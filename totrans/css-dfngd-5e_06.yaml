- en: Chapter 6\. Basic Visual Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve likely experienced the frustration of having your intended layout not
    render as expected. After adding 27 style rules to get it perfect, you still might
    not know which rule solved your problem. With a model as open and powerful as
    that contained within CSS, no book could hope to cover every possible way of combining
    properties and effects. You will undoubtedly go on to discover new ways of using
    CSS. With a thorough grasp of how the visual rendering model works, however, you’ll
    be better able to determine whether a behavior is a correct (if unexpected) consequence
    of the rendering engine CSS defines.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, CSS assumes that every element generates one or more rectangular
    boxes, called *element boxes*. (Future versions of the specification may allow
    for nonrectangular shapes, and indeed changes have been proposed, but for now
    all boxes are still rectangular.)
  prefs: []
  type: TYPE_NORMAL
- en: Each element box has a *content area* at its center. This content area is surrounded
    by optional amounts of padding, borders, outlines, and margins. These areas are
    considered optional because they could all be set to a size of 0, effectively
    removing them from the element box. [Figure 6-1](#bvf_fig01) shows an example
    content area, along with the surrounding regions of padding, borders, and margins.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0601](assets/css5_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. The content area and its surroundings
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Before looking at the properties that can alter the space taken up by elements,
    let’s cover the vocabulary needed to fully understand how elements are laid out
    and take up space.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Primer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll quickly review the kinds of boxes we’ll be discussing, as well
    as some important terms that are needed to understand the explanations to come:'
  prefs: []
  type: TYPE_NORMAL
- en: Block flow direction
  prefs: []
  type: TYPE_NORMAL
- en: Also known as the *block axis*, this is the direction along which block-level
    element boxes are stacked. In many languages, including all European and European-derived
    languages, this direction is from top to bottom. In Chinese/Japanese/Korean (CJK)
    languages, this can be either right to left or top to bottom. The actual block
    flow direction is set by the writing mode, which is discussed in [Chapter 15](ch15.html#text_properties).
  prefs: []
  type: TYPE_NORMAL
- en: Inline base direction
  prefs: []
  type: TYPE_NORMAL
- en: Also known as the *inline axis*, this is the direction along which lines of
    text are written. In Romanic languages, among others, this is left to right. In
    languages such as Arabic or Hebrew, the inline base direction is right to left.
    In CJK languages, this can be either top to bottom or left to right. As with block
    flow, the inline base direction is set by the writing mode.
  prefs: []
  type: TYPE_NORMAL
- en: Normal flow
  prefs: []
  type: TYPE_NORMAL
- en: The default system by which elements are placed inside the browser’s viewport,
    based on the parent’s writing mode. Most elements are in the normal flow, and
    the only way for an element to leave the normal flow is to be floated, positioned,
    or made into a flexible box, grid layout, or table element. The discussions in
    this chapter cover elements in the normal flow, unless otherwise stated.
  prefs: []
  type: TYPE_NORMAL
- en: Block box
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a box generated by an element such as a paragraph, heading, or `<div>`.
    These boxes generate blank spaces both before and after their boxes when in the
    normal flow so that block boxes in the normal flow stack along the block flow
    axis, one after another. Pretty much any element can be made to generate a block
    box by declaring `display: block`, though there are other ways to make elements
    generate block boxes (e.g., float them or make them flex items).'
  prefs: []
  type: TYPE_NORMAL
- en: Inline box
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a box generated by an element such as `<strong>` or `<span>`. These
    boxes are laid out along the inline base direction, and do not generate line breaks
    before or after themselves. An inline box longer than the inline size of its element
    will (by default, if it’s nonreplaced) wrap to multiple lines. Any element can
    be made to generate an inline box by declaring `display: inline`.'
  prefs: []
  type: TYPE_NORMAL
- en: Nonreplaced element
  prefs: []
  type: TYPE_NORMAL
- en: This is an element whose content is contained within the document. For example,
    a paragraph (`<p>`) is a nonreplaced element because its textual content is found
    within the element itself.
  prefs: []
  type: TYPE_NORMAL
- en: Replaced element
  prefs: []
  type: TYPE_NORMAL
- en: This is an element that serves as a placeholder for something else. The classic
    example of a replaced element is `<img>`, which simply points to an image file
    that is inserted into the document’s flow at the point where the `<img>` element
    itself is found. Most form elements are also replaced (e.g., `<input type="radio">`).
  prefs: []
  type: TYPE_NORMAL
- en: Root element
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the element at the top of the document tree. In HTML documents, this
    is the element `<html>`. In XML documents, it can be whatever the language permits:
    for example, the root element of RSS files is `<rss>`, whereas in an SVG document,
    the root element is `<svg>`.'
  prefs: []
  type: TYPE_NORMAL
- en: The Containing Block
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to examine one more kind of box in detail, and in this case enough
    detail that it merits its own section: the *containing block*.'
  prefs: []
  type: TYPE_NORMAL
- en: Every element’s box is laid out with respect to its containing block. In a very
    real way, the containing block is the *layout context* for a box. CSS defines
    a series of rules for determining a box’s containing block.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a given element, the containing block forms from the *content edge* of
    the nearest ancestor element that generates a list item or block box, which includes
    all table-related boxes (e.g., those generated by table cells). Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this simple markup, the containing block for the `<p>` element’s block box
    is the `<div>` element’s block box, as that is the closest ancestor element box
    that has a block or a list item box (in this case, it’s a block box). Similarly,
    the `<div>`’s containing block is the `<body>`’s box. Thus, the layout of the
    `<p>` is dependent on the layout of the `<div>`, which is in turn dependent on
    the layout of the `<body>` element.
  prefs: []
  type: TYPE_NORMAL
- en: And above that in the document tree, the layout of the `<body>` element is dependent
    on the layout of the `<html>` element, whose box creates what is called the *initial
    containing block*. It’s unique in that the viewport—the browser window in screen
    media, or the printable area of the page in print media—determines the dimensions
    of the initial containing block, not the size of the content of the root element.
    This matters because the content can be shorter, and usually longer, than the
    size of the viewport. Most of the time it doesn’t make a difference, but when
    it comes to things such as fixed positioning or viewport units, the difference
    is real.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand some of the terminology, we can address the properties
    that make up [Figure 6-1](#bvf_fig01). The various margin, border, and padding
    features, such as `border-style`, can be set using various side-specific longhand
    properties, such as `margin-inline-start` or `border-bottom-width`. (The outline
    properties do not have side-specific properties; a change to an outline property
    affects all four sides.)
  prefs: []
  type: TYPE_NORMAL
- en: The content’s background—a color or tiled image, for example—is applied within
    the padding and border areas by default, but this can be changed. The margins
    are always transparent, allowing the background(s) of any parent element(s) to
    be visible. Padding and borders cannot be of a negative length, but margins can.
    We’ll explore the effects of negative margins in [“Negative Margins and Collapsing”](#negative-margins-and-collapsing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Borders are most often generated using defined styles, with a `border-style`
    such as `solid`, `dotted`, or `inset`, and their colors are set using the `border-color`
    property. If no color is set, the value defaults to `currentcolor`. Borders can
    also be generated from images. If a border style has gaps of some type, as with
    `border-style: dashed` or with a border generated from a partially transparent
    image, then the element’s background is visible through those gaps by default,
    though it is possible to clip the background to stay inside the border (or the
    padding).'
  prefs: []
  type: TYPE_NORMAL
- en: Altering Element Display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can affect the way a user agent displays by setting a value for the `display`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to ignore the `ruby`- and `table`-related values, since they’re
    far too complex for this chapter. We’ll also temporarily ignore the value `list-item`,
    since it’s very similar to block boxes and is explored in detail in [Chapter 16](ch16.html#lists-and-generated-content).
    For now, we’ll spend a moment talking about how altering an element’s display
    role can alter layout.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to styling a document, it’s sometimes handy to be able to change
    the type of box an element generates. For example, suppose we have a series of
    links in a `<nav>` that we’d like to lay out as a vertical sidebar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the links will generate inline boxes, and thus get sort of mushed
    together into what looks like a short paragraph of nothing but links. We could
    put all the links into their own paragraphs or list items, or we could just make
    them all block-level elements, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will make every `<a>` element within the navigation element `<nav>` generate
    a block box, instead of its usual inline box. If we add on a few more styles,
    we could have a result like that shown in [Figure 6-2](#bvf_fig02).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0602](assets/css5_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Changing the display role from inline to block
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Changing display roles can be useful when you want the navigation links to be
    inline elements if the CSS isn’t available (perhaps by failing to load), but to
    lay out the same links as block-level elements in CSS-aware contexts. You could
    also present the links as inline on desktop displays and block on mobile devices,
    or vice versa. With the links laid out as blocks, you can style them as you would
    `<div>` or `<p>` elements, with the advantage that the entire element box becomes
    part of the link.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also want to take elements and make them inline. Suppose we have an
    unordered list of names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this markup, say we want our display to show a series of inline names
    with vertical bars between them (and on each end of the list). The only way to
    do so is to change their display role. The following rules will have the effect
    shown in [Figure 6-3](#bvf_fig03):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0603](assets/css5_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. Changing the display role from `list-item` to `inline`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understand that you are, for the most part, changing the display role of elements—not
    changing their inherent nature. In other words, causing a paragraph to generate
    an inline box does *not* turn that paragraph into an inline element. In HTML,
    for example, some elements are block while others are inline. While a `<span>`
    can easily be placed inside a paragraph, a `<span>` should not be wrapped around
    a paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: We say “for the most part” because while CSS mostly impacts presentation and
    not content, CSS properties can impact accessibility in more ways than just color
    contrast. For example, changing the `display` value can impact the way an element
    is perceived by assistive technologies. Setting an element’s `display` property
    to `none` removes the element from the accessibility tree. Setting the `display`
    property on a `<table>` to `grid` may cause the table to be interpreted as something
    other than a data table, removing normal table keyboard navigation, and making
    the table inaccessible as a data table to screen-reader users. (This shouldn’t
    happen, but it does in some browsers.)
  prefs: []
  type: TYPE_NORMAL
- en: This can be mitigated by setting the Accessible Rich Internet Applications (ARIA)
    `role` attribute for the table and all its descendants. However, in general, anytime
    a change you make in CSS forces you to make changes in ARIA roles, you should
    take a moment to consider whether there isn’t a better way to accomplish your
    goal.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Block Boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Block boxes behave in predictable, yet sometimes surprising, ways. The handling
    of box placement along the block and inline axes can differ, for example. To fully
    understand how block boxes are handled, you must clearly understand several aspects
    of these boxes. They are shown in detail in [Figure 6-4](#css5_07box), which illustrates
    placement in two different writing modes.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0604](assets/css5_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. The complete box model in two different writing modes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As shown in [Figure 6-4](#css5_07box), CSS deals with the block directions and
    inline directions, as well as block sizes and inline sizes. Block and inline sizes
    are descriptions of the size of the content area (by default) along the block
    and inline axes.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the *width* (sometimes referred to as the *physical width*) of
    a block box is defined as the distance between the inner edges of the content
    area (again, by default) along the horizontal axis (left to right), regardless
    of the writing direction, and the *height* (*physical height*) is the distance
    along the vertical axis (top to bottom). Properties are available to set all these
    sizes, which we’ll talk about shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Something important to note in [Figure 6-4](#css5_07box) is the use of *start* and
    *end* to describe various parts of the element box. For example, you’ll see a
    block-start margin and a block-end margin. The *start edge* is the edge that you
    come to first as you move along an axis.
  prefs: []
  type: TYPE_NORMAL
- en: This may be clearer if you look at [Figure 6-5](#css5_07block-inline-axes) and
    trace your finger along each axis from arrow tail to tip. As you move along a
    block axis, the first edge you come to for each element is that element’s block-start
    edge. As you pass out of the element, you move through the block-end edges. Similarly,
    as you move along an inline axis, you go through the inline-start edges, across
    the inline dimension of the content, and then out the inline-end edges. Try it
    for each of the three examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0605](assets/css5_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. The block- and inline-axis directions for three common writing
    modes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Logical Element Sizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because CSS recognizes block and inline axes for elements, it provides properties
    that let you set an explicit element size along each axis.
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties allow you to set the size of an element along its block axis,
    or to constrain the lengths of lines of text along the inline axis, regardless
    of the direction of text flow. If you write `block-size: 500px`, the element’s
    block size will be 500 pixels wide, even if that leads to content spilling out
    of the element box. (We’ll discuss that in more detail later in the chapter.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following, which has the results shown in [Figure 6-6](#sizing-elements-inline-axis)
    when applied in various writing modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0606](assets/css5_0606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6\. Sizing elements along their inline axis
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As seen in [Figure 6-6](#sizing-elements-inline-axis), the elements are sized
    consistently along their inline axis, regardless of the writing direction. If
    you tilt your head to the side, you can see that the lines wrap in exactly the
    same places. This yields a consistent line length across all writing modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can set a block size for elements. This is used a bit more often
    for replaced elements like images, but it can be used in any circumstance that
    makes sense. Take this as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Having done that, any `<img>` element found inside a `<p>` element will have
    its block size set to one and a half times the size of the surrounding text. (This
    works on images because they’re inline replaced elements; it wouldn’t work on
    inline nonreplaced elements.) You could also use `block-size` to constrain the
    block length of grid layout items to be a minimum or maximum size, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It should be said that usually block size is determined automatically, because
    elements in the normal flow often don’t have an explicitly set block size. For
    example, if an element’s block flow is top to bottom and it’s 8 lines long, and
    each line is 1/8th of an inch tall, then its block size will be 1 inch. If it’s
    10 lines tall, the block size is instead 1.25 inches. In either case, as long
    as `block-size` is `auto`, the block size is determined by the content of the
    element, not by the author. This is usually what you want, particularly for elements
    containing text. When `block-size` is explicitly set and there isn’t enough content
    to fill the box, empty space will appear inside the box; if there is more content
    than can fit, the content may overflow the box or scrollbars may appear.
  prefs: []
  type: TYPE_NORMAL
- en: Content-Based Sizing Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond the lengths and percentages you saw previously for setting block and
    inline sizes, a few keywords provide content-based sizing:'
  prefs: []
  type: TYPE_NORMAL
- en: '`max-content`'
  prefs: []
  type: TYPE_NORMAL
- en: Take up the most space possible to fit in the content, even suppressing line
    wrapping in the case of text content.
  prefs: []
  type: TYPE_NORMAL
- en: '`min-content`'
  prefs: []
  type: TYPE_NORMAL
- en: Take up the least space possible to fit in the content.
  prefs: []
  type: TYPE_NORMAL
- en: '`fit-content`'
  prefs: []
  type: TYPE_NORMAL
- en: Take up the amount of space determined by calculating the values of `max-content`,
    `min-content`, and regular content sizing, taking the maximum of `min-content`
    and regular sizing, and then taking the minimum of `max-content` and whichever
    value was the greater of `min-content` and regular sizing. Yes, that all sounds
    a bit confusing, but we’ll explain it in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve worked at all with CSS Grid (covered in [Chapter 12](ch12.html#grid-layout)),
    you may recognize these keywords, as they were originally defined as ways to size
    grid items. Now they’re making their way into other areas of CSS. Let’s consider
    the first two keywords, which are demonstrated in [Figure 6-7](#content-sizing).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0607](assets/css5_0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7\. Content sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The paragraph on the left is set to `max-content`, and that’s what happens:
    the paragraph is made as wide as needed to fit all of the content. It’s as narrow
    as it is only because there isn’t much content. Had we added another three sentences,
    the single line of text would have just kept going and going with no line wrapping,
    even if it ran right off the page (or out of the browser window).'
  prefs: []
  type: TYPE_NORMAL
- en: In the paragraph on the right, the content is as narrow as possible without
    forcing breaks or hyphens inside words. In this particular case, the element is
    *just* wide enough to fit the word “paragraph,” which is the longest word in the
    content. For every other line of text in the example, the browser places as many
    words as will fit into the space needed for “paragraph,” and goes to the next
    line when it runs out of room. If we added “antidisestablishmentarianism” to the
    text, the element would become just wide enough to fit *that* word, and every
    other line of text would very likely contain multiple words.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, at the end of the `min-content` example in [Figure 6-7](#content-sizing),
    the browser took advantage of the presence of the hyphen in `min-content` to trigger
    a line wrap there. Had it not made that choice, `min-content` would almost certainly
    have been the longest piece of content in the paragraph, and the element’s width
    would have been set to that length. This means that if your content contains symbols
    that browsers understand to be natural line-wrapping points (e.g., spaces and
    hyphens), they’ll likely be considered in the `min-content` calculations. If you
    want to squeeze the element width even further, you can enable auto-hyphenating
    of words with the `hyphens` property (see [Chapter 15](ch15.html#text_properties)).
  prefs: []
  type: TYPE_NORMAL
- en: For some more examples of `min-content` sizing, see [Figure 6-8](#minimum-content-sizing).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0608](assets/css5_0608.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-8\. Minimum content sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The third keyword, `fit-content`, is interesting in that it does its best to
    fit the element to the content. What that means in practice is that if you have
    only a little content, the element’s inline size (usually its width) will be just
    big enough to enclose it, as if `max-content` were used. If there’s enough content
    to wrap to multiple lines or otherwise threaten to overflow the element’s container,
    the inline size stops there. This is illustrated in [Figure 6-9](#fit-content-sizing).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0609](assets/css5_0609.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-9\. Fit-content sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In each case, the element is fit to the content without overspilling the element’s
    container. At least, that’s what happens with elements in the normal flow. The
    behavior can be quite different in flexbox and grid contexts, and is further explored
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum and Maximum Logical Sizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’d like to set minimum and maximum bounds on block or inline sizes, CSS
    has some properties to help you out.
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties can be very useful when you know you want upper and lower
    bounds on the sizing of an element’s box, and are willing to allow the browser
    to do whatever it wants as long as it obeys those restrictions. As an example,
    you might set part of a layout like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That keeps the `<main>` element from getting any narrower than the widest bit
    of inline content, whether that’s a long word or an illustration or something
    else. It also keeps the `<main>` element from getting any wider than around 75
    characters, thus keeping line lengths to a readable amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to set bounds on block sizing. A good example is limiting
    any image embedded in the normal flow to be its intrinsic size up to a certain
    point. The following CSS would have the effects shown in [Figure 6-10](#maximum-block-sizing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0610](assets/css5_0610.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-10\. Maximum block sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Height and Width
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve used CSS for a while or are maintaining legacy code, you’re probably
    used to thinking of “top margin” and “bottom margin.” That’s because, originally,
    all box model aspects were described in terms of their physical directions: top,
    right, bottom, and left. You can still work with the physical directions! CSS
    has simply added new directions to the mix.'
  prefs: []
  type: TYPE_NORMAL
- en: If you were to change `inline-size` to `width` in the previous code example,
    you’d get a result more like that shown in [Figure 6-11](#sizing-elements-width)
    (in which the vertical writing modes are clipped off well short of their full
    height).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0611](assets/css5_0611.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-11\. Sizing elements’ width
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These elements are made `40ch` wide horizontally, regardless of their writing
    mode. Each element’s height has been automatically determined by the content,
    the specifics of the writing mode, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use block and inline properties like `block-size` instead of physical
    directions like `height`, and your design is applied to content translated to
    other languages, the layout will automatically adjust to your intentions.
  prefs: []
  type: TYPE_NORMAL
- en: The `height` and `width` properties are known as *physical properties*. They
    refer to physical directions, as opposed to the writing-dependent directions of
    block size and inline size. Thus, `height` really does refer to the distance from
    the top to the bottom of the element’s inner edge, regardless of the direction
    of the block axis.
  prefs: []
  type: TYPE_NORMAL
- en: In writing with a horizontal inline axis, such as English or Arabic, if both
    `inline-size` and `width` are set on the same element, the one declared later
    will take precedence over the first one declared. The same is true if `block-size`
    and `height` are both declared; if origin, layer, and specificity are the same,
    the one declared last takes precedence. In vertical writing modes, `inline-size`
    corresponds to `height`, and `block-size` to `width`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting a block box’s height or width as a <*`length`*> means it will be that
    length tall or wide, regardless of the content within it. If you set an element
    that generates a block box to `width: 200px`, it will be 200 pixels wide, even
    if it has a 500-pixel-wide image inside it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the value of `width` to a <*`percentage`*> means the width of the element
    will be that percentage of its containing block’s width. If you set a paragraph
    to `width: 50%` and its containing block is 1,024 pixels wide, then the paragraph’s
    `width` will be computed to 512 pixels.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting `height` to a <*`percentage`*> works similarly, except this works only
    if the containing block has an explicitly set height. If the containing block’s
    height is automatically set, a percentage value is treated as `auto` instead,
    as seen in the `#cb4` example in [Figure 6-12](#heights-and-widths).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The handling of `auto` top and bottom margins is different for positioned elements,
    as well as flexible-box and grid elements. The differences are covered in Chapters
    [11](ch11.html#flexbox) and [12](ch12.html#grid-layout).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of these values and combinations, with the result shown
    in [Figure 6-12](#heights-and-widths):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0612](assets/css5_0612.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-12\. Heights and widths
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also use `max-content` and `min-content` with the `height` property,
    but in top-to-bottom block flows, both are the same as `height: auto`. In writing
    modes using a horizontal block axis, setting these values for `height` will have
    similar effects as setting them for `width` in vertical block flows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, these properties don’t apply to inline nonreplaced elements. For
    example, if you try to declare a `height` and `width` for a hyperlink that’s in
    the normal flow and generates an inline box, CSS-conformant browsers *must* ignore
    those declarations. Assume the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You’ll end up with red unvisited links on silver backgrounds whose height and
    width are determined by the content of the links. The links will *not* have content
    areas that are 15 pixels tall by 60 pixels wide, as these must be ignored when
    applied to inline nonreplaced elements. If, on the other hand, you add a `display`
    value, such as `inline-block` or `block`, then `height` and `width` *will* set
    the height and width of the links’ content areas.
  prefs: []
  type: TYPE_NORMAL
- en: Altering Box Sizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If it seems a little weird to use `height` and `width` (and `block-size` and
    `inline-size`) to describe the sizing of the element’s content area instead of
    its visible area, you can make that sizing more intuitive by using the property
    `box-sizing`.
  prefs: []
  type: TYPE_NORMAL
- en: This property changes what the values of the `height`, `width`, `block-size`,
    and `inline-size` properties do.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you declare `inline-size: 400px` and don’t declare a value for `box-sizing`,
    the element’s content area will be 400 pixels in the inline direction, and any
    padding, borders, and so on will be added to that. If, on the other hand, you
    declare `box-sizing: border-box`, the element box will be 400 pixels from the
    inline-start border edge to the inline-end border edge; any inline-start or -end
    border or padding will be placed within that distance, thus shrinking the inline
    size of the content area. This is illustrated in [Figure 6-13](#bvf_fig05).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0613](assets/css5_0613.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-13\. The effects of `box-sizing`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Put another way, if you declare `width: 400px` and don’t declare a value for
    `box-sizing`, the element’s content area will be 400 pixels wide, and any padding,
    borders, and so on will be added to that. If, on the other hand, you declare `box-sizing:
    border-box`, the element box will be 400 pixels from the left outer border edge
    to the right outer border edge; any left or right border or padding will be placed
    within that distance, thus shrinking the width of the content area (again, as
    seen in [Figure 6-13](#bvf_fig05)).'
  prefs: []
  type: TYPE_NORMAL
- en: We’re talking about the `box-sizing` property here because, as stated, it applies
    to “all elements that accept `width` or `height` values” (because it was defined
    before logical properties were commonplace). That’s most often elements generating
    block boxes, though it also applies to replaced inline elements like images, as
    well as inline-block boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Having established how to size elements in both logical and physical ways, let’s
    widen our scope and look at all the properties that affect block sizing.
  prefs: []
  type: TYPE_NORMAL
- en: Block-Axis Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In total, block-axis formatting is affected by seven related properties: `margin-block-start`,
    `border-block-start`, `padding-block-start`, `height`, `padding-block-end`, `border-block-end`,
    and `margin-block-end`. These properties are diagrammed in [Figure 6-14](#bvf_fig20).
    These properties are all covered in detail in [Chapter 7](ch07.html#padding-borders-outlines-and-margins);
    here, we will talk about the general principles and behavior of these properties
    before looking at the details of their values.'
  prefs: []
  type: TYPE_NORMAL
- en: The block-start and -end padding and borders must be set to specific values,
    or else they default to a width of 0, assuming no border style is declared. If
    `border-style` has been set, the thickness of the borders is set to `medium`,
    which is 3 pixels wide in all known browsers. [Figure 6-14](#bvf_fig20) depicts
    the block-axis formatting properties in two writing modes and indicates which
    parts of the box may have a value of `auto` and which may not.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0614](assets/css5_0614.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-14\. The seven properties of block-axis formatting, and which can be
    set to `auto`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Interestingly, if either `margin-block-start` or `margin-block-end` is set to
    `auto` for a block box in the normal flow, but not both, they both evaluate to
    `0`. A value of `0`, unfortunately, prevents easy block-direction centering of
    normal-flow boxes in their containing blocks (though such centering is fairly
    straightforward in flexbox or grid layout).
  prefs: []
  type: TYPE_NORMAL
- en: The `block-size` property must be set to `auto` or to a nonnegative value of
    some type; it can never be less than 0.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Block Sizing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the simplest case, a normal-flow block box with `block-size: auto` is rendered
    just tall enough to enclose the line boxes of its inline content (including text).
    If an auto-block-size, normal-flow block box has only block-level children and
    has no block-edge padding or borders, the distance from its first child’s border-start
    edge to its last child’s border-end edge will be the box’s block size. This is
    the case because the margins of the child elements can “stick out” of the element
    that contains them thanks to what’s known as *margin collapsing*, which we’ll
    talk about in [“Collapsing Block-Axis Margins”](#collapsing-block-axis-margins).'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if a block-level element has either block-start or -end padding, or
    block-start and -end borders, its block size will be the distance from the block-start
    margin edge of its first child to the block-end margin edge of its last child:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 6-15](#bvf_fig23) demonstrates both of these behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we changed the borders in the previous example to be padding instead, the
    effect on the block size of the `<div>` would be the same: it would still enclose
    the paragraph’s margins within it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0615](assets/css5_0615.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-15\. Auto block sizes with block-level children
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Percentage Heights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You saw earlier how length-value block sizes are handled, so let’s spend a
    moment on percentages. If the block size of a normal-flow block box is set to
    a percentage value, that value is taken as a percentage of the block size of the
    box’s containing block, assuming the container has an explicit, non-`auto` block
    size of its own. Given the following markup, the paragraph will be 3 em long along
    the block axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the block size of the containing block is *not* explicitly declared, percentage
    block sizes are reset to `auto`. If we change the previous example so that the
    `block-size` of the `<div>` is `auto`, the paragraph will now have its block size
    determined automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 6-16](#bvf_fig22) illustrates these two possibilities. (The spaces
    between the paragraph borders and the `<div>` borders are the block-start and
    -end margins on the paragraphs.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0616](assets/css5_0616.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-16\. Percentage block sizes in different circumstances
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Before we move on, take a closer look at the first example in [Figure 6-16](#bvf_fig22),
    the half-as-tall paragraph. It may be half as tall, but it isn’t centered along
    the block axis. That’s because the containing `<div>` is 6 em tall, which means
    the half-as-tall paragraph is 3 em tall. It has block-start and -end margins of
    1 em thanks to the browser’s default styles, so its overall block size is 5 em.
    That means there is actually 2 em of space between the block end of the paragraph’s
    visible box and the `<div>`’s block-end border, not 1 em. [Figure 6-17](#block-axis-sizing-placement-in-detail)
    illustrates this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0617](assets/css5_0617.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-17\. Block-axis sizing and placement in detail
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Handling Content Overflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given that it’s possible to set elements to specific sizes, it becomes possible
    to make an element too small for its content to fit inside. This is more likely
    to arise if block sizes are explicitly defined, but it can also happen with inline
    sizes, as you’ll see in later sections. If this sort of thing does happen, you
    can exert some control over the situation with the `overflow` shorthand property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value of `visible` means that the element’s content may be visible
    outside the element’s box. Typically, this leads to the content running outside
    its own element box, but not altering the shape of that box. The following markup
    would result in [Figure 6-18](#overflow_methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If `overflow` is set to `hidden`, the element’s content is clipped at the edges
    of the element box. With the `hidden` value, there is no way to get at the parts
    of the content that are clipped off.
  prefs: []
  type: TYPE_NORMAL
- en: If `overflow` is set to `clip`, the element’s content is also clipped—that is,
    hidden—at the edges of the element box, with no way to get at the parts that are
    clipped off.
  prefs: []
  type: TYPE_NORMAL
- en: If `overflow` is set to `scroll`, the overflowing content is clipped, but the
    content can be made available to the user via scrolling methods, including a scrollbar
    (or set of them). [Figure 6-18](#overflow_methods) depicts one possibility.
  prefs: []
  type: TYPE_NORMAL
- en: If `scroll` is used, the panning mechanisms (e.g., scrollbars) should always
    be rendered. To quote the specification, “this avoids any problem with scrollbars
    appearing or disappearing in a dynamic environment.” Thus, even if the element
    has sufficient space to display all its content, the scrollbars may still appear
    and take up space (though they may not).
  prefs: []
  type: TYPE_NORMAL
- en: In addition, when printing a page or otherwise displaying the document in a
    print medium, the content may be displayed as though the value of `overflow` were
    declared to be `visible`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-18](#overflow_methods) illustrates these `overflow` values, with
    two of them combined in a single example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0618](assets/css5_0618.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-18\. Methods for handling overflowing content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, `overflow: auto` allows user agents to determine which of the previously
    described behaviors to use, although user agents are encouraged to provide a scrolling
    mechanism whenever necessary. This is a potentially useful way to use overflow,
    since user agents could interpret it to mean “provide scrollbars only when needed.”
    (They may not, but generally do.)'
  prefs: []
  type: TYPE_NORMAL
- en: Single-axis overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two properties make up the `overflow` shorthand. You can define the overflow
    behavior along the *x* (horizontal) and *y* (vertical) directions separately,
    either by setting them both in `overflow`, or by using the `overflow-x` and `overflow-y`
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'By setting the overflow behavior separately along each axis, you’re essentially
    deciding where scrollbars will appear and where they won’t. Consider the following,
    which is rendered in [Figure 6-19](#overflow_x_y):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0619](assets/css5_0619.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-19\. Setting overflow separately for x- and y-axes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the first case, an empty scrollbar is set up for the x-axis (horizontal),
    but none for the y-axis (vertical), even though the content overflowed along the
    y-axis. This is the worst of both worlds: a scrollbar that’s empty because it
    isn’t needed, and no scrollbar where it is needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second case is the much more useful inverse: no scrollbar is set along
    the x-axis, but one is available for the y-axis, so the overflowed content can
    be accessed by means of scrolling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third case, `scroll` is set for both axes, so access to the overflowing
    content is available via scrolling, but we also have an unnecessary scrollbar
    (which is empty) for the x-axis. This is equivalent to simply declaring `overflow:
    scroll`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the true nature of `overflow`: it’s a shorthand property
    that brings `overflow-x` and `overflow-y` together under one roof. The following
    is exactly equivalent to the previous example and will have the same result shown
    in [Figure 6-19](#overflow_x_y):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you see, you can give `overflow` two keywords, which are always in the order
    *x*, then *y*. If only one value is given, it’s used for both the x- and y-axes.
    This is why `scroll` and `scroll scroll` are the same thing as values of `overflow`.
    Similarly, `hidden` would be the same as saying `hidden hidden`.
  prefs: []
  type: TYPE_NORMAL
- en: Negative Margins and Collapsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Believe it or not, negative margins are possible. The base effect is to move
    the margin edge inward toward the center of the element’s box. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we see in [Figure 6-20](#bvf_fig28), the paragraph has been pulled upward
    by its negative block-start margin. Note that the content of the `<div>` that
    follows the paragraph in the markup has also been pulled up the block axis by
    50 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0620](assets/css5_0620.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-20\. The effects of a negative block-start margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now compare the following markup to the situation shown in [Figure 6-21](#bvf_fig29):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0621](assets/css5_0621.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-21\. The effects of a negative block-end margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What’s happening? The elements following the `<div>` are placed according to
    the location of the block-end margin edge of the `<div>`, which is 50 pixels higher
    than it would be without the negative margin. As [Figure 6-21](#bvf_fig29) shows,
    the block-end of the `<div>` is actually *above* the visual block-end of its child
    paragraph. The next element after the `<div>` is the appropriate distance from
    the block-end of the `<div>`.
  prefs: []
  type: TYPE_NORMAL
- en: Collapsing Block-Axis Margins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important aspect of block-axis formatting is the *collapsing* of adjacent
    margins, which is a way of comparing adjacent margins in the block direction,
    and then using only the largest of those margins to set the distance between the
    adjacent block elements. Note that collapsing behavior applies only to margins.
    Padding and borders never collapse.
  prefs: []
  type: TYPE_NORMAL
- en: 'An unordered list, with list items that follow one another along the block
    axis, is a perfect environment for studying margin collapsing. Assume that the
    following is declared for a list that contains three items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Each list item has a 10-pixel block-start margin and a 15-pixel block-end margin.
    When the list is rendered, however, the visible distance between adjacent list
    items is 15 pixels, not 25\. This happens because, along the block axis, adjacent
    margins are collapsed. In other words, the smaller of the two margins is eliminated
    in favor of the larger. [Figure 6-22](#bvf_fig24) shows the difference between
    collapsed and uncollapsed margins.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0622](assets/css5_0622.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-22\. Collapsed versus uncollapsed margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: User agents will collapse block-adjacent margins as shown in the first list
    in [Figure 6-22](#bvf_fig24), so that 15-pixel spaces appear between each list
    item. The second list shows what happens if browsers don’t collapse margins, resulting
    in 25-pixel spaces between list items.
  prefs: []
  type: TYPE_NORMAL
- en: Another word to use, if you don’t like “collapse,” is “overlap.” Although the
    margins are not really overlapping, you can visualize what’s happening by using
    the following analogy.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that each element, such as a paragraph, is a small piece of paper with
    the content of the element written on it. Around each piece of paper is a certain
    amount of clear plastic, which represents the margins. The first piece of paper
    (say an `<h1>` piece) is laid down on the canvas. The second (a paragraph) is
    laid below it along the block axis and then slid upward along that axis until
    the edge of one piece’s plastic touches the edge of the other’s paper. If the
    first piece of paper has half an inch of plastic along its block-end edge, and
    the second has a third of an inch along its block-start, then when they slide
    together, the first piece’s block-end plastic will touch the block-start edge
    of the second piece of paper. The two are now done being placed on the canvas,
    and the plastic attached to the pieces is overlapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Collapsing also occurs where multiple margins meet, such as at the end of a
    list. Adding to the earlier example, let’s assume the following rules apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The last item in the list has a block-end margin of 20 pixels, the block-end
    margin of the `<ul>` is 15 pixels, and the block-start margin of a succeeding
    `<h1>` is 28 pixels. So once the margins have been collapsed, the distance between
    the end of the last `<li>` in the list and the beginning of the `<h1>` is 28 pixels,
    as shown in [Figure 6-23](#bvf_fig25).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0623](assets/css5_0623.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-23\. Collapsing in detail
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you add a border or padding to a containing block, this causes the margins
    of its child elements to be entirely contained within it. We can see this behavior
    in operation by adding a border to the `<ul>` element in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With this change, the block-end margin of the `<li>` element is now placed inside
    its parent element (the `<ul>`). Therefore, the only margin collapsing that takes
    place is between the `<ul>` and the `<h1>`, as illustrated in [Figure 6-24](#bvf_fig26).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0624](assets/css5_0624.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-24\. Collapsing (or not) with borders added to the mix
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Negative margin collapsing is slightly different. When a negative margin participates
    in margin collapsing, the browser takes the absolute value of the negative margin
    and subtracts it from any adjacent positive margins. In other words, the negative
    length is added to the positive length(s), and the resulting value is the distance
    between the elements, even if that distance is a negative length. [Figure 6-25](#bvf_fig27)
    provides some concrete examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0625](assets/css5_0625.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-25\. Examples of negative block-axis margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now let’s consider an example where the margins of a list item, an unordered
    list, and a paragraph are all collapsed. In this case, the unordered list and
    paragraph are assigned negative margins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The negative margin of the greatest magnitude (`-18px`) is added to the largest
    positive margin (`20px`), yielding `20px` – `18px` = `2px`. Thus, we have only
    2 pixels between the block-end of the list item’s content and the block-start
    of the `<h1>`’s content, as we can see in [Figure 6-26](#bvf_fig30).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0626](assets/css5_0626.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-26\. Collapsing margins and negative margins, in detail
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When elements overlap each other because of negative margins, it’s hard to tell
    which elements are on top of others. You may also have noticed that very few of
    the examples in this section use background colors. If they did, the background
    color of a following element might overwrite the content of a preceding element.
    This is expected behavior, since browsers usually render elements in order from
    beginning to end, so a normal-flow element that comes later in the document can
    generally be expected to overwrite an earlier element, assuming the two end up
    overlapping.
  prefs: []
  type: TYPE_NORMAL
- en: Inline-Axis Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Laying out elements along the inline axis can be more complex than you’d think.
    Part of the complexity has to do with the default behavior of `box-sizing`. With
    the default value of `content-box`, the value given for `inline-size` affects
    the inline width of the content area, *not* the entire visible element box. Consider
    the following example, where the inline axis runs left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the paragraph’s content area 200 pixels wide. If we give the element
    a background, this will be quite obvious. However, any padding, borders, or margins
    you specify are *added* to the width value. Suppose we do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The visible element box is now 220 pixels in inline size, since we’ve added
    10 pixels of padding to every side of the content. The margins will now extend
    another 20 pixels to both inline sides for an overall element inline size of 260
    pixels. This is illustrated in [Figure 6-27](#bvf_fig06).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0627](assets/css5_0627.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-27\. Additive padding and margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we change the styles to use `box-sizing: border-box`, the results will be
    different. In that case, the visible box will be 200 pixels wide along the inline
    axis with a content inline size of 180 pixels, and a total of 40 pixels of margin
    on the inline sides, giving an overall box inline size of 240 pixels, as illustrated
    in [Figure 6-28](#bvf_fig07).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0628](assets/css5_0628.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-28\. Subtractive padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In either case, the CSS specification has a rule that says the sum of the inline
    components of a block box in the normal flow always equals the inline size of
    the containing block (which is why, as you’ll see in just a bit, `margin: auto`
    centers content in the inline direction). Let’s consider two paragraphs within
    a `<div>` whose margins have been set to `1em`, and whose `box-sizing` value is
    the default `content-box`. The content size (the value of `inline-size`) of each
    paragraph in this example, plus its inline-start and -end padding, borders, and
    margins, will always add up to the inline size of the `<div>`’s content area.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say the inline size of the `<div>` is `30em`. That makes the sum total
    of the content size, padding, borders, and margins of each paragraph 30 em. In
    [Figure 6-29](#bvf_fig08), the “blank” space around the paragraphs is actually
    their margins. If the `<div>` had any padding, even more blank space would be
    present, but that isn’t the case here.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0629](assets/css5_0629.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-29\. Element boxes are as wide as the inline width of their containing
    block
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Inline-Axis Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The seven properties of inline formatting—`margin-inline-start`, `border-inline-start`,
    `padding-inline-start`, `inline-size`, `padding-inline-end`, `padding-inline-end`,
    and `padding-inline-end`—are diagrammed in [Figure 6-30](#bvf_fig09).
  prefs: []
  type: TYPE_NORMAL
- en: The values of these seven properties must add up to the inline size of the element’s
    containing block, which is usually the value of `inline-size` for a block element’s
    parent (since block-level elements nearly always have block-level elements for
    parents).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of these seven properties, only three may be set to `auto`: the inline size
    of the element’s content, and the inline-start and -end margins. The remaining
    properties must either be set to specific values or default to a width of 0\.
    [Figure 6-30](#bvf_fig09) shows which parts of the box can take a value of `auto`
    and which cannot. (That said, CSS is forgiving: if any part that can’t accept
    `auto` is erroneously set to `auto`, it will default to `0`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0630](assets/css5_0630.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-30\. The seven properties of inline-axis formatting, and which can
    be set to `auto`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `inline-size` property must either be set to `auto` or a nonnegative value.
    When you do use `auto` in inline-axis formatting, different effects can occur.
  prefs: []
  type: TYPE_NORMAL
- en: Using auto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In certain situations, it makes a lot of sense to explicitly set one or more
    of the inline margins and size to `auto`. By default, the two inline margins are
    set to `0`, and the inline size is set to `auto`. Let’s explore how moving the
    `auto` around can have different effects, and why.
  prefs: []
  type: TYPE_NORMAL
- en: Only one auto
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you set one of `inline-size`, `margin-inline-start`, or `margin-inline-end`
    to a value of `auto`, and give the other two properties specific values, then
    the property that is set to `auto` is set to the length required to make the element
    box’s overall inline size equal to the parent element’s content inline size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say the sum of the seven inline-axis properties must equal 500 pixels,
    no padding or borders are set, the inline-end margin and inline size are set to
    `100px`, and the inline-start margin is set to `auto`. The inline-start margin
    will thus be 300 pixels wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In a sense, `auto` can be used to make up the difference between everything
    else and the required total. However, what if all three of these properties (both
    inline margins and the inline size) are set to `100px` and *none* of them are
    set to `auto`?
  prefs: []
  type: TYPE_NORMAL
- en: 'If all three properties are set to something other than `auto`—or, in CSS parlance,
    when these formatting properties have been *overconstrained*—then the margin at
    the inline end is *always* forced to be `auto`. This means that if both inline
    margins and the inline size are set to `100px`, the user agent will reset the
    inline-end margin to `auto`. The inline-end margin’s width will then be set according
    to the rule that one `auto` value “fills in” the distance needed to make the element’s
    overall inline size equal to that of its containing block’s content inline size.
    [Figure 6-31](#bvf_fig11) shows the result of the following markup in left-to-right
    languages like English:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0631](assets/css5_0631.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-31\. Overriding the inline-end margin’s value
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If both side margins are set explicitly, and `inline-size` is set to `auto`,
    then `inline-size` will be whatever value is needed to reach the required total
    (which is the content inline size of the parent element). The results of the following
    markup are shown in [Figure 6-32](#bvf_fig12):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of formatting is the most common, since it is equivalent to setting
    the margins and not declaring anything for the `inline-size`. The result of the
    following markup is exactly the same as that shown in [Figure 6-32](#bvf_fig12):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0632](assets/css5_0632.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-32\. Automatic inline sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might be wondering what happens if `box-sizing` is set to `padding-box`.
    In that case, all the same principles described here apply, which is why this
    section discussed only `inline-size` and the inline-side margins without introducing
    any padding or borders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the handling of `inline-size: auto` in this section and the
    following sections is the same regardless of the value of `box-sizing`. The details
    of what gets placed where inside the `box-sizing`-defined box may vary, but the
    treatment of `auto` values does not, because `box-sizing` determines what `inline-size`
    refers to, not how it behaves in relation to the margins.'
  prefs: []
  type: TYPE_NORMAL
- en: More than one auto
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now let’s see what happens when two of the three properties (`inline-size`,
    `margin-inline-start`, and `margin-inline-end`) are set to `auto`. If both margins
    are set to `auto` but the `inline-size` is set to a specific length, then both
    margins are set to equal lengths, thus centering the element within its parent
    along the inline axis. The following code creates this layout, illustrated in
    [Figure 6-33](#bvf_fig13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0633](assets/css5_0633.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-33\. Setting an explicit inline size
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another way of sizing elements along the inline axis is to set one of the inline
    margins and `inline-size` to `auto`. In this case, the margin set to `auto` is
    reduced to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `inline-size` property is then set to the value necessary to make the element
    fill its containing block; in the preceding example, it would be 400 pixels, as
    shown in [Figure 6-34](#bvf_fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0634](assets/css5_0634.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-34\. What happens when both `inline-size` and the inline-start margin
    are `auto`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Too many autos
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, what happens when all three properties are set to `auto`? The answer:
    both margins are set to 0, and the `inline-size` is made as wide as possible.
    This result is the same as the default situation, when no values are explicitly
    declared for margins or the inline size. In such a case, the margins default to
    0 and `inline-size` defaults to `auto`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that since inline margins do not collapse (unlike block margins, as discussed
    earlier), the padding, borders, and margins of a parent element can affect the
    inline layout of its children. The effect is indirect in that the margins (and
    so on) of an element can induce an offset for child elements. The results of the
    following markup are shown in [Figure 6-35](#bvf_fig15):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0635](assets/css5_0635.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-35\. Offset is implicit in the parent’s margins and padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Negative Margins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen with block-axis margins, it’s possible to set negative values
    for inline-axis margins. Setting negative inline margins can result in some interesting
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the total of the seven inline-axis properties always equals the
    inline size of the content area of the parent element. As long as all inline properties
    are 0 or greater, an element’s inline size can never be greater than its parent’s
    content area inline size. However, consider the following markup, depicted in
    [Figure 6-36](#bvf_fig16):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0636](assets/css5_0636.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-36\. Wider children through negative margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Yes indeed, the child element is wider than its parent along the inline axis!
    This is mathematically correct. Let’s solve for inline size:'
  prefs: []
  type: TYPE_NORMAL
- en: 10 px + 0 + 0 + 540 px + 0 + 0 – 50 px = 500 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `540px` is the evaluation of `inline-size: auto`, which is the number needed
    to balance out the rest of the values in the equation. Even though it leads to
    a child element sticking out of its parent, it all works because the values of
    the seven properties add up to the required total.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s add some borders to the mix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting change will be a reduction in the evaluated width of `inline-size`:'
  prefs: []
  type: TYPE_NORMAL
- en: 10 px + 3 px + 0 + 534 px + 0 + 3 px – 50 px = 500 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Or, we can rearrange the equation to solve for the content size instead of
    for the width of the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: 500 px – 10 px – 3 px – 3 px + 50 px = 534 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we were to introduce padding, the value of `inline-size` would drop even
    more (assuming `box-sizing: content-box`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, it’s possible to have `auto` inline-end margins evaluate to negative
    amounts. If the values of other properties force the inline-end margin to be negative
    in order to satisfy the requirement that elements be no wider than their containing
    block, that’s what will happen. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The equation works out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 500 px – 10 px – 600 px – 3 px – 3 px = –116 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the inline-end margin evaluates to `-116px`. No matter what explicit
    value it’s given in the CSS, this margin will still be forced to `-116px` because
    of the rule stating that when an element’s dimensions are overconstrained, the
    inline-end margin is reset to whatever is needed to make the numbers work out
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another example, illustrated in [Figure 6-37](#bvf_fig17), in
    which the inline-start margin is set to be negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0637](assets/css5_0637.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-37\. Setting a negative inline-start margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With a negative inline-start margin, the paragraph not only spills beyond the
    borders of the `<div>`, but also spills beyond the edge of the browser window
    itself!
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: padding, borders, and content widths (and heights) can never be negative.
    Only margins can be less than 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Percentages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to percentage values for the inline size, padding, and margins,
    the same basic rules we discussed in previous sections apply. It doesn’t really
    matter whether the values are declared with lengths or percentages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Percentages can be very useful. Suppose we want an element’s content to be
    two-thirds the inline size of its containing block, the padding sides to be 5%
    each, the inline-start margin to be 5%, and the inline-end margin to take up the
    slack. That would be written something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The inline-end margin would evaluate to 18% (100% – 67% – 5% – 5% – 5%) of the
    width of the containing block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixing percentages and length units can be tricky, however. Consider the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the element’s box can be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 5 em + 0 + 2 em + 67% + 2 em + 0 + auto = containing block width
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order for the inline-end margin’s inline size to evaluate to 0, the element’s
    containing block must be 27.272727 em wide (with the content area of the element
    being 18.272727 em wide) along the inline axis. Any wider than that, and the inline-end
    margin will evaluate to a positive value. Any narrower, and the inline-end margin
    will be a negative value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation gets even more complicated if we start mixing length-value unity
    types, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And, just to make things more complex, borders cannot accept percentage values,
    only length values. The bottom line is that it isn’t really possible to create
    a fully flexible element based solely on percentages unless you’re willing to
    avoid using borders or use approaches such as flexible box layout. That said,
    if you do need to mix percentages and length units, using the `calc()` and `minmax()`
    value functions can be a life changer, or at least a layout changer.
  prefs: []
  type: TYPE_NORMAL
- en: Replaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we’ve been dealing with the inline-axis formatting of nonreplaced block
    boxes in the normal flow of text. Replaced elements are a bit simpler to manage.
    All of the rules given for nonreplaced blocks hold true, with one exception: if
    `inline-size` is `auto`, the `inline-size` of the element is the content’s intrinsic
    width. (*Intrinsic* means the original size—the size of the element by default
    when no external factors are applied to it.) The image in the following example
    will be 20 pixels wide because that’s the width of the original image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If the actual image were 100 pixels wide instead, the element (and thus the
    image) would be laid out as 100 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can override this rule by assigning a specific value to `inline-size`. Suppose
    we modify the previous example to show the same image three times, each with a
    different width value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 6-38](#bvf_fig18) illustrates the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0638](assets/css5_0638.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-38\. Changing replaced element inline sizes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that the block size of the elements also increases. When a replaced element’s
    `inline-size` is changed from its intrinsic width, the value of `block-size` is
    scaled to match, maintaining the object’s initial aspect ratio, unless `block-size`
    has been set to an explicit value of its own. The reverse is also true: if `block-size`
    is set, but `inline-size` is left as `auto`, then the inline size is scaled proportionately
    to the change in block size.'
  prefs: []
  type: TYPE_NORMAL
- en: List Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: List items have a few special rules of their own. They are typically preceded
    by a marker, such as a round bullet mark or a number.
  prefs: []
  type: TYPE_NORMAL
- en: The marker attached to a list item element can be either outside the content
    of the list item or treated as an inline marker at the beginning of the content,
    depending on the value of the property `list-style-position`, as illustrated in
    [Figure 6-39](#bvf_fig32).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0639](assets/css5_0639.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-39\. Markers outside and inside the list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the marker stays outside the content, it is placed a specified distance from
    the inline-start content edge of the content. No matter how the list’s styles
    are altered, the marker stays the same distance from the content edge.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that list-item boxes define containing blocks for their descendant
    boxes, just like regular block boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: List markers are discussed in more detail, including how to create and style
    them using the `::marker` pseudo-element, in [Chapter 16](ch16.html#lists-and-generated-content).
  prefs: []
  type: TYPE_NORMAL
- en: Box Sizing with Aspect Ratios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you’ll want to size an element by its *aspect ratio*, which means
    its block and inline sizes exist in a specific ratio. Old TVs used to have a 4:3
    width-to-height ratio, for example; HD video resolutions have a 16:9 aspect ratio.
    You might want to force elements to be square while still letting their sizes
    flex. In these cases, the `aspect-ratio` property can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we know we’ll have a bunch of elements, and we don’t know how wide
    or tall each will be, but we want them all to be squares. First, pick an axis
    you want to size on. We’ll use `height` here. Make sure the other axis is autosized,
    and set an aspect ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 6-40](#aspect-ratio) shows the same set of HTML, both with and without
    the previous CSS applied.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0640](assets/css5_0640.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-40\. A gallery with and without aspect ratios defined
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The ratio is maintained over the distances defined by `box-sizing` (see [“Altering
    Box Sizing”](#altering-box-sizing)), so given the following CSS, the result will
    be an element whose outer border distances are in an exact 2:1 ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The default value, `auto`, means that boxes that have an intrinsic aspect ratio—boxes
    generated by images, for example—will use that aspect ratio. For elements that
    don’t have an intrinsic aspect ratio, such as most HTML elements like `<div>`,
    `<p>`, and so on, the axis sizes of the box will be determined by the content.
  prefs: []
  type: TYPE_NORMAL
- en: Inline Formatting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Inline formatting* isn’t as simple as formatting block-level elements, which
    just generates block boxes and usually doesn’t allow anything to coexist with
    them. By contrast, look *inside* a block-level element, such as a paragraph. You
    may well ask, how was the size and wrapping of each line determined? What controls
    the lines’ arrangement? How can I affect it?'
  prefs: []
  type: TYPE_NORMAL
- en: Line Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how lines are generated, first consider an element containing
    one very long line of text, as shown in [Figure 6-41](#bvf_fig33). Note that we’ve
    put a border around the line by wrapping the entire line in a `<span>` element
    and then assigning it a border style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0641](assets/css5_0641.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-41\. A single-line inline element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 6-41](#bvf_fig33) shows the simplest case of an inline element contained
    by a block-level element.'
  prefs: []
  type: TYPE_NORMAL
- en: To get from this simplified state to something more familiar, all we have to
    do is determine how wide (along the inline axis) the element should be, and then
    break up the line so that the resulting pieces will fit into the content inline
    size of the element. Therefore, we arrive at the state shown in [Figure 6-42](#bvf_fig34).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0642](assets/css5_0642.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-42\. A multiple-line inline element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Nothing has really changed. All we did was take the single line and break it
    into pieces, and then stack those pieces one after the other along the direction
    of the block flow.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-42](#bvf_fig34), the borders for each line of text also happen
    to coincide with the top and bottom of each line. This is true only because no
    padding has been set for the inline text. Notice that the borders overlap each
    other slightly; for example, the bottom border of the first line is just below
    the top border of the second line. This is because the border is drawn on the
    next pixel to the *outside* of each line. Since the lines are touching each other,
    their borders overlap as shown in [Figure 6-42](#bvf_fig34).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For simplicity, we use terms such as *top* and *bottom* when talking about the
    edges of line boxes. In this context, the top of a line box is the one closest
    to the block-start, and the bottom of a line box is the one closest to the block-end.
    Similarly, *tall* and *short* refer to the size of line boxes along the block
    axis.
  prefs: []
  type: TYPE_NORMAL
- en: If we alter the span styles to have a background color, the actual placement
    of the lines becomes clearer. Consider [Figure 6-43](#bvf_fig35), which shows
    four paragraphs in each of two writing modes, and the effects of different values
    of `text-align` (see [Chapter 15](ch15.html#text_properties)), by each paragraph
    having the backgrounds of its lines filled in.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0643](assets/css5_0643.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-43\. Showing lines in different alignments and writing modes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As [Figure 6-43](#bvf_fig35) shows, not every line reaches to the edge of its
    parent paragraph’s content area, which has been denoted with a dashed gray border.
    For the left-aligned paragraph, the lines are all pushed flush against the left
    content edge of the paragraph, and the end of each line happens wherever the line
    is broken. The reverse is true for the right-aligned paragraph. For the centered
    paragraph, the centers of the lines are aligned with the center of the paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: In the last case, where the value of `text-align` is `justify`, each line (except
    the last) is forced to be as wide as the paragraph’s content area so that the
    line’s edges touch the content edges of the paragraph. The difference between
    the natural length of the line and the width of the paragraph’s content area is
    made up by altering the spacing between letters and words in each line. Therefore,
    the value of `word-spacing` can be overridden when the text is justified. (The
    value of `letter-spacing` cannot be overridden if it is a length value.)
  prefs: []
  type: TYPE_NORMAL
- en: That pretty well covers how lines are generated in the simplest cases. As you’re
    about to see, however, the inline formatting model is far from simple.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Terms and Concepts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go any further, let’s review some terms of inline layout, which will
    be crucial in navigating the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous text
  prefs: []
  type: TYPE_NORMAL
- en: Any string of characters that is not contained within an inline element. Thus,
    in the markup `<p> I'm <em>so</em> happy!</p>`, the sequences “ I’m ” and “ happy!”
    are anonymous text. Note that the spaces are part of the text, since a space is
    a character like any other.
  prefs: []
  type: TYPE_NORMAL
- en: Em box
  prefs: []
  type: TYPE_NORMAL
- en: This is defined in the given font, otherwise known as the character box. Actual
    glyphs can be taller or shorter than their em boxes. In CSS, the value of `font-size`
    determines the height of each em box.
  prefs: []
  type: TYPE_NORMAL
- en: Content area
  prefs: []
  type: TYPE_NORMAL
- en: In nonreplaced elements, the content area can be one of two things, and the
    CSS specification allows user agents to choose which one. The content area can
    be the box described by the em boxes of every character in the element, strung
    together; or it can be the box described by the character glyphs in the element.
    In this book, we use the em box definition for simplicity, and that’s what is
    used by most browsers. In replaced elements, the content area is the intrinsic
    height of the element plus any margins, borders, or padding.
  prefs: []
  type: TYPE_NORMAL
- en: Leading
  prefs: []
  type: TYPE_NORMAL
- en: Leading (pronounced “led-ing”) is the difference between the values of `font-size`
    and `line-height`. This difference is divided in half, with one half applied to
    the top and one half to the bottom of the content area. These additions to the
    content area are called, perhaps unsurprisingly, *half-leading*. Leading is applied
    only to nonreplaced elements.
  prefs: []
  type: TYPE_NORMAL
- en: Inline box
  prefs: []
  type: TYPE_NORMAL
- en: This is the box described by the addition of the leading to the content area.
    For nonreplaced elements, the height of the inline box of an element will be exactly
    equal to the value of the `line-height` property. For replaced elements, the height
    of the inline box of an element will be exactly equal to the content area, since
    leading is not applied to replaced elements.
  prefs: []
  type: TYPE_NORMAL
- en: Line box
  prefs: []
  type: TYPE_NORMAL
- en: This is the shortest box that bounds the highest and lowest points of the inline
    boxes that are found in the line. In other words, the top edge of the line box
    is placed along the top of the highest inline-box top, and the bottom of the line
    box is placed along the bottom of the lowest inline-box bottom. Remember that
    “top” and “bottom” are considered with respect to the block flow direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS also contains a set of behaviors and useful concepts that fall outside
    of the preceding list of terms and definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: The content area of an inline box is analogous to the content box of a block
    box.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The background of an inline element is applied to the content area plus any
    padding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any border on an inline element surrounds the content area plus any padding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Padding, borders, and margins on nonreplaced inline elements have no vertical
    effect on the inline elements or the boxes they generate; they do *not* affect
    the height of an element’s inline box (and thus the line box that contains the
    element).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Margins and borders on replaced elements *do* affect the height of the inline
    box for that element and, by implication, the height of the line box for the line
    that contains the element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One more thing to note: inline boxes are vertically aligned within the line
    according to their values for the property `vertical-align` (see [Chapter 15](ch15.html#text_properties)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on, let’s look at a step-by-step process for constructing a line
    box, which you can use to see how the various pieces of a line fit together to
    determine its height. Determine the height of the inline box for each element
    in the line by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the values of `font-size` and `line-height` for each inline nonreplaced
    element and text that is not part of a descendant inline element and combine them.
    This is done by subtracting the `font-size` from the `line-height`, which yields
    the leading for the box. The leading is split in half and applied to the top and
    bottom of each em box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the value of `height`, along with the values for the margins, padding,
    and borders along the block-start and block-end edges of each replaced element,
    and add them together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure out, for each content area, how much of it is above the baseline for
    the overall line and how much of it is below the baseline. This is not an easy
    task: you must know the position of the baseline for each element and piece of
    anonymous text and the baseline of the line itself, and then line them all up.
    In addition, the block-end edge of a replaced element sits on the baseline for
    the overall line.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine the vertical offset of any elements that have been given a value for
    `vertical-align`. This will tell you how far up or down that element’s inline
    box will be moved along the block axis, and that will change how much of the element
    is above or below the baseline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you know where all of the inline boxes have come to rest, calculate
    the final line box height. To do so, just add the distance between the baseline
    and the highest inline-box top to the distance between the baseline and the lowest
    inline-box bottom.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let us consider the whole process in detail, which is the key to intelligently
    styling inline content.
  prefs: []
  type: TYPE_NORMAL
- en: Line Heights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, know that all elements have a `line-height`, whether it’s explicitly
    declared or not. This value greatly influences the way inline elements are displayed,
    so let’s give it due attention.
  prefs: []
  type: TYPE_NORMAL
- en: 'A line’s height (or the height of a line box) is determined by the height of
    its constituent elements and other content, such as text. It’s important to understand
    that `line-height` affects inline elements and other inline content, *not* block-level
    elements—at least, not directly. We can set a `line-height` value for a block-level
    element, but the value will have a visual impact only as it’s applied to inline
    content within that block-level element. Consider the following empty paragraph,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Without content, the paragraph won’t have anything to display, so we won’t see
    anything. The fact that this paragraph has a `line-height` of any value—be it
    `0.25em` or `25in`—makes no difference without some content to create a line box.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set a `line-height` value for a block-level element and have that apply
    to all of the content within the block, whether it’s contained in an inline element
    or anonymous text. In a certain sense, then, each line of text contained within
    a block-level element is its own inline element, whether or not it’s surrounded
    by tags. If you like, picture a fictional tag sequence like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Even though the `line` tags don’t actually exist, the paragraph behaves as if
    they did, and each line of text “inherits” styles from the paragraph. You bother
    to create `line-height` rules for block-level elements only so you don’t have
    to explicitly declare a `line-height` for all of their inline elements, fictional
    or otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fictional `line` element clarifies the behavior that results from setting
    `line-height` on a block-level element. According to the CSS specification, declaring
    `line-height` on a block-level element sets a *minimum* line-box height for the
    content of that block-level element. Declaring `p.spacious {line-height: 24pt;}`
    means that the *minimum* height for each line box is 24 points. Technically, content
    can inherit this line height only if an inline element does so. Most text isn’t
    contained by an inline element. If you pretend that each line is contained by
    the fictional `line` element, the model works out very nicely.'
  prefs: []
  type: TYPE_NORMAL
- en: Inline Nonreplaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building on our formatting knowledge, let’s move on to the construction of lines
    that contain only nonreplaced elements (or anonymous text). Then you’ll be in
    a good position to understand the differences between nonreplaced and replaced
    elements in inline layout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this section, we use *top* and *bottom* to label where half-leading is placed
    and how line boxes are placed together. Always remember that these terms are in
    relation to the direction of block flow: the *top edge* of an inline box is the
    one closest to the block-start edge, and the *bottom edge* of an inline box is
    closest to its block-end edge. Similarly, *height* means the distance along the
    inline box’s block axis, and *width* is the distance along its inline axis.'
  prefs: []
  type: TYPE_NORMAL
- en: Building the Boxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, for an inline nonreplaced element or piece of anonymous text, the value
    of `font-size` determines the height of the content area. If an inline element
    has a `font-size` of `15px`, the content area’s height is 15 pixels because all
    of the em boxes in the element are 15 pixels tall, as illustrated in [Figure 6-44](#bvf_fig36).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0644](assets/css5_0644.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-44\. Em boxes determine content area height
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The next thing to consider is the value of `line-height` for the element, and
    the difference between it and the value of `font-size`. If an inline nonreplaced
    element has a `font-size` of `15px` and a `line-height` of `21px`, the difference
    is 6 pixels. The user agent splits the 6 pixels in half and applies half (3 pixels)
    to the top and half (3 pixels) to the bottom of the content area, which yields
    the inline box. [Figure 6-45](#bvf_fig37) illustrates this process.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0645](assets/css5_0645.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-45\. Content area plus leading equals inline box
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, let’s break stuff so we can better understand how line height works. Assume
    the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this example, most of the text has a `font-size` of `12px`, while the text
    in one inline nonreplaced element has a size of `24px`. However, *all* of the
    text has a `line-height` of `12px` since `line-height` is an inherited property.
    Therefore, the `<strong>` element’s `line-height` is also `12px`.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, for each piece of text where both `font-size` and `line-height` are `12px`,
    the content height does not change (since the difference between `12px` and `12px`
    is 0), so the inline box is 12 pixels high. For the strong text, however, the
    difference between `line-height` and `font-size` is `-12px`. This is divided in
    half to determine the half-leading (`-6px`), and the half-leading is added to
    both the top and bottom of the content height to arrive at an inline box. Since
    we’re adding a negative number in both cases, the inline box ends up being 12
    pixels tall. The 12-pixel inline box is centered vertically within the 24-pixel
    content height of the element, so the inline box is smaller than the content area.
  prefs: []
  type: TYPE_NORMAL
- en: So far, it sounds like we’ve done the same thing to each bit of text, and that
    all the inline boxes are the same size, but that’s not quite true. The inline
    boxes in the second line, although they’re the same size, don’t line up because
    the text is all baseline aligned (see [Figure 6-46](#bvf_fig38)), a concept we’ll
    discuss later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Since inline boxes determine the height of the overall line box, their placement
    with respect to one another is critical. The line box is defined as the distance
    from the top of the highest inline box in the line to the bottom of the lowest
    inline box, and the top of each line box butts up against the bottom of the line
    box for the preceding line.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 6-46](#bvf_fig38), three boxes are being laid out for a single line
    of text: the two anonymous text boxes to either side of the `<strong>` element,
    and the `<strong>` element itself. Because the enclosing paragraph has a `line-height`
    of `12px`, each of the three boxes will have a 12-pixel-tall inline box. These
    inline boxes are centered within the content area of each box. The boxes then
    have their baselines lined up, so the text all shares a common baseline.'
  prefs: []
  type: TYPE_NORMAL
- en: But because of where the inline boxes fall with respect to those baselines,
    the inline box of the `<strong>` element is a little bit higher than the inline
    boxes of the anonymous text boxes. Thus, the distance from the top of the `<strong>`’s
    inline box to the bottoms of the anonymous inline boxes is more than 12 pixels,
    while the visible content of the line isn’t completely contained within the line
    box.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0646](assets/css5_0646.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-46\. Inline boxes within a line
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After all that, the middle line of text is placed between two other lines of
    text, as depicted in [Figure 6-47](#bvf_fig39). The bottom edge of the first line
    of text is placed against the top edge of the line of text we saw in [Figure 6-46](#bvf_fig38).
    Similarly, the top edge of the third line of text is placed against the bottom
    edge of the middle line of text. Because the middle line of text has a slightly
    taller line box, the result is that the lines of text look irregular, because
    the distances between the three baselines are not consistent.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0647](assets/css5_0647.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-47\. Line boxes within a paragraph
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In just a bit, we’ll explore ways to cope with this irregular separation of
    baselines and methods for achieving consistent baseline spacing. (Spoiler: Unitless
    values for the win!)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Vertical Alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we change the vertical alignment of the inline boxes, the same height determination
    principles apply. Suppose that we give the `<strong>` element a vertical alignment
    of `4px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: That small change raises the `<strong>` element 4 pixels, which pushes up both
    its content area and its inline box. Because the `<strong>` element’s inline-box
    top was already the highest in the line, this change in vertical alignment also
    pushes the top of the line box upward by 4 pixels, as shown in [Figure 6-48](#bvf_fig40).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0648](assets/css5_0648.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-48\. Vertical alignment affects line-box height
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A formal definition for `vertical-align` can be found in [Chapter 15](ch15.html#text_properties).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider another situation. Here, we have another inline element in the
    same line as the strong text, and its alignment is other than the baseline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the same result as in our earlier example, where the middle line
    box is taller than the other line boxes. However, notice how the “tall” text is
    aligned in [Figure 6-49](#bvf_fig41).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0649](assets/css5_0649.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-49\. Aligning an inline element to the line box
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this case, the top of the “tall” text’s inline box is aligned with the top
    of the line box. Since the “tall” text has equal values for `font-size` and `line-height`,
    the content height and inline box are the same. However, consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Since the `line-height` for the “tall” text is less than its `font-size`, the
    inline box for that element is smaller than its content area. This tiny fact changes
    the placement of the text itself, because the top of its inline box must be aligned
    with the top of the line box for its line. Thus, we get the result shown in [Figure 6-50](#bvf_fig42).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0650](assets/css5_0650.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-50\. Text protruding from the line box (again)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In relation to the terms we’ve been using in this chapter, the effects of the
    assorted keyword values of `vertical-align` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`top`'
  prefs: []
  type: TYPE_NORMAL
- en: Aligns the top (block-start edge) of the element’s inline box with the top of
    the containing line box.
  prefs: []
  type: TYPE_NORMAL
- en: '`bottom`'
  prefs: []
  type: TYPE_NORMAL
- en: Aligns the bottom (block-end edge) of the element’s inline box with the bottom
    of the containing line box.
  prefs: []
  type: TYPE_NORMAL
- en: '`text-top`'
  prefs: []
  type: TYPE_NORMAL
- en: Aligns the top (block-start edge) of the element’s inline box with the top of
    the parent’s content area.
  prefs: []
  type: TYPE_NORMAL
- en: '`text-bottom`'
  prefs: []
  type: TYPE_NORMAL
- en: Aligns the bottom (block-end edge) of the element’s inline box with the bottom
    of the parent’s content area.
  prefs: []
  type: TYPE_NORMAL
- en: '`middle`'
  prefs: []
  type: TYPE_NORMAL
- en: Aligns the vertical midpoint of the element’s inline box with `0.5ex` above
    the baseline of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '`super`'
  prefs: []
  type: TYPE_NORMAL
- en: Moves the content area and inline box of the element upward along the block
    axis. The distance is not specified and may vary by user agent.
  prefs: []
  type: TYPE_NORMAL
- en: '`sub`'
  prefs: []
  type: TYPE_NORMAL
- en: The same as `super`, except the element is moved downward along the block axis
    instead of upward.
  prefs: []
  type: TYPE_NORMAL
- en: <*`percentage`*>
  prefs: []
  type: TYPE_NORMAL
- en: Shifts the element up or down the block axis by the distance defined by taking
    the declared percentage of the element’s value for `line-height`.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Line Height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In previous sections, you saw that changing the `line-height` of an inline element
    can cause text from one line to overlap another. In each case, though, the changes
    were made to individual elements. So how can you affect the `line-height` of elements
    in a more general way in order to keep content from overlapping?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this is to use the `em` unit in conjunction with an element whose
    `font-size` has changed. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: By setting a `line-height` for the `<strong>` element, we increase the overall
    height of the line box, providing enough room to display the `<strong>` element
    without overlapping any other text and without changing the `line-height` of all
    lines in the paragraph. We use a value of `1em` so that the `line-height` for
    the `<strong>` element will be set to the same size as `<strong>`’s `font-size`.
    Remember, `line-height` is set in relation to the `font-size` of the element itself,
    not the parent element. [Figure 6-51](#bvf_fig43) shows the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0651](assets/css5_0651.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-51\. Assigning the `line-height` property to inline elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Make sure you really understand the previous sections, because readable formatting
    of the text gets trickier when we try to add borders. Let’s say we want to put
    5-pixel borders around any hyperlink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t set a large-enough `line-height` to accommodate the border, it will
    be in danger of overwriting other lines. We could increase the size of the inline
    box for hyperlinks by using `line-height`, as we did for the `<strong>` element
    in the earlier example; in this case, we’d just need to make the value of `line-height`
    10 pixels larger than the value of `font-size` for those links. However, that
    will be difficult if we don’t actually know the size of the font in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another solution is to increase the `line-height` of the paragraph. This will
    affect every line in the entire element, not just the line in which the bordered
    hyperlink appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Because extra space is added above and below each line, the border around the
    hyperlink doesn’t impinge on any other line, as shown in [Figure 6-52](#bvf_fig44).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0652](assets/css5_0652.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-52\. Increasing `line-height` to leave room for inline borders
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This approach works because all of the text is the same size. If the line contained
    other elements that changed the height of the line box, our border situation might
    also change. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Given these rules, the height of the inline box of a `<strong>` element within
    a paragraph will be 31.5 pixels (14 × 1.5 × 1.5), and that will also be the height
    of the line box. To keep baseline spacing consistent, we must make the `<p>` element’s
    `line-height` equal to or greater than `32px`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding baselines and line heights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The actual height of each line box depends on the way its component elements
    line up with one another. This alignment tends to depend very much on where the
    baseline falls within each element (or piece of anonymous text) because that location
    determines how the inline boxes are arranged vertically.
  prefs: []
  type: TYPE_NORMAL
- en: Consistent baseline spacing tends to be more of an art than a science. If you
    declare all of your font sizes and line heights by using a single unit, such as
    ems, you have a good chance of consistent baseline spacing. If you mix units,
    however, that feat becomes a great deal more difficult, if not impossible.
  prefs: []
  type: TYPE_NORMAL
- en: As of late 2022, proposals call for properties that would let authors enforce
    consistent baseline spacing regardless of the inline content, which would greatly
    simplify certain aspects of online typography. None of these proposed properties
    have been implemented, which makes their adoption a distant hope at best.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling line heights
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way to set `line-height`, as it turns out, is to use a raw number
    as the value. This method is best because the number becomes the *scaling factor*,
    and that factor is an inherited, not a computed, value. Let’s say we want the
    `line-height` of all elements in a document to be one and a half times their `font-size`.
    We would declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This scaling factor of 1.5 is passed down from element to element, and, at
    each level, the factor is used as a multiplier of the `font-size` of each element.
    Therefore, the following markup would be displayed as shown in [Figure 6-53](#bvf_fig45):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the line height for the `<small>` element turns out to be
    15 pixels, and for the `<strong>` element, it’s 45 pixels. If we don’t want our
    big `<strong>` text to generate too much extra leading, we can give it its own
    `line-height` value, which will override the inherited scaling factor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0653](assets/css5_0653.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-53\. Using a scaling factor for `line-height`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Adding Box Properties to Nonreplaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may recall from previous discussions, while padding, margins, and borders
    may all be applied to inline nonreplaced elements, these properties have no impact
    on the height of the inline element’s line box.
  prefs: []
  type: TYPE_NORMAL
- en: The border edge of inline elements is controlled by `font-size`, not `line-height`.
    In other words, if a `<span>` element has a `font-size` of `12px` and a `line-height`
    of `36px`, its content area is `12px` high, and the border will surround that
    content area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can assign padding to the inline element, which will push
    the borders away from the text itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This padding does not alter the actual shape of the content height, and so it
    will not affect the height of the inline box for this element. Similarly, adding
    borders to an inline element will not affect the way line boxes are generated
    and laid out, as illustrated in [Figure 6-54](#bvf_fig47) (both with and without
    the 4-pixel padding).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0654](assets/css5_0654.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-54\. Padding and borders do not alter line height
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As for margins, they do not, practically speaking, apply to the block edges
    of an inline nonreplaced element, as they don’t affect the height of the line
    box. The inline ends of the element are another story.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the idea that an inline element is basically laid out as a single line
    and then broken into pieces. So, if we apply margins to an inline element, those
    margins will appear at its beginning and end: these are the inline-start and inline-end
    margins, respectively. Padding also appears at these edges. Thus, although padding
    and margins (and borders) do not affect line heights, they can still affect the
    layout of an element’s content by pushing text away from its ends. In fact, negative
    inline-start and -end margins can pull text closer to the inline element, or even
    cause overlap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what happens when an inline element has a background and enough padding
    to cause the lines’ backgrounds to overlap? Take the following situation as an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: All of the text within the `<span>` element will have a content area 15 pixels
    tall, and we’ve applied 10 pixels of padding to the top and bottom of each content
    area. The extra pixels won’t increase the height of the line box, which would
    be fine, except there is a background color. Thus, we get the result shown in
    [Figure 6-55](#bvf_fig48).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0655](assets/css5_0655.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-55\. Padding and margins on inline elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'CSS explicitly states that the line boxes are drawn in document order: “This
    will cause the borders on subsequent lines to paint over the borders and text
    of previous lines.” The same principle applies to backgrounds as well, as [Figure 6-55](#bvf_fig48)
    shows.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing Breaking Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you saw that when an inline nonreplaced element is
    broken across multiple lines, it’s treated as if it were one long single-line
    element that’s sliced into smaller boxes, one slice per line break. That’s just
    the default behavior, and it can be changed via the property `box-decoration-break`.
  prefs: []
  type: TYPE_NORMAL
- en: The default value, `slice`, is what you saw in the previous section. The other
    value, `clone`, causes each fragment of the element to be drawn as if it were
    a standalone box. What does that mean? Compare the two examples in [Figure 6-56](#bvf_fig50),
    in which exactly the same markup and styles are treated as either sliced or cloned.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the differences may be apparent, but a few are perhaps more subtle.
    Among the effects are the application of padding to each element’s fragment, including
    at the ends where the line breaks occur. Similarly, the border is drawn around
    each fragment individually, instead of being broken up.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0656](assets/css5_0656.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-56\. Sliced and cloned inline fragments
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: More subtly, notice how the `background-image` positioning changes between the
    two. In the sliced version, background images are sliced along with everything
    else, meaning that only one of the fragments contains the origin image. In the
    cloned version, however, each background acts as its own copy, so each has its
    own origin image. This means, for example, that even if we have a nonrepeated
    background image, it will appear once in each fragment instead of in only one
    fragment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `box-decoration-break` property will most often be used with inline boxes,
    but it applies anytime there’s a break in an element—for example, when a page
    break interrupts an element in paged media. In such a case, each fragment is a
    separate slice. If we set `box-decoration-break: clone`, each box fragment will
    be treated as a copy when it comes to borders, padding, backgrounds, and so on.
    The same holds true in multicolumn layout: if an element is split by a column
    break, the value of `box-decoration-break` will affect how it is rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: Glyphs Versus Content Area
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even when you try to keep inline nonreplaced element backgrounds from overlapping,
    it can still happen, depending on which font is in use. The problem lies in the
    difference between a font’s em box and its character glyphs. Most fonts, as it
    turns out, don’t have em boxes whose heights match the character glyphs.
  prefs: []
  type: TYPE_NORMAL
- en: That may sound abstract, but it has practical consequences. The “painting area”
    of an inline nonreplaced element is left to the user agent. If a user agent takes
    the em box to be the height of the content area, the background of an inline nonreplaced
    element will be equal to the height of the em box (which is the value of `font-size`).
    If a user agent uses the maximum ascender and descender of the font, the background
    may be taller or shorter than the em box. Therefore, you could give an inline
    nonreplaced element a `line-height` of `1em` and still have its background overlap
    the content of other lines.
  prefs: []
  type: TYPE_NORMAL
- en: Inline Replaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inline replaced elements, such as images, are assumed to have an intrinsic
    height and width; for example, an image will be a certain number of pixels high
    and wide. Therefore, a replaced element with an intrinsic height can cause a line
    box to become taller than normal. This does *not* change the value of `line-height`
    for any element in the line, *including the replaced element itself*. Instead,
    the line box is made just tall enough to accommodate the replaced element, plus
    any box properties. In other words, the entirety of the replaced element—content,
    margins, borders, and padding—is used to define the element’s inline box. The
    following styles lead to one such example, as shown in [Figure 6-57](#bvf_fig51):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0657](assets/css5_0657.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-57\. Replaced elements can increase the height of the line box but
    not the value of `line-height`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Despite all the blank space, the effective value of `line-height` has not changed,
    either for the paragraph or the image itself. The `line-height` value has no effect
    on the image’s inline box. Because the image in [Figure 6-57](#bvf_fig51) has
    no padding, margins, or borders, its inline box is equivalent to its content area,
    which is, in this case, 30 pixels tall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nonetheless, an inline replaced element still has a value for `line-height`.
    Why? In the most common case, it needs the value in order to correctly position
    the element if it’s been vertically aligned. Recall that, for example, percentage
    values for `vertical-align` are calculated with respect to an element’s `line-height`.
    Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The inherited value of `line-height` causes the image to be raised 9 pixels
    instead of some other number. Without a value for `line-height`, it wouldn’t be
    possible to perform percentage-value vertical alignments. The height of the image
    itself has no relevance when it comes to vertical alignment; the value of `line-height`
    is all that matters.
  prefs: []
  type: TYPE_NORMAL
- en: However, for other replaced elements, it might be important to pass on a `line-height`
    value to descendant elements within that replaced element. An example would be
    an SVG image, which can use CSS to style text found within the image.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Box Properties to Replaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After everything we’ve just been through, applying margins, borders, and padding
    to inline replaced elements seems almost simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Padding and borders are applied to replaced elements as usual; padding inserts
    space around the actual content, and the border surrounds the padding. What’s
    unusual about the process is that the padding and border actually influence the
    height of the line box because they are part of the inline box of an inline replaced
    element (unlike with inline nonreplaced elements). Consider [Figure 6-58](#bvf_fig52),
    which results from the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that the first line box is made tall enough to contain the image, whereas
    the second is tall enough to contain the image, its padding, and its border.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0658](assets/css5_0658.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-58\. Adding padding, borders, and margins to an inline replaced element
    increases its inline box
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Margins are also contained within the line box, but they have their own wrinkles.
    Setting a positive margin is no mystery; it will make the inline box of the replaced
    element taller. Setting negative margins has a similar effect: it decreases the
    size of the replaced element’s inline box. This is illustrated in [Figure 6-59](#bvf_fig53),
    where we can see that a negative top margin is pulling down the line above the
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Negative margins operate the same way on block-level elements, as shown earlier
    in the chapter. In this case, the negative margins make the replaced element’s
    inline box smaller than ordinary. Negative margins are the only way to cause inline
    replaced elements to bleed into other lines, and it’s why the boxes that replaced
    inline elements generate are often assumed to be inline-block.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0659](assets/css5_0659.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-59\. The effect of negative margins on inline replaced elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Replaced Elements and the Baseline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed by now that, by default, inline replaced elements sit on
    the baseline. If you add bottom (block-end) padding, a margin, or a border to
    the replaced element, then the content area will move upward along the block axis.
    Replaced elements do not have baselines of their own, so the next best thing is
    to align the bottom of their inline boxes with the baseline. Thus, it is actually
    the outer block-end margin edge that is aligned with the baseline, as illustrated
    in [Figure 6-60](#bvf_fig54).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0660](assets/css5_0660.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-60\. Inline replaced elements sit on the baseline
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This baseline alignment leads to an unexpected (and unwelcome) consequence:
    an image placed in a table cell all by itself should make the table cell tall
    enough to contain the line box containing the image. The resizing occurs even
    if no actual text, not even whitespace, is in the table cell with the image. Therefore,
    the common sliced-image and spacer-GIF designs of years past can fall apart quite
    dramatically in modern browsers. (We know that *you* don’t create such things,
    but this is still a handy context in which to explain this behavior.) Consider
    the simplest case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Under the CSS inline formatting model, the table cell will be 12 pixels tall,
    with the image sitting on the baseline of the cell. So we might have 3 pixels
    of space below the image and 8 above it, although the exact distances would depend
    on the font family used and the placement of its baseline.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is not confined to images inside table cells; it will also happen
    anytime an inline replaced element is the sole descendant of a block-level or
    table-cell element. For example, an image inside a `<div>` will also sit on the
    baseline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another interesting effect of inline replaced elements sitting on the
    baseline: if we apply a negative bottom (block-end) margin, the element will get
    pulled downward because the bottom of its inline box will be higher than the bottom
    of its content area. Thus, the following rule would have the result shown in [Figure 6-61](#bvf_fig55):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0661](assets/css5_0661.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-61\. Pulling inline replaced elements down with a negative block-end
    margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This can easily cause a replaced element to bleed into following lines of text,
    as [Figure 6-61](#bvf_fig55) shows.
  prefs: []
  type: TYPE_NORMAL
- en: Inline-Block Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As befits the hybrid look of the value name `inline-block`, inline-block elements
    are indeed a hybrid of block-level and inline elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'An inline-block element relates to other elements and content as an inline
    box just as an image would: inline-block elements are formatted within a line
    as a replaced element. This means the bottom (block-end) edge of the inline-block
    element will rest on the baseline of the text line by default and will not line
    break within itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the inline-block element, the content is formatted as though the element
    were block-level. The properties `width` and `height` apply to the element (and
    thus so does `box-sizing`), as they do to any block-level or inline replaced element,
    and those properties will increase the height of the line if they are taller than
    the surrounding content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider some example markup that should help make this clearer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To this markup, we apply the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 6-62](#bvf_fig56) depicts the result of this stylesheet.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0662](assets/css5_0662.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-62\. The behavior of an inline-block element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that in the second `<div>`, the inline paragraph is formatted as normal
    inline content, which means `width` and `text-align` get ignored (since they do
    not apply to inline elements). For the third `<div>`, however, the inline-block
    paragraph honors both properties, since it is formatted as a block-level element.
    That paragraph’s margins also force its line of text to be much taller, since
    it affects line height as though it were a replaced element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an inline-block element’s `width` is not defined or explicitly declared
    `auto`, the element box will shrink to fit the content. The element box is exactly
    as wide as necessary to hold the content, and no wider. Inline boxes act the same
    way, although they can break across lines of text, whereas inline-block elements
    cannot. Thus, we have the following rule, when applied to the previous markup
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This will create a tall box that’s just wide enough to enclose the content,
    as shown in [Figure 6-63](#bvf_fig57).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0663](assets/css5_0663.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-63\. Autosizing of an inline-block element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Flow Display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `display` values `flow` and `flow-root` deserve a moment of explanation.
    Declaring an element to be laid out using `display: flow` means that it should
    use block-and-inline layout, the same as normal—that is, unless it’s combined
    with `inline`, in which case it generates an inline box.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the first two of the following rules will result in a block
    box, whereas the third will yield an inline box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this pattern is that CSS is (very) slowly moving to a system
    that supports two kinds of display: the *outer display type* and the *inner display
    type*. Value keywords like `block` and `inline` represent the outer display type,
    which determines how the display box interacts with its surroundings. The inner
    display (in this case, `flow`), describes what should happen inside the element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach allows for declarations like `display: inline block` to indicate
    that an element should generate a block-formatting context within, but relate
    to its surrounding content as an inline element. (The new two-term `display` value
    has the same effect as the fully supported `inline-block` value.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `display: flow-root`, on the other hand, always generates a block box,
    with a new block formatting context inside itself. This is the sort of thing that
    would be applied to the root element of a document, like `<html>`, to say, “This
    is where the formatting root lies.”'
  prefs: []
  type: TYPE_NORMAL
- en: The old `display` values you may be familiar with are still available. [Table 6-1](#display_values_reference)
    shows how the old values will be represented using the new values.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Equivalent `display` values
  prefs: []
  type: TYPE_NORMAL
- en: '| Old values | New values |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `block` | `block flow` |'
  prefs: []
  type: TYPE_TB
- en: '| `inline` | `inline flow` |'
  prefs: []
  type: TYPE_TB
- en: '| `inline-block` | `inline flow-root` |'
  prefs: []
  type: TYPE_TB
- en: '| `list-item` | `list-item block flow` |'
  prefs: []
  type: TYPE_TB
- en: '| `inline-list-item` | `list-item inline flow` |'
  prefs: []
  type: TYPE_TB
- en: '| `table` | `block table` |'
  prefs: []
  type: TYPE_TB
- en: '| `inline-table` | `inline table` |'
  prefs: []
  type: TYPE_TB
- en: '| `flex` | `block flex` |'
  prefs: []
  type: TYPE_TB
- en: '| `inline-flex` | `inline flex` |'
  prefs: []
  type: TYPE_TB
- en: '| `grid` | `block grid` |'
  prefs: []
  type: TYPE_TB
- en: '| `inline-grid` | `inline grid` |'
  prefs: []
  type: TYPE_TB
- en: Content Display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A fascinating new addition to `display` is the value `contents`. When applied
    to an element, `display: contents` causes the element to be removed from page
    formatting, and effectively “elevates” its child elements to its level. As an
    example, consider the following basic CSS and HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This yields an unordered list with a red border, and three list items with silver
    borders.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we then apply `display: contents` to the `<ul>` element, the user agent
    will render the list as if the `<ul>` and `</ul>` lines had been deleted from
    the document source. [Figure 6-64](#bvf_css4_display_contents) shows the difference
    between the regular result and the `contents` result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0664](assets/css5_0664.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-64\. A regular unordered list, and one with `display: contents`'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The list items are still list items, and act like them, but visually, the `<ul>`
    is gone, as if it had never been. Not only does the list’s border go away, but
    also the top and bottom margins that usually separate the list from surrounding
    content. This is why the second list in [Figure 6-64](#bvf_css4_display_contents)
    appears higher up than the first.
  prefs: []
  type: TYPE_NORMAL
- en: Other Display Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We haven’t covered a great many more display values in this chapter, and won’t.
    The various table-related values will come up in [Chapter 13](ch13.html#title-table-layout-in-css),
    and we’ll talk about list items again in [Chapter 16](ch16.html#lists-and-generated-content).
  prefs: []
  type: TYPE_NORMAL
- en: The values we won’t really talk about are the Ruby-related values, which need
    their own book and are poorly supported as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Element Visibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to everything we’ve discussed in the chapter, you can also control
    the visibility of an entire element.
  prefs: []
  type: TYPE_NORMAL
- en: 'If an element is set to have `visibility: visible`, it is, as you might expect,
    visible. If an element is set to `visibility: hidden`, it is made “invisible”
    (to use the wording in the specification). In its invisible state, the element
    still affects the document’s layout as though it were `visible`. In other words,
    the element is still there—you just can’t see it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the difference between this and `display: none`. In the latter case, the
    element is not displayed *and* is removed from the document altogether so that
    it doesn’t have any effect on document layout. [Figure 6-65](#making_elements_invisible)
    shows a document in which an inline element inside a paragraph has been set to
    `hidden`, based on the following styles and markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0665](assets/css5_0665.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-65\. Making elements invisible without suppressing their element boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Everything visible about a hidden element—such as content, background, and borders—is
    made invisible. The space is still there because the element is still part of
    the document’s layout. We just can’t see it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set the descendant element of a `hidden` element to be `visible`. This
    causes the element to appear wherever it normally would, even though the ancestor
    is invisible. To do so, we explicitly declare the descendant element `visible`,
    since `visibility` is inherited:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As for `visibility: collapse`, this value is used in CSS table rendering and
    flexible box layout, where it has an effect very similar to `display: none`. The
    difference is that in table rendering, a row or column that’s been set to `visibility:
    hidden` is hidden and the space it would have occupied is removed, but any cells
    in the hidden row or column are used to determine the layout of intersecting columns
    or rows. This allows you to quickly hide or show rows and columns without forcing
    the browser to recalculate the layout of the whole table.'
  prefs: []
  type: TYPE_NORMAL
- en: If `collapse` is applied to an element that isn’t a flex item or part of a table,
    it has the same meaning as `hidden`.
  prefs: []
  type: TYPE_NORMAL
- en: Animating Visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to animate a change from visible visibility to one of the other
    values of `visibility`, that is possible. The catch is that you won’t see a slow
    fade from one to the other. Instead, the browser calculates where in the animation
    a change from `0` to `1` (or vice versa) would reach the end value, and instantly
    changes the value of `visibility` at that point. Thus, if an element is set to
    `visibility: hidden` and then animated to `visibility: visible`, the element will
    be completely invisible until the end point is reached, at which time it will
    become instantly visible. (See Chapters [18](ch18.html#x-transitions) and [19](ch19.html#animation)
    for more information on animating CSS properties.)'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to fade from being invisible to visible, don’t animate `visibility`.
    Animate `opacity` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although some aspects of the CSS formatting model may seem counterintuitive
    at first, they begin to make sense the more you work with them. In many cases,
    rules that seem nonsensical or even idiotic turn out to exist in order to prevent
    bizarre or otherwise undesirable document displays. Block-level elements are in
    many ways easy to understand, and affecting their layout is typically a simple
    task. Inline elements, on the other hand, can be trickier to manage, as multiple
    factors come into play, not the least of which is whether the element is replaced
    or nonreplaced.
  prefs: []
  type: TYPE_NORMAL
