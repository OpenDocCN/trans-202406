<html><head></head><body><section data-pdf-bookmark="Chapter 17. Transforms" data-type="chapter" epub:type="chapter"><div class="chapter" id="transforms">&#13;
<h1><span class="label">Chapter 17. </span>Transforms</h1>&#13;
&#13;
&#13;
<p>Ever since the inception of CSS, elements have been rectangular and firmly oriented on the horizontal and vertical axes. Several tricks&#13;
arose to make elements look like they were tilted and so on, but&#13;
underneath it all was a rigid grid.</p>&#13;
&#13;
<p>With&#13;
CSS <em>transforms</em>, you <a data-primary="transforms" data-type="indexterm" id="ix_transform_ch17"/>have the ability to break that visual grid and shake up the way your elements are presented.&#13;
Whether it’s as simple as rotating some photographs a&#13;
bit to make them appear more natural, or creating interfaces where&#13;
information can be revealed by flipping over elements, or doing&#13;
interesting perspective tricks with sidebars, CSS transforms can—if&#13;
you’ll pardon the obvious expression—transform the way you design.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Coordinate Systems" data-type="sect1"><div class="sect1" id="idm45176044185200">&#13;
<h1>Coordinate Systems</h1>&#13;
&#13;
<p>Before <a data-primary="transforms" data-secondary="coordinate systems used by" data-type="indexterm" id="ix_transform_coord_sys"/><a data-primary="coordinate systems" data-type="indexterm" id="ix_coord_sys"/>embarking on this journey, let’s take a moment to orient&#13;
ourselves. Specifically, let’s review the <em>coordinate systems</em> used to define positions or movement in space as a sequence of measurements.&#13;
Two types of coordinate systems are used in&#13;
transforms, and it’s a good idea to be familiar with both.</p>&#13;
&#13;
<p>The <a data-primary="x/y/z coordinate system" data-type="indexterm" id="ix_xyz_coord"/><a data-primary="Cartesian coordinate system" data-type="indexterm" id="ix_cartesian"/>first is the <em>Cartesian coordinate system</em>, often called the&#13;
<em>x/y/z coordinate system</em>. This system describes the position&#13;
of a point in space by using two numbers (for two-dimensional placement) or three numbers (for three-dimensional placement). In CSS, the system uses three axes: the x-axis (horizontal); the y-axis (vertical); and the z-axis (depth). This is illustrated in <a data-type="xref" href="#tf_fig01">Figure 17-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig01">&#13;
<img alt="css5 1701" src="assets/css5_1701.png"/>&#13;
<h6><span class="label">Figure 17-1. </span>The three Cartesian axes used in CSS transforms</h6>&#13;
</div></figure>&#13;
&#13;
<p>For any two-dimensional (2D) transform, you need to worry about only the&#13;
x- and y-axes. By convention, positive x values go to the right, and&#13;
negative values go to the left. Similarly, positive y values go downward along the&#13;
y-axis, while negative values go upward along the y-axis.</p>&#13;
&#13;
<p>That might seem a little weird, since we tend to think that higher&#13;
numbers should place something higher up, not lower down, as many of us&#13;
learned in pre-algebra. (This is why the “y” label is at the bottom of the&#13;
y-axis in <a data-type="xref" href="#tf_fig01">Figure 17-1</a>: the labels are placed in the positive direction on&#13;
all three axes.) If you are experienced with absolute positioning in&#13;
CSS, think of the <code>top</code> property values for absolutely positioned&#13;
elements: they get moved downward for positive <code>top</code> values, and upward&#13;
when <code>top</code> has a negative length.</p>&#13;
&#13;
<p>Given this, in order to move an element leftward and down, you would&#13;
give it a negative x and a positive y value. Here is one way to do this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">translateX</code><code class="p">(</code><code class="m">-5em</code><code class="p">)</code> <code class="n">translateY</code><code class="p">(</code><code class="m">33px</code><code class="p">)</code></pre>&#13;
&#13;
<p>That is, in fact, a valid transform value, as you’ll see in just a bit. Its effect is to translate (move) the element 5 ems to the left and 33&#13;
pixels down, in that order.</p>&#13;
&#13;
<p>If you <a data-primary="transforms" data-secondary="3D style for" data-type="indexterm" id="ix_transform_3dstyle"/><a data-primary="elements" data-secondary="frame of reference" data-type="indexterm" id="ix_elem_frame"/>want to transform something in three-dimensional (3D) space, you&#13;
add a z-axis value. This axis is the one that “sticks out” of the&#13;
display and runs straight through your head—in a theoretical sense,&#13;
that is. Positive z values are closer to you, and negative z values are&#13;
farther away from you. In this regard, it’s very much like the <code>z-index</code>&#13;
property.</p>&#13;
&#13;
<p>So let’s say that we want to take the element we moved before and add a&#13;
z-axis value:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">translateX</code><code class="p">(</code><code class="m">-5em</code><code class="p">)</code> <code class="n">translateY</code><code class="p">(</code><code class="m">33px</code><code class="p">)</code> <code class="n">translateZ</code><code class="p">(</code><code class="m">200px</code><code class="p">)</code></pre>&#13;
&#13;
<p>Now the element will appear 200 pixels closer to us than it would be&#13;
without the z value.</p>&#13;
&#13;
<p>Well, you might wonder exactly how an element can be moved 200 pixels&#13;
closer to you, given that holographic displays are regrettably rare and&#13;
expensive. How many molecules of air between you and your monitor are&#13;
equivalent to 200 pixels? What does an element moving closer to you even&#13;
look like, and what happens if it gets <em>too</em> close? These are excellent&#13;
questions that we’ll get to later. For now, just accept that moving&#13;
an element along the z-axis appears to move it closer or farther away.</p>&#13;
&#13;
<p>The really important thing to remember is that every element carries its&#13;
own frame of reference and so considers its axes with respect to&#13;
itself. If you rotate an element, the axes rotate along&#13;
with it, as illustrated in <a data-type="xref" href="#tf_fig02">Figure 17-2</a>. Any further transforms are&#13;
calculated with respect to those rotated axes, not the axes of the&#13;
display.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig02">&#13;
<img alt="css5 1702" src="assets/css5_1702.png"/>&#13;
<h6><span class="label">Figure 17-2. </span>Elemental frames of reference</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, suppose you want to rotate an element 45&#13;
degrees clockwise in the plane of the display (i.e., around the z-axis).&#13;
Here’s the transform value you’re most likely to use:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">rotate</code><code class="p">(</code><code class="m">45deg</code><code class="p">)</code></pre>&#13;
&#13;
<p>Change that to <code>–45deg</code>, and the element will rotate counterclockwise&#13;
(anticlockwise for our international friends) around the z-axis.<a data-primary="" data-startref="ix_cartesian" data-type="indexterm" id="idm45176044063568"/><a data-primary="" data-startref="ix_xyz_coord" data-type="indexterm" id="idm45176044062720"/> In&#13;
other words, it will rotate in the <em>xy</em> plane, as illustrated in <a data-type="xref" href="#tf_fig05">Figure 17-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig05">&#13;
<img alt="css5 1703" src="assets/css5_1703.png"/>&#13;
<h6><span class="label">Figure 17-3. </span>Rotations in the xy plane</h6>&#13;
</div></figure>&#13;
&#13;
<p>Speaking of <a data-primary="spherical coordinate system" data-type="indexterm" id="idm45176044059184"/>rotations, the other coordinate system used in CSS&#13;
transforms is a <em>spherical system</em>, which describes angles in 3D space.&#13;
It’s illustrated in <a data-type="xref" href="#tf_fig03">Figure 17-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig03">&#13;
<img alt="css5 1704" src="assets/css5_1704.png"/>&#13;
<h6><span class="label">Figure 17-4. </span>The spherical coordinate system used in CSS transforms</h6>&#13;
</div></figure>&#13;
&#13;
<p>For the purposes of 2D transforms, you have to worry about only a single&#13;
360-degree polar system: the one that sits on the plane described by the&#13;
x- and y-axes. When it comes to rotations, a 2D rotation actually&#13;
describes a rotation around the z-axis. Similarly, rotations around the&#13;
x-axis tilt the element toward or away from you, and rotations around&#13;
the y-axis turn the element from side to side. These are illustrated in&#13;
<a data-type="xref" href="#tf_fig04">Figure 17-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig04">&#13;
<img alt="css5 1705" src="assets/css5_1705.png"/>&#13;
<h6><span class="label">Figure 17-5. </span>Rotations around the three axes</h6>&#13;
</div></figure>&#13;
&#13;
<p>All right, now that we have our bearings, let’s get started with using CSS&#13;
transforms!<a data-primary="" data-startref="ix_coord_sys" data-type="indexterm" id="idm45176044031680"/><a data-primary="" data-startref="ix_transform_coord_sys" data-type="indexterm" id="idm45176044030832"/><a data-primary="" data-startref="ix_elem_frame" data-type="indexterm" id="idm45176044029984"/><a data-primary="" data-startref="ix_transform_3dstyle" data-type="indexterm" id="idm45176044029136"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transforming" data-type="sect1"><div class="sect1" id="idm45176044184288">&#13;
<h1>Transforming</h1>&#13;
&#13;
<p>One <a data-primary="transform property" data-type="indexterm" id="ix_transform_prop"/>property applies all transforms as a single operation, and a&#13;
few ancillary properties affect exactly how the transforms are&#13;
applied or allow transforms in a single manner. We’ll start with the <span class="keep-together">big cheese.</span></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176044024704">&#13;
<h1>transform</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>transform-list</code></em>&gt; | <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements except atomic inline-level boxes (see explanation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the size of the bounding box (see explanation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified, except for relative length values, which are converted to an absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>As a transform</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>A &lt;<em><code>transform-list</code></em>&gt; is a space-separated list of functions defining different transformations, like the examples used in the preceding section. We’ll dig into the specific functions you can use in a moment.</p>&#13;
&#13;
<p>First off, let’s clear up the <a data-primary="transforms" data-secondary="bounding box for" data-type="indexterm" id="idm45176044008224"/><a data-primary="bounding box" data-type="indexterm" id="idm45176044007248"/>matter of the bounding box. For any&#13;
element being affected by CSS, the <em>bounding box</em> is the border box—the&#13;
outermost edge of the element’s border. Any outlines and&#13;
margins are ignored for the purposes of calculating the bounding box.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If a <a data-primary="table layout" data-secondary="bounding box" data-type="indexterm" id="idm45176044005056"/>table-display element is being transformed, its&#13;
bounding box is the table wrapper box, which encloses the table box and&#13;
any &#13;
<span class="keep-together">associated</span> caption box.</p>&#13;
</div>&#13;
&#13;
<p>If you’re <a data-primary="object bounding box" data-type="indexterm" id="idm45176044002688"/><a data-primary="SVG format" data-secondary="object bounding box" data-type="indexterm" id="idm45176044001952"/>transforming an SVG element with CSS, its bounding box is its SVG-defined <em>object bounding box</em>.</p>&#13;
&#13;
<p>Note that all transformed elements (e.g., elements with <code>transform</code> set&#13;
to a value other than <code>none</code>) have their own stacking context. (See <a data-type="xref" href="ch10.html#placement-on-the-z-axis">“Placement on the Z-Axis”</a> for an explanation.)</p>&#13;
&#13;
<p>While a&#13;
scaled element may be much smaller or larger than it was before the&#13;
transform was applied, the actual space on the page that the element occupies&#13;
remains the same as before the transform was applied. This is true for&#13;
all the transform functions: when you translate or rotate an element, its siblings don’t automatically move out of the way.</p>&#13;
&#13;
<p>Now, the value entry &lt;<em><code>transform-list</code></em>&gt; requires some explanation. It&#13;
refers to a list of one or more transform functions, one after the&#13;
other, in space-separated format. It looks something like this, with the result&#13;
shown in <a data-type="xref" href="#tf_fig06">Figure 17-6</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">rotate</code><code class="p">(</code><code class="m">30deg</code><code class="p">)</code> <code class="n">skewX</code><code class="p">(</code><code class="m">-25deg</code><code class="p">)</code> <code class="n">scaleY</code><code class="p">(</code><code class="m">2</code><code class="p">);}</code></pre>&#13;
&#13;
<figure><div class="figure" id="tf_fig06">&#13;
<img alt="css5 1706" src="assets/css5_1706.png"/>&#13;
<h6><span class="label">Figure 17-6. </span>A transformed <code>&lt;div&gt;</code> element</h6>&#13;
</div></figure>&#13;
&#13;
<p>The functions are processed one at a time, starting with the first&#13;
(leftmost) and proceeding to the last (rightmost). This first-to-last&#13;
processing order is important, because changing the order can lead to&#13;
drastically different results. Consider the following two rules, which&#13;
have the results shown in <a data-type="xref" href="#tf_fig07">Figure 17-7</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nf">#one</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">translateX</code><code class="p">(</code><code class="m">200px</code><code class="p">)</code> <code class="n">rotate</code><code class="p">(</code><code class="m">45deg</code><code class="p">);}</code>&#13;
<code class="nt">img</code><code class="nf">#two</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">rotate</code><code class="p">(</code><code class="m">45deg</code><code class="p">)</code> <code class="n">translateX</code><code class="p">(</code><code class="m">200px</code><code class="p">);}</code></pre>&#13;
&#13;
<figure><div class="figure" id="tf_fig07">&#13;
<img alt="css5 1707" src="assets/css5_1707.png"/>&#13;
<h6><span class="label">Figure 17-7. </span>Different transform lists, different results</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first instance, an image is translated (moved) 200 pixels along&#13;
its x-axis and then rotated 45 degrees. In the second instance, an&#13;
image is rotated 45 degrees and then moved 200 pixels along its x-axis—that’s the x-axis of the transformed element, <em>not</em> of the parent&#13;
element, page, or viewport. In other words, when an element is rotated,&#13;
its x-axis (along with its other axes) rotates along with it. All&#13;
element transforms are conducted with respect to the element’s own frame&#13;
of reference.</p>&#13;
&#13;
<p>Note that when you have a series of transform functions, all of them&#13;
must be properly formatted; that is, they must be valid. If even one function is invalid, it renders the entire value invalid. Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nf">#one</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">translateX</code><code class="p">(</code><code class="m">100px</code><code class="p">)</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="o">.</code><code class="m">2</code><code class="p">)</code> <code class="n">rotate</code><code class="p">(</code><code class="m">22</code><code class="p">);}</code></pre>&#13;
&#13;
<p>Because the value for <code>rotate()</code> is invalid—rotational values must be an &lt;<em><code>angle</code></em>&gt;—the entire value is dropped. The image in question will just&#13;
sit there in its initial untransformed state, neither translated nor&#13;
scaled, let alone rotated.</p>&#13;
&#13;
<p>In addition, transforms are not usually cumulative. If you apply a transform to an element and then later want to add a transformation, you need to restate the original transform. Consider the following scenarios, illustrated in <a data-type="xref" href="#tf_fig08">Figure 17-8</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#ex01</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">rotate</code><code class="p">(</code><code class="m">30deg</code><code class="p">)</code> <code class="n">skewX</code><code class="p">(</code><code class="m">-25deg</code><code class="p">);}</code>&#13;
<code class="nf">#ex01</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">scaleY</code><code class="p">(</code><code class="m">2</code><code class="p">);}</code>&#13;
<code class="nf">#ex02</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">rotate</code><code class="p">(</code><code class="m">30deg</code><code class="p">)</code> <code class="n">skewX</code><code class="p">(</code><code class="m">-25deg</code><code class="p">);}</code>&#13;
<code class="nf">#ex02</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">rotate</code><code class="p">(</code><code class="m">30deg</code><code class="p">)</code> <code class="n">skewX</code><code class="p">(</code><code class="m">-25deg</code><code class="p">)</code> <code class="n">scaleY</code><code class="p">(</code><code class="m">2</code><code class="p">);}</code></pre>&#13;
&#13;
<figure><div class="figure" id="tf_fig08">&#13;
<img alt="css5 1708" src="assets/css5_1708.png"/>&#13;
<h6><span class="label">Figure 17-8. </span>Overwriting or modifying transforms</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first case, the second rule completely replaces the first,&#13;
meaning that the element is scaled only along the y-axis. This makes some sense; it’s the same as if you declare a font size and then&#13;
elsewhere declare a different font size for the same element. You don’t&#13;
get a cumulative font size that way. You just get one size or the other.&#13;
In the second example, the <a data-primary="scaleY() function" data-type="indexterm" id="idm45176043807584"/>entirety of the first set of transforms is&#13;
included in the second set, so they all are applied along with the&#13;
<code>scaleY()</code> function.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’re wishing for properties that apply to just a single type of transformation, such as a property that only rotates or a property that only scales elements, you’ll see some later in the chapter, so hang in there.</p>&#13;
</div>&#13;
&#13;
<p>There’s one <a data-primary="atomic inline-level boxes" data-type="indexterm" id="idm45176043804432"/><a data-primary="boxes" data-secondary="element boxes" data-tertiary="inline boxes" data-type="indexterm" id="idm45176043803728"/><a data-primary="elements" data-secondary="inline-level" data-type="indexterm" id="idm45176043802512"/><a data-primary="inline-level elements" data-type="indexterm" id="idm45176043764000"/>important caveat: as of this writing, transforms are not&#13;
applied to <em>atomic inline-level</em> boxes. These are inline boxes like&#13;
spans, hyperlinks, and so on. Those elements can be transformed if their&#13;
block-level parent is transformed, in which case they go along for the&#13;
ride. But you can’t just rotate a <code>&lt;span&gt;</code> unless you’ve changed its&#13;
display role via <code>display: block</code>, <code>display: inline-block</code>, or something&#13;
along those lines. The reason for this limitation boils down to an&#13;
uncertainty. Suppose you have a <code>&lt;span&gt;</code> (or any inline-level box) that&#13;
breaks across multiple lines. If you rotate it, what happens? Does each&#13;
line box rotate with respect to itself, or should all the line boxes be&#13;
rotated as a single group? There’s no clear answer, and the debate&#13;
continues, so for now you can’t directly transform inline-level boxes.<a data-primary="" data-startref="ix_transform_prop" data-type="indexterm" id="idm45176043761216"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Transform Functions" data-type="sect1"><div class="sect1" id="idm45176044027376">&#13;
<h1>The Transform Functions</h1>&#13;
&#13;
<p>CSS has 21 <a data-primary="transforms" data-secondary="functions used with" data-type="indexterm" id="ix_transform_func"/>transform functions, as of early 2023, employing various value patterns to get their jobs done. The following is a list of all the available transform functions, minus their value patterns:</p>&#13;
<table>&#13;
<tr>&#13;
<td>&#13;
<p><code>translate()</code><br/>&#13;
<code>translate3d()</code><br/>&#13;
<code>translateX()</code><br/>&#13;
<code>translateY()</code><br/>&#13;
<code>translateZ()</code></p>&#13;
</td><td>&#13;
<p><code>scale()</code><br/>&#13;
<code>scale3d()</code><br/>&#13;
<code>scaleX()</code><br/>&#13;
<code>scaleY()</code><br/>&#13;
<code>scaleZ()</code></p>&#13;
</td><td>&#13;
<p><code>rotate()</code><br/>&#13;
<code>rotate3d()</code><br/>&#13;
<code>rotateX()</code><br/>&#13;
<code>rotateY()</code><br/>&#13;
<code>rotateZ()</code></p>&#13;
</td><td>&#13;
<p><code>skew()</code><br/>&#13;
<code>skewX()</code><br/>&#13;
<code>skewY()</code></p>&#13;
</td><td>&#13;
<p><code>matrix()</code><br/>&#13;
<code>matrix3d()</code><br/>&#13;
<code>perspective()</code></p>&#13;
</td>&#13;
</tr>&#13;
</table>&#13;
&#13;
<p>We’ll tackle the most common types of transforms first, along with their associated properties if they exist, and then deal with the more obscure or difficult ones.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Translation" data-type="sect2"><div class="sect2" id="idm45176043742000">&#13;
<h2>Translation</h2>&#13;
&#13;
<p>A <em>translation transform</em> is just a <a data-primary="translateY() function" data-type="indexterm" id="idm45176043739536"/><a data-primary="translateX() function" data-type="indexterm" id="idm45176043738800"/>move along one or more axes. For&#13;
example, <code class="keep-together">translateX()</code> moves an element along its own x-axis,&#13;
<code>translateY()</code> moves it along its &#13;
<span class="keep-together">y-axis,</span> and <code>translateZ()</code> moves it along its z-axis.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043735760">&#13;
<h1>translateX(), translateY() functions</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>These are <a data-primary="distance values" data-type="indexterm" id="idm45176043730720"/>usually referred to as the 2D <em>translation functions</em>, since&#13;
they can slide an element up and down, or side to side, but not forward&#13;
or backward along the z-axis. Each of these functions accepts a single&#13;
distance value, expressed as either a length or a &#13;
<span class="keep-together">percentage.</span></p>&#13;
&#13;
<p>If the value is a length, the effect is about what you’d expect.&#13;
Translate an element 200 pixels along the x-axis with&#13;
<code>translateX(200px)</code>, and it will move 200 pixels to its right. Change&#13;
that to <code>translateX(-200px)</code>, and the element will move 200 pixels to its left. For <code>translateY()</code>, positive values move the element downward, while negative values move it upward.</p>&#13;
&#13;
<p>Keep in mind that translations are always declared&#13;
with respect to the element itself. Thus, for example, if&#13;
you flip the element upside down by rotation, positive <code>translateY()</code>&#13;
values will move the element downward on the page,&#13;
because that’s a move upward from the upside-down element’s point of view.</p>&#13;
&#13;
<p>If the <a data-primary="translate() function" data-type="indexterm" id="idm45176043726000"/>value is a percentage, the distance is calculated as a&#13;
percentage of the element’s own size. Thus, if an element is 300 pixels wide&#13;
and 200 pixels tall, <code>translateX(50%)</code> will move it 150 pixels to its right,&#13;
and <code>translateY(-10%)</code> will move that same element upward (with&#13;
respect to itself) by 20 pixels.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043724208">&#13;
<h1>translate() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] [<code>,</code> &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;]?</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If you want to translate an element along both the x- and y-axes at the&#13;
same time, <code>translate()</code> makes it easy. Just supply the x value&#13;
first and the y value second, separated by a comma, which is the same as if you included both a <code>translateX()</code> and a <code>translateY()</code>. If you omit the y value, it’s assumed to be 0. Thus, <code>translate(2em)</code> is treated as if it were <code>translate(2em,0)</code>, which is also the same as <code>translateX(2em)</code>. <a data-primary="translateZ() function" data-type="indexterm" id="idm45176043714336"/>See <a data-type="xref" href="#tf_fig09">Figure 17-9</a> for some examples of 2D translation.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig09">&#13;
<img alt="css5 1709" src="assets/css5_1709.png"/>&#13;
<h6><span class="label">Figure 17-9. </span>Translating in two dimensions</h6>&#13;
</div></figure>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043710736">&#13;
<h1>translateZ() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>translateZ()</code> function <a data-primary="translate3d() function" data-type="indexterm" id="idm45176043705376"/>translates elements along the z-axis, thus moving them into the third dimension. Unlike the 2D translation functions, <code>translateZ()</code> accepts only length values. Percentage values are <em>not</em> permitted for <code>translateZ()</code>, or indeed for any z-axis value.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043703072">&#13;
<h1>translate3d() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ], [ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;], [ &lt;<em><code>length</code></em>&gt; ]</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Much like <code>translate()</code> does for x and y translations, <code>translate3d()</code>&#13;
is a shorthand function that incorporates the x, y, and z translation&#13;
values into a single function. This is handy if you want to&#13;
move an element over, up, and forward in one fell swoop.</p>&#13;
&#13;
<p>See <a data-type="xref" href="#tf_fig10">Figure 17-10</a> for an illustration of how 3D translation works. Each arrow represents the translation along that axis, arriving at a point in 3D space. The dashed lines show the distance and direction from the origin point (the intersection of the three axes) and the distance above the x<em>y</em> plane.</p>&#13;
&#13;
<p>Unlike <code>translate()</code>, there is no fallback if <code>translate3d()</code> does not contain three values. Thus, <code>translate3d(1em,-50px)</code> should be treated as invalid by browsers, with no actual translation taking place as a result.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig10">&#13;
<img alt="css5 1710" src="assets/css5_1710.png"/>&#13;
<h6><span class="label">Figure 17-10. </span>Translating in three dimensions</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The translate property" data-type="sect3"><div class="sect3" id="idm45176043689712">&#13;
<h3>The translate property</h3>&#13;
&#13;
<p>When you <a data-primary="translate property" data-type="indexterm" id="idm45176043688048"/>want to translate an element without having to go through the <code>transform</code> property, you can use the <code>translate</code> property instead.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043686256">&#13;
<h1>translate</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>| <code>none</code> | [ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,2} &lt;<em><code>length</code></em>&gt;?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the corresponding size of the bounding box</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified, except for relative length values, which are converted to an absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>As a transform</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Very much like the <code>translate()</code> function, the <code>translate</code> property accepts from one to three length values, or two percentages and a length value, or more reduced patterns such as a single length.  Unlike the <code>translate()</code> function, the <code>transform</code> property does not use commas to separate its values.</p>&#13;
&#13;
<p>If only one value is given, it is used as an x-axis translation.  With two values, the first is the x-axis translation, and the second is the y-axis translation.  With three values, they are taken in the order <code>x y z</code>.  Any missing values default to <code>0px</code>.</p>&#13;
&#13;
<p>If you refer back to <a data-type="xref" href="#tf_fig09">Figure 17-9</a>, the following would yield the same results as are shown there:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">translate</code><code class="o">:</code> <code class="m">25px</code><code class="p">;</code>    <code class="c">/* equivalent to 25px 0px 0px */</code>&#13;
<code class="k">translate</code><code class="o">:</code> <code class="m">25%</code><code class="p">;</code>&#13;
<code class="k">translate</code><code class="o">:</code> <code class="m">0</code> <code class="m">25px</code><code class="p">;</code>  <code class="c">/* equivalent to 0 25px 0px */</code>&#13;
<code class="k">translate</code><code class="o">:</code> <code class="m">0</code> <code class="m">-25px</code><code class="p">;</code>&#13;
<code class="k">translate</code><code class="o">:</code> <code class="m">20%</code> <code class="m">20%</code><code class="p">;</code>&#13;
<code class="k">translate</code><code class="o">:</code> <code class="m">-20%</code> <code class="m">-20%</code><code class="p">;</code>&#13;
<code class="k">translate</code><code class="o">:</code> <code class="m">110%</code> <code class="m">25px</code><code class="p">;</code></pre>&#13;
&#13;
<p>Similarly, the following would have the same effect diagrammed in <a data-type="xref" href="#tf_fig10">Figure 17-10</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">translate</code><code class="o">:</code> <code class="m">150px</code> <code class="m">-50px</code> <code class="m">100px</code><code class="p">;</code></pre>&#13;
&#13;
<p>The default value, <code>none</code>, means that no translation is applied.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scaling" data-type="sect2"><div class="sect2" id="idm45176043741504">&#13;
<h2>Scaling</h2>&#13;
&#13;
<p>A <em>scale transform</em> makes an <a data-primary="scaleX() function" data-type="indexterm" id="idm45176043620784"/><a data-primary="scaleY() function" data-type="indexterm" id="idm45176043584832"/><a data-primary="scaleZ() function" data-type="indexterm" id="idm45176043584160"/>element larger or smaller, depending on the value you supply. These values are unitless real numbers, either positive or negative.&#13;
On the 2D plane, you can scale along the x- and y-axes&#13;
individually or scale them together.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043583232">&#13;
<h1>scaleX(), scaleY(), scaleZ() functions</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>A number <a data-primary="scale() function" data-type="indexterm" id="idm45176043578000"/>value supplied to a scale function is a multiplier; thus,&#13;
<code>scaleX(2)</code> will make an element twice as wide as it was before the&#13;
transformation, whereas <code class="keep-together">scaleY(0.5)</code> will make it half as tall.  Percentage values are equivalent to number values at a ratio of 100:1; that is, <code>50%</code> will have the same effect as <code>0.5</code>, and <code>200%</code> will have the same effect as <code>2</code>, and &#13;
<span class="keep-together">so on.</span></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043554176">&#13;
<h1>scale() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] [<code>,</code>  &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]?</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If you want to scale along both axes simultaneously, use <code>scale()</code>. The&#13;
x value is always first, and the y always second, so <code>scale(2,0.5)</code> will&#13;
make the element twice as wide and half as tall as it was before being&#13;
transformed. If you supply only one number, it is used as the scaling&#13;
value for both axes; thus, <code>scale(2)</code> will make the element twice as&#13;
wide <em>and</em> twice as tall. This is in contrast to <code>translate()</code>, where an&#13;
omitted second value is always set to 0. Using <code>scale(1)</code> will scale an&#13;
element to be exactly the same size it was before you scaled it, as will&#13;
<code>scale(1,1)</code>—just in case you were dying to do that.</p>&#13;
&#13;
<p><a data-type="xref" href="#tf_fig11">Figure 17-11</a> shows a few examples of element scaling, using the&#13;
single-axis scaling functions as well as the combined <code>scale()</code>.</p>&#13;
&#13;
<p>If you <a data-primary="scale3d() function" data-type="indexterm" id="idm45176043542208"/>can scale in two dimensions, you can also scale in&#13;
three. CSS offers <code>scaleZ()</code> for scaling just along the z-axis, and&#13;
<code>scale3d()</code> for scaling along all three axes at once. These have an effect only if the element has any depth, which elements don’t by&#13;
default. If you do make a change that conveys depth—say, rotating an&#13;
element around the x- or y-axis—then there is a depth that can be scaled,&#13;
and either <code>scaleZ()</code> or <code>scale3d()</code> can do so.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig11">&#13;
<img alt="css5 1711" src="assets/css5_1711.png"/>&#13;
<h6><span class="label">Figure 17-11. </span>Scaled elements</h6>&#13;
</div></figure>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043537680">&#13;
<h1>scale3d() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>,</code> [ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>,</code> [ &lt;<em><code>number</code></em>&gt; | <br/>&lt;<em><code>percentage</code></em>&gt; ]</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Similar to <code>translate3d()</code>, the <code>scale3d()</code> function requires all three numbers to be valid. If you fail to do this, the malformed <code>scale3d()</code> will invalidate the entire transform value to which it belongs.</p>&#13;
&#13;
<p>Also note that scaling an element will change the effective distance&#13;
of any translations.  For example, the following will cause the element to be translated 50 pixels to its right:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">)</code> <code class="n">translateX</code><code class="p">(</code><code class="m">100px</code><code class="p">);</code></pre>&#13;
&#13;
<p>This is because the element is shrunk by 50%, and then moved to the right by 100 pixels <em>within its own frame of reference</em>, which is half-size.  Switch the order of the functions, and the element will be translated 100 pixels to its right and then shrunk 50% from that spot.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The scale property" data-type="sect3"><div class="sect3" id="idm45176043514240">&#13;
<h3>The scale property</h3>&#13;
&#13;
<p>Also <a data-primary="scale property" data-type="indexterm" id="idm45176043512720"/>similarly to translation, the <code>scale</code> property allows you to scale elements up or down without having to use the <code>transform</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043510928">&#13;
<h1>scale</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | [ &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>number</code></em>&gt; ]{1,3}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the corresponding size of the bounding box</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>As a transform</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The way <code>scale</code> handles its values differs little from the <code>translate</code> property.  If you give only one value, such as <code>scale(2)</code>, that value is used to scale in both the x and y directions.  With two values, the first is used to scale in the x-axis direction, and the second in the y-axis direction.  With three values, the third is used to scale in the z-axis direction.</p>&#13;
&#13;
<p>The following would have the same results as shown in <a data-type="xref" href="#tf_fig11">Figure 17-11</a>.</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">scale</code><code class="o">:</code> <code class="m">2</code> <code class="m">1</code><code class="p">;</code>   <code class="c">/* equivalent to 200% 100% */</code>&#13;
<code class="k">scale</code><code class="o">:</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code> <code class="m">1</code><code class="p">;</code> <code class="c">/* equivalent to 50% 100% */</code>&#13;
<code class="k">scale</code><code class="o">:</code> <code class="m">1</code> <code class="m">2</code><code class="p">;</code>&#13;
<code class="k">scale</code><code class="o">:</code> <code class="m">1</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">;</code>&#13;
<code class="k">scale</code><code class="o">:</code> <code class="m">1</code><code class="o">.</code><code class="m">5</code><code class="p">;</code>&#13;
<code class="k">scale</code><code class="o">:</code> <code class="m">1</code><code class="o">.</code><code class="m">5</code><code class="p">;</code>&#13;
<code class="k">scale</code><code class="o">:</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code> <code class="m">1</code><code class="o">.</code><code class="m">5</code><code class="p">;</code>&#13;
<code class="k">scale</code><code class="o">:</code> <code class="m">1</code> <code class="m">5</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">;</code></pre>&#13;
&#13;
<p>The default value, <code>none</code>, means that no scaling is applied.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Element Rotation" data-type="sect2"><div class="sect2" id="element_rotation">&#13;
<h2>Element Rotation</h2>&#13;
&#13;
<p>A <em>rotation function</em> causes an <a data-primary="rotate() function" data-type="indexterm" id="idm45176043422528"/><a data-primary="rotateX() function" data-type="indexterm" id="idm45176043421792"/><a data-primary="rotateY() function" data-type="indexterm" id="idm45176043421120"/><a data-primary="rotateZ() function" data-type="indexterm" id="idm45176043420448"/>element to be rotated around an axis, or&#13;
around an arbitrary vector in 3D space. CSS has four simple rotation&#13;
functions, and one less-simple function meant specifically for 3D.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043419520">&#13;
<h1>rotate(), rotateX(), rotateY(), rotateZ() functions</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p>&lt;<em><code>angle</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>All four basic rotation functions accept just one value: an angle. This&#13;
can be expressed using a number, either positive or negative, and then&#13;
any of the valid angle units (<code>deg</code>, <code>grad</code>,&#13;
<code>rad</code>, and <code>turn</code>). (See <a data-type="xref" href="ch05.html#angles">“Angles”</a> for more details.) If a&#13;
value’s number runs outside the usual range for the given unit, it will&#13;
look as if it were given a value in the allowed range. In other words, a value of&#13;
<code>437deg</code> will be tilted the same as if it were <code>77deg</code>, or, for that&#13;
matter, <code>-283deg</code>.</p>&#13;
&#13;
<p>Note, however, <a data-primary="animation" data-secondary="of transforms" data-secondary-sortas="transforms" data-type="indexterm" id="idm45176043364880"/><a data-primary="transforms" data-secondary="animated" data-type="indexterm" id="idm45176043363600"/>that these are visually equivalent only if you don’t&#13;
animate the rotation in some fashion. That is to say, animating a&#13;
rotation of <code>1100deg</code> will spin the element around several times before&#13;
coming to rest at a tilt of –20 degrees (or 340 degrees, if you like).&#13;
By contrast, animating a rotation of <code>-20deg</code> will tilt the element a&#13;
bit to the left, with no spinning; and animating a rotation of&#13;
<code>340deg</code> will animate an almost full spin to the right. All three&#13;
animations come to the same end state, but the process of getting there&#13;
is very different in each case.</p>&#13;
&#13;
<p>The <code>rotate()</code> function is a straight 2D rotation, and the one you’re&#13;
most likely to use. It is visually equivalent to <code>rotateZ()</code> because it rotates the element around the z-axis. In a similar manner, <code>rotateX()</code> causes rotation around the x-axis, thus causing the element to tilt toward or away from you; and <code>rotateY()</code> rotates the element around its y-axis, as though it were a door. These are all illustrated in <a data-type="xref" href="#tf_fig12">Figure 17-12</a>.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig12">&#13;
<img alt="css5 1712" src="assets/css5_1712.png"/>&#13;
<h6><span class="label">Figure 17-12. </span>Rotations around the three axes</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Several of the examples in <a data-type="xref" href="#tf_fig12">Figure 17-12</a> present a fully 3D&#13;
appearance. This is possible with certain values of the <code>transform-style</code> and <code>perspective</code> properties, described in <a data-type="xref" href="#choosing-a-3d-style">“Choosing a 3D Style”</a> and <a data-type="xref" href="#changing-perspective">“Changing Perspective”</a> and omitted here for clarity. <a data-primary="rotate3d() function" data-type="indexterm" id="ix_rotate_3d_func"/>This will be true throughout this text anytime 3D-transformed elements appear to be fully three-dimensional. This is important to keep in mind because if you just try to apply the transform functions shown, you won’t get the same visual results as in the figures.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043349520">&#13;
<h1>rotate3d() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt;, &lt;<em><code>number</code></em>&gt;, &lt;<em><code>number</code></em>&gt;, &lt;<em><code>angle</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If you’re comfortable with vectors and want to rotate an element through&#13;
3D space, <code>rotate3d()</code> is for you. The first three numbers specify&#13;
the x, y, and z components of a vector in 3D space, and the degree value (angle) determines the amount of rotation around the declared 3D vector.</p>&#13;
&#13;
<p>To start with a basic example, the 3D equivalent of <code>rotateZ(45deg)</code> is&#13;
<code>rotate3d(0,0,1,45deg)</code>. This specifies a vector of zero magnitude on&#13;
the x- and y-axes, and a magnitude of 1 along the z-axis; in other words, the z-axis. The element is thus rotated 45 degrees around that vector, as shown in <a data-type="xref" href="#tf_fig13">Figure 17-13</a>. This figure also shows the appropriate <code>rotate3d()</code> values to rotate an element by 45 degrees around the x- and y-axes.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig13">&#13;
<img alt="css5 1713" src="assets/css5_1713.png"/>&#13;
<h6><span class="label">Figure 17-13. </span>Rotations around 3D vectors</h6>&#13;
</div></figure>&#13;
&#13;
<p>A little more complicated is something like&#13;
<code>rotate3d(-0.95,0.5,1,45deg)</code>, where the described vector points off into 3D space between the axes. To understand how this works,&#13;
let’s start with a basic example: <code>rotateZ(45deg)</code> (illustrated in&#13;
<a data-type="xref" href="#tf_fig13">Figure 17-13</a>). The equivalent is <code>rotate3d(0,0,1,45deg)</code>. The first three&#13;
numbers describe the components of a vector that has no x or y&#13;
magnitude, and a z magnitude of 1. Thus, it points along the z-axis in a&#13;
positive direction—that is, toward the viewer. The element is then&#13;
rotated clockwise as you look toward the origin of the vector.</p>&#13;
&#13;
<p>Similarly, the 3D equivalent of <code>rotateX(45deg)</code> is&#13;
<code>rotate3d(1,0,0,45deg)</code>. The vector points along the x-axis in the&#13;
positive direction (to the right). If you stand at the end of that vector&#13;
and look toward its origin, you rotate the element 45 degrees&#13;
clockwise around the vector. Thus, from the usual viewer placement, the&#13;
top of the element rotates away from, and the bottom rotates toward, the&#13;
viewer.</p>&#13;
&#13;
<p>Now let’s make the example slightly more complex: suppose you have&#13;
<code>rotate3d(1,1,0,45deg)</code>. When viewed on your monitor, that describes a&#13;
vector running from the top-left to bottom-right corner, going right through&#13;
the center of the element (by default, anyway; we’ll see how to change&#13;
that later). So the element’s rectangle has a line running through it&#13;
at a 45-degree angle, effectively spearing it. Then the vector rotates&#13;
45 degrees, taking the element with it. The rotation is clockwise as you&#13;
look back toward the vector’s origin, so again, the top of the element&#13;
rotates away from the viewer, while the bottom rotates toward the viewer. If we were to change the rotation to <code>rotate3d(1,1,0,90deg)</code>, the element would be edge-on to the viewer, tilted at a 45-degree angle and facing off toward the upper right. Try it with a piece of paper: draw a line from the top left to bottom right, and then rotate the paper around that line.</p>&#13;
&#13;
<p>OK, so given all of that, now try visualizing how the vector is determined&#13;
for <code>rotate3d(-0.95,0.5,1,45deg)</code>. If we assume a cube 200 pixels on a&#13;
side, the vector’s components are 190 pixels to the <em>left</em> along the x-axis, 100 pixels down along the y-axis, and 200 pixels toward the views&#13;
along the z-axis. The vector goes from the origin point (0, 0, 0) to the point (–190 px, 100 px, 200 px). <a data-type="xref" href="#tf_fig14">Figure 17-14</a> depicts that vector, as well as the final result presented to the viewer.</p>&#13;
&#13;
<p>So the vector is like a metal rod speared through the element being&#13;
rotated. As we look back along the line of the vector, the rotation is&#13;
45 degrees clockwise. But since the vector points left, down, and&#13;
forward, that means the top-left corner of the element rotates toward&#13;
the viewer, and the bottom right rotates away, as shown in <a data-type="xref" href="#tf_fig14">Figure 17-14</a>.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig14">&#13;
<img alt="css5 1714" src="assets/css5_1714.png"/>&#13;
<h6><span class="label">Figure 17-14. </span>Rotation around a 3D vector, and how that vector is determined</h6>&#13;
</div></figure>&#13;
&#13;
<p>Just to be crystal clear, <code>rotate3d(1,1,0,45deg)</code> is <em>not</em> equivalent to&#13;
<code>rotateX(45deg) rotateY(45deg) rotateZ(0deg)</code>! It’s an easy mistake to&#13;
make, and many people—including your humble&#13;
correspondent—have made it. It seems like it should be equivalent, but it really&#13;
isn’t. If we place that vector inside the imaginary 200 × 200 × 200 cube&#13;
previously mentioned, the axis of rotation would go from the origin&#13;
point to a point 200 pixels right and 200 pixels down (200, 200, 0).</p>&#13;
&#13;
<p>Having done that, the axis of rotation is shooting through the element&#13;
from the top left to the bottom right, at a 45-degree angle. The element&#13;
then rotates 45 degrees clockwise around that diagonal, as you look back&#13;
toward its origin (the top left), which rotates the top-right corner of&#13;
the element away and a bit to the left, while the bottom-left corner&#13;
rotates closer and a bit to the right. <a data-primary="" data-startref="ix_rotate_3d_func" data-type="indexterm" id="idm45176043326128"/>This is distinctly different from&#13;
the result of <code>rotateX(45deg) rotateY(45deg) rotateZ(0deg)</code>, as you can&#13;
see in <a data-type="xref" href="#tf_fig15">Figure 17-15</a>.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig15">&#13;
<img alt="css5 1715" src="assets/css5_1715.png"/>&#13;
<h6><span class="label">Figure 17-15. </span>The difference between rotating around a 3D axis and rotating in sequence around three different axes</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The rotate property" data-type="sect3"><div class="sect3" id="idm45176043321472">&#13;
<h3>The rotate property</h3>&#13;
&#13;
<p>As with <a data-primary="rotate property" data-type="indexterm" id="ix_rotate_prop"/>translations and scaling, CSS has a <code>rotate</code> property that allows you to rotate elements around various axes without having to use the <code>transform</code> property to do so.  The value syntax to make that possible is a bit different, however.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043317472">&#13;
<h1>rotate</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | &lt;<em><code>angle</code></em>&gt; | [ <code>x</code> | <code>y</code> | <code>z</code> | &lt;<em><code>number</code></em>&gt;{3} ] &amp;&amp; &lt;<em><code>angle</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the corresponding size of the bounding box</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>As a transform</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The valid values are divided into three mutually exclusive syntax options.&#13;
The simplest is that the default value of <code>none</code> means no rotation is applied.</p>&#13;
&#13;
<p>If you want to rotate around a single axis, it’s easiest to give the axis identifier along with the angle you want to rotate.  In the following code, each line contains two equivalent ways of rotating an element around a given axis:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">transform</code><code class="o">:</code> <code class="n">rotateX</code><code class="p">(</code><code class="m">45deg</code><code class="p">);</code>    <code class="k">rotate</code><code class="o">:</code> <code class="n">x</code> <code class="m">45deg</code><code class="p">;</code>&#13;
<code class="k">transform</code><code class="o">:</code> <code class="n">rotateY</code><code class="p">(</code><code class="m">33deg</code><code class="p">);</code>    <code class="k">rotate</code><code class="o">:</code> <code class="n">y</code> <code class="m">33deg</code><code class="p">;</code>&#13;
<code class="k">transform</code><code class="o">:</code> <code class="n">rotateZ</code><code class="p">(</code><code class="m">-45deg</code><code class="p">);</code>   <code class="k">rotate</code><code class="o">:</code> <code class="n">z</code> <code class="m">-45deg</code><code class="p">;</code>&#13;
<code class="k">transform</code><code class="o">:</code> <code class="n">rotate</code><code class="p">(</code><code class="m">90deg</code><code class="p">);</code>     <code class="k">rotate</code><code class="o">:</code> <code class="m">90deg</code><code class="p">;</code></pre>&#13;
&#13;
<p>The last line is similar to the handling of the <code>rotate()</code> function discussed earlier: a rotation with a single degree value is a 2D rotation on the <em>xy</em> plane.  (See <a data-type="xref" href="#tf_fig12">Figure 17-12</a> for a refresher.)</p>&#13;
&#13;
<p>If you want to define a 3D vector as the axis of rotation, the value of <code>rotate</code> looks a little different.  For example, suppose we want to rotate an element 45 degrees around the vector –0.95, 0.5, 1, as illustrated in <a data-type="xref" href="#tf_fig14">Figure 17-14</a>.  Either of the following two declarations will have this effect:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">transform</code><code class="o">:</code> <code class="n">rotate3d</code><code class="p">(</code><code class="m">-0</code><code class="o">.</code><code class="m">95</code><code class="o">,</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="o">,</code> <code class="m">1</code><code class="o">,</code> <code class="m">45deg</code><code class="p">);</code>&#13;
<code class="k">rotate</code><code class="o">:</code> <code class="m">-0</code><code class="o">.</code><code class="m">95</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code> <code class="m">1</code> <code class="m">45deg</code><code class="p">;</code></pre>&#13;
&#13;
<p>If you want, you can use this pattern to rotate around the cardinal axes; that is, <code>rotate: z 23deg</code> and <code>rotate: 0 0 1 23deg</code> will have that same effect (as will <code>rotate: 23deg</code>).  This can be useful when changing the vector of rotation via JavaScript, but is rarely useful in other cases.</p>&#13;
&#13;
<p>Note that <code>transform</code> has a power that <code>rotate</code> cannot duplicate: the ability to chain rotations in sequence.  For example, <code>transform: rotateZ(20deg) rotateY(30deg)</code> will first rotate the element 20 degrees around the z-axis, and then the result of that rotation is rotated around the y-axis.  The <code>rotate</code> property can do only one or the other of these on its own.  The only way to get the same result is to figure out the vector and angle that will leave the element in the same state as the <code>transform</code> operation did.  The math to do that certainly exists, but is outside the scope of this book (although see <a data-type="xref" href="#matrix_functions">“Matrix Functions”</a>).<a data-primary="" data-startref="ix_rotate_prop" data-type="indexterm" id="idm45176043187600"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Individual Transform Property Order" data-type="sect2"><div class="sect2" id="idm45176043424400">&#13;
<h2>Individual Transform Property Order</h2>&#13;
&#13;
<p>When using the <a data-primary="transforms" data-secondary="order of individual properties" data-type="indexterm" id="idm45176043185856"/>individual transform properties, the effects are always applied in the order <code>translate</code>, then <code>rotate</code>, then <code>scale</code>. <a data-primary="scale property" data-type="indexterm" id="idm45176043152608"/><a data-primary="translate property" data-type="indexterm" id="idm45176043152000"/>The following two rules are functionally equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#mover</code> <code class="p">{</code>&#13;
	<code class="k">rotate</code><code class="o">:</code> <code class="m">30deg</code><code class="p">;</code>&#13;
	<code class="k">scale</code><code class="o">:</code> <code class="m">1</code><code class="o">.</code><code class="m">5</code> <code class="m">1</code><code class="p">;</code>&#13;
	<code class="k">translate</code><code class="o">:</code> <code class="m">10rem</code><code class="p">;}</code>&#13;
&#13;
<code class="nf">#mover</code> <code class="p">{</code>&#13;
	<code class="k">transform</code><code class="o">:</code> <code class="n">translate</code><code class="p">(</code><code class="m">10rem</code><code class="p">)</code> <code class="n">rotate</code><code class="p">(</code><code class="m">30deg</code><code class="p">)</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="o">.</code><code class="m">5</code><code class="o">,</code> <code class="m">1</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This matters because, for example, translating and then rotating is very different from rotating and then translating.  If you need to have an element’s transforms happen in an order other than transform-rotate-scale, use <code>transform</code> instead of the individual &#13;
<span class="keep-together">properties.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Skewing" data-type="sect2"><div class="sect2" id="idm45176043087200">&#13;
<h2>Skewing</h2>&#13;
&#13;
<p>When you <em>skew</em> an <a data-primary="skewX() function" data-type="indexterm" id="idm45176043078784"/><a data-primary="skewY() function" data-type="indexterm" id="idm45176043078176"/>element, you slant it along one or both of the x- and y-axes. There is no z-axis or 3D skewing.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043077200">&#13;
<h1>skewX(), skewY() functions</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p>&lt;<em><code>angle</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>In <a data-primary="skew() function" data-type="indexterm" id="idm45176043072864"/>both cases, you supply an angle value, and the element is skewed to&#13;
match that angle. It’s much easier to show skewing rather than try to&#13;
explain it in words, so <a data-type="xref" href="#tf_fig16">Figure 17-16</a> shows skew examples along the x- and y-axes.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig16">&#13;
<img alt="css5 1716" src="assets/css5_1716.png"/>&#13;
<h6><span class="label">Figure 17-16. </span>Skewing along the x- and y-axes</h6>&#13;
</div></figure>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043069136">&#13;
<h1>skew() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>angle</code></em>&gt; [<code>,</code> &lt;<em><code>angle</code></em>&gt; ]?</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Using <code>skew(a,b)</code> is different from including <code>skewX(a)</code> with <code>skewY(b)</code>. The former specifies a 2D skew using the matrix operation <code>[ax,ay]</code>. <a data-type="xref" href="#tf_fig17">Figure 17-17</a> shows examples of this matrix skewing and how they differ from double-skew transforms that look the same at first but aren’t.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>For a variety of reasons, including the way <code>skew(a,b)</code> is different from <code>skewX(a) skewY(b)</code>, the CSS specification explicitly discourages the use of <code>skew()</code>.  You should avoid using it if at all possible; we document it here in case you find yourself coming across it in legacy code.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="tf_fig17">&#13;
<img alt="css5 1717" src="assets/css5_1717.png"/>&#13;
<h6><span class="label">Figure 17-17. </span>Skewed elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you supply two values, the x skew angle is always first, and the y&#13;
skew angle comes second. If you leave out a y skew angle, it’s treated as 0.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Unlike for translation, rotation, and scaling, CSS has no <code>skew</code> property as of late 2022, so any skewing has to be managed via the <code>transform</code> property.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Matrix Functions" data-type="sect2"><div class="sect2" id="matrix_functions">&#13;
<h2>Matrix Functions</h2>&#13;
&#13;
<p>If you’re a <a data-primary="matrix() function" data-type="indexterm" id="ix_matrix_func"/>particular fan of advanced math, or stale jokes derived from&#13;
the Wachowski siblings’ movies, the matrix functions will be your favorites. CSS has no <code>matrix</code> properties, to be clear.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176043050112">&#13;
<h1>matrix() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt; [<code>,</code> &lt;<em><code>number</code></em>&gt; ]{5,5}</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>In the CSS transforms specification, we find the trenchant description&#13;
of <code>matrix()</code> as a function that “specifies a 2D transformation in the&#13;
form of a transformation matrix of the six values <em>a</em>–<em>f</em>.”</p>&#13;
&#13;
<p>First things first: a valid <code>matrix()</code> value is a list of six&#13;
comma-separated numbers. No more, no less. The values can be positive or&#13;
negative. Second, the value describes the final transformed state of the&#13;
element, combining all of the other transform types (rotation, skewing,&#13;
and so on) into a compact syntax. Third, very few people use&#13;
this syntax to write code themselves, though it is often generated by drawing or animation software.</p>&#13;
&#13;
<p>We’re not going to go through the complicated process of&#13;
doing the matrix math. For most readers, it would be an&#13;
eye-watering wall of apparent gibberish; for the rest, it would be&#13;
time wasted on familiar territory. You can certainly research the&#13;
intricacies of matrix calculations online, and we encourage anyone with&#13;
an interest to do so. We’ll just look at the basics of syntax and usage&#13;
in CSS.</p>&#13;
&#13;
<p>Here’s a brief rundown of how it works. Say you have this function&#13;
applied to an <span class="keep-together">element:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">matrix</code><code class="p">(</code><code class="m">0</code><code class="o">.</code><code class="m">838671</code><code class="o">,</code> <code class="m">0</code><code class="o">.</code><code class="m">544639</code><code class="o">,</code> <code class="m">-0</code><code class="o">.</code><code class="m">692519</code><code class="o">,</code> <code class="m">0</code><code class="o">.</code><code class="m">742636</code><code class="o">,</code> <code class="m">6</code><code class="o">.</code><code class="m">51212</code><code class="o">,</code> <code class="m">34</code><code class="o">.</code><code class="m">0381</code><code class="p">)</code></pre>&#13;
&#13;
<p>That’s the CSS syntax used to describe this transformation matrix:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="m">0</code><code class="o">.</code><code class="m">838671</code>    <code class="m">-0</code><code class="o">.</code><code class="m">692519</code>   <code class="m">0</code>   <code class="m">6</code><code class="o">.</code><code class="m">51212</code>&#13;
<code class="m">0</code><code class="o">.</code><code class="m">544639</code>     <code class="m">0</code><code class="o">.</code><code class="m">742636</code>   <code class="m">0</code>   <code class="m">34</code><code class="o">.</code><code class="m">0381</code>&#13;
<code class="m">0</code>            <code class="m">0</code>          <code class="m">1</code>   <code class="m">0</code>&#13;
<code class="m">0</code>            <code class="m">0</code>          <code class="m">0</code>   <code class="m">1</code></pre>&#13;
&#13;
<p>Right. So what does that do? It has the result shown in <a data-type="xref" href="#tf_fig20">Figure 17-18</a>, which&#13;
is exactly the same result as writing this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">rotate</code><code class="p">(</code><code class="m">33deg</code><code class="p">)</code> <code class="n">translate</code><code class="p">(</code><code class="m">24px</code><code class="o">,</code><code class="m">25px</code><code class="p">)</code> <code class="n">skewX</code><code class="p">(</code><code class="m">-10deg</code><code class="p">)</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="tf_fig20">&#13;
<img alt="css5 1718" src="assets/css5_1718.png"/>&#13;
<h6><span class="label">Figure 17-18. </span>A matrix-transformed element and its functional equivalent</h6>&#13;
</div></figure>&#13;
&#13;
<p>What this comes down to is that if you’re familiar with or need to use matrix calculations, you can and should. Otherwise, you can chain much more human-readable transform functions together and get the element to the same end state.</p>&#13;
&#13;
<p>Now, <a data-primary="matrix3d() function" data-type="indexterm" id="idm45176042913296"/>that was for plain old 2D transforms. What if you want to use a&#13;
matrix to transform through three dimensions?</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176042912176">&#13;
<h1>matrix3d() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt; <code>[,</code> &lt;<em><code>number</code></em>&gt; <code>]{15,15}</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Again, just for kicks, we’ll savor the definition of <code>matrix3d()</code> from&#13;
the CSS Transforms specification: “specifies a 3D transformation as a&#13;
4 × 4 homogeneous matrix of 16 values in column-major order.” This means the parameter of <code>matrix3d()</code> <em>must</em> be a list of 16 comma-separated numbers, no more or less. Those numbers are arranged in a 4 × 4 grid in column order, so the first column of the matrix is formed by the first set of four numbers in the value, the second column by the second set of four numbers, the third column by the third set, and so on. Thus, you can take the following function,</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">matrix3d</code><code class="p">(</code>&#13;
    <code class="m">0</code><code class="o">.</code><code class="m">838671</code><code class="o">,</code> <code class="m">0</code><code class="o">,</code> <code class="m">-0</code><code class="o">.</code><code class="m">544639</code><code class="o">,</code> <code class="m">0</code><code class="o">.</code><code class="m">00108928</code><code class="o">,</code>&#13;
    <code class="m">-0</code><code class="o">.</code><code class="m">14788</code><code class="o">,</code> <code class="m">1</code><code class="o">,</code> <code class="m">0</code><code class="o">.</code><code class="m">0960346</code><code class="o">,</code> <code class="m">-0</code><code class="o">.</code><code class="m">000192069</code><code class="o">,</code>&#13;
    <code class="m">0</code><code class="o">.</code><code class="m">544639</code><code class="o">,</code> <code class="m">0</code><code class="o">,</code> <code class="m">0</code><code class="o">.</code><code class="m">838671</code><code class="o">,</code> <code class="m">-0</code><code class="o">.</code><code class="m">00167734</code><code class="o">,</code>&#13;
    <code class="m">20</code><code class="o">.</code><code class="m">1281</code><code class="o">,</code> <code class="m">25</code><code class="o">,</code> <code class="m">-13</code><code class="o">.</code><code class="m">0713</code><code class="o">,</code> <code class="m">1</code><code class="o">.</code><code class="m">02614</code><code class="p">)</code></pre>&#13;
&#13;
<p>and write it out as this matrix:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting">  <code class="m">0</code><code class="o">.</code><code class="m">838671</code>   <code class="m">-0</code><code class="o">.</code><code class="m">14788</code>        <code class="m">0</code><code class="o">.</code><code class="m">544639</code>     <code class="m">20</code><code class="o">.</code><code class="m">1281</code>&#13;
  <code class="m">0</code>           <code class="m">1</code>              <code class="m">0</code>            <code class="m">25</code>&#13;
 <code class="m">-0</code><code class="o">.</code><code class="m">544639</code>    <code class="m">0</code><code class="o">.</code><code class="m">0960346</code>      <code class="m">0</code><code class="o">.</code><code class="m">838671</code>    <code class="m">-13</code><code class="o">.</code><code class="m">0713</code>&#13;
  <code class="m">0</code><code class="o">.</code><code class="m">00108928</code> <code class="m">-0</code><code class="o">.</code><code class="m">000192069</code>   <code class="m">-0</code><code class="o">.</code><code class="m">00167734</code>   <code class="m">1</code><code class="o">.</code><code class="m">02614</code></pre>&#13;
&#13;
<p>Both have an end state equivalent to the following, which is depicted in <a data-type="xref" href="#tf_fig21">Figure 17-19</a>.</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">perspective</code><code class="p">(</code><code class="m">500px</code><code class="p">)</code> <code class="n">rotateY</code><code class="p">(</code><code class="m">33deg</code><code class="p">)</code> <code class="n">translate</code><code class="p">(</code><code class="m">24px</code><code class="o">,</code><code class="m">25px</code><code class="p">)</code> <code class="n">skewX</code><code class="p">(</code><code class="m">-10deg</code><code class="p">)</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="tf_fig21">&#13;
<img alt="css5 1719" src="assets/css5_1719.png"/>&#13;
<h6><span class="label">Figure 17-19. </span>A <code>matrix3d()</code>-transformed element and its functional equivalent</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A note on end-state equivalence" data-type="sect3"><div class="sect3" id="idm45176042693616">&#13;
<h3>A note on end-state equivalence</h3>&#13;
&#13;
<p>It’s <a data-primary="transforms" data-secondary="end-state equivalence" data-type="indexterm" id="idm45176042691856"/>important to keep in mind that only the end states of a <code>matrix()</code>&#13;
function, and of an equivalent chain of transform functions, can be&#13;
considered identical. This is for the same reason discussed in <a data-type="xref" href="#element_rotation">“Element Rotation”</a>: because a rotation angle of <code>393deg</code> will end&#13;
with the same visible rotation as an angle of <code>33deg</code>. <a data-primary="animation" data-secondary="of transforms" data-secondary-sortas="transforms" data-type="indexterm" id="idm45176042688704"/><a data-primary="transforms" data-secondary="animated" data-type="indexterm" id="idm45176042687424"/>This matters if&#13;
you are animating the transformation, since the former will cause the&#13;
element to do a barrel roll in the animation, whereas the latter will&#13;
not. The <code>matrix()</code> version of this end state won’t include the barrel&#13;
roll, either. Instead, it will always use the shortest possible rotation&#13;
to reach the end state.</p>&#13;
&#13;
<p>To illustrate what this means, consider the following, a transform chain&#13;
and its <code>matrix()</code> equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">rotate</code><code class="p">(</code><code class="m">200deg</code><code class="p">)</code> <code class="n">translate</code><code class="p">(</code><code class="m">24px</code><code class="o">,</code><code class="m">25px</code><code class="p">)</code> <code class="n">skewX</code><code class="p">(</code><code class="m">-10deg</code><code class="p">)</code>&#13;
<code class="n">matrix</code><code class="p">(</code><code class="m">-0</code><code class="o">.</code><code class="m">939693</code><code class="o">,</code> <code class="m">-0</code><code class="o">.</code><code class="m">34202</code><code class="o">,</code> <code class="m">0</code><code class="o">.</code><code class="m">507713</code><code class="o">,</code> <code class="m">-0</code><code class="o">.</code><code class="m">879385</code><code class="o">,</code> <code class="m">-14</code><code class="o">.</code><code class="m">0021</code><code class="o">,</code> <code class="m">-31</code><code class="o">.</code><code class="m">7008</code><code class="p">)</code></pre>&#13;
&#13;
<p>Note the rotation of 200 degrees. We naturally interpret this to mean a&#13;
clockwise rotation of 200 degrees, which it is. If these two&#13;
transforms are animated, however, they will act differently: the&#13;
chained-functions version will indeed rotate 200 degrees clockwise,&#13;
whereas the <code>matrix()</code> version will rotate 160 degrees counterclockwise.&#13;
Both will end up in the same place but will get there in different&#13;
ways.</p>&#13;
&#13;
<p>Other differences can arise even when you might think they&#13;
wouldn’t. Once again, this is because a <code>matrix()</code> transformation will&#13;
always take the shortest possible route to the end state, whereas a&#13;
transform chain might not. (In fact, it probably doesn’t.) Consider&#13;
these apparently equivalent transforms:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">rotate</code><code class="p">(</code><code class="m">160deg</code><code class="p">)</code> <code class="n">translate</code><code class="p">(</code><code class="m">24px</code><code class="o">,</code><code class="m">25px</code><code class="p">)</code> <code class="n">rotate</code><code class="p">(</code><code class="m">-30deg</code><code class="p">)</code> <code class="n">translate</code><code class="p">(</code><code class="m">-100px</code><code class="p">)</code>&#13;
<code class="n">matrix</code><code class="p">(</code><code class="m">-0</code><code class="o">.</code><code class="m">642788</code><code class="o">,</code> <code class="m">0</code><code class="o">.</code><code class="m">766044</code><code class="o">,</code> <code class="m">-0</code><code class="o">.</code><code class="m">766044</code><code class="o">,</code> <code class="m">-0</code><code class="o">.</code><code class="m">642788</code><code class="o">,</code> <code class="m">33</code><code class="o">.</code><code class="m">1756</code><code class="o">,</code> <code class="m">-91</code><code class="o">.</code><code class="m">8883</code><code class="p">)</code></pre>&#13;
&#13;
<p>As ever, they end up in the same place. When animated, though, the&#13;
elements will take different paths to reach that end state. They might&#13;
not be obviously different at first glance, but the difference is still&#13;
there.</p>&#13;
&#13;
<p>None of this matters if you aren’t animating the&#13;
transformation, but it’s an important distinction to make nevertheless,&#13;
because you never know when you’ll decide to start animating things.&#13;
(Hopefully after reading Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch18.html#x-transitions">18</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch19.html#animation">19</a>!)<a data-primary="" data-startref="ix_matrix_func" data-type="indexterm" id="idm45176042524016"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Element Perspective" data-type="sect2"><div class="sect2" id="idm45176043053152">&#13;
<h2>Setting Element Perspective</h2>&#13;
&#13;
<p>If you’re <a data-primary="perspective() function" data-type="indexterm" id="ix_persp_func"/>transforming an element in 3D space, you most likely want it&#13;
to have some perspective. <em>Perspective</em> gives the appearance of&#13;
front-to-back depth, and you can vary the degree of perspective applied&#13;
to an element.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176042519968">&#13;
<h1>perspective() function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>It might seem a bit weird to specify perspective as a distance.&#13;
After all, <code class="keep-together">perspective(200px)</code> seems odd when you can’t really measure pixels along the z-axis. And yet, here we are. You supply a length, and the illusion of depth is constructed around that value.</p>&#13;
&#13;
<p>Smaller numbers create a more extreme perspective, as though you are up close to the element. Higher numbers create a gentler perspective, as though viewing the element through a zoom lens from far away. <em>Really</em> high perspective values create an isometric effect, which looks the same as no perspective at all.</p>&#13;
&#13;
<p>This makes a certain amount of sense. You can visualize perspective as a&#13;
pyramid, with its apex point at the perspective origin (by default, the center of the untransformed element’s position) and its base as the browser window that you’re looking through.&#13;
A shorter distance between apex and base will&#13;
create a shallower pyramid, and thus a more extreme distortion. This is&#13;
illustrated in <a data-type="xref" href="#tf_fig18">Figure 17-20</a>, with hypothetical pyramids representing 200-pixel, 800-pixel, and 2,000-pixel perspective distances.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="tf_fig18">&#13;
<img alt="css5 1720" src="assets/css5_1720.png"/>&#13;
<h6><span class="label">Figure 17-20. </span>Different perspective pyramids</h6>&#13;
</div></figure>&#13;
&#13;
<p>In <a href="https://developer.apple.com/library/archive/documentation/InternetWeb/Conceptual/SafariVisualEffectsProgGuide/Using2Dand3DTransforms/Using2Dand3DTransforms.html">documentation for Safari</a>, Apple writes that perspective values&#13;
below <code>300px</code> tend to be extremely distorted, values above <code>2000px</code>&#13;
create “very mild” distortion, and values between <code>500px</code> and <code>1000px</code>&#13;
create “moderate perspective.” To illustrate this, <a data-type="xref" href="#tf_fig19">Figure 17-21</a> shows a series of elements with the exact same rotation as displayed with varying &#13;
<span class="keep-together">perspective values.</span></p>&#13;
&#13;
<figure><div class="figure" id="tf_fig19">&#13;
<img alt="css5 1721" src="assets/css5_1721.png"/>&#13;
<h6><span class="label">Figure 17-21. </span>The effects of varying perspective values</h6>&#13;
</div></figure>&#13;
&#13;
<p>Perspective values must always be positive, nonzero lengths. Any other&#13;
value will cause the <code>perspective()</code> function to be ignored. Also note&#13;
that its placement in the list of functions is important. If you&#13;
look at the code for <a data-type="xref" href="#tf_fig19">Figure 17-21</a>, the <code class="keep-together">perspective()</code> function comes&#13;
before the <code>rotateY()</code> function:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#ex1</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">100px</code><code class="p">)</code> <code class="n">rotateY</code><code class="p">(</code><code class="m">-45deg</code><code class="p">);}</code>&#13;
<code class="nf">#ex2</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">250px</code><code class="p">)</code> <code class="n">rotateY</code><code class="p">(</code><code class="m">-45deg</code><code class="p">);}</code>&#13;
<code class="nf">#ex3</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">500px</code><code class="p">)</code> <code class="n">rotateY</code><code class="p">(</code><code class="m">-45deg</code><code class="p">);}</code>&#13;
<code class="nf">#ex4</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">1250px</code><code class="p">)</code> <code class="n">rotateY</code><code class="p">(</code><code class="m">-45deg</code><code class="p">);}</code></pre>&#13;
&#13;
<p>If you were to reverse the order, the&#13;
rotation would happen before the perspective is applied, so all four&#13;
examples in <a data-type="xref" href="#tf_fig19">Figure 17-21</a> would look exactly the same. So if you plan to&#13;
apply a perspective value via the list of transform functions, make sure&#13;
it comes first, or at the <span class="keep-together">very least</span> before any transforms that depend&#13;
on it. <a data-primary="" data-startref="ix_persp_func" data-type="indexterm" id="idm45176042451216"/><a data-primary="" data-startref="ix_transform_func" data-type="indexterm" id="idm45176042450272"/>This serves as a stark reminder that the order in which you&#13;
write <code>transform</code> functions can be very <span class="keep-together">important.</span></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Transform Properties" data-type="sect1"><div class="sect1" id="idm45176043760272">&#13;
<h1>More Transform Properties</h1>&#13;
&#13;
<p>In addition to the base <code>transform</code> property and the standalone transform properties like <code>rotate</code>, a few related properties help to define how the elements transform the origin point of a transform, the perspective used for a “scene,” and more.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving the Transform’s Origin" data-type="sect2"><div class="sect2" id="idm45176042413840">&#13;
<h2>Moving the Transform’s Origin</h2>&#13;
&#13;
<p>So far, all of our <a data-primary="transforms" data-secondary="origin of, moving" data-type="indexterm" id="ix_transform_origin_move"/><a data-primary="transform-origin property" data-type="indexterm" id="ix_transform_origin_prop"/>transforms have shared one thing in common: we’ve used the precise center of the element as the <em>transform origin</em>. For example, when rotating the element, it rotated around its center, instead of, say, a corner. This is the default behavior, but with the property <code>transform-origin</code>, you can change it.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176042409136">&#13;
<h1>transform-origin</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>left</code> | <code>center</code> | <code>right</code> | <code>top</code> | <code>bottom</code> | &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>length</code></em>&gt; ]&#13;
|&#13;
  [ <code>left</code> | <code>center</code> | <code>right</code> | &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>length</code></em>&gt; ] &amp;&amp;&#13;
  [ <code>top</code> | <code>center</code> | <code>bottom</code> | &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>length</code></em>&gt; ] ] &lt;<em><code>length</code></em>&gt;?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>50% 50%</code> (<code>0 0</code> in SVG)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the size of the bounding box (see explanation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>A percentage, except for length values, which are converted to an absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The syntax definition looks really abstruse and confusing, but it’s fairly simple in practice. With <code>transform-origin</code>, you supply two or three lengths or keywords to define the point&#13;
around which transforms should be made: first the horizontal, then the&#13;
vertical, and optionally a length along the z-axis. For the horizontal and vertical axes, you can use plain-English keywords like <code>top</code> and <code>right</code>, percentages, lengths, or a combination of keywords and percentage or length values. For the z-axis, you can’t use plain-English keywords or percentages, but can use any length value.  Pixels are by far the most common.</p>&#13;
&#13;
<p>Length values are taken as a distance starting from the top-left corner of the element. Thus, <code>transform-origin: 5em 22px</code> will place the transform origin 5 ems in from the left side of the element, and 22 pixels down from the top of the element. Similarly, <code>transform-origin:&#13;
5em 22px -200px</code> will place it 5 ems over, 22 pixels down, and 200 pixels&#13;
away (that is, 200 pixels behind the untransformed position of the element).</p>&#13;
&#13;
<p>Percentages are calculated with respect to the corresponding axis and&#13;
size of the element’s bounding box, as offsets from the element’s top-left corner. For&#13;
example, <code>transform-origin: 67% 40%</code> will place the transform origin 67&#13;
percent of the width to the right of the element’s left side, and 40&#13;
percent of the element’s height down from the element’s top side. <a data-type="xref" href="#tf_fig22">Figure 17-22</a> illustrates a few origin calculations.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig22">&#13;
<img alt="css5 1722" src="assets/css5_1722.png"/>&#13;
<h6><span class="label">Figure 17-22. </span>Various origin calculations</h6>&#13;
</div></figure>&#13;
&#13;
<p>All right, so if you change the origin, what happens? The easiest way to&#13;
visualize this is with 2D rotations. Suppose you rotate an element 45&#13;
degrees to the right. Its final placement will depend on its origin.&#13;
<a data-type="xref" href="#tf_fig23">Figure 17-23</a> illustrates the effects of several transform origins; in each case, the transform origin is marked with a circle.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig23">&#13;
<img alt="css5 1723" src="assets/css5_1723.png"/>&#13;
<h6><span class="label">Figure 17-23. </span>Rotational effects using various transform origins</h6>&#13;
</div></figure>&#13;
&#13;
<p>The origin matters for other transform types, such as skews and scales.&#13;
Scaling down an <span class="keep-together">element</span> with its origin in the center will pull in all sides equally, whereas scaling down an element with a bottom-right origin will&#13;
cause it to shrink toward that corner. Similarly, skewing an element&#13;
with respect to its center will result in the same shape as if it’s&#13;
skewed with respect to the top-right corner, but the placement of the&#13;
shape will be different. Some examples are shown in <a data-type="xref" href="#tf_fig24">Figure 17-24</a>; again,&#13;
each transform origin is marked with a circle.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig24">&#13;
<img alt="css5 1724" src="assets/css5_1724.png"/>&#13;
<h6><span class="label">Figure 17-24. </span>Skew and scale effects using various transform origins</h6>&#13;
</div></figure>&#13;
&#13;
<p>The one transform type that isn’t really affected by changing the&#13;
transform origin is translation. If you move an element around with <code>translate()</code> or its cousins like <code>translateX()</code> and <code>translateY()</code>, or the <code>translate</code> property, the element is going to end up in the same place regardless of where the transform’s origin is located. If that’s all the transforming you plan to do, setting the transform origin is irrelevant. If you ever do anything besides translating, though, the origin will matter. Use it wisely.<a data-primary="" data-startref="ix_transform_origin_prop" data-type="indexterm" id="idm45176042367696"/><a data-primary="" data-startref="ix_transform_origin_move" data-type="indexterm" id="idm45176042366752"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Choosing the Transform’s Box" data-type="sect2"><div class="sect2" id="choosing-the-transforms-box">&#13;
<h2>Choosing the Transform’s Box</h2>&#13;
&#13;
<p>We wrote the <a data-primary="transform-box property" data-type="indexterm" id="ix_transf_box_prop"/><a data-primary="boxes" data-secondary="transform-box property" data-type="indexterm" id="ix_box_transf_prop"/>previous section as though the transform origin is always calculated with respect to the outer border edge, and that is indeed the default in HTML, but not always in SVG. You can change this, at least in theory, with the property <code>transform-box</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176042361296">&#13;
<h1>transform-box</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>border-box</code> | <code>content-box</code> | <code>fill-box</code> | <code>stroke-box</code> | <code>view-box</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>view-box</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Two of the values are directly related to CSS when styling HTML:</p>&#13;
<dl>&#13;
<dt><code>border-box</code></dt>&#13;
<dd>&#13;
<p>Use the element’s border box (defined by the outer border edge) as the reference box for transforms.</p>&#13;
</dd>&#13;
<dt><code>content-box</code></dt>&#13;
<dd>&#13;
<p>Use the element’s content box as the reference box for transforms.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The remaining three are designed for SVG purposes, though they can also apply in HTML contexts:</p>&#13;
<dl>&#13;
<dt><code>fill-box</code></dt>&#13;
<dd>&#13;
<p>Use the element’s object bounding box as the reference box.</p>&#13;
</dd>&#13;
<dt><code>stroke-box</code></dt>&#13;
<dd>&#13;
<p>Use the element’s stroke bounding box as the reference box.</p>&#13;
</dd>&#13;
<dt><code>view-box</code></dt>&#13;
<dd>&#13;
<p>Use the element’s nearest SVG viewport as the reference box.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Using <code>fill-box</code> in an SVG context causes transforms to be performed on the element in question, as we would expect from HTML.  The default <code>view-box</code>, on the other hand, causes all transforms to be calculated with respect to the origin of the coordinate system established by the SVG <code>viewBox</code> attribute.  The difference is illustrated in <a data-type="xref" href="#transform-box-compare">Figure 17-25</a>, which is the result of the following SVG file and the CSS it contains:</p>&#13;
&#13;
<pre data-code-language="svg" data-type="programlisting"><code class="nt">&lt;svg</code><code class="w"> </code><code class="na">xmlns=</code><code class="s">"http://www.w3.org/2000/svg"</code><code class="w"/>&#13;
<code class="w">     </code><code class="na">width=</code><code class="s">"500"</code><code class="w"> </code><code class="na">height=</code><code class="s">"200"</code><code class="w"/>&#13;
<code class="w">     </code><code class="na">fill=</code><code class="s">"none"</code><code class="w"> </code><code class="na">stroke=</code><code class="s">"#000"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;defs&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;style&gt;</code>&#13;
      <code class="nt">g</code> <code class="nt">rect</code> <code class="p">{</code><code class="k">transform-origin</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code><code class="p">;</code> <code class="k">transform</code><code class="o">:</code> <code class="n">rotate</code><code class="p">(</code><code class="m">20deg</code><code class="p">);}</code>&#13;
      <code class="nt">g</code> <code class="nt">rect</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">transform-box</code><code class="o">:</code> <code class="n">view</code><code class="o">-</code><code class="n">box</code><code class="p">;}</code>&#13;
      <code class="nt">g</code> <code class="nt">rect</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">transform-box</code><code class="o">:</code> <code class="n">fill</code><code class="o">-</code><code class="n">box</code><code class="p">;}</code>&#13;
    <code class="nt">&lt;/style&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/defs&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;rect</code><code class="w"> </code><code class="na">width=</code><code class="s">"100%"</code><code class="w"> </code><code class="na">height=</code><code class="s">"100%"</code><code class="w"> </code><code class="na">stroke-dasharray=</code><code class="s">"4 3"</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;rect</code><code class="w"> </code><code class="na">x=</code><code class="s">"100"</code><code class="w"> </code><code class="na">y=</code><code class="s">"50"</code><code class="w"> </code><code class="na">width=</code><code class="s">"100"</code><code class="w"> </code><code class="na">height=</code><code class="s">"100"</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;rect</code><code class="w"> </code><code class="na">x=</code><code class="s">"300"</code><code class="w"> </code><code class="na">y=</code><code class="s">"50"</code><code class="w"> </code><code class="na">width=</code><code class="s">"100"</code><code class="w"> </code><code class="na">height=</code><code class="s">"100"</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;g</code><code class="w"> </code><code class="na">stroke-width=</code><code class="s">"3"</code><code class="w"> </code><code class="na">fill=</code><code class="s">"#FFF8"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;rect</code><code class="w"> </code><code class="na">x=</code><code class="s">"100"</code><code class="w"> </code><code class="na">y=</code><code class="s">"50"</code><code class="w"> </code><code class="na">width=</code><code class="s">"100"</code><code class="w"> </code><code class="na">height=</code><code class="s">"100"</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;rect</code><code class="w"> </code><code class="na">x=</code><code class="s">"300"</code><code class="w"> </code><code class="na">y=</code><code class="s">"50"</code><code class="w"> </code><code class="na">width=</code><code class="s">"100"</code><code class="w"> </code><code class="na">height=</code><code class="s">"100"</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">&lt;/g&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/svg&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="transform-box-compare">&#13;
<img alt="css5 1725" src="assets/css5_1725.png"/>&#13;
<h6><span class="label">Figure 17-25. </span>A square rotated around the SVG origin and its own origin</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first square, on the left, is rotated 20 degrees from its starting point, with the center of rotation as the top left of the entire SVG file (the top-left corner of the dashed-line box).  This is because the value of <code>transform-box</code> for this square is <code>view-box</code>.  The second square has a <code>transform-box</code> of <code>fill-box</code>, so it uses the top left of its own fill box—what in HTML we would call the background area—as the center of rotation.<a data-primary="" data-startref="ix_box_transf_prop" data-type="indexterm" id="idm45176042247792"/><a data-primary="" data-startref="ix_transf_box_prop" data-type="indexterm" id="idm45176042246816"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Choosing a 3D Style" data-type="sect2"><div class="sect2" id="choosing-a-3d-style">&#13;
<h2>Choosing a 3D Style</h2>&#13;
&#13;
<p>If you’re setting <a data-primary="transforms" data-secondary="3D style for" data-type="indexterm" id="ix_transf_3dstyle"/><a data-primary="transform-style property" data-type="indexterm" id="ix_transf_style_prop"/>elements to be transformed through three&#13;
dimensions—using, say, <code>translate3d()</code> or <code>rotateY()</code>—you probably&#13;
expect that the elements will be presented as though they’re in a 3D&#13;
space. The <code>transform-style</code> property helps bring that to life.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176042240224">&#13;
<h1>transform-style</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>flat</code> | <code>preserve-3d</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>flat</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Suppose you want to move an element “closer” to your eye, and&#13;
then tilt it away a bit, with a moderate amount of perspective. You might use something like this rule:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nf">#inner</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">750px</code><code class="p">)</code> <code class="n">translateZ</code><code class="p">(</code><code class="m">60px</code><code class="p">)</code> <code class="n">rotateX</code><code class="p">(</code><code class="m">45deg</code><code class="p">);}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"outer"</code><code class="o">&gt;</code>&#13;
<code class="nt">outer</code>&#13;
<code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"inner"</code><code class="o">&gt;</code><code class="nt">inner</code><code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>So you do that and get the result shown in <a data-type="xref" href="#tf_fig25">Figure 17-26</a>—more or less what&#13;
you might expect.</p>&#13;
&#13;
<figure><div class="figure" id="tf_fig25">&#13;
<img alt="css5 1726" src="assets/css5_1726.png"/>&#13;
<h6><span class="label">Figure 17-26. </span>A 3D-transformed inner <code>&lt;div&gt;</code></h6>&#13;
</div></figure>&#13;
&#13;
<p>But then you decide to rotate the outer <code>&lt;div&gt;</code> to one side, and suddenly&#13;
nothing makes sense anymore. The inner <code>&lt;div&gt;</code> isn’t where you envisioned&#13;
it. In fact, it just looks like a picture pasted to the front of the&#13;
outer <code>&lt;div&gt;</code>.</p>&#13;
&#13;
<p>Well, that’s exactly what it is, because the default value of&#13;
<code>transform-style</code> is <code>flat</code>. The inner <code>div</code> got&#13;
drawn in its moved-forward, tilted-back state, and that was applied to&#13;
the front of the outer <code>&lt;div&gt;</code> as if it were an image. So when you rotated the outer <code>&lt;div&gt;</code>, as shown in <a data-type="xref" href="#tf_fig27">Figure 17-27</a>, the flat picture rotated right along with it:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nf">#outer</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">750px</code><code class="p">)</code> <code class="n">rotateY</code><code class="p">(</code><code class="m">60deg</code><code class="p">)</code> <code class="n">rotateX</code><code class="p">(</code><code class="m">-20deg</code><code class="p">);}</code>&#13;
<code class="nt">div</code><code class="nf">#inner</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">750px</code><code class="p">)</code> <code class="n">translateZ</code><code class="p">(</code><code class="m">60px</code><code class="p">)</code> <code class="n">rotateX</code><code class="p">(</code><code class="m">45deg</code><code class="p">);}</code></pre>&#13;
&#13;
<p>Change the value to <code>preserve-3d</code>, however, and the result is very different. The inner <code>div</code> will be drawn as a full 3D object with respect to its parent outer <code>&lt;div&gt;</code>, floating in space nearby, and <em>not</em> as a picture pasted on the front of the outer <code>&lt;div&gt;</code>. You can see the results of this change in <a data-type="xref" href="#tf_fig27">Figure 17-27</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code><code class="nf">#outer</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">750px</code><code class="p">)</code> <code class="n">rotateY</code><code class="p">(</code><code class="m">60deg</code><code class="p">)</code> <code class="n">rotateX</code><code class="p">(</code><code class="m">-20deg</code><code class="p">);</code>&#13;
    <code class="k">transform-style</code><code class="o">:</code> <code class="n">preserve-3d</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#inner</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">750px</code><code class="p">)</code> <code class="n">translateZ</code><code class="p">(</code><code class="m">60px</code><code class="p">)</code> <code class="n">rotateX</code><code class="p">(</code><code class="m">45deg</code><code class="p">);}</code></pre>&#13;
&#13;
<figure><div class="figure" id="tf_fig27">&#13;
<img alt="css5 1727" src="assets/css5_1727.png"/>&#13;
<h6><span class="label">Figure 17-27. </span>The effects of a flat versus a 3D-preserved transform style</h6>&#13;
</div></figure>&#13;
&#13;
<p>One important aspect of <code>transform-style</code> is that it can be overridden&#13;
by other properties. The reason is that some values of these other&#13;
properties require a flattened presentation of an element and its&#13;
children in order to work. In such cases, the value of&#13;
<code>transform-style</code> is forced to be <code>flat</code>, regardless of what you may&#13;
have declared.</p>&#13;
&#13;
<p>So, to avoid this overriding behavior, make sure the following&#13;
properties are set to the listed values on any 3D-transformed container&#13;
elements that also have 3D-transformed &#13;
<span class="keep-together">children:</span></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>overflow: visible</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>filter: none</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>clip: auto</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>clip-path: none</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>mask-image: none</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>mask-border-source: none</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>mix-blend-mode: normal</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>isolation: auto</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Those are all the default values for those properties, so as long as you&#13;
don’t try to change any of them for your preserved 3D elements, you’re&#13;
fine! But if you find that editing some CSS suddenly flattens out your&#13;
lovely 3D transforms, one of these properties might be the culprit.<a data-primary="" data-startref="ix_transf_style_prop" data-type="indexterm" id="idm45176041867312"/><a data-primary="" data-startref="ix_transf_3dstyle" data-type="indexterm" id="idm45176041866304"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Changing Perspective" data-type="sect2"><div class="sect2" id="changing-perspective">&#13;
<h2>Changing Perspective</h2>&#13;
&#13;
<p>Two <a data-primary="transforms" data-secondary="perspective change" data-type="indexterm" id="ix_transf_persp"/>properties are used to define the way perspective is handled: one to define the perspective distance, as with the <code>perspective()</code> function discussed in an earlier section; and another to define the perspective’s origin point.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining a group perspective" data-type="sect3"><div class="sect3" id="idm45176041861520">&#13;
<h3>Defining a group perspective</h3>&#13;
&#13;
<p>First, let’s <a data-primary="perspective property" data-type="indexterm" id="ix_persp_prop"/><a data-primary="perspective() function" data-type="indexterm" id="ix_persp_func2"/>consider the property <code>perspective</code>, which accepts a length&#13;
that defines the depth of the perspective pyramid. At first glance, it&#13;
looks just like the <code>perspective()</code> function discussed earlier, but some critical differences exist.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176041856720">&#13;
<h1>perspective</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | &lt;<em><code>length</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>The absolute length, or else <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>As a quick example, if you want to create a very deep perspective, one&#13;
mimicking the results you’d get from a zoom lens, you might declare&#13;
something like <code>perspective: 2500px</code>. For a shallow depth, one that&#13;
mimics a close-up fish-eye lens effect, you might declare <code>perspective: 200px</code>.</p>&#13;
&#13;
<p>So how does this differ from the <code>perspective()</code> function? When you use&#13;
<code class="keep-together">perspective()</code>, you’re defining the perspective effect for the element&#13;
that is given that function. So if you write <code>transform: perspective(800px) rotateY(-50grad);</code>, you’re applying that&#13;
perspective to each element that has the rule applied.</p>&#13;
&#13;
<p>With the <code>perspective</code> property, on the other hand, you’re creating&#13;
a shared perspective for all the child elements of the&#13;
element that received the property. Here’s an illustration of the difference, as shown in <a data-type="xref" href="#tf_fig28">Figure 17-28</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="k">transform-style</code><code class="o">:</code> <code class="n">preserve-3d</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">660px</code><code class="p">;}</code>&#13;
<code class="nt">img</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">10px</code><code class="p">;}</code>&#13;
<code class="nf">#func</code> <code class="p">{</code><code class="k">perspective</code><code class="o">:</code> <code class="nb">none</code><code class="p">;}</code>&#13;
<code class="nf">#func</code> <code class="nt">img</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">perspective</code><code class="p">(</code><code class="m">800px</code><code class="p">)</code> <code class="n">rotateX</code><code class="p">(</code><code class="m">-50grad</code><code class="p">);}</code>&#13;
<code class="nf">#prop</code> <code class="p">{</code><code class="k">perspective</code><code class="o">:</code> <code class="m">800px</code><code class="p">;}</code>&#13;
<code class="nf">#prop</code> <code class="nt">img</code> <code class="p">{</code><code class="k">transform</code><code class="o">:</code> <code class="n">rotateX</code><code class="p">(</code><code class="m">-50grad</code><code class="p">);}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="tf_fig28">&#13;
<img alt="css5 1728" src="assets/css5_1728.png"/>&#13;
<h6><span class="label">Figure 17-28. </span>No perspective, individual <code>perspective()</code>, and shared <code>perspective</code>, respectively</h6>&#13;
</div></figure>&#13;
&#13;
<p>In <a data-type="xref" href="#tf_fig28">Figure 17-28</a>, we first see a line of images that haven’t been&#13;
transformed. In the second line, each image has been rotated 50 gradians&#13;
(equivalent to 45 degrees) toward us, but each one within its own&#13;
individual perspective.</p>&#13;
&#13;
<p>In the third line of images, none has an individual perspective.&#13;
Instead, all are drawn within the perspective defined by&#13;
<code>perspective: 800px;</code> that’s been set on the <code>&lt;div&gt;</code> that contains them.&#13;
Since they all operate within a shared perspective, they look “correct”—that is, as we would expect if we had three physical pictures mounted on a clear sheet of glass and rotated that toward us around its center horizontal axis.</p>&#13;
&#13;
<p>This is the critical difference between <code>perspective</code>, the property, and&#13;
<code class="keep-together">perspective()</code>, the function. The former creates a 3D space shared by&#13;
all its children. The latter affects only the element to which it’s&#13;
applied. Another difference is that the effect of the <code>perspective()</code> function is different depending on when it is called in the chain of transforms. The <code>perspective</code> property is always applied before all other transforms, which is what you normally want to create a 3D effect.</p>&#13;
&#13;
<p>In most cases, you’re going to use the <code>perspective</code> property instead of&#13;
the <code class="keep-together">perspective()</code> function. In fact, container <code>&lt;div&gt;</code>s (or other&#13;
elements) are a common feature of 3D transforms—the way they used&#13;
to be for page layout—largely to establish a shared perspective. In the&#13;
previous example, the <code>&lt;div id="two"&gt;</code> is there solely to serve as a&#13;
perspective container, so to speak. On the other hand, we couldn’t have&#13;
done what we did without it.<a data-primary="" data-startref="ix_persp_func2" data-type="indexterm" id="idm45176041736144"/><a data-primary="" data-startref="ix_persp_prop" data-type="indexterm" id="idm45176041735168"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Moving the perspective’s origin" data-type="sect3"><div class="sect3" id="idm45176041860896">&#13;
<h3>Moving the perspective’s origin</h3>&#13;
&#13;
<p>When <a data-primary="perspective-origin property" data-type="indexterm" id="ix_persp_orig_prop"/>transforming elements in three dimensions, a perspective will be used. (See <code>transform-style</code> and <code>perspective</code> in previous sections.) That perspective will have an origin, which is also known as the <em>vanishing point</em>, and you can change its location with the <code>perspective-origin</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176041729616">&#13;
<h1>perspective-origin</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>left</code> | <code>center</code> | <code>right</code> | <code>top</code> | <code>bottom</code> | &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>length</code></em>&gt; ]&#13;
|&#13;
  [ <code>left</code> | <code>center</code> | <code>right</code> | &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>length</code></em>&gt; ] &amp;&amp;&#13;
  [ <code>top</code> | <code>center</code> | <code>bottom</code> | &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>length</code></em>&gt; ] ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>50% 50%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the size of the bounding box (see explanation)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>A percentage, except for length values, which are converted to an absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>With <code>perspective-origin</code>, you define the point on which sight&#13;
lines converge, and as with <code>perspective</code>, that point is defined relative to a parent container.</p>&#13;
&#13;
<p>As with most 3D transform properties, this is more easily demonstrated&#13;
than described. Consider the following CSS and markup, illustrated in&#13;
<a data-type="xref" href="#tf_fig29">Figure 17-29</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#container</code> <code class="p">{</code><code class="k">perspective</code><code class="o">:</code> <code class="m">850px</code><code class="p">;</code> <code class="k">perspective-origin</code><code class="o">:</code> <code class="m">50%</code> <code class="m">0%</code><code class="p">;}</code>&#13;
<code class="nf">#ruler</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="m">#DED</code> <code class="sx">url(tick.gif)</code> <code class="nb">repeat-x</code><code class="p">;</code>&#13;
    <code class="k">rotate</code><code class="o">:</code> <code class="n">x</code> <code class="m">60deg</code><code class="p">;</code>&#13;
    <code class="k">transform-origin</code><code class="o">:</code> <code class="m">50%</code> <code class="m">100%</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"container"</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"ruler"</code><code class="o">&gt;&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="tf_fig29">&#13;
<img alt="css5 1729" src="assets/css5_1729.png"/>&#13;
<h6><span class="label">Figure 17-29. </span>A basic “ruler”</h6>&#13;
</div></figure>&#13;
&#13;
<p>We have a repeated background image of tick marks on a ruler,&#13;
with the <code>&lt;div&gt;</code> that contains them tilted away from us by 60 degrees. All the lines point at a common vanishing point, the top center of the&#13;
container <code>&lt;div&gt;</code> (because of the <code>50% 0%</code> value for&#13;
<code>perspective-origin</code>).</p>&#13;
&#13;
<p>Now consider that same setup with various perspective origins (<a data-type="xref" href="#tf_fig30">Figure 17-30</a>).</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="tf_fig30">&#13;
<img alt="css5 1730" src="assets/css5_1730.png"/>&#13;
<h6><span class="label">Figure 17-30. </span>A basic “ruler” with different perspective origins</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can see, moving the perspective origin changes the rendering of&#13;
the 3D-transformed element. Note that these have an effect only because we supplied a value for <code>perspective</code>. If the value of <code>perspective</code> is ever the default <code>none</code>, any value given for <code>perspective-origin</code> will be ignored. That makes sense, since you can’t have a perspective origin when there’s no perspective at all!<a data-primary="" data-startref="ix_transf_persp" data-type="indexterm" id="idm45176041606768"/><a data-primary="" data-startref="ix_persp_orig_prop" data-type="indexterm" id="idm45176041605920"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dealing with Backfaces" data-type="sect2"><div class="sect2" id="dealing-with-backfaces">&#13;
<h2>Dealing with Backfaces</h2>&#13;
&#13;
<p>Over all the <a data-primary="transforms" data-secondary="backface visibility" data-type="indexterm" id="ix_transf_backface_vis"/><a data-primary="backface-visibility property" data-type="indexterm" id="ix_backface_vis_prop"/>years you’ve been laying out elements, you’ve probably never thought, “What would it look like if we could see the back side of the element?” With 3D transforms, if there comes a day when you <em>do</em> see the back side of an element, CSS has you covered. What happens is determined by the property <code>backface-visibility</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176041600128">&#13;
<h1>backface-visibility</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>visible</code> | <code>hidden</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>visible</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Any transformable element</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Unlike many of the other properties and functions we’ve already talked&#13;
about, this one is pretty uncomplicated. All it&#13;
does is determine whether the back side of an element is rendered when&#13;
it’s facing toward the viewer, or not. That’s it.</p>&#13;
&#13;
<p>So let’s say you flip over two elements, one with <code>backface-visibility</code>&#13;
set to <span class="keep-together">the default</span> value of <code>visible</code> and the other set to <code>hidden</code>. You&#13;
get the result shown in <a data-type="xref" href="#tf_fig31">Figure 17-31</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">span</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">red</code><code class="p">;</code> <code class="k">display</code><code class="o">:</code> <code class="nb">inline-block</code><code class="p">;}</code>&#13;
<code class="nt">img</code> <code class="p">{</code><code class="k">vertical-align</code><code class="o">:</code> <code class="n">bottom</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.flip</code> <code class="p">{</code><code class="k">rotate</code><code class="o">:</code> <code class="n">x</code> <code class="m">180deg</code><code class="p">;</code> <code class="k">display</code><code class="o">:</code> <code class="nb">inline-block</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nf">#show</code> <code class="p">{</code><code class="k">backface-visibility</code><code class="o">:</code> <code class="nb">visible</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nf">#hide</code> <code class="p">{</code><code class="k">backface-visibility</code><code class="o">:</code> <code class="nb">hidden</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">span</code><code class="o">&gt;&lt;</code><code class="nt">img</code> <code class="nt">src</code><code class="o">=</code><code class="s2">"salmon.gif"</code> <code class="nt">alt</code><code class="o">=</code><code class="s2">"salmon"</code><code class="o">&gt;&lt;/</code><code class="nt">span</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;</code><code class="nt">span</code><code class="o">&gt;&lt;</code><code class="nt">img</code> <code class="nt">src</code><code class="o">=</code><code class="s2">"salmon.gif"</code> <code class="nt">class</code><code class="o">=</code><code class="s2">"flip"</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"show"</code> <code class="nt">alt</code><code class="o">=</code><code class="s2">"salmon"</code><code class="o">&gt;&lt;/</code><code class="nt">span</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;</code><code class="nt">span</code><code class="o">&gt;&lt;</code><code class="nt">img</code> <code class="nt">src</code><code class="o">=</code><code class="s2">"salmon.gif"</code> <code class="nt">class</code><code class="o">=</code><code class="s2">"flip"</code> <code class="nt">id</code><code class="o">=</code><code class="s2">"hide"</code> <code class="nt">alt</code><code class="o">=</code><code class="s2">"salmon"</code><code class="o">&gt;&lt;/</code><code class="nt">span</code><code class="o">&gt;</code></pre>&#13;
&#13;
<figure><div class="figure" id="tf_fig31">&#13;
<img alt="css5 1731" src="assets/css5_1731.png"/>&#13;
<h6><span class="label">Figure 17-31. </span>Visible and hidden backfaces</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can see, the first image is unchanged. The second is flipped over its x-axis, so we see it from the back. The third has also been&#13;
flipped, but we can’t see it at all because its backface has been hidden.</p>&#13;
&#13;
<p>This property can come in handy in several situations. In the simplest, you have two elements that represent the two sides of a UI element that flips over—say, a search area with preference settings on its back, or a photo with some information on the back. Let’s take the latter case. The CSS and markup might look something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">section</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="o">,</code> <code class="nt">div</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">backface-visibility</code><code class="o">:</code> <code class="nb">hidden</code><code class="p">;}</code>&#13;
<code class="nt">div</code> <code class="p">{</code><code class="k">rotate</code><code class="o">:</code> <code class="n">y</code> <code class="m">180deg</code><code class="p">;}</code>&#13;
<code class="nt">section</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">rotate</code><code class="o">:</code> <code class="n">y</code> <code class="m">180deg</code><code class="p">;</code> <code class="k">transform-style</code><code class="o">:</code> <code class="n">preserve-3d</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">section</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">img</code> <code class="nt">src</code><code class="o">=</code><code class="s2">"photo.jpg"</code> <code class="nt">alt</code><code class="o">=</code><code class="s2">""</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">class</code><code class="o">=</code><code class="s2">"info"</code><code class="o">&gt;(</code><code class="err">…</code><code class="nt">info</code> <code class="nt">goes</code> <code class="nt">here</code><code class="err">…</code><code class="o">)&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;/</code><code class="nt">section</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>(This would be a lot more interesting with an animated rotation, causing the card to flip over in 3D space.)</p>&#13;
&#13;
<p>A variant of this example uses the same markup, but slightly different CSS to show the image’s backface when it’s flipped&#13;
over. This is probably more what was intended, since it makes&#13;
information look like it’s literally written on the back of the image.&#13;
It leads to the end result shown in <a data-type="xref" href="#tf_fig32">Figure 17-32</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">section</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="o">,</code> <code class="nt">div</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="nt">div</code> <code class="p">{</code><code class="k">rotate</code><code class="o">:</code> <code class="n">y</code> <code class="m">180deg</code><code class="p">;</code> <code class="k">backface-visibility</code><code class="o">:</code> <code class="nb">hidden</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="n">rgba</code><code class="p">(</code><code class="m">255</code><code class="o">,</code><code class="m">255</code><code class="o">,</code><code class="m">255</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">85</code><code class="p">);}</code>&#13;
<code class="nt">section</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">rotate</code><code class="o">:</code> <code class="n">y</code> <code class="m">180deg</code><code class="p">;</code> <code class="k">transform-style</code><code class="o">:</code> <code class="n">preserve-3d</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="tf_fig32">&#13;
<img alt="css5 1732" src="assets/css5_1732.png"/>&#13;
<h6><span class="label">Figure 17-32. </span>Photo on the front, information on the back</h6>&#13;
</div></figure>&#13;
&#13;
<p>All we had to do to make that happen was shift <code>backface-visibility: hidden</code> to the <code>&lt;div&gt;</code> instead of applying it to both the <code>&lt;img&gt;</code> and the <code>&lt;div&gt;</code>. Thus, the <code>&lt;div&gt;</code>’s backface is hidden when it’s flipped over, but that of the image is not.  (Well, that and use a semitransparent background so we could see both the text and the flipped image underneath it.)<a data-primary="" data-startref="ix_backface_vis_prop" data-type="indexterm" id="idm45176041225888"/><a data-primary="" data-startref="ix_transf_backface_vis" data-type="indexterm" id="idm45176041224912"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45176041604480">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>With the ability to transform elements in two- and three-dimensional&#13;
space, CSS transforms provide a great deal of power to designers.&#13;
From creating interesting&#13;
combinations of 2D transforms, to creating a fully 3D-acting interface,&#13;
transforms open up a great deal of new territory in the design space. Some dependencies exist between properties, which is&#13;
something that not every CSS author will find natural at first, but they&#13;
become second nature with practice.<a data-primary="" data-startref="ix_transform_ch17" data-type="indexterm" id="idm45176041222896"/></p>&#13;
&#13;
<p>One of the things authors often do with transforms is animate them, so that a card flips over, an element scales and rotates smoothly, and so on.  In the next two chapters, we’ll get into the details of how those transitions and animations are defined.</p>&#13;
</div></section>&#13;
</div></section></body></html>