<html><head></head><body><section data-pdf-bookmark="Chapter 10. React Testing" data-type="chapter" epub:type="chapter"><div class="chapter" id="react-testing">&#13;
<h1><span class="label">Chapter 10. </span>React Testing</h1>&#13;
&#13;
&#13;
<p>In<a data-primary="unit testing" data-secondary="benefits of" data-type="indexterm" id="idm45901621153496"/> order to keep up with our competitors, we must move quickly while ensuring quality. One vital tool that allows us to do this is <em>unit testing</em>. Unit testing makes it possible to verify that every piece, or unit, of our application functions as intended.<sup><a data-type="noteref" href="ch10.html#idm45901621151704" id="idm45901621151704-marker">1</a></sup></p>&#13;
&#13;
<p>One benefit of practicing functional techniques is that they lend themselves to writing testable code. Pure functions are naturally testable. Immutability is easily testable. Composing applications out of small functions designed for specific tasks produces testable functions or units of code.</p>&#13;
&#13;
<p>In this section, we’ll demonstrate techniques that can be used to unit test React applications. This chapter will not only cover testing, but also tools that can be used to help evaluate and improve your code and your tests.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ESLint" data-type="sect1"><div class="sect1" id="eslint">&#13;
<h1>ESLint</h1>&#13;
&#13;
<p>In<a data-primary="unit testing" data-secondary="ESLint" data-type="indexterm" id="UTeslint10"/><a data-primary="ESLint" data-type="indexterm" id="eslint10"/> most programming languages, code needs to be compiled before you can run anything. Programming languages have pretty strict rules about coding style and will not compile until the code is formatted appropriately. JavaScript does not have those rules and does not come with a compiler. We write code, cross our fingers, and run it in the browser to see if it works or not. The good news is that there are tools we can use to analyze our code and make us stick to specific formatting guidelines.</p>&#13;
&#13;
<p>The process of analyzing JavaScript code is called<a data-primary="hinting" data-type="indexterm" id="idm45901621143192"/><a data-primary="linting" data-type="indexterm" id="idm45901621142488"/> <em>hinting</em> or <em>linting</em>. JSHint<a data-primary="JSHint" data-type="indexterm" id="idm45901621140824"/><a data-primary="JSLint" data-type="indexterm" id="idm45901621140088"/> and JSLint are the original tools used to analyze JavaScript and provide feedback about formatting. <a href="http://eslint.org">ESLint</a> is the latest code linter that supports emerging <span class="keep-together">JavaScript</span> syntax. Additionally, ESLint is pluggable. This means we can create and share plug-ins that can be added to ESLint configurations to extend its capabilities.</p>&#13;
&#13;
<p>ESLint is supported out of the box with Create React App, and we’ve already seen lint warnings and errors appear in the console.</p>&#13;
&#13;
<p>We’ll be working with a plug-in called <a href="https://oreil.ly/3yeXO"><code>eslint-plugin-react</code></a>. This plug-in will analyze our JSX and React syntax in addition to our JavaScript.</p>&#13;
&#13;
<p>Let’s install <code>eslint</code> as a dev dependency. We can install <code>eslint</code> with npm:</p>&#13;
&#13;
<pre data-type="programlisting">npm install eslint --save-dev&#13;
&#13;
# or&#13;
&#13;
yarn add eslint --dev</pre>&#13;
&#13;
<p>Before we use ESLint, we’ll need to define some configuration rules that we can agree to follow. We’ll define these in a configuration file that’s located in our project root. This file can be formatted as JSON or YAML. <a href="http://yaml.org">YAML</a> is a data serialization formation like JSON but with less syntax, making it a little easier for humans to read.</p>&#13;
&#13;
<p>ESLint comes with a tool that helps us set up configuration. There are several companies that have created ESLint config files that we can use as a starting point, or we can create our own.</p>&#13;
&#13;
<p>We can create an ESLint configuration by running <code>eslint --init</code> and answering some questions about our coding style:</p>&#13;
<pre data-type="programlisting">npx eslint --init&#13;
&#13;
How would you like to configure ESLint?&#13;
<strong>To check syntax and find problems</strong>&#13;
&#13;
What type of modules does your project use?&#13;
<strong>JavaScript modules (import/export)</strong>&#13;
&#13;
Which framework does your project use?&#13;
<strong>React</strong>&#13;
&#13;
Does your project use TypeScript?&#13;
<strong>N</strong>&#13;
&#13;
Where does your code run? (Press space to select, a to toggle all,&#13;
i to invert selection)&#13;
<strong>Browser</strong>&#13;
&#13;
What format do you want your config file to be in?&#13;
<strong>JSON</strong>&#13;
&#13;
Would you like to install them now with npm?&#13;
<strong>Y</strong></pre>&#13;
&#13;
<p>After <code>npx eslint --init</code> runs, three things happen:</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>eslint-plugin-react</code> is installed locally to the <em>./node_modules</em> folder.</p>&#13;
</li>&#13;
<li>&#13;
<p>These dependencies are automatically added to the <em>package.json</em> file.</p>&#13;
</li>&#13;
<li>&#13;
<p>A configuration file, <em>.eslintrc.json</em>, is created and added to the root of our project.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>If we open <em>.eslintrc.json</em>, we’ll see an object of settings:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"env"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"browser"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nt">"es6"</code><code class="p">:</code> <code class="kc">true</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"extends"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="s2">"eslint:recommended"</code><code class="p">,</code>&#13;
    <code class="s2">"plugin:react/recommended"</code>&#13;
  <code class="p">],</code>&#13;
  <code class="nt">"globals"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"Atomics"</code><code class="p">:</code> <code class="s2">"readonly"</code><code class="p">,</code>&#13;
    <code class="nt">"SharedArrayBuffer"</code><code class="p">:</code> <code class="s2">"readonly"</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"parserOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"ecmaFeatures"</code><code class="p">:</code> <code class="p">{</code>&#13;
      <code class="nt">"jsx"</code><code class="p">:</code> <code class="kc">true</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nt">"ecmaVersion"</code><code class="p">:</code> <code class="mi">2018</code><code class="p">,</code>&#13;
    <code class="nt">"sourceType"</code><code class="p">:</code> <code class="s2">"module"</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nt">"plugins"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"react"</code><code class="p">],</code>&#13;
  <code class="nt">"rules"</code><code class="p">:</code> <code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Importantly, if we look at the <code>extends</code> key, we’ll see that our <code>--init</code> command initalized defaults for <code>eslint</code> and <code>react</code>. This means that we don’t have to manually configure all of the rules. Instead, those rules are provided to us.</p>&#13;
&#13;
<p>Let’s test our ESLint configuration and these rules by creating a <em>sample.js</em> file:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">gnar</code> <code class="o">=</code> <code class="s2">"gnarly"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">info</code> <code class="o">=</code> <code class="p">({</code>&#13;
  <code class="nx">file</code> <code class="o">=</code> <code class="nx">__filename</code><code class="p">,</code>&#13;
  <code class="nx">dir</code> <code class="o">=</code> <code class="nx">__dirname</code>&#13;
<code class="p">})</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code>&#13;
    <code class="p">{</code><code class="nx">dir</code><code class="p">}</code><code class="o">:</code> <code class="p">{</code><code class="nx">file</code><code class="p">}</code>&#13;
  <code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="k">switch</code> <code class="p">(</code><code class="nx">gnar</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">default</code><code class="o">:</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"gnarly"</code><code class="p">);</code>&#13;
    <code class="k">break</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This file has some issues, but nothing that would cause errors in the browser. Technically, this code works just fine. Let’s run ESLint on this file and see what feedback we get based on our customized rules:</p>&#13;
&#13;
<pre data-type="programlisting">npx eslint sample.js&#13;
&#13;
3:7 error 'info' is assigned a value but never used no-unused-vars&#13;
4:3 error 'file' is missing in props validation react/prop-types&#13;
4:10 error 'filename' is not defined no-undef&#13;
5:3 error 'dir' is missing in props validation react/prop-types&#13;
5:9 error 'dirname' is not defined no-undef&#13;
7:3 error 'React' must be in scope when using JSX react/react-in-jsx-scope&#13;
&#13;
✖ 6 problems (6 errors, 0 warnings)</pre>&#13;
&#13;
<p>ESLint has performed a static analysis of our code and is reporting some issues based on our configuration choices. There are errors about property validation, and ESLint also complains about <code>__filename</code> and <code>__dirname</code> because it does not automatically include Node.js globals. And finally, ESLint’s default React warnings let us know that React must be in scope when using JSX.</p>&#13;
&#13;
<p>The command <code>eslint .</code> will lint our entire directory. To do this, we’ll most likely require that ESLint ignore some JavaScript files. The <em>.eslintignore</em> file is where we can add files or directories for ESLint to ignore:</p>&#13;
&#13;
<pre data-type="programlisting">dist/assets/&#13;
sample.js</pre>&#13;
&#13;
<p>This <em>.eslintignore</em> file tells ESLint to ignore our new <em>sample.js</em> file as well as anything in the <em>dist/assets</em> folder. If we don’t ignore the <em>assets</em> folder, ESLint will analyze the client <em>bundle.js</em> file, and it will probably find a lot to complain about in that file.</p>&#13;
&#13;
<p>Let’s add a script to our <em>package.json</em> file for running ESLint:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"scripts"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"lint"</code><code class="p">:</code> <code class="s2">"eslint ."</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now ESLint can be run any time we want with <code>npm run lint</code>, and it will analyze all of the files in our project except the ones we’ve ignored.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="ESLint Plug-Ins" data-type="sect2"><div class="sect2" id="eslint-plugins">&#13;
<h2>ESLint Plug-Ins</h2>&#13;
&#13;
<p>There are a multitude of plug-ins that can be added to your ESLint configuration to help you as you’re writing code. For a React project, you’ll definitely want to install <a href="https://reactjs.org/docs/hooks-rules.html"><code>eslint-plugin-react-hooks</code></a>, a plug-in to enforce the rules of React Hooks. This package was released by the React team to help fix bugs related to Hooks usage.</p>&#13;
&#13;
<p>Start by installing it:</p>&#13;
&#13;
<pre data-type="programlisting">npm install eslint-plugin-react-hooks --save-dev&#13;
&#13;
# OR&#13;
&#13;
yarn add eslint-plugin-react-hooks --dev</pre>&#13;
&#13;
<p>Then, open the <em>.eslintrc.json</em> file and add the following:</p>&#13;
&#13;
<pre data-type="programlisting">{&#13;
  "plugins": [&#13;
    // ...&#13;
    "react-hooks"&#13;
  ],&#13;
  "rules": {&#13;
    "react-hooks/rules-of-hooks": "error",&#13;
    "react-hooks/exhaustive-deps": "warn"&#13;
  }&#13;
}</pre>&#13;
&#13;
<p>This plug-in will check to ensure that functions that start with the word “use” (assumed to be a hook) are following the rules of Hooks.</p>&#13;
&#13;
<p>Once this has been added, we’ll write some sample code to test the plug-in. Adjust the code in <em>sample.js</em>. Even though this code won’t run, we’re testing to see if the plug-in is working appropriately:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">gnar</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">nickname</code><code class="p">,</code> <code class="nx">setNickname</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code>&#13;
    <code class="s2">"dude"</code>&#13;
  <code class="p">);</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">gnarly</code><code class="o">&lt;</code><code class="err">/h1&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Several errors will pop up from this code, but most importantly, there’s the error that lets us know we’re trying to call <code>useState</code> in a function that isn’t a component or a hook:</p>&#13;
&#13;
<pre data-type="programlisting">4:35 error React Hook "useState" is called in function "gnar" that is neither&#13;
a React function component nor a custom React Hook function&#13;
react-hooks/rules-of-hooks</pre>&#13;
&#13;
<p>These shoutouts will help us along the way as we learn the ins and outs of working with Hooks.</p>&#13;
&#13;
<p>Another useful ESLint plug-in to incorporate into your projects is <code>eslint-plugin-jsx-a11y</code>. A11y is a numeronym, which means that there are 11 letters between the “a” and the “y” in accessibility. When we consider accessibility, we build tools, websites, and technologies that can be used by people with disabilities.</p>&#13;
&#13;
<p>This plug-in will analyze your code and ensure that it’s not breaking any accessibility rules. Accessibility should be an area of focus for all of us, and working with this plug-in will promote good practices when writing accessible React applications.</p>&#13;
&#13;
<p>To install, we’ll use npm or yarn again:</p>&#13;
&#13;
<pre data-type="programlisting">npm install eslint-plugin-jsx-a11y&#13;
&#13;
// or&#13;
&#13;
yarn add eslint-plugin-jsx-a11y</pre>&#13;
&#13;
<p>Then we’ll add to our config, <em>.eslintrc.json</em>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"extends"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="err">//</code> <code class="err">...</code>&#13;
    <code class="s2">"plugin:jsx-a11y/recommended"</code>&#13;
  <code class="p">],</code>&#13;
  <code class="nt">"plugins"</code><code class="p">:</code> <code class="p">[</code>&#13;
    <code class="err">//</code> <code class="err">...</code>&#13;
    <code class="s2">"jsx-a11y"</code>&#13;
  <code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now let’s test it. We’ll adjust our <em>sample.js</em> file to include an image tag that has no alt property. In order for an image to pass a lint check, it must have an alt prop or an empty string if the image doesn’t affect the user’s understanding of the content:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Image</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">img</code> <code class="nx">src</code><code class="o">=</code><code class="s2">"/img.png"</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we run lint again with <code>npm run lint</code>, we’ll see that there’s a new error that’s called by the <code>jsx/a11y</code> plug-in:</p>&#13;
&#13;
<pre data-type="programlisting">5:10 error img elements must have an alt prop, either with meaningful text,&#13;
or an empty string for decorative images</pre>&#13;
&#13;
<p>There<a data-primary="" data-startref="UTeslint10" data-type="indexterm" id="idm45901620760456"/><a data-primary="" data-startref="eslint10" data-type="indexterm" id="idm45901620759448"/> are many other ESLint plug-ins you can use to statically analyze your code, and you could spend weeks tuning your ESLint config to perfection. If you’re looking to take yours to the next level, there are many useful resources in the <a href="https://github.com/dustinspecker/awesome-eslint">Awesome ESLint repository</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Prettier" data-type="sect1"><div class="sect1" id="prettier">&#13;
<h1>Prettier</h1>&#13;
&#13;
<p>Prettier<a data-primary="unit testing" data-secondary="Prettier" data-type="indexterm" id="idm45901620717896"/><a data-primary="Prettier" data-type="indexterm" id="idm45901620716888"/> is an opinionated code formatter you can use on a range of projects. The effect Prettier has had on the day-to-day work of web developers since its release has been pretty incredible. Based on historical records, arguing over syntax filled 87% of an average JavaScript developer’s day, but now Prettier handles code formatting and defining the rules around what code syntax should be used per project. The time savings are significant. Also, if you’ve ever unleashed Prettier on a Markdown table, the quick, crisp formatting that occurs is a pretty incredible sight to behold.</p>&#13;
&#13;
<p>ESLint used to be in charge of code formatting for many projects, but now there’s a clear delineation of responsibilities. ESLint handles code-quality concerns. Prettier handles code formatting.</p>&#13;
&#13;
<p>To make Prettier work with ESLint, we’ll tinker with the configuration of our project a bit more. You can install Prettier globally to get started:</p>&#13;
&#13;
<pre data-type="programlisting">sudo npm install -g prettier</pre>&#13;
&#13;
<p>Now you can use Prettier anywhere on any project.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring Prettier by Project" data-type="sect2"><div class="sect2" id="configuring-prettier">&#13;
<h2>Configuring Prettier by Project</h2>&#13;
&#13;
<p>To add a Prettier configuration file to your project, you can create a <em>.prettierrc</em> file. This file will describe the project defaults:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"semi"</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="s2">"trailingComma"</code><code class="o">:</code> <code class="nx">none</code><code class="p">,</code>&#13;
  <code class="s2">"singleQuote"</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="s2">"printWidth"</code><code class="o">:</code> <code class="mi">80</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>These are our preferred defaults, but of course, choose what makes most sense to you. For more Prettier formatting options, check out <a href="https://prettier.io/docs/en/options.html">Prettier’s documentation</a>.</p>&#13;
&#13;
<p>Let’s replace what currently lives in our <em>sample.js</em> file with some code to format:</p>&#13;
&#13;
<pre data-type="programlisting">console.log("Prettier Test")</pre>&#13;
&#13;
<p>Now let’s try running the Prettier CLI from the Terminal or Command Prompt:</p>&#13;
&#13;
<pre data-type="programlisting">prettier --check "sample.js"</pre>&#13;
&#13;
<p>Prettier runs the test and shows us the following message: <code>Code style issues found in the above file(s). Forgot to run Prettier?</code> To run it from the CLI, we can pass the <code>write</code> flag:</p>&#13;
&#13;
<pre data-type="programlisting">prettier --write "sample.js"</pre>&#13;
&#13;
<p>Once we do this, we’ll see an output of a certain number of milliseconds that it took Prettier to format the file. If we open the file, we’ll see that the content has changed based on the defaults supplied in the <em>.prettierrc</em> file. If you’re thinking that this process seems laborious and could be sped up, you’re right. Let’s start automating!</p>&#13;
&#13;
<p>First, we’ll integrate ESLint and Prettier by installing a config tool and a plug-in:</p>&#13;
&#13;
<pre data-type="programlisting">npm install eslint-config-prettier eslint-plugin-prettier --save-dev</pre>&#13;
&#13;
<p>The config (<code>eslint-config-prettier</code>) turns off any ESLint rules that could conflict with Prettier. The plug-in (<code>eslint-plugin-prettier</code>) integrates Prettier rules into ESLint rules. In other words, when we run our <code>lint</code> script, Prettier will run, too.</p>&#13;
&#13;
<p>We’ll incorporate these tools into <em>.eslintrc.json</em>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"extends"</code><code class="o">:</code> <code class="p">[</code>&#13;
    <code class="c1">// ...</code>&#13;
    <code class="s2">"plugin:prettier/recommended"</code>&#13;
  <code class="p">],</code>&#13;
  <code class="s2">"plugins"</code><code class="o">:</code> <code class="p">[</code>&#13;
    <code class="c1">//,</code>&#13;
  <code class="s2">"prettier"</code><code class="p">],</code>&#13;
  <code class="s2">"rules"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
    <code class="s2">"prettier/prettier"</code><code class="o">:</code> <code class="s2">"error"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Make sure to break some formatting rules in your code to ensure that Prettier is working. For example, in <em>sample.js</em>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Prettier Test"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Running the lint command <code>npm run lint</code> will yield the following output:</p>&#13;
&#13;
<pre data-type="programlisting">1:13 error Replace `'Prettier·Test')` with `"Prettier·Test");` prettier/prettier</pre>&#13;
&#13;
<p>All of the errors were found. Now you can run the Prettier write command and sweep the formatting for one file:</p>&#13;
&#13;
<pre data-type="programlisting">prettier --write "sample.js"</pre>&#13;
&#13;
<p>Or for all of the JavaScript files in certain folders:</p>&#13;
&#13;
<pre data-type="programlisting">prettier --write "src/*.js"</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Prettier in VSCode" data-type="sect2"><div class="sect2" id="prettier-in-vscode">&#13;
<h2>Prettier in VSCode</h2>&#13;
&#13;
<p>If<a data-primary="VSCode" data-type="indexterm" id="idm45901620562984"/> you’re using VSCode, it’s highly recommended that you set up Prettier in your editor. Configuration is fairly quick and will save you a lot of time as you’re writing code.</p>&#13;
&#13;
<p>You’ll first want to install the VSCode extension for Prettier. Just follow <a href="https://oreil.ly/-7Zgz">this link</a> and click Install. Once installed, you can run Prettier with Control + Command + P on a Mac or Ctrl + Shift + P on a PC to manually format a file or highlighted bit of code. For even better results, you can format your code on Save. This involves adding some settings to VSCode.</p>&#13;
&#13;
<p>To access these settings, select the Code menu, then Preferences, then Settings. (Or Command + comma on a Mac or Ctrl + comma on a PC, if you’re in a hurry.) Then you can click on the small paper icon in the upper right-hand corner to open the VSCode settings as JSON. You’ll want to add a few helpful keys here:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"editor.formatOnSave"</code><code class="p">:</code> <code class="kc">true</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now when you save any file, Prettier will format it based on the <code>.prettierrc</code> defaults! Pretty killer. You can also search Settings for Prettier options to set up defaults in your editor if you want to enforce formatting, even if your project doesn’t contain a <em>.prettierrc</em> config file.</p>&#13;
&#13;
<p>If you’re using a different editor, Prettier likely supports that, too. For instructions specific to other code editors, check out the <a href="https://prettier.io/docs/en/editors.html">Editor Integration section of the docs</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Typechecking for React Applications" data-type="sect1"><div class="sect1" id="typechecking-for-react-apps">&#13;
<h1>Typechecking for React Applications</h1>&#13;
&#13;
<p>When you’re working with a larger application, you may want to incorporate typechecking to help pinpoint certain types of bugs. There are three main solutions for typechecking in React apps: the <code>prop-types</code> library, Flow, and TypeScript. In the next section, we’ll take a closer look at how you might set up these tools to increase code quality.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="PropTypes" data-type="sect2"><div class="sect2" id="prop-types">&#13;
<h2>PropTypes</h2>&#13;
&#13;
<p>In<a data-primary="unit testing" data-secondary="typechecking" data-tertiary="PropTypes library" data-type="indexterm" id="idm45901620535160"/><a data-primary="PropTypes library" data-type="indexterm" id="idm45901620605656"/><a data-primary="typechecking" data-secondary="PropTypes library" data-type="indexterm" id="idm45901620604984"/> the first edition of this book, PropTypes were part of the core React library and were the recommended way to add typechecking to your application. Today, due to the emergence of other solutions like Flow and TypeScript, the functionality has been moved to its own library to make React’s bundle size smaller. Still, PropTypes are a widely used solution.</p>&#13;
&#13;
<p>To add PropTypes to your app, install the <code>prop-types</code> library:</p>&#13;
&#13;
<pre data-type="programlisting">npm install prop-types --save-dev</pre>&#13;
&#13;
<p>We’ll test this by creating a minimal <code>App</code> component that renders the name of a library:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ReactDOM</code> <code class="nx">from</code> <code class="s2">"react-dom"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">({</code> <code class="nx">name</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">name</code><code class="o">=</code><code class="s2">"React"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Then we’ll import the <code>prop-types</code> library and use <code>App.propTypes</code> to define which type each property should be:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">PropTypes</code> <code class="nx">from</code> <code class="s2">"prop-types"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">({</code> <code class="nx">name</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">App</code><code class="p">.</code><code class="nx">propTypes</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="nx">PropTypes</code><code class="p">.</code><code class="nx">string</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>The <code>App</code> component has one property <code>name</code> and should always be a string. If an incorrect type value is passed as the name, an error will be thrown. For example, if we used a boolean:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">name</code><code class="o">=</code><code class="s2">"React"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Our console would report a problem back to us:</p>&#13;
&#13;
<pre data-type="programlisting">Warning: Failed prop type: Invalid prop name of type boolean supplied to App,&#13;
expected string. in App</pre>&#13;
&#13;
<p>When a value of an incorrect type is provided for a property, the warning only appears in development mode. The warnings and broken renders won’t appear in production.</p>&#13;
&#13;
<p>Other types are available, of course, when validating properties. We could add a boolean for whether or not a technology was used at a company:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">({</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">using</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">using</code> <code class="o">?</code> <code class="s2">"used here"</code> <code class="o">:</code> <code class="s2">"not used here"</code><code class="p">}</code>&#13;
      <code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">App</code><code class="p">.</code><code class="nx">propTypes</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="nx">PropTypes</code><code class="p">.</code><code class="nx">string</code><code class="p">,</code>&#13;
  <code class="nx">using</code><code class="o">:</code> <code class="nx">PropTypes</code><code class="p">.</code><code class="nx">bool</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">name</code><code class="o">=</code><code class="s2">"React"</code> <code class="nx">using</code><code class="o">=</code><code class="p">{</code><code class="kc">true</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>The longer list of type checks includes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>PropTypes.array</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>PropTypes.object</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>PropTypes.bool</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>PropTypes.func</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>PropTypes.number</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>PropTypes.string</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>PropTypes.symbol</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Additionally, if you want to ensure that a value was provided, you can chain <code>.isRequired</code> onto the end of any of these options. For example, if a string must be supplied, you’d use:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">App</code><code class="p">.</code><code class="nx">propTypes</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="nx">PropTypes</code><code class="p">.</code><code class="nx">string</code><code class="p">.</code><code class="nx">isRequired</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Then, if you fail to provide a value for this field, the following warning will appear in the console:</p>&#13;
&#13;
<pre data-type="programlisting">index.js:1 Warning: Failed prop type: The prop name is marked as required in App,&#13;
but its value is undefined.</pre>&#13;
&#13;
<p>There also may be situations where you don’t care what the value is, as long as a value is provided. In that case, you can use <code>any</code>. For example:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">App</code><code class="p">.</code><code class="nx">propTypes</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="nx">PropTypes</code><code class="p">.</code><code class="nx">any</code><code class="p">.</code><code class="nx">isRequired</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This means that a boolean, string, number––anything––could be supplied. As long as <code>name</code> is not <code>undefined</code>, the typecheck will succeed.</p>&#13;
&#13;
<p>In addition to the basic typechecks, there are a few other utilities that are useful for many real-world situations. Consider a component where there are two <code>status</code> options: <code>Open</code> and <code>Closed</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">({</code> <code class="nx">status</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code>&#13;
        <code class="nx">We</code><code class="err">'</code><code class="nx">re</code> <code class="p">{</code><code class="nx">status</code> <code class="o">===</code> <code class="s2">"Open"</code> <code class="o">?</code> <code class="s2">"Open!"</code> <code class="o">:</code> <code class="s2">"Closed!"</code><code class="p">}</code>&#13;
      <code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">status</code><code class="o">=</code><code class="s2">"Open"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Status is a string, so we might be inclined to use the string check:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">App</code><code class="p">.</code><code class="nx">propTypes</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">status</code><code class="o">:</code> <code class="nx">PropTypes</code><code class="p">.</code><code class="nx">string</code><code class="p">.</code><code class="nx">isRequired</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>That works well, but if other string values besides <code>Open</code> and <code>Closed</code> are passed in, the property will be validated. The type of check we actually want to enforce is an enum check. An enumeration type is a restricted list of options for a particular field or property. We’ll adjust the <code>propTypes</code> object like so:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">App</code><code class="p">.</code><code class="nx">propTypes</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">status</code><code class="o">:</code> <code class="nx">PropTypes</code><code class="p">.</code><code class="nx">oneOf</code><code class="p">([</code><code class="s2">"Open"</code><code class="p">,</code> <code class="s2">"Closed"</code><code class="p">])</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now if anything other than the values from the array that’s passed to <code>PropTypes.oneOf</code> is supplied, a warning will appear.</p>&#13;
&#13;
<p>For all the options you can configure for PropTypes in your React app, check out <a href="https://oreil.ly/pO2Js">the documentation</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Flow" data-type="sect2"><div class="sect2" id="flow">&#13;
<h2>Flow</h2>&#13;
&#13;
<p>Flow<a data-primary="unit testing" data-secondary="typechecking" data-tertiary="Flow" data-type="indexterm" id="idm45901620000248"/><a data-primary="Flow" data-type="indexterm" id="idm45901619997768"/><a data-primary="typechecking" data-secondary="Flow" data-type="indexterm" id="idm45901619997064"/> is a typechecking library that’s used and maintained by Facebook Open Source. It’s a tool that checks for errors via static type annotations. In other words, if you create a variable that’s a particular type, Flow will check to be sure that that value used is the correct type.</p>&#13;
&#13;
<p>Let’s fire up a Create React App project:</p>&#13;
&#13;
<pre data-type="programlisting">npx create-react-app in-the-flow</pre>&#13;
&#13;
<p>Then we’ll add Flow to the project. Create React App doesn’t assume you want to use Flow, so it doesn’t ship with the library, but it’s smooth to incorporate:</p>&#13;
&#13;
<pre data-type="programlisting">npm install --save flow-bin</pre>&#13;
&#13;
<p>Once installed, we’ll add an npm script to run Flow when we type <code>npm run flow</code>. In <em>package.json</em>, just add this to the <code>scripts</code> key:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"scripts"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"start"</code><code class="p">:</code> <code class="s2">"react-scripts start"</code><code class="p">,</code>&#13;
    <code class="nt">"build"</code><code class="p">:</code> <code class="s2">"react-scripts build"</code><code class="p">,</code>&#13;
    <code class="nt">"test"</code><code class="p">:</code> <code class="s2">"react-scripts test"</code><code class="p">,</code>&#13;
    <code class="nt">"eject"</code><code class="p">:</code> <code class="s2">"react-scripts eject"</code><code class="p">,</code>&#13;
    <code class="nt">"flow"</code><code class="p">:</code> <code class="s2">"flow"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now running the <code>flow</code> command will run typechecking on our files. Before we can use it, though, we need to create a <em>.flowconfig</em> file. To do so, we run:</p>&#13;
&#13;
<pre data-type="programlisting">npm run flow init</pre>&#13;
&#13;
<p>This creates a skeleton of a configuration file that looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">[ignore]&#13;
&#13;
[include]&#13;
&#13;
[libs]&#13;
&#13;
[lints]&#13;
&#13;
[options]&#13;
&#13;
[strict]</pre>&#13;
&#13;
<p>In most cases, you’ll leave this blank to use Flow’s defaults. If you want to configure Flow beyond the basics, you can explore more options in <a href="https://flow.org/en/docs/config/">the documentation</a>.</p>&#13;
&#13;
<p class="pagebreak-before">One of the coolest features of Flow is that you can adopt Flow incrementally. It can feel overwhelming to have to add typechecking to an entire project. With Flow, this isn’t a requirement. All you need to do is add the line <code>//@flow</code> to the top of any files you want to typecheck, then Flow will automatically only check those files.</p>&#13;
&#13;
<p>Another option is to add the VSCode extension for Flow to help with code completion and parameter hints. If you have Prettier or a linting tool set up, this will help your editor handle the unexpected syntax of Flow. You can find that <a href="https://oreil.ly/zdaPv">in the marketplace</a>.</p>&#13;
&#13;
<p>Let’s open the <em>index.js</em> file and, for the sake of simplicity, keep everything in the same file. Make sure to add <code>//@flow</code> to the top of the file:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">//@flow</code>&#13;
&#13;
<code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ReactDOM</code> <code class="nx">from</code> <code class="s2">"react-dom"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">(</code><code class="nx">props</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">item</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="s2">"jacket"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Now we’ll define the types for the properties:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">type</code> <code class="nx">Props</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">item</code><code class="o">:</code> <code class="nx">string</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">Props</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">//...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Then run Flow <code>npm run flow</code>. In certain versions of Flow, you may see this warning:</p>&#13;
&#13;
<pre data-type="programlisting">Cannot call ReactDOM.render with root bound to container because null [1] is&#13;
incompatible with Element [2]</pre>&#13;
&#13;
<p>This warning exists because if <code>document.getElementById("root")</code> returns <code>null</code>, the app will crash. To safeguard against this (and to clear the error), we can do one of two things. The first approach is to use an <code>if</code> statement to check to see that <code>root</code> is not <code>null</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">root</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">);</code>&#13;
&#13;
<code class="k">if</code> <code class="p">(</code><code class="nx">root</code> <code class="o">!==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="s2">"jacket"</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="nx">root</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Another option is to add a typecheck to the root constant using Flow syntax:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">root</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">);</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="s2">"jacket"</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="nx">root</code><code class="p">);</code></pre>&#13;
&#13;
<p>In either case, you’ll clear the error and see that your code is free of errors!</p>&#13;
&#13;
<p><em>No errors!</em></p>&#13;
&#13;
<p>We could trust this fully, but trying to break it feels like a good idea. Let’s pass a different property type to the app:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="p">{</code><code class="mi">3</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="nx">root</code><code class="p">);</code></pre>&#13;
&#13;
<p>Cool, we broke it! Now we get an error that reads:</p>&#13;
&#13;
<pre data-type="programlisting">Cannot create App element because number [1] is incompatible with string [2]&#13;
in property item.</pre>&#13;
&#13;
<p>Let’s switch it back and add another property for a number. We’ll also adjust the component and property definitions:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">type</code> <code class="nx">Props</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">item</code><code class="o">:</code> <code class="nx">string</code><code class="p">,</code>&#13;
  <code class="nx">cost</code><code class="o">:</code> <code class="nx">number</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">Props</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">item</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">Cost</code><code class="o">:</code> <code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">cost</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/p&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="s2">"jacket"</code> <code class="nx">cost</code><code class="o">=</code><code class="p">{</code><code class="mi">249</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nx">root</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Running this works, but what if we removed the cost value?</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="s2">"jacket"</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="nx">root</code><code class="p">);</code></pre>&#13;
&#13;
<p>We’ll immediately get an error:</p>&#13;
&#13;
<pre data-type="programlisting">Cannot create App element because property cost is missing in props [1] but&#13;
exists in Props [2].</pre>&#13;
&#13;
<p>If <code>cost</code> is truly not a required value, we can make it optional in the property definitions using the question mark after the property name, <code>cost?</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">type</code> <code class="nx">Props</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">item</code><code class="o">:</code> <code class="nx">string</code><code class="p">,</code>&#13;
  <code class="nx">cost</code><code class="o">?:</code> <code class="nx">number</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>If we run it again, we don’t see the error.</p>&#13;
&#13;
<p>That’s the tip of the iceberg with all of the different features that Flow has to offer. To learn more and to stay on top of the changes in the library, head over to the <a href="https://flow.org/en/docs/getting-started/">documentation site</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="TypeScript" data-type="sect2"><div class="sect2" id="typescript">&#13;
<h2>TypeScript</h2>&#13;
&#13;
<p>TypeScript<a data-primary="unit testing" data-secondary="typechecking" data-tertiary="TypeScript" data-type="indexterm" id="idm45901619999096"/><a data-primary="TypeScript" data-type="indexterm" id="idm45901619472440"/><a data-primary="typechecking" data-secondary="TypeScript" data-type="indexterm" id="idm45901619471768"/> is another popular tool for typechecking in React applications. It’s an open source superset of JavaScript, which means that it adds additional features to the language. Created at Microsoft, TypeScript is designed to be used for large apps to help developers find bugs and iterate more quickly on projects.</p>&#13;
&#13;
<p>TypeScript has a growing allegiance of supporters, so the tooling in the ecosystem continues to improve. One tool that we’re already familiar with is Create React App, which has a TypeScript template we can use. Let’s set up some basic typechecking, similar to what we did with PropTypes and Flow, to get a sense of how we can start using it in our own apps.</p>&#13;
&#13;
<p>We’ll start by generating yet another Create React App, this time with some different flags:</p>&#13;
&#13;
<pre data-type="programlisting">npx create-react-app my-type --template typescript</pre>&#13;
&#13;
<p>Now let’s tour the features of our scaffolded project. Notice in the <code>src</code> directory that the file extensions are <em>.ts</em> or <em>.tsx</em> now. We’ll also find a <em>.tsconfig.json</em> file, which contains all of our TypeScript settings. More on that in a bit.</p>&#13;
&#13;
<p>Also, if you take a look at the <em>package.json</em> file, there are new dependencies listed and installed related to TypeScript, like the library itself and type definitions for Jest, React, ReactDOM, and more. Any dependency that starts with <code>@types/</code> describes the type definitions for a library. That means that the functions and methods in the library are typed so that we don’t have to describe all of the library’s types.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If your project doesn’t include the TypeScript features, you might be using an old version of Create React App. To get rid of this, you can run <code>npm uninstall -g create-react-app</code>.</p>&#13;
</div>&#13;
&#13;
<p>Let’s try dropping our component from the Flow lesson into our project. Just add the following to the <em>index.ts</em> file:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ReactDOM</code> <code class="nx">from</code> <code class="s2">"react-dom"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">(</code><code class="nx">props</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">item</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="s2">"jacket"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>If we run the project with <code>npm start</code>, we should see our first TypeScript error. This is to be expected at this point:</p>&#13;
&#13;
<pre data-type="programlisting">Parameter 'props' implicitly has an 'any' type.</pre>&#13;
&#13;
<p>This means we need to add type rules for this <code>App</code> component. We’ll start by defining types just as we did earlier for the Flow component. The <code>item</code> is a string, so we’ll add that to the <code>AppProps</code> type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AppProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">item</code>: <code class="kr">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="s2">"jacket"</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Then we’ll reference <code>AppProps</code> in the component:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">(</code><code class="nx">props</code>: <code class="nx">AppProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">item</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now the component will render with no TypeScript issues. It’s also possible to destructure <code>props</code> if we’d like to:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">({</code> <code class="nx">item</code> <code class="p">}</code><code class="o">:</code> <code class="nx">AppProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">item</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can break this by passing a value of a different type as the <code>item</code> property:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">App</code> <code class="nx">item</code><code class="o">=</code><code class="p">{</code><code class="mi">1</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>This immediately triggers an error:</p>&#13;
&#13;
<pre data-type="programlisting">Type 'number' is not assignable to type 'string'.</pre>&#13;
&#13;
<p>The error also tells us the exact line where there’s a problem. This is extremely useful as we’re debugging.</p>&#13;
&#13;
<p>TypeScript helps with more than just property validation, though. We<a data-primary="type inference" data-type="indexterm" id="idm45901619143768"/> can use TypeScript’s <em>type inference</em> to help us do typechecking on hook values.</p>&#13;
&#13;
<p>Consider a state value for a <code>fabricColor</code> with an initial state of <code>purple</code>. The component might look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">AppProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">item</code>: <code class="kr">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">({</code> <code class="nx">item</code> <code class="p">}</code><code class="o">:</code> <code class="nx">AppProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">fabricColor</code><code class="p">,</code> <code class="nx">setFabricColor</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code>&#13;
    <code class="s2">"purple"</code>&#13;
  <code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">fabricColor</code><code class="p">}</code> <code class="p">{</code><code class="nx">item</code><code class="p">}</code>&#13;
      <code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">button</code>&#13;
        <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setFabricColor</code><code class="p">(</code><code class="s2">"blue"</code><code class="p">)}</code>&#13;
      <code class="o">&gt;</code>&#13;
        <code class="nx">Make</code> <code class="nx">the</code> <code class="nx">Jacket</code> <code class="nx">Blue</code>&#13;
      <code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice that we haven’t added anything to the type definitions object. Instead, TypeScript is inferring that the type for the <code>fabricColor</code> should match the type of its initial state. If we try setting the <code>fabricColor</code> with a number instead of another string color <code>blue</code>, an error will be thrown:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">setFabricColor</code><code class="p">(</code><code class="mi">3</code><code class="p">)}</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>The error looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">Argument of type '3' is not assignable to parameter of type string.</pre>&#13;
&#13;
<p>TypeScript is hooking us up with some pretty low-effort typechecking for this value. Of course, you can customize this further, but this should give you a start toward adding typechecking to your applications.</p>&#13;
&#13;
<p>For more on TypeScript, check out the <a href="https://oreil.ly/97_Px">official docs</a> and the amazing <a href="https://oreil.ly/vmran">React+TypeScript Cheatsheets on GitHub</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Test-Driven Development" data-type="sect1"><div class="sect1" id="test-driven-development">&#13;
<h1>Test-Driven Development</h1>&#13;
&#13;
<p>Test-driven<a data-primary="unit testing" data-secondary="test-driven development" data-type="indexterm" id="idm45901618940072"/><a data-primary="test-driven development (TDD)" data-type="indexterm" id="idm45901618939064"/> development, or TDD, is a practice—not a technology. It does not mean that you simply have tests for your application. Rather, it’s the practice of letting the tests drive the development process.  In order to practice TDD, you should follow these steps:</p>&#13;
<dl>&#13;
<dt>Write the tests first</dt>&#13;
<dd>&#13;
<p>This is the most critical step. You declare what you’re building and how it should work first in a test. The steps you’ll use to test are red, green, and gold.</p>&#13;
</dd>&#13;
<dt>Run the tests and watch them fail (red)</dt>&#13;
<dd>&#13;
<p>Run the tests and watch them fail before you write the code.</p>&#13;
</dd>&#13;
<dt>Write the minimal amount of code required to make the tests pass (green)</dt>&#13;
<dd>&#13;
<p>Focus specifically on making each test pass; do not add any functionality beyond the scope of the test.</p>&#13;
</dd>&#13;
<dt>Refactor both the code and the tests (gold)</dt>&#13;
<dd>&#13;
<p>Once the tests pass, it’s time to take a closer look at your code and your tests. Try to express your code as simply and as beautifully as possible.<sup><a data-type="noteref" href="ch10.html#idm45901618932040" id="idm45901618932040-marker">2</a></sup></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>TDD gives us an excellent way to approach a React application, particularly when testing Hooks. It’s typically easier to think about how a Hook should work before actually writing it. Practicing TDD will allow you to build and certify the entire data structure for a feature or application independent of the UI.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="TDD and Learning" data-type="sect2"><div class="sect2" id="tdd-and-learning">&#13;
<h2>TDD and Learning</h2>&#13;
&#13;
<p>If you’re new to TDD, or new to the language you’re testing, you may find it challenging to write a test before writing code. This is to be expected, and it’s OK to write the code before the test until you get the hang of it. Try to work in small batches: a little bit of code, a few tests, and so on. Once you get used to writing tests, it will be easier to write the tests first.</p>&#13;
&#13;
<p>For the remainder of this chapter, we’ll be writing tests for code that already exists. Technically, we’re not practicing TDD. However, in the next section, we’ll pretend that our code does not already exist so we can get a feel for the TDD workflow.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Incorporating Jest" data-type="sect1"><div class="sect1" id="incorporating-jest">&#13;
<h1>Incorporating Jest</h1>&#13;
&#13;
<p>Before<a data-primary="unit testing" data-secondary="Jest" data-type="indexterm" id="UTjest102"/><a data-primary="Jest" data-type="indexterm" id="jest10"/> we can get started writing tests, we’ll need to select a testing framework. You can write tests for React with any JavaScript testing framework, but the official React docs recommend testing with Jest, a JavaScript test runner that lets you access the DOM via JSDOM. Accessing the DOM is important because you want to be able to check what is rendered with React to ensure your application is working correctly.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create React App and Testing" data-type="sect2"><div class="sect2" id="create-react-app-testing">&#13;
<h2>Create React App and Testing</h2>&#13;
&#13;
<p>Projects that have been initialized with<a data-primary="Create React App" data-type="indexterm" id="idm45901618970120"/> Create React App already come with the <code>jest</code> package installed. We can create another Create React App project to get started, or use an existing one:</p>&#13;
&#13;
<pre data-type="programlisting">npx create-react-app testing</pre>&#13;
&#13;
<p>Now we can start thinking about testing with a small example. We’ll create two new files in the <em>src</em> folder: <em>functions.js</em> and <em>functions.test.js</em>. Remember, Jest is already configured and installed in Create React App, so all you need to do is start writing tests. In <em>functions.test.js</em>, we’ll stub the tests. In other words, we’ll write what we think the function should do.</p>&#13;
&#13;
<p>We want our function to take in a value, multiply it by two, and return it. So we’ll model that in the test. The <code>test</code> function is the function that Jest provides to test a single piece of functionality:</p>&#13;
&#13;
<p><em>functions.test.js</em></p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"Multiplies by two"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">();</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>The first argument, <code>Multiplies by two</code>, is the test name. The second argument is the function that contains what should be tested and the third (optional) argument specifies a timeout. The default timeout is five seconds.</p>&#13;
&#13;
<p>The next thing we’ll do is stub the function that will multiply numbers by two. This function will be referred to as<a data-primary="system under test (SUT)" data-type="indexterm" id="idm45901618902696"/> our <em>system under test</em> (<em>SUT</em>). In <em>functions.js</em>, create the function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">timesTwo</code><code class="p">()</code> <code class="p">{...}</code></pre>&#13;
&#13;
<p>We’ll export it so that we can use the SUT in the test. In the test file, we want to import the function, and we’ll use <code>expect</code> to write an assertion. In the assertion, we’ll say that if we pass 4 to the <code>timesTwo</code> function, we expect that it should return 8:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">timesTwo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./functions"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">test</code><code class="p">(</code><code class="s2">"Multiplies by two"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">timesTwo</code><code class="p">(</code><code class="mi">4</code><code class="p">)).</code><code class="nx">toBe</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Jest “matchers” are returned by the <code>expect</code> function and used to verify results. To test the function, we’ll use the <code>.toBe</code> matcher. This verifies that the resulting object matches the argument sent to <code>.toBe</code>.</p>&#13;
&#13;
<p>Let’s run the tests and watch them fail using <code>npm test</code> or <code>npm run test</code>. Jest will provide specific details on each failure, including a stack trace:</p>&#13;
&#13;
<pre data-type="programlisting">FAIL  src/functions.test.js&#13;
  ✕ Multiplies by two (5ms)&#13;
&#13;
  ● Multiplies by two&#13;
&#13;
    expect(received).toBe(expected) // Object.is equality&#13;
&#13;
    Expected: 8&#13;
    Received: undefined&#13;
&#13;
      2 |&#13;
      3 | test("Multiplies by two", () =&gt; {&#13;
    &gt; 4 |   expect(timesTwo(4)).toBe(8);&#13;
        |                       ^&#13;
      5 | });&#13;
      6 |&#13;
&#13;
      at Object.&lt;anonymous&gt; (src/functions.test.js:4:23)&#13;
&#13;
Test Suites: 1 failed, 1 total&#13;
Tests:       1 failed, 1 total&#13;
Snapshots:   0 total&#13;
Time:        1.048s&#13;
Ran all test suites related to changed files.</pre>&#13;
&#13;
<p>Taking the time to write the tests and run them to watch them fail shows us that our tests are working as intended. This failure feedback represents our to-do list. It’s our job to write the minimal code required to make our tests pass.</p>&#13;
&#13;
<p>Now if we add the proper functionality to the <em>functions.js</em> file, we can make the tests pass:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="kd">function</code> <code class="nx">timesTwo</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>.toBe</code> matcher has helped us test for equality with a single value. If we want to test an object or array, we could use <code>.toEqual</code>. Let’s go through another cycle with our tests. In the test file, we’ll test for equality of an array of objects.</p>&#13;
&#13;
<p>We have a list of menu items from the Guy Fieri restaurant in Las Vegas. It’s important that we build an object of their ordered items so the customer can get what they want and know what they’re supposed to pay. We’ll stub the test first:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"Build an order object"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">();</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Then we’ll stub our function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="kd">function</code> <code class="nx">order</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now we’ll use the order function in the test file. We’ll also assume that we have a starter list of data for an order that we need to transform:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">timesTwo</code><code class="p">,</code> <code class="nx">order</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./functions"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">menuItems</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"1"</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Tatted Up Turkey Burger"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="mf">19.5</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"2"</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Lobster Lollipops"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="mf">16.5</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"3"</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Motley Que Pulled Pork Sandwich"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="mf">21.5</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s2">"4"</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Trash Can Nachos"</code><code class="p">,</code>&#13;
    <code class="nx">price</code><code class="o">:</code> <code class="mf">19.5</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">];</code>&#13;
&#13;
<code class="nx">test</code><code class="p">(</code><code class="s2">"Build an order object"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">order</code><code class="p">(</code><code class="nx">menuItems</code><code class="p">));</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Remember that we’ll use <code>toEqual</code> because we’re checking the value of an object instead of an array. What do we want the result to equal? Well, we want to create an object that looks like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">orderItems</code><code class="o">:</code> <code class="nx">menuItems</code><code class="p">,</code>&#13;
  <code class="nx">total</code><code class="o">:</code> <code class="mi">77</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>So we just add that to the test and use it in the assertion:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"Build an order object"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">orderItems</code><code class="o">:</code> <code class="nx">menuItems</code><code class="p">,</code>&#13;
    <code class="nx">total</code><code class="o">:</code> <code class="mi">77</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">order</code><code class="p">(</code><code class="nx">menuItems</code><code class="p">)).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">result</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Now we’ll complete the function in the <em>functions.js</em> file:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="kd">function</code> <code class="nx">order</code><code class="p">(</code><code class="nx">items</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">total</code> <code class="o">=</code> <code class="nx">items</code><code class="p">.</code><code class="nx">reduce</code><code class="p">(</code>&#13;
    <code class="p">(</code><code class="nx">price</code><code class="p">,</code> <code class="nx">item</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">price</code> <code class="o">+</code> <code class="nx">item</code><code class="p">.</code><code class="nx">price</code><code class="p">,</code>&#13;
    <code class="mi">0</code>&#13;
  <code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
    <code class="nx">orderItems</code><code class="o">:</code> <code class="nx">items</code><code class="p">,</code>&#13;
    <code class="nx">total</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And when we check out the terminal, we’ll find that are tests are now passing! Now this might feel like a trivial example, but if you were fetching data, it’s likely that you’d test for shape matches of arrays and objects.</p>&#13;
&#13;
<p>Another commonly used function with Jest is <code>describe()</code>. If you’ve used other testing libraries, you might have seen a similar function before. This function is typically used to wrap several related tests. For example, if we had a few tests for similar functions, we could wrap them in a <code>describe</code> statement:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">describe</code><code class="p">(</code><code class="s2">"Math functions"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s2">"Multiplies by two"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">timesTwo</code><code class="p">(</code><code class="mi">4</code><code class="p">)).</code><code class="nx">toBe</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s2">"Adds two numbers"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">)).</code><code class="nx">toBe</code><code class="p">(</code><code class="mi">6</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s2">"Subtracts two numbers"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">subtract</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">2</code><code class="p">)).</code><code class="nx">toBe</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>When you wrap tests in the <code>describe</code> statement, the test runner creates a block of tests, which makes the testing output in the terminal look more organized and easier to read:</p>&#13;
&#13;
<pre data-type="programlisting">Math functions&#13;
    ✓ Multiplies by two&#13;
    ✓ Adds two numbers&#13;
    ✓ Subtracts two numbers (1ms)</pre>&#13;
&#13;
<p>As you write more tests, grouping them in <code>describe</code> blocks might be a useful enhancement.</p>&#13;
&#13;
<p>This process represents a typical TDD cycle. We wrote the tests first, then wrote code to make the tests pass. Once the tests pass, we can take a closer look at the code to see if there’s anything that’s worth refactoring for clarity or performance. This approach is very effective when working with JavaScript (or really any other language).<a data-primary="" data-startref="UTjest102" data-type="indexterm" id="idm45901618323736"/><a data-primary="" data-startref="jest10" data-type="indexterm" id="idm45901618322760"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing React Components" data-type="sect1"><div class="sect1" id="testing-react-components">&#13;
<h1>Testing React Components</h1>&#13;
&#13;
<p>Now<a data-primary="unit testing" data-secondary="testing React components" data-type="indexterm" id="UTtest10"/><a data-primary="components" data-secondary="testing React components" data-type="indexterm" id="Ctest10"/><a data-primary="React components" data-type="indexterm" id="reactcomp10"/> that we have a basic understanding of the process behind writing tests, we can start to apply these techniques to component testing in React.</p>&#13;
&#13;
<p>React components provide instructions for React to follow when creating and managing updates to the DOM. We can test these components by rendering them and checking the resulting DOM.</p>&#13;
&#13;
<p>We’re not running our tests in a browser; we’re running them in the terminal with Node.js. Node.js does not have the DOM API that comes standard with each browser. Jest incorporates an npm package called <code>jsdom</code> that’s used to simulate a browser environment in Node.js, which is essential for testing React components.</p>&#13;
&#13;
<p>For each component test, it’s likely that we’ll need to render our React component tree to a DOM element. To demonstrate this workflow, let’s revisit our <code>Star</code> component in <em>Star.js</em>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">FaStar</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react-icons/fa"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">Star</code><code class="p">({</code> <code class="nx">selected</code> <code class="o">=</code> <code class="kc">false</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">FaStar</code> <code class="nx">color</code><code class="o">=</code><code class="p">{</code><code class="nx">selected</code> <code class="o">?</code> <code class="s2">"red"</code> <code class="o">:</code> <code class="s2">"grey"</code><code class="p">}</code> <code class="nx">id</code><code class="o">=</code><code class="s2">"star"</code> <code class="o">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">Then in <em>index.js</em>, we’ll import and render the star:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">Star</code> <code class="nx">from</code> <code class="s2">"./Star"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nx">Star</code> <code class="o">/&gt;</code><code class="p">,</code>&#13;
  <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"root"</code><code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Now let’s write our test. We already wrote the code for the star, so we won’t be partaking in TDD here. If you had to incorporate tests into your existing apps, this is how you’d do it. In a new file called <em>Star.test.js</em>, start by importing React, ReactDOM, and the <code>Star</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">ReactDOM</code> <code class="nx">from</code> <code class="s2">"react-dom"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="nx">Star</code> <code class="nx">from</code> <code class="s2">"./Star"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">test</code><code class="p">(</code><code class="s2">"renders a star"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"div"</code><code class="p">);</code>&#13;
  <code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Star</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="nx">div</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We’ll also want to write the tests. Remember, the first argument we supply to <code>test</code> is the name of the test. Then we’re going to perform some setup by creating a div that we can render the star to with <code>ReactDOM.render</code>. Once the element is created, we can write the assertion:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"renders a star"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"div"</code><code class="p">);</code>&#13;
  <code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Star</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="nx">div</code><code class="p">);</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">div</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"svg"</code><code class="p">)).</code><code class="nx">toBeTruthy</code><code class="p">();</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>We’ll expect that if we try to select an <code>svg</code> element inside of the created <code>div</code>, the result will be truthy. When we run the test, we should see that the test passes. Just to verify that we aren’t getting a valid assertion when we shouldn’t be, we can change the selector to find something fake and watch the test fail:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">expect</code><code class="p">(</code>&#13;
  <code class="nx">div</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"notrealthing"</code><code class="p">)</code>&#13;
<code class="p">).</code><code class="nx">toBeTruthy</code><code class="p">();</code></pre>&#13;
&#13;
<p><a href="https://oreil.ly/ah7ZU">The documentation</a> provides more detail about all of the custom matchers that are available so that you can test exactly what you want to test.</p>&#13;
&#13;
<p>When you generated your React project, you may have noticed that a few packages from <code>@testing-library</code> were installed in addition to the basics like React and ReactDOM. React Testing Library is a project that was started by Kent C. Dodds as a way to enforce good testing practices and to expand the testing utilities that were part of the React ecosystem. Testing Library is an umbrella over many testing packages for libraries like Vue, Svelte, Reason, Angular, and more—it’s not just for React.</p>&#13;
&#13;
<p>One potential reason you might choose React Testing Library is to get better error messages when a test fails. The current error we see when we test the assertion:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">expect</code><code class="p">(</code>&#13;
  <code class="nx">div</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"notrealthing"</code><code class="p">)</code>&#13;
<code class="p">).</code><code class="nx">toBeTruthy</code><code class="p">();</code></pre>&#13;
&#13;
<p>is:</p>&#13;
&#13;
<pre data-type="programlisting">expect(received).toBeTruthy()&#13;
&#13;
Received: null</pre>&#13;
&#13;
<p>Let’s punch this up by adding React Testing Library. It’s already installed in our Create React App project. To begin, we’ll import the <code>toHaveAttribute</code> function from <code>@testing-library/jest-dom</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">toHaveAttribute</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@testing-library/jest-dom"</code><code class="p">;</code></pre>&#13;
&#13;
<p>From there, we want to extend the functionality of <code>expect</code> to include this function:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">expect</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code> <code class="nx">toHaveAttribute</code> <code class="p">});</code></pre>&#13;
&#13;
<p>Now instead of using <code>toBeTruthy</code>, which gives us hard-to-read messages, we can use <code>toHaveAttribute</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"renders a star"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">div</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"div"</code><code class="p">);</code>&#13;
  <code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Star</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="nx">div</code><code class="p">);</code>&#13;
  <code class="nx">expect</code><code class="p">(</code>&#13;
    <code class="nx">div</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"svg"</code><code class="p">)</code>&#13;
  <code class="p">).</code><code class="nx">toHaveAttribute</code><code class="p">(</code><code class="s2">"id"</code><code class="p">,</code> <code class="s2">"hotdog"</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Now when we run the tests, we see an error telling us exactly what’s what:</p>&#13;
&#13;
<pre data-type="programlisting">    expect(element).toHaveAttribute("id", "hotdog")&#13;
    // element.getAttribute("id") === "hotdog"&#13;
&#13;
    Expected the element to have attribute:&#13;
      id="hotdog"&#13;
    Received:&#13;
      id="star"</pre>&#13;
&#13;
<p>It should be pretty straightforward to fix this now:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">expect</code><code class="p">(</code><code class="nx">div</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"svg"</code><code class="p">)).</code><code class="nx">toHaveAttribute</code><code class="p">(</code>&#13;
  <code class="s2">"id"</code><code class="p">,</code>&#13;
  <code class="s2">"star"</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Using more than one of the custom matchers just means that you need to import, extend, and use:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code>&#13;
  <code class="nx">toHaveAttribute</code><code class="p">,</code>&#13;
  <code class="nx">toHaveClass</code>&#13;
<code class="p">}</code> <code class="nx">from</code> <code class="s2">"@testing-library/jest-dom"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">expect</code><code class="p">.</code><code class="nx">extend</code><code class="p">({</code> <code class="nx">toHaveAttribute</code><code class="p">,</code> <code class="nx">toHaveClass</code> <code class="p">});</code>&#13;
&#13;
<code class="nx">expect</code><code class="p">(</code><code class="nx">you</code><code class="p">).</code><code class="nx">toHaveClass</code><code class="p">(</code><code class="s2">"evenALittle"</code><code class="p">);</code></pre>&#13;
&#13;
<p>There’s an even faster way to do this, though. If you find yourself importing too many of these matchers to list or keep track of, you can import the <code>extend-expect</code> library:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="s2">"@testing-library/jest-dom/extend-expect"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Remove this --&gt; expect.extend({ toHaveAttribute, toHaveClass });</code></pre>&#13;
&#13;
<p>The assertions will continue to run as expected (pun intended). Another fun fact about Create React App is that, in a file called <em>setupTests.js</em> that ships with CRA, there’s a line that has already included the <code>extend-expect</code> helpers. If you look at the <em>src</em> folder, you’ll see that <em>setupTests.js</em> contains:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// jest-dom adds custom jest matchers for asserting on DOM nodes.</code>&#13;
<code class="c1">// allows you to do things like:</code>&#13;
<code class="c1">// expect(element).toHaveTextContent(/react/i)</code>&#13;
<code class="c1">// learn more: https://github.com/testing-library/jest-dom</code>&#13;
<code class="kr">import</code> <code class="s2">"@testing-library/jest-dom/extend-expect"</code><code class="p">;</code></pre>&#13;
&#13;
<p>So if you’re using Create React App, you don’t even have to include the import in your test files.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Queries" data-type="sect2"><div class="sect2" id="queries">&#13;
<h2>Queries</h2>&#13;
&#13;
<p>Queries<a data-primary="queries (React Testing Library)" data-type="indexterm" id="idm45901617752456"/> are another feature of the React Testing Library that allow you to match based on certain criteria. In order to demonstrate using a query, let’s adjust the <code>Star</code> component to include a title. This will allow us to write a common style of test—one that matches based on text:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">Star</code><code class="p">({</code> <code class="nx">selected</code> <code class="o">=</code> <code class="kc">false</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Great</code> <code class="nx">Star</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">FaStar</code>&#13;
        <code class="nx">id</code><code class="o">=</code><code class="s2">"star"</code>&#13;
        <code class="nx">color</code><code class="o">=</code><code class="p">{</code><code class="nx">selected</code> <code class="o">?</code> <code class="s2">"red"</code> <code class="o">:</code> <code class="s2">"grey"</code><code class="p">}</code>&#13;
      <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s pause to think about what we’re trying to test. We want the component to render, and now we want to test to see if the <code>h1</code> contains the correct text. A function that’s part of React Testing Library, <code>render</code>, will help us do just that. <code>render</code> will replace our need to use <code>ReactDOM.render()</code>, so the test will look a bit different. Start by importing <code>render</code> from React Testing Library:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">render</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@testing-library/react"</code><code class="p">;</code></pre>&#13;
&#13;
<p><code>render</code> will take in one argument: the component or element that we want to render. The function returns an object of queries that can be used to check in with values in that component or element. The query we’ll use is <code>getByText</code>, which will find the first matching node for a query and throw an error if no elements match. To return a list of all matching nodes, use <code>getAllBy</code> to return an array:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"renders an h1"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">getByText</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Star</code> <code class="o">/&gt;</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">h1</code> <code class="o">=</code> <code class="nx">getByText</code><code class="p">(</code><code class="sr">/Great Star/</code><code class="p">);</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">h1</code><code class="p">).</code><code class="nx">toHaveTextContent</code><code class="p">(</code><code class="s2">"Great Star"</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p><code>getByText</code> finds the <code>h1</code> element via the regular expression that’s passed to it. Then we use the Jest matcher <code>toHaveTextContent</code> to describe what text the <code>h1</code> should include.</p>&#13;
&#13;
<p>Run the tests, and they’ll pass. If we change the text passed to the <code>toHaveTextContent()</code> function, the test will fail.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing Events" data-type="sect2"><div class="sect2" id="testing-events">&#13;
<h2>Testing Events</h2>&#13;
&#13;
<p>Another important part of writing tests is testing events that are part of components. Let’s use and test the <code>Checkbox</code> component we created in <a data-type="xref" href="ch07.html#enhancing_components_with_hooks">Chapter 7</a>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">export</code> <code class="kd">function</code> <code class="nx">Checkbox</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">checked</code><code class="p">,</code> <code class="nx">setChecked</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useReducer</code><code class="p">(</code>&#13;
    <code class="nx">checked</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">checked</code><code class="p">,</code>&#13;
    <code class="kc">false</code>&#13;
  <code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">label</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">checked</code> <code class="o">?</code> <code class="s2">"checked"</code> <code class="o">:</code> <code class="s2">"not checked"</code><code class="p">}</code>&#13;
        <code class="o">&lt;</code><code class="nx">input</code>&#13;
          <code class="nx">type</code><code class="o">=</code><code class="s2">"checkbox"</code>&#13;
          <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">checked</code><code class="p">}</code>&#13;
          <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">setChecked</code><code class="p">}</code>&#13;
        <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/label&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This component uses <code>useReducer</code> to toggle a checkbox. Our aim here is to create an automated test that will click this checkbox and change the value of <code>checked</code> from the default <code>false</code> to <code>true</code>. Writing a test to check the box will also fire <code>useReducer</code> and test the hook.</p>&#13;
&#13;
<p>Let’s stub the test:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">test</code><code class="p">(</code><code class="s2">"Selecting the checkbox should change the value of checked to true"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// .. write a test</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>The first thing we need to do is select the element that we want to fire the event on. In other words, which element do we want to click on with the automated test? We’ll use one of Testing Library’s queries to find the element we’re looking for. Since the input has a label, we can use <code>getByLabelText()</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">render</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@testing-library/react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">Checkbox</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./Checkbox"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">test</code><code class="p">(</code><code class="s2">"Selecting the checkbox should change the value of checked to true"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">getByLabelText</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Checkbox</code> <code class="o">/&gt;</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>When the component first renders, its label text reads <code>not checked</code>, so we can search via a regular expression to find a match with the string:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"Selecting the checkbox should change the value of checked to true"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">getByLabelText</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Checkbox</code> <code class="o">/&gt;</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">checkbox</code> <code class="o">=</code> <code class="nx">getByLabelText</code><code class="p">(</code><code class="sr">/not checked/</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Currently, this regex is case sensitive, so if you wanted to search for any case, you could add an <code>i</code> to the end of it. Use that technique with caution depending on how permissive you want the query selection to be:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">checkbox</code> <code class="o">=</code> <code class="nx">getByLabelText</code><code class="p">(</code><code class="sr">/not checked/i</code><code class="p">);</code></pre>&#13;
&#13;
<p>Now we have our checkbox selected. All we need to do now is fire the event (click the checkbox) and write an assertion to make sure that the <code>checked</code> property is set to <code>true</code> when the checkbox is clicked:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">mport</code> <code class="p">{</code> <code class="nx">render</code><code class="p">,</code> <code class="nx">fireEvent</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@testing-library/react"</code>&#13;
&#13;
<code class="nx">test</code><code class="p">(</code><code class="s2">"Selecting the checkbox should change the value of checked to true"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">getByLabelText</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Checkbox</code> <code class="o">/&gt;</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">checkbox</code> <code class="o">=</code> <code class="nx">getByLabelText</code><code class="p">(</code><code class="sr">/not checked/i</code><code class="p">);</code>&#13;
  <code class="nx">fireEvent</code><code class="p">.</code><code class="nx">click</code><code class="p">(</code><code class="nx">checkbox</code><code class="p">);</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">checkbox</code><code class="p">.</code><code class="nx">checked</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>You also could add the reverse toggle to this checkbox test by firing the event again and checking that the property is set to <code>false</code> on toggle. We changed the name of the test to be more accurate:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"Selecting the checkbox should toggle its value"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">getByLabelText</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Checkbox</code> <code class="o">/&gt;</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">checkbox</code> <code class="o">=</code> <code class="nx">getByLabelText</code><code class="p">(</code><code class="sr">/not checked/i</code><code class="p">);</code>&#13;
  <code class="nx">fireEvent</code><code class="p">.</code><code class="nx">click</code><code class="p">(</code><code class="nx">checkbox</code><code class="p">);</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">checkbox</code><code class="p">.</code><code class="nx">checked</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code>&#13;
  <code class="nx">fireEvent</code><code class="p">.</code><code class="nx">click</code><code class="p">(</code><code class="nx">checkbox</code><code class="p">);</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">checkbox</code><code class="p">.</code><code class="nx">checked</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>In this case, selecting the checkbox is pretty easy. We have a label we can use to find the input we want to check. In the event that you don’t have such an easy way to access a DOM element, Testing Library gives you another utility you can use to check in with any DOM element. You’ll start by adding an attribute to the element you want to select:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="o">&lt;</code><code class="nx">input</code>&#13;
  <code class="nx">type</code><code class="o">=</code><code class="s2">"checkbox"</code>&#13;
  <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">checked</code><code class="p">}</code>&#13;
  <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">setChecked</code><code class="p">}</code>&#13;
  <code class="nx">data</code><code class="o">-</code><code class="nx">testid</code><code class="o">=</code><code class="s2">"checkbox"</code> <code class="c1">// Add the data-testid= attribute</code>&#13;
<code class="err">/&gt;</code></pre>&#13;
&#13;
<p>Then use the query <code>getByTestId</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s2">"Selecting the checkbox should change the value of checked to true"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">getByTestId</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">render</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">Checkbox</code> <code class="o">/&gt;</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">checkbox</code> <code class="o">=</code> <code class="nx">getByTestId</code><code class="p">(</code><code class="s2">"checkbox"</code><code class="p">);</code>&#13;
  <code class="nx">fireEvent</code><code class="p">.</code><code class="nx">click</code><code class="p">(</code><code class="nx">checkbox</code><code class="p">);</code>&#13;
  <code class="nx">expect</code><code class="p">(</code><code class="nx">checkbox</code><code class="p">.</code><code class="nx">checked</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>This will do the same thing but is particularly useful when reaching out to DOM elements that are otherwise difficult to access.</p>&#13;
&#13;
<p>Once this <code>Checkbox</code> component is tested, we can confidently incorporate it into the rest of the application and reuse it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Code Coverage" data-type="sect2"><div class="sect2" id="using-code-coverage">&#13;
<h2>Using Code Coverage</h2>&#13;
&#13;
<p><em>Code coverage</em> is<a data-primary="code coverage" data-type="indexterm" id="idm45901616956600"/> the process of reporting on how many lines of code have actually been tested. It provides a metric that can help you decide when you’ve written enough tests.</p>&#13;
&#13;
<p>Jest ships with  Istanbul, a JavaScript tool used to review your tests and generate a report that describes how many statements, branches, functions, and lines have been covered.</p>&#13;
&#13;
<p>To run Jest with code coverage, simply add the <code>coverage</code> flag when you run the <code>jest</code> command:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">npm</code> <code class="nx">test</code> <code class="o">--</code> <code class="o">--</code><code class="nx">coverage</code></pre>&#13;
&#13;
<p>This report tells you how much of your code in each file has been executed during the testing process and reports on all files that have been imported into tests.</p>&#13;
&#13;
<p>Jest also generates a report that you can run in your browser, which provides more details about what code has been covered by tests. After running Jest with coverage reporting, you’ll notice that a <em>coverage</em> folder has been added to the root. In a web browser, open this file: <em>/coverage/lcov-report/index.html</em>. It will show you your code coverage in an interactive report.</p>&#13;
&#13;
<p>This report tells you how much of the code has been covered, as well as the individual coverage based on each subfolder. You can drill down into a subfolder to see how well the individual files within have been covered. If you select the <em>components/ui</em> folder, you’ll see how well your user interface components are covered by testing.</p>&#13;
&#13;
<p>You can see which lines have been covered in an individual file by clicking on the <span class="keep-together">filename</span>.</p>&#13;
&#13;
<p>Code coverage is a great tool to measure the reach of your tests. It’s one benchmark to help you understand when you’ve written enough unit tests for your code. It’s not typical to have 100% code coverage in every project. Shooting for anything above 85% is a good target.<sup><a data-type="noteref" href="ch10.html#idm45901616918376" id="idm45901616918376-marker">3</a></sup></p>&#13;
&#13;
<p>Testing<a data-primary="unit testing" data-secondary="benefits of" data-type="indexterm" id="idm45901616916712"/> can often feel like an extra step, but the tooling around React testing has never been better. Even if you don’t test all of your code, starting to think about how to incorporate testing practices can help you save time and money when building production-ready applications.<a data-primary="" data-startref="reactcomp10" data-type="indexterm" id="idm45901616915288"/><a data-primary="" data-startref="Ctest10" data-type="indexterm" id="idm45901616947528"/><a data-primary="" data-startref="UTtest10" data-type="indexterm" id="idm45901616946584"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45901621151704"><sup><a href="ch10.html#idm45901621151704-marker">1</a></sup> For a brief introduction to unit testing, see Martin Fowler’s article, <a href="http://martinfowler.com/bliki/UnitTest.html">“Unit Testing”</a>.</p><p data-type="footnote" id="idm45901618932040"><sup><a href="ch10.html#idm45901618932040-marker">2</a></sup> For more on this development pattern, see Jeff McWherter’s and James Bender’s <a href="https://oreil.ly/Hr6Me">“Red, Green, Refactor”</a>.</p><p data-type="footnote" id="idm45901616918376"><sup><a href="ch10.html#idm45901616918376-marker">3</a></sup> See Martin Fowler’s article, <a href="https://oreil.ly/Hbb-D">“Test-Coverage”</a>.</p></div></div></section></body></html>