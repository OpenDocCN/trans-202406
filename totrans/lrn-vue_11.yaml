- en: Chapter 11\. Testing in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To this point, we have learned about developing a complete Vue application from
    scratch with different Vue APIs. Our application is now ready for deployment,
    but before we do that, we need to make sure that our application is bug-free and
    ready for production. This is where testing comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is crucial to any application development, as it helps to increase code
    confidence and quality before releasing it to production. In this chapter, we
    will learn about the different types of testing and how to use them in Vue applications.
    We will also explore the various tools, such as Vitest and Vue Test Utils, for
    unit testing and PlaywrightJS for end-to-end (E2E) testing.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Unit Testing and E2E Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development has both manual and automated testing practices and techniques
    to ensure your application works as expected. While manual testing requires a
    tester to interact with the software manually and can be expensive, automated
    testing is mainly about executing a predefined test script containing a set of
    tests in an automated manner. The collection of automated tests can validate simple
    to more complex application scenarios, from a single function to a combination
    of different parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automated testing is more reliable and scalable than manual testing, assuming
    we write the tests correctly, and performs the following testing processes:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs: []
  type: TYPE_NORMAL
- en: The most common and lowest level of testing in software development. We use
    unit testing to validate a unit of code (or code block) that performs a specific
    action, such as functions, hooks, and modules. We can combine unit testing with
    test-driven development (TDD)^([1](ch11.html#id1547)) as a standard development
    practice.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating testing
  prefs: []
  type: TYPE_NORMAL
- en: This testing type validates the integration of different unit blocks of code.
    Integrating testing aims to assert the flow of logic functions, components, or
    modules. Component testing integrates testing with its internal logic as a unit
    test. We also mock most upstream services and other functions outside the test
    scope to ensure testing quality.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end (E2E) testing
  prefs: []
  type: TYPE_NORMAL
- en: The highest level of testing in software development. We use E2E testing to
    validate the entire application flow from the client side to the backend, usually
    by simulating actual user behaviors. There would not be any mocked services or
    functions in E2E testing, as we want to test the entire application flow.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Test-driven development (TDD) means you design and write the test cases first
    (red phase), work on the code to pass the tests (green phase), and improve the
    code implementation (refactor phase). It helps to verify the logic and design
    before actual development.
  prefs: []
  type: TYPE_NORMAL
- en: These three testing types form a pyramid of testing, as shown in [Figure 11-1](#figure_ch10_01),
    where the focus should be mainly on the unit tests, then integration testing,
    leaving the smallest number to E2E testing as it is primarily for sanity and can
    be expensive to trigger. Since we create an application from any components, services,
    and modules, performing unit testing for each isolated function or feature can
    be sufficient for keeping your codebase’s quality at the minimum cost and effort.
  prefs: []
  type: TYPE_NORMAL
- en: And as the primary ground for the testing system in our application, we start
    with unit tests using Vitest.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing a pyramid, divided into three levels representing unit
    testing, integration testing, and E2E testing](assets/lvue_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. Pyramid of testing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vitest as a Unit Testing Tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Vitest](https://oreil.ly/1upy0) is the test runner for unit testing built
    on Vite for Vite-powered projects. Its API is similar to Jest and Chai while offering
    a more modular approach to testing. Focusing on speed and developer experience,
    Vitest offers several significant features, including multithreading workers,
    TypeScript and JSX support, and component testing for frameworks such as Vue and
    React.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Vitest, we need to install it as a dev dependency in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then in the `package.json` file, we can add a new script command to run our
    tests in the watch mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Alternatively, during the Vue project initialization, we can choose to install
    Vitest as a unit testing tool ([“Create a New Vue Application”](ch01.html#chapter_01_newVueApp)),
    and Vite will take care of the rest, including some sample tests as the starter.
  prefs: []
  type: TYPE_NORMAL
- en: Once we run the command `yarn test` in the terminal (or command line), Vitest
    will automatically detect the test files whose name contains the pattern `.spec.`
    or `.test.` in the project directory. For example, a test file for the `useFetch`
    hook will be either `useFetch.spec.ts` or `useFetch.test.ts`. Whenever you change
    any test file, Vitest will rerun the test in your local environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using vitest with Extra Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can specify the mode for the `vitest` command, such as `vitest watch` for
    watch mode explicitly or `vitest run` for a one-time run on all the tests. Vite
    will automatically switch to the single run mode when using the `vitest` command
    alone in a continuous integration (CI) environment.
  prefs: []
  type: TYPE_NORMAL
- en: We can further customize the settings for Vitest using the command parameters
    or the Vite config file `vite.config.js` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Vitest Using Parameters and Config File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Vitest will scan for tests starting from the project folder as
    its current directory. We can specify a target folder for Vitest to check by passing
    the folder path as an argument to the test command, such as the `tests` folder
    within the source `src` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this chapter, we will put our tests under the `tests` folder, with the test
    file name convention `<test-file-name.test>.ts` (such as `myComponent.test.ts`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also specify the test files to run by passing the file path as an argument
    to the `yarn test` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command is handy when working on a file and wanting to enable the watch
    mode for that test file exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to set the `environment` parameter to `jsdom` (JSDOM^([2](ch11.html#id1566)))
    as the DOM environment runner for our Vue project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Without setting the environment, Vitest will use the default environment `node`,
    which is unsuitable for testing UI components and interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using the command parameters, we can also modify the `vite.config.js`
    file to configure our Vitest runner, using the field `test` with the relevant
    properties `root` and `environment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to add the reference to Vitest using the `<reference>` tag within
    this file by adding the following line to the top of the `vite.config.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As a result, Vite will know that we are using Vitest as the test runner and
    will provide the relevant type definitions for the `test` field in the config
    file for TypeScript type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also can turn on the global mode for the Vitest APIs across the entire project,
    so we don’t need to import any function explicitly from the `vitest` package into
    our test files. We can do this by enabling the `globals` flag of the `test` object
    in the `vite.config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `globals` is enabled, for TypeScript to be able to detect the availability
    of Vitest APIs as global, we still have one more step to perform: adding `vitest/globals`
    type definitions to the `types` array in the `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With these settings, we are now ready to start writing our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Your First Test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the TDD approach, let’s start with a simple test to check if a function
    to filter an array based on a given string and an array element’s property key
    is working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new file, `filterArray.test.ts`, in the `src/tests` folder
    and another one, `filterArray.ts` in the `src/utils` folder. The `filterArray.ts`
    should export a function `filterArray`, which takes three arguments (the original
    array to filter of type `ArrayObject`, a `string` property key, and the `string`
    term to filter with) and returns the filtered elements of type `ArrayObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`{ [key: string]: string }` is a type for an object with a `string` key and
    a `string` value. Specify using type instead of the generic `Object` (similar
    to using `any`) to avoid the potential bug of passing the wrong object type to
    the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `filterArray.test.ts` file, we will import the `filterArray` function
    and model its functionality. We will use the `it()` method and `expect()` from
    the `@vitest` package to define a single test case, and to assert the expected
    result, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can remove the `import { it, expect } from *@vitest*` line if we have `globals`
    set to `true` in the `vite.config.ts` file or the command line with the `--globals`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: The `it()` method takes a string representing the test case’s name (`should
    return a filtered array`), a function containing the test logic to run, and an
    optional timeout for waiting for the test to complete. By default, we have five
    seconds for the test’s timeout.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now implement the test logic for our first test case. We also assume
    that we have a list of pizzas that we need to filter by `title` containing `Hawaiian`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`expect()` returns a test instance that has various modifiers such as `not`,
    `resolves`, `rejects`, and matcher functions like `toEqual` and `toBe`. While
    `toEqual` performs a deep comparison for equality on the target object, `toBe`
    performs an additional check to the target value’s instance reference in the memory.
    In most scenarios, using `toEqual` is good enough for validating our logic, such
    as checking the returned value to match our desired array. We will define our
    target `result` array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s modify our `pizzas` to ensure it contains elements of `result` before
    passing it to the `filterArray` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use `.toEqual()` to assert the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Let’s run our tests in the watch mode using the `yarn test` command. The test
    will fail, and Vitest will display the failure’s details, including the expected
    result and the actual result, as seen in [Figure 11-2](#figure_chap10_02).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot displaying a stack trace for each test and details of the failed
    test](assets/lvue_1102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. Test failure details
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Part of the TDD approach is to define the tests and watch them fail before implementing
    the actual code. The next step is working on the `filterArray` function to make
    the test pass with the minimum code required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example implementation of `filterArray` using `filter()` and `toLowerCase()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this code, our test should pass ([Figure 11-3](#figure_chap10_03)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot displaying a stack trace for each test and details of the failed
    test](assets/lvue_1103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3\. Test passes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At this point, you can create more tests to cover the rest of the function’s
    scenarios. For example, when the key doesn’t exist in the array’s element (`item[key]`
    is `undefined`), or when the `term` is case-insensitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the terminal, you will see the tests displayed with the relevant name ([Figure 11-4](#figure_chap10_04))
    in a flat order.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot displaying a stack trace for each test and details of the failed
    test](assets/lvue_1104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-4\. Displaying the tests in a flat order
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As the number of tests in a file and the number of test files grow, the flat
    order can be hard to read and understand. To make it readable per functionality,
    use `describe()` to group the tests into logical blocks, each with the appropriate
    block name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Vitest will display the tests in a more organized hierarchy, as seen in [Figure 11-5](#figure_chap10_05).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot displaying a stack trace for each test and details of the failed
    test](assets/lvue_1105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-5\. Displaying the tests per group
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can move `pizzas` and `result` inside the `describe` block. This ensures
    the scope of these variables is relevant only within the `filterArray` test group.
    Otherwise, once this test suite runs, these two variables will be available in
    the global test scope and can overlap other variables with the same name, causing
    unwanted behavior.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have learned how to write tests for a function with the TDD
    approach using `it()`, `expect()`, and grouping them with `expect()`. While TDD
    is handy if we understand all the desired scenarios for our function, it can be
    challenging for beginners to adapt and follow. Consider combining TDD and other
    approaches rather than following a single process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also use `test()` for `it()`, `assert()`, and for `expect()` as their
    alternatives. While its name should start with “should do something” representing
    a coherent sentence (such as “it should return a filtered array”), `test` can
    be any meaningful name.
  prefs: []
  type: TYPE_NORMAL
- en: Since composables in Vue are JavaScript functions that use Vue’s Composition
    API, using Vitest to test them is simple. Next, we will explore how to write tests
    for composables, starting with the non-lifecycle ones.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Non-Lifecycle Composables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start with a composition function, `useFilter`, that returns an object
    containing the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filterBy`'
  prefs: []
  type: TYPE_NORMAL
- en: The key to filtering by
  prefs: []
  type: TYPE_NORMAL
- en: '`filterTerm`'
  prefs: []
  type: TYPE_NORMAL
- en: The term to filter by
  prefs: []
  type: TYPE_NORMAL
- en: '`filteredArray`'
  prefs: []
  type: TYPE_NORMAL
- en: The filtered array
  prefs: []
  type: TYPE_NORMAL
- en: '`order`'
  prefs: []
  type: TYPE_NORMAL
- en: The order of the filtered array, with the default value of `asc`
  prefs: []
  type: TYPE_NORMAL
- en: It accepts a reactive array, `arr`, a `key`, and a `term` as initial values
    for the filtered array, the filter key, and the filter term.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation for `useFilter` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_testing_in_vue_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare `arr` as a reactive `Ref` type of `ArrayObject` and `key` and `term`
    as `string` types
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_testing_in_vue_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create `filterBy`, `filterTerm`, and `order` as `ref()` with the initial values
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_testing_in_vue_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create `filteredArray` as `computed()`, reacting to changes of `filterBy`, `filterTerm`,
    `order`, and `arr`
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `tests/` folder, we create a file `useFilter.test.ts` to test `useFilter`,
    with the following setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `books` is a constant array and not a Vue-reactive object, in our test
    case we will wrap it with `ref()` to enable its reactivity before passing it to
    the function for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We also declare the expected `result` based on the `books` array value. Now
    we can write our first reactivity test case, where we assert the `useFilter` function
    to return the updated filtered array when changing `filterTerm`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When we run the test, it should pass with the output shown in [Figure 11-6](#figure_ch10_composable_1).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the passing tests for +useFilter+](assets/lvue_1106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-6\. All the tests for `useFilter` pass
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can continue writing the test cases for `filterBy` and `order` in the same
    approach and have `useFilter` fully test-covered. In this example of `useFilter`,
    we asserted a composable that uses `ref` and `computed` under the hood. We can
    apply the same asserting practice to composables with similar APIs like `watch`,
    `reactive`, `provide`, etc. However, for composables that use `onMounted`, `onUpdated`,
    `onUnmounted`, etc., we use a different approach to test them, discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Composables with Lifecycle Hook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following composable, `useFetch`, uses `onMounted` to fetch data from an
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The function receives a `url` parameter; fetches data from the given `url` before
    mounting the component; updates data, errors, and loading values accordingly;
    and returns them. Since this composable relies on `onBeforeMount` of a component’s
    lifecycle to fetch data, we must create a Vue component and simulate the mounting
    process to test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by using `createApp` from the `vue` package and creating a component/app
    that uses `useFetch` in its `setup` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `withSetup` function takes a `composable` and returns an array of `result`
    of the composable execution and the `app` instance created. We can then use `withSetup`
    in all our test cases to mimic the creation process of a component that uses `useFetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is one issue here. `useFetch` is using `fetch` API to fetch
    data; it is not a good practice to use the actual API in the test for these reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The test will fail if the API is down or the URL is invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test will fail if the API is slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, we need to mock the `fetch` API to simulate the response by using the
    `vi.spyOn` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can place the `fetchSpy` declaration within the `describe` section to ensure
    the isolation of this spy from other test suites. And in the `beforeEach` hook,
    we need to reset every mocked implementation and value before running the test
    case with the `mockClear()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s write our test. We will first mock the `fetch` API to return a successful
    response with the `mockResolvedValueOnce` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can assert the `data` value of the `result` to be equal to the
    mocked data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also expect calling the `fetch` with the given `url` with the `toHaveBeenCalledWith`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we need to unmount the app to clean up the test environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we expect the test to pass successfully. Unfortunately, the test
    will still fail. The reason is that while the `fetch` API is asynchronous, the
    component’s lifecycle hook `beforeMount` isn’t. The hook execution can finish
    before the `fetch` API is resolved, causing the `data` value to stay unchanged
    ([Figure 11-7](#figure_ch10_failing_fetch_test)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the details of the failing test for useFetch](assets/lvue_1107.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-7\. Failing test for `useFetch`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To fix this issue, we need help from another package, Vue Test Utils (`@vue/test-utils`),
    [the official testing utility library for Vue](https://oreil.ly/dZILU). This package
    offers a set of utility methods to help test Vue components. We will import and
    use `flushPromises` from this package to wait for the `fetch` API to resolve before
    asserting the `data` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The test should pass successfully ([Figure 11-8](#figure_ch10_passing_fetch_test)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the tests passed for useFetch in green](assets/lvue_1108.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-8\. Passing the test for `useFetch`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also assert the `loading` value by placing the assertion before the
    `flush` `Promises` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Another benefit of mocking the `fetch` API is that we can simulate the failure
    response by using the `mockRejectedValueOnce` method and test our composable’s
    error-handling logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That’s it. You can apply the same mocking approach to external test APIs in
    your applications or mock any dependent functions that are already tested and
    reduce the complexity of your test suites. We have successfully tested our `useFetch`
    method with Vitest and Vue Test Utils.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how to test a Vue component with Vitest and Vue Test Utils.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Components Using Vue Test Utils
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Vue engine uses the configurations of the Vue components to create and manage
    component instance updates on the browser DOM. Testing components means we will
    test the components’ rendering results to the DOM. We set our `test.environment`
    to `jsdom` in the `vite.config.ts` for simulating the browser environment, which
    doesn’t exist in the Node.js environment where the tests are running. We also
    use the methods like `mount`, `shallowMount`, etc., from the `@vue/test-utils`
    package to help mount the component and assert the rendering results from a virtual
    Vue node to a DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at our `PizzaCard.vue` component, shown in [Example 11-1](#ch10_pizza_card).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-1\. `PizzaCard` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a test file `tests/PizzaCard.test.ts` to test the component.
    We will import the `shallowMount` method from `@vue/test-utils` to mount the element
    within the file. The `shallowMount` function receives two main arguments: the
    Vue component to mount, and an object containing additional data for mounting
    the component, such as props’ values, stubs, etc. The following code demonstrates
    how the test file looks, with the initial value for the `pizza` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Using shallowMount vs mount
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `shallowMount` method is a wrapper around the `mount` method with its `shallow`
    flag active. It is best to use `shallowMount` to render and test the component
    without caring about its children. If you want to try the children components,
    use the `mount` method instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shallowMount` method returns a Vue instance, `wrapper`, with some helper
    methods to allow us to mimic UI interactions with the component. Once we have
    the wrapper instance, we can write our assertions. For example, we can use the
    `find` method to find the DOM element with the class selector `pizza- -details-wrapper`
    and assert its existence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can assert the text content of the `.pizza- -inventory-stock`
    and `.pizza- -inventory-price` elements with the `text()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `shallowMount` method also provides the `html` property to assert the rendered
    HTML of the component. We can then use `toMatchSnapshot` to test the HTML snapshot
    of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Upon running the test, the testing engine will create a snapshot file, `PizzaCard.test.ts.snap`,
    and store the HTML snapshot of the component. On the next test run, Vitest will
    validate the component’s HTML rendering against the existing snapshot, ensuring
    the component’s stability in complex app development.
  prefs: []
  type: TYPE_NORMAL
- en: Using Snapshots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you change the component’s template, the snapshot test will fail. To solve
    this issue, you must update the snapshot by running the test with the `-u` flag
    as `yarn test -u`.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the limitations of snapshot testing, you should use it only for the components
    that are not likely to change. A more recommended approach is to test HTML rendering
    in E2E tests using PlaywrightJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instance received from the `find()` method is a wrapper around the DOM
    element, with various methods to assert the element’s attributes and properties.
    We will add another test case where we will assert the `src` and `alt` attributes
    of the `img` element using the `attributes()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let’s make the test fail by changing the `pizza.title` to a text of `Pineapple
    pizza`. As [Figure 11-9](#ch10_pineapple-pizza-fail) shows, the test will fail
    and show this message.
  prefs: []
  type: TYPE_NORMAL
- en: '![Test failure message when trying to test the image alt text](assets/lvue_1109.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-9\. Assertion of image alt text failed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As this screenshot shows, the received value is `Test Pizza`, highlighted in
    red, and the expected value is green. We also know the reason for the failure:
    “expected `Test Pizza` to deeply equal `Pineapple pizza`,” with a pointer to the
    line where the test fails. This information lets us quickly fix the test or check
    our implementation to ensure the expected behavior is correct.'
  prefs: []
  type: TYPE_NORMAL
- en: Other practical methods for asserting the component’s interaction and data communication
    are the `trigger()` method of the DOM wrapper instance and `emitted()` of the
    wrapper instance. We will modify the implementation of the `PizzaCard` component
    to add an “Add to cart” button and test the button’s behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Interaction and Events of a Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add the following code to the `PizzaCard` component for a new Add to
    cart button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The button accepts a `click` event, which triggers the `addCart` method. The
    `addCart` method will emit a `add-to-cart` event with the `pizza.id` and the new
    quantity as the payload. We can then test the `addCart` method by asserting the
    emitted event and its payload. First, we will look for the button using the `find()`
    method, and then trigger the `click` event using the `trigger()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We will execute the `wrapper.emitted()` function to receive a map of emitted
    events, with the key being the event name, and the value is an array of received
    payloads. Each payload is an array of arguments passed to the `emits()` function
    apart from the event name. For instance, when we emit the `add-to-cart` event
    with the payload `{ id: 1, quantity: 1 }`, the emitted event will be `{ *add-to-cart*:
    [[{ id: 1, quantity: 1 }]] }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now assert the emitted event and its payload with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Testing a Component That Uses a Pinia Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use `createTestingPinia()` from the `@pinia/testing` package to create
    a testing Pinia instance and plug it in the component as a global plugin during
    mounting. This will allow you to test the component without mocking the store
    or using the real store instance.
  prefs: []
  type: TYPE_NORMAL
- en: The test passes successfully, as expected. At this point, we have covered the
    basic testing of components and composables with Vitest and Vue Test Utils. The
    following section will look at using Vitest with a GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vitest with a GUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some scenarios, looking at the terminal (or command line) outputs can be
    complex, and having a Graphic User Interface (GUI) can be beneficial. For such
    cases, Vitest offers `@vitest/ui` as its extra dependency along the command parameter
    `--ui`. To start using the Vitest UI, you need to install `@vitest/ui` with the
    following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: When running the command `yarn test --ui`, Vite will start a local server for
    its UI app and launch it on the browser, as shown in [Figure 11-10](#ch10_vitest-ui).
  prefs: []
  type: TYPE_NORMAL
- en: '![Vitest UI dashboard screenshot](assets/lvue_1110.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-10\. Vitest UI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: On the left-side pane, we can see the list of test files with their status,
    indicated by relevant colors and icons. On the main dashboard is a quick summary
    of the test results, including the number of tests, the number of passed tests,
    and the number of failed tests. We can select a single test using the left-side
    pane and review each test case report, its module graph, and the implementation
    code for the tests. [Figure 11-11](#figure-ch10_vitest-ui) shows the test report
    for the `PizzaCard` component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Vitest UI test report for PizzaCard component](assets/lvue_1111.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-11\. Vitest UI test report for `PizzaCard` component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also run the tests using the GUI by clicking the Run (or Rerun all)
    tests icon, as seen in [Figure 11-12](#figure_ch10_run-tests).
  prefs: []
  type: TYPE_NORMAL
- en: '![Run tests icon](assets/lvue_1112.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-12\. Run tests using the GUI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using the GUI can be beneficial in some cases, but it can also be a distraction
    when you are working on a project and need to watch the tests during development.
    In this case, using the terminal may be a better option, and to review the test
    results, you can choose between the GUI, or the test coverage runner, which we
    will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vitest with a Coverage Runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing tests is straightforward, but knowing if we write enough tests to cover
    all the scenarios of our test target is not. To create a sufficient testing system
    for our application, we use *code coverage* practice, which measures how much
    of our code we cover with our tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various tools for measuring code coverage and generating understandable
    reports. One of the most common tools is Istanbul, a JavaScript testing coverage
    tool. With Vitest, we can integrate Istanbul into our testing system using the
    `@vitest/coverage-istanbul` package. To install the package, run the following
    command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'After installing the package, we can configure the `test.coverage` section
    in the `vite.config.ts` file with the provider as `istanbul`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We also add a new script command in `package.json` to run the tests with coverage
    reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When we run our tests using the command `yarn test:coverage`, we will see the
    coverage reports displayed in the terminal, as shown in [Figure 11-13](#figure_ch10_coverage-report).
  prefs: []
  type: TYPE_NORMAL
- en: '![Coverage report on terminal](assets/lvue_1113.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-13\. Coverage report in terminal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The Istanbul report tool will show you the percentage of your code in each
    file your tests cover during the testing execution process, dividing it into four
    categories: statements, branches, functions, and lines. It will also inform you
    of the line numbers of the uncovered code in the last column. For example, in
    [Figure 11-13](#figure_ch10_coverage-report), for `composables/``useFetch.ts`,
    we saw `13,18` in the *Uncovered Lines* column, indicating that our test for this
    file didn’t cover the code in line 13 and line 18.'
  prefs: []
  type: TYPE_NORMAL
- en: However, the terminal report is not always readable. For such a purpose, Istanbul
    will also generate a `coverage` folder in the `test.root` directory defined in
    `vite.config.ts`, or the root of the project. This folder contains the HTML reports
    for the coverage, denoted by `index.html`. You can open this file in the browser
    to see a prettier and more readable version of the coverage report, as shown in
    [Figure 11-14](#figure_ch10_coverage-report-html).
  prefs: []
  type: TYPE_NORMAL
- en: '![Coverage report in HTML](assets/lvue_1114.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-14\. Coverage report in HTML
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you set the `root` to point to the `src/tests` folder, you should change
    it to `src`. Otherwise, Istanbul can’t locate and analyze the source files’ coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The HTML version displays test coverage by folders and files, with their names
    on the first column, *File*. The second column, with the progress bar, shows the
    coverage percentage for each file in colors (green means fully covered, yellow
    means partly covered, and red means not meeting the acceptance coverage level).
    The other columns show the coverage breakdown in statements, branches, functions,
    and lines.
  prefs: []
  type: TYPE_NORMAL
- en: We can click on each folder name to see the breakdown report per file within
    this folder, such as in */composables* in [Figure 11-15](#figure_ch10_coverage_composables).
  prefs: []
  type: TYPE_NORMAL
- en: '![Coverage report for composables](assets/lvue_1115.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-15\. Coverage report for composables
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can click on each file name to see the highlights of untested code lines
    in red and the number of times a line we covered (like `3x`), as shown in [Figure 11-16](#figure_ch10_coverage_composables-useFetch).
  prefs: []
  type: TYPE_NORMAL
- en: '![Coverage report for useFetch](assets/lvue_1116.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-16\. Coverage report for useFetch
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The HTML report version is also interactive during watch mode, meaning that
    it will update the coverage report automatically when you change the code or the
    tests. This mechanism is handy during development, as you can see the coverage
    report changes in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also set the coverage threshold for each category using the `test.coverage`
    section in `vite.config.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we set the coverage threshold for each category to 80%. If the
    coverage percentage for any type is lower than the threshold, the test will fail
    with an error message, as seen in [Figure 11-17](#figure_ch10_coverage-threshold).
  prefs: []
  type: TYPE_NORMAL
- en: '![Coverage threshold error](assets/lvue_1117.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-17\. Error when a test doesn’t meet the coverage threshold
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Code coverage is essential for testing since it provides the benchmark to help
    you protect your code from bugs and ensure the quality of your application. However,
    it is just a tool to help you manage your tests, and you still need to write good
    tests to ensure your code quality and standards.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the Threshold Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try to keep your coverage threshold number between 80% and 85%. It can be overkill
    if you set it to more than 85%. If less than 80%, it can be too low since you
    may miss some edge cases that cause bugs in your application.
  prefs: []
  type: TYPE_NORMAL
- en: We have explored unit testing using Vitest and other tools like Vue Test Utils
    for Vue-specific testing and Istanbul for code coverage. We will move to the next
    testing level, where we will learn how to write E2E tests for our application
    using PlaywrightJS.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-End Testing with PlaywrightJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PlaywrightJS](https://oreil.ly/sIUKp), or Playwright, is a fast, reliable
    cross-browser end-to-end testing framework. It supports programming languages
    besides JavaScript, such as Python, Java, and C#. It also supports multiple browser
    rendering engines like WebKit, Firefox, and Chromium, allowing us to perform testing
    in cross-browser environments on the same codebase.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using Playwright, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Yarn will run the creation script for Playwright, with the prompts asking for
    the test location (`e2e`), if we want to install GitHub Actions as the pipeline
    tool for CI/CD, and if it should install Playwright browsers. [Figure 11-18](#figure_ch10_playwright-creation)
    shows an example of a configuration for initializing Playwright in our application.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the prompts for initializing Playwright](assets/lvue_1118.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-18\. Initializing Playwright with prompts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After the initialization process, we will see a new `e2e` folder in the root
    of our project, with a single `example.spec.ts` file. Also, Playwright will generate
    a configuration file, `playwright.config.ts`, for our project, modifying the `package.json`
    with the relevant packages and another `test-examples` folder containing a working
    test example for a todo component using Playwright.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add a new script command in our `package.json` to run our E2E tests
    using Playwright:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can add the following command to run the coverage reporter on
    our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: By default, Playwright comes with an HTML coverage reporter, and this reporter
    runs when any test fails during the test run. We can try to run the tests using
    these commands and see the example tests passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the `playwright.config.ts` and see what it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The configuration file exports an instance created by the `defineConfig()`
    method, based on a set of configuration options with the following main properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testDir`'
  prefs: []
  type: TYPE_NORMAL
- en: The directory where we store the tests. We usually define it during the initialization
    process (`e2e` in our case).
  prefs: []
  type: TYPE_NORMAL
- en: '`projects`'
  prefs: []
  type: TYPE_NORMAL
- en: The list of browser projects for running the tests. We can import `devices`
    from the same `@playwright/test` package and select the relevant setup to define
    the browser’s configuration for Playwright to `use`, such as `devices[*Desktop
    Chrome*]` for the Chromium browser.
  prefs: []
  type: TYPE_NORMAL
- en: '`worker`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of parallel workers to run the tests on. This feature is helpful
    when we have many tests and need to run them in parallel to speed up the test
    process.
  prefs: []
  type: TYPE_NORMAL
- en: '`use`'
  prefs: []
  type: TYPE_NORMAL
- en: The configuration object for the test runner, including an optional `baseURL`
    as the base URL and `trace` to enable the trace recording for failed tests on
    retry.
  prefs: []
  type: TYPE_NORMAL
- en: Other properties can customize our Playwright test runner as needed. See the
    complete list of configuration options at the [Playwright documentation](https://oreil.ly/nXapE).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will leave the file as is and write our first E2E test for our application.
    Let’s head to the `vite.config.ts` and make sure we have the following configuration
    for the local server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting the port to 3000, we ensure our local URL will always be *http://localhost:3000*.
    Next, we will create a new E2E test file in the `e2e` folder with the name `PizzasView.spec.ts`,
    dedicated to testing the *“/pizzas”* page. The *“/pizzas”* page uses the `PizzasView`
    view component to display a list of pizzas with the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to write the tests for this page. Like Vitest, we start by wrapping
    the test file with a `test.describe()` block, where we import `test` from `@playwright/test`
    package. We then ensure the test runner will always navigate to our target page
    before testing the page content using the `test.beforeEach()` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We also ensure the page is closed after finishing the tests using the `test.afterEach()`
    hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can start writing our first test for the page, such as checking the page
    title. We can use the `page.locator()` method to locate the page element. In this
    case, it is the `h1` element and asserts its content to be the text `Pizzas`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We can run the test using the `yarn test:e2e` command and see the test passed
    ([Figure 11-19](#figure_ch10_test_passed_pw)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing E2E test with Playwright](assets/lvue_1119.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-19\. Test report showing passing E2E tests with Playwright
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Great! We can add more tests to the file, such as checking the search functionality.
    We can locate the search `input` element using its tag name or the `data-testid`
    attribute as a better approach. To use the `data-testid` attribute, we need to
    add it to the `input` in the `PizzasView` component template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can locate the element using the `data-testid` attribute in our new
    test and `fill` it with the search term `Hawaiian`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To assert the result of the search, we will head to the `PizzaCard` implementation
    and add the `data-testid` attribute to the container element with the value of
    `pizza.title`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Back to our `PizzasView.spec.ts` file, we can assert the visibility of pizza
    card with the `data-testid` attribute containing the search term on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We can rerun the test suite and see the tests passed ([Figure 11-20](#figure_ch10_test_passed_pw_2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Passing E2E test with Playwright](assets/lvue_1120.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-20\. Test report showing the search tests passed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can also click on each test displayed in the report to view the test details,
    including the test steps, their execution time, and any errors that occurred during
    the test execution in a target browser environment ([Figure 11-21](#figure_ch10_test_details_pw)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Test details report with Playwright in Chromium](assets/lvue_1121.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-21\. Details report for a single test run on Chromium
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must use `await` for `page.isVisible()` method, as it returns a `Promise`.
    Otherwise, the test will fail since Playwright will execute the assertion before
    the `isVisible()` process returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s edit our search test to make it fail by changing the search term to `Cheese`
    instead of `Hawaiian`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We can rerun the test suite and see if the test failed ([Figure 11-22](#figure_ch10_test_failed_pw)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Failed E2E test with Playwright for a search term](assets/lvue_1122.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-22\. Test report showing the search test failed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The report shows which step the test failed. Let’s debug it.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging E2E Tests Using Playwright Test Extension for VSCode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can install the [Playwright Test for VSCode extension](https://oreil.ly/9zlFB)
    to debug a failed test. This extension will add another section on the Testing
    tab of VSCode, and auto-detect the relevant Playwright tests within the project,
    as shown in [Figure 11-23](#figure_ch10_test_debug_pw_2).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Playwright tests in the project listed in the Testing
    tab of VSCode](assets/lvue_1123.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-23\. Testing tab displays the Playwright tests in the project
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can run the tests or a single test using the actions available on this view.
    We can also add breakpoints (denoted by the red dot) to debug a target test ([Figure 11-24](#figure_ch10_test_debug_pw_3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding breakpoints to debug a test](assets/lvue_1124.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-24\. Adding breakpoints to debug a test
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To start debugging, navigate to the search test in the Test Explorer pane and
    click on the “Debug” icon ([Figure 11-25](#figure_ch10_test_debug_pw_4)). Hovering
    on the “Debug” icon will display the text “Debug Text.”
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a test button](assets/lvue_1125.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-25\. Run a test in debug mode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Upon running, Playwright will open a browser window (such as Chromium) and execute
    the test steps. Once the test runner reaches the breakpoint, it will stop and
    wait for us to continue the execution manually. Then we can hover over the variables
    to see their values or head to the testing browser to inspect the elements ([Figure 11-26](#figure_ch10_test_debug_pw_5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a test](assets/lvue_1126.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-26\. Debugging the search test
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What’s left is to fix the test and continue the debugging process until the
    test passes.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to create basic E2E tests with Playwright and how to debug
    them with the help of external tools. Playwright provides many other features,
    such as generating the test based on the actual interaction with the application
    or performing accessibility testing with the `@axe-core/playwright` package. Check
    out other features and see how Playwright can help create better E2E tests for
    your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the concept of testing and how to use Vitest as a unit
    testing tool for Vue applications. We learned how to write basic tests for components
    and composables with Vitest and Vue Test Utils and how to use external packages
    such as a coverage runner and Vitest UI for a better UI experience. We also explored
    creating E2E tests with PlaywrightJS, ensuring code confidence throughout our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch11.html#id1547-marker)) If you are new to TDD, start with [*Learning
    Test-Driven Development* by Saleem Siddiqui (O’Reilly)](https://oreil.ly/TqUwM).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch11.html#id1566-marker)) JSDOM is an open source library that acts as
    a headless browser that implements the web standards, providing a simulated environment
    for testing any web-related code.
  prefs: []
  type: TYPE_NORMAL
