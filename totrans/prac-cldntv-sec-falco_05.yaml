- en: Chapter 3\. Understanding Falco’s Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [Part II](part02.xhtml#ii_the_architecture_of_falco) of the book!
    In [Part I](part01.xhtml#i_the_basics), you learned what Falco is and what it
    does. You also took a high-level look at its architecture, installed it on your
    machine, and took it for a spin. Now it’s time to step up your game!
  prefs: []
  type: TYPE_NORMAL
- en: In this part of the book (Chapters [3](#understanding_falcoapostr) through [8](ch08.xhtml#the_output_framework)),
    we’ll get into the inner workings of Falco. You will learn about its architecture
    in more detail, including its main components and how data flows across them.
    We’ll show you how Falco interfaces with the kernel of the operating system and
    with the cloud logs to collect data, and how this data is enriched with context
    and metadata. [Chapter 6](ch06.xhtml#fields_and_filters) will then introduce you
    to the important topic of fields and filters, while [Chapter 7](ch07.xhtml#falco_rules)
    will get you more familiar with Falco rules. We’ll conclude [Part II](part02.xhtml#ii_the_architecture_of_falco)
    by talking about the outputs framework, a key piece of Falco.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you really need to learn about the internals of Falco in order to operate
    it? The answer, as it is so often in life, is “it depends.” If your goal is simply
    to deploy Falco in its default configuration and show your boss that it’s up and
    working, then you’re probably fine skipping this part of the book. However, doing
    so will make some things hard, and others impossible. For example, in Parts [III](part03.xhtml#iii_running_falco_in_production)
    and [IV](part04.xhtml#iv_extending_falco) we’ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Interpreting Falco’s output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining if an alert could be a false positive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-tuning Falco to privilege accuracy over noise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precisely adapting Falco to your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing and extending Falco
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these tasks require you to truly understand the core concepts behind
    Falco and its architecture, and that’s what we’ll help you accomplish here.
  prefs: []
  type: TYPE_NORMAL
- en: True security is never trivial. It requires an investment that goes beyond a
    superficial understanding. But that investment is typically paid back in spades,
    because it can make the difference in whether your software gets compromised and
    your company ends up in the news for all the wrong reasons.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming we’ve convinced you, let’s get started. [Figure 3-1](#the_high_level_architecture_of_a_typica)
    depicts the main components of a typical Falco sensor deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/pcns_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. The high-level architecture of a typical Falco sensor deployment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The architecture depicted in [Figure 3-1](#the_high_level_architecture_of_a_typica)
    reflects the components as they are organized at the code level in the [Falcosecurity
    organization on GitHub](https://oreil.ly/ClRJj). At this level of granularity,
    the main components are:'
  prefs: []
  type: TYPE_NORMAL
- en: Falco libraries
  prefs: []
  type: TYPE_NORMAL
- en: The [Falco libraries](https://oreil.ly/6CbQH), or “libs,” are responsible for
    collecting the data the sensor will process. They also manage state and provide
    multiple layers of enrichment for the collected data.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs: []
  type: TYPE_NORMAL
- en: The [plugins](https://oreil.ly/9Jyi8) extend the sensor with additional data
    sources. For example, plugins make it possible for Falco to use AWS CloudTrail
    and Kubernetes audit logs as data sources.
  prefs: []
  type: TYPE_NORMAL
- en: Falco
  prefs: []
  type: TYPE_NORMAL
- en: This is the [main sensor executable](https://oreil.ly/2IQkj), including the
    rule engine.
  prefs: []
  type: TYPE_NORMAL
- en: Falcosidekick
  prefs: []
  type: TYPE_NORMAL
- en: '[Falcosidekick](https://oreil.ly/lmOie) is responsible for routing the notifications
    and connecting the sensor to the external world.'
  prefs: []
  type: TYPE_NORMAL
- en: Of the components in [Figure 3-1](#the_high_level_architecture_of_a_typica),
    Falco and the Falco libs are required and always installed, while Falcosidekick
    and the plugins are optional; you can install them based on your deployment strategy
    and needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Falco and the Falco Libraries: A Data-Flow View'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take the two most important of the components we just described, the Falco
    libraries and Falco, and explore their data flows and critical modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As [Figure 3-2](#sensor_data_flow_and_main_modules) shows, system calls are
    one of the core sources of data. These are captured in the kernel of the operating
    system by one of Falco’s two drivers: the *kernel module* and the *eBPF (extended
    Berkeley Packet Filter) probe*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/pcns_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Sensor data flow and main modules
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The collected system calls flow into the first of the Falco core libraries,
    *libscap*, which can also receive data from the plugins and exposes a common interface
    to the upper layers. Data is then passed to the other key library, *libsinsp*,
    to be parsed and enriched. Next, the data is fed to the rule engine for evaluation.
    Falco receives the output of the rule engine and emits the resulting notifications,
    which can optionally go to Falcosidekick.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty straightforward, right? [Figure 3-3](#key_roles_of_the_sensorapostrophes_main)
    gives further details about what each of these modules does, and in the following
    sections we’ll explore them in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/pcns_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Key roles of the sensor’s main modules
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Drivers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'System calls are Falco’s original data source, and to this day they remain
    the most important. Collecting system calls is at the core of Falco’s ability
    to trace the behavior of processes, containers, and users in a very granular way
    and with high efficiency. Reliable and efficient system call collection needs
    to be performed from inside the kernel of the operating system, so it requires
    a driver that runs inside the OS itself. As mentioned in the previous section,
    Falco offers two such drivers: the kernel module and the eBPF probe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These two components offer identical functionality and are deployed in a mutually
    exclusive way: if you deploy the kernel module, you can’t run the eBPF probe,
    and vice versa. So what distinguishes them?'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel module works with any version of the Linux kernel, including older
    ones. Also, it requires somewhat fewer resources to run, so you should use it
    when you care about Falco having the smallest possible overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The eBPF probe, on the other hand, runs only on more recent versions of Linux,
    starting at kernel 4.11\. Its advantage is that it’s safer, because its code is
    strictly validated by the operating system before it is executed. This means that
    even if it contains a bug, it is (in theory) guaranteed not to crash your machine.
    Compared to the kernel module, it is also much better protected from security
    flaws that could compromise the machine where you run it. Therefore, in most cases,
    the eBPF probe is the option you should go with. Note also that some environments—in
    particular, cloud-based managed containerized environments—prevent kernel modules
    from being loaded in the operating system kernel. In such environments, the eBPF
    probe is your only option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the kernel module and the eBPF probe are entrusted with a set of very
    important tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Capturing system calls
  prefs: []
  type: TYPE_NORMAL
- en: The driver’s first responsibility is capturing system calls. This happens through
    a kernel facility called [tracepoints](https://oreil.ly/tEYsq) and is heavily
    optimized to minimize the performance impact on the monitored applications.
  prefs: []
  type: TYPE_NORMAL
- en: System call packing
  prefs: []
  type: TYPE_NORMAL
- en: The driver then encodes the system call information into a transfer buffer,
    using a format that the rest of the Falco stack can parse easily and efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-copy data transfer
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the driver is responsible for efficiently transferring this data from
    the kernel to the user level, where *libscap* will receive it. We should really
    call this efficiently *not* transferring the data, since both the kernel module
    and the eBPF probe are designed around a zero-copy architecture that maps the
    data buffers into user-level memory so that *libscap* can access the original
    data without needing to copy or transfer it.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.xhtml#data_source) you will learn all you need to know about
    drivers, including their architecture, functionality, and usage scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Plugins are a way to add additional data sources to Falco simply and without
    the need to rebuild it. Plugins implement an interface that feeds events into
    Falco, similar to what the kernel module and eBPF probe do. However, plugins are
    not limited to capturing system calls: they can feed Falco any kind of data, including
    logs and API events.'
  prefs: []
  type: TYPE_NORMAL
- en: Falco has several powerful plugins that extend its scope. For example, the CloudTrail
    plugin ingests JSON logs from AWS CloudTrail and allows Falco to alert you when
    something dangerous happens in your cloud infrastructure. Plugins can be written
    in any language, but there are Go and C++ software development kits (SDKs) available
    that make it easier to write them in those languages. We will talk more about
    plugins in Chapters [4](ch04.xhtml#data_source) and [11](ch11.xhtml#using_falco_for_cloud_se).
  prefs: []
  type: TYPE_NORMAL
- en: libscap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name *libscap* stands for “library for system capture,” a clear hint about
    its purpose. *libscap* is the gateway through which the input data passes before
    getting into the Falco processing pipeline. Let’s take a look at the main things
    *libscap* does for us.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Data Sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *libscap* library contains the logic to control both the kernel module and
    the eBPF probe, including loading them, starting and stopping captures, and reading
    the data they produce. It also includes the logic to load, manage, and run plugins.
  prefs: []
  type: TYPE_NORMAL
- en: '*libscap* is designed to export a generic capture source abstraction to the
    upper layers of the stack. This means that no matter how you collect data (kernel
    module, eBPF probe, a plugin), programs that use *libscap* will have a consistent
    way to enumerate and control data sources, start and stop captures, and receive
    captured events, and you won’t have to worry about the nuances of interfacing
    with these disparate input sources.'
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Trace Files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another extremely important piece of functionality in *libscap* is support for
    trace files. If you’ve ever created or opened a PCAP file with Wireshark or tcpdump,
    we’re sure you understand how useful (and powerful!) the concept of trace files
    is. If not, allow us to explain.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to capturing and decoding network traffic, protocol analyzers (like
    Wireshark and tcpdump) let you “dump” the captured network packets into a *trace
    file*. The trace file contains a copy of each packet so that later you can open
    it to analyze the activity of that network segment. You can also share it with
    other people or filter its contents to isolate relevant information.
  prefs: []
  type: TYPE_NORMAL
- en: Trace files are often referred to as PCAP *files*, a name that originates from
    the *.pcap* file format used to encode the data inside them (an open, standardized
    format understood by every networking tool in the universe). This enables an endless
    list of the capture now, analyze later workflows that are critical in computer
    networks.
  prefs: []
  type: TYPE_NORMAL
- en: Many Falco users don’t realize that Falco supports trace files using the *.pcap*
    format. This feature is extremely powerful and should definitely be part of your
    arsenal as you gain more experience. For example, trace files are invaluable when
    it comes to writing new rules.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll talk extensively about how to leverage trace files, for example in Chapters
    [4](ch04.xhtml#data_source) and [13](ch13.xhtml#writing_falco_rules), but for
    now let’s whet your appetite by teaching you how to create a trace file and have
    Falco read it, in two simple steps. To do that, we need to introduce a command-line
    tool called sysdig. You’ll learn more about sysdig in [Chapter 4](ch04.xhtml#data_source),
    but for the moment we’ll just use it as a simple trace file generator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Create the trace file'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Install sysdig on your Linux host by following the [installation instructions](https://oreil.ly/Rmkxr).
    After finishing the installation, run the following on your command line, which
    instructs sysdig to capture all of the system calls generated by the host and
    write them to a file called *testfile.scap*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Wait a few seconds to make sure your machine is working on it, then press Ctrl-C
    to stop sysdig.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have a snapshot of a few seconds’ worth of your host’s activity. Let’s
    take a look at what it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ll go through the format of this output in detail later, but you can probably
    tell that this is a bunch of background input/output (I/O) activity performed
    by system tools like Xorg, gmain, and prlcp, which are running on this machine
    while it’s idle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Process the trace file with Falco'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Think of the trace file as taking us back in time: you took a snapshot of your
    host at a specific point in time, and now you can trace the system calls generated
    on the host around that time, observing every process in detail. Processing the
    trace file with Falco is easy and lets you see quickly if any security violations
    happened during that time. Here’s a sample of its output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, it looks like we’re safe. This consistent, back-in-time way of
    running Falco is useful when writing or unit-testing rules. We’ll talk more about
    it when we deep dive into rules in [Chapter 13](ch13.xhtml#writing_falco_rules).
  prefs: []
  type: TYPE_NORMAL
- en: Collecting System State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: System state collection is an important task that’s specifically related to
    capturing system calls. The kernel module and the eBPF probe produce raw system
    calls, which lack some important context Falco needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example. A very common system call is `read`, which,
    as the name implies, reads a buffer of data from a file descriptor. Here is the
    prototype of `read`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It has three inputs: the numeric file descriptor identifier, a buffer to fill,
    and the buffer size. It returns the amount of data that was written in the buffer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *file descriptor* is like the ID of an object inside the operating system
    kernel: it can indicate a file, a network connection (specifically, a socket),
    the endpoint of a pipe, a mutex (used for process synchronization), a timer, or
    several other types of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the file descriptor number is not very useful when crafting a Falco
    rule. As users, we prefer to think about a file or directory name, or maybe a
    connection’s IP addresses and ports, than a file descriptor number. *libscap*
    helps us do that. When Falco starts, *libscap* fetches a bunch of data from a
    diverse set of sources within the operating system (for example, the */proc* Linux
    filesystem). It uses this data to construct a set of tables that can be used to
    resolve cryptic numbers—file descriptors, process IDs, and so forth—into logical
    entities and their details, which are much easier for humans to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'This functionality is part of why Falco’s syntax is so much more expressive
    and usable than that of most comparable tools. One theme that you will be hearing
    often in this book is that *granular data is useless without context*. This gives
    you a hint of what that means. Next we’ll dive into the other important Falco
    library: *libsinsp*.'
  prefs: []
  type: TYPE_NORMAL
- en: libsinsp
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*libsinsp* stands for “library for system inspection.” This library taps into
    the stream of data *libscap* produces, enriches it, and provides a number of higher-level
    primitives to work with it. Let’s start by exploring its most important functionality,
    the state engine.'
  prefs: []
  type: TYPE_NORMAL
- en: State Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we noted in the previous section, when Falco starts, *libscap* constructs
    a set of tables to convert low-level identifiers, like file descriptor numbers,
    into high-level, actionable information, like IP addresses and filenames. This
    is great, but what if a program opens a file *after* Falco starts? For example,
    a very common system call in Unix is `open`, which takes two input arguments,
    the filename and some flags, and returns a file descriptor identifying the newly
    opened file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, `open`, like many other system calls, creates a new file descriptor,
    effectively changing the state of the process that called it. If a process invokes
    `open` after Falco has been launched, its new file descriptor will not be part
    of the state table, and Falco won’t know what to do with that descriptor. However,
    consider this: `open` is a system call. More generally, system calls are always
    used to create, destroy, or modify file descriptors. Recall, too, that the Falco
    libs capture *all* system calls from *every* process.'
  prefs: []
  type: TYPE_NORMAL
- en: '*libsinsp*, in particular, has logic to inspect every state-changing system
    call and, based on the system call arguments, update the state tables. In other
    words, it tracks the activity of the whole machine to keep the state in sync with
    the underlying operating system. Further, it does so in a way that accurately
    supports containers. *libsinsp* keeps this constantly updated information in a
    hierarchical structure. This structure ([Figure 3-4](#the_libsinsp_state_hierarchy))
    starts with a process table, each entry of which contains a file descriptor table,
    among other information.'
  prefs: []
  type: TYPE_NORMAL
- en: These accurate, constantly updated state tables are at the core of Falco’s data
    enrichment, which in turn is a key building block of the rule engine.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/pcns_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. The libsinsp state hierarchy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Event Parsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The state engine requires a substantial amount of logic to understand system
    calls and parse their arguments. This is what *libsinsp*’s *event parser* does.
    State tracking leverages event parsing, but it’s used for other purposes as well.
    For example, it extracts useful arguments from system calls or other data sources,
    making them available to the rule engine. It also collates and reconstructs buffers
    that can be spread across multiple collected messages, making it easier to decode
    their content from Falco rules.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filtering is one of the most important concepts in Falco, and it’s fully implemented
    in *libsinsp*. A *filter* is a Boolean expression that ties together multiple
    *checks*, each of which compares a filter field with a constant value. The importance
    of filters is obvious when we look at rules. (Indeed, it’s so important that we
    dedicate all of [Chapter 6](ch06.xhtml#fields_and_filters) to it.) Let’s take
    the simple rule shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `condition` section of the rule is a *libsinsp* filter. The condition in
    our example checks that the container ID is not `host` and that the name of the
    process is `bash`. Every captured system call that meets both criteria will trigger
    the rule.
  prefs: []
  type: TYPE_NORMAL
- en: '*libsinsp* is responsible for defining and implementing system call–related
    filter fields. It also contains the engine that evaluates filters and tells us
    if the rule should trigger, so it’s not an exaggeration to say that *libsinsp*
    is the heart of Falco.'
  prefs: []
  type: TYPE_NORMAL
- en: Output Formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we take another look at the example rule, we can see that the `output` section
    makes use of a syntax similar to that of the `condition` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Output is what Falco prints when the rule triggers—and yes, you can use filter
    fields in this section (the same fields that you can use in the `condition` section)
    by prepending the `%` character to the field names. *libsinsp* has logic to resolve
    these fields and create the final output string. What’s nice is that if you become
    an expert at writing condition filters, you will also have mastered output strings!
  prefs: []
  type: TYPE_NORMAL
- en: One More Thing About libsinsp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now you can probably see that a lot of Falco’s logic is in *libsinsp*. That’s
    deliberate. Falco’s developers recognized the value (and elegance) of its data
    collection stack and realized it could be the base for many other tools. That’s
    precisely why *libsinsp* exists. It sits on top of the powerful Falco collection
    stack (which includes the drivers, plugins, and *libscap*) and adds the most important
    pieces of the Falco logic in a way that makes them reusable. What’s more, *libsinsp*
    includes all you need to collect security and forensics data from containers,
    virtual machines, Linux hosts, and cloud infrastructure. It’s stable, efficient,
    and well documented.
  prefs: []
  type: TYPE_NORMAL
- en: Several other open source and commercial tools have been built on top of *libsinsp*.
    If you would like to write one, or if you are just curious and want to learn more,
    we recommend you start at the [*falcosecurity/libs* repository](https://oreil.ly/Cp2Nt).
  prefs: []
  type: TYPE_NORMAL
- en: Rule Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Falco rule engine is the component you interact with when you run Falco.
    Here are some of the things that the rule engine is responsible for:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading Falco rules files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing the rules in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying local customizations (such as appends and overrides) to rules based
    on local rules files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using *libsinsp* to compile the condition and output of each rule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing the appropriate action, including emitting the output, when a rule
    triggers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to the power of *libscap* and *libsinsp*, the rule engine is simple and
    relatively independent from the rest of the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know what’s inside Falco and how its components relate to each other—you’re
    well on your way to mastering it! In the next chapters we’ll dive deeper into
    some of the components and concepts that this chapter introduced.
  prefs: []
  type: TYPE_NORMAL
