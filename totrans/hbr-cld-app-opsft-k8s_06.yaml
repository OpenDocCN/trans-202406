- en: Chapter 5\. Continuous Delivery Across Clusters
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。跨集群的持续交付
- en: 'Cloud native applications have the potential to disrupt entire industries.
    A key reason for this is their ability to support continuous delivery. When the
    market environment changes and applications need to be updated to address real-world
    constraints that pop up quickly, continuous delivery enables applications to quickly
    adapt to meet these newly encountered issues. Here is a brief overview of how
    container images, Kubernetes, and OpenShift support DevOps principles to facilitate
    continuous delivery:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用有可能颠覆整个行业。其中一个关键原因是它们支持持续交付。当市场环境发生变化，应用程序需要更新以应对迅速出现的现实约束时，持续交付使应用程序能够快速适应以解决这些新出现的问题。以下是容器镜像、Kubernetes和OpenShift如何支持DevOps原则以促进持续交付的简要概述：
- en: Small batch changes
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 小批量更改
- en: All changes should be incremental and finite. When failures occur, small batch
    changes are typically easier to recover than large, disruptive changes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有更改都应该是增量和有限的。当发生故障时，小批量更改通常比大规模、破坏性的更改更容易恢复。
- en: Source control all the things
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有事物进行源代码控制
- en: A history of all changes is helpful to understand the changes that have been
    made and to identify the causes of regressions in the code base or configuration.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 了解已经进行的所有更改对于理解已经进行的更改以及识别代码库或配置中回归原因非常有帮助。
- en: Production-like environments
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 类似生产的环境
- en: Developers should have access to environments and tools that are representative
    of production. Production environments typically operate at larger scales than
    development or quality assurance (QA) and with more complex configuration. The
    variance can mean that features that work fine in the early stages do not work
    correctly in production, which is the only place they matter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应该能够访问与生产环境相对应的环境和工具。生产环境通常比开发或质量保证（QA）环境规模更大，配置更复杂。这种差异可能意味着在早期阶段正常工作的功能在生产环境中无法正确运行，而这是它们真正重要的地方。
- en: Shift-left of operational practices
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 运维实践的左移
- en: We should expose behaviors for health management, log collection, change management,
    and so on earlier in the development process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在开发过程的早期阶段就暴露出健康管理、日志收集、变更管理等行为。
- en: Continuous integration of changes
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 更改的持续集成
- en: All changes should be built and deployed together on an ongoing basis to identify
    when the intermingling of various changes lead to an unforeseen issue or API incompatibility.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有更改都应该持续构建和部署在一起，以便识别各种更改相互交织导致意外问题或API不兼容性的情况。
- en: Highly automated testing with continuous feedback
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 高度自动化的测试与持续反馈
- en: To manage velocity, we have to automate our testing and validation work so that
    we can always be testing (ABT).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了管理速度，我们必须自动化我们的测试和验证工作，以便我们始终可以进行测试（ABT）。
- en: In this chapter, we provide an overview of a variety of tools and methodologies
    for supporting continuous delivery in production across clusters. We begin with
    a discussion of Helm, which is a popular packaging tool for Kubernetes applications.
    Next we introduce Kustomize, which provides the ability to repurpose your existing
    Kubernetes YAML files for multiple purposes and configurations while avoiding
    the use of templates. We then describe several popular approaches for supporting
    continuous delivery pipelines, including GitOps, Razee, and Tekton. Finally, we
    conclude this chapter with an extensive discussion of OpenShift pipelines and
    the Open Cluster Management project for deploying applications across multiple
    clusters.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了支持跨集群生产环境中持续交付的各种工具和方法。我们首先讨论了Helm，这是一个用于Kubernetes应用程序的流行打包工具。接下来我们介绍了Kustomize，它提供了重新利用现有Kubernetes
    YAML文件以实现多种目的和配置的能力，同时避免使用模板。然后，我们描述了几种支持持续交付流水线的流行方法，包括GitOps、Razee和Tekton。最后，我们通过对OpenShift流水线和Open
    Cluster Management项目进行广泛讨论来结束本章，这些项目用于在多个集群中部署应用程序。
- en: Helm
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm
- en: Helm is the Kubernetes package manager. It enables you to create a package containing
    multiple templates for all of the resources that make up your application. Common
    Kubernetes resources you would expect to find included in a Helm package are `ConfigMaps`,
    deployments, `PersistentVolumeClaims`, services, and many others.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes的包管理器。它使您能够创建一个包含构成应用程序的所有资源的多个模板的软件包。您可以期望在Helm软件包中找到的常见Kubernetes资源包括`ConfigMaps`、部署、`PersistentVolumeClaims`、服务等等。
- en: Helm provides its own [CLI](https://oreil.ly/9S6Ne) that will generate a collection
    of template files, and it also supports passing variable values into these template
    files. The collection of template files that Helm generates is called a *Helm
    chart*. The CLI will then create complete YAML files from the template files,
    package up all the related files, and deploy the chart.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供其自己的[CLI](https://oreil.ly/9S6Ne)，该 CLI 将生成一组模板文件集合，并支持将变量值传递到这些模板文件中。Helm
    生成的模板文件集称为 *Helm 图表*。然后，CLI 将从模板文件生成完整的 YAML 文件，打包所有相关文件，并部署该图表。
- en: 'The `helm create` command is used to create a new package by passing in the
    name of the chart. So to create a new chart called `firstchart` we do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`helm create`命令通过传递图表名称来创建新包。因此，要创建名为`firstchart`的新图表，我们执行以下操作：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This command creates the following files and subfolders:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将创建以下文件和子文件夹：
- en: '*Chart.yaml*'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Chart.yaml*'
- en: '*charts/*'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*charts/*'
- en: '*templates/*'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*templates/*'
- en: '*values.yaml*'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*values.yaml*'
- en: 'The *templates* folder contains some generated templates for representing key
    Kubernetes abstractions like deployments and service accounts. These template
    files are:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*templates* 文件夹包含一些生成的模板，用于表示关键的 Kubernetes 抽象，如部署和服务账户。'
- en: '*NOTES.txt*'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NOTES.txt*'
- en: '*_helpers.tpl*'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*_helpers.tpl*'
- en: '*deployment.yaml*'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*deployment.yaml*'
- en: '*hpa.yaml*'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*hpa.yaml*'
- en: '*ingress.yaml*'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ingress.yaml*'
- en: '*Service.yaml*'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Service.yaml*'
- en: '*serviceaccount.yaml*'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*serviceaccount.yaml*'
- en: '*tests/*'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*tests/*'
- en: The *_helpers.tpl* file contains partial templates that are used to generate
    values such as Kubernetes selector labels and the name to use for the service
    account. Template files such as *deployment.yaml* and *serviceaccount.yaml* then
    use the partial templates to obtain these values. The template files also pull
    values from the *values.yaml* file. This file contains values such as `replicaCount`
    that are variables the user can change. These variables are also passed into template
    files such as *deployment.yaml* and *serviceaccount.yaml* and used to set desired
    values.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*_helpers.tpl* 文件包含部分模板，用于生成诸如 Kubernetes 选择器标签和用于服务账户的名称等值。然后，诸如 *deployment.yaml*
    和 *serviceaccount.yaml* 的模板文件使用这些部分模板获取这些值。模板文件还从 *values.yaml* 文件中提取值。该文件包含用户可以更改的变量，例如
    `replicaCount`。这些变量也传递到诸如 *deployment.yaml* 和 *serviceaccount.yaml* 的模板文件中，并用于设置所需值。'
- en: 'Once you have the proper set of template files and proper variables set for
    your application, it’s time to package up all the contents associated with this
    Helm chart. This is accomplished by using the `helm package` command. In our example,
    we would call the `helm package` as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有适当的模板文件集和为应用程序设置适当的变量，就可以打包与此 Helm 图表相关的所有内容了。使用`helm package`命令即可完成此操作。在我们的示例中，我们将如下调用`helm
    package`：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As shown in the example, running the `helm package` command generates an archive
    file containing all the content associated with the Helm chart. Now, if we want
    to install the Helm chart, we just need to run the `helm install` command as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，运行`helm package`命令会生成一个包含与 Helm 图表相关所有内容的归档文件。现在，如果我们想要安装 Helm 图表，只需运行以下`helm
    install`命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `helm install` command in its most basic form takes two arguments, the name
    of the release and the archive file. The `helm install` command is quite flexible
    and can install a Helm chart and its content in a variety of different ways. In
    addition, the Helm release that has been installed can be easily updated using
    the `helm update` command. For more information on the use of Helm and its capabilities,
    please see the [Helm documentation](https://helm.sh/docs).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm install`命令在其最基本的形式中需要两个参数，即发布名称和归档文件。`helm install`命令非常灵活，可以以多种不同的方式安装
    Helm 图表及其内容。此外，已安装的 Helm 发布可以轻松使用`helm update`命令进行更新。有关 Helm 及其功能的更多信息，请参阅[Helm
    文档](https://helm.sh/docs)。'
- en: Kustomize
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kustomize
- en: When running Kubernetes in production, you will invariably have lots of YAML
    files used for deploying and configuring applications. Moreover, you would typically
    store these configuration files in some form of source control to enable continuous
    delivery. Experience with running in production has shown that in many cases the
    configuration YAML files will need customizations for a variety of reasons. For
    example, there may be configuration changes for differences between development
    and production environments. Or custom prefix names may be needed to distinguish
    similar applications. To address these needs, the Kubernetes `kubectl` CLI has
    incorporated a recently developed tool called [Kustomize](https://kustomize.io).
    The Kustomize tool provides a template-free approach to customizing Kubernetes
    configurations.^([1](ch05.html#ch01fn33)) The Kustomize tool has several key features
    that both reduce the complexity of managing a large number of Kubernetes configurations
    for production deployments and facilitate the use of continuous deployment methodologies.
    The primary capabilities provided by Kustomize include generators, composition,
    patches, and overlays.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行 Kubernetes 时，通常会有大量用于部署和配置应用程序的 YAML 文件。此外，通常会将这些配置文件存储在某种形式的源代码控制中，以实现持续交付。生产环境的运行经验表明，出于各种原因，配置
    YAML 文件通常需要定制。例如，可能需要根据开发和生产环境之间的差异进行配置更改。或者可能需要自定义前缀名称以区分类似的应用程序。为了解决这些需求，Kubernetes
    的 `kubectl` CLI 已经整合了一个名为 [Kustomize](https://kustomize.io) 的最新开发工具。Kustomize
    工具提供了一种无模板的方法来定制 Kubernetes 配置。^([1](ch05.html#ch01fn33)) Kustomize 工具具有几个关键特性，既减少了管理生产部署的大量
    Kubernetes 配置的复杂性，又促进了持续部署方法的使用。Kustomize 提供的主要功能包括 generators、composition、patches
    和 overlays。
- en: Generators
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成器
- en: 'Best practices for Kubernetes deployment recommend that configuration and secret
    data should not be hardcoded into an application. Instead, this information should
    be stored in Kubernetes resources like `ConfigMaps` and secrets. Kustomize provides
    the notion of *generators* that can create `ConfigMaps` and secrets to simplify
    this aspect of deployment. Kustomize uses YAML files to describe what should be
    generated. The following Kustomize YAML is used to generate a Kubernetes secret:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 部署的最佳实践建议，配置和秘密数据不应硬编码到应用程序中。相反，这些信息应存储在像 `ConfigMaps` 和 secrets
    这样的 Kubernetes 资源中。Kustomize 提供了 *generators* 的概念，可以创建 `ConfigMaps` 和 secrets
    来简化部署的这一方面。Kustomize 使用 YAML 文件描述应生成的内容。以下 Kustomize YAML 用于生成一个 Kubernetes secret：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To run the previous example, save the file as *kustomization.yaml* in a new
    folder called *generateSecret*. You can now run it by doing the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行上述示例，将文件保存为 *kustomization.yaml*，并放入一个名为 *generateSecret* 的新文件夹中。现在可以通过以下步骤运行它：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After you run the above command, Kustomize will generate a Kubernetes secret
    resource as shown:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行以上命令后，Kustomize 将生成一个如下所示的 Kubernetes secret 资源：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As an alternative, Kustomize can generate a secret where the username and password
    are stored in a separate file. For example, create a file called *password.txt*
    and store the following key value pairs in the file:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代方案，Kustomize 可以生成一个 secret，其中用户名和密码存储在一个单独的文件中。例如，创建一个名为 *password.txt*
    的文件，并将以下键值对存储在文件中：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With these values now in *password.txt*, you can create a Kustomization file
    that generates a secret and pulls the username and password from *password.txt*
    as shown:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 *password.txt* 中有了这些值，您可以创建一个 Kustomization 文件来生成一个 secret，并从 *password.txt*
    中提取用户名和密码，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To run the previous example, save the file as *kustomization.yaml* in a new
    folder called *generateSecret2*. You can now run Kustomize using this file by
    doing the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行上述示例，将文件保存为 *kustomization.yaml*，并放入一个名为 *generateSecret2* 的新文件夹中。现在可以通过以下步骤使用此文件运行
    Kustomize：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After you run this command, Kustomize will generate a Kubernetes secret resource
    similar to the one shown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Kustomize 将生成一个类似于以下显示的 Kubernetes secret 资源：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the next section, we discuss another key feature of Kustomize: the ability
    to aggregate individual Kubernetes resource files into a single deployment YAML
    file.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们讨论 Kustomize 的另一个关键功能：将单个 Kubernetes 资源文件聚合到单个部署 YAML 文件中。
- en: Composition
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合成
- en: Kubernetes deployments are typically created from a large set of YAML files.
    The YAML files themselves may be shared for multiple purposes. Kustomize supports
    the notion of *composition*, which enables individual YAML files to be selected
    and aggregated into a single deployment YAML file. The composition functionality
    also reduces the need to copy YAML files and then make slight modifications to
    those duplicate files for different purposes.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 部署通常是从大量的 YAML 文件创建的。这些 YAML 文件本身可能被用于多种目的。Kustomize 支持*组合*的概念，这使得可以选择并将单个
    YAML 文件聚合到一个部署 YAML 文件中。组合功能还减少了复制 YAML 文件然后对这些重复文件进行轻微修改以用于不同目的的需求。
- en: 'To demonstrate the capabilities of Kustomize composition, let’s create some
    Kubernetes YAML resource files that we want to aggregate. First, create a new
    folder called *composition* and store the following content in a file called *deploymentset.yaml*
    in the *composition* folder:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示 Kustomize 组合的功能，让我们创建一些我们想要聚合的 Kubernetes YAML 资源文件。首先，在一个名为*composition*的新文件夹中创建一个名为*deploymentset.yaml*的文件，并将以下内容存储在其中：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, store the following service resource YAML in a file called *service.yaml*
    in the *composition* folder:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在*composition*文件夹中的一个名为*service.yaml*的文件中存储以下服务资源 YAML：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can now create a customization file that is capable of composing *deploymentset.yaml*
    and *service.yaml* by doing the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以创建一个自定义文件，通过以下方式能够组合*deploymentset.yaml*和*service.yaml*：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run this example, save the file as *kustomization.yaml* in the *composition*
    folder you previously created. You can now run Kustomize using this file by doing
    the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，在之前创建的*composition*文件夹中将文件保存为*kustomization.yaml*。现在，您可以通过以下方式使用此文件运行
    Kustomize：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After you run this command, Kustomize will generate the aggregated deployment
    YAML as shown:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Kustomize 将生成如下所示的聚合部署 YAML：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next section, we cover Kustomize’s patch capability, which enables us
    to avoid duplicating a full Kubernetes YAML file when all we need is a small change
    to an existing YAML file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将介绍 Kustomize 的补丁功能，这使我们能够避免在需要对现有 YAML 文件进行小改动时复制整个 Kubernetes YAML
    文件。
- en: Patches
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补丁
- en: In many cases, the YAML file needed for a deployment may be very similar to
    an existing YAML file and only needs a small change to one of the resources. As
    an example, perhaps the only thing in a YAML file that needs to be changed is
    the number of replicas to create. For this type of situation, Kustomize provides
    the notion of *patches*, which are capable of making small modifications to resources
    described in YAML files. This is a much better approach than having to make a
    copy of the complete YAML file and then making the small modification to the duplicate
    file.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，用于部署的 YAML 文件可能与现有的 YAML 文件非常相似，只需要对其中一个资源进行小改动。例如，也许一个 YAML 文件中唯一需要更改的是要创建的副本数量。对于这种情况，Kustomize
    提供了*补丁*的概念，能够对描述在 YAML 文件中的资源进行小修改。这比不得不复制完整的 YAML 文件然后对副本文件进行小修改的方法要好得多。
- en: 'To demonstrate the capabilities of patches, let’s create a Kubernetes YAML
    resource file that is close to what we want but needs small changes. First, create
    a new folder called *patch* and store the following content in a file called *deploymentset.yaml*
    in the *patch* folder:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示补丁的功能，让我们创建一个接近我们想要的但需要进行小改动的 Kubernetes YAML 资源文件。首先，在一个名为*patch*的新文件夹中创建一个名为*deploymentset.yaml*的文件，并将以下内容存储在其中：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The deployment YAML file shown above is close to what we desire, but we now
    need a new version of this file that needs to provide six replicas instead of
    three. Rather than duplicating the whole *deploymentset.yaml* resource file and
    then changing the value of the `replicas` field, we can create a patch file that
    is much smaller and easier to maintain.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上面显示的部署 YAML 文件接近我们想要的，但现在我们需要一个新版本的此文件，需要提供六个副本而不是三个。与复制整个*deploymentset.yaml*资源文件然后更改`replicas`字段值不同，我们可以创建一个更小且更易于维护的补丁文件。
- en: 'Here is a simple patch file that can be used to create a duplicate *deploymentset.yaml*
    with a modified `replicas` field value:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的补丁文件，可用于创建一个带有修改后`replicas`字段值的重复*deploymentset.yaml*：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that this small file identifies the kind of resource, the name of the resource,
    and the attribute field we wish to modify. This small file gives Kustomize enough
    information to identify the field that needs to be patched. To use this patch
    file, save it in a new file called *update_replicas.yaml* in the *patch* folder
    you just created.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此小文件标识资源类型、资源名称和我们希望修改的属性字段。此小文件为 Kustomize 提供了足够的信息来识别需要打补丁的字段。要使用此补丁文件，请将其保存在您刚刚创建的*patch*文件夹中的新文件*update_replicas.yaml*中。
- en: 'With the patch file created, we can now create a *kustomization.yaml* file
    that identifies the *deploymentset.yaml* file we wish to modify and also identifies
    the *update_replicas.yaml* file as the file that contains information on which
    fields to modify:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了补丁文件后，现在我们可以创建一个*kustomization.yaml*文件，标识我们希望修改的*deploymentset.yaml*文件，并将*update_replicas.yaml*文件标识为包含要修改的字段信息的文件：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To run the previous example, save the file as *kustomization.yaml* in the *patch*
    folder you previously created. You can now run Kustomize using this file by doing
    the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行前面的例子，请将文件保存为*kustomization.yaml*，保存在先前创建的*patch*文件夹中。现在可以通过以下方式使用此文件运行 Kustomize：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After you run this command, Kustomize will generate the patched deployment
    YAML as shown:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Kustomize 将生成如下所示的修补部署 YAML 文件：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the next section, we describe the overlays capability, which is one of the
    most powerful features available in Kustomize.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述叠加能力，这是 Kustomize 提供的最强大的功能之一。
- en: Overlays
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 叠加
- en: Building on the features described in the previous sections, the *overlays*
    functionality is where users see the most significant capabilities available from
    Kustomize. Overlays provide an approach where the user starts with a base folder
    that contains a set of Kubernetes deployment YAML files and builds on the base
    folder using overlay folders that enhance and customize the deployment YAML files
    contained in the base folder. In this section, we demonstrate how Kustomize overlays
    can be used to manage the differences that occur in deployment YAML files that
    exist when using the deployment YAML files across development, staging, and production
    Kubernetes environments.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几节描述的功能基础上，*overlays*功能是用户从 Kustomize 中看到的最重要的功能之一。Overlays 提供了一种方法，用户从一个包含一组
    Kubernetes 部署 YAML 文件的基础文件夹开始，并使用增强和定制部署 YAML 文件的叠加文件夹来构建基础文件夹。在本节中，我们演示了如何使用
    Kustomize 叠加来管理在开发、暂存和生产 Kubernetes 环境中使用部署 YAML 文件时发生的差异。
- en: 'To demonstrate how Kustomize can be used in this fashion, let’s first create
    a new folder called *base* and copy into this folder the *deploymentset.yaml*
    and *service.yaml* files that we created in [“Composition”](#composition). With
    these files in the *base* folder, we can now create a *kustomization.yaml* in
    the *base* folder that references the deployment YAML files as shown:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 Kustomize 如何以这种方式使用，让我们首先创建一个名为*base*的新文件夹，并将我们在[“组合”](#composition)中创建的*deploymentset.yaml*和*service.yaml*文件复制到该文件夹中。有了这些文件在*base*文件夹中，我们现在可以在*base*文件夹中创建一个*kustomization.yaml*，引用部署
    YAML 文件，如下所示：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we are going to create an overlay folder that tailors the base deployment
    files for a development environment. We begin by creating a new folder called
    *development*. Inside this folder, we create a new *kustomization.yaml* as shown:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个叠加文件夹，为开发环境定制基础部署文件。我们首先创建一个名为*development*的新文件夹。在此文件夹内，如下所示创建一个新的*kustomization.yaml*：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As shown in *kustomization.yaml*, the Kustomization file starts by defining
    a new label called `env` that contains the value `development`. Since this label
    is defined as part of the `commonLabels` field, the effect is that this label
    will be set on all resources that are included in *kustomization.yaml*. The Kustomization
    then declares that its base will be the deployment YAML files that are located
    in the *base* folder. Next, the Kustomization defines a `namePrefix` with the
    value `dev-`*.* The effect of this declaration is to add a prefix to all resource
    names and references. In the final portion of *kustomization.yaml*, a patch is
    declared that will contain modifications to the deployment YAML files found in
    the *base* directory. The patch is contained in the file *update_replicas.yaml*.
    The contents of *update_replicas.yaml* are shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如*kustomization.yaml*所示，Kustomization文件首先定义了一个名为`env`的新标签，其中包含值`development`。由于此标签作为`commonLabels`字段的一部分进行定义，其效果是该标签将设置在包括在*kustomization.yaml*中的所有资源上。然后，Kustomization声明其基础将是位于*base*文件夹中的部署YAML文件。接下来，Kustomization定义了一个`namePrefix`，其值为`dev-`。此声明的效果是为所有资源名称和引用添加前缀。在*kustomization.yaml*的最后部分，声明了一个补丁，该补丁包含了对位于*base*目录中的部署YAML文件的修改。补丁包含在文件*update_replicas.yaml*中。*update_replicas.yaml*的内容如下所示：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The *update_replicas.yaml* file contains a patch that modifies the number of
    replicas to now be `2` for a development environment. To run this example, make
    sure to save the patch in the *development* folder with the name *update_replicas.yaml*.
    You can now run Kustomize using the *kustomization.yaml* and *update_replicas.yaml*
    files by doing the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*update_replicas.yaml*文件包含一个补丁，将开发环境的副本数量修改为`2`。要运行此示例，请确保将该补丁保存在名为*update_replicas.yaml*的*development*文件夹中。现在，您可以通过以下步骤运行Kustomize，使用*kustomization.yaml*和*update_replicas.yaml*文件：'
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After you run this command, Kustomize will generate the patched deployment
    YAML as shown:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行此命令后，Kustomize将生成如下的修补部署YAML：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Upon reviewing the deployment file that was generated, we see several changes
    that resulted from the use of *kustomization.yaml* and *update_replicas.yaml*
    files. First, notice that a new `env` label with the value of `development` now
    exists in both the service and deployment resources, as well as in the `template`
    section used to create the container replicas. Also note that all names listed
    in the deployment YAML have a prefix of `dev-`*.* Finally, the number of replicas
    for the development deployment YAML has been modified to denote that only two
    replicas should be created.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查生成的部署文件时，我们看到了几个由使用*kustomization.yaml*和*update_replicas.yaml*文件导致的变化。首先，请注意现在在服务和部署资源以及用于创建容器副本的`template`部分中都存在一个新的`env`标签，其值为`development`。还要注意，部署的YAML中列出的所有名称现在都有一个前缀`dev-`。最后，开发环境的部署YAML中副本的数量已经修改，以表示只需创建两个副本。
- en: 'Next, we are going to create *kustomize.yaml* and *update_replicas.yaml* files
    that are used to tailor the base deployment YAMLs for a staging environment. In
    our situation, the staging environment should have a label of `env` with the value
    of `staging` on all resources, the names of all resources should have a prefix
    of `staging-`*,* and the number of replicas that should be used for the staging
    environment is five. Similar to the previous example for the development environment
    customizations, we begin by creating a new folder called *staging*. Inside this
    folder, we create a new *kustomization.yaml* as shown:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建*kustomize.yaml*和*update_replicas.yaml*文件，用于为分期环境定制基本部署YAML文件。在我们的情况下，分期环境应该在所有资源上具有一个`env`标签，其值为`staging`，所有资源的名称应该以`staging-`为前缀，分期环境使用的副本数量为五。与之前用于开发环境自定义的示例类似，我们首先创建一个名为*staging*的新文件夹。在该文件夹内，我们创建一个如下所示的新*kustomization.yaml*：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this example, we defined `env` as a `commonLabel` and gave it the value
    of `staging`. We created a new `namePrefix` with the value of `staging-`*.* We
    also are once again creating an *update_replicas.yaml* that will be used as a
    patch file to modify the number of replicas when the base deployments YAML files
    are used in a staging environment. The contents of *update_replicas.yaml* are
    shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将`env`定义为一个`commonLabel`，并将其值设置为`staging`。我们创建了一个新的`namePrefix`，其值为`staging-`。我们还再次创建了一个*update_replicas.yaml*文件，该文件将作为补丁文件，在基本部署YAML文件在分期环境中使用时修改副本数量。*update_replicas.yaml*的内容如下所示：
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once again, the *update_replicas.yaml* file contains a patch that modifies
    the number of replicas. For staging, we have chosen to use five replicas. To run
    this example, make sure to save the patch in the *staging* folder with the name
    *update_replicas.yaml*. You can now run Kustomize using the *kustomization.yaml*
    and *update_replicas.yaml* files by doing the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，*update_replicas.yaml* 文件包含一个补丁，用于修改副本数量。对于暂存环境，我们选择使用五个副本。要运行此示例，请确保将补丁保存在
    *staging* 文件夹中，命名为 *update_replicas.yaml*。现在，您可以通过以下方式运行 Kustomize，使用 *kustomization.yaml*
    和 *update_replicas.yaml* 文件：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'After you run this command, Kustomize will generate the patched deployment
    YAML as shown:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Kustomize 将生成如下的补丁部署 YAML：
- en: '[PRE28]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once more, we see several changes that resulted from the use of our *kustomization.yaml*
    and *update_replicas.yaml* files. First, notice that a new `env` label with the
    value of `staging` now exists in both the service and deployment resources, as
    well as in the `template` section used to create the container replicas. Also
    note that all names listed in the deployment YAML have a prefix of `staging-`*.*
    Finally, the number of replicas for the development deployment YAML has been modified
    to denote that five replicas should be created.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们看到由于使用了我们的 *kustomization.yaml* 和 *update_replicas.yaml* 文件所导致的几个更改。首先，请注意现在服务和部署资源以及用于创建容器副本的
    `template` 部分中都存在一个新的 `env` 标签，其值为 `staging`。还请注意，部署 YAML 中列出的所有名称现在都具有 `staging-`
    的前缀。最后，请注意，开发部署 YAML 的副本数量已被修改，表示应创建五个副本。
- en: 'For our final example, we will use the same techniques to modify the base deployment
    YAML files for a production environment. In our production environment, we should
    have a label of `env` with the value of `production` on all resources, the names
    of all resources should have a prefix of `prod-`*,* and the number of replicas
    that should be used for the production environment is 20\. We begin by creating
    a new folder called *production*. Inside this folder, we create a new *kustomization.yaml*
    as shown:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最终示例，我们将使用相同的技术修改用于生产环境的基础部署 YAML 文件。在我们的生产环境中，所有资源的标签应具有值为 `production`
    的 `env` 标签，所有资源的名称应具有 `prod-` 的前缀，并且生产环境中应使用 20 个副本。我们首先创建一个名为 *production* 的新文件夹。在此文件夹内，我们创建一个新的
    *kustomization.yaml*，如下所示：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We again create an *update_replicas.yaml* file that will be used as a patch
    file to modify the number of replicas when the base deployments YAML files are
    used in the production environment. The contents of *update_replicas.yaml* are
    as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次创建一个 *update_replicas.yaml* 文件，用作在将基础部署 YAML 文件用于生产环境时修改副本数量的补丁文件。*update_replicas.yaml*
    的内容如下：
- en: '[PRE30]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To run this example, make sure to save the patch in the *production* folder
    with the name *update_replicas.yaml*. You can now run Kustomize using the *kustomization.yaml*
    and *update_replicas.yaml* files by doing the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，请确保将补丁保存在 *production* 文件夹中，命名为 *update_replicas.yaml*。现在，您可以通过以下方式运行
    Kustomize，使用 *kustomization.yaml* 和 *update_replicas.yaml* 文件：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'After you run this command, Kustomize will generate the patched deployment
    YAML with the proper labels, prefixes, and replica count value as shown here:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Kustomize 将生成带有正确标签、前缀和副本数量值的补丁部署 YAML，如下所示：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As we have demonstrated with this comprehensive example, Kustomize was able
    to manage deployment YAML files for a development environment, a staging environment,
    and a production environment, and it reduced the number of deployment YAML files
    we needed to maintain for all of these environments. We avoided a large amount
    of copy and paste of files and ended up with a much more manageable solution.
    In the next section, we show how Kustomize can be used to directly deploy its
    generated deployment files.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在这个全面的示例中展示的那样，Kustomize 能够管理用于开发环境、暂存环境和生产环境的部署 YAML 文件，并减少了我们需要维护所有这些环境的部署
    YAML 文件的数量。我们避免了大量的文件复制粘贴，并最终得到了一个更易管理的解决方案。在下一节中，我们将展示如何使用 Kustomize 直接部署其生成的部署文件。
- en: Direct Deploy of Kustomize-Generated Resource Files
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kustomize 生成的资源文件的直接部署
- en: 'In all of the previous Kustomize examples, we generated the modified deployment
    YAMLs and outputted them to make it clear what Kustomize was generating. Kustomize
    provides another option in which the generated deployment YAML files can be automatically
    submitted to Kubernetes for processing. This avoids the step of first generating
    all the deployment YAML files and instead enables us to use Kustomize to directly
    deploy what it generates. To use Kustomize to directly deploy to Kubernetes, we
    use the `kubectl apply -k` option and pass in the desired customization directory.
    For example, if we wanted to directly deploy the production example we just covered,
    we would do the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有之前的 Kustomize 示例中，我们生成了修改后的部署 YAML，并将它们输出，以清晰展示 Kustomize 生成的内容。Kustomize
    提供了另一种选项，即可以自动将生成的部署 YAML 文件提交给 Kubernetes 进行处理。这样可以避免首先生成所有部署 YAML 文件的步骤，而是直接使用
    Kustomize 来部署生成的内容。要使用 Kustomize 直接部署到 Kubernetes，我们使用 `kubectl apply -k` 选项，并传入所需的自定义目录。例如，如果我们想直接部署我们刚刚讨论过的生产示例，我们将执行以下操作：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In addition, Kustomize provides commands for viewing and deleting the Kubernetes
    resources objects that it generates and deploys. More details on these capabilities
    can be found in the [Kustomization documentation](https://oreil.ly/4kCu4). In
    the next section, we introduce the concept of GitOps, which is a popular cloud
    native methodology for automated continuous delivery that is driven directly from
    Git repositories.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kustomize 还提供了查看和删除其生成和部署的 Kubernetes 资源对象的命令。关于这些功能的更多详细信息可以在 [Kustomization
    文档](https://oreil.ly/4kCu4) 中找到。在下一节中，我们介绍 GitOps 的概念，这是一种流行的云原生方法论，用于直接从 Git
    存储库驱动自动化持续交付。
- en: GitOps
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GitOps
- en: '*GitOps* is the idea of using Git to manage your infrastructure as code. The
    idea was first popularized by Weaveworks,^([2](ch05.html#ch01fn34)) and with the
    proliferation of more containerized approaches to software delivery, GitOps has
    become a popular topic in the industry. The basic GitOps flow is always the same:
    an update to your source code triggers automation and ultimately validates a potential
    new change or delivers a new change into a running environment.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*GitOps* 是使用 Git 管理基础设施即代码的理念。这个理念最初由 Weaveworks 提出，^([2](ch05.html#ch01fn34))
    随着更多面向容器化的软件交付方法的流行，GitOps 已成为行业内的热门话题。基本的 GitOps 流程始终如一：对源代码的更新触发自动化流程，最终验证潜在的新变更或将新变更交付到正在运行的环境中。'
- en: 'Applying GitOps involves the following steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 应用 GitOps 包括以下步骤：
- en: Containerized applications are represented with declarative infrastructure (easily
    done with Kubernetes API represented as YAML) and stored in Git.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器化应用程序以声明性基础设施表示（可通过 Kubernetes API 以 YAML 表示轻松实现），并存储在 Git 中。
- en: All changes originate from your source control revision system, typically Git-based
    systems like GitHub, GitLab, Bitbucket, and so on.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有变更均源自您的源代码控制修订系统，通常是 GitHub、GitLab、Bitbucket 等基于 Git 的系统。
- en: Code-review techniques like pull requests or merge requests allow you to apply
    a review process and even automated validation to ensure that changes work correctly
    before wide rollouts.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 像拉取请求或合并请求这样的代码审查技术允许您应用审查流程，甚至自动验证以确保更改在广泛推出之前能够正确运行。
- en: Kubernetes (or more generally a software agent) is then used to apply and reconcile
    the desired state whenever changes are merged into the appropriate branch in your
    repository.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes（或更广义地说是软件代理）随后用于在将更改合并到存储库中的适当分支时应用和协调所需的状态。
- en: The first half of this flow is really about your team and organizational culture.
    Is your organization disciplined enough with the appropriate skill set to make
    all changes indirectly via Git rather than directly manipulating the target infrastructure?
    Are you at a scale in terms of the number of applications, number of delivery
    stages, and number of actual clusters that you can manage the proliferation of
    repositories and branches? As with any cultural change, look for teams in your
    organization that adapt well to new ideas and can become good representative examples
    for the broader organization. Focus on a specific application or set of related
    applications applying this approach from end to end before attempting a broader
    reorganization of your team’s delivery practices.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流程的前半部分实际上关乎于您的团队和组织文化。您的组织是否有足够的纪律性和适当的技能集，可以通过Git间接进行所有更改，而不是直接操作目标基础设施？在应用数量、交付阶段数量和实际集群数量方面，您是否有规模，可以管理库和分支的增加？与任何文化变革一样，寻找在您的组织中适应新思想并且可以成为广泛组织良好代表例的团队。在尝试更广泛地重新组织团队交付实践之前，专注于一个特定的应用程序或一组相关应用程序应用这种方法的端到端。
- en: The second half of the flow is where you have various tools that have evolved
    to simplify the management of adopting changes out of Git, applying the changes
    to your running environments, and validating the changes. We will review a few
    projects that can help you adopt your changes from Git and apply them to your
    Kubernetes environment in the following sections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 流程的后半部分是您拥有各种工具，这些工具已经发展出来，可以简化从Git采纳更改、将更改应用于运行环境并验证更改的管理。我们将在接下来的章节中审查一些可以帮助您从Git采纳更改并将其应用于您的Kubernetes环境的项目。
- en: Pull requests/merge requests (PR/MR) allow you to leverage feature branches
    to complete enhancements and fixes against your code base and validate those changes
    before integration with the main delivery branches. These PR/MR branches generally
    apply automated validation to virtually all dimensions of code quality, including
    security scans, linting or best practices required by your team or organization,
    automated unit testing, automated functional testing, automated integration testing,
    and review by other humans on your team to ensure that the change is consistent
    with the rest of the system’s goals and use cases.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用拉取请求/合并请求（PR/MR）可以利用功能分支完成代码库的增强和修复，并在与主要交付分支集成之前验证这些更改。这些PR/MR分支通常会对代码质量的几乎所有方面进行自动化验证，包括安全扫描、代码检查或团队或组织要求的最佳实践、自动化单元测试、自动化功能测试、自动化集成测试以及团队其他成员的审查，以确保更改与系统其余部分的目标和用例一致。
- en: GitOps can work well in systems with fewer independent applications and fewer
    active environments under management (e.g., software as a service, or SaaS). When
    your delivery output includes software that must be packaged and versioned, GitOps
    can still add value but likely becomes part of a larger story.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps在管理较少独立应用程序和较少活动环境的系统中效果良好（例如软件即服务，或SaaS）。当您的交付产出包括必须打包和版本化的软件时，GitOps仍然可以增加价值，但可能成为更大故事的一部分。
- en: Consider a single application managed with source under management in a Git
    repository. For each stage of your release process, you will create a distinct
    Git branch. In the most basic version, you keep a single “main” branch deployed
    continuously within your end-user accessible production applications. In other
    cases, your release process may require additional lower environments and thus
    additional corresponding branches like “main” (for code under active development),
    “candidate” (for code undergoing user acceptance testing), and “stable” (for code
    running in production). For example, you might have branches “main” and “stable”
    where the “main” branch accumulates changes for development and “stable” tracks
    the version of code and configuration deployed in production. Many organizations
    likely have additional layers of validation, including quality engineering, user
    acceptance testing, performance and scale testing, and so on. Each distinct phase
    that you want control over means potentially another branch in your Git repository.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个使用 Git 存储库中托管源代码管理的单个应用程序。对于发布流程的每个阶段，您将创建一个不同的 Git 分支。在最基本的版本中，您持续部署单个“主”分支，在您的终端用户可访问的生产应用程序中。在其他情况下，您的发布流程可能需要额外的较低环境，因此需要像“主”（用于活跃开发的代码）、“候选”（用于用户验收测试中的代码）和“稳定”（用于生产中运行的代码）这样的相应分支。例如，您可能有“主”和“稳定”分支，“主”分支积累开发中的更改，“稳定”跟踪在生产中部署的代码和配置版本。许多组织可能还有其他层次的验证，包括质量工程、用户验收测试、性能和规模测试等。您希望控制的每个独特阶段可能意味着在您的
    Git 存储库中另一个分支。
- en: In the next section, we introduce Razee, which is the first of several production-quality
    continuous delivery systems for Kubernetes that we survey in this chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们介绍 Razee，这是我们在本章中调查的几种适用于 Kubernetes 的生产质量持续交付系统之一。
- en: Razee
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Razee
- en: '[Razee](https://razee.io) is an open source continuous deployment system originally
    developed by IBM to address issues that arise when supporting extreme-scale environments
    with tens of thousands of Kubernetes clusters that need to be managed. Razee automates
    the deployment of Kubernetes resources across a large number of clusters and environments
    and provides several key features to address issues that arise when managing a
    large number of clusters.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[Razee](https://razee.io) 是一种开源持续部署系统，最初由 IBM 开发，用于解决在支持数万个 Kubernetes 集群的极限规模环境中出现的问题。Razee
    自动化了在大量集群和环境中部署 Kubernetes 资源，并提供了几个关键功能，以解决管理大量集群时出现的问题。'
- en: In contrast to other deployment systems, Razee has a pull-based deployment approach
    that enables Kubernetes clusters to be self-updating. Also, Razee has a dynamic
    inventory-creation feature that allows it to ascertain what is running in all
    the Kubernetes clusters that it manages. With this feature, operators can gain
    insights into what applications and versions run in their clusters. Razee keeps
    a history of this inventory data and provides alerts to help troubleshoot issues
    in clusters.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他部署系统相比，Razee 采用拉取式部署方法，使 Kubernetes 集群能够自我更新。此外，Razee 还具有动态库存创建功能，允许其确定它管理的所有
    Kubernetes 集群中正在运行的内容。通过此功能，操作员可以了解他们的集群中运行的应用程序和版本。Razee 保留了此库存数据的历史记录，并提供警报，以帮助解决集群中的问题。
- en: Razee provides a lot of rule-based support for the grouping of clusters that
    helps to simplify managing large groups of clusters. Razee also uses a rule-based
    approach to orchestrate its pull-based update deployment model. The combination
    of all of these features enables Razee to support automated deployment and management
    of tens of thousands of clusters across multiple availability zones without manual
    intervention. For more details on Razee’s approach to scalability and the key
    features it provides, see the [Razee documentation](https://oreil.ly/1N0ql).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Razee 提供了大量基于规则的支持，用于集群分组，有助于简化管理大量集群。Razee 还使用基于规则的方法来编排其拉取式更新部署模型。所有这些功能的结合使
    Razee 能够支持在多个可用性区域内自动化部署和管理数万个集群，无需手动干预。有关 Razee 扩展性方法和提供的关键功能的更多详细信息，请参阅[Razee
    文档](https://oreil.ly/1N0ql)。
- en: Argo CD
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Argo CD
- en: '[Argo CD](https://oreil.ly/H2UiL) is a declarative continuous delivery system
    that will continuously reconcile the contents of a Git repository with a Kubernetes
    cluster. Argo CD has a number of flexible access control models ranging from a
    deployment per namespace to per cluster, or you can provide credentials for multiple
    clusters via Kubernetes secrets to manage multiple clusters.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[Argo CD](https://oreil.ly/H2UiL)是一个声明式持续交付系统，将Git仓库的内容与Kubernetes集群持续对比。Argo
    CD拥有多种灵活的访问控制模型，从每个命名空间到每个集群的部署，或者您可以通过Kubernetes secrets为多个集群提供凭据以管理多个集群。'
- en: Argo CD adapts well to Kubernetes applications using Helm charts, [Kustomize](https://oreil.ly/TOE56),
    or [ksonnet](https://oreil.ly/9apwT) for templating changes to your resources
    for different clusters. Once deployed and configured, Argo CD will respond to
    postcommit hooks or ongoing polling of changes to the repository and apply those
    changes to the cluster. In many ways, it resembles a Puppet- or Chef-style convergence
    model. If changes are made out of band to the cluster, the desired state will
    eventually be restored.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD很好地适应使用Helm图表、[Kustomize](https://oreil.ly/TOE56)或[ksonnet](https://oreil.ly/9apwT)对资源进行模板化更改的Kubernetes应用程序。一旦部署和配置完成，Argo
    CD将响应仓库的提交挂钩或持续轮询的变更，并将这些变更应用到集群中。在许多方面，它类似于Puppet或Chef风格的收敛模型。如果在集群外进行更改，最终会恢复到期望的状态。
- en: As of the time of this writing, Argo CD has begun looking at additional API
    kinds, including [ApplicationSet](https://oreil.ly/5nbsB), that allow the deployment
    of resources to more than one cluster. One proposed path would enable Argo CD
    to leverage the inventory of clusters available from Open Cluster Management to
    automatically configure GitOps for members of the fleet.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就我写作时而言，Argo CD已经开始关注其他API种类，包括[ApplicationSet](https://oreil.ly/5nbsB)，这些API允许将资源部署到多个集群。一个提议的路径将使Argo
    CD能够利用来自Open Cluster Management的集群库存，自动为机群成员配置GitOps。
- en: For more information on Argo CD, we recommend the [Getting Started](https://oreil.ly/VJQk5)
    materials from the project website.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多有关Argo CD的信息，我们建议从项目网站的[入门指南](https://oreil.ly/VJQk5)开始。
- en: Tekton
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tekton
- en: Tekton is a *continuous integration and continuous delivery* (CI/CD) system
    that runs as a Kubernetes-based cloud native application. Since Tekton runs as
    a Kubernetes-based application, it is built to run as a scalable cloud native
    application. This is a significant advantage over more legacy CI/CD systems, which
    are not cloud native based and thus are more susceptible to failures or performance
    bottlenecks.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton是一个基于Kubernetes的云原生应用程序的*持续集成和持续交付*（CI/CD）系统。由于Tekton作为基于Kubernetes的应用程序运行，它被构建为可扩展的云原生应用程序。这是与传统的非云原生CI/CD系统相比的一个重大优势，后者更容易出现故障或性能瓶颈。
- en: Tekton was originally the build system for the Knative serverless workload platform.
    Because it provided value as a general-purpose CI/CD platform, it was converted
    to a standalone project and donated to the Continuous Delivery Foundation in March
    2019.^([3](ch05.html#ch01fn35))
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton最初是Knative无服务器工作负载平台的构建系统。因为它作为通用的CI/CD平台提供了价值，所以在2019年3月被转换为独立项目，并捐赠给Continuous
    Delivery Foundation。^([3](ch05.html#ch01fn35))
- en: 'Tekton provides a CLI and a dashboard user interface for managing its CI/CD
    workloads. It also has event trigger and webhooks support. There are several great
    tutorials for getting started with Tekton available at the [Tekton Pipeline GitHub
    site](https://oreil.ly/0yZDx) and the [IBM Developer Tekton Tutorial page](https://oreil.ly/FSE9g).
    In the next few sections, we introduce the fundamental concepts of Tekton: tasks
    and pipelines.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton提供了CLI和仪表板用户界面，用于管理其CI/CD工作负载。它还支持事件触发器和Webhook。您可以在[Tekton Pipeline GitHub站点](https://oreil.ly/0yZDx)和[IBM
    Developer Tekton教程页面](https://oreil.ly/FSE9g)找到几篇入门Tekton的优秀教程。在接下来的几节中，我们将介绍Tekton的基本概念：任务和流水线。
- en: Tasks
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务
- en: 'A *task* represents a collection of commands or tools that should be executed
    in a specific order. Each command or tool is represented as a *step,* which defines
    the command or tool to be executed and the container image that contains the command
    or tool. The following example illustrates a simple task with two discrete steps
    that each run an echo command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*任务*代表应按特定顺序执行的命令或工具集合。每个命令或工具被表示为一个*步骤*，定义要执行的命令或工具以及包含该命令或工具的容器镜像。以下示例展示了一个简单的任务，其中包含两个独立的步骤，每个步骤都运行一个echo命令：'
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To run this task, first save the previous example in a file called *simpleexample.yaml*.
    Next, you need to create a `TaskRun` resource that will be used to run the task
    in a standalone fashion on a Kubernetes cluster. Here is the YAML for the `TaskRun`
    resource that we will use:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此任务，请先将前一个示例保存为名为*simpleexample.yaml*的文件。接下来，您需要创建一个`TaskRun`资源，该资源将用于在Kubernetes集群上以独立方式运行任务。以下是我们将使用的`TaskRun`资源的YAML：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As shown in our sample `TaskRun` YAML, we create a `TaskRun` resource and give
    it a name. Then in the `taskRef` field, we provide the name of the task that we
    want to run on a Kubernetes cluster. To deploy the `TaskRun` resource, save the
    previous example as *simpleexamplerun.yaml*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们示例的`TaskRun` YAML中所示，我们创建一个`TaskRun`资源并为其命名。然后在`taskRef`字段中，我们提供要在Kubernetes集群上运行的任务的名称。要部署`TaskRun`资源，请将前一个示例保存为*simpleexamplerun.yaml*。
- en: 'On a Kubernetes cluster that has Tekton installed, run the following commands:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了Tekton的Kubernetes集群上，运行以下命令：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After running these commands, you should see output like the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令后，您应该看到如下输出：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To confirm that the task ran properly, we can use the `tkn taskrun logs --last
    -f` Tekton command to view the logs from the `simple-task-example` that we just
    ran:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认任务是否正确运行，我们可以使用`tkn taskrun logs --last -f` Tekton命令查看刚刚运行的`simple-task-example`的日志：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you need more details on the execution of your task, you can use the `tkn
    taskrun describe` command to get a much larger list of information:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更多关于任务执行的详细信息，可以使用`tkn taskrun describe`命令获取一个更大的信息列表：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While not shown in the previous example, Tekton has a large number of built-in
    capabilities for common integration steps like pulling in content from Git repositories
    and building container images. In addition, Tekton gives tasks a new feature called
    *workspaces,* which is a shared persistent volume. The workspace provides an area
    of shared storage that tasks can use to share files with other tasks that are
    working with it cooperatively. For more details on workspaces, see the [Tekton
    Workspaces Documentation](https://oreil.ly/XUZdv).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在上一个示例中未显示，但Tekton具有大量内置功能，用于常见的集成步骤，如从Git存储库中提取内容和构建容器镜像。此外，Tekton为任务提供了一个名为*工作空间*的新功能，这是一个共享的持久卷。工作空间提供了一个共享存储区，任务可以在其中共享文件，并与正在协作处理它的其他任务一起使用。有关工作空间的更多详细信息，请参阅[Tekton工作空间文档](https://oreil.ly/XUZdv)。
- en: In the next section, we describe pipelines, which is Tekton’s construct for
    enabling multiple tasks to work together on common build integration and deployment
    activities.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将描述管道，这是Tekton用于启用多个任务共同进行构建集成和部署活动的构造。
- en: Pipelines
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管道
- en: 'Tekton provides the notion of *pipelines* as its mechanism for creating a collection
    of tasks and ordering the execution of the group of tasks. In some cases, tasks
    have dependencies on other tasks and must declare that they execute after the
    tasks they are dependent on. In other cases, tasks may not have dependencies on
    one another, and those tasks can run concurrently. The pipelines construct manages
    its collection of tasks and the order in which they execute, as well as the common
    shared workspaces that each task is entitled to use. To better understand how
    pipelines work, we need at least two tasks. In the previous section, we defined
    and deployed the `simple-task-example` task. We will now create a second task
    called `simple-task-example2`. This task is shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton提供了*管道*的概念作为其创建任务集合并排序执行任务组的机制。在某些情况下，任务依赖于其他任务，并且必须声明它们在依赖的任务之后执行。在其他情况下，任务可能不依赖于彼此，并且这些任务可以并发运行。管道构造管理其任务集合以及它们执行的顺序，以及每个任务有权使用的共享工作空间。为了更好地理解管道的工作原理，我们需要至少两个任务。在前一部分中，我们定义并部署了`simple-task-example`任务。现在我们将创建第二个任务称为`simple-task-example2`。此任务如下所示：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To deploy this task, save the previous example in a file called *simpleexample2.yaml*.
    Deploy this task by running the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署此任务，请将前一个示例保存在名为*simpleexample2.yaml*的文件中。通过运行以下命令来部署此任务：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You may notice that with our second task example, we did not provide a corresponding
    `TaskRun` for running it. The reason we don’t have a second `TaskRun` is because
    we are going to group both tasks into a pipeline, and the pipeline will be responsible
    for creating any `TaskRun` objects it needs to run its tasks.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到，对于我们的第二个任务示例，我们没有提供相应的`TaskRun`来运行它。我们之所以没有第二个`TaskRun`，是因为我们将这两个任务分组到一个管道中，管道将负责创建其需要运行其任务的任何`TaskRun`对象。
- en: 'The pipeline that we are using for this example is named `simple-pipeline`,
    and it declares that it manages two tasks, which it references as `simple-task-example`
    and `simple-task-example2` respectively:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用的流水线命名为 `simple-pipeline`，声明其管理两个任务，分别称为 `simple-task-example` 和 `simple-task-example2`：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To run this pipeline, first save the previous example in a file called *simplepipeline.yaml*.
    Deploy this pipeline using the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此流水线，请首先将前面的示例保存到名为 *simplepipeline.yaml* 的文件中。使用以下命令部署此流水线：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we will create a `PipelineRun` object that is responsible for running
    this pipeline on a Kubernetes cluster:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 `PipelineRun` 对象，负责在 Kubernetes 集群上运行此流水线：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Save the previous file as *simplepipelinerun.yaml*. You can then run the `simple-pipeline`
    example on the cluster by running the following command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一个文件保存为 *simplepipelinerun.yaml*。然后，您可以通过运行以下命令在集群上运行 `simple-pipeline` 示例：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To confirm that the pipeline ran properly, use the `tkn pipelinerun logs --last
    -f` Tekton command and view the logs from the `simple-pipeline` example that you
    just ran:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认流水线是否正确运行，请使用 `tkn pipelinerun logs --last -f` Tekton 命令，并查看刚刚运行的 `simple-pipeline`
    示例的日志：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Upon reviewing the log output, we notice that the two tasks ran concurrently.
    This is consistent with how we defined our tasks. If the two tasks had a dependency
    and we needed the second task to defer execution until after the first task completed,
    the Tekton pipeline supports this by adding a `runAfter` declaration to the second
    task that states it should be run after the first task completes. This is shown
    in the following example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查日志输出后，我们注意到两个任务并行运行。这与我们定义任务的方式一致。如果两个任务有依赖关系，并且我们需要第二个任务在第一个任务完成后才能执行，Tekton
    流水线支持通过在第二个任务中添加 `runAfter` 声明来实现这一点。以下是示例：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note that the `runAfter` field explicitly references the task named `simple-task`
    as the task that must be completed before `simple-task2` is permitted to execute.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`runAfter` 字段明确引用了名为 `simple-task` 的任务，在允许 `simple-task2` 执行之前必须完成该任务。
- en: Tekton has a large number of useful features that are beyond the scope of this
    book. For more information on Tekton and its capabilities, see the [Tekton Pipeline
    documentation](https://oreil.ly/nw5yD). In addition, Tekton pipelines serve as
    the foundation for OpenShift Pipelines, an offering available from Red Hat.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton 具有许多有用的功能，超出本书的范围。有关 Tekton 及其功能的更多信息，请参阅 [Tekton Pipeline documentation](https://oreil.ly/nw5yD)。此外，Tekton
    流水线是 Red Hat 提供的 OpenShift Pipelines 的基础。
- en: OpenShift Pipelines
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OpenShift Pipelines
- en: '[OpenShift Pipelines](https://oreil.ly/VU8Gr) is a fully supported software
    offering from Red Hat based on Tekton. Using the operator paradigm simplifies
    the configuration of Tekton and helps you get to value from the ecosystem faster.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[OpenShift Pipelines](https://oreil.ly/VU8Gr) 是 Red Hat 提供的基于 Tekton 的完全支持软件产品。使用操作员范例简化了
    Tekton 的配置，并帮助您更快地从生态系统中获得价值。'
- en: Let’s look at an end-to-end example using OpenShift Pipelines, which is available
    from the [GitHub organization associated with this book](https://oreil.ly/X749O).
    In this example, you’ll see the Tekton concepts of tasks and pipelines put to
    work to build a simple app that lets you play PAC-MAN in your browser.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用 OpenShift Pipelines 的端到端示例，该示例可以从与本书关联的 [GitHub 组织](https://oreil.ly/X749O)
    获取。在此示例中，您将看到任务和流水线的 Tekton 概念，用于构建一个简单的应用程序，让您在浏览器中玩 PAC-MAN。
- en: 'Configure OpenShift Pipelines by installing the operator from the OperatorHub
    catalog available within your OpenShift Container Platform web console (4.4 or
    greater):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 OpenShift Container Platform 网页控制台（4.4 或更高版本）中的 OperatorHub 目录安装操作员来配置 OpenShift
    Pipelines：
- en: Navigate to Operators > OperatorHub and search for “OpenShift Pipelines,” as
    shown in [Figure 5-1](#operatorhub_catalog_filtered_by_the_quer).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 Operators > OperatorHub，并搜索“OpenShift Pipelines”，如 [Figure 5-1](#operatorhub_catalog_filtered_by_the_quer)
    所示。
- en: '![](assets/hcok_0501.png)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](assets/hcok_0501.png)'
- en: Figure 5-1\. OperatorHub catalog filtered by the query “OpenShift Pipelines”
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 根据“OpenShift Pipelines”查询筛选的 OperatorHub 目录
- en: Click on the tile to display information about the operator. Scroll to the bottom
    of the page to download the appropriate command-line version for your platform
    (see [Figure 5-2](#download_the_cli_for_tekton_left_parenth)).
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击瓷砖以显示有关操作员的信息。滚动到页面底部，下载适合您平台的命令行版本（参见 [Figure 5-2](#download_the_cli_for_tekton_left_parenth)）。
- en: '![](assets/hcok_0502.png)'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](assets/hcok_0502.png)'
- en: Figure 5-2\. Download the CLI for Tekton (`tkn`) for your platform
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 下载适用于您平台的 Tekton CLI (`tkn`) 的命令行版本
- en: Click Install.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击安装。
- en: Select the appropriate update channel for your version of OpenShift. For example,
    if you’re running OCP 4.4.x, use ocp-4.4.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择适合你的 OpenShift 版本的更新频道。例如，如果你正在运行 OCP 4.4.x 版本，请使用 ocp-4.4。
- en: Click Subscribe.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击订阅。
- en: You can confirm that the installation was successful by navigating to Operators
    > Installed Operator and filtering the project to “openshift-operators,” as shown
    in [Figure 5-3](#confirm_successful_installation_of_the_o).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到运算符 > 已安装的运算符并将项目过滤为“openshift-operators”，如 [图 5-3](#confirm_successful_installation_of_the_o)
    所示，确认安装成功。
- en: '![](assets/hcok_0503.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0503.png)'
- en: Figure 5-3\. Confirm successful installation of the OpenShift Pipelines Operator
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. 确认成功安装 OpenShift Pipelines 运算符
- en: 'When assembling your continuous delivery solution with Tekton Tasks, you have
    access to a broad community library of existing tasks:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Tekton Tasks 组装您的持续交付解决方案时，您可以访问广泛的社区库存的现有任务：
- en: '[Tekton task catalog](https://oreil.ly/INXgA)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Tekton 任务目录](https://oreil.ly/INXgA)'
- en: '[OpenShift Pipelines task catalog](https://oreil.ly/z3KwI)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OpenShift Pipelines 任务目录](https://oreil.ly/z3KwI)'
- en: 'Let’s reuse some of the tasks in the public catalogs to put together our working
    example. You will also have a set of tasks available after installing the operator:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新利用公共目录中的一些任务来组合我们的工作示例。安装运算符后，您还将获得一组可用的任务：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We will now create a pipeline to build our image and publish to the in-cluster
    registry. First, create a project in your OpenShift cluster to hold the resources
    we are about to create:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个流水线来构建我们的图像，并发布到集群内部的注册表中。首先，在您的 OpenShift 集群中创建一个项目来保存我们即将创建的资源：
- en: '[PRE49]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'All of the following examples assume that you are working in this same namespace,
    `pipelines-tutorial`. If for some reason your `KUBECONFIG` is referencing a different
    namespace, then you can use the `oc project` command to update your context:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所有以下示例假设您正在同一命名空间`pipelines-tutorial`中工作。如果由于某种原因您的`KUBECONFIG`引用了不同的命名空间，则可以使用`oc
    project`命令更新您的上下文：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Alternatively, you can add the `-n pipelines-tutorial` flag to the example
    commands after `oc apply`, `oc create`, `oc get`, and so on. For example:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在`oc apply`、`oc create`、`oc get`等命令后添加`-n pipelines-tutorial`标志，例如：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: To build and publish an image, the default service account `pipeline` must have
    the authorization to push an image into your destination registry. For this example,
    the [Quay.io](https://quay.io) registry is used, but any registry will work fine.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建并发布图像，必须授予默认服务帐户`pipeline`将图像推送到目标注册表的授权。例如，本示例使用 [Quay.io](https://quay.io)
    注册表，但任何注册表都可以正常工作。
- en: 'To enable the authorization for the `pipeline` service account, you must create
    a `docker-registry` secret and update the `pipeline` service account. These steps
    are not related to Tekton specifically but are relevant to our example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`pipeline`服务帐户启用授权，您必须创建一个`docker-registry`密钥，并更新`pipeline`服务帐户。这些步骤与 Tekton
    没有直接关系，但与我们的示例相关：
- en: Create the Quay.io image repository named `quay.io/*<username>*/pacman` for
    your username by following the [Quay.io documentation](https://oreil.ly/N3Ng3).
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为`quay.io/*<username>*/pacman`的 Quay.io 镜像仓库，以您的用户名命名，按照 [Quay.io 文档](https://oreil.ly/N3Ng3)
    进行操作。
- en: Download the Kubernetes secret from Quay.io. You can access the secret from
    the Settings page under “Generate Encrypted Password.”
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Quay.io 下载 Kubernetes 密钥。您可以从“生成加密密码”页面下的设置页面访问此密钥。
- en: 'Apply the secret (and be sure to update the default name of `*<username>*-pull-secret
    to quay-registry-secret`) or use the `kubectl` or `oc` command line to create
    the secret:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用该密钥（确保更新`*<username>*-pull-secret`的默认名称为`quay-registry-secret`），或使用`kubectl`或`oc`命令行创建密钥：
- en: '[PRE52]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Patch the `quay-registry-secret` into the `pipeline` service account. The OpenShift
    pipelines operator automatically creates the `pipeline` service account in every
    namespace of your cluster. By updating the service account in the `pipelines-tutorial`
    namespace, you will allow any Tekton `TaskRun`s to leverage this authorization
    for pushing images:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`quay-registry-secret`补丁到`pipeline`服务帐户中。OpenShift pipelines 运算符会自动在集群的每个命名空间中创建`pipeline`服务帐户。通过更新`pipelines-tutorial`命名空间中的服务帐户，您可以允许任何
    Tekton `TaskRun` 利用此授权来推送图像：
- en: '[PRE53]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will start creating a pipeline that will build an image and push it into
    the image repository that you just defined:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始创建一个流水线，用于构建图像并将其推送到您刚刚定义的图像仓库中：
- en: '[PRE54]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `build-pacman` Pipeline defines a single task that uses the `buildah ClusterTask`.
    The input requires a Git repository with the `Dockerfile` and associated source
    files that are required and the details of the image to build.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`build-pacman`流水线定义了一个使用`buildah ClusterTask`的单个任务。输入需要一个带有所需的`Dockerfile`和相关源文件以及要构建的镜像详细信息的Git仓库。'
- en: 'We create the pipeline using the `oc` command-line tool:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`oc`命令行工具创建流水线：
- en: '[PRE55]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'After applying the pipeline definition, we can verify it exists:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 应用流水线定义后，我们可以验证其是否存在：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `tkn` command-line tool offers a specific set of actions for Tekton resources.
    In addition to equivalents for commands like `get` or `describe`, there are direct
    commands to view task logs and other Tekton-specific behaviors:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkn`命令行工具为Tekton资源提供了一组特定的操作。除了类似于`get`或`describe`的命令等价物外，还有直接的命令来查看任务日志和其他Tekton特定的行为：'
- en: '[PRE57]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Tekton pipelines define parameters that drive their behavior. To simplify the
    management of parameters, Tekton also defines `PipelineResource`s that represent
    different kinds of objects that occur frequently in desired pipeline behavior.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Tekton流水线定义驱动其行为的参数。为了简化参数的管理，Tekton还定义了代表在所需流水线行为中经常出现的不同类型对象的`PipelineResource`s。
- en: 'The following are the defined [`PipelineResource` types](https://oreil.ly/KrZlb):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是定义的[`PipelineResource`类型](https://oreil.ly/KrZlb)：
- en: '`git`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`git`'
- en: GitHub repository
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库
- en: '`storage`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage`'
- en: Storage blob
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 存储blob
- en: '`image`'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`'
- en: Container image metadata
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像元数据
- en: '`cluster`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster`'
- en: Kubernetes cluster description with access credentials
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 具有访问凭据的Kubernetes集群描述
- en: '`pullRequest`'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`pullRequest`'
- en: A GitHub pull request
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个GitHub拉取请求
- en: '`cloudEvent`'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`cloudEvent`'
- en: Cloud Event
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 云事件
- en: '`gcs`'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`gcs`'
- en: GCSResource backed by a GCS blob/directory
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由GCS blob/目录支持的GCSResource
- en: '`build-gcs`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`build-gcs`'
- en: BuildGCSResources added to be compatible with Knative build
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了BuildGCSResources以与Knative构建兼容
- en: 'We will create `PipelineResource`s that will become inputs to the pipeline
    and fulfill the required values for the input parameters:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建`PipelineResource`s，这些资源将成为流水线的输入，并满足输入参数的所需值：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We will apply these resources and then reference them in our `PipelineRun`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用这些资源，然后在我们的`PipelineRun`中引用它们：
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we have a pipeline and we have inputs (our Git repo and our desired image
    to build). Let’s trigger the pipeline by creating a `PipelineRun`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个流水线，我们有输入（我们的Git仓库和我们要构建的期望镜像）。让我们通过创建一个`PipelineRun`来触发流水线：
- en: '[PRE60]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `PipelineRun` will carry out two actions with a single `buildah` task:
    clone the Git repository, and then build the image and publish it to the Quay.io
    registry that you previously created.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`PipelineRun`将使用单个`buildah`任务执行两个操作：克隆Git仓库，然后构建镜像并将其发布到您之前创建的Quay.io注册表中。'
- en: 'To run the pipeline, use `oc create`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行流水线，使用`oc create`：
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We are using `oc create` here instead of `oc apply` because the `PipelineRun`
    uses a `generateName` instead of a `name` attribute. The `oc apply` command requires
    the `name` attribute, whereas `oc create` supports additional behavior to generate
    a suffix for the name automatically.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`oc create`而不是`oc apply`，因为`PipelineRun`使用`generateName`而不是`name`属性。`oc
    apply`命令需要`name`属性，而`oc create`支持额外的行为来自动生成名称的后缀。
- en: 'You can see the running pipelines with the `tkn` command-line tool:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`tkn`命令行工具查看正在运行的流水线：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can follow along with the `PipelineRun` using the `tkn` command line:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`tkn`命令行跟踪`PipelineRun`的执行过程：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The output should resemble the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In this example, we built the container image. Let’s take it further and apply
    the change to the cluster. In this step, we will create a pipeline with three
    distinct stages:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们构建了容器镜像。让我们进一步将更改应用到集群中。在这一步中，我们将创建一个具有三个不同阶段的流水线：
- en: Build the application image.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建应用程序镜像。
- en: Fetch the Git repository that contains our deployment manifests (using Kustomize).
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取包含我们部署清单的Git仓库（使用Kustomize）。
- en: Apply Kustomization deployment manifests.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用Kustomization部署清单。
- en: 'The first step works exactly the same way as before. The additional steps introduce
    a few new ideas:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步的工作方式与以前完全相同。额外的步骤引入了一些新的想法：
- en: We will create a `PersistentVolumeClaim` to provide available storage to host
    the contents of our Git repository. Otherwise, the files retrieved from Git in
    Step 2 will not be available for use in Step 3.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将创建一个`PersistentVolumeClaim`来为我们的Git仓库内容提供可用存储空间。否则，在第2步中从Git检索的文件将无法在第3步中使用。
- en: We will require additional permissions for our `pipeline` service account to
    allow the deployment manifests to be applied to the application namespace on this
    cluster.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将需要为我们的`pipeline`服务账户添加额外的权限，以允许将部署清单应用到此集群上的应用程序命名空间。
- en: 'Let’s create the `PersistentVolumeClaim`. The `PersistentVolumeClaim` should
    request enough capacity for all persistent file system storage required by all
    tasks in the pipeline. If the `PersistentVolume` is reclaimed or recycled in between
    tasks, you may lose important state and the pipeline run will likely fail. On
    the other hand, if the same `PersistentVolume` is reused across many pipeline
    runs, it may eventually exhaust all available space. If the same `PersistentVolume`
    is expected to support multiple pipeline runs in parallel, be sure to set the
    `accessMode` to `ReadWriteMany`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`PersistentVolumeClaim`。`PersistentVolumeClaim`应请求足够的容量，以满足流水线中所有任务所需的所有持久文件系统存储。如果`PersistentVolume`在任务之间被回收或重新利用，可能会丢失重要状态，并且流水线运行可能会失败。另一方面，如果相同的`PersistentVolume`在许多流水线运行之间被重复使用，最终可能会耗尽所有可用空间。如果预计相同的`PersistentVolume`将支持多个并行流水线运行，请确保将`accessMode`设置为`ReadWriteMany`：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: State management of workspaces could become an issue over time. Tekton 0.12
    introduces a `volumeClaimTemplate` that offers to simplify this process. Otherwise,
    you may always be creating `PersistentVolumeClaim`s and `PersistentVolume`s for
    each `PipelineRun`. For any resource that you are creating via automation, be
    sure to define your reclamation strategy to destroy or allow any unnecessary resources
    to age out as appropriate.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，工作区的状态管理可能成为一个问题。Tekton 0.12引入了`volumeClaimTemplate`，可以简化这个过程。否则，您可能会为每个`PipelineRun`始终创建`PersistentVolumeClaim`和`PersistentVolume`。对于通过自动化创建的任何资源，请确保定义回收策略，以销毁或允许任何不必要的资源适时过期。
- en: 'In our first pipeline, we updated the `system:serviceaccounts:pipelines-tutorial:pipeline`
    service account to allow the use of an additional secret that authorized our service
    account to push images into our Quay.io image registry. In our second pipeline,
    our service account will apply deployment manifests to the same cluster running
    the pipeline and will require authorization to the application namespace:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个流水线中，我们更新了`system:serviceaccounts:pipelines-tutorial:pipeline`服务账户，以允许使用额外的秘钥授权我们的服务账户将镜像推送到我们的Quay.io镜像注册表中。在我们的第二个流水线中，我们的服务账户将向运行流水线的相同集群应用部署清单，并需要授权到应用程序命名空间：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With the `edit ClusterRoleBinding` to the `pacman` namespace, the service account
    will be able to create, modify, and view most of the Kubernetes API objects, including
    deployments, services, and OpenShift routes. Our chosen example application creates
    each of these as part of its deployment manifests.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`edit ClusterRoleBinding`到`pacman`命名空间，服务账户将能够创建、修改和查看大多数Kubernetes API对象，包括部署、服务和OpenShift路由。我们选择的示例应用程序在其部署清单中创建了每一个这些对象。
- en: 'To verify that you have applied the permission correctly, you can use the `can-i`
    command, which will print a simple “yes” or “no” answer:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证你已经正确应用权限，可以使用`can-i`命令，它会打印一个简单的“yes”或“no”答案：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now we will create our new pipeline:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建我们的新流水线：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We do not need any additional `PipelineResource`s to run this pipeline. In fact,
    you may notice that the details about the two related Git repositories are managed
    differently in this pipeline. As you consume different tasks or define your own,
    you may find slight inconsistencies in how you assemble tasks to accomplish your
    goals. Specifically, the community `git-clone` task does not use the `git` type
    `Pipeline​Res⁠ource` but rather accepts the component parts needed to identify
    the repository URL and revision.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要任何额外的`PipelineResource`来运行这个流水线。实际上，您可能会注意到在此流水线中管理两个相关的Git仓库的细节有所不同。在消耗不同任务或定义自己的任务时，您可能会发现如何组装任务以实现您的目标存在轻微的不一致。具体来说，社区`git-clone`任务不使用`git`类型的`PipelineRes⁠ource`，而是接受需要识别仓库URL和修订版本的组件部分。
- en: 'Just as before, we will create a `PipelineRun` and monitor its progress:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们将创建一个`PipelineRun`并监视其进度：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Again, you can use the `tkn` command-line tool to view all `PipelineRun`s:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，你可以使用`tkn`命令行工具查看所有`PipelineRun`：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'You can review or follow the logs as well. Note that if you run this after
    the `PipelineRun` has completed, the log order will be reversed:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以查看或跟随日志。请注意，如果您在`PipelineRun`完成后运行此操作，则日志顺序将被反转：
- en: '[PRE71]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Defining and troubleshooting tasks can be a little error prone at first. Use
    the API reference and don’t be afraid to delete or recreate the initial pipelines
    and pipeline runs to resolve reference issues.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义和排查任务可能会有些容易出错。使用API参考，并且不要害怕删除或重新创建初始管道和管道运行以解决引用问题。
- en: 'Now we can confirm whether `pacman` was successfully deployed by opening the
    route with the web browser ([Figure 5-4](#successful_deployment_of_the_pac_man_app)):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用Web浏览器打开路由确认`pacman`是否成功部署（[图5-4](#successful_deployment_of_the_pac_man_app)）：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![](assets/hcok_0504.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0504.png)'
- en: Figure 5-4\. Successful deployment of the PAC-MAN application
  id: totrans-292
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-4\. PAC-MAN应用程序的成功部署
- en: Open Cluster Management Apps
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放集群管理应用程序
- en: The [Open Cluster Management](https://oreil.ly/QbBRN) project is a new approach
    to managing applications across one or more OpenShift clusters. The approach applies
    a native GitOps approach to attaching a Kubernetes object to a Git repository.
    Let’s take a simple example based on the open source PAC-MAN app.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[开放集群管理](https://oreil.ly/QbBRN)项目是跨一个或多个OpenShift集群管理应用程序的新方法。该方法将本地GitOps方法应用于将Kubernetes对象附加到Git存储库。让我们以开源PAC-MAN应用程序为基础进行一个简单的示例。'
- en: The Open Cluster Management project is focused on several aspects of managing
    Kubernetes clusters, including creating and upgrading clusters, distributed delivery
    and management of applications, syndicating cluster configuration, and maintaining
    visibility on the compliance and governance of managed clusters. The *hub* cluster
    runs the multicluster control plane, and a lightweight agent that runs as a set
    of pods on the *managed clusters* applies the desired state to all clusters under
    management and provides a feedback loop for health, search index, and compliance.
    We will focus only on the application management concepts for the next example.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 开放集群管理项目专注于管理Kubernetes集群的几个方面，包括创建和升级集群、分布式交付和应用程序管理、集群配置的同步以及维护托管集群的合规性和治理的可见性。*hub*集群运行多集群控制平面，而在*托管集群*上以一组Pod形式运行的轻量级代理则将所需状态应用于所有受管理的集群，并提供健康、搜索索引和合规性的反馈循环。在下一个示例中，我们将仅关注应用程序管理的概念。
- en: 'The Open Cluster Management app model relies on the following concepts:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 开放集群管理应用程序模型依赖于以下概念：
- en: '`Application`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application`'
- en: A grouping of related resources required to provide a logical service to a consumer.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一组相关资源的分组，用于为消费者提供逻辑服务。
- en: '`Channel`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`Channel`'
- en: A source of application parts required for deployment. Current supported channels
    include Git repositories, object store buckets, and Helm repositories.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 部署所需的应用程序部件的来源。当前支持的通道包括Git存储库、对象存储桶和Helm存储库。
- en: '`Subscription`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscription`'
- en: Connects parts of an application from a channel to one or more clusters. Subscriptions
    consume a range of versions from a release branch (e.g., “latest,” “stable,” “production,”
    etc.).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序的部分连接到一个或多个集群的通道。订阅从发布分支（例如“latest”，“stable”，“production”等）消费一系列版本。
- en: '`PlacementRule`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlacementRule`'
- en: Links a subscription to one or more clusters.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 将订阅链接到一个或多个集群。
- en: '[*Red Hat Advanced Cluster Management* (RHACM)](https://oreil.ly/6x2Ba) is
    a fully supported software offering that is based on the Open Cluster Management
    project. Similar to how OpenShift Pipelines simplifies the setup and life cycle
    of adopting Tekton and other projects, RHACM for Kubernetes simplifies the adoption
    of the Open Cluster Management project ([Figure 5-5](#installation_of_advanced_cluster_managem)).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[*Red Hat高级集群管理* (RHACM)](https://oreil.ly/6x2Ba)是一个基于开放集群管理项目的完全支持的软件提供。类似于OpenShift
    Pipelines简化了采用Tekton和其他项目的设置和生命周期的方式，RHACM为Kubernetes简化了采用开放集群管理项目的方式（[图5-5](#installation_of_advanced_cluster_managem)）。'
- en: '![](assets/hcok_0505.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0505.png)'
- en: Figure 5-5\. Installation of Advanced Cluster Management for Kubernetes in OpenShift
  id: totrans-307
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-5\. 在OpenShift中安装Kubernetes高级集群管理
- en: 'To install RHACM for Kubernetes, follow these steps:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Kubernetes的RHACM，请按照以下步骤操作：
- en: Search for the operator by name and click Install.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名称搜索运营商，然后单击安装。
- en: 'Once the operator is installed, create an instance of the `MultiClusterHub`
    API:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装运营商后，创建`MultiClusterHub` API的实例：
- en: '[PRE73]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: From the Applications list in the OpenShift Container Platform web console,
    click the new item to open the RHACM web console, as shown in [Figure 5-6](#opening_the_rhacm_web_console_in_openshi).
    You may need to refresh your web browser for this new link to appear.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 OpenShift 容器平台 web 控制台的应用程序列表中，单击新项目以打开 RHACM web 控制台，如 [图 5-6](#opening_the_rhacm_web_console_in_openshi)
    所示。您可能需要刷新您的网页浏览器以使此新链接出现。
- en: '![](assets/hcok_0506.png)'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](assets/hcok_0506.png)'
- en: Figure 5-6\. Opening the RHACM web console in OpenShift
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-6\. 在 OpenShift 中打开 RHACM web 控制台
- en: 'The example assumes that you have created or imported two clusters in Advanced
    Cluster Management with the following labels:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 示例假定您在高级集群管理中创建或导入了两个集群，并具有以下标签：
- en: '[PRE74]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For reference, we will assume the following two managed clusters: “cluster1-aws-east”
    and “cluster3-gcp-europe-west3.” Notice that one cluster (“cluster1-aws-east”)
    is provisioned on Amazon in North America, while the second (“cluster3-gcp-europe-west3”)
    is provisioned on Google in Europe (see [Figure 5-7](#using_the_rhacm_web_console_to_manage_bo)).
    So for this example, we’re deploying our app to a multicluster and multicloud
    platform backed by OpenShift!'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，我们假设以下两个托管集群：“cluster1-aws-east”和“cluster3-gcp-europe-west3”。请注意，一个集群（“cluster1-aws-east”）位于北美亚马逊上，而第二个（“cluster3-gcp-europe-west3”）位于欧洲谷歌上（参见
    [图 5-7](#using_the_rhacm_web_console_to_manage_bo)）。因此，在此示例中，我们正在向由 OpenShift
    支持的多集群和多云平台部署我们的应用程序！
- en: '![](assets/hcok_0507.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0507.png)'
- en: Figure 5-7\. Using the RHACM web console to manage both Amazon- and Google-provisioned
    clusters
  id: totrans-319
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-7\. 使用 RHACM web 控制台管理亚马逊和谷歌提供的集群
- en: 'We can display these managed clusters from the command line as well:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从命令行显示这些托管集群：
- en: '[PRE75]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We start by defining our application and referencing the `Subscription` kind
    that will make up the application:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义我们的应用程序，并引用将组成应用程序的`Subscription`类型：
- en: '[PRE76]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The application provides a way to group a set of related parts into a logical
    unit for management. As of the current project readiness, the application is used
    to understand the delivery of parts to different managed clusters. Work is underway
    to also use the application to aggregate health information and summarize the
    readiness of the complete application for all supporting clusters where the application
    or its parts are deployed.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序提供了一种将一组相关部件组合成逻辑单元以便进行管理的方式。根据当前项目准备情况，该应用程序用于理解将部件交付给不同管理集群的情况。目前正在进行工作，以便使用该应用程序汇总健康信息，并总结部署应用程序或其部件的所有支持集群的准备情况。
- en: 'Now let’s define the channel and subscription to attach our application to
    one or more clusters. The channel simply references the Git repository for our
    application:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义频道和订阅，以将我们的应用程序附加到一个或多个集群。该频道简单地引用我们应用程序的 Git 存储库：
- en: '[PRE77]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The subscription then references the channel, includes details about the requested
    branch for application changes, and isolates the relevant directory structure
    within the Git repository. Subscriptions can further restrict when deployments
    are allowed by specifying `timeWindows` that either explicitly allow or block
    changes to the cluster that are recognized in the source repository.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 然后订阅引用频道，包括有关申请变更的分支的详细信息，并在 Git 存储库中隔离相关目录结构。订阅可以通过指定`timeWindows`进一步限制允许或阻止对源存储库中识别的集群的更改的部署时间。
- en: 'Here we see the subscription for the `pacman-app` with references to the channel
    defined previously:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到`pacman-app`的订阅，并参考先前定义的频道：
- en: '[PRE78]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The subscription also provides the ability to supply information to the deployment
    via `packageOverrides` for Kustomization projects or Helm charts.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅还提供通过`packageOverrides`向 Kustomization 项目或 Helm charts 提供部署信息的能力。
- en: The subscription is then matched to a managed cluster by a `PlacementRule`.
    The `PlacementRule` uses match selectors to identify target clusters that are
    under management that should host the application.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`PlacementRule`将订阅与托管集群匹配。`PlacementRule`使用匹配选择器来识别应该托管应用程序的管理目标集群。
- en: 'In the following example, a `PlacementRule` defines a selection clause to select
    at most two clusters that have a region value of `us-east`, `us-west`, or `europe-west3`
    and include the labels `environment=dev` and `apps/pacman=deployed`:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`PlacementRule`定义了一个选择子句，以选择最多两个具有`us-east`、`us-west`或`europe-west3`区域值并包含标签`environment=dev`和`apps/pacman=deployed`的集群：
- en: '[PRE79]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We can apply all of these API resources from our example project:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用我们示例项目中的所有这些 API 资源：
- en: '[PRE80]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now let’s see what this would look like if we had two clusters under management.
    Our first cluster is an OpenShift cluster running on Amazon Elastic Compute Cloud
    (EC2) in the us-east region. Our second cluster is an OpenShift cluster running
    on Google Compute Platform in the europe-west3 region. We can inspect any managed
    clusters in RHACM with the following command:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如果我们管理两个集群会是什么样子。我们的第一个集群是在亚马逊弹性计算云（EC2）的us-east区域运行的OpenShift集群。我们的第二个集群是在Google计算平台的europe-west3区域运行的OpenShift集群。我们可以使用以下命令在RHACM中检查任何管理的集群：
- en: '[PRE81]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Our `PlacementRule` will have identified these two eligible clusters based
    on the `matchLabels` and `matchExpressions` that we defined previously:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`PlacementRule`基于我们之前定义的`matchLabels`和`matchExpressions`，已经识别出这两个符合条件的集群：
- en: '[PRE82]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We can view our application in the Advanced Cluster Management topology view
    and its relevant parts (described by the subscription) that were deployed to our
    two managed clusters (identified by the `PlacementRule`) that originated from
    our Git repository (identified by the channel). In [Figure 5-8](#visualization_of_the_application_in_the),
    we can see the application has exactly one subscription (it could have multiple)
    that is placed on two clusters.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在高级集群管理拓扑视图中查看我们的应用程序及其相关部分（由订阅描述），这些部分部署到我们的两个由`PlacementRule`确定的管理集群（由通道标识），源自我们的Git仓库。在图[5-8](#visualization_of_the_application_in_the)中，我们可以看到该应用程序正好有一个订阅（可能有多个），并且部署在两个集群上。
- en: We can select elements in the topology to view more information, as shown in
    [Figure 5-9](#displaying_the_details_of_multiple_clust).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择拓扑图中的元素以查看更多信息，如图[5-9](#displaying_the_details_of_multiple_clust)所示。
- en: '![](assets/hcok_0508.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0508.png)'
- en: Figure 5-8\. Visualization of the application in the RHACM topology view
  id: totrans-343
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-8\. 在RHACM拓扑视图中显示应用程序的可视化
- en: '![](assets/hcok_0509.png)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0509.png)'
- en: Figure 5-9\. Displaying the details of multiple clusters in the RHACM topology
    view
  id: totrans-345
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-9\. 在RHACM拓扑视图中显示多个集群的详细信息
- en: The cluster icon depicted in [Figure 5-10](#displaying_the_details_of_a_selected_clu)
    shows us the clusters that were selected.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 图[5-10](#displaying_the_details_of_a_selected_clu)中描绘的集群图标显示了我们选择的集群。
- en: '![](assets/hcok_0510.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0510.png)'
- en: Figure 5-10\. Displaying the details of a selected cluster in the RHACM topology
    view
  id: totrans-348
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-10\. 显示选定集群的详细信息在RHACM拓扑视图中
- en: The deployment icons show us how our deployment is doing and whether it was
    successfully deployed and is currently healthy on our managed clusters.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 部署图标展示了我们的部署情况以及它是否成功部署并且当前在我们管理的集群上保持健康状态。
- en: Clicking “Launch resource in Search” will show us details about the `pacman`
    deployment across all managed clusters (see [Figure 5-11](#display_of_the_pacman_deployment_in_the)).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“在搜索中启动资源”将显示跨所有管理的集群中`pacman`部署的详细信息（见图[5-11](#display_of_the_pacman_deployment_in_the)）。
- en: 'Here we can see our `pacman` deployment is running on two clusters: cluster3-gcp-europe-west3
    and cluster1-aws-east. From here we could further inspect related objects, including
    the related pods, services, and secrets used by the deployment.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们的`pacman`部署在两个集群上运行：cluster3-gcp-europe-west3和cluster1-aws-east。从这里，我们可以进一步检查相关的对象，包括部署使用的相关Pod、服务和秘密。
- en: The powerful search capability allows you to understand your application with
    a holistic view. At a minimum, you are able to validate that parts of the application
    are deployed as expected. If a problem arises, these views help you isolate what
    may be the root cause of an observed failure. Making the information available
    in a more consumable form helps SREs and developers be more effective in dealing
    with the complexity of a multicluster or multicloud architecture.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的搜索功能允许您以整体视角了解您的应用程序。至少，您能够验证应用程序的部分按预期部署。如果出现问题，这些视图帮助您隔离可能导致观察到的故障的根本原因。以更易消化的形式提供信息有助于SRE和开发人员更有效地处理多集群或多云架构的复杂性。
- en: '![](assets/hcok_0511.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/hcok_0511.png)'
- en: Figure 5-11\. Display of the `pacman` deployment in the RHACM web console
  id: totrans-354
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-11\. 在RHACM web控制台中显示`pacman`部署
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter provided an overview of several popular tools and methodologies
    for supporting continuous delivery in production across traditional Kubernetes
    and OpenShift clusters. We first introduced Helm, which is a popular packaging
    tool for Kubernetes applications. Next, we described Kustomize, which provides
    the ability to use your existing Kubernetes YAML files for multiple purposes and
    configurations while avoiding the use of templates. We then described several
    popular approaches for supporting continuous delivery pipelines, including GitOps,
    Razee, Tekton, and Argo CD. Finally, we concluded with an extensive discussion
    of OpenShift Pipelines and Open Cluster Management tools for deploying and managing
    OpenShift applications across multiple clusters. With the techniques learned in
    this chapter, you now have a solid understanding of the most popular and proven
    continuous delivery options available to you and some hands-on experience managing
    applications across multiple clusters. In the next chapter, we provide an in-depth
    examination of the crucial operations of provisioning and upgrading in multicluster
    environments.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 本章概述了几种支持在传统 Kubernetes 和 OpenShift 集群中进行生产环境持续交付的流行工具和方法。首先介绍了 Helm，这是 Kubernetes
    应用程序的流行打包工具。接下来，我们描述了 Kustomize，它提供了使用现有的 Kubernetes YAML 文件进行多种用途和配置的能力，同时避免使用模板。然后，我们描述了几种支持持续交付流水线的流行方法，包括
    GitOps、Razee、Tekton 和 Argo CD。最后，我们详细讨论了 OpenShift Pipelines 和 Open Cluster Management
    工具，用于在多个集群中部署和管理 OpenShift 应用程序。通过本章学习的技术，您现在对于可用的最流行和经过验证的持续交付选项有了扎实的理解，并且具备了管理跨多个集群的应用程序的实际经验。在下一章中，我们将深入探讨在多集群环境中进行配置和升级的关键操作。
- en: ^([1](ch05.html#ch01fn33-marker)) Jeff Regan and Phil Wittrock, “Introducing
    Kustomize; Template-free Configuration Customization for Kubernetes,” Kubernetes
    Blog (May 29, 2018), [*https://oreil.ly/fli5E*](https://oreil.ly/fli5E).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#ch01fn33-marker)) Jeff Regan 和 Phil Wittrock，“介绍 Kustomize；用于
    Kubernetes 的无模板配置定制”，Kubernetes 博客（2018 年 5 月 29 日），[*https://oreil.ly/fli5E*](https://oreil.ly/fli5E)。
- en: ^([2](ch05.html#ch01fn34-marker)) Weaveworks, “Guide to GitOps,” [*https://oreil.ly/QIQ24*](https://oreil.ly/QIQ24).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#ch01fn34-marker)) Weaveworks，“GitOps 指南”，[*https://oreil.ly/QIQ24*](https://oreil.ly/QIQ24).
- en: ^([3](ch05.html#ch01fn35-marker)) “Introducing the Continuous Delivery Foundation,
    the New Home for Tekton, Jenkins, Jenkins X, and Spinnaker,” Google Open Source
    Blog (March 12, 2019), [*https://oreil.ly/FvwF1*](https://oreil.ly/FvwF1).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#ch01fn35-marker)) “引入持续交付基金会，Tekton、Jenkins、Jenkins X 和 Spinnaker
    的新家园”，Google 开源博客（2019 年 3 月 12 日），[*https://oreil.ly/FvwF1*](https://oreil.ly/FvwF1).
