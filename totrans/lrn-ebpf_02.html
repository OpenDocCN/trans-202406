<html><head></head><body><section data-pdf-bookmark="Chapter 2. eBPF&#x2019;s &#x201C;Hello World&#x201D;" data-type="chapter" epub:type="chapter"><div class="chapter" id="ebpfapostrophes_quotation_markhello_wor">&#13;
	<h1><span class="label">Chapter 2. </span>eBPF’s “Hello World”</h1>&#13;
&#13;
	<p><a contenteditable="false" data-primary="BCC framework" data-secondary="&quot;Hello World&quot; application" data-secondary-sortas="Hello World" data-type="indexterm" id="ch02.html1"/><a contenteditable="false" data-primary="C (language)" data-secondary="&quot;Hello World&quot; application" data-secondary-sortas="Hello World" data-type="indexterm" id="ch02.html2"/>In the previous chapter&#13;
		I discussed why eBPF is so powerful, but it’s OK if you don’t yet feel you have a concrete grasp of what it&#13;
		really means to run eBPF programs. In this chapter I’ll use a simple “Hello World” example to give you a better&#13;
		feel for it.</p>&#13;
&#13;
	<p>As you’ll learn while you read through this book, there are several different libraries and frameworks for&#13;
		writing eBPF applications. As a warm-up, I’ll show you what is probably the most accessible approach from a&#13;
		programming point of view: the <a href="https://github.com/iovisor/bcc">BCC Python framework</a>. This offers a&#13;
		very easy way to write basic eBPF programs. For reasons that I’ll cover in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, it’s not necessarily an approach&#13;
		I would recommend these days for production apps that you’re intending to distribute to other users, but it’s&#13;
		great for taking your first steps.</p>&#13;
&#13;
	<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
		<p>If you want to try this code for yourself, it is available at <a href="https://github.com/lizrice/learning-ebpf"><em class="hyperlink">https://github.com/lizrice/learning-ebpf</em></a> in the <em>chapter2</em>&#13;
			directory.</p>&#13;
&#13;
		<p>You’ll find the BCC project at <a href="https://github.com/iovisor/bcc"><em class="hyperlink">https://github.com/iovisor/bcc</em></a>, and the instructions for installing BCC&#13;
			are at <a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md"><em class="hyperlink">https://github.com/iovisor/bcc/blob/master/INSTALL.md</em></a>.</p>&#13;
	</div>&#13;
&#13;
	<section data-pdf-bookmark="BCC’s “Hello World”" data-type="sect1"><div class="sect1" id="bccapostrophes_quotation_markhello_worl">&#13;
		<h1>BCC’s “Hello World”</h1>&#13;
&#13;
		<p>The following is the full source code of <em>hello.py</em>, an eBPF “Hello World” application<sup><a data-type="noteref" href="ch02.html#ch02fn1" id="ch02fn1-marker">1</a></sup> written using BCC’s&#13;
			Python library:</p>&#13;
&#13;
		<pre data-code-language="python" data-type="programlisting">&#13;
<code class="c1">#!/usr/bin/python  </code>&#13;
<code class="kn">from</code> <code class="nn">bcc</code> <code class="kn">import</code> <code class="n">BPF</code>&#13;
&#13;
<code class="n">program</code> <code class="o">=</code> <code class="sa">r</code><code class="s2">"""</code>&#13;
<code class="s2">int hello(void *ctx) {</code>&#13;
<code class="s2">    bpf_trace_printk("Hello World!");</code>&#13;
<code class="s2">    return 0;</code>&#13;
<code class="s2">}</code>&#13;
<code class="s2">"""</code>&#13;
&#13;
<code class="n">b</code> <code class="o">=</code> <code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code class="o">=</code><code class="n">program</code><code class="p">)</code>&#13;
<code class="n">syscall</code> <code class="o">=</code> <code class="n">b</code><code class="o">.</code><code class="n">get_syscall_fnname</code><code class="p">(</code><code class="s2">"execve"</code><code class="p">)</code>&#13;
<code class="n">b</code><code class="o">.</code><code class="n">attach_kprobe</code><code class="p">(</code><code class="n">event</code><code class="o">=</code><code class="n">syscall</code><code class="p">,</code> <code class="n">fn_name</code><code class="o">=</code><code class="s2">"hello"</code><code class="p">)</code>&#13;
&#13;
<code class="n">b</code><code class="o">.</code><code class="n">trace_print</code><code class="p">()</code></pre>&#13;
&#13;
		<p>This code consists of two parts: the eBPF program itself that will run in the kernel, and some user space&#13;
			code that loads the eBPF program into the kernel and reads out the trace that it generates. As you can see&#13;
			in <a data-type="xref" href="#the_user_space_and_kernel_components_of">Figure 2-1</a>,&#13;
			<em>hello.py</em> is the user space part of this application, and <code>hello()</code> is the eBPF program&#13;
			that runs in the kernel.&#13;
		</p>&#13;
&#13;
		<figure><div class="figure" id="the_user_space_and_kernel_components_of"><img alt="The user space and kernel components of “Hello World”" src="assets/lebp_0201.png"/>&#13;
			<h6><span class="label">Figure 2-1. </span>The user space and kernel components of “Hello World”</h6>&#13;
		</div></figure>&#13;
&#13;
		<p>Let’s dig into each line of the source code to understand it better.</p>&#13;
&#13;
		<p>The first line tells you this is Python code, and the program that can run it is the Python interpreter&#13;
			(<em>/usr/bin/python</em>).</p>&#13;
&#13;
		<p>The eBPF program itself is written in C code, and it’s this part:</p>&#13;
&#13;
		<pre data-code-language="c" data-type="programlisting">&#13;
<code class="kt">int</code><code class="w"> </code><code class="nf">hello</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">bpf_trace_printk</code><code class="p">(</code><code class="s">"Hello World!"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
		<p class="pagebreak-before"><a contenteditable="false" data-primary="tracing" data-secondary="bpf_trace_printk()" data-type="indexterm" id="idm46123211312352"/>All the eBPF program does is use a helper function,&#13;
			<code>bpf_trace_printk()</code>, to write a message. Helper functions are another feature that distinguishes&#13;
			“extended” BPF from its “classic” predecessor. They are a set of functions that eBPF programs can call to&#13;
			interact with the system; I’ll discuss them further in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>. For now you can just think&#13;
			of this as printing a line of text.&#13;
		</p>&#13;
&#13;
		<p>The entire eBPF program is defined as a string called <code>program</code> in the Python code. This C program&#13;
			needs to be compiled before it can be executed, but BCC takes care of that for you. (You’ll see how to&#13;
			compile eBPF programs yourself in the next chapter.) All you need to do is pass this string as a parameter&#13;
			when creating a BPF object, as in the following line:</p>&#13;
&#13;
		<pre data-code-language="python" data-type="programlisting">&#13;
<code class="n">b</code> <code class="o">=</code> <code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code class="o">=</code><code class="n">program</code><code class="p">)</code></pre>&#13;
&#13;
		<p>eBPF programs need to be attached to an event, and for this example I’ve chosen to attach to the system call&#13;
			<code>execve</code>, which is the syscall used to execute a program. Whenever anything or anyone starts a&#13;
			new program executing on this machine, that will call <code>execve()</code>, which will trigger the eBPF&#13;
			program. Although the “execve()” name is a standard interface in Linux, the name of the function that&#13;
			implements it in the kernel depends on the chip architecture, but BCC gives us a convenient way to look up&#13;
			the function name for the machine we’re running on:&#13;
		</p>&#13;
&#13;
		<pre data-code-language="python" data-type="programlisting">&#13;
<code class="n">syscall</code> <code class="o">=</code> <code class="n">b</code><code class="o">.</code><code class="n">get_syscall_fnname</code><code class="p">(</code><code class="s2">"execve"</code><code class="p">)</code></pre>&#13;
&#13;
		<p>Now, <code>syscall</code> represents the name of the kernel function I’m going to attach to, using a kprobe&#13;
			(you were introduced to the concept of kprobes in <a data-type="xref" href="ch01.html#what_is_ebpf_and_why_is_it_importantque">Chapter 1</a>).<sup><a data-type="noteref" href="ch02.html#ch02fn2" id="ch02fn2-marker">2</a></sup> You can attach the&#13;
			<code>hello</code> function to that event, like this:&#13;
		</p>&#13;
&#13;
		<pre data-code-language="python" data-type="programlisting">&#13;
<code class="n">b</code><code class="o">.</code><code class="n">attach_kprobe</code><code class="p">(</code><code class="n">event</code><code class="o">=</code><code class="n">syscall</code><code class="p">,</code> <code class="n">fn_name</code><code class="o">=</code><code class="s2">"hello"</code><code class="p">)</code></pre>&#13;
&#13;
		<p>At this point, the eBPF program is loaded into the kernel and attached to an event, so the program will be&#13;
			triggered whenever a new executable gets launched on the machine. All that’s left to do in the Python code&#13;
			is to read the tracing that is output by the kernel and write it on the screen:</p>&#13;
&#13;
		<pre data-type="programlisting">&#13;
b.trace_print()</pre>&#13;
&#13;
		<p>This <code>trace_print()</code> function will loop indefinitely (until you stop the program, perhaps with&#13;
			Ctrl+C), displaying any trace.</p>&#13;
&#13;
		<p class="pagebreak-before"><a data-type="xref" href="#quotation_markhello_worldquotation_mark">Figure 2-2</a> illustrates&#13;
			this code. The Python program compiles the C code, loads it into the kernel, and attaches it to the&#13;
			<code>execve</code> syscall kprobe. Whenever any application on this (virtual) machine calls&#13;
			<code>execve()</code>, it triggers the eBPF <code>hello()</code> program, which writes a line of trace into&#13;
			a specific pseudofile. (I’ll cover where that pseudofile is later in this chapter.) The Python program reads&#13;
			the trace message from the pseudofile and displays it to the user.&#13;
		</p>&#13;
&#13;
		<figure><div class="figure" id="quotation_markhello_worldquotation_mark"><img alt="“Hello World” in operation" src="assets/lebp_0202.png"/>&#13;
			<h6><span class="label">Figure 2-2. </span>“Hello World” in operation</h6>&#13;
		</div></figure>&#13;
	</div></section>&#13;
&#13;
	<section data-pdf-bookmark="Running “Hello World”" data-type="sect1"><div class="sect1" id="running_quotation_markhello_worldquotat">&#13;
		<h1>Running “Hello World”</h1>&#13;
&#13;
		<p>Run this program, and depending on what is happening on the (virtual) machine you’re using, you might see&#13;
			tracing being generated straightaway, because other processes could be executing programs<sup><a data-type="noteref" href="ch02.html#ch02fn3" id="ch02fn3-marker">3</a></sup> with the <code>execve</code> syscall. If you don’t see anything, open a second&#13;
			terminal and execute any commands you like,<sup><a data-type="noteref" href="ch02.html#ch02fn4" id="ch02fn4-marker">4</a></sup> and you’ll see the corresponding trace generated by “Hello World”:</p>&#13;
&#13;
		<pre data-type="programlisting">&#13;
$ hello.py&#13;
b'     bash-5412    [001] .... 90432.904952: 0: bpf_trace_printk: Hello World'</pre>&#13;
&#13;
		<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
			<p><a contenteditable="false" data-primary="privileges" data-type="indexterm" id="idm46123214079936"/><a contenteditable="false" data-primary="privileges" data-secondary="for running eBPF programs" data-type="indexterm" id="idm46123203717152"/>Since eBPF is so powerful, it requires special&#13;
				privileges to use it. Privileges are automatically assigned to the root user, so the easiest way to run&#13;
				eBPF programs is as root, perhaps by using <code>sudo</code>. For clarity I won’t include&#13;
				<code>sudo</code> in the example commands in this book, but if you ever see an “Operation not permitted”&#13;
				error, the first thing to check is whether you’re trying to run eBPF programs as an unprivileged user.&#13;
			</p>&#13;
&#13;
			<p><code>CAP_BPF</code> was introduced in kernel version 5.8, and it gives sufficient privilege to perform&#13;
				some eBPF operations like creating certain types of map. However, you will probably need additional&#13;
				<span class="keep-together">capabilities</span>:&#13;
			</p>&#13;
&#13;
			<ul>&#13;
				<li>&#13;
					<p><code>CAP_PERFMON</code> and <code>CAP_BPF</code> are both required to load tracing programs.</p>&#13;
				</li>&#13;
				<li>&#13;
					<p><code>CAP_NET_ADMIN</code> and <code>CAP_BPF</code> are both required for loading networking&#13;
						programs.</p>&#13;
				</li>&#13;
			</ul>&#13;
&#13;
			<p>There is a lot more detail on this in the blog post <a href="https://oreil.ly/G2zFO">“Introduction to&#13;
					CAP_BPF”</a> by Milan Landaverde.</p>&#13;
		</div>&#13;
&#13;
		<p>As soon as the <em>hello</em> eBPF program is loaded and attached to an event, it gets triggered by events&#13;
			that are being generated from preexisting processes. This should reinforce a couple of points that you&#13;
			learned in <a data-type="xref" href="ch01.html#what_is_ebpf_and_why_is_it_importantque">Chapter 1</a>:</p>&#13;
&#13;
		<ul class="list_style_type_none">&#13;
			<li>&#13;
				<p>eBPF programs can be used to dynamically change the behavior of the system. There’s no need to reboot&#13;
					the machine or restart existing processes. eBPF code starts taking effect as soon as it is attached&#13;
					to an event.</p>&#13;
			</li>&#13;
			<li>&#13;
				<p>There’s no need to change anything about other applications for them to be visible to eBPF. Wherever&#13;
					you have terminal access on that machine, if you run an executable in it, that will use the&#13;
					<code>execve()</code> syscall, and if you have the <em>hello</em> program attached to that syscall,&#13;
					it will be triggered to generate tracing output. Likewise, if you have a script that runs&#13;
					executables, that will also trigger the <em>hello</em> eBPF program. You don’t need to change&#13;
					anything about the terminal’s shell, the script, or the executables you’re running.&#13;
				</p>&#13;
			</li>&#13;
		</ul>&#13;
&#13;
		<p>The trace output shows not only the <code>"Hello World</code>" string, but also some additional contextual&#13;
			information about the event that triggered the <em>hello</em> eBPF program to run. In the example output&#13;
			shown at the beginning of this section, the process that made the <code>execve</code> system call had a&#13;
			process ID of 5412, and it was running the command <code>bash</code>. For trace messages, this contextual&#13;
			information is added as part of the kernel tracing infrastructure (which isn’t specific to eBPF), but as&#13;
			you’ll see later in this chapter, it’s also possible to retrieve contextual information like this within the&#13;
			eBPF program itself.</p>&#13;
&#13;
		<p>You might be wondering how the Python code knows where to read the tracing output from. <a contenteditable="false" data-primary="tracing" data-secondary="bpf_trace_printk()" data-type="indexterm" id="idm46123203186400"/><a contenteditable="false" data-primary="tracing" data-secondary="trace pipe" data-type="indexterm" id="idm46123203172800"/>The answer is not very sophisticated—the&#13;
			<code>bpf_trace_printk()</code> helper function in the kernel always sends output to the same predefined&#13;
			pseudofile location: <em>/sys/kernel/debug/tracing/trace_pipe</em>. You can confirm this by using&#13;
			<code>cat</code> to view its contents; you’ll need root privileges to access it.&#13;
		</p>&#13;
&#13;
		<p>A single trace pipe location is fine for a simple “Hello World” example or for basic debugging purposes, but&#13;
			it’s very limited. There is very little flexibility in the format of the output, and it only supports the&#13;
			output of strings, so it’s not terribly useful for passing structured information. Perhaps most importantly,&#13;
			there is just this one location on the (virtual) machine. If you had multiple eBPF programs running&#13;
			simultaneously, they would all write trace output to the same trace pipe, which could get very confusing for&#13;
			a human operator.</p>&#13;
&#13;
		<p>There’s a much better way to get information out of an eBPF program: use an eBPF map.</p>&#13;
	</div></section>&#13;
&#13;
	<section data-pdf-bookmark="BPF Maps" data-type="sect1"><div class="sect1" id="bpf_maps">&#13;
		<h1>BPF Maps</h1>&#13;
&#13;
		<p><a contenteditable="false" data-primary="maps, BPF" data-type="indexterm" id="ch02.html7"/>A <a contenteditable="false" data-primary="maps, BPF" data-secondary="defined" data-type="indexterm" id="idm46123203166400"/><em>map</em> is a data structure that can be accessed from an eBPF&#13;
			program and from user space. Maps are one of the really significant features that distinguish extended BPF&#13;
			from its classic predecessor. (You might think this would mean they are commonly referred to as “eBPF maps,”&#13;
			but you’ll frequently see “BPF maps.” As is generally the case, both terms are used interchangeably.)</p>&#13;
&#13;
		<p>Maps can be used to share data among multiple eBPF programs or to communicate between a user space&#13;
			application and eBPF code running in the kernel. Typical uses include the following:</p>&#13;
&#13;
		<ul class="list_style_type_none">&#13;
			<li>&#13;
				<p>User space writing configuration information to be retrieved by an eBPF <span class="keep-together">program</span></p>&#13;
			</li>&#13;
			<li>&#13;
				<p>An eBPF program storing state, for later retrieval by another eBPF program (or a future run of the&#13;
					same program)</p>&#13;
			</li>&#13;
			<li>&#13;
				<p>An eBPF program writing results or metrics into a map, for retrieval by the user space app that will&#13;
					present results</p>&#13;
			</li>&#13;
		</ul>&#13;
&#13;
		<p>There are various types of BPF maps defined in Linux’s <a href="https://oreil.ly/1s1GM"><em>uapi/linux/bpf.h</em> file</a>, and there is some information about&#13;
			them in the <a href="https://oreil.ly/5oUW7">kernel docs</a>. In general they are all key–value stores, and&#13;
			in this chapter you’ll see examples of maps for hash tables, perf and ring buffers, and arrays of eBPF&#13;
			programs.</p>&#13;
&#13;
		<p class="pagebreak-before">Some map types are defined as arrays, which always have a 4-byte index as the key&#13;
			type; other maps are hash tables that can use some arbitrary data type as the key.</p>&#13;
&#13;
		<p>There are map types that are optimized for particular types of operations, such as <a href="https://oreil.ly/VSoEp">first-in-first-out queues</a>, <a href="https://oreil.ly/VSoEp">first-in-last-out stacks</a>, <a href="https://oreil.ly/vpsun">least-recently-used data storage</a>, <a href="https://oreil.ly/hZ5aM">longest-prefix matching</a>, and <a href="https://oreil.ly/DzCTK">Bloom&#13;
				filters</a> (a probabilistic data structure designed to provide very fast results on whether an element&#13;
			exists).</p>&#13;
&#13;
		<p>Some eBPF map types hold information about specific types of objects. For example, <a href="https://oreil.ly/UUTHO">sockmaps</a> and <a href="https://oreil.ly/jzKYh">devmaps</a> hold&#13;
			information about sockets and network devices and are used by network-related eBPF programs to redirect&#13;
			traffic. A program array map stores a set of indexed eBPF programs, and (as you’ll see later in this&#13;
			chapter) this is used to implement tail calls, where one program can call another. There’s even a <a href="https://oreil.ly/038tN">map-of-maps type</a> to support storing information about maps.</p>&#13;
&#13;
		<p>Some map types have per-CPU variants, which is to say that the kernel uses a different block of memory for&#13;
			each CPU core’s version of that map. This might have you wondering about concurrency concerns for maps that&#13;
			are <em>not</em> per-CPU, where multiple CPU cores could be accessing the same map simultaneously. Spin lock&#13;
			support for (some) maps was added in kernel version 5.1, and we’ll return to this subject in <span class="keep-together"><a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a></span>.</p>&#13;
&#13;
		<p>The next example (<em>chapter2/hello-map.py</em> in the <a href="https://github.com/lizrice/learning-ebpf">GitHub repository</a>) shows some basic operations using&#13;
			a hash table map. It also demonstrates some of BCC’s convenient abstractions that make it very easy to use&#13;
			maps.</p>&#13;
&#13;
		<section data-pdf-bookmark="Hash Table Map" data-type="sect2"><div class="sect2" id="hash_table_map">&#13;
			<h2>Hash Table Map</h2>&#13;
&#13;
			<p><a contenteditable="false" data-primary="hash table map" data-type="indexterm" id="ch02.html8"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="hash table map" data-type="indexterm" id="ch02.html9"/>Like the previous&#13;
				example in this chapter, this eBPF program will be attached to a kprobe at the entry to the&#13;
				<code>execve</code> system call. It’s going to populate a hash table with key–value pairs, where the key&#13;
				is a user ID and the value is a counter for the number of times <code>execve</code> is called by a&#13;
				process running under that user ID. In practice, this example will show how many times each different&#13;
				user has run programs.&#13;
			</p>&#13;
&#13;
			<p>First, let’s look at the C code for the eBPF program itself:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="n">BPF_HASH</code><code class="p">(</code><code class="n">counter_table</code><code class="p">)</code><code class="p">;</code><code class="w">                                     </code><a class="co" href="#list_id_2_1" id="code_id_2_1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="nf">hello</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">u64</code><code class="w"> </code><code class="n">uid</code><code class="p">;</code><code class="w">                                                  </code><code class="w">&#13;
</code><code class="w">  </code><code class="n">u64</code><code class="w"> </code><code class="n">counter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">u64</code><code class="w"> </code><code class="o">*</code><code class="n">p</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">uid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_uid_gid</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="mh">0xFFFFFFFF</code><code class="p">;</code><code class="w">              </code><a class="co" href="#list_id_2_2" id="code_id_2_2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">counter_table</code><code class="p">.</code><code class="n">lookup</code><code class="p">(</code><code class="o">&amp;</code><code class="n">uid</code><code class="p">)</code><code class="p">;</code><code class="w">                            </code><a class="co" href="#list_id_2_3" id="code_id_2_3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">p</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">                                              </code><a class="co" href="#list_id_2_4" id="code_id_2_4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">     </code><code class="n">counter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">*</code><code class="n">p</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">counter</code><code class="o">+</code><code class="o">+</code><code class="p">;</code><code class="w">                                                 </code><a class="co" href="#list_id_2_5" id="code_id_2_5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="n">counter_table</code><code class="p">.</code><code class="n">update</code><code class="p">(</code><code class="o">&amp;</code><code class="n">uid</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">counter</code><code class="p">)</code><code class="p">;</code><code class="w">                      </code><a class="co" href="#list_id_2_6" id="code_id_2_6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
			<dl class="calloutlist">&#13;
				<dt><a class="co" href="#code_id_2_1" id="list_id_2_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
				<dd><code>BPF_HASH()</code> is a BCC macro that defines a hash table map.</dd>&#13;
				<dt><a class="co" href="#code_id_2_2" id="list_id_2_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
				<dd><code>bpf_get_current_uid_gid()</code> is a helper function used to obtain the user ID that is&#13;
					running the process that triggered this kprobe event. The user ID is held in the lowest 32 bits of&#13;
					the 64-bit value that gets returned. (The top 32 bits hold the group ID, but that part is masked&#13;
					out.)</dd>&#13;
				<dt><a class="co" href="#code_id_2_3" id="list_id_2_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
				<dd>Look for an entry in the hash table with a key matching the user ID. It returns a pointer to the&#13;
					corresponding value in the hash table.</dd>&#13;
				<dt><a class="co" href="#code_id_2_4" id="list_id_2_4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
				<dd>If there is an entry for this user ID, set the <code>counter</code> variable to the current value in&#13;
					the hash table (pointed to by <code>p</code>). If there is no entry for this user ID in the hash&#13;
					table, the pointer will be <code>0</code>, and the counter value will be left at <code>0</code>.&#13;
				</dd>&#13;
				<dt><a class="co" href="#code_id_2_5" id="list_id_2_5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
				<dd>Whatever the current counter value is, it gets incremented by one.</dd>&#13;
				<dt><a class="co" href="#code_id_2_6" id="list_id_2_6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
				<dd>Update the hash table with the new counter value for this user ID.</dd>&#13;
			</dl>&#13;
&#13;
			<p>Take a closer look at the lines of code that access the hash table:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="w">  </code><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">counter_table</code><code class="p">.</code><code class="n">lookup</code><code class="p">(</code><code class="o">&amp;</code><code class="n">uid</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
			<p>And later:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="w">  </code><code class="n">counter_table</code><code class="p">.</code><code class="n">update</code><code class="p">(</code><code class="o">&amp;</code><code class="n">uid</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">counter</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
			<p>If you’re thinking “that’s not proper C code!” you’re absolutely right. C doesn’t support defining&#13;
				methods on structures like that.<sup><a data-type="noteref" href="ch02.html#ch02fn5" id="ch02fn5-marker">5</a></sup> This&#13;
				is a great example where BCC’s version of C is very loosely a C-like language that BCC rewrites before&#13;
				it sends the code to the compiler. BCC offers some convenient shortcuts and macros that it converts into&#13;
				“proper” C.</p>&#13;
&#13;
			<p>Just like in the previous example, the C code is defined as a string called <code>program</code>. The&#13;
				program is compiled, loaded into the kernel, and attached to the <code>execve</code> kprobe, in exactly&#13;
				the same way as the previous “Hello World” example:</p>&#13;
&#13;
			<pre data-code-language="python" data-type="programlisting">&#13;
<code class="n">b</code> <code class="o">=</code> <code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code class="o">=</code><code class="n">program</code><code class="p">)</code>&#13;
<code class="n">syscall</code> <code class="o">=</code> <code class="n">b</code><code class="o">.</code><code class="n">get_syscall_fnname</code><code class="p">(</code><code class="s2">"execve"</code><code class="p">)</code>&#13;
<code class="n">b</code><code class="o">.</code><code class="n">attach_kprobe</code><code class="p">(</code><code class="n">event</code><code class="o">=</code><code class="n">syscall</code><code class="p">,</code> <code class="n">fn_name</code><code class="o">=</code><code class="s2">"hello"</code><code class="p">)</code></pre>&#13;
&#13;
			<p>This time a little more work is required on the Python side to read the information out of the hash&#13;
				table:</p>&#13;
&#13;
			<pre data-code-language="python" data-type="programlisting">&#13;
<code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code><code>                                       </code><a class="co" href="#list_id_2_7" id="code_id_2_7"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>  </code><code class="n">sleep</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code>                                         </code><code>&#13;
</code><code>  </code><code class="n">s</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">"</code><code>&#13;
</code><code>  </code><code class="k">for</code><code> </code><code class="n">k</code><code class="p">,</code><code class="n">v</code><code> </code><code class="ow">in</code><code> </code><code class="n">b</code><code class="p">[</code><code class="s2">"</code><code class="s2">counter_table</code><code class="s2">"</code><code class="p">]</code><code class="o">.</code><code class="n">items</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>          </code><a class="co" href="#list_id_2_8" id="code_id_2_8"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>    </code><code class="n">s</code><code> </code><code class="o">+</code><code class="o">=</code><code> </code><code class="sa">f</code><code class="s2">"</code><code class="s2">ID </code><code class="si">{</code><code class="n">k</code><code class="o">.</code><code class="n">value</code><code class="si">}</code><code class="s2">: </code><code class="si">{</code><code class="n">v</code><code class="o">.</code><code class="n">value</code><code class="si">}</code><code class="se">\t</code><code class="s2">"</code><code>&#13;
</code><code>  </code><code class="nb">print</code><code class="p">(</code><code class="n">s</code><code class="p">)</code></pre>&#13;
&#13;
			<dl class="calloutlist">&#13;
				<dt><a class="co" href="#code_id_2_7" id="list_id_2_7"><img alt="1" src="assets/1.png"/></a></dt>&#13;
				<dd>This part of the code loops indefinitely, looking for output to display every two seconds.</dd>&#13;
				<dt><a class="co" href="#code_id_2_8" id="list_id_2_8"><img alt="2" src="assets/2.png"/></a></dt>&#13;
				<dd>BCC automatically creates a Python object to represent the hash table. This code loops through any&#13;
					values and prints them to the screen.</dd>&#13;
			</dl>&#13;
&#13;
			<p>When you run this example, you’ll want a second terminal window where you can run some commands. Here’s&#13;
				some example output I obtained, annotated on the right side with the commands I ran in another terminal:&#13;
			</p>&#13;
&#13;
			<pre data-type="programlisting">&#13;
Terminal 1                          Terminal 2&#13;
$ ./hello-map.py &#13;
                                    [blank line(s) until I run something]&#13;
ID 501: 1                           ls &#13;
ID 501: 1&#13;
ID 501: 2                           ls&#13;
ID 501: 3       ID 0: 1             sudo ls&#13;
ID 501: 4       ID 0: 1             ls&#13;
ID 501: 4       ID 0: 1&#13;
ID 501: 5       ID 0: 2             sudo ls</pre>&#13;
&#13;
			<p>This example generates a line of output every two seconds, whether anything has happened or not. At the&#13;
				end of this output, the hash table contains two entries:</p>&#13;
&#13;
			<ul class="list_style_type_none">&#13;
				<li>&#13;
					<p><code>key=501, value=5</code></p>&#13;
				</li>&#13;
				<li>&#13;
					<p><code>key=0, value=2</code></p>&#13;
				</li>&#13;
			</ul>&#13;
&#13;
			<p>In the second terminal, I have the user ID of 501. Running the <code>ls</code> command with this user ID&#13;
				increments the <code>execve</code> counter. When I run <code>sudo ls</code>, this results in two calls&#13;
				to <code>execve</code>: one is the execution of <code>sudo</code>, under user ID 501; the other is the&#13;
				execution of <code>ls</code>, under root’s user ID of 0.</p>&#13;
&#13;
			<p>In this example, I used a hash table to convey data from the eBPF program to user space. (I could also&#13;
				have used an array type of map here, since the key was an integer; hash tables let you use an arbitrary&#13;
				type as the key.) Hash tables are very convenient when the data is naturally in key–value pairs, but the&#13;
				user space code has to keep polling the table on a regular basis. The Linux kernel already supported the&#13;
				<a href="https://oreil.ly/nTvvH">perf <span class="keep-together">subsystem</span></a> for sending data&#13;
				from the kernel to user space, and&#13;
				eBPF includes support for using perf buffers and their successor, BPF ring buffers. Let’s take a look.<a contenteditable="false" data-primary="" data-startref="ch02.html9" data-type="indexterm" id="idm46123202694256"/><a contenteditable="false" data-primary="" data-startref="ch02.html8" data-type="indexterm" id="idm46123202693040"/>&#13;
			</p>&#13;
		</div></section>&#13;
&#13;
		<section data-pdf-bookmark="Perf and Ring Buffer Maps" data-type="sect2"><div class="sect2" id="perf_and_ring_buffer_maps">&#13;
			<h2>Perf and Ring Buffer Maps</h2>&#13;
&#13;
			<p><a contenteditable="false" data-primary="perf ring buffer" data-type="indexterm" id="idm46123202688880"/><a contenteditable="false" data-primary="ring buffer map" data-type="indexterm" id="idm46123202687904"/><a contenteditable="false" data-primary="BPF_PERF_OUTPUT" data-type="indexterm" id="idm46123202686928"/>In this&#13;
				section I’m going to describe a slightly more sophisticated version of “Hello World” that uses BCC’s&#13;
				<code>BPF_PERF_OUTPUT</code> capabilities, which let you write data in a structure of your choosing into&#13;
				a perf ring buffer map.&#13;
			</p>&#13;
&#13;
			<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
				<p><a contenteditable="false" data-primary="perf buffers" data-secondary="ring buffers versus" data-type="indexterm" id="idm46123202684560"/><a contenteditable="false" data-primary="ring buffers" data-secondary="perf buffers versus" data-type="indexterm" id="idm46123202683344"/>There is a newer construct&#13;
					called “BPF ring buffers” that are now generally preferred over BPF perf buffers, if you have a&#13;
					kernel of version 5.8 or above. Andrii Nakryiko discusses the difference in his <a href="https://oreil.ly/ARRyV">BPF ring buffer</a> blog post. You’ll see an example of BCC’s&#13;
					<code>BPF_RINGBUF_OUTPUT</code> in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>.&#13;
				</p>&#13;
			</div>&#13;
&#13;
			<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="ring_buffers">&#13;
				<h1>Ring Buffers</h1>&#13;
&#13;
				<p><a contenteditable="false" data-primary="ring buffers" data-secondary="basics" data-type="indexterm" id="idm46123202677792"/>Ring buffers are by no means unique to eBPF, but I’ll explain&#13;
					them just in case you haven’t come across them before. You can think of a ring buffer as a piece of&#13;
					memory logically organized in a ring, with separate “write” and “read” pointers. Data of some&#13;
					arbitrary length gets written to wherever the write pointer is, with the length information included&#13;
					in a header for that data. The write pointer moves to after the end of that data, ready for the next&#13;
					write operation.</p>&#13;
&#13;
				<p>Similarly, for a read operation, data gets read from wherever the read pointer is, using the header&#13;
					to determine how much data to read. The read pointer moves along in the same direction as the write&#13;
					pointer so that it points to the next available piece of data. This is illustrated in <a data-type="xref" href="#a_ring_buffer">Figure 2-3</a>, showing a ring buffer with three&#13;
					items of different length available for reading.</p>&#13;
&#13;
				<p>If the read pointer catches up with the write pointer, it simply means there’s no data to read. <a contenteditable="false" data-primary="ring buffers" data-secondary="drop counter" data-type="indexterm" id="idm46123202674272"/><a contenteditable="false" data-primary="drop counter" data-type="indexterm" id="idm46123202672896"/>If a write operation would make the write pointer overtake the&#13;
					read pointer, the data doesn’t get written and a <em>drop counter</em> gets incremented. Read&#13;
					operations include the drop counter to indicate whether data has been lost since the last successful&#13;
					read.</p>&#13;
&#13;
				<p>If read and write operations happened at precisely the same rate with no variability, and they always&#13;
					contained the same amount of data, you could at least in theory get away with a ring buffer just big&#13;
					enough to accommodate that data size. In most applications there will be some variation in the time&#13;
					between reads, writes, or both, so the buffer size needs to be tuned to account for this.</p>&#13;
&#13;
				<figure><div class="figure" id="a_ring_buffer"><img alt="A ring buffer" src="assets/lebp_0203.png"/>&#13;
					<h6><span class="label">Figure 2-3. </span>A ring buffer</h6>&#13;
				</div></figure>&#13;
&#13;
&#13;
			</div></aside>&#13;
&#13;
			<p>You’ll find the source code for this example in <em>chapter2/hello-buffer.py</em> in the <em>Learning&#13;
					eBPF</em> <a href="http://github.com/lizrice/learning-ebpf">GitHub repository</a>. As in the first&#13;
				“Hello World” example you saw early in this chapter, this version will write the string&#13;
				<code>"Hello World"</code> to the screen every time the <code>execve()</code> syscall is used. It will&#13;
				also look up the process ID and the name of the command that makes each <code>execve()</code> call so&#13;
				that you’ll get similar output to the first example. This gives me the opportunity to show you a couple&#13;
				more examples of BPF helper functions.&#13;
			</p>&#13;
&#13;
			<p>Here’s the eBPF program that will be loaded into the kernel:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="n">BPF_PERF_OUTPUT</code><code class="p">(</code><code class="n">output</code><code class="p">)</code><code class="p">;</code><code class="w">                                                </code><a class="co" href="#list_id_2_9" id="code_id_2_9"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="k">struct</code><code class="w"> </code><code class="nc">data_t</code><code class="w"> </code><code class="p">{</code><code class="w">                                                         </code><a class="co" href="#list_id_2_10" id="code_id_2_10"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">pid</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">uid</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="kt">char</code><code class="w"> </code><code class="n">command</code><code class="p">[</code><code class="mi">16</code><code class="p">]</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">]</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="nf">hello</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">data_t</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="p">}</code><code class="p">;</code><code class="w">                                             </code><a class="co" href="#list_id_2_11" id="code_id_2_11"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="kt">char</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="mi">12</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"</code><code class="s">Hello World</code><code class="s">"</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="n">data</code><code class="p">.</code><code class="n">pid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_pid_tgid</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="o">&gt;</code><code class="w"> </code><code class="mi">32</code><code class="p">;</code><code class="w">                         </code><a class="co" href="#list_id_2_12" id="code_id_2_12"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="n">data</code><code class="p">.</code><code class="n">uid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_uid_gid</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">&amp;</code><code class="w"> </code><code class="mh">0xFFFFFFFF</code><code class="p">;</code><code class="w">                   </code><a class="co" href="#list_id_2_13" id="code_id_2_13"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="n">bpf_get_current_comm</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">command</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">           </code><a class="co" href="#list_id_2_14" id="code_id_2_14"><img alt="6" src="assets/6.png"/></a><code class="w"> </code><code class="w">&#13;
</code><code class="w">   </code><code class="n">bpf_probe_read_kernel</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="n">message</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><a class="co" href="#list_id_2_15" id="code_id_2_15"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="n">output</code><code class="p">.</code><code class="n">perf_submit</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="w">                        </code><a class="co" href="#list_id_2_16" id="code_id_2_16"><img alt="8" src="assets/8.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
			<dl class="calloutlist">&#13;
				<dt><a class="co" href="#code_id_2_9" id="list_id_2_9"><img alt="1" src="assets/1.png"/></a></dt>&#13;
				<dd><a contenteditable="false" data-primary="BPF_PERF_OUTPUT" data-type="indexterm" id="idm46123202460496"/>BCC&#13;
					defines the macro <code>BPF_PERF_OUTPUT</code> for creating a map that will be used to pass messages&#13;
					from the kernel to user space. I’ve called this map <code>output</code>.</dd>&#13;
				<dt><a class="co" href="#code_id_2_10" id="list_id_2_10"><img alt="2" src="assets/2.png"/></a></dt>&#13;
				<dd>Every time <code>hello()</code> is run, the code will write a structure’s worth of data. This is the&#13;
					definition of that structure, which has fields for the process ID, the name of the currently running&#13;
					command, and a text message.</dd>&#13;
				<dt><a class="co" href="#code_id_2_11" id="list_id_2_11"><img alt="3" src="assets/3.png"/></a></dt>&#13;
				<dd><code>data</code> is a local variable that holds the data structure to be submitted, and&#13;
					<code>message</code> holds the <code>"Hello World"</code> string.&#13;
				</dd>&#13;
				<dt><a class="co" href="#code_id_2_12" id="list_id_2_12"><img alt="4" src="assets/4.png"/></a></dt>&#13;
				<dd><code>bpf_get_current_pid_tgid()</code> is a helper function that gets the ID of the process that&#13;
					triggered this eBPF program to run. It returns a 64-bit value with the process ID in the top 32&#13;
					bits.<sup><a data-type="noteref" href="ch02.html#ch02fn6" id="ch02fn6-marker">6</a></sup>&#13;
				</dd>&#13;
				<dt><a class="co" href="#code_id_2_13" id="list_id_2_13"><img alt="5" src="assets/5.png"/></a></dt>&#13;
				<dd><code>bpf_get_current_uid_gid()</code> is the helper function you saw in the previous example for&#13;
					obtaining the user ID.</dd>&#13;
				<dt><a class="co" href="#code_id_2_14" id="list_id_2_14"><img alt="6" src="assets/6.png"/></a></dt>&#13;
				<dd>Similarly, <code>bpf_get_current_comm()</code> is a helper function for getting the name of the&#13;
					executable (or “command”) that’s running in the process that made the <code>execve</code> syscall.&#13;
					This is a string, not a numeric value like the process and user IDs, and in C you can’t simply&#13;
					assign a string using <code>=</code>. You have to pass the address of the field where the string&#13;
					should be written, <code>&amp;data.command</code>, as an argument to the helper function.</dd>&#13;
				<dt><a class="co" href="#code_id_2_15" id="list_id_2_15"><img alt="7" src="assets/7.png"/></a></dt>&#13;
				<dd>For this example, the message is <code>"Hello World"</code> every time.&#13;
					<code>bpf_probe_read_kernel()</code> copies it into the right place in the data structure.&#13;
				</dd>&#13;
				<dt><a class="co" href="#code_id_2_16" id="list_id_2_16"><img alt="8" src="assets/8.png"/></a></dt>&#13;
				<dd>At this point the data structure is populated with the process ID, command name, and message. This&#13;
					call to <code>output.perf_submit()</code> puts that data into the map.</dd>&#13;
			</dl>&#13;
&#13;
			<p class="pagebreak-before">Just as in the first “Hello World” example, this C program is assigned to a&#13;
				string called <code>program</code> in the Python code. What follows is the rest of the Python code:</p>&#13;
&#13;
			<pre data-code-language="python" data-type="programlisting">&#13;
<code class="n">b</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code class="o">=</code><code class="n">program</code><code class="p">)</code><code>                                </code><a class="co" href="#list_id_2_17" id="code_id_2_17"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="n">syscall</code><code> </code><code class="o">=</code><code> </code><code class="n">b</code><code class="o">.</code><code class="n">get_syscall_fnname</code><code class="p">(</code><code class="s2">"</code><code class="s2">execve</code><code class="s2">"</code><code class="p">)</code><code>&#13;
</code><code class="n">b</code><code class="o">.</code><code class="n">attach_kprobe</code><code class="p">(</code><code class="n">event</code><code class="o">=</code><code class="n">syscall</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code class="o">=</code><code class="s2">"</code><code class="s2">hello</code><code class="s2">"</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="k">def</code><code> </code><code class="nf">print_event</code><code class="p">(</code><code class="n">cpu</code><code class="p">,</code><code> </code><code class="n">data</code><code class="p">,</code><code> </code><code class="n">size</code><code class="p">)</code><code class="p">:</code><code>                    </code><a class="co" href="#list_id_2_18" id="code_id_2_18"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>   </code><code class="n">data</code><code> </code><code class="o">=</code><code> </code><code class="n">b</code><code class="p">[</code><code class="s2">"</code><code class="s2">output</code><code class="s2">"</code><code class="p">]</code><code class="o">.</code><code class="n">event</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code>&#13;
</code><code>   </code><code class="nb">print</code><code class="p">(</code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">data</code><code class="o">.</code><code class="n">pid</code><code class="si">}</code><code class="s2"> </code><code class="si">{</code><code class="n">data</code><code class="o">.</code><code class="n">uid</code><code class="si">}</code><code class="s2"> </code><code class="si">{</code><code class="n">data</code><code class="o">.</code><code class="n">command</code><code class="o">.</code><code class="n">decode</code><code class="p">(</code><code class="p">)</code><code class="si">}</code><code class="s2"> </code><code class="s2">"</code><code> </code><code class="o">+</code><code> </code><code>\&#13;
</code><code>         </code><code class="sa">f</code><code class="s2">"</code><code class="si">{</code><code class="n">data</code><code class="o">.</code><code class="n">message</code><code class="o">.</code><code class="n">decode</code><code class="p">(</code><code class="p">)</code><code class="si">}</code><code class="s2">"</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="n">b</code><code class="p">[</code><code class="s2">"</code><code class="s2">output</code><code class="s2">"</code><code class="p">]</code><code class="o">.</code><code class="n">open_perf_buffer</code><code class="p">(</code><code class="n">print_event</code><code class="p">)</code><code>            </code><a class="co" href="#list_id_2_19" id="code_id_2_19"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="k">while</code><code> </code><code class="kc">True</code><code class="p">:</code><code>                                          </code><a class="co" href="#list_id_2_20" id="code_id_2_20"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>   </code><code class="n">b</code><code class="o">.</code><code class="n">perf_buffer_poll</code><code class="p">(</code><code class="p">)</code></pre>&#13;
&#13;
			<dl class="calloutlist">&#13;
				<dt><a class="co" href="#code_id_2_17" id="list_id_2_17"><img alt="1" src="assets/1.png"/></a></dt>&#13;
				<dd>The lines that compile the C code, load it into the kernel, and attach it to the syscall event are&#13;
					unchanged from the version of “Hello World” you saw earlier.</dd>&#13;
				<dt><a class="co" href="#code_id_2_18" id="list_id_2_18"><img alt="2" src="assets/2.png"/></a></dt>&#13;
				<dd><code>print_event</code> is a callback function that will output a line of data to the screen. BCC&#13;
					does some heavy lifting so that I can refer to the map simply as <code>b["output"]</code> and grab&#13;
					data from it using <code>b["output"].event()</code>.</dd>&#13;
				<dt><a class="co" href="#code_id_2_19" id="list_id_2_19"><img alt="3" src="assets/3.png"/></a></dt>&#13;
				<dd><code>b["output"].open_perf_buffer()</code> opens the perf ring buffer. The function takes&#13;
					<code>print_event</code> as an argument to define that this is the callback function to be used&#13;
					whenever there is data to read from the buffer.&#13;
				</dd>&#13;
				<dt><a class="co" href="#code_id_2_20" id="list_id_2_20"><img alt="4" src="assets/4.png"/></a></dt>&#13;
				<dd>The program will now loop indefinitely,<sup><a data-type="noteref" href="ch02.html#ch02fn7" id="ch02fn7-marker">7</a></sup>&#13;
					polling the perf ring buffer. If there is any data available, <code>print_event</code> will get&#13;
					called.</dd>&#13;
			</dl>&#13;
&#13;
			<p>Running this code gives us output that’s fairly similar to the original “Hello World”:</p>&#13;
&#13;
			<pre data-type="programlisting">&#13;
$ sudo ./hello-buffer.py&#13;
11654 node Hello World&#13;
11655 sh Hello World&#13;
...</pre>&#13;
&#13;
			<p>As before, you might need to open a second terminal to the same (virtual) machine and run some commands&#13;
				to trigger some output.</p>&#13;
&#13;
			<p><a contenteditable="false" data-primary="tracing" data-secondary="trace pipe" data-type="indexterm" id="idm46123202197488"/>The big difference between this and the original “Hello World”&#13;
				example is that instead of using a single, central trace pipe, the data is now being passed via a ring&#13;
				buffer map called <code>output</code> that was created by this program for its own use, as shown in <a data-type="xref" href="#using_a_perf_ring_buffer_for_passing_da">Figure 2-4</a>.</p>&#13;
&#13;
			<figure><div class="figure" id="using_a_perf_ring_buffer_for_passing_da"><img alt="Using a perf ring buffer for passing data from the kernel to user space" src="assets/lebp_0204.png"/>&#13;
				<h6><span class="label">Figure 2-4. </span>Using a perf ring buffer for passing data from the kernel to user space</h6>&#13;
			</div></figure>&#13;
&#13;
			<p>You can verify that the information isn’t going to the trace pipe by using&#13;
				<code>cat /sys/kernel/debug/tracing/trace_pipe</code>.&#13;
			</p>&#13;
&#13;
			<p>As well as demonstrating the use of a ring buffer map, this example shows some eBPF helper functions for&#13;
				retrieving contextual information about the event that triggered the eBPF program to run. Here you’ve&#13;
				seen helper functions getting the user ID, <span class="keep-together">the process</span> ID, and the&#13;
				name of the current command. As&#13;
				you’ll see in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>, the set of&#13;
				contextual information that’s available and the set of valid helper functions that can be used to&#13;
				retrieve it depend on what type of program it is and what event triggered it.</p>&#13;
&#13;
			<p>The fact that contextual information like this is available to the eBPF code is what makes it so valuable&#13;
				for observability. Whenever an event occurs, an eBPF program can report not only the fact that the event&#13;
				happened but also relevant information about what happened to trigger the event. It’s also highly&#13;
				performant, since all this information can be gathered within the kernel, without the need for any&#13;
				synchronous context switching to user space.</p>&#13;
&#13;
			<p>You’ll see further examples in this book where eBPF helper functions are used to gather other contextual&#13;
				data, as well as examples where eBPF programs change the contextual data or even block events from&#13;
				happening altogether.</p>&#13;
		</div></section>&#13;
&#13;
		<section class="pagebreak-before" data-pdf-bookmark="Function Calls" data-type="sect2"><div class="sect2" id="function_calls">&#13;
			<h2 class="less_space">Function Calls</h2>&#13;
&#13;
			<p><a contenteditable="false" data-primary="function calls" data-type="indexterm" id="idm46123202187552"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="function calls and" data-type="indexterm" id="idm46123202186448"/>You’ve seen that eBPF programs can call helper functions provided by&#13;
				the kernel, but what if you want to split the code you’re writing into functions? Generally, in software&#13;
				development it’s considered good practice<sup><a data-type="noteref" href="ch02.html#ch02fn8" id="ch02fn8-marker">8</a></sup> to pull common code into a function that you can call from&#13;
				multiple places, rather than duplicating the same lines over and over again. But in the early days, eBPF&#13;
				programs were not permitted to call functions other than helper functions. To work around this,&#13;
				programmers have directed the compiler to “always inline” their functions, like this:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="k">static</code><code class="w"> </code><code class="n">__always_inline</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="n">my_function</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">val</code><code class="p">)</code><code class="w"/></pre>&#13;
&#13;
			<p><a contenteditable="false" data-primary="jump instruction" data-type="indexterm" id="idm46123202178352"/>Generally, a&#13;
				function in source code results in the compiler emitting a jump instruction, which causes execution to&#13;
				jump to the set of instructions that make up the called function (and then to jump back again when that&#13;
				function has completed). You can see this illustrated on the left side of <a data-type="xref" href="#layout_of_noninlined_and_inlined_functi">Figure 2-5</a>. The&#13;
				right side shows what happens when a function is inlined: there is no jump instruction; instead, a copy&#13;
				of the function’s instructions is emitted directly within the calling function.</p>&#13;
&#13;
			<figure><div class="figure" id="layout_of_noninlined_and_inlined_functi"><img alt="Layout of noninlined and inlined function instructions" src="assets/lebp_0205.png"/>&#13;
				<h6><span class="label">Figure 2-5. </span>Layout of noninlined and inlined function instructions</h6>&#13;
			</div></figure>&#13;
&#13;
			<p class="pagebreak-before">If the function is called from multiple places, that results in multiple copies&#13;
				of that function’s instructions in the compiled executable. (Sometimes the compiler might choose to&#13;
				inline a function for optimization purposes, and that is one reason why you might not be able to attach&#13;
				a kprobe to certain kernel functions. I’ll come back to this in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>.)</p>&#13;
&#13;
			<p><a contenteditable="false" data-primary="BCC framework" data-secondary="BPF function calls" data-type="indexterm" id="idm46123202154864"/><a contenteditable="false" data-primary="subprograms, eBPF" data-type="indexterm" id="idm46123202153488"/>Starting from Linux kernel 4.16 and LLVM 6.0, the&#13;
				restriction requiring functions to be inlined was lifted so that eBPF programmers could write function&#13;
				calls more naturally. However, this feature, called “BPF to BPF function calls” or “BPF subprograms,”&#13;
				isn’t currently supported by the BCC framework, so let’s come back to it in the next chapter. (You can,&#13;
				of course, continue to use functions with BCC if they are inlined.)</p>&#13;
&#13;
			<p>There is another mechanism for decomposing complex functionality into smaller parts in eBPF: tail calls.&#13;
			</p>&#13;
		</div></section>&#13;
&#13;
		<section data-pdf-bookmark="Tail Calls" data-type="sect2"><div class="sect2" id="tail_calls">&#13;
			<h2>Tail Calls</h2>&#13;
&#13;
			<p><a contenteditable="false" data-primary="maps, BPF" data-secondary="tail calls and" data-type="indexterm" id="ch02.html10"/><a contenteditable="false" data-primary="tail calls" data-type="indexterm" id="ch02.html11"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="tail calls" data-type="indexterm" id="ch02.html12"/>As described at&#13;
				<a href="https://oreil.ly/Loyuz">ebpf.io</a>, “tail calls can call and execute another eBPF program and&#13;
				replace the execution context, similar to how the <code>execve()</code> system call operates for regular&#13;
				processes.” In other words, execution doesn’t return to the caller after a tail call completes.&#13;
			</p>&#13;
&#13;
			<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
				<p><a href="https://oreil.ly/cOA1r">Tail calls</a> are by no means exclusive to eBPF programming. The&#13;
					general motivation behind tail calls is to avoid adding frames to the stack over and over again as a&#13;
					function is called recursively, which can eventually lead to stack overflow errors. If you can&#13;
					arrange your code to call a recursive function as the last thing it does, the stack frame associated&#13;
					with the calling function isn’t really doing anything useful. Tail calls allow for calling a series&#13;
					of functions without growing the stack. This is particularly useful in eBPF where the <a href="https://oreil.ly/SZmkd">stack is limited to 512 bytes</a>.</p>&#13;
			</div>&#13;
&#13;
			<p>Tail calls are made using the <code>bpf_tail_call()</code> helper function, which has the following&#13;
				signature:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="kt">long</code><code class="w"> </code><code class="n">bpf_tail_call</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><em><code class="n">ctx</code></em><code class="p">,</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">bpf_map</code><code class="w"> </code><code class="o">*</code><em><code class="n">prog_array_map</code></em><code class="p">,</code><code class="w"> </code><code class="n">u32</code><code class="w"> </code><em><code class="n">index</code></em><code class="p">)</code></pre>&#13;
&#13;
			<p>The three arguments to this function have the following meanings:</p>&#13;
&#13;
			<ul class="list_style_type_none">&#13;
				<li>&#13;
					<p><code>ctx</code> allows passing the context from the calling eBPF program to the callee.</p>&#13;
				</li>&#13;
				<li>&#13;
					<p><code>prog_array_map</code> is an eBPF map of type <code>BPF_MAP_TYPE_PROG_ARRAY</code>, which&#13;
						holds a set of file descriptors that identify eBPF programs.</p>&#13;
				</li>&#13;
				<li>&#13;
					<p><code>index</code> indicates which of that set of eBPF programs should be invoked.</p>&#13;
				</li>&#13;
			</ul>&#13;
&#13;
			<p>This helper is somewhat unusual in that if it succeeds, it never returns. The currently running eBPF&#13;
				program is replaced on the stack by the program being called. The helper could fail, for example, if the&#13;
				indicated program doesn’t exist in the map, in which case the calling program carries on executing.</p>&#13;
&#13;
			<p>User space code has to load all the eBPF programs into the kernel (as usual), and it also sets up the&#13;
				program array map.</p>&#13;
&#13;
			<p>Let’s look at a simple example written in Python using BCC; you’ll find the code in the <a href="http://github.com/lizrice/learning-ebpf">GitHub repo</a> as <em>chapter2/hello-tail.py</em>.&#13;
				The main eBPF program is attached to a tracepoint at the common entry point for all syscalls. This&#13;
				program uses tail calls to trace out specific messages for certain syscall opcodes. If there isn’t a&#13;
				tail call for a given opcode, the program traces out a generic message.</p>&#13;
&#13;
			<p>If you’re using the BCC framework, to make a <a href="https://oreil.ly/rT9e1">tail call</a> you can use a&#13;
				line of the slightly simpler form:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="n">prog_array_map</code><code class="p">.</code><code class="n">call</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="n">index</code><code class="p">)</code><code class="w"/></pre>&#13;
&#13;
			<p>Before passing the code to the compilation step, BCC will rewrite the preceding line to this:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="n">bpf_tail_call</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="n">prog_array_map</code><code class="p">,</code><code class="w"> </code><code class="n">index</code><code class="p">)</code><code class="w"/></pre>&#13;
&#13;
			<p>Here is the source code for the eBPF program and its tail calls:</p>&#13;
&#13;
			<pre data-code-language="c" data-type="programlisting">&#13;
<code class="n">BPF_PROG_ARRAY</code><code class="p">(</code><code class="n">syscall</code><code class="p">,</code><code class="w"> </code><code class="mi">300</code><code class="p">)</code><code class="p">;</code><code class="w">                                   </code><a class="co" href="#list_id_2_21" id="code_id_2_21"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="nf">hello</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">bpf_raw_tracepoint_args</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">                </code><a class="co" href="#list_id_2_22" id="code_id_2_22"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">opcode</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">ctx</code><code class="o">-</code><code class="o">&gt;</code><code class="n">args</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="p">;</code><code class="w">                                   </code><a class="co" href="#list_id_2_23" id="code_id_2_23"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="n">syscall</code><code class="p">.</code><code class="n">call</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="n">opcode</code><code class="p">)</code><code class="p">;</code><code class="w">                                   </code><a class="co" href="#list_id_2_24" id="code_id_2_24"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="n">bpf_trace_printk</code><code class="p">(</code><code class="s">"</code><code class="s">Another syscall: %d</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">opcode</code><code class="p">)</code><code class="p">;</code><code class="w">             </code><a class="co" href="#list_id_2_25" id="code_id_2_25"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="nf">hello_execve</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">                                   </code><a class="co" href="#list_id_2_26" id="code_id_2_26"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="n">bpf_trace_printk</code><code class="p">(</code><code class="s">"</code><code class="s">Executing a program</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="nf">hello_timer</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">bpf_raw_tracepoint_args</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">          </code><a class="co" href="#list_id_2_27" id="code_id_2_27"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">ctx</code><code class="o">-</code><code class="o">&gt;</code><code class="n">args</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="mi">222</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">       </code><code class="n">bpf_trace_printk</code><code class="p">(</code><code class="s">"</code><code class="s">Creating a timer</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">ctx</code><code class="o">-</code><code class="o">&gt;</code><code class="n">args</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="mi">226</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">       </code><code class="n">bpf_trace_printk</code><code class="p">(</code><code class="s">"</code><code class="s">Deleting a timer</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">       </code><code class="n">bpf_trace_printk</code><code class="p">(</code><code class="s">"</code><code class="s">Some other timer operation</code><code class="s">"</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="nf">ignore_opcode</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">                                  </code><a class="co" href="#list_id_2_28" id="code_id_2_28"><img alt="8" src="assets/8.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
			<dl class="calloutlist">&#13;
				<dt><a class="co" href="#code_id_2_21" id="list_id_2_21"><img alt="1" src="assets/1.png"/></a></dt>&#13;
				<dd>BCC provides a <code>BPF_PROG_ARRAY</code> macro for easily defining maps of type&#13;
					<code>BPF_MAP_TYPE_PROG_ARRAY</code>. I have called the map <code>syscall</code> and allowed for&#13;
					300 entries,<sup><a data-type="noteref" href="ch02.html#ch02fn9" id="ch02fn9-marker">9</a></sup> which&#13;
					is going to be sufficient for this example.&#13;
				</dd>&#13;
				<dt><a class="co" href="#code_id_2_22" id="list_id_2_22"><img alt="2" src="assets/2.png"/></a></dt>&#13;
				<dd>In the user space code that you’ll see shortly, I’m going to attach this eBPF program to the&#13;
					<code>sys_enter</code> raw tracepoint, which gets hit whenever any syscall is made. The context&#13;
					passed to an eBPF program attached to a raw tracepoint takes the form of this&#13;
					<code>bpf_raw_tracepoint_args</code> structure.&#13;
				</dd>&#13;
				<dt><a class="co" href="#code_id_2_23" id="list_id_2_23"><img alt="3" src="assets/3.png"/></a></dt>&#13;
				<dd>In the case of <code>sys_enter</code>, the raw tracepoint arguments include the opcode identifying&#13;
					which syscall is being made.</dd>&#13;
				<dt><a class="co" href="#code_id_2_24" id="list_id_2_24"><img alt="4" src="assets/4.png"/></a></dt>&#13;
				<dd>Here we make a tail call to the entry in the program array whose key matches the opcode. This line&#13;
					of code will be rewritten by BCC to a call to the <code>bpf_tail_call()</code> helper function&#13;
					before it passes the source code to the <span class="keep-together">compiler</span>.</dd>&#13;
				<dt><a class="co" href="#code_id_2_25" id="list_id_2_25"><img alt="5" src="assets/5.png"/></a></dt>&#13;
				<dd>If the tail call succeeds, this line tracing out the opcode value will never be hit. I’ve used this&#13;
					to provide a default line of trace for opcodes for which there isn’t a program entry in the map.&#13;
				</dd>&#13;
				<dt><a class="co" href="#code_id_2_26" id="list_id_2_26"><img alt="6" src="assets/6.png"/></a></dt>&#13;
				<dd><code>hello_exec()</code> is a program that will be loaded into the syscall program array map, to be&#13;
					executed as a tail call when the opcode indicates it’s an <code>execve()</code> syscall. It’s just&#13;
					going to generate a line of trace to tell the user a new program is being executed.</dd>&#13;
				<dt><a class="co" href="#code_id_2_27" id="list_id_2_27"><img alt="7" src="assets/7.png"/></a></dt>&#13;
				<dd><code>hello_timer()</code> is another program that will be loaded into the syscall program array. In&#13;
					this case it’s going to be referred to by more than one entry in the program array.</dd>&#13;
				<dt><a class="co" href="#code_id_2_28" id="list_id_2_28"><img alt="8" src="assets/8.png"/></a></dt>&#13;
				<dd><code>ignore_opcode()</code> is a tail call program that does nothing. I’ll use this for syscalls&#13;
					where I don’t want any trace to be generated at all.</dd>&#13;
			</dl>&#13;
&#13;
			<p class="pagebreak-before">Now let’s look at the user space code that loads and manages this set of eBPF&#13;
				<span class="keep-together">programs</span>:&#13;
			</p>&#13;
&#13;
			<pre data-code-language="python" data-type="programlisting">&#13;
<code class="n">b</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code class="o">=</code><code class="n">program</code><code class="p">)</code><code>                                              </code><code>&#13;
</code><code class="n">b</code><code class="o">.</code><code class="n">attach_raw_tracepoint</code><code class="p">(</code><code class="n">tp</code><code class="o">=</code><code class="s2">"</code><code class="s2">sys_enter</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code class="o">=</code><code class="s2">"</code><code class="s2">hello</code><code class="s2">"</code><code class="p">)</code><code>           </code><a class="co" href="#list_id_2_29" id="code_id_2_29"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>&#13;
</code><code class="n">ignore_fn</code><code> </code><code class="o">=</code><code> </code><code class="n">b</code><code class="o">.</code><code class="n">load_func</code><code class="p">(</code><code class="s2">"</code><code class="s2">ignore_opcode</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">BPF</code><code class="o">.</code><code class="n">RAW_TRACEPOINT</code><code class="p">)</code><code>       </code><a class="co" href="#list_id_2_30" id="code_id_2_30"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="n">exec_fn</code><code> </code><code class="o">=</code><code> </code><code class="n">b</code><code class="o">.</code><code class="n">load_func</code><code class="p">(</code><code class="s2">"</code><code class="s2">hello_exec</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">BPF</code><code class="o">.</code><code class="n">RAW_TRACEPOINT</code><code class="p">)</code><code>&#13;
</code><code class="n">timer_fn</code><code> </code><code class="o">=</code><code> </code><code class="n">b</code><code class="o">.</code><code class="n">load_func</code><code class="p">(</code><code class="s2">"</code><code class="s2">hello_timer</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">BPF</code><code class="o">.</code><code class="n">RAW_TRACEPOINT</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="n">prog_array</code><code> </code><code class="o">=</code><code> </code><code class="n">b</code><code class="o">.</code><code class="n">get_table</code><code class="p">(</code><code class="s2">"</code><code class="s2">syscall</code><code class="s2">"</code><code class="p">)</code><code>                                </code><a class="co" href="#list_id_2_31" id="code_id_2_31"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">59</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">exec_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">222</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">timer_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">223</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">timer_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">224</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">timer_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">225</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">timer_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">226</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">timer_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="c1"># Ignore some syscalls that come up a lot                          </code><a class="co" href="#list_id_2_32" id="code_id_2_32"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">21</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">ignore_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">22</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">ignore_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code class="n">prog_array</code><code class="p">[</code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="mi">25</code><code class="p">)</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="n">ct</code><code class="o">.</code><code class="n">c_int</code><code class="p">(</code><code class="n">ignore_fn</code><code class="o">.</code><code class="n">fd</code><code class="p">)</code><code>&#13;
</code><code class="o">.</code><code class="o">.</code><code class="o">.</code><code>&#13;
</code><code>&#13;
</code><code class="n">b</code><code class="o">.</code><code class="n">trace_print</code><code class="p">(</code><code class="p">)</code><code>                                                    </code><a class="co" href="#list_id_2_33" id="code_id_2_33"><img alt="5" src="assets/5.png"/></a></pre>&#13;
&#13;
			<dl class="calloutlist">&#13;
				<dt><a class="co" href="#code_id_2_29" id="list_id_2_29"><img alt="1" src="assets/1.png"/></a></dt>&#13;
				<dd>Instead of attaching to a kprobe, as you saw earlier, this time the user space code attaches the&#13;
					main eBPF program to the <code>sys_enter</code> tracepoint.</dd>&#13;
				<dt><a class="co" href="#code_id_2_30" id="list_id_2_30"><img alt="2" src="assets/2.png"/></a></dt>&#13;
				<dd>These calls to <code>b.load_func()</code> return a file descriptor for each tail call program.&#13;
					Notice that tail calls need to have the same program type as their&#13;
					parent—<code>BPF.RAW_TRACEPOINT</code> in this case. Also, it bears pointing out that each tail call&#13;
					program is an eBPF program in its own right.</dd>&#13;
				<dt><a class="co" href="#code_id_2_31" id="list_id_2_31"><img alt="3" src="assets/3.png"/></a></dt>&#13;
				<dd>The user space code creates entries in the <code>syscall</code> map. The map doesn’t have to be&#13;
					fully populated for every possible opcode; if there is no entry for a particular opcode, it simply&#13;
					means no tail call will be executed. Also, it’s perfectly fine to have multiple entries that point&#13;
					to the same eBPF program. In this case, I want the <code>hello_timer()</code> tail call to be&#13;
					executed for any of a set of timer-related <span class="keep-together">syscalls</span>.</dd>&#13;
				<dt><a class="co" href="#code_id_2_32" id="list_id_2_32"><img alt="4" src="assets/4.png"/></a></dt>&#13;
				<dd>Some syscalls get run so frequently by the system that a line of trace for each of them clutters up&#13;
					the trace output to the point of unreadability. I’ve used the <code>ignore_opcode()</code> tail call&#13;
					for several syscalls.</dd>&#13;
				<dt><a class="co" href="#code_id_2_33" id="list_id_2_33"><img alt="5" src="assets/5.png"/></a></dt>&#13;
				<dd>Print the trace output to the screen, until the user terminates the program.</dd>&#13;
			</dl>&#13;
&#13;
			<p>Running this program generates trace output for every syscall that runs on the (virtual) machine, unless&#13;
				the opcode has an entry that links it to the <code>ignore_opcode()</code> tail call. Here’s some example&#13;
				output from running <code>ls</code> in another terminal (some details have been omitted for&#13;
				readability):</p>&#13;
&#13;
			<pre data-type="programlisting">&#13;
./hello-tail.py &#13;
b'   hello-tail.py-2767    ... Another syscall: 62'&#13;
b'   hello-tail.py-2767    ... Another syscall: 62'&#13;
...&#13;
b'            bash-2626    ... Executing a program'&#13;
b'            bash-2626    ... Another syscall: 220'&#13;
...&#13;
b'           &lt;...&gt;-2774    ... Creating a timer'&#13;
b'           &lt;...&gt;-2774    ... Another syscall: 48'&#13;
b'           &lt;...&gt;-2774    ... Deleting a timer'&#13;
...&#13;
b'              ls-2774    ... Another syscall: 61'&#13;
b'              ls-2774    ... Another syscall: 61'&#13;
...</pre>&#13;
&#13;
			<p>The particular syscalls being executed are beside the point, but you can see that the different tail&#13;
				calls are getting called and are generating trace messages. You can also see the default message&#13;
				<code>Another syscall</code> for opcodes that don’t have an entry in the tail call program map.&#13;
			</p>&#13;
&#13;
			<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
				<p>Check out Paul Chaignon’s blog post about the <a href="https://oreil.ly/jTxcb">cost of BPF tail&#13;
						calls</a> on various different kernel versions.</p>&#13;
			</div>&#13;
&#13;
			<p>Tail calls have been supported in eBPF since kernel version 4.2, but for a long time they were&#13;
				incompatible with making BPF to BPF function calls. This restriction was lifted in kernel 5.10.<sup><a data-type="noteref" href="ch02.html#ch02fn10" id="ch02fn10-marker">10</a></sup></p>&#13;
&#13;
			<p>The fact that you can chain up to 33 tail calls together, combined with the instruction complexity limit&#13;
				per eBPF program of 1 million instructions, means that today’s eBPF programmers have a lot of leeway to&#13;
				write very complex code to run entirely in the kernel<a contenteditable="false" data-primary="" data-startref="ch02.html12" data-type="indexterm" id="idm46123201314800"/><a contenteditable="false" data-primary="" data-startref="ch02.html11" data-type="indexterm" id="idm46123201313584"/><a contenteditable="false" data-primary="" data-startref="ch02.html10" data-type="indexterm" id="idm46123201312368"/>.<a contenteditable="false" data-primary="" data-startref="ch02.html7" data-type="indexterm" id="idm46123201311024"/></p>&#13;
		</div></section>&#13;
	</div></section>&#13;
&#13;
	<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000011">&#13;
		<h1>Summary</h1>&#13;
&#13;
		<p>I hope that by showing some concrete examples of an eBPF program, this chapter helped you consolidate your&#13;
			mental model of eBPF code running in the kernel, triggered by events. You’ve also seen examples of data&#13;
			being passed from the kernel to user space using BPF maps.</p>&#13;
&#13;
		<p>Using the BCC framework hides many of the details of how the program is built, loaded into the kernel, and&#13;
			attached to events. In the next chapter I’ll show you a different approach to writing “Hello World,” and&#13;
			we’ll dive deeper into those hidden details.<a contenteditable="false" data-primary="" data-startref="ch02.html2" data-type="indexterm" id="idm46123201308528"/><a contenteditable="false" data-primary="" data-startref="ch02.html1" data-type="indexterm" id="idm46123201307312"/></p>&#13;
	</div></section>&#13;
&#13;
	<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="exercises_id000001">&#13;
		<h1>Exercises</h1>&#13;
&#13;
		<p>Here are some optional activities you might like to try (or think about) if you want to explore “Hello World”&#13;
			a bit further:</p>&#13;
&#13;
		<ol>&#13;
			<li>&#13;
				<p>Adapt the <em>hello-buffer.py</em> eBPF program to output different trace messages for odd and even&#13;
					process IDs.</p>&#13;
			</li>&#13;
			<li>&#13;
				<p>Modify <em>hello-map.py</em> so that the eBPF code gets triggered by more than one syscall. For&#13;
					example, <code>openat()</code> is commonly called to open files, and <code>write()</code> is called&#13;
					to write data to a file. You can start by attaching the <em>hello</em> eBPF program to multiple&#13;
					syscall kprobes. Then try having modified versions of the <em>hello</em> eBPF program for different&#13;
					syscalls, demonstrating that you can access the same map from multiple different programs.</p>&#13;
			</li>&#13;
			<li>&#13;
				<p>The <em>hello-tail.py</em> eBPF program is an example of a program that attaches to the&#13;
					<code>sys_enter</code> raw tracepoint that is hit whenever <em>any</em> syscall is called. Change&#13;
					<em>hello-map.py</em> to show the total number of syscalls made by each user ID, by attaching it to&#13;
					that same <code>sys_enter</code> raw tracepoint.&#13;
				</p>&#13;
				<p>Here’s some example output I got after making that change:</p>&#13;
&#13;
				<pre data-type="programlisting">&#13;
$ ./hello-map.py &#13;
ID 104: 6     ID 0: 225&#13;
ID 104: 6     ID 101: 34    ID 100: 45    ID 0: 332     ID 501: 19&#13;
ID 104: 6     ID 101: 34    ID 100: 45    ID 0: 368     ID 501: 38&#13;
ID 104: 6     ID 101: 34    ID 100: 45    ID 0: 533     ID 501: 57</pre>&#13;
			</li>&#13;
			<li class="pagebreak-before">&#13;
				<p>The <a href="https://oreil.ly/kh-j4"><code>RAW_TRACEPOINT_PROBE</code> macro provided by BCC</a>&#13;
					simplifies attaching to raw tracepoints, telling the user space BCC code to automatically attach it&#13;
					to a specified tracepoint. Try it in <em>hello-tail.py</em>, like this:</p>&#13;
&#13;
				<ul>&#13;
					<li>&#13;
						<p>Replace the definition of the <code>hello()</code> function with&#13;
							<code>RAW_TRACEPOINT_PROBE(sys_enter)</code>.&#13;
						</p>&#13;
					</li>&#13;
					<li>&#13;
						<p>Remove the explicit attachment call <code>b.attach_raw_tracepoint()</code> from the Python&#13;
							code.</p>&#13;
					</li>&#13;
				</ul>&#13;
&#13;
				<p>You should see that BCC automatically creates the attachment and the program works exactly the same.&#13;
					This is an example of the many convenient macros that BCC provides.</p>&#13;
			</li>&#13;
			<li>&#13;
				<p>You could further adapt <em>hello_map.py</em> so that the key in the hash table identifies a&#13;
					particular syscall (rather than a particular user). The output will show how many times that syscall&#13;
					has been called across the whole system.</p>&#13;
			</li>&#13;
		</ol>&#13;
	</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch02fn1"><sup><a href="ch02.html#ch02fn1-marker">1</a></sup> I originally wrote this for a talk titled “The Beginner’s Guide to&#13;
				eBPF Programming.” You can find the original code along with links to the slides and video at <a href="https://github.com/lizrice/ebpf-beginners"><em class="hyperlink">https://github.com/lizrice/ebpf-beginners</em></a>.</p><p data-type="footnote" id="ch02fn2"><sup><a href="ch02.html#ch02fn2-marker">2</a></sup> There is a more performant way to attach eBPF programs to functions,&#13;
				available from kernel version 5.5 onward, that uses fentry (and the corresponding fexit instead of&#13;
				kretprobe for the exit from a function). I’ll discuss this later in the book, but for now I’m using&#13;
				kprobe to keep the example in this chapter as simple as possible.</p><p data-type="footnote" id="ch02fn3"><sup><a href="ch02.html#ch02fn3-marker">3</a></sup> I quite often use VScode remote to connect to a virtual machine in the&#13;
				cloud. This runs lots of node scripts on the virtual machine, which generates lots of tracing from this&#13;
				“Hello World” app.</p><p data-type="footnote" id="ch02fn4"><sup><a href="ch02.html#ch02fn4-marker">4</a></sup> Some commands&#13;
				(<code>echo</code> is a common example) might be shell built-ins that run as part of the shell process,&#13;
				rather than executing a new program. These won’t trigger the <code>execve()</code> event, so no trace&#13;
				will be generated.</p><p data-type="footnote" id="ch02fn5"><sup><a href="ch02.html#ch02fn5-marker">5</a></sup> C++ does, but not C.</p><p data-type="footnote" id="ch02fn6"><sup><a href="ch02.html#ch02fn6-marker">6</a></sup> The lower 32 bits are the <em>thread group ID</em>. For&#13;
						a single-threaded process, this is the same as the process ID, but additional threads for the&#13;
						process would be given different IDs. The docs for the GNU C library have a good description of&#13;
						the difference between <a href="https://oreil.ly/Wo9k3">process and thread group IDs</a>.</p><p data-type="footnote" id="ch02fn7"><sup><a href="ch02.html#ch02fn7-marker">7</a></sup> This is just example&#13;
						code, so I’m not worrying about cleaning up on keyboard interrupt or any other niceties!</p><p data-type="footnote" id="ch02fn8"><sup><a href="ch02.html#ch02fn8-marker">8</a></sup> This principle is often&#13;
					called “DRY” (“Don’t Repeat Yourself”), as popularized by <a href="https://oreil.ly/QFich">The&#13;
						Pragmatic Programmer</a>.</p><p data-type="footnote" id="ch02fn9"><sup><a href="ch02.html#ch02fn9-marker">9</a></sup> There are some 300 syscalls in Linux, and since&#13;
						I’m not&#13;
						using any recently added syscalls for this example, this is good enough.</p><p data-type="footnote" id="ch02fn10"><sup><a href="ch02.html#ch02fn10-marker">10</a></sup> Making tail calls from a BPF subprogram requires support from the&#13;
					JIT compiler, which you’ll meet in the next chapter. In the kernel version I used to write the&#13;
					examples in this book, only the JIT compiler on x86 has this support, although <a href="https://oreil.ly/KYUYS">support has been added to ARM in kernel 6.0</a>.</p></div></div></section></body></html>