<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
      lang="en"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning Kali Linux, 2nd Edition</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Foundations of Kali Linux"><div class="chapter" id="foundations_of_kali_linux">
<h1><span class="label">Chapter 1. </span>Foundations of Kali Linux</h1>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id69">
<h1>A Note for Early Release Readers</h1>
<p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p>

<p>This will be the 1st chapter of the final book. Please note that the GitHub repo will be made active later on.</p>

<p>If you have comments about how we might improve the content and/or examples in this book, or if you notice missing material within this chapter, please reach out to the editor at <a href="mailto:rfernando@oreilly.com">rfernando@oreilly.com</a>.</p>
</div></aside>

<p>Kali Linux<a data-type="indexterm" data-primary="Kali Linux" data-secondary="basics of" id="KLfound01"></a> is a specialized distribution of the Linux operating system based on Ubuntu Linux, which in turn is based on Debian Linux. Kali is targeted at people who want to engage in security work. This may be security testing, it may be exploit development or reverse engineering, or it may be digital forensics. The thing about Linux distributions is that they aren’t the same. Linux is really just the kernel—​the actual operating system and the core of the distribution. Each distribution layers additional software on top of that core, making it unique. In the case of Kali, what gets layered on are not only the essential utilities, but also hundreds of software packages that are specific to security work.</p>

<p>One<a data-type="indexterm" data-primary="Linux" data-secondary="benefits of" id="id70"></a> of the really nice things about Linux, especially as compared to other operating systems, is that it is almost completely customizable. This includes selecting the shell you run programs from, which includes the terminal environment where you type commands as well as the graphical desktop you use. Even beyond that, you can change the look of each of those things once you have selected the environment. Using Linux allows you to make the system operate the way you want it to to benefit your working style, rather than having the system force the way you function because of how it works, looks, and feels.</p>

<p>Linux actually has a long history, if you trace it back to its beginnings. Understanding this history will help provide some context for why Linux is the way it is—​especially the seemingly arcane commands that are used to manage the system, manipulate files, and just get work done.</p>






<section data-type="sect1" data-pdf-bookmark="Heritage of Linux"><div class="sect1" id="id1">
<h1>Heritage of Linux</h1>

<p>Once<a data-type="indexterm" data-primary="Linux" data-secondary="heritage of" id="id71"></a><a data-type="indexterm" data-primary="Multics operating system" id="id72"></a> upon a time, back in the days of the dinosaur, there existed an operating system called Multics. The goal of <em>Multics</em> was to support multiple users and offer compartmentalization of processes and files on a per user basis. After all, this was an era when the computer hardware necessary to run operating systems like Multics ran into the millions of dollars. At a minimum, computer hardware was hundreds of thousands of dollars. As a point of comparison, a $7 million system then would cost about $62 million as of April 2023. Having a system that could support only a single user at a time was just not cost-effective—thus the development of Multics by MIT, Bell Labs, and GE was a way of making computers more cost-effective.</p>

<p>Inevitably, the project slowly fell apart, though the operating system was eventually released. One of the programmers assigned to the project from Bell Labs returned to his regular job and eventually decided to write his own version of an operating system in order to play a game he had originally written for Multics but wanted to play on a PDP-7 that was available at Bell Labs. The game was called Space Trave and the programmer, Ken Thompson<a data-type="indexterm" data-primary="Thompson, Ken" id="id73"></a>, needed a decent environment to redevelop the game for the PDP-7. In those days, systems were largely incompatible. They had entirely different hardware instructions (operation codes), and they sometimes had different memory word sizes, which we often refer to today as bus size. As a result, programs written for one environment, particularly if very low-level languages were used, would not work in another environment. The<a data-type="indexterm" data-primary="Unix/Unics" id="id74"></a> resulting environment was named Unics. Eventually, other Bell Labs programmers joined the project, and it was eventually renamed Unix.</p>

<p>Unix had a simple design. Because it was developed as a programming environment for a single user at a time, it ended up getting used, first within Bell Labs and then outside, by other programmers. One of the biggest advantages to Unix over other operating systems was that the kernel was rewritten in the C programming language in 1972. Using a higher-level language than assembly, which was more common then, made it portable across multiple hardware systems. Rather than being limited to the PDP-7, Unix could run on any system that had a C compiler in order to compile the source code needed to build Unix. This allowed for a standard operating system across numerous hardware platforms.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Assembly language, if you are not familiar, is as close as you can get to writing in something directly understood by the machine without resorting to binary. Assembly language is comprised of mnemonics, which are how humans can refer to the operations the processor understands. The mnemonic is usually a very short word that describes the operation. CMP, for example, is compare. MOV is move, where you move data from one location to another. Assembly language gives you complete control over how the program works since it’s translated directly to machine language — the binary values of processor operations and memory addresses.</p>
</div>

<p>In addition to having a simple design, Unix had the advantage of being distributed with the source code. This allowed researchers not only to read the source code in order to understand it better, but also to extend and improve the source. Assembly language, which was used previously, can be very challenging to read without a lot of time and experience. Higher level languages like C make reading the source code significantly easier. Unix has spawned many child operating systems that all behaved just as Unix did, with the same functionality. In some cases, these other operating system distributions started with the Unix source that was provided by AT&amp;T. In other cases, Unix was essentially reverse engineered based on documented functionality and was the starting point for two popular Unix-like operating systems: BSD and Linux.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As you will see later, one of the advantages of the Unix design—​using small, simple programs that do one thing, but allow you to feed the output of one into the input of another—​is the power that comes with chaining. One common use of this function is to get a process list by using one utility and feed the output into another utility that will then process that output, either searching specifically for one entry or manipulating the output to strip away some of it to make it easier to understand.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="About Linux"><div class="sect1" id="id2">
<h1>About Linux</h1>

<p>As<a data-type="indexterm" data-primary="Linux" data-secondary="basics of" id="Lbasic01"></a> Unix spread, the simplicity of its design and its focus on being a programming environment, though primarily the availability of source code led to it being taught in computer science programs around the world. A number of books about operating system design were written in the 1980s based on the design of Unix. While using the original source code would violate copyright, the extensive documentation and simplicity of design allowed clones to be developed. One of these implementations was written by Andrew Tannenbaum<a data-type="indexterm" data-primary="Tannenbaum, Andrew" id="id75"></a><a data-type="indexterm" data-primary="Operating Systems: Design and Implementation (Tannenbaum)" id="id76"></a><a data-type="indexterm" data-primary="Minix" id="id77"></a> for his book <em>Operating Systems: Design and Implementation</em> (Prentice Hall, 1987). This<a data-type="indexterm" data-primary="Torvalds, Linus" id="id78"></a> implementation, called <em>Minix</em>, was the basis for Linus Torvalds’ development of Linux. What Torvalds developed was the Linux kernel, which some consider the operating system. The kernel allows hardware to be managed, including the processor, which allows processes to be run through the central processing unit (CPU). It did not provide a facility for users to interact with the operating system, meaning execute programs.</p>

<p>The<a data-type="indexterm" data-primary="GNU Project" id="id79"></a> GNU Project, started<a data-type="indexterm" data-primary="Stallman, Richard" id="id80"></a> in the late 1970s by Richard Stallman, had a collection of programs that either were duplicates of the standard Unix utilities or were functionally the same with different names. The GNU Project wrote programs primarily in C, which meant they could be ported easily. As a result, Torvalds, and later other developers, bundled the GNU Project’s utilities with his kernel to create a complete distribution of software that anyone could develop and install to their computer system. The collection of GNU utilities is sometimes (or at least historically was) called userland. The userland utilities are how users interact with the system.</p>

<p>Linux<a data-type="indexterm" data-primary="Berkeley Systems Distribution (BSD)" id="id81"></a> inherited the majority of Unix design ideals, primarily because it was begun as something functionally identical to the standard Unix that had been developed by AT&amp;T and was reimplemented by a small group at the University of California at Berkeley as the Berkeley Systems Distribution (BSD). This meant that anyone familiar with how Unix or even BSD worked could start using Linux and be immediately productive. Over the decades since Torvalds first released Linux, many projects have started up to increase the functionality and user-friendliness of Linux. This includes several desktop environments, all of which sit on top of the X/Windows system, which was first developed by MIT (which, again, was involved in the development of Multics).</p>

<p>The<a data-type="indexterm" data-primary="git version-control system" id="id82"></a><a data-type="indexterm" data-primary="version-control systems" id="id83"></a> development of Linux itself, meaning the kernel, has changed the way developers work. As an example, Torvalds was dissatisfied with the capabilities of software repository systems that allowed concurrent developers to work on the same files at the same time. As a result, Torvalds led the development of <em>git</em>, a version-control system that has largely supplanted other version-control systems for open source development. If you want to grab the current version of source code from most open source projects these days, you will likely be offered access via git. Additionally, there are now public repositories for projects to store their code that support the use of git, a source code manager, to access the code. Even outside of open source projects, many if not most enterprises have moved their version control systems to git because of its modern, decentralized approach to managing source code.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id84">
<h1>Monolithic Versus Micro</h1>
<p>Linux<a data-type="indexterm" data-primary="monolithic kernel" id="id85"></a><a data-type="indexterm" data-primary="micro kernels" id="id86"></a> is considered a <em>monolithic</em> kernel. This is different from Minix, which Linux started from, and other Unix-like implementations that use <em>micro</em> kernels. The difference between a monolithic kernel and a micro kernel is that all functionality is built into a monolithic kernel. This includes any code necessary to support hardware devices. With a micro kernel, only the essential code is included in the kernel. This is roughly the bare minimum necessary to keep the operating system functional. Any additional functionality that is required to run in kernel space is implemented as a module and loaded into the kernel space as it is needed. This is not to say that Linux doesn’t have modules, but the kernel that is typically built and included in Linux distributions is not a micro kernel. Because Linux is not designed around the idea that only core services are implemented in the kernel proper, it is not considered a micro kernel but instead a monolithic kernel.</p>
</div></aside>

<p>Linux<a data-type="indexterm" data-primary="distributions (Linux)" id="id87"></a> is available, generally free of charge, in distributions. A Linux <em>distribution</em> is a collection of software packages that have been selected by the distribution maintainers. Also, the software packages have been built in a particular way, with features determined by the package maintainer. These software packages are acquired as source code, and many packages can have multiple options—​whether to include database support, which type of database, whether to enable encryption—​that have to be enabled when the package is being configured and built. The package maintainer for one distribution may make different choices for options than the package maintainer for another distribution.</p>

<p>Different<a data-type="indexterm" data-primary="package formats (Linux)" id="id88"></a><a data-type="indexterm" data-primary="RedHat Enterprise Linux (RHEL)" id="id89"></a><a data-type="indexterm" data-primary="Fedora Core" id="id90"></a><a data-type="indexterm" data-primary="RedHat Package Manager (RPM)" id="id91"></a><a data-type="indexterm" data-primary="Yellowdog Updater Modified (yum)" id="id92"></a><a data-type="indexterm" data-primary="Debian" id="id93"></a><a data-type="indexterm" data-primary="Advanced Package Tool (apt)" id="id94"></a> distributions will also have different package formats. As an example, RedHat and its associated distributions, like RedHat Enterprise Linux (RHEL) and Fedora Core, use the RedHat Package Manager (RPM) format. In addition, RedHat uses both the RPM utility as well as the Yellowdog Updater Modified (yum) to manage packages on the system. Other distributions may use the different package management utilities used by Debian. Debian uses the Advanced Package Tool (APT) to manage packages in the Debian package format. Regardless of the distribution or the package format, the object of the packages is to collect all the files necessary for the software to function and make those files easy to put into place to make the software functional. Since ultimately, Kali Linux inherits from Debian, by way of Ubuntu, Kali also uses APT for package management, both from the perspective of the package format it supports as well as the tools that are used to manage the packages.</p>

<p>Over<a data-type="indexterm" data-primary="desktop environments" data-secondary="per distribution" id="id95"></a><a data-type="indexterm" data-primary="GNU Object Model Environment (GNOME)" id="id96"></a><a data-type="indexterm" data-primary="K Desktop Environment (KDE)" id="id97"></a><a data-type="indexterm" data-primary="Xfce" id="id98"></a><a data-type="indexterm" data-primary="ElementaryOS" id="id99"></a> the years, another difference between distributions has come with the desktop environment that is provided by default by the distribution. In recent years, distributions have created their own custom views on existing desktop environments. Whether it’s the GNU Object Model Environment (GNOME), the K Desktop Environment (KDE), or Xfce, they can all be customized with different themes and wallpapers and organization of menus and panels. Distributions will often provide their own spin on a different desktop environment. Some distributions, like ElementaryOS, have even provided their own desktop environment, called Pantheon.</p>

<p>While<a data-type="indexterm" data-primary="package repositories" id="id100"></a> in the end the result of package managers is the same, sometimes the choice of package manager or even desktop environment can make a difference to users. Additionally, the depth of the package repository can make a difference to some users. They may want to ensure they have a lot of choices in software they can install through the repository rather than trying to build the software by hand and install it. Different distributions may have smaller repositories, even if they are based on the same package management utilities and formats as other distributions. Because of dependencies of software that need to be installed before the software you are looking for will work, packages are not always mix-and-match between even related distributions.</p>

<p>Sometimes, different<a data-type="indexterm" data-primary="Ubuntu Linux" id="id101"></a> distributions will focus on specific groups of users, rather than being general-purpose distributions for anyone who wants a desktop. Beyond that, distributions like Ubuntu will even have separate installation distributions per release, such as one for a server installation and one for a desktop installation. A desktop installation<a data-type="indexterm" data-primary="graphical user interfaces (GUIs)" id="id102"></a> generally includes a graphical user interface (GUI), whereas a server installation won’t, and as a result will install far fewer packages. The fewer packages, the less exposure to attack, and servers are often where sensitive information is stored in addition to being systems that may be more likely to be exposed to unauthorized users because they provide network services that aren’t commonly found on desktop systems.</p>

<p>Kali Linux is a distribution that is specifically tailored to a particular type of user—​those who are interested in information security and the range of capabilities that fall under that incredibly broad umbressa. Kali Linux, as a distribution focused on security functions, falls into the desktop category, and there is no intention to limit the number of packages that are installed to make Kali harder to attack. Someone focused on security testing will probably need a wide variety of software packages, and Kali loads their distribution out of the gate. This may seem mildly ironic, considering distributions that focus on keeping their systems safe from attack (sometimes mistakenly called <em>secure</em>) tend to limit the packages through a process called hardening. Kali, though, is focused on testing, rather than keeping the distribution safe from attack.<a data-type="indexterm" data-primary="" data-startref="Lbasic01" id="id103"></a></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Acquiring and Installing Kali Linux"><div class="sect1" id="id3">
<h1>Acquiring and Installing Kali Linux</h1>

<p>The<a data-type="indexterm" data-primary="Kali Linux" data-secondary="acquiring and installing" id="KLinstall01"></a><a data-type="indexterm" data-primary="installation" id="install01"></a><a data-type="indexterm" data-primary="downloading" id="down01"></a> easiest way to acquire Kali Linux is to visit its <a href="http://www.kali.org">website</a>. From there, you can gather additional information about the software, such as lists of packages that are installed. You will be downloading an ISO image that can be used as is if you are installing into a virtual machine (VM), or it can be burned to a DVD to install to a physical machine.</p>

<p>Kali<a data-type="indexterm" data-primary="Debian" id="id104"></a><a data-type="indexterm" data-primary="BackTrack Linux" id="id105"></a><a data-type="indexterm" data-primary="Knoppix Linux" id="id106"></a> Linux is based on Debian. This was not always the case. There was a time when Kali was named <em>BackTrack Linux</em>. BackTrack was based on Knoppix Linux, which is primarily a live distribution, meaning that it was designed to boot from CD, DVD, or USB stick and run from the source media rather than being installed to a destination hard drive. Knoppix, in turn, inherits from Debian.  BackTrack was, just as Kali Linux is, a distribution focused on penetration testing and digital forensics. The last version of BackTrack was released in 2012, before the Offensive Security team took the idea of BackTrack and rebuilt it to be based on Debian Linux. One of the features that Kali retains that was available in BackTrack is the ability to live boot. When you get boot media for Kali, you can choose to either install or boot live. In <a data-type="xref" href="#boot_screen_for_kali_linux">Figure 1-1</a>, you can see the boot options.</p>

<figure><div id="boot_screen_for_kali_linux" class="figure">
<img src="assets/lklx_0101.png" alt="Kali Linux Boot Screen" width="1272" height="952"/>
<h6><span class="label">Figure 1-1. </span>Boot screen for Kali Linux</h6>
</div></figure>

<p>Whether you run from the DVD or install to a hard drive is entirely up to you. If you boot to DVD and don’t have a home directory stored on some writable media, you won’t be able to maintain anything from one boot to another. If you don’t have writable media to store information to, you will be starting entirely from scratch every time you boot. There are advantages to this if you don’t want to leave any trace of what you did while the operating system was running. If you customize or want to maintain SSH keys or other stored credentials, you’ll need to install to local media.</p>

<p>Installation of Kali is straightforward. You don’t have the options that other distributions have. You won’t select package categories. Kali has a defined set of packages that gets installed. You can add more later or even take some away, but you start with a fairly comprehensive set of tools for security testing or forensics. What<a data-type="indexterm" data-primary="configuration" id="config01"></a> you need to configure is selecting a disk to install to and getting it partitioned and formatted. You also need to configure the network, including hostname and whether you are using a static address rather than DHCP. Once you have configured that and set your time zone as well as some other foundational configuration settings, the packages will get updated and you will be ready to boot to Linux.</p>








<section data-type="sect2" data-pdf-bookmark="Virtual Machines"><div class="sect2" id="id4">
<h2>Virtual Machines</h2>

<p>The approach described can work very nicely on a dedicated machine. Dedicated machines can be expensive. Even low cost machines cost something, then there is the space and power that is required for the machine to operate. In some cases, you may need cooling, depending on the hardware you have in place.</p>

<p>Fortunately, Kali<a data-type="indexterm" data-primary="virtual machines (VMs)" id="id107"></a> doesn’t require its own hardware. It runs nicely inside a VM. If you intend to play around with security testing, and most especially penetration testing, getting a virtual lab started isn’t a bad idea. I’ve found that Kali runs quite nicely in 4 GB of memory with about 20 GB of disk space. If you want to store a lot of artifacts from your testing, you may want additional disk space. You should be able to get by with 2 GB of memory, but obviously, the more memory you can spare, the better the performance will be.</p>

<p>There<a data-type="indexterm" data-primary="hypervisors" data-secondary="selecting" id="id108"></a><a data-type="indexterm" data-primary="VMware" id="id109"></a><a data-type="indexterm" data-primary="Parallels" id="id110"></a><a data-type="indexterm" data-primary="VirtualBox" id="id111"></a> are many hypervisors you can choose from, depending on your host operating system. VMware has hypervisors for both Mac and PC. Parallels will run on Macs. <a href="https://www.virtualbox.org/">VirtualBox</a>, on the other hand, will run on PCs, Macs, Linux systems, and even Solaris. VirtualBox has been around since 2007, but was acquired by Sun Microsystems in 2008. As Sun was acquired by Oracle, VirtualBox is currently maintained by Oracle. Regardless of who maintains it, VirtualBox is free to download and use. If you are just getting started in the world of VMs, this may be a place for you to start. Each works in a slightly different way in terms of how it interacts with users. Different keys to break out of the VM. Different levels of interaction with the operating system. Different support for guest operating systems, since the hypervisor has to provide the drivers for the guest. In the end, it comes down to how much you want to spend and which of them you feel comfortable using.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As a point of possible interest, or at least connection, one of the primary developers on BSD was<a data-type="indexterm" data-primary="Joy, Bill" id="id112"></a> Bill Joy, who was a graduate student at the University of California at Berkeley. Joy was responsible for the first implementation in Berkeley Unix of TCP/IP. He became a cofounder of Sun Microsystems in 1982 and while there wrote a paper about a better programming language than C++, which served as the inspiration for the creation of Java.</p>
</div>

<p>One<a data-type="indexterm" data-primary="hypervisors" data-secondary="tools provided by" id="id113"></a><a data-type="indexterm" data-primary="drivers" id="id114"></a><a data-type="indexterm" data-primary="VMware" id="id115"></a> consideration is the tools provided by the hypervisor. The tools are drivers that get installed into the kernel to better integrate with the host operating system. This may include print drivers, drivers to share the filesystem from the host into the guest, and better video support. VMware can use the VMware tools that are open source and available within the Kali Linux repository. You can also get the VirtualBox tools<a data-type="indexterm" data-primary="VirtualBox" id="id116"></a> from the Kali repository. Parallels, on<a data-type="indexterm" data-primary="Parallels" id="id117"></a> the other hand, provides its own tools. One advantage to using VMware is there are open-source drivers available in most if not all Linux distributions. I have had some issues in the past with installing Parallels Tools in some versions of Linux, though I generally like Parallels. If you don’t want to scale the display automatically in the Kali VM or share documents, you may not care about any of the VM tools.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Low Cost Computing"><div class="sect2" id="id5">
<h2>Low Cost Computing</h2>

<p>If you’d prefer not to do an install from scratch but are interested in using a VM, you can download either a VMware or VirtualBox image. Kali<a data-type="indexterm" data-primary="Raspberry Pi" data-secondary="Kali support for" id="id118"></a><a data-type="indexterm" data-primary="BeagleBone" id="id119"></a> provides support for not only virtual environments but also ARM-based devices like the Raspberry Pi and the BeagleBone. The advantage to using the VM images is that it gets you up and running faster. You don’t have to take the time to do the installation. Instead, you download the image, load it into your chosen hypervisor, and you’re up and running. If you choose to go the route of using a preconfigured VM, you can find the images at the <a href="https://www.kali.org/get-kali/#kali-virtual-machines"><em class="hyperlink">https://www.kali.org/get-kali/#kali-virtual-machines</em></a> on Kali’s site for downloading one of these custom images.</p>

<p>Another low-cost option for running Kali Linux is a Raspberry Pi. The Pi is a very low-cost and small-footprint computer. You can, though, download an image specific for the Pi. The Pi doesn’t use an Intel or AMD processor as you would see on most desktop systems. Instead, it<a data-type="indexterm" data-primary="Advanced RISC Machine (ARM)" id="id120"></a> uses an Advanced RISC Machine (ARM) processor. These processors use a smaller instruction set and take less power than the processors you would usually see in desktop computers. The Pi comes as just a very small board that fits in the palm of your hand. You can get multiple cases to insert the board into and then outfit it with any peripherals you may want, such as a keyboard, mouse, and monitor.</p>

<p>One<a data-type="indexterm" data-primary="Raspberry Pi" data-secondary="advantages of" id="id121"></a> of the advantages of the Pi is that it can be used in physical attacks, considering its small size. You can install Kali onto the Pi and leave it at a location you are testing but it does require power and some sort of network connection. The Pi has an Ethernet connection built in, but there are also USB ports for WiFi adapters. Once you have Kali in place, you can perform even local attacks remotely by accessing your Pi from inside the network. We’ll get into some of that later.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Windows Subsystem for Linux (WSL)"><div class="sect2" id="id6">
<h2>Windows Subsystem for Linux (WSL)</h2>

<p>Many people use Windows as their primary operating system and rightly so considering its utility for most desktop tasks. While virtual machines are one way of getting Linux on any system, Windows has a more direct way of installing Linux. In 2016, Windows released a feature called Windows Subsystem for Linux (WSL). This was a way of running Executable and Linkable Format (ELF) binaries that are the default executable format for Linux directly on Windows. There have been two versions of WSL. The first was a way of implementing Linux system calls directly in the Windows kernel. Since the hardware architecture is not in play, because both Windows and the Linux executables are based on the Intel processor architecture, the largest consideration is the way the Linux kernel manages hardware. This is done through system calls. The system calls in Windows are different from those in Linux. Implementing the system calls of Linux in Windows is a major step to allowing Linux executables to run nearly natively on Windows.</p>

<p>More recently, Microsoft changed the implementation. Desktop versions of Windows now include a lightweight hypervisor, which is an implementation of Hyper-V, previously available as a native hypervisor on Windows servers. WSL is now implemented using a Linux kernel running in a Hyper-V machine. The Linux applications make direct calls to the Linux kernel rather than calling into the Windows kernel. One reason for this is some of the Linux system calls ended up being difficult to implement in Windows. Implementing WSL in a virtualized environment provides isolation so Linux applications can’t impact Windows applications because they are executing in separate memory spaces.</p>

<p>Installing WSL is very easy. Using the command line, whether it’s PowerShell or the older Command Processor, you run <em>wsl --install</em>. You can see in <a data-type="xref" href="#wsl_installation">Figure 1-2</a> that Windows will install a version of the Ubuntu kernel by default. If you have an older version of WSL installed already, it can be converted to WSL2 using <em>wsl --upgrade</em>. Once the environment has been installed, you can launch it from the Windows menu. The default Ubuntu environment will be named Ubuntu in the menu.</p>

<figure><div id="wsl_installation" class="figure">
<img src="assets/wsl-installation.png" alt="Installing WSL in Windows PowerShell" width="647" height="185"/>
<h6><span class="label">Figure 1-2. </span>Installing WSL in PowerShell</h6>
</div></figure>

<p>We don’t want Ubuntu, though. We want Kali. You can find Kali in the Microsoft Store app. If you search for Kali, you will see it just as in <a data-type="xref" href="#marketplace_kali_linux">Figure 1-3</a>. Installing it doesn’t actually install the entire distribution, though. It installs the capability to run Kali Linux. Opening Kali Linux for the first time in Windows will install the image along with the user configuration you will be prompted for. You will get asked for a username and a password for that username. When you subsequently run Kali Linux, you will get automatically logged into a command line shell.</p>

<figure class="width-60"><div id="marketplace_kali_linux" class="figure">
<img src="assets/KaliLinuxMarketplace.png" alt="Kali Linux in Microsoft Store" width="368" height="626"/>
<h6><span class="label">Figure 1-3. </span>Kali Linux in Microsoft Store</h6>
</div></figure>

<p>The base image of Kali in WSL is very small. There isn’t much installed. One big advantage of using WSL2 is the ability to run graphical applications directly in Windows. This didn’t used to be the case. You could run command line programs in Windows but running graphical programs required another piece of software to host those graphical programs. Today, Windows includes the functionality to host those graphical programs. Because of that, you will probably want to install some metapackages to get some additional programs. To start with, you may want kali-linux-default. It will install hundreds of additional packages which will get you started. You won’t have a complete graphical desktop, but you can run graphical programs directly on Windows. You can see this in <a data-type="xref" href="#ettercap_in_windows">Figure 1-4</a> where Ettercap is running as a graphical program out of Linux on the Windows desktop.</p>

<figure class="width-60"><div id="ettercap_in_windows" class="figure">
<img src="assets/ettercaponwindows.png" alt="Ettercap Running on Windows Desktop" width="1367" height="1078"/>
<h6><span class="label">Figure 1-4. </span>Ettercap Running on Windows Desktop</h6>
</div></figure>

<p>With so many options to get yourself started, it should be easy to get an installation up quickly. Once you have the installation up and running, you’ll want to get familiar with the desktop environment, if you are using an option that has a desktop environment, so you can start to become productive.<a data-type="indexterm" data-primary="" data-startref="KLinstall01" id="id122"></a><a data-type="indexterm" data-primary="" data-startref="install01" id="id123"></a><a data-type="indexterm" data-primary="" data-startref="down01" id="id124"></a><a data-type="indexterm" data-primary="" data-startref="config01" id="id125"></a></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Desktops"><div class="sect1" id="id38">
<h1>Desktops</h1>

<p>You’re<a data-type="indexterm" data-primary="desktop environments" data-secondary="selecting" id="id126"></a> going to be spending a lot of time interacting with the desktop environment, so you may as well get something that you’ll feel comfortable with. Unlike proprietary operating systems like Windows and macOS, Linux has multiple desktop environments. Kali supports the popular ones from their repository without needing to add any additional repositories. If the desktop environment that is installed by default doesn’t suit you, replacing it is easy. Because you’ll likely be spending a lot of time in the environment, you really want to be not only comfortable but also productive. This means finding the right environment and toolsets for you.</p>








<section data-type="sect2" data-pdf-bookmark="Xfce Desktop"><div class="sect2" id="id7">
<h2>Xfce Desktop</h2>

<p>The <a data-type="indexterm" data-primary="desktop environments" data-secondary="Xfce" id="id127"></a><a data-type="indexterm" data-primary="Xfce" id="id128"></a> default desktop environment on Kali at this time in mid-2023 is Xfce. It is often a popular alternative desktop environment, though not often a default one. One of the reasons it has been popular is that it was designed to be fairly lightweight for a full desktop environment and, as a result, more responsive. Many hardcore Linux users I have known over the years have gravitated to Xfce as their preferred environment, if they needed a desktop environment. Again, the reason is that it has a simple design that is highly configurable. In <a data-type="xref" href="#xfce_desktop_showing_applications_menu">Figure 1-5</a>, you can see a basic setup of Xfce. The panel on the bottom of the desktop is entirely configurable. You can change where it’s located and how it behaves, and add or remove items as you see fit, based on how you prefer to work. This panel includes an applications menu that includes all the same folders/categories that are in the GNOME menu.</p>

<figure><div id="xfce_desktop_showing_applications_menu" class="figure">
<img src="assets/lklx_0105.png" alt="Xfce Desktop Showing Applications Menu" width="2068" height="1528"/>
<h6><span class="label">Figure 1-5. </span>Xfce desktop showing applications menu</h6>
</div></figure>

<p>While<a data-type="indexterm" data-primary="GNOME Toolkit (GTK)" id="id129"></a> Xfce is based on the GNOME Toolkit (GTK), it is not a fork of GNOME. It was developed on top of an older version of GTK. The intention was to create something that was simpler than the direction GNOME was going in. It was intended to be lighter weight and, as a result, have better performance. The feeling was that the desktop shouldn’t get in the way of the real work users want to do.</p>

<p>Just as with Windows, if that’s what you are mostly familiar with, you get an application menu with shortcuts to the programs that have been installed. Rather than being broken into groups by software vendor or program name, Kali presents the programs in groups based on functionality. The categories presented, and ones covered over the course of this book, are as follows:</p>

<ul>
<li>
<p>Information Gathering</p>
</li>
<li>
<p>Vulnerability Analysis</p>
</li>
<li>
<p>Web Application Analysis</p>
</li>
<li>
<p>Database Assessment</p>
</li>
<li>
<p>Password Attacks</p>
</li>
<li>
<p>Wireless Attacks</p>
</li>
<li>
<p>Reverse Engineering</p>
</li>
<li>
<p>Exploitation Tools</p>
</li>
<li>
<p>Sniffing &amp; Spoofing</p>
</li>
<li>
<p>Post Exploitation</p>
</li>
<li>
<p>Forensics</p>
</li>
<li>
<p>Reporting Tools</p>
</li>
<li>
<p>Social Engineering Tools</p>
</li>
<li>
<p>System Services</p>
</li>
</ul>

<p>Alongside the menu are a set of launchers, much like the quick launchers you can find in Windows on the menu bar. Xfce also sets up four virtual desktops by default. You can see those as numbered boxes on the menu bar. Each of these virtual desktops can be spaces where you can hold running applications. It’s a way of having separate places to keep your desktop less cluttered.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="GNOME Desktop"><div class="sect2" id="id8">
<h2>GNOME Desktop</h2>

<p>GNOME <a data-type="indexterm" data-primary="desktop environments" data-secondary="GNOME" id="DEgnome01"></a><a data-type="indexterm" data-primary="GNU Object Model Environment (GNOME)" id="GNU01"></a> has been a default desktop environment on a lot of different Linux distributions. It is available as an option on Kali Linux.  This desktop environment was part of the GNU (GNU’s Not Unix, which is referred to as a recursive acronym) Project. RedHat has been a primary corporate contributor and uses the GNOME desktop as its primary interface for the distributions it controls, as does Ubuntu and several other distributions. In <a data-type="xref" href="#gnome_desktop_for_kali_linux">Figure 1-6</a>, you can see the desktop environment with the main menu expanded.</p>

<figure><div id="gnome_desktop_for_kali_linux" class="figure">
<img src="assets/lklx_0102.png" alt="GNOME Desktop" width="2056" height="1524"/>
<h6><span class="label">Figure 1-6. </span>GNOME desktop for Kali Linux</h6>
</div></figure>

<p>The main menu is accessed from the Applications menu in the top bar. This is minimally configurable using the Tweaks program, mostly related to the clock and calendar. Additionally, there is a Places menu that will allow you to open a file explorer that shows contents from the locations in the places menu. For example, Home and Documents are two places. If you select either of them, you will get a file explorer open to your home directory or the Documents directory inside your home directory. On the left side of the top panel, you can open up the virtual desktop manager.</p>

<p>Along with the menu in the top panel, there is a dock along the bottom, much like macOS. The dock includes commonly used applications like the Terminal, Firefox, Metasploit, WireShark, Burp Suite, and Files.  Clicking one of the icons once launches the application. You can add launchers to this dock by dragging them out of the list of applications. This can be shown by clicking on the tile with nine squares on the right side of the dock. It brings up the applications installed on the system, shown in alphabetical order, as you can see in <a data-type="xref" href="#gnome_application_list">Figure 1-7</a>. The applications in the dock to start with also show up as favorites in the Applications menu accessible from the top panel. Where the Windows taskbar stretches the width of the screen, the dock in GNOME and macOS is only as wide as it needs to be to store the icons that have been set to persist there, plus the ones for running applications.<a data-type="indexterm" data-primary="" data-startref="DEgnome01" id="id130"></a><a data-type="indexterm" data-primary="" data-startref="GNU01" id="id131"></a></p>

<figure><div id="gnome_application_list" class="figure">
<img src="assets/lklx_0103.png" alt="GNOME Application List" width="2062" height="940"/>
<h6><span class="label">Figure 1-7. </span>GNOME application list</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The dock in macOS comes from the interface in the NeXTSTEP operating system, which was designed for the NeXT Computer. This is the computer Steve Jobs formed a company to design and build after he was forced out of Apple in the 1980s. Many of the elements of the NeXTSTEP user interface (UI) were incorporated into the macOS UI when Apple bought NeXT. Incidentally, NeXTSTEP was built over the top of a BSD operating system, which is why macOS has Unix under the hood if you open a terminal <span class="keep-together">window</span>.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Logging In Through the Desktop Manager"><div class="sect2" id="id9">
<h2>Logging In Through the Desktop Manager</h2>

<p>Although<a data-type="indexterm" data-primary="desktop environments" data-secondary="desktop manager" id="id132"></a> GNOME is the default desktop environment, others are available without much effort. If you have multiple desktop environments installed, you will be able to select one in the display manager when you log in. First, you need to enter your username so the system can identify the default environment you have configured. This may be the last one you logged into. <a data-type="xref" href="#desktop_selection_at_login">Figure 1-8</a> shows environments that I can select from on one of my Kali Linux systems.</p>

<figure class="width_set_50"><div id="desktop_selection_at_login" class="figure">
<img src="assets/lklx_0104.png" alt="Desktop Selection in LightDM" width="1692" height="1002"/>
<h6><span class="label">Figure 1-8. </span>Desktop selection at login</h6>
</div></figure>

<p>There<a data-type="indexterm" data-primary="display managers" id="id133"></a><a data-type="indexterm" data-primary="LightDM" id="id134"></a> have been numerous display managers over the years. Initially, the login screen was something the X window manager provided, but other display managers have been developed, expanding the capabilities. One of the advantages of LightDM is that it’s considered lightweight. This may be especially relevant if you are working on a system with fewer resources such as memory and processor.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Cinnamon and MATE"><div class="sect2" id="id10">
<h2>Cinnamon and MATE</h2>

<p>Two<a data-type="indexterm" data-primary="desktop environments" data-secondary="Cinnamon" id="id135"></a><a data-type="indexterm" data-primary="desktop environments" data-secondary="MATE" id="id136"></a><a data-type="indexterm" data-primary="Cinnamon desktop environment" id="id137"></a><a data-type="indexterm" data-primary="MATE desktop environment" id="id138"></a> other desktops, Cinnamon and MATE, owe their origins to GNOME as well. The Linux distribution, Linux Mint, wasn’t sure about GNOME 3 and its GNOME shell, the desktop interface that came with it. As a result, it developed <em>Cinnamon</em>, which was initially just a shell sitting on top of GNOME. With the second version of Cinnamon, it became a desktop environment in its own right. One of the advantages to Cinnamon is that it bears a strong resemblance to Windows in terms of where things are located and how you get around. You can see that there is a Menu button at the bottom left, much like the Windows button, as well as a clock and other system widgets at the right of the menu bar or panel. You can see the panel as well as the menu in <a data-type="xref" href="#cinnamon_desktop_with_menu">Figure 1-9</a>. Again, the menu is just like the one you see in GNOME and Xfce.</p>

<figure class="width-60"><div id="cinnamon_desktop_with_menu" class="figure">
<img src="assets/lklx_0106.png" alt="Cinnamon Desktop with Menu" width="1442" height="1602"/>
<h6><span class="label">Figure 1-9. </span>Cinnamon desktop with menu</h6>
</div></figure>

<p>As I’ve suggested, there were concerns about GNOME 3 and the change in the look and behavior of the desktop. Some might say this was an understatement, and the reversion of some distributions to other looks might be considered proof of that. This includes the latest implementation of GNOME in Kali Linux. Regardless, Cinnamon was one response to GNOME 3 by creating a shell that sat on top of the underlying GNOME 3 architecture. <em>MATE</em>, on the other hand, is an outright fork of GNOME 2. For anyone familiar with GNOME 2, MATE will seem familiar. It’s an implementation of the classic look of GNOME 2. You can see this running on Kali in <a data-type="xref" href="#mate_desktop_with_menu">Figure 1-10</a>. Again, the menu is shown so you can see that you will get the same easy access to applications in all of the environments. While Xfce, Cinnamon, GNOME and other desktop environments have evolved their look over time, MATE continues to look pretty much the same in its Kali implementation as it did when it was first released.</p>

<figure class="width-60"><div id="mate_desktop_with_menu" class="figure">
<img src="assets/lklx_0107.png" alt="MATE Desktop with Menu" width="674" height="1248"/>
<h6><span class="label">Figure 1-10. </span>MATE desktop with menu</h6>
</div></figure>

<p>The<a data-type="indexterm" data-primary="K Desktop Environment (KDE)" id="id139"></a><a data-type="indexterm" data-primary="desktop environments" data-secondary="K Desktop Environment (KDE)" id="id140"></a> choice of desktop environment is entirely personal. One desktop that I have left off here but that is still very much an option is the K Desktop Environment (KDE). There are two reasons for this. The first is that I have always found KDE to be fairly heavyweight, although this has evened out some with GNOME 3 and the many packages it brings along with it. KDE never felt as quick as GNOME and certainly Xfce. However, a lot of people like it. More particularly, one reason for omitting an image of it is that it looks like some versions of Windows and also some of the alternative Linux desktops. One of the objectives behind KDE always seemed to be to clone the look and feel of Windows so users coming from that platform would feel comfortable.</p>

<p>If<a data-type="indexterm" data-primary="desktop environments" data-secondary="selecting" id="id141"></a> you are serious about really getting started with Kali and working with it, you may want to spend some time playing with the different desktop environments. It’s important that you are comfortable and can get around the interface efficiently. If you have a desktop environment that gets in your way or is hard to navigate, you probably don’t have a good fit for you. You may try another one. It’s easy enough to install additional environments. When we get to package management a little later, you’ll learn how to install additional packages and, as a result, desktop environments. You may even discover some that aren’t included in this discussion.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Using the Command Line"><div class="sect1" id="id11">
<h1>Using the Command Line</h1>

<p>You<a data-type="indexterm" data-primary="command line" data-secondary="benefits of using" id="id142"></a><a data-type="indexterm" data-primary="full screens" id="id143"></a> will find over the course of this book that I have a great fondness for the command line. There are a lot of reasons for this. For one, I started in computing when terminals didn’t have what we call <em>full screens</em>. And we certainly didn’t have desktop environments. In complete honesty, my first access to a computer was on a teletype with no screen at all. What we had in cases where there was a screen was primarily command lines. As a result, I got used to typing. When I started on Unix systems, all I had was a command line so I needed to get used to the command set available there. The other reason for getting comfortable with the command line is that you can’t always get a UI. You may be working remotely and connecting over a network. This may get you only command-line programs without additional work. So, making friends with the command line is useful.</p>

<p>Another reason for getting used to the command line and the locations of program elements is that GUI programs may have failures or may leave out details that could be helpful. This may be especially true of some security or forensics tools. As one example, I much prefer to use<a data-type="indexterm" data-primary="TSK (The Sleuth Kit)" id="id144"></a><a data-type="indexterm" data-primary="Autopsy" id="id145"></a> The Sleuth Kit (TSK), a collection of command-line programs, over the web-based interface, Autopsy, which is more visual. Since Autopsy sits on top of TSK, it’s just a different way of looking at the information TSK is capable of generating. The difference is that with Autopsy, you don’t get all of the details, especially ones that are fairly low level. If you are just learning how to do things, understanding what is going on may be far more beneficial than learning a GUI. Your skills and knowledge will be far more transferable to other situations and tools. So, there’s that too.</p>

<p>A<a data-type="indexterm" data-primary="shells" id="id146"></a> UI is often called a <em>shell</em>. This is true whether you are referring to the program that manages the desktop or the program that takes commands that you type into a terminal window. The<a data-type="indexterm" data-primary="Bourne Again Shell (bash)" id="id147"></a> default shell in Linux has been the <em>Bourne Again Shell</em> (bash). This is a play on the Bourne Shell, which was an early and long-standing shell. However, the Bourne Shell had limitations and missing features. As a result, in 1989, the Bourne Again Shell was released. It has since become the common shell in Linux distributions. There<a data-type="indexterm" data-primary="command line" data-secondary="command types" id="id148"></a><a data-type="indexterm" data-primary="built-in commands" id="id149"></a> are two types of commands you will run on the command line. One is called a <em>built-in</em>. This is a function of the shell itself and it doesn’t call out to any other program—​the shell handles it. The other command you will run is a program that sits in a directory. The shell has a listing of directories where programs are kept that is provided (and configurable) through an environment variable.</p>

<p>Currently, the default shell in Kali Linux is the <em>Z shell</em> (zsh). This is a shell that is based on bash but includes many enhancements. For the most part, you won’t notice a lot of difference and certainly when it comes to running commands, there is no difference. zsh includes a lot of customization options, specifically when it comes to command line completion, as well as how the prompt is represented. The default prompt in Kali using zsh is shown in <a data-type="xref" href="#zsh_prompt">Figure 1-11</a>.</p>

<figure class="width-60"><div id="zsh_prompt" class="figure">
<img src="assets/kali_prompt.png" alt="zsh Prompt in Kali" width="904" height="468"/>
<h6><span class="label">Figure 1-11. </span>zsh prompt</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Keep in mind that Unix was developed by programmers for programmers. The point was to create an environment that was both comfortable and useful for the programmers using it. As a result, the shell is, as much as anything else, a programming language and environment. Each shell has different syntax for the control statements that it uses, but you can create a program right on the command line because, as a programming language, the shell will be able to execute all of the statements.</p>
</div>

<p>In short, we’re going to spend some time with the command line because it’s where Unix started and it’s also powerful. To start with, you’ll want to get around the filesystem and get listings of files, including details like permissions. Other commands that are useful are ones that manage processes and general utilities.</p>








<section data-type="sect2" data-pdf-bookmark="File and Directory Management"><div class="sect2" id="id12">
<h2>File and Directory Management</h2>

<p>To<a data-type="indexterm" data-primary="command line" data-secondary="file and directory management" id="CLfile01"></a><a data-type="indexterm" data-primary="file and directory management" data-secondary="pwd (print working directory) command" id="id150"></a><a data-type="indexterm" data-primary="pwd (print working directory) command" id="id151"></a><a data-type="indexterm" data-primary="print working directory (pwd) command" id="id152"></a><a data-type="indexterm" data-primary="working directory" id="id153"></a> start, let’s talk about getting the shell to tell you the directory you are currently in. This is called the <em>working directory</em>. To get the working directory, the one we are currently situated in from the perspective of the shell, we use the command <em>pwd</em>, which is shorthand for <em>print working directory</em>. In <a data-type="xref" href="#EX_1_1">Example 1-1</a>, you can see the prompt, which ends<a data-type="indexterm" data-primary="# (hash sign)" id="id154"></a><a data-type="indexterm" data-primary="hash sign (#)" id="id155"></a> in #, indicating that the effective user who is currently logged in is a superuser. The # ends the prompt, which is followed by the command that is being entered and run. This is followed on the next line by the results, or output, of the command.</p>
<div id="EX_1_1" data-type="example">
<h5><span class="label">Example 1-1. </span>Printing your working directory</h5>

<pre data-type="programlisting" data-code-language="bash">┌──<code class="o">(</code>kilroy@badmilo<code class="o">)</code>-<code class="o">[</code>~<code class="o">]</code><code class="w"></code>
└─$<code class="w"> </code><code class="nb">pwd</code><code class="w"></code>
/home/kilroy<code class="w"></code></pre></div>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When you get to the point where you have multiple machines, either physical or virtual, you may find it interesting to have a theme for the names of your different systems. I’ve known people who named their systems for <em>The Hitchhiker’s Guide to the Galaxy</em> characters, for instance. I’ve also seen coins, planets, and various other themes. For ages now, my systems have been named after <em>Bloom County</em> characters. The Kali system here is named for Rosebud the Basselope.</p>
</div>

<p>Once<a data-type="indexterm" data-primary="file and directory management" data-secondary="ls (listing files and directories) command" id="id156"></a><a data-type="indexterm" data-primary="root directory (/)" id="id157"></a><a data-type="indexterm" data-primary="/ (root directory)" id="id158"></a><a data-type="indexterm" data-primary="ls (listing files and directories) command" id="id159"></a><a data-type="indexterm" data-primary="file and directory management" data-secondary="ls-la (long listing of all files) command" id="id160"></a><a data-type="indexterm" data-primary="ls-la (long listing of all files) command" id="id161"></a> we know where in the filesystem we are, which always starts at the root directory (/) and when shown visually, looks like the roots of a tree, we can get a listing of the files and directories. You will find that with Unix/Linux commands, the minimum number of characters is often used. In the case of getting file listings, the command is <em>ls</em>. While <em>ls</em> is useful, it only lists the file and directory names. You<a data-type="indexterm" data-primary="permissions" data-secondary="listing file details" id="id162"></a> may want additional details about the files, including times and dates as well as permissions. You can see those results by using the command <em>ls -la</em>. The <em>l</em> (ell) specifies <em>long</em> listing, including details. The <em>a</em> specifies that <em>ls</em> should show <em>all</em> the files, including files that are otherwise hidden. You can see the output in <a data-type="xref" href="#EX_1_2">Example 1-2</a>.</p>
<div id="EX_1_2" data-type="example">
<h5><span class="label">Example 1-2. </span>Getting a long listing</h5>

<pre data-type="programlisting">┌──(kilroy@badmilo)-[~]
└─$ ls -la
total 192
drwx------ 19 kilroy kilroy  4096 Jun 17 18:54 .
drwxr-xr-x  3 root   root    4096 Jun  3 07:17 ..
-rw-r--r--  1 kilroy kilroy   220 Jun  3 07:17 .bash_logout
-rw-r--r--  1 kilroy kilroy  5551 Jun  3 07:17 .bashrc
-rw-r--r--  1 kilroy kilroy  3526 Jun  3 07:17 .bashrc.original
drwxr-xr-x  8 kilroy kilroy  4096 Jun  3 18:24 .cache
drwxr-xr-x 13 kilroy kilroy  4096 Jun 13 17:37 .config
drwxr-xr-x  2 kilroy kilroy  4096 Jun  3 07:26 Desktop
-rw-r--r--  1 kilroy kilroy    35 Jun  3 07:44 .dmrc
drwxr-xr-x  2 kilroy kilroy  4096 Jun  3 07:26 Documents
drwxr-xr-x  5 kilroy kilroy  4096 Jun 12 19:21 Downloads
-rw-r--r--  1 kilroy kilroy 11759 Jun  3 07:17 .face
lrwxrwxrwx  1 kilroy kilroy     5 Jun  3 07:17 .face.icon -&gt; .face
drwx------  3 kilroy kilroy  4096 Jun  3 07:26 .gnupg
-rw-------  1 kilroy kilroy     0 Jun  3 07:26 .ICEauthority
drwxr-xr-x  3 kilroy kilroy  4096 Jun 11 19:25 .ipython
drwxr-xr-x  4 kilroy kilroy  4096 Jun 11 12:04 .java
-rw-------  1 kilroy kilroy    34 Jun 17 18:53 .lesshst
drwxr-xr-x  4 kilroy kilroy  4096 Jun  3 07:26 .local
drwx------  4 kilroy kilroy  4096 Jun  3 18:24 .mozilla
drwxr-xr-x  2 kilroy kilroy  4096 Jun  3 07:26 Music
-rw-r--r--  1 kilroy kilroy    33 Jun 17 18:54 myhosts
drwxr-xr-x  2 kilroy kilroy  4096 Jun  3 07:26 Pictures
-rw-r--r--  1 kilroy kilroy   807 Jun  3 07:17 .profile
drwxr-xr-x  2 kilroy kilroy  4096 Jun  3 07:26 Public
-rw-r--r--  1 kilroy kilroy    37 Jun  3 18:28 pw.txt
-rw-r--r--  1 kilroy kilroy 28672 Jun 17 15:51 .scapy_history
-rw-r--r--  1 kilroy kilroy     0 Jun  3 07:26 .sudo_as_admin_successful
drwxr-xr-x  2 kilroy kilroy  4096 Jun  3 07:26 Templates
drwxr-xr-x  2 kilroy kilroy  4096 Jun  3 07:26 Videos
-rw-------  1 kilroy kilroy   948 Jun 17 18:54 .viminfo
drwxr-xr-x  3 kilroy kilroy  4096 Jun 11 12:02 .wpscan
-rw-------  1 kilroy kilroy    52 Jun 13 17:23 .Xauthority
-rw-------  1 kilroy kilroy  5960 Jun 17 18:36 .xsession-errors
-rw-------  1 kilroy kilroy  5385 Jun 12 19:23 .xsession-errors.old
drwxr-xr-x 20 kilroy kilroy  4096 Jun 11 13:55 .ZAP
-rw-------  1 kilroy kilroy  2716 Jun 14 18:47 .zsh_history
-rw-r--r--  1 kilroy kilroy 10868 Jun  3 07:17 .zshrc</pre></div>

<p>Starting<a data-type="indexterm" data-primary="permissions" data-secondary="owner, group, and world" id="id163"></a><a data-type="indexterm" data-primary="file and directory management" data-secondary="executable files" id="id164"></a> in the left column, you can see the permissions. Unix has a simple set of permissions. Each file or directory has a set of permissions that are associated with the user owner, then a set of permissions associated with the group that owns the file, and finally a set of permissions that belong to everyone else, referred to as the <em>world</em>. Directories are indicated with a <em>d</em> in the very first position. The other permissions available are read, write, and execute. On Unix-like operating systems, a program gets the execute bit set to determine whether it’s executable. This is different from Windows, where a file extension may make that determination. The executable bit determines not only whether a file is executable, but also who can execute it, depending on which category the execute bit is set in (user, group, world).</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id165">
<h1>Linux Filesystem Structure</h1>
<p>The Linux<a data-type="indexterm" data-primary="Linux" data-secondary="filesystem structure" id="id166"></a><a data-type="indexterm" data-primary="file and directory management" data-secondary="Linux filesystem structure" id="id167"></a> filesystem, just as the Unix filesystem before it, has a common layout. No matter how many disks you have installed in your system, everything will fall under / (the root folder). The common directories you will see in a Linux system are as follows:</p>
<dl>
<dt>/bin</dt>
<dd>
<p>Commands/binary files that have to be available when the system is booted in single-user mode.</p>
</dd>
<dt>/boot</dt>
<dd>
<p>Boot files are stored here, including the configuration of the boot loader, the kernel, and any initial ramdisk files needed to boot the kernel.</p>
</dd>
<dt>/dev</dt>
<dd>
<p>A pseudofilesystem that contains entries for hardware devices for programs to access.</p>
</dd>
<dt>/etc</dt>
<dd>
<p>Configuration files related to the operating system and system services.</p>
</dd>
<dt>/home</dt>
<dd>
<p>The directory containing the user’s home directories.</p>
</dd>
<dt>/lib</dt>
<dd>
<p>Library files that contain shared code and functions that any program can use.</p>
</dd>
<dt>/opt</dt>
<dd>
<p>Optional, third-party software is loaded here.</p>
</dd>
<dt>/proc</dt>
<dd>
<p>A pseudofilesystem that has directories containing files related to running processes, including memory maps, the command line used to run the program, and other essential system information related to the program.</p>
</dd>
<dt>/root</dt>
<dd>
<p>The home directory of the root user.</p>
</dd>
<dt>/sbin</dt>
<dd>
<p>System binaries that also need to be available in single-user mode.</p>
</dd>
<dt>/tmp</dt>
<dd>
<p>Temporary files are stored here.</p>
</dd>
<dt>/usr</dt>
<dd>
<p>Read-only user data (includes bin, doc, lib, sbin, and share subdirectories).</p>
</dd>
<dt>/var</dt>
<dd>
<p>Variable data including state information about running processes, log files, runtime data, and other temporary files. All of these files are expected to change in size or existence during the running of the system.</p>
</dd>
</dl>
</div></aside>

<p>You can also see the owner (user) and group, both of which are root in these cases. This is followed by the file size, the last time the file or directory was modified, and then the name of the file or directory. You may notice at the top that there are files that start with a dot, or period. The dot files and directories store user-specific settings and logs. Because they are managed by the applications that create them, as a general rule, they are hidden from regular directory listings.</p>

<p>The<a data-type="indexterm" data-primary="touch program" id="id168"></a> program <em>touch</em> can be used to update the modified date and time to the moment that touch is run. If the file doesn’t exist, touch will create an empty file that has the modified and created timestamp set to the moment touch was executed.</p>

<p>Other file- and directory-related commands that will be really useful are ones related to setting permissions and owners. Every file and directory gets a set of permissions, as indicated previously, as well as having an owner and a group. To<a data-type="indexterm" data-primary="permissions" data-secondary="setting" id="id169"></a><a data-type="indexterm" data-primary="file and directory management" data-secondary="chmod (set permissions) command" id="id170"></a><a data-type="indexterm" data-primary="chmod (set permissions) command" id="id171"></a> set permissions on a file or directory, you use the <em>chmod</em> command, which can take a numerical value for each of the possible permissions. Three bits are used, each either on or off for whether the permission is set or not. You can think about the order of permissions as being the least privilege to the most privilege, read, write, execute. However, since the most significant bit is first, read has the highest value out of the three bits used. The most significant bit has a value of 2<sup>2</sup>, or 4. Write has the value of 2<sup>1</sup>, or 2. Finally, execute has the value of 2<sup>0</sup>, or 1. As an example, if you want to set both read and write permissions on a file, you would use 4 + 2, or 6. The bit pattern would be 110, if it’s easier to see it that way.</p>

<p>There<a data-type="indexterm" data-primary="permissions" data-secondary="specifying individual" id="id172"></a> are three sets of permissions: owner, group, and world (everyone). When you are setting permissions, you specify a numeric value for each, meaning you have a three-digit value. As an example, in order to set read, write, and execute for the owner but just read for the group and everyone, you use <em>chmod 744 filename</em>, where <em>filename</em> is the name of the file you are setting permissions for. You could also just specify the bit you want either set or unset, if that’s easier. For example, you could use <em>chmod u+x filename</em> to add the executable bit for the owner.</p>

<p>The Linux filesystem is generally well-structured, so you can be sure of where to look for files. However, in some cases, you may need to search for files. On Windows or macOS, you may understand how to look for files, as the necessary tools are embedded in the file managers. If<a data-type="indexterm" data-primary="file and directory management" data-secondary="locate command" id="id173"></a><a data-type="indexterm" data-primary="locate command" id="id174"></a> you are working from the command line, you need to know the means you can use to locate files. The first is <em>locate</em>, which relies on a system database. The<a data-type="indexterm" data-primary="updatedb program" id="id175"></a><a data-type="indexterm" data-primary="file and directory management" data-secondary="updatedb program" id="id176"></a> program <em>updatedb</em> will update that database, and when you use <em>locate</em>, the system will query the database to find the location of the file.</p>

<p>If<a data-type="indexterm" data-primary="file and directory management" data-secondary="finding programs" id="id177"></a><a data-type="indexterm" data-primary="which program" id="id178"></a><a data-type="indexterm" data-primary="programs, locating" id="id179"></a><a data-type="indexterm" data-primary="searching and filtering" id="id180"></a><a data-type="indexterm" data-primary="filtering and searching" id="id181"></a> you are looking for a program, you can use another utility. The program <em>which</em> will tell you where the program is located. This may be useful if you have various locations where executables are kept. The thing to note here is that <em>which</em> uses the PATH variable in the user’s environment to search for the program. If the executable is found in the PATH, the full path to the executable is displayed.</p>

<p>A<a data-type="indexterm" data-primary="find program" id="id182"></a> more multipurpose program for location is <em>find</em>. While <em>find</em> has a lot of capabilities, a simple approach is to use something like <em>find / -name foo -print</em>. You don’t have to provide the <em>-print</em> parameter, since printing the results is the default behavior; it’s just how I learned how to run the command and it’s stayed with me. Using <em>find</em>, you specify the path to search in. <em>find</em> performs a recursive search, meaning it starts at the directory specified and searches all directories under the specified directory. In<a data-type="indexterm" data-primary="regular expressions" id="id183"></a> the preceding example, we are looking for the file named <em>foo</em>. You can use regular expressions, including wildcards, in your search. If you want to find a file that begins with the letters <em>foo</em>, you use <em>find / -name “foo*” -print</em>. In <a data-type="xref" href="#EX_1_3">Example 1-3</a>, you can see the use of find to locate a file in the /etc directory. You will see errors indicating permission denied. This results from searching through directories that are owned by another user and don’t have read permissions set for other users. If you are using search patterns, you need to put the string and pattern inside double quotes. While <em>find</em> has a lot of capabilities, this will get you started.<a data-type="indexterm" data-primary="" data-startref="CLfile01" id="id184"></a></p>
<div id="EX_1_3" data-type="example">
<h5><span class="label">Example 1-3. </span>Using find</h5>

<pre data-type="programlisting">┌──(kilroy@badmilo)-[/etc]
└─$ find . -name catalog.xml
find: ‘./redis’: Permission denied
find: ‘./ipsec.d/private’: Permission denied
find: ‘./openvas/gnupg’: Permission denied
find: ‘./ssl/private’: Permission denied
find: ‘./polkit-1/localauthority’: Permission denied
find: ‘./polkit-1/rules.d’: Permission denied
./vmware-tools/vgauth/schemas/catalog.xml
find: ‘./vpnc’: Permission denied</pre></div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Process Management"><div class="sect2" id="id13">
<h2>Process Management</h2>

<p>When<a data-type="indexterm" data-primary="command line" data-secondary="process management" id="CLprocess01"></a><a data-type="indexterm" data-primary="process management" data-secondary="process basics" id="id185"></a> you run a program, you initiate a process. You can think of a <em>process</em> as a dynamic, running instance of a program, which is static as it sits on a storage medium. Every running Linux system has dozens or hundreds of processes running at any given time. In most cases, you can expect the operating system to manage the processes in the best way. However, at times you may want to get yourself involved. As an example, you may want to check whether a process is running, since not all processes are running in the foreground. A <em>foreground process</em> is<a data-type="indexterm" data-primary="foreground processes" id="id186"></a><a data-type="indexterm" data-primary="process management" data-secondary="foreground and background processes" id="id187"></a> one that currently has the potential for the user to see and interact with, as compared<a data-type="indexterm" data-primary="background processes" id="id188"></a> with a <em>background process</em>, which a user wouldn’t be able to interact with unless it was brought to the foreground and designed for user interaction. For example, just checking the number of processes running on an otherwise idle Kali Linux system, I discovered 141 processes. Out of that 141, only one was in the foreground. All others were services of some sort.</p>

<p>To<a data-type="indexterm" data-primary="process management" data-secondary="ps (list processes) command" id="PMlist01"></a><a data-type="indexterm" data-primary="ps (list processes) command" id="pslistcom01"></a> get a list of processes, you can use the <em>ps</em> command. The command all by itself doesn’t get you much more than the list of processes that belong to the user running the program. Every process, just like files, has an owner and a group. The reason is that processes need to interact with the filesystem and other objects, and having an owner and a group is the way the operating system determines whether the process should be allowed access. In <a data-type="xref" href="#EX_1_4">Example 1-4</a>, you can see what just running <em>ps</em> looks like.</p>
<div id="EX_1_4" data-type="example">
<h5><span class="label">Example 1-4. </span>Getting a process list</h5>

<pre data-type="programlisting">┌──(kilroy@badmilo)-[~]
└─$  ps
  PID TTY          TIME CMD
 4068 pts/1    00:00:00 bash
 4091 pts/1    00:00:00 ps
 &lt;/pre&gt;</pre></div>

<p>What<a data-type="indexterm" data-primary="process management" data-secondary="PIDs (process IDs)" id="id189"></a><a data-type="indexterm" data-primary="PIDs (process IDs)" id="id190"></a> you see in <a data-type="xref" href="#EX_1_4">Example 1-4</a> is the identification number of the process, commonly known as the <em>process ID</em>, or <em>PID</em>, followed by the teletypewriter port the command was issued on, the amount of time spent in the processor, and finally the command. Most of the commands you will see have parameters you can append to the command line, and these will change the behavior of the program.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id191">
<h1>Manual Pages</h1>
<p>Historically, the Unix manual<a data-type="indexterm" data-primary="command line" data-secondary="manual pages" id="id192"></a><a data-type="indexterm" data-primary="manual pages" id="id193"></a><a data-type="indexterm" data-primary="Unix/Unics" id="id194"></a><a data-type="indexterm" data-primary="man program" id="id195"></a> has been available online, meaning directly on the machine. To get the documentation for any command, you would run the program <em>man</em> followed by the command you wanted the documentation for. These<a data-type="indexterm" data-primary="troff typesetting language" id="id196"></a> manual, or man, pages have been formatted in a typesetting language called <em>troff</em>. As a result, when you are reading the man page, it looks like it was formatted to be printed, which is essentially true. If you need help finding the relevant command-line parameters to get the behavior you are looking for, you can use the man page to get the details. The man pages will also provide you with associated commands and information.</p>

<p>The Unix manual was divided into sections, as follows:</p>

<ul>
<li>
<p>General Commands</p>
</li>
<li>
<p>System Calls</p>
</li>
<li>
<p>Library Functions</p>
</li>
<li>
<p>Special Files</p>
</li>
<li>
<p>File Formats</p>
</li>
<li>
<p>Games and Screensavers</p>
</li>
<li>
<p>Miscellanea</p>
</li>
<li>
<p>System Administration Commands and Daemons</p>
</li>
</ul>

<p>When the same keyword applies in several areas, such as <em>open</em>, you just specify which section you want. If you want the system call open, you use the command <em>man 2 open</em>. If you also need to know relevant commands, you can use the command <em>apropos</em>, as in <em>apropos open</em>. You will get a list of all the relevant manual entries.</p>
</div></aside>

<p>Interestingly, AT&amp;T Unix diverged a bit from BSD Unix. This has resulted in some command-line parameter variations, depending on which Unix derivation you may have begun with. For more detailed process listings, including all of the processes belonging to all users (since without specifying, you get only processes belonging to your user), you<a data-type="indexterm" data-primary="process management" data-secondary="ps -ea (detailed processes listing) command" id="id197"></a><a data-type="indexterm" data-primary="process management" data-secondary="ps aux (detailed processes listing) command" id="id198"></a><a data-type="indexterm" data-primary="ps -ea (detailed processes listing) command" id="id199"></a><a data-type="indexterm" data-primary="ps aux (detailed processes listing) command" id="id200"></a> might use either <em>ps -ea</em> or <em>ps aux</em>. Either will provide the complete list, though there will be differences in the details provided.</p>

<p>The<a data-type="indexterm" data-primary="process management" data-secondary="top (refresh) command" id="id201"></a><a data-type="indexterm" data-primary="top (refresh) command" id="id202"></a> thing about using <em>ps</em> is that it’s static: you run it once and get the list of processes. Another program can be used to watch the process list change in near-real time. While it’s possible to also get statistics<a data-type="indexterm" data-primary="memory usage, listing" id="id203"></a><a data-type="indexterm" data-primary="processor usage, listing" id="id204"></a> like memory and processor usage from <em>ps</em>, with <em>top</em>, you don’t have to ask for it. Running <em>top</em> will give you the list of processes, refreshed at regular intervals. You can see sample output in <a data-type="xref" href="#EX_1_5t">Example 1-5</a>.</p>
<div id="EX_1_5t" data-type="example">
<h5><span class="label">Example 1-5. </span>Using top for process listings</h5>

<pre data-type="programlisting">top - 21:54:53 up 63 days,  3:20,  1 user,  load average: 0.00, 0.00, 0.00
Tasks: 253 total,   1 running, 252 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  64033.1 total,   2912.2 free,   1269.2 used,  59851.7 buff/cache
MiB Swap:   8192.0 total,   8180.7 free,     11.2 used.  62114.3 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
 346409 plex      20   0  825004 640152  45780 S   0.3   1.0  94:56.45 Plex Me+
 347400 plex      20   0   55028  34432  11248 S   0.3   0.1  10:27.28 Plex Sc+
 419627 kilroy    20   0    7736   3864   3004 R   0.3   0.0   0:00.02 top
      1 root      20   0  167732  12648   7668 S   0.0   0.0   1:08.01 systemd
      2 root      20   0       0      0      0 S   0.0   0.0   0:00.47 kthreadd
      3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp
      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par+
      5 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 slub_fl+</pre></div>

<p>In<a data-type="indexterm" data-primary="resources, listing programs consuming" id="id205"></a> addition to providing a list of processes, the amount of memory they are using, the percentage of CPU being used, as well as other specifics, <em>top</em> shows details about the running system, which you will see at the top. Each time the display refreshes, the process list will rearrange, indicating which processes are consuming the most resources at the top. As you will note, <em>top</em> itself consumes some amount of resources, and you will often see it near the top of the process list. One of the important fields that you will see not only in <em>top</em> but also in <em>ps</em> is the PID. In addition to providing a way of clearly identifying one process from another, particularly when the name of the process is the same, it also provides a way of sending messages to the process.</p>

<p>You<a data-type="indexterm" data-primary="process management" data-secondary="interprocess communication (IPC)" id="id206"></a><a data-type="indexterm" data-primary="IPC (interprocess communication)" id="id207"></a><a data-type="indexterm" data-primary="process management" data-secondary="kill command" id="id208"></a><a data-type="indexterm" data-primary="kill command" id="id209"></a><a data-type="indexterm" data-primary="interprocess communication (IPC)" id="id210"></a> will find two commands invaluable when you are managing processes. They are closely related, performing the same function, though offering slightly different capabilities. The first command is <em>kill</em>, which, perhaps unsurprisingly, can kill a running process. More specifically, it sends a signal to the process. The operating system will interact with processes by sending signals to them. Signals are one means of interprocess communication (IPC). The default signal for <em>kill</em> is the<a data-type="indexterm" data-primary="TERM signal (SIGTERM)" id="id211"></a><a data-type="indexterm" data-primary="process management" data-secondary="TERM signal (SIGTERM)" id="id212"></a> TERM signal (SIGTERM), which means <em>terminate</em>, but if you specify a different signal, <em>kill</em> will send that signal instead. To send a different signal, you issue <em>kill -# pid</em>, where # indicates the number that equates to the signal you intend to send, and <em>pid</em> is the process identification number that you can find from using either <em>ps</em> or <em>top</em>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id213">
<h1>Signals</h1>
<p>The signals<a data-type="indexterm" data-primary="signals" id="id214"></a><a data-type="indexterm" data-primary="process management" data-secondary="signals" id="id215"></a> for a system are provided in a C header file. The easiest way to get a listing of all the signals with their numeric value as well as the mnemonic identifier for the signal is to run <em>kill -l</em>, as you can see here:</p>

<pre data-type="programlisting">┌──(kilroy@badmilo)-[~]
└─$  sudo kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12
47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14
51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10
55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6
59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX</pre>

<p>While there are a lot of signals defined you, as a user, will only use a small number of them. Commonly, when it comes to managing processes, the SIGTERM signal is most useful. That’s the signal that <em>kill</em> and <em>killall</em> issue by default. When SIGTERM isn’t adequate to get the process to stop, you might need to issue a stronger signal. When SIGTERM is sent, it’s up to the process to handle the signal and exit. If the process is hung up, it may need additional help. SIGKILL (signal number 9) will forcefully terminate the process without relying on the process itself to deal with it.</p>
</div></aside>

<p>The<a data-type="indexterm" data-primary="killall program" id="id216"></a><a data-type="indexterm" data-primary="process management" data-secondary="killall program" id="id217"></a> second program that you should become acquainted with is <em>killall</em>. The difference between <em>kill</em> and <em>killall</em> is that with <em>killall</em> you don’t necessarily need the PID. Instead, you use the name of the process. This can be useful, especially when a parent may have spawned several child processes. If you want to kill all of them at the same time, you can use <em>killall</em>, and it will do the work of looking up the PIDs from the process table and issuing the appropriate signal to the process. Just as in the case of <em>kill</em>, <em>killall</em> will take a signal number to send to the process. If you need to forcefully kill all instances of the process named <em>firefox</em>, for instance, you would use <em>killall -9 firefox</em>.<a data-type="indexterm" data-primary="" data-startref="CLprocess01" id="id218"></a></p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Other Utilities"><div class="sect2" id="id14">
<h2>Other Utilities</h2>

<p>Obviously, we<a data-type="indexterm" data-primary="command line" data-secondary="input and output utilities" id="id219"></a><a data-type="indexterm" data-primary="input/output streams" id="id220"></a><a data-type="indexterm" data-primary="STDIN, STDOUT, and STDERR" id="id221"></a> aren’t going to go over the entire list of commands available on the Linux command line. However, some additional ones are useful to get your head around. Keep in mind that Unix was designed to have simple utilities that could be chained together. It does this by having three standard input/output streams: STDIN, STDOUT, and STDERR. Each process inherits these three streams when it starts. Input comes in using STDIN, output goes to STDOUT, and errors are sent to STDERR, though perhaps that all goes without saying. The advantage to this is if you don’t want to see errors, for example, you can send the STDERR stream somewhere so you don’t have your normal output cluttered.</p>

<p>Each<a data-type="indexterm" data-primary="&gt; operator" id="id222"></a> of these streams can be redirected. Normally, STDOUT and STDERR go to the same place (typically, the console). STDIN originates from the console. If you want your output to go somewhere else, you can use the <em>&gt;</em> operator. If, for instance, I wanted to send the output of <em>ps</em> to a file, I might use <em>ps auxw &gt; ps.out</em>. This sends the output of the <em>ps</em> command to the file named ps.out. When you redirect the output, you don’t see it on the console anymore. In this example, if there were an error, you would see that, but not anything going to STDOUT. If you wanted to redirect input, you would go the other way. Rather<a data-type="indexterm" data-primary="&lt; operator" id="id223"></a> than <em>&gt;</em>, you would use <em>&lt;</em>, indicating the direction you want the information to flow.</p>

<p>Understanding<a data-type="indexterm" data-primary="command line" data-secondary="| (pipe) operator" id="id224"></a><a data-type="indexterm" data-primary="| (pipe) operator" id="id225"></a><a data-type="indexterm" data-primary="pipe (|) operator" id="id226"></a> the different I/O streams and redirection will help you down the path of understanding the <em>|</em> (pipe) operator. When you use <em>|</em>, you are saying, “Take the output from what’s on the left side and send it to the input for what’s on the right side.” You are effectively putting a coupler in place between two applications, sending STDOUT to STDIN, without having to go through any intermediary devices.</p>

<p>One<a data-type="indexterm" data-primary="command chaining" id="id227"></a><a data-type="indexterm" data-primary="grep program" id="id228"></a><a data-type="indexterm" data-primary="searching and filtering" id="id229"></a><a data-type="indexterm" data-primary="filtering and searching" id="id230"></a> of the most useful uses of command chaining or piping is for searching or filtering. As an example, if you have a long list of processes from the <em>ps</em> command, you might use the pipe operator to send the output of <em>ps</em> to another program, <em>grep</em>, which can be used to search for strings. As an example, if you want to find all the instances of the program named <em>httpd</em>, you use <em>ps auxw | grep httpd</em>. <em>grep</em> is used to search an input stream for a search string. While it’s useful for filtering information, you can also search the contents of files with <em>grep</em>. As an example, if you want to search for the string <em>wubble</em> in all the files in a directory, you can use <em>grep wubble *</em>. If you want to make sure that the search follows all the directories, you tell <em>grep</em> to use a recursive search with <em>grep -R wubble *</em>.<a data-type="indexterm" data-primary="" data-startref="PMlist01" id="id231"></a><a data-type="indexterm" data-primary="" data-startref="pslistcom01" id="id232"></a></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="User Management"><div class="sect1" id="id15">
<h1>User Management</h1>

<p>Where<a data-type="indexterm" data-primary="user management" id="id233"></a><a data-type="indexterm" data-primary="root users" id="id234"></a><a data-type="indexterm" data-primary="superuser (root) permissions" id="id235"></a><a data-type="indexterm" data-primary="permissions" data-secondary="superuser (root) permissions" id="id236"></a> Kali used to have you login as root by default, that hasn’t been true in several versions. You will be asked, just like other Linux distributions, to create the user you will be using. This user is granted the ability to gain superuser permissions temporarily using the <em>sudo</em> utility. Your user will be added to the <em>sudo</em> group. This is necessary because much of what you will be doing in Kali will require administrative privileges.</p>

<p>You may want to add additional users in Kali<a data-type="indexterm" data-primary="useradd command" id="id237"></a><a data-type="indexterm" data-primary="adduser command" id="id238"></a> as well as manage users in Kali, just as it is with other distributions. If you want to create a user, you can just use the <em>useradd</em> command. You might also use <em>adduser</em>. Both accomplish the same goal. When you are creating users, it’s useful to understand some of the characteristics of users. Each user should have a home directory, a shell, a username, and a group at a minimum. If I want to add my common username, for instance, I would use <em>useradd -d /home/kilroy -s /bin/bash -g users -m kilroy</em>. The parameters given specify the home directory, the shell the user should execute when logging in interactively, and the default group. The <em>-m</em> specified indicates that <em>useradd</em> should create the home directory. This will also populate the home directory with the skeleton files needed for interactive logins.</p>

<p>In<a data-type="indexterm" data-primary="groupadd command" id="id239"></a> the case of the group ID specified, <em>useradd</em> requires that the group exist. If you want your user to have its own group, you can use <em>groupadd</em> to create a new group and then use <em>useradd</em> to create the user that belongs to the new group. If you want to add your user to multiple groups, you can edit the <em>/etc/group</em> file and add your user to the end of each group line you want your user to be a member of. To pick up any permissions associated with those groups’ access to files, for example, you need to log out and log back in again. That will pick up the changes to your user, including the new groups.</p>

<p>Once<a data-type="indexterm" data-primary="passwd program" id="id240"></a> you have created the user, you should set a password. That’s done using the <em>passwd</em> command. If you are root and want to change another user’s password, you use <em>passwd kilroy</em> in the case of the user created in the preceding example. If you just use <em>passwd</em> without a username, you are going to change your own password.</p>
<div data-type="tip"><h1>Shells</h1>
<p>The<a data-type="indexterm" data-primary="Bourne Again Shell (bash)" id="id241"></a><a data-type="indexterm" data-primary="shells" id="id242"></a><a data-type="indexterm" data-primary="zsh shell" id="id243"></a> common default shell used is the Z shell (zsh), which replaces the Bourne Again Shell (bash) as the default. However, other shells can be used. If you are feeling adventurous, you could look at other shells like bash, fish, csh, or ksh. The bash shell will behave a lot like the zsh that you will be started off with. Others offer other possibilities that may be of interest, especially if you like to experiment. If you want to permanently change your shell, you can either edit <em>/etc/passwd</em> or just use <em>chsh</em> and have your shell changed for you.</p>
</div>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Service Management"><div class="sect1" id="id16">
<h1>Service Management</h1>

<p>For<a data-type="indexterm" data-primary="service management" data-secondary="services defined" id="id244"></a> a long time, there were two styles of service management: the BSD way and the AT&amp;T way. This is no longer true. There are now three ways of managing services. Before we get into service management, we should first define a service. A <em>service</em> in this context is a program that runs without any user intervention. The operating environment starts it up automatically and it runs in the background. Unless you got a list of processes, you may never know it was running. Most systems have a decent number of these services running at any point. They are called <em>services</em> because they provide a service either to the system, to the users, or sometimes to remote users.</p>

<p>Since there is no direct user interaction, generally, in terms of the startup and termination of these services, there needs to be another way to start and stop the services that can be called automatically during startup and shutdown of the system. With the facility to manage the services in place, users can also use the same facility to start, stop, restart, and get the status of these services.</p>
<div data-type="note" epub:type="note"><h1>Administrative Privileges for Services</h1>
<p>Services<a data-type="indexterm" data-primary="service management" data-secondary="administrative privileges for" id="id245"></a> are system-level. Managing them requires administrative privileges. Either you need to be root or you need to use <em>sudo</em> to gain temporary root privileges in order to perform the service management functions.</p>
</div>

<p>Often, <a data-type="indexterm" data-primary="service management" data-secondary="starting, stopping, restarting" id="id246"></a> Linux distributions<a data-type="indexterm" data-primary="init startup process" id="id247"></a> used the AT&amp;T <em>init</em> startup process. This meant that services were run with a set of scripts that took standard parameters. The <em>init</em> startup system used runlevels to determine which services started. Single-user mode would start up a different set of services than multiuser mode. Even more services would be started up when a display manager is being used, to provide GUIs to users. The scripts were stored in <em>/etc/init.d/</em> and could be managed by providing parameters such as <em>start</em>, <em>stop</em>, <em>restart</em>, and <em>status</em>. As an example, if you wanted to start the SSH service, you might use the command <em>/etc/init.d/ssh start</em>. The problem with the <em>init</em> system, though, was that it was generally serial in nature. This caused performance issues on system startup because every service would be started in sequence rather than multiple services starting at the same time. The other problem with the <em>init</em> system was that it didn’t support dependencies well. Often, one service may rely on other services that had to be started first.</p>

<p>Along<a data-type="indexterm" data-primary="systemd program" id="id248"></a> comes <em>systemd</em>, which was developed by software developers at RedHat. The goal of <em>systemd</em> was to improve the efficiency of the <em>init</em> system and overcome some of its shortcomings. Services can declare dependencies, and services can start in parallel. There is no longer a need to write bash scripts to start up the services. Instead, there are configuration files, and all service management<a data-type="indexterm" data-primary="service management" data-secondary="systemctl program" id="id249"></a><a data-type="indexterm" data-primary="systemctl verb service" id="id250"></a> is handled with the program <em>systemctl</em>. To manage a service using <em>systemctl</em>, you would use <em>systemctl verb service</em>, where <em>verb</em> is the command you are passing and <em>service</em> is the name of the service. As an example, if you wanted to enable the SSH service and then start it, you would issue the commands in <a data-type="xref" href="#EX_1_6">Example 1-6</a>.</p>
<div id="EX_1_6" data-type="example">
<h5><span class="label">Example 1-6. </span>Enabling and starting SSH service</h5>

<pre data-type="programlisting" data-code-language="bash">┌──<code class="o">(</code>kilroy@badmilo<code class="o">)</code>-<code class="o">[</code>~<code class="o">]</code><code class="w"></code>
└─$<code class="w">  </code>sudo<code class="w"> </code>systemctl<code class="w"> </code><code class="nb">enable</code><code class="w"> </code>ssh<code class="w"></code>
Synchronizing<code class="w"> </code>state<code class="w"> </code>of<code class="w"> </code>ssh.service<code class="w"> </code>with<code class="w"> </code>SysV<code class="w"> </code>service<code class="w"> </code>script<code class="w"> </code>with<code class="w"></code>
/lib/systemd/systemd-sysv-install.<code class="w"></code>
Executing:<code class="w"> </code>/lib/systemd/systemd-sysv-install<code class="w"> </code><code class="nb">enable</code><code class="w"> </code>ssh<code class="w"></code>
┌──<code class="o">(</code>kilroy@badmilo<code class="o">)</code>-<code class="o">[</code>~<code class="o">]</code><code class="w"></code>
└─$<code class="w">  </code>sudo<code class="w"> </code>systemctl<code class="w"> </code>start<code class="w"> </code>ssh<code class="w"></code></pre></div>

<p>The first thing we do is enable the service: you are telling your system that when you boot, you want this service to start. The different system startup modes that the service will start in are configured in the configuration file associated with the service. Every service has a configuration file. Instead of runlevels, as the old <em>init</em> system used, <em>systemd</em> uses targets. A <em>target</em> is essentially the same as a runlevel, in that it indicates a particular mode of operation of your system. In <a data-type="xref" href="#EX_1_7">Example 1-7</a>, you can see an example of one of these scripts from the <em>smartd</em> service, which is used to manage storage devices.</p>
<div id="EX_1_7" data-type="example">
<h5><span class="label">Example 1-7. </span>Configuring service for systemd</h5>

<pre data-type="programlisting">$ cat smartd.service
[Unit]
Description=Self Monitoring and Reporting Technology (SMART) Daemon
Documentation=man:smartd(8) man:smartd.conf(5)

# Typically physical storage devices are managed by the host physical machine
# Override it if you are using PCI/USB passthrough
ConditionVirtualization=no

[Service]
Type=notify
EnvironmentFile=-/etc/default/smartmontools
ExecStart=/usr/sbin/smartd -n $smartd_opts
ExecReload=/bin/kill -HUP $MAINPID

[Install]
WantedBy=multi-user.target
Alias=smartd.service</pre></div>

<p>The <em>Unit</em> section indicates requirements and the description as well as documentation. The <em>Service</em> section indicates how the service is to be started and managed. The <em>Install</em> service indicates the target that is to be used. In this case, <em>syslog</em> is in the multi-user target.</p>

<p>Kali is using a <em>systemd</em>-based system for initialization and service management, so you will primarily use <em>systemctl</em> to manage your services. In rare cases, a service that has been installed doesn’t support installing to <em>systemd</em>. In that case, you will install a service script to <em>/etc/init.d/</em> and you will have to call the script there to start and stop the service. For the most part, these are rare occurrences, though.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Package Management"><div class="sect1" id="id17">
<h1>Package Management</h1>

<p>While<a data-type="indexterm" data-primary="package management" data-secondary="Advanced Package Tool (apt)" id="id251"></a><a data-type="indexterm" data-primary="Advanced Package Tool (apt)" id="id252"></a> Kali comes with an extensive set of packages, not everything Kali is capable of installing is in the default installation. In some cases, you may want to install packages. You are also going to want to update your set of packages. To manage packages, regardless of what you are trying to do, you can use the Advanced Package Tool (<em>apt</em>) to perform package management functions. There are also other ways of managing packages. You can use frontends, but in the end, they are all just programs that sit on top of <em>apt</em>. You can use whatever frontend you like, but <em>apt</em> is so easy to use, it’s useful to know how to use it. While it’s command line, it’s still a great program. In fact, it’s quite a bit easier to use than some of the frontends I’ve seen on top of <em>apt</em> over the years.</p>

<p>The<a data-type="indexterm" data-primary="package management" data-secondary="updating local package databases" id="id253"></a><a data-type="indexterm" data-primary="version-control systems" id="id254"></a> first task you may want to perform is updating all the metadata in your local package database. These are the details about the packages that the remote repositories have, including version numbers. The version information is needed to determine whether the software you have is out-of-date and in need of upgrading. To update your local package database, you tell <em>apt</em> you want to update, as you can see in <a data-type="xref" href="#EX_1_8">Example 1-8</a>.</p>
<div id="EX_1_8" data-type="example">
<h5><span class="label">Example 1-8. </span>Updating package database using apt</h5>

<pre data-type="programlisting">┌──(kilroy@badmilo)-[~]
└─$  sudo apt update
Get:1 http://kali.localmsp.org/kali kali-rolling InRelease [30.5 kB]
Get:2 http://kali.localmsp.org/kali kali-rolling/main amd64 Packages [15.5 MB]
Get:3 http://kali.localmsp.org/kali kali-rolling/non-free amd64 Packages [166 kB]
Get:4 http://kali.localmsp.org/kali kali-rolling/contrib amd64 Packages [111 kB]
Fetched 15.8 MB in 2s (6437 kB/s)
Reading package lists... Done
Building dependency tree
Reading state information... Done
142 packages can be upgraded. Run 'apt list --upgradable' to see them.</pre></div>

<p>Once your local package database has been updated, <em>apt</em> will tell you whether you have updates to what you have installed. In this case, 142 packages are in need of updating. To<a data-type="indexterm" data-primary="apt" data-secondary="upgrade command" id="id255"></a><a data-type="indexterm" data-primary="package management" data-secondary="apt upgrade command" id="id256"></a><a data-type="indexterm" data-primary="package management" data-secondary="updating package metadata" id="id257"></a> update all the software on your system, you can use <em>apt upgrade</em>. Just using <em>apt upgrade</em> will update all the packages. If you need to update just a single package, you can use <em>apt upgrade packagename</em>, where <em>packagename</em> is the name of the package you want to update. The packaging format used by Debian and, by extension, Kali, tells <em>apt</em> what the required packages are. This list of dependencies tells Kali what needs to be installed for a particular package to work. In the case of upgrading software, it helps to determine the order in which packages should be upgraded.</p>

<p>If<a data-type="indexterm" data-primary="package management" data-secondary="apt install packagename command" id="id258"></a><a data-type="indexterm" data-primary="apt" data-secondary="install packagename command" id="id259"></a><a data-type="indexterm" data-primary="package management" data-secondary="installing software" id="id260"></a> you need to install software, it’s as easy as typing <em>apt install packagename</em>. Again, the dependencies are important here. <em>apt</em> will determine what software needs to be installed ahead of the package you are asking for. As a result, when you are asking for a piece of software to be installed, <em>apt</em> will tell you that other software is needed. You will get a list of all the necessary software and be asked whether you want to install all of it. You may also get a list of optional software packages. Packages may have a list of related software that can be used with the packages you are installing. If you want to install them, you will have to tell <em>apt</em> separately that you want to install them. The optional packages are not required at all.</p>

<p>Removing<a data-type="indexterm" data-primary="package management" data-secondary="apt remove packagename command" id="id261"></a><a data-type="indexterm" data-primary="apt" data-secondary="remove packagename command" id="id262"></a><a data-type="indexterm" data-primary="package management" data-secondary="removing packages" id="id263"></a> packages uses <em>apt remove packagename</em>. One of the issues with removing software is that although there are dependencies for installation, the same software may not necessarily get removed—​simply because once it’s installed, it may be used by other software packages. <em>apt</em> will, though, determine whether software packages are no longer in use. When you perform a function using <em>apt</em>, it may tell you that there are packages that could be removed. To<a data-type="indexterm" data-primary="package management" data-secondary="apt autoremove command" id="id264"></a><a data-type="indexterm" data-primary="apt" data-secondary="autoremove command" id="id265"></a> remove packages that are no longer needed, you use <em>apt autoremove</em>.</p>

<p>All<a data-type="indexterm" data-primary="package management" data-secondary="apt-cache command" id="id266"></a><a data-type="indexterm" data-primary="apt" data-secondary="-cache command" id="id267"></a><a data-type="indexterm" data-primary="package management" data-secondary="searching for packages" id="id268"></a> of this assumes that you know what you are looking for. You may not be entirely sure of a package name. In that case, you can use <em>apt-cache</em> to search for packages. You can use search terms that may be partial names of packages, since sometimes packages may not be named quite what you expect. Different Linux distributions may name a package with a different name. As an example, as you can see in <a data-type="xref" href="#EX_1_9">Example 1-9</a>, I have searched for <em>sshd</em> because the package name may be <em>sshd</em>, <em>ssh</em>, or something else altogether. You can see the results.</p>
<div id="EX_1_9" data-type="example">
<h5><span class="label">Example 1-9. </span>Searching for packages using apt-cache</h5>

<pre data-type="programlisting">┌──(kilroy@badmilo)-[~]
└─$ apt-cache search sshd
fail2ban - ban hosts that cause multiple authentication errors
libconfig-model-cursesui-perl - curses interface to edit config data through Config::Model
libconfig-model-openssh-perl - configuration editor for OpenSsh
libconfig-model-tkui-perl - Tk GUI to edit config data through Config::Model
libnetconf2-2 - NETCONF protocol library [C library]
libnetconf2-dev - NETCONF protocol library [C development]
libnetconf2-doc - NETCONF protocol library [docs]
openssh-server - secure shell (SSH) server, for secure access from remote machines
tinysshd - Tiny SSH server - daemon
zsnapd - ZFS Snapshot Daemon written in python
zsnapd-rcmd - Remote sshd command checker for ZFS Snapshot Daemon</pre></div>

<p>What you can see is that the SSH server on Kali appears to be named <em>openssh-server</em>. If that package weren’t installed but you wanted it, you would use the package name <em>openssh-server</em> to install it. This sort of assumes that you know what packages are installed on your system. With thousands of software packages installed, it’s unlikely you would know everything that’s already in place. If<a data-type="indexterm" data-primary="package management" data-secondary="dpkg command" id="id269"></a><a data-type="indexterm" data-primary="dpkg command" id="id270"></a> you want to know what software is installed, you can use the program <em>dpkg</em>, which can also be used to install software that isn’t in the remote repository but you have located a <em>.deb</em> file, which is a Debian package file. To get the list of all the software packages installed, you use <em>dpkg --list</em>. This is the same as using <em>dpkg -l</em>. Both will give you a list of all the software installed.</p>

<p>The list you get back will provide the package name as well as a description of the package and the version number that’s installed. You will also get the CPU architecture that the package was built to. If you have a 64-bit CPU and have installed the 64-bit version of Kali, you will likely see that most packages have the architecture set as <em>amd64</em>, though you may also see some flagged as <em>all</em>, which may just mean that no executables are in the package. Any documentation package would be for all architectures, as an example.</p>

<p>Another place you can use <em>dpkg</em> is installing software you find that isn’t in the Kali repository. If you find a <em>.deb</em> file, you can download it and then use <em>dpkg -i &lt;packagename&gt;</em> to install it. You may also want to remove a package that has been installed. While you can use <em>apt</em> for that, you can also use <em>dpkg</em>, especially if the package was installed that way. To remove a package by using dpkg, you use <em>dpkg -r &lt;packagename&gt;</em>. If you are unsure of the package name, you can get it from the list of packages installed you can use <em>dpkg</em> to obtain.</p>

<p>Each<a data-type="indexterm" data-primary="package management" data-secondary="viewing package contents" id="id271"></a> software package may include a collection of files including executables, documentation, default configuration files, and libraries as needed for the package. If you want to view the contents of a package, you can use <em>dpkg -c &lt;filename&gt;</em>, where the filename is the full name of the <em>.deb</em> file. In <a data-type="xref" href="#EX_1_10">Example 1-10</a>, you can see the partial contents of a<a data-type="indexterm" data-primary="log management" data-secondary="nxlog package" id="id272"></a><a data-type="indexterm" data-primary="nxlog package" id="id273"></a> log management package, <em>nxlog</em>. This package is not provided as part of the Kali repository but is provided as a free download for the community edition. The contents of this package include not only the files, but also permissions, including the owner and group. You can also see the date and time associated with the file from the package.</p>
<div id="EX_1_10" data-type="example">
<h5><span class="label">Example 1-10. </span>Partial contents of nxlog package</h5>

<pre data-type="programlisting" data-code-language="bash">┌──<code class="o">(</code>kilroy@badmilo<code class="o">)</code>-<code class="o">[</code>~<code class="o">]</code><code class="w"></code>
└─$<code class="w"> </code>dpkg<code class="w"> </code>-c<code class="w"> </code>nxlog-ce_3.2.2329_ubuntu22_amd64.deb<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./etc/<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./etc/nxlog/<code class="w"></code>
-rw-r--r--<code class="w"> </code>root/root<code class="w">      </code><code class="m">1275</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">08</code>:49<code class="w"> </code>./etc/nxlog/nxlog.conf<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./lib/<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./lib/systemd/<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./lib/systemd/system/<code class="w"></code>
-rw-r--r--<code class="w"> </code>root/root<code class="w">       </code><code class="m">349</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">08</code>:49<code class="w"> </code>./lib/systemd/system/nxlog.service<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/bin/<code class="w"></code>
-rwxr-xr-x<code class="w"> </code>root/root<code class="w">    </code><code class="m">517232</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/bin/nxlog<code class="w"></code>
-rwxr-xr-x<code class="w"> </code>root/root<code class="w">    </code><code class="m">500856</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/bin/nxlog-processor<code class="w"></code>
-rwxr-xr-x<code class="w"> </code>root/root<code class="w">    </code><code class="m">455808</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/bin/nxlog-stmnt-verifier<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/lib/<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/lib/nxlog/<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/lib/nxlog/modules/<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/lib/nxlog/modules/extension/<code class="w"></code>
drwxr-xr-x<code class="w"> </code>root/root<code class="w">         </code><code class="m">0</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/lib/nxlog/modules/extension/python/<code class="w"></code>
-rw-r--r--<code class="w"> </code>root/root<code class="w">     </code><code class="m">15678</code><code class="w"> </code><code class="m">2023</code>-04-14<code class="w"> </code><code class="m">09</code>:14<code class="w"> </code>./usr/lib/nxlog/modules/extension/python/libpynxlog.a<code class="w"></code></pre></div>

<p>One thing to take into account is that packages that you get in <em>.deb</em> files are generally created for a particular distribution. This occurs because there are usually dependencies that the person or group creating the package knows the distribution can supply. Other distributions may not have the right versions to satisfy the requirements for the software package. If that’s the case, the software may not run correctly. <em>dpkg</em> will error if the dependencies aren’t satisfied. You can force the install by using <em>--force-install</em> as a command-line parameter in addition to <em>-i</em>, but although the software will install, there is no guarantee that it will function correctly.</p>

<p><em>dpkg</em> has other capabilities that enable you to look into software packages, query installed software, and more. The options listed previously will more than get you started. With the extensive number of packages available in the Kali repository, it would be unusual, though not impossible, that you would need to do any external installations. It’s still useful to know about <em>dpkg</em> and its capabilities, however.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Log Management"><div class="sect1" id="id18">
<h1>Log Management</h1>

<p>For<a data-type="indexterm" data-primary="log management" data-secondary="benefits of" id="id274"></a> the most part, if you are doing security testing, you may never really need to look at the logs on your system. However, over a lot of years, I have found logs to be utterly invaluable. As solid a distribution as Kali is, there is always the possibility that something will go wrong and you will need to investigate. Even when everything is going well, you may still want to see what an application is logging. Because of that, you need to understand the logging system in Linux. To do that, you need to know what you are using. Unix has long used <em>syslog</em> as the system logger, though it began its life as a logging facility for the sendmail mail server.</p>

<p>Over<a data-type="indexterm" data-primary="syslog system logger" id="id275"></a> the years, <em>syslog</em> has had many implementations. Kali Linux<a data-type="indexterm" data-primary="rsyslog system logger" id="id276"></a><a data-type="indexterm" data-primary="log management" data-secondary="rsyslog system logger" id="id277"></a> does not come with a common syslog implementation installed, though you can install a typical system loger like <em>rsyslog</em>. It is a fairly straightforward implementation, and it’s easy to determine the locations for the files you will need to look in for log information. In general, all logs go to <em>/var/log</em>. However, there are specific files you will need to look in for log entries in different categories of information. On Kali, you would check the <em>/etc/rsyslog.conf</em> file. In addition to a lot of other configuration settings, you will see the entries shown in <a data-type="xref" href="#EX_1_11">Example 1-11</a>.</p>
<div id="EX_1_11" data-type="example">
<h5><span class="label">Example 1-11. </span>Log configuration for rsyslog</h5>

<pre data-type="programlisting" data-code-language="bash">auth,authpriv.*<code class="w">                 </code>/var/log/auth.log<code class="w"></code>
cron.*<code class="w">                          </code>-/var/log/cron.log<code class="w"></code>
kern.*<code class="w">                          </code>-/var/log/kern.log<code class="w"></code>
mail.*<code class="w">                          </code>-/var/log/mail.log<code class="w"></code>
user.*<code class="w">                          </code>-/var/log/user.log<code class="w"></code>

<code class="c1">#</code>
<code class="c1"># Emergencies are sent to everybody logged in.</code>
<code class="c1">#</code>
*.emerg<code class="w">                         </code>:omusrmsg:*<code class="w"></code></pre></div>

<p>What you see on the left side is a combination of facility and severity level. The word before the dot is the facility. The facility is based on the different subsystems that are logging using <em>syslog</em>. You may note that <em>syslog</em> goes back a long way, so there are still facilities identified for subsystems and services that you are unlikely to see much of these days. In <a data-type="xref" href="#syslog_facilities">Table 1-1</a>, you will see the list of facilities as defined for use in <em>syslog</em>. The Description column indicates what the facility is used for in case the facility itself doesn’t give that information to you.</p>
<table id="syslog_facilities">
<caption><span class="label">Table 1-1. </span>Syslog facilities</caption>
<thead>
<tr>
<th>Facility number</th>
<th>Facility</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>kern</p></td>
<td><p>Kernel messages</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>user</p></td>
<td><p>User-level messages</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>mail</p></td>
<td><p>Mail system</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>daemon</p></td>
<td><p>System daemons</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>auth</p></td>
<td><p>Security/authorization messages</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>syslog</p></td>
<td><p>Messages generated internally by syslogd</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>lpr</p></td>
<td><p>Line printer subsystem</p></td>
</tr>
<tr>
<td><p>7</p></td>
<td><p>news</p></td>
<td><p>Network news subsystem</p></td>
</tr>
<tr>
<td><p>8</p></td>
<td><p>uucp</p></td>
<td><p>UUCP subsystem</p></td>
</tr>
<tr>
<td><p>9</p></td>
<td></td>
<td><p>Clock daemon</p></td>
</tr>
<tr>
<td><p>10</p></td>
<td><p>authpriv</p></td>
<td><p>Security/authorization messages</p></td>
</tr>
<tr>
<td><p>11</p></td>
<td><p>ftp</p></td>
<td><p>FTP daemon</p></td>
</tr>
<tr>
<td><p>12</p></td>
<td><p>-</p></td>
<td><p>NTP subsystem</p></td>
</tr>
<tr>
<td><p>13</p></td>
<td><p>-</p></td>
<td><p>Log audit</p></td>
</tr>
<tr>
<td><p>14</p></td>
<td><p>-</p></td>
<td><p>Log alert</p></td>
</tr>
<tr>
<td><p>15</p></td>
<td><p>cron</p></td>
<td><p>Scheduling daemon</p></td>
</tr>
<tr>
<td><p>16</p></td>
<td><p>local0</p></td>
<td><p>Local use 0 (local0)</p></td>
</tr>
<tr>
<td><p>17</p></td>
<td><p>local1</p></td>
<td><p>Local use 1 (local1)</p></td>
</tr>
<tr>
<td><p>18</p></td>
<td><p>local2</p></td>
<td><p>Local use 2 (local2)</p></td>
</tr>
<tr>
<td><p>19</p></td>
<td><p>local3</p></td>
<td><p>Local use 3 (local3)</p></td>
</tr>
<tr>
<td><p>20</p></td>
<td><p>local4</p></td>
<td><p>Local use 4 (local4)</p></td>
</tr>
<tr>
<td><p>21</p></td>
<td><p>local5</p></td>
<td><p>Local use 5 (local5)</p></td>
</tr>
<tr>
<td><p>22</p></td>
<td><p>local6</p></td>
<td><p>Local use 6 (local6)</p></td>
</tr>
<tr>
<td><p>23</p></td>
<td><p>local7</p></td>
<td><p>Local use 7 (local7)</p></td>
</tr>
</tbody>
</table>

<p>Along with the facility is the severity. The severity has potential values of Emergency, Alert, Critical, Error, Warning, Notice, Informational, and Debug. These severities are listed in descending order, with the most severe listed first. You<a data-type="indexterm" data-primary="log management" data-secondary="selecting log delivery facilities" id="id278"></a> may determine that Emergency logs should be sent somewhere different from other severity levels. In <a data-type="xref" href="#EX_1_8">Example 1-8</a>, all of the severities are being sent to the log associated with each facility. The “*” after the facility name indicates all facilities. If you wanted to, for instance, send errors from the auth facility to a specific log file, you would use <em>auth.error</em> and indicate the file you want to use.</p>

<p>Once<a data-type="indexterm" data-primary="log management" data-secondary="parsing logs" id="id279"></a> you know where the logs are kept, you need to be able to read them. Fortunately, syslog log entries are easy enough to parse. If you look at <a data-type="xref" href="#EX_1_12">Example 1-12</a>, you will see a collection of log entries from the <em>auth.log</em> on a Kali system. Starting on the left of the entry, you will see the date and time that the log entry was written. This is followed by the hostname. Since <em>syslog</em> has the capability to send log messages to remote hosts, like a central log host, the hostname is important to be able to separate one entry from another if you are writing logs from multiple hosts into the same log file. After the hostname is the process name and PID. Most of these entries are from the process named <em>realmd</em> that has a PID 803.</p>
<div id="EX_1_12" data-type="example">
<h5><span class="label">Example 1-12. </span>Partial auth.log contents</h5>

<pre data-type="programlisting">2023-05-21T18:14:30.094986-04:00 badmilo sudo: pam_unix(sudo:session): session closed for user root
2023-05-21T18:15:01.783725-04:00 badmilo CRON[41805]: pam_unix(cron:session): session opened for user root(uid=0) by (uid=0)
2023-05-21T18:15:01.787913-04:00 badmilo CRON[41805]: pam_unix(cron:session): session closed for user root
2023-05-21T18:16:59.653896-04:00 badmilo sudo:   kilroy : TTY=pts/0 ; PWD=/var/log ; USER=root ; COMMAND=/usr/bin/cat auth.log
2023-05-21T18:16:59.654531-04:00 badmilo sudo: pam_unix(sudo:session): session opened for user root(uid=0) by (uid=1000)</pre></div>

<p>The<a data-type="indexterm" data-primary="log management" data-secondary="application entries" id="id280"></a> challenging part of the log isn’t the preamble, which is created and written by the <em>syslog</em> service, but the application entries. What we are looking at here is in English so is possible to understand if you read English once you understand what you are looking at. However, the contents of the log entries are created by the application itself, which means the programmer has to call functions that generate and write out the log entries. Some programmers may be better about generating useful and understandable log entries than others. Once you have gotten used to reading logs, you’ll start to understand what they are saying. If you run across a log entry that you really need but you don’t understand, internet search engines can always help find someone who has a better understanding of that log entry. Alternately, you can reach out to the software development team for help.</p>

<p>Not all logs run through <em>syslog</em>, but all system-related logs do. Even when <em>syslog</em> doesn’t manage the logs for an application, as in the case of the Apache web server, the logs are still likely to be in <em>/var/log/</em>. In some cases, you may have to go searching for the logs. This may be the case with some third-party software that installs to <em>/opt</em>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="id19">
<h1>Summary</h1>

<p>Linux has a long history behind it, going back to the days when resources were very constrained. This has led to some arcane commands whose purpose was to allow users (primarily programmers) to be efficient. It’s important to find an environment that works well for you so you too can be efficient in your work. Here are some key points to take away from this chapter:</p>

<ul>
<li>
<p>Unix is an environment created by programmers for programmers using the command line.</p>
</li>
<li>
<p>Unix was created with simple, single-purpose tools that can be combined for more complex tasks.</p>
</li>
<li>
<p>Kali Linux has several potential GUIs that can be installed and utilized; it’s important to find one that you’re most comfortable with.</p>
</li>
<li>
<p>Each desktop environment has a lot of customization options.</p>
</li>
<li>
<p>Kali is based on <em>systemd</em>, so service management uses <em>systemctl</em>.</p>
</li>
<li>
<p>Processes can be managed using signals, including interrupt and kill.</p>
</li>
<li>
<p>Logs will be your friends and help you troubleshoot errors. Logs are typically stored in <em>/var/log</em>.</p>
</li>
<li>
<p>Configuration files are typically stored in <em>/etc</em>, though individual configuration files are stored in the home directory.<a data-type="indexterm" data-primary="" data-startref="KLfound01" id="id281"></a></p>
</li>
</ul>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Quiz Questions"><div class="sect1" id="id62">
<h1>Quiz Questions</h1>

<p>1) What Linux command would you use to get a directory listing?
a) dir
b) fl
c) ls
d) list</p>

<p>2) What operating system is Linux derived from?
a) Windows
b) Unix
c) Multics
d) macOS</p>

<p>3) Which desktop environment is the default in Kali Linux?
a) Xfce
b) GNOME
c) KDE
d) Ratpoison</p>

<p>4) What package management utility is used to manage packages by default in Kali Linux?
a) yum
b) rpm
c) slackpkg
d) apt</p>

<p>5) If you wanted to get a listing of processes and associated utilizations that was periodically updated automatically, what utility would you use?
a) ps
b) top
c) free
d) grep</p>

<p>6) What are the names of the two streams in Linux used for I/O?
a) IN,OUT
b) SIN,SOUT
c) STDIN,STDOUT
d) INPUT,OUTPUT</p>

<p>7) Which of these Linux utilities is not used for locating files?
a) which
b) locate
c) find
d) search</p>

<p>8) If you wanted to find help information related to a command you know, what would you use?
a) apropos
b) like
c) regards
d) similar</p>

<p>9) If you were to use ps aux | grep top, what would you be doing?
a) Putting the process listing into top
b) Using top to find processes that match the term aux
c) Searching for the process named top in a process listing
d) Formatting a process listing</p>

<p>10) What would you use to manage system services like daemons that execute at system startup on Kali Linux?
a) init
b) update-rc
c) inetd
d) systemctl</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Useful Resources"><div class="sect1" id="id63">
<h1>Useful Resources</h1>

<ul>
<li>
<p><a href="http://bit.ly/linux-in-a-nutshell"><em>Linux in a Nutshell</em>, 6e</a>, by Ellen Siever, Stephen Figgins, Robert Love, and Arnold Robbins (O’Reilly, 2009)</p>
</li>
<li>
<p><a href="https://learning.oreilly.com/library/view/practical-linux-system/9781098109028/" class="bare"><em class="hyperlink">https://learning.oreilly.com/library/view/practical-linux-system/9781098109028/</em></a> [<em>Practical Linux System Administration</em>], by Kenneth Hess (O’Reilly, 2023)</p>
</li>
<li>
<p><a href="https://learning.oreilly.com/library/view/efficient-linux-at/9781098113391/" class="bare"><em class="hyperlink">https://learning.oreilly.com/library/view/efficient-linux-at/9781098113391/</em></a> [<em>Efficient Linux at the Command Line</em>], by Daniel J. Barrettt</p>
</li>
<li>
<p>The Kali Linux <a href="https://www.kali.org/">website</a></p>
</li>
<li>
<p><a href="http://bit.ly/linode-linux">“Linux System Administration Basics”</a> by Linode</p>
</li>
</ul>
</div></section>
</div></section></div>
</div>
</body>
</html>