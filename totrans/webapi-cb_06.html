<html><head></head><body><section data-pdf-bookmark="Chapter 6. Observing DOM Elements" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_observers">&#13;
<h1><span class="label">Chapter 6. </span>Observing DOM Elements</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introduction" data-type="sect1"><div class="sect1" id="id70">&#13;
<h1>Introduction</h1>&#13;
&#13;
<p><a data-primary="DOM elements" data-type="indexterm" id="ix_06-observers-asciidoc0"/>This<a data-primary="DOM elements" data-secondary="basics" data-type="indexterm" id="ix_06-observers-asciidoc1"/> chapter looks at three types of <em>observers</em> that the browser gives you for watching DOM elements: <code>MutationObserver</code>, <code>IntersectionObserver</code>, and <code>ResizeObserver</code>. These observer objects can watch DOM elements and notify you of certain changes or events.</p>&#13;
&#13;
<p>Observers are created with a callback function. This function is called whenever relevant events occur in the page. It’s called with one or more entries that contain information about what occurred. This just creates the observer. To actually start watching an element, you need to call <code>observe</code> on the observer, passing the element you want to observe and an optional set of options.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="MutationObserver" data-type="sect2"><div class="sect2" id="id71">&#13;
<h2>MutationObserver</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="MutationObserver" data-type="indexterm" id="id864"/><a data-primary="MutationObserver" data-type="indexterm" id="id865"/><code>MutationObserver</code> watches for changes in the DOM for an element. You can watch for changes to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Child elements</p>&#13;
</li>&#13;
<li>&#13;
<p>Attributes</p>&#13;
</li>&#13;
<li>&#13;
<p>Text content</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>What the browser observes is defined in an options object passed to the <code>observe</code> function. You can also give an optional <code>subtree</code> option when observing an element. This extends the monitoring of child elements, attributes, and/or text content to all descendant nodes (instead of just the element and its direct children).</p>&#13;
&#13;
<p>When a mutation occurs that you are interested in, your callback gets executed with an array of <code>MutationEntry</code> objects that describe the mutation that just occurred.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ResizeObserver" data-type="sect2"><div class="sect2" id="id72">&#13;
<h2>ResizeObserver</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="ResizeObserver" data-type="indexterm" id="id866"/><a data-primary="ResizeObserver" data-type="indexterm" id="id867"/>As its name suggests, <code>ResizeObserver</code> notifies you when an element’s size changes. When the size changes, your callback is called with information about what was resized. The entries contain information about the element’s new size.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="IntersectionObserver" data-type="sect2"><div class="sect2" id="id73">&#13;
<h2>IntersectionObserver</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="IntersectionObserver" data-type="indexterm" id="id868"/><a data-primary="IntersectionObserver" data-type="indexterm" id="id869"/><code>IntersectionObserver</code> watches for changes in an element’s position relative to a viewport. The viewport can be a scrollable element or the browser window itself. If any portion of the child element is visible within the scrollable area, it is said to be <em>intersecting</em> the ancestor element. <a data-type="xref" href="#figure6-1">Figure 6-1</a> shows elements on a scrollable page.</p>&#13;
&#13;
<figure><div class="figure" id="figure6-1">&#13;
<img alt="Elements on a scrollable page. Element 1 is not intersecting, element 2 is partially intersecting, and element 3 is fully intersecting." src="assets/wacb_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>Element 1 is not intersecting, element 2 is partially intersecting, and &#13;
<span class="keep-together">element 3</span> is fully intersecting</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="intersection ratio" data-type="indexterm" id="id870"/><code>IntersectionObserver</code> uses the concept of an <em>intersection ratio</em>—what portion of the element is actually intersecting the root. If the element is fully visible, it has a ratio of 1. If it is completely off-screen, it has a ratio of 0. If it is exactly half visible and half invisible, it has a ratio of 0.5. The entries passed to the callback function have an <code>intersectionRatio</code> property specifying the current intersection ratio.</p>&#13;
&#13;
<p><a data-primary="threshold, with IntersectionObserver" data-type="indexterm" id="id871"/>When you create an <code>IntersectionObserver</code>, you can also specify a <em>threshold</em>. This defines when the observer fires. By default, the threshold is 0. This means the observer fires as soon as the element becomes partially visible, even if it’s just a single pixel. A threshold of 1 only fires when the element becomes completely visible<a data-startref="ix_06-observers-asciidoc1" data-type="indexterm" id="id872"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lazy Loading an Image When Scrolled into View" data-type="sect1"><div class="sect1" id="recipe_lazyImage">&#13;
<h1>Lazy Loading an Image When Scrolled into View</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id277">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="lazy loading an image when scrolled into view" data-type="indexterm" id="ix_06-observers-asciidoc2"/><a data-primary="images" data-secondary="lazy loading components" data-type="indexterm" id="ix_06-observers-asciidoc3"/><a data-primary="IntersectionObserver" data-secondary="for lazy loading an image" data-type="indexterm" id="ix_06-observers-asciidoc4"/><a data-primary="lazy loading" data-secondary="for images" data-type="indexterm" id="ix_06-observers-asciidoc5"/>You want to defer loading of an image until its position is scrolled into view. This is sometimes called <em>lazy loading</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id454">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>IntersectionObserver</code> on the <code>&lt;img&gt;</code> element and wait until it intersects with the viewport. Once it enters the viewport, set the <code>src</code> attribute to start loading the image (see <a data-type="xref" href="#code_lazyLoadImage">Example 6-1</a>).</p>&#13;
<div data-type="example" id="code_lazyLoadImage">&#13;
<h5><span class="label">Example 6-1. </span>Lazily loading an image with <code>IntersectionObserver</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Observes an image element for lazy loading</code>&#13;
<code class="cm"> *</code>&#13;
<code class="cm"> * @param img A reference to the image DOM node</code>&#13;
<code class="cm"> * @param url The URL of the image to load</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">lazyLoad</code><code class="p">(</code><code class="nx">img</code><code class="p">,</code> <code class="nx">url</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">observer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">IntersectionObserver</code><code class="p">(</code><code class="nx">entries</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// isIntersecting becomes true once the image enters the viewport.</code>&#13;
    <code class="c1">// At that point, set the src URL and stop listening.</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">entries</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">isIntersecting</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">img</code><code class="p">.</code><code class="nx">src</code> <code class="o">=</code> <code class="nx">url</code><code class="p">;</code>&#13;
      <code class="nx">observer</code><code class="p">.</code><code class="nx">disconnect</code><code class="p">();</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="c1">// Start observing the image element.</code>&#13;
  <code class="nx">observer</code><code class="p">.</code><code class="nx">observe</code><code class="p">(</code><code class="nx">img</code><code class="p">);</code>&#13;
<code class="p">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id74">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>When you create an <code>IntersectionObserver</code>, you give it a callback function. Every time an element enters or exits, the observer calls this function with information about the element’s intersection status.</p>&#13;
&#13;
<p>The observer may be observing multiple elements whose intersection could change at the same time, so the callback is passed an array of elements. In <a data-type="xref" href="#code_lazyLoadImage">Example 6-1</a>, the observer is only observing a single image element, so the array only has one element.</p>&#13;
&#13;
<p class="pagebreak-before">If multiple elements enter (or leave) the viewport at the same time, there is one entry for each element.</p>&#13;
&#13;
<p>You want to check the <code>isIntersecting</code> property to determine if it’s time to load the image. This becomes <code>true</code> when the element becomes even partially visible.</p>&#13;
&#13;
<p>Finally, you have to tell the observer what element to watch by calling <code>observe</code> on the observer object. This starts watching the element.</p>&#13;
&#13;
<p>Once you scroll down enough so that the element enters the viewport area, the observer calls the callback. The callback sets the URL of the image, then stops listening by calling <code>disconnect</code>. The callback stops listening because once the image is loaded, there is no need to continue observing the element.</p>&#13;
&#13;
<p>Before <code>IntersectionObserver</code>, there weren’t many options to do this. One option would be to listen for the parent’s <code>scroll</code> event, and then calculate if the element is in the viewport by comparing the parent’s and child’s bounding rectangles.</p>&#13;
&#13;
<p>This, of course, is not very performant. It’s also generally considered bad practice. You’d have to throttle or debounce this check to prevent it from running on every scroll operation<a data-startref="ix_06-observers-asciidoc5" data-type="indexterm" id="id873"/><a data-startref="ix_06-observers-asciidoc4" data-type="indexterm" id="id874"/><a data-startref="ix_06-observers-asciidoc3" data-type="indexterm" id="id875"/><a data-startref="ix_06-observers-asciidoc2" data-type="indexterm" id="id876"/>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id877">&#13;
<h1>Lazy Loading in Newer Browsers</h1>&#13;
<p><a data-primary="lazy loading" data-secondary="in newer browsers" data-type="indexterm" id="id878"/><code>IntersectionObserver</code> has very good browser support, but if you are targeting only newer browsers, there is a way to lazily load images without &#13;
<span class="keep-together">JavaScript.</span></p>&#13;
&#13;
<p>In these newer browsers, the <code>&lt;img&gt;</code> element supports a <code>loading</code> attribute. If this is set to <code>lazy</code>, the image won’t be loaded until the element is scrolled into the viewport:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">img</code> <code class="na">src</code><code class="o">=</code><code class="s">"/path/to/image.jpg"</code> <code class="na">loading</code><code class="o">=</code><code class="s">"lazy"</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>You can find the latest data on browser support for the <code>loading</code> attribute on &#13;
<span class="keep-together"><a href="https://oreil.ly/coP8C">CanIUse</a>.</span></p>&#13;
</div></aside>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Wrapping IntersectionObserver with a Promise" data-type="sect1"><div class="sect1" id="id455">&#13;
<h1>Wrapping IntersectionObserver with a Promise</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id278">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="wrapping IntersectionObserver with a Promise" data-type="indexterm" id="ix_06-observers-asciidoc6"/><a data-primary="IntersectionObserver" data-secondary="wrapping with a Promise" data-type="indexterm" id="ix_06-observers-asciidoc7"/><a data-primary="Promises" data-secondary="wrapping IntersectionObserver with" data-type="indexterm" id="ix_06-observers-asciidoc8"/>You want to create a <code>Promise</code> that resolves once an element enters the viewport.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id456">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Wrap an <code>IntersectionObserver</code> in a <code>Promise</code>. Once the element intersects its parent, resolve the <code>Promise</code> (see <a data-type="xref" href="#example6-2">Example 6-2</a>).</p>&#13;
<div data-type="example" id="example6-2">&#13;
<h5><span class="label">Example 6-2. </span>Wrapping an <code>IntersectionObserver</code> with a <code>Promise</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Returns a Promise that is resolved once the given element enters the viewport</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">waitForElement</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">observer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">IntersectionObserver</code><code class="p">(</code><code class="nx">entries</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="nx">entries</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">isIntersecting</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">observer</code><code class="p">.</code><code class="nx">disconnect</code><code class="p">();</code>&#13;
        <code class="nx">resolve</code><code class="p">();</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="nx">observer</code><code class="p">.</code><code class="nx">observe</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id75">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>When the observer executes your callback with an entry that indicates the element is intersecting, you can resolve the <code>Promise</code>.</p>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#example6-3">Example 6-3</a>, you could use this approach to lazily load an image, similar to <a data-type="xref" href="#recipe_lazyImage">“Lazy Loading an Image When Scrolled into View”</a>.</p>&#13;
<div data-type="example" id="example6-3">&#13;
<h5><span class="label">Example 6-3. </span>Using the <code>waitForElement</code> helper to lazily load an image</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">lazyLoad</code><code class="p">(</code><code class="nx">img</code><code class="p">,</code> <code class="nx">url</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">waitForElement</code><code class="p">(</code><code class="nx">img</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">img</code><code class="p">.</code><code class="nx">src</code> <code class="o">=</code> <code class="nx">url</code><code class="p">)</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Once you have resolved the <code>Promise</code>, the calling code can be sure the element is in the viewport. At that point the <code>lazyLoad</code> function sets the <code>src</code> attribute on the image<a data-startref="ix_06-observers-asciidoc8" data-type="indexterm" id="id879"/><a data-startref="ix_06-observers-asciidoc7" data-type="indexterm" id="id880"/><a data-startref="ix_06-observers-asciidoc6" data-type="indexterm" id="id881"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Automatically Pause and Play a Video" data-type="sect1"><div class="sect1" id="id457">&#13;
<h1>Automatically Pause and Play a Video</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id279">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="automatically pause and play a video" data-type="indexterm" id="ix_06-observers-asciidoc9"/><a data-primary="IntersectionObserver" data-secondary="automatically pausing/playing video" data-type="indexterm" id="ix_06-observers-asciidoc10"/><a data-primary="videos" data-secondary="automatically pausing and playing" data-type="indexterm" id="ix_06-observers-asciidoc11"/><a data-primary="videos" data-secondary="pause and play automatically" data-type="indexterm" id="ix_06-observers-asciidoc12"/>You have a <code>&lt;video&gt;</code> element in a scrollable container. When the video is playing, you want to automatically pause it if it scrolls out of view.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id458">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <code>IntersectionObserver</code> to watch the video element. Once it no longer intersects the viewport, pause it. Later, if it reenters the viewport, resume it (see <a data-type="xref" href="#code_autoPlay">Example 6-4</a>).</p>&#13;
<div data-type="example" id="code_autoPlay">&#13;
<h5><span class="label">Example 6-4. </span>Automatically pausing and resuming a video</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">observer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">IntersectionObserver</code><code class="p">(</code><code class="nx">entries</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">entries</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">isIntersecting</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">video</code><code class="p">.</code><code class="nx">pause</code><code class="p">();</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="nx">video</code><code class="p">.</code><code class="nx">play</code><code class="p">()</code>&#13;
      <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="c1">// In case of a permission error autoplaying the video.</code>&#13;
        <code class="c1">// This avoids an unhandled rejection error that could crash your app.</code>&#13;
      <code class="p">});</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">observer</code><code class="p">.</code><code class="nx">observe</code><code class="p">(</code><code class="nx">video</code><code class="p">);</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id76">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>This observer watches the <code>video</code> element. As soon as it scrolls out of view, it is paused. Later, if you scroll it back into view, it is resumed.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id882">&#13;
<h1>Automatically Playing Videos</h1>&#13;
<p><a data-primary="videos" data-secondary="automatically playing" data-type="indexterm" id="id883"/>Browsers are strict about automatically playing videos. If you try to programmatically play a video, like in <a data-type="xref" href="#code_autoPlay">Example 6-4</a>, the browser may throw an exception. If you don’t mute the video by default (by setting the <code>video</code> element’s <code>muted</code> attribute), you can’t automatically or programmatically play it until the user has interacted with the page.</p>&#13;
&#13;
<p>The <code>play</code> method of the <code>video</code> element actually returns a <code>Promise</code>. To gracefully handle this situation, you should add a call to <code>catch</code> to the <code>Promise</code>.</p>&#13;
&#13;
<p>You shouldn’t automatically start playing a video when a page first loads, though. This is annoying and creates accessibility issues. For example, an automatically playing video could be triggering to someone with a vestibular disorder. The audio could also interfere with a screen reader user being able to hear narration.</p>&#13;
&#13;
<p>In a real-world application, you should use this solution only as a convenience once a user has clicked the play <a data-startref="ix_06-observers-asciidoc12" data-type="indexterm" id="id884"/><a data-startref="ix_06-observers-asciidoc11" data-type="indexterm" id="id885"/><a data-startref="ix_06-observers-asciidoc10" data-type="indexterm" id="id886"/><a data-startref="ix_06-observers-asciidoc9" data-type="indexterm" id="id887"/>button.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Animating Changes in Height" data-type="sect1"><div class="sect1" id="id459">&#13;
<h1>Animating Changes in Height</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id77">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="animations" data-secondary="changes in height" data-type="indexterm" id="ix_06-observers-asciidoc13"/><a data-primary="DOM elements" data-secondary="animating changes in height" data-type="indexterm" id="ix_06-observers-asciidoc14"/><a data-primary="height, animating changes in" data-type="indexterm" id="ix_06-observers-asciidoc15"/>You have an element whose contents may change. If the content changes, you want a smooth transition in the height.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id78">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="MutationObserver" data-type="indexterm" id="ix_06-observers-asciidoc16"/>Use a <code>MutationObserver</code> to watch the element’s children. If the element adds, removes, or changes any child elements, use a CSS transition to smoothly animate the height change. Because you can’t animate an element with an <code>auto</code> height, this requires some extra work to calculate explicit heights between which to animate (see <a data-type="xref" href="#example6-5">Example 6-5</a>).</p>&#13;
<div data-type="example" id="example6-5">&#13;
<h5><span class="label">Example 6-5. </span>Animating an element’s height due to child element changes</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Watches an element for changes to its children. When the height changes</code>&#13;
<code class="cm"> * due to child changes, animate the change.</code>&#13;
<code class="cm"> * @param element The element to watch for changes</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">animateHeightChanges</code><code class="p">(</code><code class="nx">element</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// You can't animate an element with 'height: auto', so an explicit</code>&#13;
  <code class="c1">// height is needed here.</code>&#13;
  <code class="nx">element</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">height</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">details</code><code class="p">.</code><code class="nx">offsetHeight</code><code class="si">}</code><code class="sb">px`</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// Set a few CSS properties needed for the animated transition.</code>&#13;
  <code class="nx">element</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">transition</code> <code class="o">=</code> <code class="s1">'height 200ms'</code><code class="p">;</code>&#13;
  <code class="nx">element</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">overflow</code> <code class="o">=</code> <code class="s1">'hidden'</code><code class="p">;</code>&#13;
&#13;
  <code class="cm">/**</code>&#13;
<code class="cm">   * This observer will fire when the element's child elements</code>&#13;
<code class="cm">   * change. It measures the new height, then uses requestAnimationFrame</code>&#13;
<code class="cm">   * to update the height. The height change will be animated.</code>&#13;
<code class="cm">   */</code>&#13;
  <code class="kr">const</code> <code class="nx">observer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MutationObserver</code><code class="p">(</code><code class="nx">entries</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// entries is always an array. There may be times where this array has multiple</code>&#13;
    <code class="c1">// elements, but in this case, the first and only element is what you need.</code>&#13;
    <code class="kr">const</code> <code class="nx">element</code> <code class="o">=</code> <code class="nx">entries</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">target</code><code class="p">;</code>&#13;
&#13;
    <code class="c1">// The content has changed, and so has the height.</code>&#13;
    <code class="c1">// There are a few steps to measure the new explicit height.</code>&#13;
&#13;
    <code class="c1">// (1) Remember the current height to use for the animation's starting point.</code>&#13;
    <code class="kr">const</code> <code class="nx">currentHeightValue</code> <code class="o">=</code> <code class="nx">element</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">height</code><code class="p">;</code>&#13;
&#13;
    <code class="c1">// (2) Set the height to 'auto' and read the offsetHeight property.</code>&#13;
    <code class="c1">// This is the new height to set.</code>&#13;
    <code class="nx">element</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">height</code> <code class="o">=</code> <code class="s1">'auto'</code><code class="p">;</code>&#13;
    <code class="kr">const</code> <code class="nx">newHeight</code> <code class="o">=</code> <code class="nx">element</code><code class="p">.</code><code class="nx">offsetHeight</code><code class="p">;</code>&#13;
&#13;
    <code class="c1">// (3) Set the current height back before animating.</code>&#13;
    <code class="nx">element</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">height</code> <code class="o">=</code> <code class="nx">currentHeightValue</code><code class="p">;</code>&#13;
&#13;
    <code class="c1">// On the next animation frame, change the height. This will</code>&#13;
    <code class="c1">// trigger the animated transition.</code>&#13;
    <code class="nx">requestAnimationFrame</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">element</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">height</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">newHeight</code><code class="si">}</code><code class="sb">px`</code><code class="p">;</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="c1">// Begin watching the element for changes.</code>&#13;
  <code class="nx">observer</code><code class="p">.</code><code class="nx">observe</code><code class="p">(</code><code class="nx">element</code><code class="p">,</code> <code class="p">{</code> <code class="nx">childList</code><code class="o">:</code> <code class="kc">true</code> <code class="p">});</code>&#13;
<code class="p">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id79">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>As with other observers, you need to pass a callback function when you create a &#13;
<span class="keep-together"><code>MutationObserver</code>.</span> The observer calls this function whenever an observed element changes (which changes trigger the callback, specifically, depends on the options passed to <code>observer.observe</code>). When your app causes any changes to the element’s child list (adding, removing, or modifying elements), the callback recalculates the height to accommodate the new content.</p>&#13;
&#13;
<p>There’s a lot going on here, mostly because the browser won’t let you animate an element with a <code>height</code> of <code>auto</code>. To make the animation work, you have to use explicit values for the start and end heights.</p>&#13;
&#13;
<p>When first observing the element, you calculate its height by reading the <code>offset​Height</code> property. The function then explicitly sets this height on the element. This takes care of the <code>height: auto</code> for now.</p>&#13;
&#13;
<p>When the element’s children change, the parent won’t resize automatically because it now has an explicit height set. The observer callback calculates the new height. With an explicit height set, the <code>offsetHeight</code> property has the same value.</p>&#13;
&#13;
<p>To measure the <em>new</em> height, you must first set the height <em>back</em> to <code>auto</code>. Once you do this, <code>offsetHeight</code> gives the new height value. However, recall that you can’t animate from <code>height: auto</code>. Before updating the height, it has to be set from <code>auto</code> back to what it was <em>previously</em> set to.</p>&#13;
&#13;
<p>At this point you have the new height. The actual height update goes in a call to <code>requestAnimationFrame</code>.</p>&#13;
&#13;
<p>This method of calculating the heights adds a lot of extra code. <a data-type="xref" href="ch08.html#ch_webAnimationsApi">Chapter 8</a> covers the Web Animations API, which makes these types of animations less<a data-startref="ix_06-observers-asciidoc16" data-type="indexterm" id="id888"/> painful<a data-startref="ix_06-observers-asciidoc15" data-type="indexterm" id="id889"/><a data-startref="ix_06-observers-asciidoc14" data-type="indexterm" id="id890"/><a data-startref="ix_06-observers-asciidoc13" data-type="indexterm" id="id891"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Change an Element’s Content Based on Size" data-type="sect1"><div class="sect1" id="id460">&#13;
<h1>Change an Element’s Content Based on Size</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id280">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="changing an element’s content based on size" data-type="indexterm" id="ix_06-observers-asciidoc17"/>You want to show different content within an element depending on its size. For example, you may want to handle the case when the element is very wide.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id80">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="ResizeObserver" data-type="indexterm" id="id892"/>Use a <code>ResizeObserver</code> on the element and update the content if the size goes above or below your defined threshold (see <a data-type="xref" href="#example6-6">Example 6-6</a>).</p>&#13;
<div data-type="example" id="example6-6">&#13;
<h5><span class="label">Example 6-6. </span>Updating an element’s content when it is resized</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Look up the element you want to observe.</code>&#13;
<code class="kr">const</code> <code class="nx">container</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s1">'#resize-container'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Create a ResizeObserver that will watch the element for size changes.</code>&#13;
<code class="kr">const</code> <code class="nx">observer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ResizeObserver</code><code class="p">(</code><code class="nx">entries</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// The observer fires immediately, so you can set the initial text.</code>&#13;
  <code class="c1">// There's typically only going to be one entry in the array—the first element is</code>&#13;
  <code class="c1">// the element you're interested in.</code>&#13;
  <code class="nx">container</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="sb">`My width is </code><code class="si">${</code><code class="nx">entries</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">contentRect</code><code class="p">.</code><code class="nx">width</code><code class="si">}</code><code class="sb">px`</code><code class="p">;</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// Start watching the element.</code>&#13;
<code class="nx">observer</code><code class="p">.</code><code class="nx">observe</code><code class="p">(</code><code class="nx">container</code><code class="p">);</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id81">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The <code>ResizeObserver</code> calls the callback that you pass every time the element’s size changes. The observer also calls it initially when the element is first observed.</p>&#13;
&#13;
<p>The callback is called with an array of <code>ResizeObserverEntry</code> objects—here, where you’re only observing one element, it’s typically going to just be one entry. The <code>entry</code> object has a few properties, including <code>contentRect</code>, which defines the bounding rectangle of the element. From there you can get the width.</p>&#13;
&#13;
<p>As a result, when the element is resized, the observer callback changes its text to indicate the current width.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Use care when working with <code>ResizeObserver</code> to ensure the code in your callback doesn’t trigger the observer again. Such a callback can cause an infinite loop of <code>ResizeObserver</code> callbacks. This can happen if you make changes to the element within the callback that cause its size to change again<a data-startref="ix_06-observers-asciidoc17" data-type="indexterm" id="id893"/>.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Applying a Transition When an Element &#10;Scrolls into View" data-type="sect1"><div class="sect1" id="id461">&#13;
<h1>Applying a Transition When an Element &#13;
<span class="keep-together">Scrolls into View</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id281">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="applying a transition when an element scrolls into view" data-type="indexterm" id="ix_06-observers-asciidoc19"/><a data-primary="IntersectionObserver" data-secondary="applying a transition when an element scrolls into view" data-type="indexterm" id="ix_06-observers-asciidoc20"/><a data-primary="transitions" data-secondary="applying a transition when an element scrolls into view" data-type="indexterm" id="ix_06-observers-asciidoc21"/>You have content that is not initially shown. When the content enters the viewport, you want to show it with an animated transition. For example, when an image scrolls into view, you want to make it fade in by transitioning its opacity.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id462">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use an <code>IntersectionObserver</code> to watch for when the element scrolls into view. When it does, apply the animated transition (see <a data-type="xref" href="#example6-7">Example 6-7</a>).</p>&#13;
<div data-type="example" id="example6-7">&#13;
<h5><span class="label">Example 6-7. </span>Fading in all images on the page when they scroll into view</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">observer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">IntersectionObserver</code><code class="p">(</code><code class="nx">entries</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// There are multiple images per row, so there are multiple</code>&#13;
  <code class="c1">// entries.</code>&#13;
  <code class="nx">entries</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">entry</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// Once the element becomes partially visible, apply the animated transition,</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">entry</code><code class="p">.</code><code class="nx">isIntersecting</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="c1">// The image is 25% visible, begin the fade-in transition.</code>&#13;
      <code class="nx">entry</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">style</code><code class="p">.</code><code class="nx">opacity</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>&#13;
&#13;
      <code class="c1">// No need to observe this element any further.</code>&#13;
      <code class="nx">observer</code><code class="p">.</code><code class="nx">unobserve</code><code class="p">(</code><code class="nx">entry</code><code class="p">.</code><code class="nx">target</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">},</code> <code class="p">{</code> <code class="nx">threshold</code><code class="o">:</code> <code class="mf">0.25</code> <code class="p">});</code> <code class="c1">// Fires when images become 25% visible</code>&#13;
&#13;
<code class="c1">// Observe all images on the page. Only images with the 'animate'</code>&#13;
<code class="c1">// class name will be observed, since you might not want to do this to</code>&#13;
<code class="c1">// all images on the page.</code>&#13;
<code class="nb">document</code><code class="p">.</code><code class="nx">querySelectorAll</code><code class="p">(</code><code class="s1">'img.animate'</code><code class="p">).</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">image</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">observer</code><code class="p">.</code><code class="nx">observe</code><code class="p">(</code><code class="nx">image</code><code class="p">);</code>&#13;
<code class="p">});</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id82">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>This recipe uses the <code>IntersectionObserver</code>’s <code>threshold</code> option. By default, an observer fires as soon as the element becomes visible (a <code>threshold</code> of <code>0</code>). This isn’t ideal here because you want enough of the image to be visible so that the user notices the transition. By setting a <code>threshold</code> of <code>0.25</code>, the observer won’t execute the callback until the image becomes at least 25% visible.</p>&#13;
&#13;
<p>The callback also checks to see if the image is actually intersecting; that is, if it has become visible. This is necessary because when the observer first starts observing an element, it fires immediately. In this case, the images that are offscreen are not yet intersecting, so this check prevents them from becoming visible too early.</p>&#13;
&#13;
<p>If the entry is intersecting, you can set new styles that trigger an animation or transition. In this case, the callback is setting the image’s opacity to 1. To make this effect work, you need to have previously set the opacity to 0 and defined a <code>transition</code> property of <code>opacity</code> (see <a data-type="xref" href="#example6-8">Example 6-8</a>).</p>&#13;
<div data-type="example" id="example6-8">&#13;
<h5><span class="label">Example 6-8. </span>Styling images to fade in</h5>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.animate</code> <code class="p">{</code>&#13;
  <code class="k">opacity</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
  <code class="k">transition</code><code class="o">:</code> <code class="n">opacity</code> <code class="m">500ms</code><code class="p">;</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>With this style, the images are invisible. When the observer callback sets the opacity to 1, the transition takes effect and you’ll see the image fade in.</p>&#13;
&#13;
<p>You only want to perform this animation once, so once the image is visible you don’t need to observe it anymore. You can clean up by calling <code>observer.unobserve</code> and passing the element to stop observing<a data-startref="ix_06-observers-asciidoc21" data-type="indexterm" id="id894"/><a data-startref="ix_06-observers-asciidoc20" data-type="indexterm" id="id895"/><a data-startref="ix_06-observers-asciidoc19" data-type="indexterm" id="id896"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Infinite Scrolling" data-type="sect1"><div class="sect1" id="id463">&#13;
<h1>Using Infinite Scrolling</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id83">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="DOM elements" data-secondary="using infinite scrolling" data-type="indexterm" id="id897"/><a data-primary="infinite scrolling" data-type="indexterm" id="id898"/><a data-primary="IntersectionObserver" data-secondary="using for infinite scrolling" data-type="indexterm" id="id899"/><a data-primary="scrolling, infinite" data-type="indexterm" id="id900"/>You want to automatically load more data when the user scrolls to the bottom of a list without the user having to click a Load More button.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id464">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Place an element at the end of the scrollable list and observe it with an <code>Intersection​Observer</code>. When the element starts intersecting, load more data (see <a data-type="xref" href="#example6-9">Example 6-9</a>).</p>&#13;
<div data-type="example" id="example6-9">&#13;
<h5><span class="label">Example 6-9. </span>Using <code>IntersectionObserver</code> for infinite scrolling</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/**</code>&#13;
<code class="cm"> * Observes a placeholder element with an IntersectionObserver.</code>&#13;
<code class="cm"> * When the placeholder becomes visible, more data is loaded.</code>&#13;
<code class="cm"> *</code>&#13;
<code class="cm"> * @param placeholder The Load More placeholder element</code>&#13;
<code class="cm"> * @param loadMore A function that loads more data</code>&#13;
<code class="cm"> */</code>&#13;
<code class="kd">function</code> <code class="nx">observeForInfiniteScroll</code><code class="p">(</code><code class="nx">placeholder</code><code class="p">,</code> <code class="nx">loadMore</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">observer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">IntersectionObserver</code><code class="p">(</code><code class="nx">entries</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// If the placeholder becomes visible, it means the user</code>&#13;
    <code class="c1">// has scrolled to the bottom of the list. In this case, time to</code>&#13;
    <code class="c1">// load more data.</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">entries</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">isIntersecting</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">loadMore</code><code class="p">();</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="nx">observer</code><code class="p">.</code><code class="nx">observe</code><code class="p">(</code><code class="nx">placeholder</code><code class="p">);</code>&#13;
<code class="p">}</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id84">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The placeholder element could say Load More, or it can be visually hidden. The <code>IntersectionObserver</code> watches the placeholder element. Once it enters the viewport, the callback starts loading more data. Using this technique, a user can keep scrolling and scrolling until they reach the end of the data.</p>&#13;
&#13;
<p>You could make this placeholder a loading spinner. When the user scrolls to the bottom of the list, triggering a new request, they’ll see the spinner while the new data is loading. This is accurate because with the default threshold of 0.0, the observer fires just before the user scrolls far enough to see the spinner. By this time, the data is already loading, so it’s not an artificial spinner.</p>&#13;
&#13;
<p>When the observer first starts observing, the callback fires immediately. If the list is empty, the placeholder is visible, which triggers the code to load the first page of data.<a data-startref="ix_06-observers-asciidoc0" data-type="indexterm" id="id901"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>