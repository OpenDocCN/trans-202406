- en: Chapter 7\. Concurrent React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we delved deep into the world of server-side rendering
    with React. We examined the importance of server-side rendering for improving
    the performance and user experience of our applications, especially in the context
    of modern web development. We explored different server rendering APIs, such as
    `renderToString` and `renderToPipeableStream`, and discussed their use cases and
    benefits. We also touched upon the challenges of implementing server-side rendering
    and how it’s better to rely on established frameworks like Next.js and Remix to
    handle the complexities for us.
  prefs: []
  type: TYPE_NORMAL
- en: We covered the concept of hydration and its significance in connecting server-rendered
    markup with client-side React components, creating a seamless user experience.
    Additionally, we discussed the potential security issues and challenges that come
    with managing multiple client connections in a serverful environment, emphasizing
    the need for using frameworks that handle these concerns effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as we transition to the next concurrent React—we will build upon our understanding
    of all that we’ve learned so far. We will dive into the Fiber reconciler and learn
    about the concurrent features of React, as well as how efficiently it manages
    updates and rendering. By examining scheduling, deferring updates, and render
    lanes, we’ll gain insights into the performance optimizations made possible by
    React’s core architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once again, it’s worth noting that Fiber itself and the things we’re about to
    discuss are implementation details in React that are likely to change and that
    you don’t need to know to use React effectively. However, learning the underlying
    mechanisms will help you better understand how React works and how to use it effectively,
    while also making you more knowledgeable as an engineer in general.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s embark on our journey into the fascinating world of concurrent
    React, as we continue to build on our expertise and discover new ways to harness
    the power of React for creating high-performance applications.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem with Synchronous Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recap, the problem with synchronous rendering is that it blocks the main
    thread, which can lead to a poor user experience. This is especially true for
    complex applications with many components and frequent updates. In such cases,
    the UI can become unresponsive, resulting in a frustrating user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical mitigation step to this problem is to batch a series of updates into
    one update and minimize work done on the main thread: instead of processing 10
    things 10 times, batch them and process them once. We covered batching in [Chapter 4](ch04.html#ch04),
    so we won’t go into more detail here, but for the purposes of our discussion,
    it’s important to understand that batching is a mitigation step to these problems,
    but even that has limitations, as we’ll uncover in the next few paragraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: The problems we’ve been talking about, even with batching, are further compounded
    by the fact that by design, synchronous rendering has no sense of priority. It
    treats all updates equally, regardless of their visibility. For example, with
    sync rendering you may block the main thread with rendering work for items that
    the user can’t see, such as tabs that aren’t visible, content behind a modal,
    or content in a loading state. You still want those items to render if there is
    CPU available, but you want to prioritize rendering the thing the user can see
    and interact with. Before React had concurrent features, we often had situations
    where critical updates were blocked by less important ones, resulting in a poor
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: With concurrent rendering, React can prioritize updates based on their importance
    and urgency, ensuring that critical updates are not blocked by less important
    ones. This allows React to maintain a responsive UI even under heavy load, resulting
    in a better user experience. For example, when a user hovers over or clicks on
    a button, the expectation is that it immediately shows feedback for that action.
    If React is working on rerendering a long list of items, then the hover or active
    state feedback will be delayed until the entire list is rendered. With concurrent
    rendering, rendering tasks that are CPU bound and CPU intensive can be given a
    back seat to rendering tasks that are more important, such as user interactions
    and animations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, with the concurrent rendering capabilities, React is able to time
    slice: that is, it can break up the rendering process into smaller chunks and
    process them incrementally. This allows React to perform work over multiple frames,
    and if the work needs to be interrupted, it can be.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll dive into all of this together starting now.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting Fiber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As covered in [Chapter 4](ch04.html#ch04), the Fiber reconciler is the core
    mechanism in React that enables concurrent rendering. It was introduced in React
    16 and represented a significant architectural shift from the previous stack reconciler.
    The primary goal of the Fiber reconciler is to improve the responsiveness and
    performance of React applications, particularly for large and complex UIs.
  prefs: []
  type: TYPE_NORMAL
- en: The Fiber reconciler achieves this by breaking the rendering process into smaller,
    more manageable units of work called Fibers. This allows React to pause, resume,
    and prioritize rendering tasks, making it possible to defer or schedule updates
    based on their importance. This improves the responsiveness of the application
    and ensures that critical updates are not blocked by less important tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling and Deferring Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React’s ability to schedule and defer updates is crucial for maintaining a responsive
    application. The Fiber reconciler enables this functionality by relying on a scheduler
    and a number of efficient APIs. These APIs allow React to perform work during
    idle periods and schedule updates at the most opportune times.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll dive into the scheduler in more detail in upcoming sections, but for
    now, consider it to be exactly what it sounds like: a system that receives updates
    and says, “you do this now,” “you do this later,” etc., using browser APIs like
    `setTimeout`, `MessageChannel`, and others.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a real-time chat application where users can send and receive messages.
    We will have a chat component that displays a list of messages, and a message
    input component where users can type and submit their messages. Additionally,
    the chat application receives new messages from the server in real time. In this
    scenario, we want to prioritize user interactions (typing and submitting messages)
    to maintain a responsive experience, while ensuring that incoming messages are
    rendered efficiently without blocking the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this example a little more concrete, let’s create some components.
    First, a list of messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a message input component that allows users to type and submit
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have a chat component that combines the two components and handles
    the logic for sending and receiving messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, React’s concurrent rendering capabilities come into play by
    efficiently managing the updates of both the message list and the user’s interactions
    with the message input. When a user types or submits a message, React prioritizes
    the text input updates above other updates to ensure a smooth user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'When new messages arrive from the server and need to be rendered, they are
    rendered in the default/unknown render lane, which updates the DOM synchronously
    and instantly in a blocking manner: this would delay any user input. If we want
    rendering the new list of messages to be de-prioritized, we can wrap the corresponding
    state update in a `startTransition` function from the `useTransition` hook, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this, we signal to React to schedule the message list updates with a lower
    priority and render them without blocking the UI, allowing the chat application
    to function efficiently, even under heavy load. Thus, user input is never interrupted,
    and incoming messages are rendered with a lower priority than user interactions
    since they are less critical to the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates how React’s concurrent rendering capabilities can
    be leveraged to build responsive applications that handle complex interactions
    and frequent updates without compromising on performance or user experience. We
    will dive deeper into `useTransition` further in this chapter. For now, let’s
    look a little deeper at how, exactly, React schedules updates.
  prefs: []
  type: TYPE_NORMAL
- en: Diving Deeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In React, the process of scheduling, prioritizing, and deferring updates is
    essential to maintaining a responsive user interface. This process ensures that
    high-priority tasks are addressed promptly, while low-priority tasks can be deferred,
    allowing the UI to remain smooth even under heavy load. To delve deeper into this
    topic, we’ll examine several core concepts: the scheduler, the priority levels
    of tasks, and the mechanisms that defer updates.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Before we proceed—let’s remind ourselves one more time that the information
    covered here consists of implementation details and is *not requisite to using
    React*. However, understanding these concepts will help you better understand
    how React works and how to use it effectively, while also teaching you the underlying
    mechanism that you can apply in other engineering endeavors, improving your overall
    skill set. With that in mind, let’s proceed.
  prefs: []
  type: TYPE_NORMAL
- en: The Scheduler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the core of React’s architecture, the scheduler is a standalone package that
    provides timing-related utilities, independent of the Fiber reconciler. React
    uses this scheduler within the reconciler. The scheduler and reconciler, through
    the usage of render lanes, enable tasks to cooperate by prioritizing and organizing
    them based on their urgency. We will dive deep into render lanes shortly. The
    scheduler’s primary role in React today is to manage the yielding of the main
    thread, mainly by scheduling microtasks to ensure smooth execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this in a little more detail, let’s look at a portion of React’s
    source code at the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ensureRootIsScheduled` function in React’s codebase plays a crucial role
    in managing the rendering process. When a React root, represented by `root: FiberRoot`,
    receives an update, this function is called to perform two critical actions. Remember
    from [Chapter 4](ch04.html#ch04): a React root is the final “swap” that happens
    during the commit phase to make updates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When `ensureRootIsScheduled` is called, it confirms that the root is included
    in the root schedule: a list that tracks which roots need to be processed. Secondly,
    it ensures the existence of a pending microtask dedicated to processing this root
    schedule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A microtask is a concept in JavaScript event-loop management, representing
    a type of task that is managed by the microtask queue. To understand microtasks,
    it’s important to first have a basic grasp of the JavaScript event loop and the
    task queues associated with it:'
  prefs: []
  type: TYPE_NORMAL
- en: Event loop
  prefs: []
  type: TYPE_NORMAL
- en: 'The JavaScript engine uses an event loop to manage asynchronous operations.
    The event loop continuously checks if there’s any work (like executing a callback)
    that needs to be done. It operates on two kinds of task queues: the task queue
    (macro task queue) and the microtask queue.'
  prefs: []
  type: TYPE_NORMAL
- en: Task queue (macro task queue)
  prefs: []
  type: TYPE_NORMAL
- en: This queue holds tasks such as handling events, executing `setTimeout` and `set​Interval`
    callbacks, and performing I/O operations. Tasks in this queue are processed one
    at a time, and the next task is picked up only after the current one is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Microtask queue
  prefs: []
  type: TYPE_NORMAL
- en: A microtask is a smaller, more immediate task. Microtasks arise from operations
    like promises, `Object.observe`, and `MutationObserver`. They are stored in the
    microtask queue, which is different from the regular task queue.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs: []
  type: TYPE_NORMAL
- en: Microtasks are processed at the end of the current task, before the JavaScript
    engine picks up the next (macro) task from the task queue. After executing a task,
    the engine checks if there are any microtasks in the microtask queue and executes
    them all before moving on. This ensures that microtasks are processed quickly
    and in order, just after the currently executing script and before any other tasks,
    like rendering or handling events.
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics and usage
  prefs: []
  type: TYPE_NORMAL
- en: Microtasks have higher priority over other tasks in the task queue, meaning
    they are executed before moving on to the next macro task. If a microtask continuously
    adds more microtasks to the queue, it can lead to a situation where the task queue
    never gets processed. This is known as *starvation*.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of React and the `ensureRootIsScheduled` function, a microtask
    is used to ensure that the processing of the root schedule happens promptly and
    with high priority, right after the current script execution and before the browser
    performs other tasks like rendering or handling events. This helps in maintaining
    smooth UI updates and efficient task management within the React framework.
  prefs: []
  type: TYPE_NORMAL
- en: The function starts by adding the root to the schedule. This involves checking
    if the root is either the last scheduled one or already present in the schedule.
    If it’s not present, the function adds the root to the end of the schedule, updating
    the `lastScheduledRoot` to point to the current root. If no root was previously
    scheduled (`lastScheduledRoot === null`), the current root becomes both the first
    and the last in the schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the function sets the flag `mightHavePendingSyncWork` to `true`. This
    flag signals that there might be synchronous work pending, essential for the `flushSync`
    function, which we’ll cover in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The function then ensures that a microtask is scheduled to process the root
    schedule. This is done by calling `scheduleImmediateTask(processRootScheduleInMicrotask)`.
    This scheduling happens both within and outside of React’s `act` testing utility
    scope, indicated by `__DEV__` and `ReactCurrentActQueue.current`.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant part of this function is the conditional block checking
    the `enableDeferRootSchedulingToMicrotask` flag. If this flag is disabled, the
    function schedules the render task immediately instead of deferring it to a microtask.
    This part is marked with a `TODO` comment (at the time of writing), indicating
    future plans to enable this feature for unlocking additional functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the function includes a condition for handling legacy updates within
    React’s `act` utility. This is specific to testing scenarios where updates are
    batched differently, and it records whenever a legacy update is scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: The long and short of this is that `ensureRootIsScheduled` is a sophisticated
    function that integrates several aspects of React’s scheduling and rendering logic,
    focusing on efficiently managing updates to React roots and ensuring smooth rendering
    by strategically scheduling tasks and microtasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'From this, we understand the role of the scheduler in React: scheduling work
    based on the render lanes that work falls into. We get pretty deep into lanes
    in the next section, but for now, suffice it to say that lanes are indicative
    of an update’s priority.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we model the scheduler’s behavior in code, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'From this, we see that:'
  prefs: []
  type: TYPE_NORMAL
- en: If the next lane is `Sync`, then the scheduler queues a microtask to process
    the next lane immediately. Ideally, by now we understand what microtasks are and
    how this fits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the next lane is not `Sync`, then the scheduler schedules a callback and
    processes the next lane.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, the scheduler is exactly what it sounds like: a system that schedules
    functions to run determined by that function’s lane. OK, we’ve been talking about
    lanes for a while. Let’s dive in and understand them in detail!'
  prefs: []
  type: TYPE_NORMAL
- en: Render Lanes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Render lanes are an essential part of React’s scheduling system, which ensures
    efficient rendering and prioritization of tasks. A lane is a unit of work that
    represents a priority level and can be processed by React as part of its rendering
    cycle. The concept of render lanes was introduced in React 18, replacing the previous
    scheduling mechanism that used expiration times. Let’s dive into the details of
    render lanes, how they work, and their underlying representation as bitmasks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once again, these are implementation details in React that may change at any
    time. The point here is to understand the underlying mechanism that will help
    us in our everyday engineering work, and will also help us understand how React
    works and enable us to use it more effectively or fluently. It would serve us
    well to not get hung up on the details, but to instead stick to the mechanism
    and its potential for real-world application.
  prefs: []
  type: TYPE_NORMAL
- en: First off, a render lane is a lightweight abstraction that React uses to organize
    and prioritize updates that need to be made during the rendering process.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when you call `setState`, that update is put into a lane. We can
    understand the different priorities based on the context of the updates, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: If `setState` is called inside of a click handler, it is put into the Sync lane
    (highest priority) and scheduled in a microtask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `setState` is called inside a transition from `startTransition`, it’s put
    in a transition lane (lower priority) and scheduled in a microtask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each lane corresponds to a specific priority level, with higher-priority lanes
    processed before lower-priority lanes. Some examples of lanes in React are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SyncHydrationLane`'
  prefs: []
  type: TYPE_NORMAL
- en: When users click on a React app during hydration, the click event is put into
    this lane.
  prefs: []
  type: TYPE_NORMAL
- en: '`SyncLane`'
  prefs: []
  type: TYPE_NORMAL
- en: When users click on a React app, the click event is put into this lane.
  prefs: []
  type: TYPE_NORMAL
- en: '`InputContinuousHydrationLane`'
  prefs: []
  type: TYPE_NORMAL
- en: Hover events, scroll events, and other continuous events during hydration are
    put into this lane.
  prefs: []
  type: TYPE_NORMAL
- en: '`InputContinuousLane`'
  prefs: []
  type: TYPE_NORMAL
- en: Same as the preceding, but for after a React app is hydrated.
  prefs: []
  type: TYPE_NORMAL
- en: '`DefaultLane`'
  prefs: []
  type: TYPE_NORMAL
- en: Any updates from the network, timers like `setTimeout`, and the initial render
    where priority isn’t inferred are put into this lane.
  prefs: []
  type: TYPE_NORMAL
- en: '`TransitionHydrationLane`'
  prefs: []
  type: TYPE_NORMAL
- en: Any transitions from `startTransition` during hydration are put into this lane.
  prefs: []
  type: TYPE_NORMAL
- en: '`TransitionLanes` (1–15)'
  prefs: []
  type: TYPE_NORMAL
- en: Any transitions from `startTransition` after hydration are put into these lanes.
  prefs: []
  type: TYPE_NORMAL
- en: '`RetryLanes` (1–4)'
  prefs: []
  type: TYPE_NORMAL
- en: Any Suspense retries are put into these lanes.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that these lanes are indicative of React’s internal implementation
    at the time of writing and are subject to change. To reiterate, the point of this
    book is to understand the *mechanism* by which React works without being too married
    to the exact implementation details, so the names of lanes likely don’t matter
    too much. What matters infinitely more is our understanding of the mechanism—that
    is, how React uses the concept—and how we can apply it to our work.
  prefs: []
  type: TYPE_NORMAL
- en: How Render Lanes Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a component updates or a new component is added to the render tree, React
    assigns a lane to the update based on its priority using the lanes we previously
    discussed. As we know, the priority is determined by the type of update (e.g.,
    user interaction, data fetching, or background task) and other factors, such as
    the component’s visibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'React then uses the render lanes to schedule and prioritize updates in the
    following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. Collect updates
  prefs: []
  type: TYPE_NORMAL
- en: React collects all the updates that have been scheduled since the last render
    and assigns them to their respective lanes based on their priority.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Process lanes
  prefs: []
  type: TYPE_NORMAL
- en: React processes the updates in their respective lanes, starting with the highest
    priority lane. Updates in the same lane are batched together and processed in
    a single pass.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Commit phase
  prefs: []
  type: TYPE_NORMAL
- en: After processing all the updates, React enters the commit phase, where it applies
    the changes to the DOM, runs effects, and performs other finalization tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Repeat
  prefs: []
  type: TYPE_NORMAL
- en: The process repeats for each render, ensuring that updates are always processed
    in priority order, and that high-priority updates are not starved by lower-priority
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: React takes care of assigning updates to the correct lanes based on these priorities,
    allowing the application to function efficiently without manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an update is triggered, React performs the following steps to determine
    its priority and assign it to the correct lane:'
  prefs: []
  type: TYPE_NORMAL
- en: 1. Determine the update’s context
  prefs: []
  type: TYPE_NORMAL
- en: React evaluates the context in which the update was triggered. This context
    could be a user interaction, an internal update due to state or props changes,
    or even an update that’s a result of a server response. The context plays a crucial
    role in determining the priority of the update.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Estimate priority based on the context
  prefs: []
  type: TYPE_NORMAL
- en: Based on the context, React estimates the priority of the update. For instance,
    if the update is a result of user input, it’s likely to have a higher priority,
    while an update triggered by a noncritical background process might have a lower
    priority. We’ve already discussed the different priority levels in detail, so
    we won’t go into more detail here.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Check for any priority overrides
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, developers can explicitly set the priority of an update using
    React’s `useTransition` or `useDeferredValue` hooks. If such a priority override
    is present, React will consider the provided priority instead of the estimated
    one.
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Assign the update to the correct lane
  prefs: []
  type: TYPE_NORMAL
- en: Once the priority is determined, React assigns the update to the corresponding
    lane. This process is done using the bitmask we just looked at, which allows React
    to efficiently work with multiple lanes and ensure that updates are correctly
    grouped and processed.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this process, React relies on its internal heuristics and the context
    in which updates occur to make informed decisions about their priorities. This
    dynamic assignment of priorities and lanes allows React to balance responsiveness
    and performance, ensuring that applications function efficiently without manual
    intervention from developers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look into how exactly React processes updates in their respective lanes.
  prefs: []
  type: TYPE_NORMAL
- en: Processing Lanes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once updates have been assigned to their respective lanes, React processes
    them in priority order. In our chat application example, React would process updates
    in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImmediatePriority`'
  prefs: []
  type: TYPE_NORMAL
- en: Process updates to the message input, ensuring it remains responsive and updates
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '`UserBlockingPriority`'
  prefs: []
  type: TYPE_NORMAL
- en: Process updates to the typing indicator, providing users with real-time feedback.
  prefs: []
  type: TYPE_NORMAL
- en: '`NormalPriority`'
  prefs: []
  type: TYPE_NORMAL
- en: Process updates to the message list, displaying new messages and updates at
    a reasonable pace.
  prefs: []
  type: TYPE_NORMAL
- en: By processing updates in priority order, React ensures that the most important
    parts of the application remain responsive even under heavy load.
  prefs: []
  type: TYPE_NORMAL
- en: Commit Phase
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After processing all the updates in their respective lanes, React enters the
    commit phase, where it applies the changes to the DOM, runs effects, and performs
    other finalization tasks. In our chat application example, this might include
    updating the message input value, showing or hiding the typing indicator, and
    appending new messages to the message list. React then moves on to the next render
    cycle, repeating the process of collecting updates, processing lanes, and committing
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process, however, is exceedingly more complex than we can truly appreciate
    in this book: there are concepts like *entanglement*, which decides when two lanes
    need to be processed together, and further concepts like *rebasing*, which decides
    when an update needs to be rebased on top of updates that have already been processed.
    Rebasing is useful, for example, in cases where a transition is interrupted by
    a sync update before it finished, and you need to run both together.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a lot to say here about flushing effects. For example, like when
    there is a synchronous update, React may flush effects before/after the update
    to ensure consistent ordering of state between sync updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ultimately, this is why React exists, and the true value React adds behind
    the scenes as an abstraction layer: it fundamentally handles the update problems,
    their prioritization, and their ordering for us, while we continue to focus on
    our applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that while React is good at estimating priorities, it’s
    not always perfect. As a developer, you may sometimes need to override the default
    priority assignments using some of the APIs we’ve mentioned so far: `useTransition`
    and `useDeferredValue` to fine-tune your application’s performance and responsiveness.
    Let’s dive into these APIs in more detail.'
  prefs: []
  type: TYPE_NORMAL
- en: useTransition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`useTransition` is a powerful React Hook that allows you to manage the priority
    of state updates in your components and prevent the UI from becoming unresponsive
    due to high-priority updates. It’s particularly useful when dealing with updates
    that can be visually disruptive, such as loading new data or navigating between
    pages.'
  prefs: []
  type: TYPE_NORMAL
- en: It essentially puts whatever update you wrap in its returned `startTransition`
    function into the transition lane, which is lower priority than the Sync lane
    as we’ve seen earlier, allowing you to control the timing of updates and maintain
    a smooth user experience, even when other higher-priority updates are competing
    for the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: '`useTransition` is a hook, meaning you can only use it inside function components.
    It returns an array containing two elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isPending`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A boolean indicating whether a transition is in progress. One interesting part
    about the way `useTransition` works is that the first thing it does when you call
    `startTransition` is schedule a sync `setState({ isPending: false })` on this
    property, which means updates depending on `isPending` need to be fast or it defeats
    the purpose of `useTransition`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`startTransition`'
  prefs: []
  type: TYPE_NORMAL
- en: A function that you can use to wrap updates that should be deferred or given
    a lower priority.
  prefs: []
  type: TYPE_NORMAL
- en: It’s probably worth mentioning here that there is also a `startTransition` API
    that is available not as a hook, but as a regular function. The second way to
    start a nonurgent transition is by using the function `startTransition` imported
    directly from React. This approach doesn’t give us access to the `isPending` flag,
    but it’s available for places in your code when you can’t use hooks, like `useTransition`,
    but still want to signal a low-priority update to React.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s a simple example that demonstrates the basic usage of `useTransition`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `useTransition` to manage the priority of a state update
    that increments a counter. By wrapping the `setCount` update inside the `startTransition`
    function, we are telling React that this update can be deferred, preventing the
    UI from becoming unresponsive if there are other high-priority updates happening
    simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Advanced Example: Navigation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useTransition` is also useful when navigating between pages. By managing the
    priority of updates related to navigation, you can ensure that the user experience
    remains smooth and responsive, even when dealing with complex page transitions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example where we demonstrate how to use `useTransition` for managing
    page transitions in a single-page application (SPA):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have two simple components representing different pages
    in our SPA. We use `useTransition` to wrap the state update that changes the current
    page, ensuring that the page transition is deferred if there are other high-priority
    updates (like user input) happening simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you might be thinking, “Wait, shouldn’t the page transition
    be instant though since it happens in response to a user click?” Yes, you’d be
    right; however, if the next page requires some data to be fetched using `Suspense`,
    then the page transition might be delayed. This is where `useTransition` comes
    in handy, as it allows you to manage the priority of updates related to navigation,
    ensuring that the user experience remains smooth and responsive, even when dealing
    with complex page transitions. It’s worth noting that if the next page data fetching
    happens in an effect, then `startTranstion` won’t wait for the data in the effect
    to be fetched; however, when you suspend inside of a transition, React will tie
    the `isPending` state to the data fetch and the rendering of that data when it
    comes back.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `isPending` state will be `true` while the page transition
    is in progress, allowing us to immediately show a loading indicator to the user
    in response to their button click. Once the transition is complete, the `isPending`
    state will be `false`, and the new page will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Diving Deeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the background knowledge of React’s Fiber architecture, the React scheduler,
    priority levels, and the render lanes mechanism, we can now delve into the inner
    workings of the `useTransition` hook.
  prefs: []
  type: TYPE_NORMAL
- en: The `useTransition` hook works by creating a transition and assigning a specific
    priority level to the updates made within that transition. When an update is wrapped
    in a transition, React ensures that the update gets scheduled and rendered based
    on the assigned priority level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an overview of the steps involved in using the `useTransition` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: Import and invoke the `useTransition` hook within a functional component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The hook returns an array with two elements: the first is the `isPending` state,
    and the second is the `startTransition` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `startTransition` function to wrap any state update or component rendering
    that you want to control the timing of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `isPending` state provides an indicator of whether the transition is still
    in progress or has completed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React ensures that updates wrapped in a transition are treated with the appropriate
    priority level. This is achieved by using the scheduler and render lanes mechanism
    to assign and manage the updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By using `useTransition`, we can effectively control the timing of updates and
    maintain a smooth user experience, even when other higher-priority updates are
    competing for the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: useDeferredValue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`useDeferredValue` is a React Hook that allows for the deferral of certain
    UI updates to a later time, especially useful in scenarios where the application
    is dealing with a heavy load or computationally intensive tasks, thereby aiding
    in managing update prioritization and promoting smoother transitions and an improved
    user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: During the initial render, the returned deferred value is the same as the supplied
    value. In subsequent updates, `useDeferredValue` helps maintain a smooth user
    experience by keeping the old value for a longer duration before updating to the
    new value, particularly in scenarios with computationally intensive operations.
    This does not entail multiple rerenders with old and new values, but a controlled
    update to the new value. This mechanism is akin to a `stale-while-revalidate`
    strategy, holding on to stale values to keep the UI responsive while awaiting
    new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking through React’s commit history, we see that the first implementation
    of `useDeferredValue` looked something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Let’s chat a bit about what this code is doing. Initially, it sets up a state
    (`newValue`) with the initial value passed to it. The function then utilizes the
    `useEffect` hook to observe changes in this value. When a change is detected,
    the `startTransition` function is invoked, which is crucial for deferring the
    update.
  prefs: []
  type: TYPE_NORMAL
- en: Within `startTransition`, the state is updated to the new value using `setNewValue`.
    The use of `startTransition` signifies to React that this update is not urgent,
    allowing React to prioritize other, more critical updates first. This is more
    or less exactly how `useDeferredValue` works today and should be helpful for our
    mental model of it.
  prefs: []
  type: TYPE_NORMAL
- en: '`useDeferredValue` is a part of React’s concurrent features that enables interruptibility
    by allowing certain state updates to be deferred.'
  prefs: []
  type: TYPE_NORMAL
- en: When a component rerenders with a deferred value, React keeps showing the old
    value for a certain period, allowing high-priority updates to be processed before
    low-priority ones. This breaks up the rendering work into smaller chunks, which
    can be spread out over time, improving responsiveness and ensuring that high-priority
    updates (like user interactions) are not delayed by lower-priority updates, hence
    boosting positive user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose of useDeferredValue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary purpose of `useDeferredValue` is to allow you to defer the rendering
    of less critical updates. This is particularly useful when you want to prioritize
    more important updates, such as user interactions, over less critical ones, such
    as displaying updated data from the server.
  prefs: []
  type: TYPE_NORMAL
- en: By using `useDeferredValue`, you can provide a smoother user experience and
    ensure that your application remains responsive even under heavy load or when
    dealing with complex operations.
  prefs: []
  type: TYPE_NORMAL
- en: To use `useDeferredValue`, you will need to import it from the React package
    and pass a value to be deferred as its argument. The hook will then return a deferred
    version of the value that can be used in your component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how to use `useDeferredValue` in a simple application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have a search input and a `SearchResults` component that
    displays the results. We use `useDeferredValue` to defer the rendering of the
    search results, allowing the application to prioritize user input and remain responsive
    even when rendering the list of results is expensive. Let’s understand this in
    a little more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We use `memo` on the component to make sure it doesn’t unnecessarily update,
    as we’ve discussed in prior chapters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it updates, it causes performance problems because it’s expensive to render.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we give it a deferred prop, `deferredSearchValue`, since the prop itself
    is updated after more urgent rendering work, so is the component. Thus, the component
    only rerenders when there’s no more urgent work to be done, like updating the
    text input field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One might ask here, “Why not just debounce or throttle `searchValue`?”
  prefs: []
  type: TYPE_NORMAL
- en: 'Great question. Let’s contrast those here:'
  prefs: []
  type: TYPE_NORMAL
- en: Debouncing
  prefs: []
  type: TYPE_NORMAL
- en: Involves a pause before updating the list, waiting for the user to finish typing,
    such as a delay of one second
  prefs: []
  type: TYPE_NORMAL
- en: Throttling
  prefs: []
  type: TYPE_NORMAL
- en: Updates the list at regular intervals, say, no more than once per second
  prefs: []
  type: TYPE_NORMAL
- en: While these methods can be effective in certain situations, `useDeferredValue`
    emerges as a more tailored solution for rendering optimization since it adapts
    seamlessly to the performance capabilities of the user’s device and isn’t some
    arbitrary delay.
  prefs: []
  type: TYPE_NORMAL
- en: The key difference with `useDeferredValue` lies in its dynamic approach to delays.
    It eliminates the need for setting a fixed delay time. On a high-performance device,
    such as a powerful laptop, the delay in rerendering is almost imperceptible, occurring
    almost instantaneously. Conversely, on slower devices, the rendering delay adjusts
    accordingly, causing the list to update with a slight lag in response to the input,
    proportional to the device’s speed.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, `useDeferredValue` has a significant advantage in its ability to interrupt
    deferred rerenders. In scenarios where React is processing a substantial list,
    and the user enters a new keystroke, React can pause the rerendering, respond
    to the new input, and then resume the rendering process in the background. This
    is a contrast to debouncing and throttling, which, despite delaying updates, can
    still lead to a disjointed experience as they block interactivity during rendering.
  prefs: []
  type: TYPE_NORMAL
- en: That said, debouncing and throttling are still useful in scenarios not directly
    related to rendering. For instance, they can be effective in reducing the frequency
    of network requests. These techniques can also be used in conjunction with `useDeferredValue`
    for a comprehensive optimization strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on all of this, we see several advantages to using `useDeferredValue`
    in React applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Improved responsiveness
  prefs: []
  type: TYPE_NORMAL
- en: In the example, when the user types into the search box, the input field updates
    immediately and the results are deferred. If the user quickly types five characters
    in a row, the input field updates immediately five times, and the `searchResults`
    are only rendered once, after the user stops typing. For characters 1–4, the rendering
    of `SearchResults` is interrupted by the new values.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative prioritization
  prefs: []
  type: TYPE_NORMAL
- en: '`useDeferredValue` provides a simple and declarative way to manage the prioritization
    of updates in your application. By encapsulating the logic for deferring updates
    within the hook, you can keep your component code clean and focused on the essential
    aspects of your app.'
  prefs: []
  type: TYPE_NORMAL
- en: Better resource utilization
  prefs: []
  type: TYPE_NORMAL
- en: By deferring less critical updates, `useDeferredValue` allows your application
    to make better use of available resources. This can help reduce the likelihood
    of performance bottlenecks and improve the overall performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use useDeferredValue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useDeferredValue` is most useful in situations where your application needs
    to prioritize certain updates over others. Some common scenarios where you might
    consider using `useDeferredValue` include:'
  prefs: []
  type: TYPE_NORMAL
- en: Searching or filtering large data sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering complex visualizations or animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating data from a server in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling computationally expensive operations that could impact user interactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a look at an example where `useDeferredValue` can be particularly
    useful. Imagine we have a large list of items that we want to filter based on
    user input. Filtering a large list can be computationally expensive, so using
    `useDeferredValue` can help keep the application responsive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use `useDeferredValue` to defer the rendering of the filtered
    list. As the user types in the filter input, the deferred value updates less frequently,
    allowing the application to prioritize the user input and remain responsive.
  prefs: []
  type: TYPE_NORMAL
- en: The `useMemo` hooks are used to memoize the items and `filteredItems` arrays,
    preventing unnecessary rerendering and recalculations. This further improves the
    performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: When Not to Use useDeferredValue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `useDeferredValue` can be beneficial in certain scenarios, it’s important
    to recognize the trade-offs. Namely, by deferring updates, there’s a possibility
    that the data displayed to the user might be slightly out-of-date. While this
    is usually acceptable for less critical updates, it’s important to consider the
    implications of displaying stale data to users.
  prefs: []
  type: TYPE_NORMAL
- en: A good question to ask yourself when deciding whether to use `useDeferredValue`
    or not is, “Is this update user input?”
  prefs: []
  type: TYPE_NORMAL
- en: 'React is called React for a reason: it enables our web applications to react
    to things. Anything that causes a user to expect a reaction ought not be deferred.
    Everything else should be.'
  prefs: []
  type: TYPE_NORMAL
- en: While the usage of `useDeferredValue` can greatly enhance your application’s
    responsiveness under load, it should not be seen as a magic bullet. Always remember
    that the best way to improve performance is to write efficient code and avoid
    unnecessary computations.
  prefs: []
  type: TYPE_NORMAL
- en: Problems with Concurrent Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrent rendering, while allowing for performant and responsive user interactions,
    presents new problems for developers to consider. The main problem is that it’s
    difficult to reason about the order in which updates will be processed, which
    can lead to unexpected behavior and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: One such bug is called *tearing*, where the UI becomes inconsistent due to updates
    being processed out of order. This can happen when a component depends on some
    value that is updated while it’s still rendering, causing applications to be rendered
    with inconsistent data. Let’s dive into this a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: Tearing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tearing is a bug that occurs when a component depends on some state that is
    updated while the application is still rendering. To understand this, let’s contrast
    synchronous rendering with concurrent rendering.
  prefs: []
  type: TYPE_NORMAL
- en: In a synchronous world, React would walk down a tree of components and render
    them one by one, from top to bottom. This ensures that the state of the application
    is consistent throughout the rendering process, as each component is rendered
    with the latest state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'At the very top of our app, we have `count`: a variable that we set globally
    and keep updating via `setInterval` outside of the React render cycle so that
    we can simulate a tearing bug by having it update while the application is rendering.
    Since rendering is concurrent and interruptible, it’s possible for the `ExpensiveComponent`
    to be rendered with different values for `count`, resulting in inconsistent data
    being displayed to the user, or tearing.'
  prefs: []
  type: TYPE_NORMAL
- en: We expect to see inconsistent values for `count` rendered inside `ExpensiveComponent`
    as React “stops” rendering on user input to prioritize a more urgent update, like
    updating the text input field, thereby leaving a stale value of `count` in the
    `ExpensiveComponent`, but only sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: Our example renders a text input field and a list of five `ExpensiveComponent`s.
    These components are not memoized intentionally to illustrate a point here, as
    they cause performance problems and we need these performance problems, to identify
    tearing for the purposes of understanding it. In the real world, you’ll want to
    wrap `ExpensiveComponent` in `React.memo`. Here, we’re intentionally avoiding
    this to demonstrate tearing—which you’ll want to avoid in your application.
  prefs: []
  type: TYPE_NORMAL
- en: '`ExpensiveComponent` takes a long time to render, simulating a computationally
    expensive operation. The `ExpensiveComponent` also displays the current value
    of the `count` variable, which is incremented every millisecond and read from
    an external store, in this case the global namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: If we run this example, we’ll see that for the five instances of `ExpensiveComponent`
    that we render, after typing a few keystrokes in the `input`, the `ExpensiveComponent`s
    will render with different values for `count`.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the `ExpensiveComponent` is rendered five times, and each time
    it’s rendered, the value of `count` is different. Since React is rendering the
    components concurrently, it’s possible for the `ExpensiveComponent` to be rendered
    with different values for `count`, resulting in inconsistent data displayed to
    the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is called tearing, and it’s a bug that can occur when a component depends
    on some state that is updated while the application is still rendering. In this
    case, the `ExpensiveComponent` depends on the `count` variable, which is updated
    while the component is still rendering, causing the application to be rendered
    with inconsistent data. With tearing, we see the following output for the five
    instances of `ExpensiveComponent`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Expensive count is 568`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expensive count is 568`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expensive count is 569`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expensive count is 569`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expensive count is 570`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This makes sense because earlier instances of the component are rendered, the
    updated `count` value is flushed/committed to the DOM, and lower instances continue
    to be rendered and yielded (flushed, updated) with newer values of `count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn’t a huge deal because React will eventually render the consistent
    state. The bigger issue is when you have something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this code, if the user is deleted from the global store between renders,
    this will throw a sudden error that can surprise a user. This is why tearing is
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this problem of tearing, React exposes a hook called `useSyncExternalStore`.
    Let’s dive into this hook.
  prefs: []
  type: TYPE_NORMAL
- en: useSyncExternalStore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`useSyncExternalStore` is a React Hook that allows you to synchronize external
    state with the internal state of your application. It’s particularly useful when
    dealing with computationally expensive operations that might cause tearing if
    not handled properly. The “sync” in `useSyncExternalStore` has a double meaning.
    It’s “synchronize,” but it’s also “synchronous”: it forces a synchronous update
    when the store changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `useSyncExternalStore` hook has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`store.subscribe`'
  prefs: []
  type: TYPE_NORMAL
- en: A function that receives a callback function as its first and only argument.
    Inside this function, you can subscribe to changes in the external store and call
    the callback function whenever the store changes. The callback can be considered
    a call to prompt React to rerender the component with the new value. The expected
    return of this function is a cleanup function that unsubscribes from the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical `subscribe` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple use case for this would be subscribing to browser events, such as
    `resize` or `scroll` events, and updating the component when these events occur,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, our React components would rerender whenever the browser window is resized.
    However, how does it get the new value? That’s where the second argument to `useSyncExternalStore`
    comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '`store.getSnapshot`'
  prefs: []
  type: TYPE_NORMAL
- en: A function that returns the current value of the external store. This function
    is called whenever the component is rendered, and the returned value is used to
    update the component’s internal state. This function is called synchronously,
    so it should not perform any asynchronous operations or have any side effects.
    Moreover, this function ensures the state at render time is consistent across
    multiple instances of the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'To follow our window resize example, this is how we would get the current window
    size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The object with `{ width, height }` is the snapshot of the current state of
    the window, and it’s what `useSyncExternalStore` will return. We can then use
    this object in our component with confidence that its state will always be consistent
    across concurrent renders.
  prefs: []
  type: TYPE_NORMAL
- en: How can we have this confidence? It’s because the `immediatelyRerenderSynchronously`
    function forces a synchronous rerender and does not allow React to defer it. This
    is the key to solving tearing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at how we can use `useSyncExternalStore` to solve the
    tearing problem in our previous example. If we recall, we saw a list of `ExpensiveComponent`s
    that rendered with different values for `count` due to tearing. Let’s see how
    we can fix this using `useSyncExternalStore`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For starters, we don’t want to subscribe to the store and have React rerender
    when updates happen; but instead we want consistent state when rerenders happen
    due to user input. So our `subscribe` function will be empty, but to get consistent
    state, we’ll use the `getSnapshot` function to get the current value of `count`
    and return it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what our previous example will look like with `useSyncExternalStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we run this example, we will see that the `ExpensiveComponent`s render
    with the same value for `count`, preventing tearing from occurring. This is because
    the `useSyncExternalStore` hook ensures that the state at render time is consistent
    across multiple instances of the component.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t use a `subscribe` function because its purpose is to tell React when
    to rerender with the latest state, but in our case we just want state to be consistent
    across renders. We use the `getSnapshot` function to get the current value of
    `count` and return it, ensuring that the state at render time is consistent across
    multiple instances of the component.
  prefs: []
  type: TYPE_NORMAL
- en: This is how we can use `useSyncExternalStore` to solve the tearing problem in
    our previous example, ensuring that the state at render time is consistent across
    multiple instances of the component.
  prefs: []
  type: TYPE_NORMAL
- en: OK, this ensures that when the text input changes and `ExpensiveComponent` rerenders,
    it will have the same value of `count` as the other instances of `ExpensiveComponent`,
    preventing tearing—but what if we wanted to update `count` inside `ExpensiveComponent`
    at the same interval that we update `count` outside of `ExpensiveComponent`?
  prefs: []
  type: TYPE_NORMAL
- en: 'We just create a store for this that follows the same update rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, whenever `count` changes, `ExpensiveComponent` will rerender with the
    new value of `count`, and we’ll see the same value for `count` across all instances
    of `ExpensiveComponent`. The change detection logic itself can be as simple or
    as complex as you want it to be, but the key is that we understand the mechanisms
    of how `useSyncExternalStore` does its main things, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring consistent state across concurrent renders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing a synchronous rerender when the store changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we understand how `useSyncExternalStore` works and solves the tearing
    problem, we have a solid grasp not only of concurrent rendering in React but also
    of how to solve some of the problems that come with it. This is a great place
    to be in as a React developer.
  prefs: []
  type: TYPE_NORMAL
- en: This was quite a deep dive, but we’re nearly done. Let’s review.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This comprehensive conversation focused on the deep exploration of concurrent
    React, touching on multiple aspects, including the Fiber Reconciler, scheduling,
    deferring updates, render lanes, and new hooks, such as `useTransition` and `useDeferredValue`.
  prefs: []
  type: TYPE_NORMAL
- en: We began by discussing the Fiber reconciler, the heart of React’s concurrent
    rendering engine. It’s the algorithm behind the framework’s ability to break work
    into smaller chunks and manage the execution priority, allowing React to be “interruptible”
    and support concurrent rendering. This contributes significantly to the ability
    of React to handle complex, high-performance applications smoothly, ensuring user
    interactions remain responsive even during heavy computation.
  prefs: []
  type: TYPE_NORMAL
- en: Then we moved on to the concept of scheduling and deferring updates, which essentially
    allows React to prioritize certain state updates over others. React can defer
    lower-priority updates in favor of higher-priority ones, thus maintaining a smooth
    user experience even under heavy load. An example illustrated a chat application
    where incoming message updates were intelligently scheduled and rendered without
    blocking the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The discussion then moved to render lanes, a central concept in React’s concurrent
    features. Render lanes are a mechanism that React uses to assign priority to updates
    and effectively manage their execution. It’s the secret behind how React decides
    which updates are urgent and need to be processed immediately and which ones can
    be deferred until later. The detailed explanation mentioned how these render lanes
    use bitmasking to efficiently handle multiple priorities.
  prefs: []
  type: TYPE_NORMAL
- en: We then delved into the new hooks introduced for concurrent operations in React,
    `useTransition` and `useDeferredValue`. These hooks are designed to handle transitions
    and provide smoother user experiences, particularly for operations that take a
    considerable amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: The `useTransition` hook was first discussed, which allows React to transition
    between states in a way that ensures a responsive user interface even if the new
    state takes a while to prepare. In other words, it allows for delaying an update
    to the next render cycle if the component is currently rendering.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed the `useDeferredValue` hook, which defers the update of less
    critical parts of a component, thus preventing janky user experience. It essentially
    allows React to “hold on” to the previous value for a little longer if the new
    value is taking too much time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we dove into issues with concurrency, including tearing, and explored
    how `useSyncExternalStore` can help keep state consistent across multiple concurrent
    renders.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the conversation, the recurring theme was understanding the “what”
    and “why” behind React’s strategies for managing complex, dynamic applications
    with heavy computation, and how developers can utilize these strategies to deliver
    a smooth, responsive user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s ask ourselves a few questions to test our understanding of the concepts
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the Fiber reconciler in React, and how does it contribute to the handling
    of complex, high-performance applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the concept of scheduling and deferring updates in React. How does it
    help in maintaining a smooth user experience even under heavy load?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are render lanes in React, and how do they manage the execution of updates?
    Can you describe how render lanes use bitmasking to handle multiple priorities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `useTransition` and `useDeferredValue` hooks in React?
    Describe a situation where each hook would be beneficial.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When might it be inappropriate to use `useDeferredValue`? What are some of the
    trade-offs involved with using these hooks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have a deep understanding of the concurrent features of React and
    its inner workings, you are well equipped to harness its full potential in building
    high-performance applications. In [Chapter 8](ch08.html#ch08), we will explore
    various popular frameworks built on top of React, such as Next.js and Remix, which
    further streamline the development process by providing best practices, conventions,
    and additional features.
  prefs: []
  type: TYPE_NORMAL
- en: These frameworks are designed to help you build complex applications with ease,
    taking care of many common concerns, such as server rendering, routing, and code
    splitting. By leveraging the power of these frameworks, you can focus on building
    your application’s features and functionality while ensuring optimal performance
    and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Stay tuned for an in-depth exploration of these powerful frameworks, and learn
    how to build scalable, performant, and feature-rich applications using React and
    its ecosystem.
  prefs: []
  type: TYPE_NORMAL
