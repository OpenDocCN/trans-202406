<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Secure Remote Access with OpenSSH"><div class="chapter" id="cha-ssh">
<h1><span class="label">Chapter 12. </span>Secure Remote Access with OpenSSH</h1>


<p>OpenSSH is <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="purpose of" id="idm46466157635960"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="purpose of" id="idm46466157634872"/><a data-type="indexterm" data-primary="remote access" data-see="OpenSSH; OpenVPN" id="idm46466157634024"/><a data-type="indexterm" data-primary="secure remote access" data-see="OpenSSH; OpenVPN" id="idm46466157633176"/><a data-type="indexterm" data-primary="SSH" data-see="OpenSSH" id="idm46466157632104"/>the tool of choice for secure remote administration. It encrypts
authentication and all traffic during a session, and guarantees the integrity
of the data transfer. If something happens to alter your packets, SSH will tell
you. In this chapter you will learn how to set up SSH access to remote hosts,
manage your SSH encryption keys, configure logins to multiple remote hosts,
customize your Bash prompt to show when it is an SSH session, and more good
things.</p>

<p>OpenSSH supports<a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="encryption algorithms" id="idm46466157629896"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="encryption algorithms" id="idm46466157628808"/><a data-type="indexterm" data-primary="encryption" data-secondary="in OpenSSH" data-secondary-sortas="OpenSSH" id="idm46466157627960"/> a large number of strong encryption algorithms. All of them
are unencumbered by patents because the OpenSSH team has gone to great lengths
to ensure that no patented or otherwise encumbered code is inside OpenSSH.
<a data-type="xref" href="#rec-list-algorithms">Recipe 12.16</a> shows how to print lists of all supported algorithms.</p>

<p>OpenSSH is<a data-type="indexterm" data-primary="OpenSSH" data-secondary="utilities in" id="openssh-utilities"/> a suite of remote transfer utilities:</p>

<ul>
<li>
<p><em>sshd</em>, the<a data-type="indexterm" data-primary="sshd" id="idm46466157620856"/> OpenSSH server daemon.</p>
</li>
<li>
<p><em>ssh</em>, short<a data-type="indexterm" data-primary="ssh command" id="idm46466157619192"/> for secure shell, though it doesn’t really include a shell,
but provides a secure channel to the command shell on the remote system.</p>
</li>
<li>
<p><em>scp</em>, secure <a data-type="indexterm" data-primary="scp command" id="idm46466157617320"/>copy, for encrypted file transfer.</p>
</li>
<li>
<p><em>sftp</em>, Secure<a data-type="indexterm" data-primary="sftp command" id="idm46466157615320"/> File Transfer Protocol, provides file access.</p>
</li>
<li>
<p><em>ssh-copy-id</em>, a <a data-type="indexterm" data-primary="ssh-copy-id command" id="idm46466157613144"/>nice little program for installing your public key to a remote SSH server’s <em>authorized_keys</em> file.</p>
</li>
<li>
<p><em>ssh-keyscan</em>, finds<a data-type="indexterm" data-primary="ssh-keyscan command" id="idm46466157610648"/> and collects public host keys on a network, saving
you the trouble of hunting them down manually.</p>
</li>
<li>
<p><em>ssh-keygen</em>, <a data-type="indexterm" data-primary="ssh-keygen command" id="idm46466157608760"/>generates and manages authentication keys.</p>
</li>
<li>
<p><em>ssh-add</em>, adds <a data-type="indexterm" data-primary="ssh-add command" id="idm46466157606472"/>your identities to the authentication agent,
<em>ssh-agent</em>.</p>
</li>
</ul>

<p>In this chapter you will learn about <em>ssh</em>, <em>sshd</em>, <em>ssh-copy-id</em>,
<em>ssh-keygen</em>, and two useful related utilities: <em>sshfs</em> and
<em>ssh-agent</em>.</p>

<p><em>sshfs</em> mounts<a data-type="indexterm" data-primary="sshfs command" id="idm46466157601704"/> remote filesystems on your local PC, while
<em>ssh-agent</em> remembers<a data-type="indexterm" data-primary="ssh-agent command" id="idm46466157600168"/> the passphrases on your private SSH keys over multiple
SSH logins for automatic authentication. <em>ssh-agent</em> binds to a single login
session, so logging out or opening another terminal means starting over. A
better utility for automated operations is<a data-type="indexterm" data-primary="Keychain" id="idm46466157597048"/> Keychain, which is a frontend
to <em>ssh-agent</em>. Keychain reuses <em>ssh-agent</em> until you restart your machine,
so you only have to enter your passphrases at<a data-type="indexterm" data-primary="OpenSSH" data-secondary="utilities in" data-startref="openssh-utilities" id="idm46466157595448"/> startup (see <a data-type="xref" href="#rec-keychain">Recipe 12.10</a>).</p>

<p>OpenSSH supports <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="types of" id="idm46466157594168"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="authentication types" id="idm46466157593080"/>different types of authentication:</p>
<dl>
<dt>Password authentication</dt>
<dd>
<p>Uses <a data-type="indexterm" data-primary="password authentication in OpenSSH" id="idm46466157590072"/>your Linux login and password to authenticate.
This is the simplest and the most flexible, because you can log in from any
machine. You must be careful to not open an SSH session from an untrustworthy
computer, like in a library or internet cafe. If it is infected with a keylogger, it will capture your credentials.</p>
</dd>
<dt>Public key authentication</dt>
<dd>
<p>Authenticates
with your personal SSH public keys,<a data-type="indexterm" data-primary="public key authentication in OpenSSH" id="idm46466157587032"/> not your system login. This is a bit more work to set up because
you need to create and distribute your public keys, and you can log in only from
machines that hold your private key. Some commercial services require customers
to use some form of public key authentication.</p>
</dd>
<dt>Passphrase-less authentication</dt>
<dd>
<p>Public<a data-type="indexterm" data-primary="passphrase-less authentication in OpenSSH" id="idm46466157583032"/> key authentication without a
passphrase. This is useful for automated services, like scripts and cron jobs.
Anyone who succeeds in thieving the private key can easily masquerade as you, so
you need to be very protective of a passphrase-less private key.</p>
</dd>
</dl>

<p>An alternative to using keys without passphrases is Keychain, which remembers
your private keys for you (see <a data-type="xref" href="#rec-keychain">Recipe 12.10</a>).</p>

<p>There are two different uses for authentication keys: host keys, which<a data-type="indexterm" data-primary="host keys" data-secondary="purpose of" id="idm46466157581064"/><a data-type="indexterm" data-primary="public keys" id="idm46466157580216"/><a data-type="indexterm" data-primary="private keys" data-secondary="purpose of" id="idm46466157579320"/>
authenticate computers, and public keys, which authenticate users. SSH keys
come in pairs, private and public. Transmissions are encrypted with the public
key and decrypted with the private key, a brilliantly simple scheme. You can
safely distribute your public keys as much as you want, while you must protect
your private key and not let anyone else have it.</p>

<p>Server and client are defined by the direction of the transaction. The server
has the SSH daemon running and listening for connection requests, and the
client is anyone logging in to this machine via SSH.</p>






<section data-type="sect1" data-pdf-bookmark="12.1 Installing OpenSSH Server"><div class="sect1" id="idm46466157585128">
<h1>12.1 Installing OpenSSH Server</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157574232">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="OpenSSH" data-secondary="server installation" id="idm46466157578024"/><a data-type="indexterm" data-primary="servers" data-secondary="OpenSSH" data-tertiary="installing" id="idm46466157577176"/><a data-type="indexterm" data-primary="installing" data-secondary="OpenSSH server" id="idm46466157576056"/><a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="server installation" id="idm46466157572488"/>want to install an OpenSSH server.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157570920">
<h2>Solution</h2>

<p>Most Linux distributions install the OpenSSH client by default, but not always
the server. The different Linux distributions package OpenSSH in different ways,
so use your package manager to list the packages for your Linux (see the
<a data-type="xref" href="app01.xhtml#appendix">Appendix</a>). Install the server, then check if it has started:</p>
<pre>$ <strong>systemctl status sshd</strong>
● sshd.service - OpenSSH Daemon
   Loaded: loaded (/usr/lib/systemd/system/sshd.service; disabled; vendor preset
   Active: inactive (dead)
   [...]</pre>

<p>This shows that the server is not running and is not enabled. On most Linuxes, OpenSSH is not
configured to start automatically after installation. This is good because you
need to configure your server correctly before opening it up to receive connection
requests. If it is running before you have examined the server configuration, stop
it, or block its listening port(s) with your firewall.</p>

<p>The next steps are to set up host encryption keys and configure your
server. See 
<span class="keep-together">Recipes</span> <a data-xrefstyle="select:labelnumber" data-type="xref" href="#rec-gen-host-keys">12.2</a> and <a data-xrefstyle="select:labelnumber" data-type="xref" href="#rec-secure-server-ssh">12.3</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157562680">
<h2>Discussion</h2>

<p>Remember, server and client are not only about hardware, but are defined by the
direction of the transaction. The server<a data-type="indexterm" data-primary="OpenSSH" data-secondary="clients" id="idm46466157559288"/><a data-type="indexterm" data-primary="clients" data-secondary="OpenSSH" id="idm46466157561112"/> has the SSH daemon running and listening
for connection requests, and the client is anyone logging in to the server via SSH.
Any Linux PC can be a server, client, or both.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157559848">
<h2>See Also</h2>

<ul>
<li>
<p><a data-type="xref" href="ch14.xhtml#cha-firewalld">Chapter 14</a></p>
</li>
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p>sshd (8)</p>
</li>
<li>
<p>The <a data-type="xref" href="app01.xhtml#appendix">Appendix</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.2 Generating New Host Keys"><div class="sect1" id="rec-gen-host-keys">
<h1>12.2 Generating New Host Keys</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157550008">
<h2>Problem</h2>

<p>Your<a data-type="indexterm" data-primary="OpenSSH" data-secondary="host keys, generating" id="idm46466157548552"/><a data-type="indexterm" data-primary="host keys" data-secondary="generating" id="idm46466157547704"/><a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="host key generation" id="idm46466157546856"/> Linux distribution does not automatically create host keys at installation,
or you want to replace your existing host keys, or when you clone an
installation or a virtual machine your clones need their own unique host keys.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157545128">
<h2>Solution</h2>

<p>Use the <em>ssh-keygen</em> command. There <a data-type="indexterm" data-primary="ssh-keygen command" id="idm46466157543256"/>are four different types of keys: RSA, DSA, ECDSA, and ED25519. First, delete the old keys, if they exist:</p>
<pre>$ <strong>sudo rm /etc/ssh/ssh_host*</strong></pre>

<p>Create all of the new keys at once with the following command:</p>
<pre>$ <strong>sudo ssh-keygen -A</strong>
ssh-keygen: generating new host keys: RSA DSA ECDSA ED25519</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157544872">
<h2>Discussion</h2>

<p>If you ever get bored and need something to do, try researching “Which SSH key
formats should I use?” The arguments are endless. The short answer is use RSA,
ECDSA, and ED25519, and avoid DSA. Delete your DSA host key and keep the rest.</p>

<p>RSA is the oldest. It is strong and provides the most compatibility.</p>

<p>ECDSA and ED25519 are newer, very strong, and computationally less expensive.</p>

<p>Some older SSH clients do not support ECDSA and ED25519. Hopefully you are not
using such ancient clients, because ECDSA and ED25519 were released with
OpenSSH 6.5 in 2014. It is extremely important to keep security services updated and to not allow unsafe old clients.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157534872">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p>ssh-keygen (1)</p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.3 Configuring Your OpenSSH Server"><div class="sect1" id="rec-secure-server-ssh">
<h1>12.3 Configuring Your OpenSSH Server</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157530776">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="server configuration" id="authenticate-openssh-server-config"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="server configuration" id="openssh-server-config"/><a data-type="indexterm" data-primary="servers" data-secondary="OpenSSH" data-tertiary="configuring" id="server-openssh-config"/><a data-type="indexterm" data-primary="configuring" data-secondary="OpenSSH servers" id="config-openssh-server"/> want to configure your OpenSSH server as securely as possible and test it
safely.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157523544">
<h2>Solution</h2>

<p>First, verify that your server’s private host keys are owned by root, read-only:</p>
<pre>$ <strong>ls -l /etc/ssh/</strong>
-r-------- 1 root root    227 Jun  4 11:30 ssh_host_ecdsa_key
-r-------- 1 root root    399 Jun  4 11:30 ssh_host_ed25519_key
-r-------- 1 root root   1679 Jun  4 11:30 ssh_host_rsa_key</pre>

<p>That is how they are supposed to look. Then check your public keys, which are
owned by root, read-write for root, and read-only for everyone else:</p>
<pre>$ <strong>ls -l /etc/ssh/</strong>
-rw-r--r-- 1 root root    174 Jun  4 11:30 ssh_host_ecdsa_key.pub
-rw-r--r-- 1 root root     94 Jun  4 11:30 ssh_host_ed25519_key.pub
-rw-r--r-- 1 root root    394 Jun  4 11:30 ssh_host_rsa_key.pub</pre>

<p>These are correct.</p>

<p>Now take a look at <em>/etc/ssh/sshd_config</em>. When you change this file, reload
<em>sshd</em> to load your changes:</p>
<pre>$ <strong>sudo systemctl reload sshd.server</strong></pre>

<p>Uncomment the options you want to use or change.</p>

<p>Configure <em>sshd</em> to check if the file modes and ownership of the user’s files and
home directory are correct before accepting their login:</p>

<pre data-type="programlisting">StrictModes yes</pre>

<p>If file permissions are not correct, this setting will not allow them to log
in.</p>

<p>If your machine has more than one IP address, define which address, or
addresses, it listens on:</p>
<pre>ListenAddress <i>192.168.10.15</i>
ListenAddress 1<i>92.168.10.16</i></pre>

<p>You may assign nonstandard ports for <em>sshd</em> to listen on. Use only ports above
1024, and check <em>/etc/services</em> to find unused ports, then add your new ports to
<em>/etc/services</em>:</p>
<pre><i>sshd 2022</i>
<i>sshd 2023</i></pre>

<p>Then add them to <em>/etc/ssh/sshd_config</em>:</p>
<pre>Port <i>2022</i>
Port <i>2023</i></pre>

<p>You can restrict access to only the specified groups (create these groups in
<em>/etc/group</em>):</p>
<pre>AllowGroups <i>webadmins backupadmins</i></pre>

<p>Or deny access with <em>DenyGroups</em>.</p>

<p>Do not allow root logins. It is safer to log in as an unprivileged user, and
then use <em>sudo</em> after login:</p>

<pre data-type="programlisting">PermitRootLogin no</pre>

<p>An alternative is to allow root logins only with public key authentication:</p>

<pre data-type="programlisting">PermitRootLogin prohibit-password</pre>

<p>You can disable password logins for all users, and allow only public key
authentication (see <a data-type="xref" href="#rec-public-key-auth">Recipe 12.7</a>):</p>

<pre data-type="programlisting">PasswordAuthentication no</pre>

<p>You can deny specified users, either by username, or user at hostname or IP address:</p>
<pre>DenyUsers <i>duchess madmax stash@example.com cagney@192.168.10.25</i></pre>

<p>Or allow access with <em>AllowUsers</em>. You may use both, and <em>DenyUsers</em> is
always processed first.</p>

<p>Limit the length of time the server waits for a user to log in and complete the
connection. The default is 120 seconds:</p>

<pre data-type="programlisting">LoginGraceTime 90</pre>

<p>You can limit the number of failed connection attempts. The default is 6:</p>

<pre data-type="programlisting">MaxAuthTries 4</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157494584">
<h2>Discussion</h2>

<p>Any port scanner will find your open ports, and attackers will attempt brute force password cracking. Attackers still target the default SSH port 22 the most.
Changing the port won’t reduce this risk very much, but it should reduce the number
of entries in your log files. When you use alternate port numbers, first look in
<em>/etc/services</em> to find unused ports, and then record the ports you use in this file.</p>

<p>Public key authentication is very strong and cannot be brute-forced like
password logins (see <a data-type="xref" href="#rec-public-key-auth">Recipe 12.7</a>). The trade-off is less
convenience, as you can log in only from machines that have your <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="server configuration" data-startref="authenticate-openssh-server-config" id="idm46466157490392"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="server configuration" data-startref="openssh-server-config" id="idm46466157489560"/><a data-type="indexterm" data-primary="servers" data-secondary="OpenSSH" data-tertiary="configuring" data-startref="server-openssh-config" id="idm46466157488760"/><a data-type="indexterm" data-primary="configuring" data-secondary="OpenSSH servers" data-startref="config-openssh-server" id="idm46466157486152"/>private key.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157484600">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p><em>man 5 sshd_config</em></p>
</li>
<li>
<p><a data-type="xref" href="#rec-host-key-auth">Recipe 12.5</a></p>
</li>
<li>
<p><a data-type="xref" href="#rec-public-key-auth">Recipe 12.7</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.4 Checking Configuration Syntax"><div class="sect1" id="idm46466157477928">
<h1>12.4 Checking Configuration Syntax</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157476680">
<h2>Problem</h2>

<p>Everyone<a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="syntax checking" id="idm46466157475432"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="syntax checking" id="idm46466157474344"/><a data-type="indexterm" data-primary="configuring" data-secondary="OpenSSH servers" data-tertiary="syntax checking" id="idm46466157473496"/><a data-type="indexterm" data-primary="syntax checking OpenSSH configuration" id="idm46466157472280"/> makes mistakes, and you want a syntax checker for
<em>/etc/ssh/sshd_config</em>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157471512">
<h2>Solution</h2>

<p>And you shall have one. After making your changes, run this command:</p>
<pre>$ <strong>sudo sshd -t</strong></pre>

<p>If there are no syntax errors, it exits silently. If it find mistakes, it tells
you:</p>
<pre>$ <strong>sudo sshd -t</strong>
/etc/ssh/sshd_config: line 9: Bad configuration option: Porotocol
/etc/ssh/sshd_config: terminating, 1 bad configuration options</pre>

<p>You can do this while the SSH daemon is running, so you can correct your
mistakes before issuing a reload or restart command.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157466200">
<h2>Discussion</h2>

<p>The <em>-t</em> stands for <em>test</em>. It does not affect the SSH daemon, it only
checks <em>/etc/ssh/sshd_config</em> for syntax errors, so you can use it anytime.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157463624">
<h2>See Also</h2>

<ul class="no-space-list">
<li>
<p><em>man 5 sshd_config</em></p>
</li>
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.5 Setting Up Password Authentication"><div class="sect1" id="rec-host-key-auth">
<h1>12.5 Setting Up Password Authentication</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157457192">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="password authentication" id="authenticate-openssh-password"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="password authentication" id="openssh-password"/><a data-type="indexterm" data-primary="password authentication in OpenSSH" id="password-authenticate-openssh"/><a data-type="indexterm" data-primary="host keys" data-secondary="password authentication" id="host-key-password"/>want to set up your OpenSSH client to log in to a remote host
using the simplest method that it supports.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157450824">
<h2>Solution</h2>

<p>Password authentication is the simplest way to set up remote SSH access.
You need:</p>

<ul class="">
<li>
<p>OpenSSH server installed and properly configured on the machine you want to
log in to (<a data-type="xref" href="#rec-secure-server-ssh">Recipe 12.3</a>)</p>
</li>
<li>
<p>The SSH daemon running on the remote machine, and port 22, or whatever port
<em>sshd</em> uses, not blocked by firewalls</p>
</li>
<li>
<p>The SSH client installed on your client machine</p>
</li>
<li>
<p>Your own user account on the remote machine</p>
</li>
<li>
<p>Host keys on the server (see <a data-type="xref" href="#rec-gen-host-keys">Recipe 12.2</a>)</p>
</li>
</ul>

<p>The public host key must be distributed to the clients. The easy way is to log
in from the client, and let OpenSSH transfer the key:</p>
<pre>duchess@pc:~$ <strong>ssh <i>duchess@server1</i></strong>
  The authenticity of host '<i>server1 (192.168.43.74)</i>' can't be established.
  ECDSA key fingerprint is SHA256:8iIg9wwFIzLgwiiQ62WNLF5oOS3SL/aTw6gFrtVJTx8.
  Are you sure you want to continue connecting (yes/no)? *yes*
  Warning: Permanently added '<i>server1,192.168.43.74</i>' (ECDSA) to the list of
  known hosts.
  Password: <strong>password</strong>
  Last login: Wed Jul  8 19:22:39 2021 from <i>192.168.43.183</i>
  Have a lot of fun...</pre>

<p>Now Duchess can work on <em>server1</em> just as if she were sitting at <em>server1</em>’s
keyboard. All traffic and authentication are encrypted.</p>

<p>The host key exchange happens only once, the first time you log in. You should
never be asked again unless the key is replaced with a new key, or you delete
it from your personal <em>~/.ssh/known_hosts</em> file.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157435160">
<h2>Discussion</h2>

<p><em>server1</em>’s public host key is stored in the <em>~/.ssh/known_hosts</em> file on the
client PC. This file can contain any number of host keys.</p>

<p>It is unsafe to log in as root over SSH; it is better to log in as an
ordinary user, then <em>su</em> or <em>sudo</em> after login. You can log in as
any user that has an account on the remote machine, if you know their password:</p>
<pre>duchess@pc:~$ <strong>ssh <i>madmax@server1</i></strong></pre>

<p>When you have the same username on both machines, you don’t need to specify the
user, and can log in like this:</p>
<pre>duchess@pc:~$ <strong>ssh <i>server1</i></strong></pre>

<p>I make it a habit to always specify the username as cheap insurance against
mistakes.</p>

<p>Don’t get too worked up over <em>client</em> and <em>server</em>. These are not about
hardware. The server is whatever machine you are logging in to, and the client
is wherever you are logging in from. <em>sshd</em> does not need to be running
on the client.</p>

<p>There is a risk that the host key transmission could be intercepted and a
forged key substituted, which would allow an attacker access to your systems.
You can verify the public key fingerprint before typing <strong><code>yes</code></strong>. Use an
old-fashioned method like writing it down and comparing, or a newfangled
method like taking a photo of the host key with your phone for comparison, or
using your phone as an actual phone and calling someone who has access to the
remote machine to read the fingerprint to you.</p>

<p>See <a data-type="xref" href="#rec-retrieve-fingerprint">Recipe 12.6</a> to learn how to retrieve a key <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="password authentication" data-startref="authenticate-openssh-password" id="idm46466157423704"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="password authentication" data-startref="openssh-password" id="idm46466157421992"/><a data-type="indexterm" data-primary="password authentication in OpenSSH" data-startref="password-authenticate-openssh" id="idm46466157420360"/><a data-type="indexterm" data-primary="host keys" data-secondary="password authentication" data-startref="host-key-password" id="idm46466157419448"/>fingerprint.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157434072">
<h2>See Also</h2>

<ul>
<li>
<p><a data-type="xref" href="#rec-retrieve-fingerprint">Recipe 12.6</a></p>
</li>
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p><em>man 1 ssh</em></p>
</li>
<li>
<p><em>man 1 ssh-keygen</em></p>
</li>
<li>
<p><em>man 8 sshd</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.6 Retrieving a Key Fingerprint"><div class="sect1" id="rec-retrieve-fingerprint">
<h1>12.6 Retrieving a Key Fingerprint</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157408872">
<h2>Problem</h2>

<p>You<a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="key fingerprints" id="idm46466157407752"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="key fingerprints" id="idm46466157406664"/><a data-type="indexterm" data-primary="host keys" data-secondary="fingerprint retrieval" id="idm46466157405816"/><a data-type="indexterm" data-primary="key fingerprints, retrieving" id="idm46466157404872"/> need the fingerprint of a host key so you can verify for the client that
the key is legitimate.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157403768">
<h2>Solution</h2>

<p>Use the <em>ssh-keygen</em> command on the server with the host key you want to query:</p>
<pre>duchess@server1:~$ <strong>ssh-keygen -lf /etc/ssh/ssh_host_rsa_key</strong>
4096 SHA256:32Pja4+F2+MTdla9cs4ucecThswRQp6a4xZ+5sC+Bf0 <i>backup server1</i> (RSA)</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157399720">
<h2>Discussion</h2>

<p>This is where old-fashioned methods of communication, like telephone and
sneakernet, come in handy. Don’t use email, unless you already have encrypted
email with its own separate encryption and authentication, because
unencrypted email is easy to intercept and read.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157398184">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p><em>man 1 ssh-keygen</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.7 Using Public Key Authentication"><div class="sect1" id="rec-public-key-auth">
<h1>12.7 Using Public Key Authentication</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157392376">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="public key authentication" id="authenticate-openssh-publickey"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="public key authentication" id="openssh-publickey"/><a data-type="indexterm" data-primary="public key authentication in OpenSSH" id="publickey-openssh"/>want to use public key authentication because it is stronger than
password authentication, and because it does not use your Linux password. You
want the option of using a single public key to access multiple systems, or
creating a unique public key for each remote machine.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157387576">
<h2>Solution</h2>

<p>Yes, Linux user, you can have it all. You may create as many SSH keys
as you want and use them however you wish. This is my favorite incantation for
creating a new RSA key pair. Of course you will create your own comment and key
name. (See the Discussion to learn if you need to set a passphrase on your private
key.)</p>
<pre>duchess@pc:~/.ssh $ <strong>ssh-keygen -C "<i>backup server2</i>" -f <i>id-server2</i> -t rsa -b 4096</strong>
Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in <i>id-server2</i>.
Your public key has been saved in <i>id-server2.pub</i>.
The key fingerprint is:
SHA256:32Pja4+F2+MTdla9cs4ucecThswRQp6a4xZ+5sC+Bf0 <i>backup server2</i>
The key's randomart image is:
+---[RSA 4096]----+
|          ..     |
|          ....   |
|           o. . .|
|          +  .  o|
|        S* .o o o|
|        +.+..Bo*+|
|         *.+*EX=o|
|        o *o.Oo+.|
|         o.o=+*+.|
+----[SHA256]-----+</pre>

<p>The next step is to copy your nice new key to a remote machine, which in this
case is the local backup server <em>server1</em>. You must already have SSH access
to the remote machine, for example, via host key authentication, then use the
<em>ssh-copy-id</em> command <a data-type="indexterm" data-primary="ssh-copy-id command" id="sshcopyid"/>to transfer your public key to the server:</p>
<pre>duchess@pc:~/.ssh $ <strong>ssh-copy-id -i <i>id-server1 duchess@server1</i></strong>
/usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: "<i>.ssh/id-server1</i>"
/usr/bin/ssh-copy-id: INFO: attempting to log in with the new key(s), to filter
out any that are already installed
/usr/bin/ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are
prompted now it is to install the new keys

Number of key(s) added: 1

Now try logging into the machine, with:   "ssh '<i>duchess@server1</i>'"
and check to make sure that only the key(s) you wanted were added.</pre>

<p>Try logging in:</p>
<pre>duchess@pc:~/.ssh $ <strong>ssh -i <i>id-server1 duchess@server1</i></strong>
Enter passphrase for key '<i>id-server1</i>':
Last login: Sat Jul 11 11:09:53 2021 from <i>192.168.43.234</i>
Have a lot of fun...
duchess@server1:~$</pre>

<p>You may use this new key to access multiple remote hosts, or create a
unique key for each remote host. Using the same key for multiple machines is easy to
use, but a pain to change on multiple hosts. If a unique key is compromised or
lost, you only need to replace it once.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157372296">
<h2>Discussion</h2>

<p>Always use a passphrase on SSH keys created for human users, because anyone
who gains access to your private keys can masquerade as you if there is no
passphrase.</p>

<p><em>ssh-copy-id</em> is a lovely little utility that ensures your public keys are
copied into the correct location, which is <em>~/.ssh/authorized_keys</em> on the
remote host, in the correct format and with the correct permissions. It also
ensures your private key will not be copied by mistake.</p>

<p>Options are as follows:</p>

<ul>
<li>
<p><em>-C</em> is for adding a comment to your key, which can help you remember what
the key is for.</p>
</li>
<li>
<p><em>-f</em> is the key name, which can be anything you want. Be mindful of your
current working directory; if you are not in <em>~/.ssh</em>, include the path.</p>
</li>
<li>
<p><em>-t</em> is the key type: <em>rsa</em>, <em>ecdsa</em>, or <em>ed25519</em>.</p>
</li>
<li>
<p><em>-b</em> is the bit strength, and only <em>rsa</em> takes this option. The default
is 2048, and 4096 is the maximum. More bits equals more processing overhead,
but it is doubtful you would notice any difference using 4096 bits except on
old feeble hardware or on very busy servers.</p>
</li>
<li>
<p><em>-i</em> tells your SSH client which key you want to use. When you have more
than one key, you must use this. When you have multiple public keys, you may
see a “Too many authentication failures” error message if you do not specify
one key, because SSH tries all of them when one is not <a data-type="indexterm" data-primary="ssh-copy-id command" data-startref="sshcopyid" id="idm46466157355176"/><a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="public key authentication" data-startref="authenticate-openssh-publickey" id="idm46466157354440"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="public key authentication" data-startref="openssh-publickey" id="idm46466157355736"/><a data-type="indexterm" data-primary="public key authentication in OpenSSH" data-startref="publickey-openssh" id="idm46466157359352"/>specified.</p>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157357864">
<h2>See Also</h2>

<ul class="no-space-list">
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p><em>man 1 ssh</em></p>
</li>
<li>
<p><em>man 1 ssh-keygen</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.8 Managing Multiple Public Keys"><div class="sect1" id="idm46466157349512">
<h1>12.8 Managing Multiple Public Keys</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157348504">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="multiple public keys" id="authenticate-openssh-multiple-public"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="public key authentication" data-tertiary="multiple public keys" id="openssh-public-multiple"/><a data-type="indexterm" data-primary="public key authentication in OpenSSH" data-secondary="multiple public keys" id="publickey-openssh-multiple"/><a data-type="indexterm" data-primary="multiple public keys in OpenSSH" id="multiple-public-key-openssh"/>want to use different keys for different servers. How do you
manage keys with different names?</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157341416">
<h2>Solution</h2>

<p>When you create a new key pair, use the <em>-f</em> option of the <em>ssh-keygen</em> command<a data-type="indexterm" data-primary="ssh-keygen command" data-secondary="multiple public keys" id="idm46466157338616"/>
to give keys unique names:</p>
<pre>duchess@pc:~/.ssh $ <strong>ssh-keygen -t rsa -f <i>id-server2</i></strong></pre>

<p>Then, use the <em>-i</em> option to specify the key you want to use when you log in to
the remote host:</p>
<pre>duchess@pc:~/.ssh $ <strong>ssh -i <i>id-server2 duchess@server2</i></strong></pre>

<p>To manage multiple public keys more easily, create a new file,
<em>~/.ssh.config</em>. This file configures the logins for your various remote
hosts, so you log in with <em>ssh foo</em> instead of a long command string. The
following example configures a simpler login for Duchess to access <em>server2</em>:</p>

<pre data-type="programlisting">Host server2
  HostName server2
  User duchess
    IdentityFile ~/.ssh/id-server2
    IdentitiesOnly yes</pre>

<p>Now Duchess logs in like this, using the <em>Host</em> value:</p>
<pre>$ <strong>ssh <i>server2</i></strong></pre>

<p>Keep adding to this file for your other public key logins, like this:</p>

<pre data-type="programlisting">Host server3
  HostName server3
  User duchess
    IdentityFile ~/.ssh/id-server3
    IdentitiesOnly yes

Host server3
  HostName server3
  User madmax
    IdentityFile ~/.ssh/id-server3
    IdentitiesOnly yes</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157340840">
<h2>Discussion</h2>

<p>In the preceding solution snippet:</p>

<ul>
<li>
<p>The <em>Host</em> line defines the start of each configuration. This is the label
you use to login, and it can be anything you want.</p>
</li>
<li>
<p><em>HostName</em> is the remote machine’s hostname, fully qualified domain name, or
IP address.</p>
</li>
<li>
<p><em>User</em> is your user on the remote machine.</p>
</li>
<li>
<p><em>IdentityFile</em> is the full path to your public key.</p>
</li>
<li>
<p><em>IdentitiesOnly yes</em> tells <em>ssh</em> to use the settings in <em>~/.ssh/config</em>, or
passed on the command line, and not other providers, if there are any.</p>
</li>
</ul>

<p>The default SSH port number is 22. When you need to connect to a nonstandard
port, for example 2022, specify it with <em>Port</em>:</p>

<pre data-type="programlisting">Port 2022</pre>

<p>You may call your keys anything you want. I like to use descriptive names so I
know what machines they belong to.</p>

<p>Remember to always put a passphrase on your personal private<a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="multiple public keys" data-startref="authenticate-openssh-multiple-public" id="idm46466157315624"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="public key authentication" data-tertiary="multiple public keys" data-startref="openssh-public-multiple" id="idm46466157314040"/><a data-type="indexterm" data-primary="public key authentication in OpenSSH" data-secondary="multiple public keys" data-startref="publickey-openssh-multiple" id="idm46466157312712"/><a data-type="indexterm" data-primary="multiple public keys in OpenSSH" data-startref="multiple-public-key-openssh" id="idm46466157311624"/> keys.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157316792">
<h2>See Also</h2>

<ul class="no-space-list">
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p><em>man 1 ssh_config</em></p>
</li>
<li>
<p><em>man 1 ssh</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.9 Changing a Passphrase"><div class="sect1" id="idm46466157305416">
<h1>12.9 Changing a Passphrase</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157304424">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="passphrase changes" id="authenticate-openssh-passphrase"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="public key authentication" data-tertiary="passphrase changes" id="openssh-publickey-passphrase"/><a data-type="indexterm" data-primary="public key authentication in OpenSSH" data-secondary="passphrase changes" id="publickey-openssh-passphrase"/><a data-type="indexterm" data-primary="private keys" data-secondary="passphrases" data-tertiary="changing" id="privatekey-passphrase-change"/><a data-type="indexterm" data-primary="passphrases" data-secondary="changing" id="passphrase-change"/><a data-type="indexterm" data-primary="changing" data-secondary="passphrases" id="change-passphrase"/>want to change the passphrase on one of your private keys.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157294168">
<h2>Solution</h2>

<p>Use<a data-type="indexterm" data-primary="ssh-keygen command" data-secondary="passphrase changes" id="sshkeygen-passphrase"/> the <em>-p</em> option with the <em>ssh-keygen</em> command:</p>
<pre>$ <strong>ssh-keygen -p -f ~/.ssh/<i>id-server2</i></strong>
Enter old passphrase:
Key has comment '<i>backup server2</i>'
Enter new passphrase (empty for no <strong><i>passphrase</i></strong>):
Enter same passphrase again: <strong><i>passphrase</i></strong>
Your identification has been saved with the new passphrase.</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157286904">
<h2>Discussion</h2>

<p>Passphrases are not recoverable. If you lose a passphrase, your only option is
to create a new key with a new<a data-type="indexterm" data-primary="ssh-keygen command" data-secondary="passphrase changes" data-startref="sshkeygen-passphrase" id="idm46466157286360"/><a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="passphrase changes" data-startref="authenticate-openssh-passphrase" id="idm46466157285352"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="public key authentication" data-tertiary="passphrase changes" data-startref="openssh-publickey-passphrase" id="idm46466157284584"/><a data-type="indexterm" data-primary="public key authentication in OpenSSH" data-secondary="passphrase changes" data-startref="publickey-openssh-passphrase" id="idm46466157281240"/><a data-type="indexterm" data-primary="private keys" data-secondary="passphrases" data-tertiary="changing" data-startref="privatekey-passphrase-change" id="idm46466157279960"/><a data-type="indexterm" data-primary="passphrases" data-secondary="changing" data-startref="passphrase-change" id="idm46466157278424"/><a data-type="indexterm" data-primary="changing" data-secondary="passphrases" data-startref="change-passphrase" id="idm46466157277080"/> passphrase.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157275000">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p><em>man 1 ssh_</em></p>
</li>
<li>
<p><em>man 1 ssh-keygen</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.10 Automatic Passphrase Management with Keychain"><div class="sect1" id="rec-keychain">
<h1>12.10 Automatic Passphrase Management with Keychain</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157269352">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="private key management with Keychain" id="authenticate-openssh-keychain"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="public key authentication" data-tertiary="private key management with Keychain" id="openssh-publickey-keychain"/><a data-type="indexterm" data-primary="public key authentication in OpenSSH" data-secondary="private key management with Keychain" id="publickey-openssh-keychain"/><a data-type="indexterm" data-primary="private keys" data-secondary="passphrases" data-tertiary="managing with Keychain" id="privatekey-passphrase-keychain"/><a data-type="indexterm" data-primary="passphrases" data-secondary="managing with Keychain" id="passphrase-manage"/><a data-type="indexterm" data-primary="Keychain" id="keychain"/>want something to remember your private key passphrases for you, and
use them as needed.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157259720">
<h2>Solution</h2>

<p>The Keychain utility was made for this. Install the <em>keychain</em> package, then
copy the lines in the following example into your <em>.bashrc</em> file.</p>

<p>In the following example, you want access to <em>server1</em>, <em>server2</em>, and
<em>server3</em> without entering your passphrases every time you log in. Copy these
lines, except using your own key names:</p>
<pre><strong>keychain ~/.ssh/<i>id-server1</i> ~/.ssh/<i>id-server2</i> \
 ~/.ssh/<i>id-server3</i> . ~/.keychain/$HOSTNAME-sh</strong></pre>

<p>Keychain keeps your private keys available until you shut down, so you must enter
your passphrases every time you start up your system.</p>

<p>When you boot to a graphical environment, you may not be prompted to enter your
passphrases. Try opening a terminal, and if you still don’t see a Keychain
prompt for your passphrases, you must enter a Linux console. Press Ctrl-Alt-F2
and log in. After logging in, you should see something like this:</p>
<pre>* keychain 2.8.5 ~ http://www.funtoo.org
 * Found existing ssh-agent: 2016
 * Adding 3 ssh key(s): <i>/home/duchess/.ssh/id-server1
/home/duchess/.ssh/id-server2 /home/duchess/.ssh/id-server3</i>
Enter passphrase for <i>/home/duchess/.ssh/id-server1</i>:
Enter passphrase for <i>/home/duchess/.ssh/id-server2</i>:
Enter passphrase for <i>/home/duchess/.ssh/id-server3</i>:
 * ssh-add: Identities added: <i>/home/duchess/.ssh/id-server1
/home/duchess/.ssh/id-server2 /home/duchess/.ssh/id-server3</i></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157248888">
<h2>Discussion</h2>

<p>The leading dot in <em>. ~/.keychain/$HOSTNAME-sh</em> is short for <em>source</em>, meaning use the named file.</p>

<p><em>$HOSTNAME</em> tells Keychain to look in the user’s environment variables to fetch
their hostname. You can see this for yourself:</p>
<pre>$ <strong>echo $HOSTNAME</strong>
pc</pre>

<p>Keychain is a manager for both <em>ssh-agent</em> and <em>gpg-agent</em>, caching your
SSH and GPG passphrases for as long as your computer is powered on. You can log
out and log back in, and will have to reenter your passphrases only after a
restart.</p>

<p>A good alternative is <em>gnome-keyring</em>, which runs in graphical environments.
This provides a graphical interface for viewing and managing SSH and GPG keys,
and it also includes a password manager. This appears as “Passwords and Keys” on
most systems. Its has two disadvantage: it’s not suitable to use on headless
systems, and it does not make passphrases available to cron (see <a data-type="xref" href="#rec-keychain-cron">Recipe 12.11</a>.)</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157236168">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://oreil.ly/rljaf">Funtoo Keychain</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.11 Using Keychain to Make Passphrases Available &#10;to Cron"><div class="sect1" id="rec-keychain-cron">
<h1>12.11 Using Keychain to Make Passphrases Available 
<span class="keep-together">to Cron</span></h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157238344">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="cron" data-secondary="passphrase management with Keychain" id="idm46466157234568"/>need to use cron to automate tasks, such as running rsync backups to a
remote host. But no matter what you try, you get nothing for your troubles but
failed backups with authentication errors.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157233400">
<h2>Solution</h2>

<p>To configure Keychain to manage your private keys for cron jobs, create
a script for cron to use. The following example is for an rsync backup, and the
script is named <em>duchess-backup-server1</em>:</p>

<pre data-type="programlisting">#!/bin/bash
source $HOME/.keychain/${HOSTNAME}-sh
/usr/bin/rsync -ae "ssh -i /home/duchess/.ssh/id-server3" /home/duchess/ \
duchess@server1:/backups/</pre>

<p>Make this script executable with <em>chmod</em>:</p>
<pre>$ <strong>chmod +x duchess-backup-server1</strong></pre>

<p>This example adds a line to your crontab to run the script every night at 10:15
P.M.:</p>

<pre data-type="programlisting">15 22 * * * /home/duchess/duchess-backup-server1</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157233144">
<h2>Discussion</h2>

<p>In the example script, the line starting with <em>/usr/bin/rsync</em> must be all on a
single line.</p>

<p>Cron runs in its own special limited environment and needs Keychain to provide
the required keys and environment variables.<a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="private key management with Keychain" data-startref="authenticate-openssh-keychain" id="idm46466157225608"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="public key authentication" data-tertiary="private key management with Keychain" data-startref="openssh-publickey-keychain" id="idm46466157223944"/><a data-type="indexterm" data-primary="public key authentication in OpenSSH" data-secondary="private key management with Keychain" data-startref="publickey-openssh-keychain" id="idm46466157222232"/><a data-type="indexterm" data-primary="private keys" data-secondary="passphrases" data-tertiary="managing with Keychain" data-startref="privatekey-passphrase-keychain" id="idm46466157221144"/><a data-type="indexterm" data-primary="passphrases" data-secondary="managing with Keychain" data-startref="passphrase-manage" id="idm46466157219752"/><a data-type="indexterm" data-primary="Keychain" data-startref="keychain" id="idm46466157218408"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157216472">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 1 crontab</em></p>
</li>
<li>
<p><a href="https://oreil.ly/rljaf">Funtoo Keychain</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.12 Tunneling an X Session Securely over SSH"><div class="sect1" id="idm46466157215512">
<h1>12.12 Tunneling an X Session Securely over SSH</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157211928">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="tunneling X sessions" id="authenticate-openssh-tunnelx"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="tunneling X sessions" id="openssh-tunnelx"/><a data-type="indexterm" data-primary="X sessions, tunneling over SSH" id="xtunnel-ssh"/><a data-type="indexterm" data-primary="tunneling" data-secondary="X sessions over SSH" id="tunnelx-ssh"/>want to run graphical applications from the remote host. You know that the X
Window System has built-in networking abilities, but it sends all traffic in
cleartext, which is insecure, and you want to do this safely.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157204920">
<h2>Solution</h2>

<p>Tunneling X over SSH requires no additional software. First, use these
commands to see if your client machine is running the X11 or Wayland protocol.
The following examples show both results:</p>
<pre>$ <strong>echo $XDG_SESSION_TYPE</strong>
x11
$ <strong>echo $XDG_SESSION_TYPE</strong>
wayland
$ <strong>loginctl show-session "$XDG_SESSION_ID" -p Type</strong>
Type=x11
$ <strong>loginctl show-session "$XDG_SESSION_ID" -p Type</strong>
Type=wayland</pre>

<p><em>loginctl</em> is part of systemd.</p>

<p>If you are running Wayland, you cannot tunnel it over SSH because it does
not have networking support.</p>

<p>If your system is using X11, configure X11 forwarding in <em>/etc/ssh/sshd_config</em>
on the remote machine:</p>

<pre data-type="programlisting">X11Forwarding yes</pre>

<p>The following example tunnels X over SSH, using the <em>-Y</em> option:</p>
<pre>duchess@pc:~$ <strong>ssh -Yi <i>id-server1 duchess@server1</i></strong>
Last login: Thu Jul  9 09:26:09 2021 from 192.168.43.80
Have a lot of fun..
duchess@server1:~$</pre>

<p>Now you can run graphical applications, though only one at a time, like the
game in <a data-type="xref" href="#fig-x-tunnel-ssh">Figure 12-1</a>:</p>
<pre>duchess@server1:~$ <strong>kmahjongg</strong></pre>

<figure><div id="fig-x-tunnel-ssh" class="figure">
<img src="Images/lcb2_1201.png" alt="KMahjongg tunneled over SSH" width="1357" height="826"/>
<h6><span class="label">Figure 12-1. </span>Playing KMahjongg on the remote server</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157204504">
<h2>Discussion</h2>

<p>The X server runs with the offset specified in <em>/etc/ssh/sshd.conf</em>,
<em>X11DisplayOffset 10</em>. This avoids colliding with existing X sessions. Your
regular local X session is :0.0, so your first remote X session is :10.0. You
can see this with your own eyes. Run the following commands on your local
machine. The first one is at your local command prompt:</p>
<pre>duchess@pc:~$ <strong>echo $DISPLAY</strong>
:0.0</pre>

<p>The second example is at your SSH command prompt:</p>
<pre>duchess@server1:~ssh $ <strong>echo $DISPLAY</strong>
localhost:10.0</pre>

<p>The remote system only needs to be powered on. You don’t need any local users
to be logged in, and you don’t even need X to be running. X needs
to be running only on the client<a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="tunneling X sessions" data-startref="authenticate-openssh-tunnelx" id="idm46466157184296"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="tunneling X sessions" data-startref="openssh-tunnelx" id="idm46466157186264"/><a data-type="indexterm" data-primary="X sessions, tunneling over SSH" data-startref="xtunnel-ssh" id="idm46466157185016"/><a data-type="indexterm" data-primary="tunneling" data-secondary="X sessions over SSH" data-startref="tunnelx-ssh" id="idm46466157181928"/> PC.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157180360">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 1 sshd</em></p>
</li>
<li>
<p><em>man 1 ssh_config</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.13 Opening an SSH Session and Running a Command &#10;in One Line"><div class="sect1" id="idm46466157176392">
<h1>12.13 Opening an SSH Session and Running a Command 
<span class="keep-together">in One Line</span></h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157175528">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="open session and run command" id="idm46466157173640"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="open session and run command" id="idm46466157172552"/>have a single command to run on the remote machine, and you think it would
be nice to run it without logging in and running the command, and then logging out.
After all, is it not true that laziness is a virtue for system administrators?</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157171288">
<h2>Solution</h2>

<p>OpenSSH can do this. This example shows how to restart Postfix:</p>
<pre>$ <strong>ssh <i>mailadmin@server2.example.com</i> sudo systemctl restart postfix</strong>
</pre>

<p>You’ll be asked for a <em>sudo</em> password, but you will still save one whole step.</p>

<p>This shows how to open a quick game of GNOME Sudoku, which requires the X Window
System:</p>
<pre>$ <strong>ssh -Y <i>duchess@laptop</i> /usr/games/gnome-sudoku</strong></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157165096">
<h2>Discussion</h2>

<p>Another way to do this is with public key authentication for the root user, so
you don’t have to invoke <em>sudo</em> (<a data-type="xref" href="#rec-public-key-auth">Recipe 12.7</a>).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157162392">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 1 ssh</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.14 Mounting Entire Remote Filesystems with sshfs"><div class="sect1" id="rec-sshfs">
<h1>12.14 Mounting Entire Remote Filesystems with sshfs</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157158312">
<h2>Problem</h2>

<p>OpenSSH <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="sshfs command" id="authenticate-openssh-sshfs"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="remote filesystems, mounting with sshfs" id="openssh-remote-mount"/><a data-type="indexterm" data-primary="remote filesystems, mounting with sshfs command" id="remote-mount-sshfs"/><a data-type="indexterm" data-primary="filesystems" data-secondary="remote, mounting with sshfs" id="filesystem-remote-mount-sshfs"/><a data-type="indexterm" data-primary="sshfs command" id="sshfs"/><a data-type="indexterm" data-primary="mounting" data-secondary="remote filesystems with sshfs command" id="mount-remote-sshfs"/>is fast and efficient, and even tunneling X applications over
OpenSSH isn’t too laggy. But you want a faster way to edit a number of remote
files without running a graphical file manager over SSH.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157148552">
<h2>Solution</h2>

<p><em>sshfs</em> is the tool for you. <em>sshfs</em> is for mounting an entire remote
filesystem, and then accessing it just like a local filesystem, without the
hassles of setting up an NFS or Samba server.</p>

<p>Install the <em>sshfs</em> package, which should also install FUSE, the Filesystem in
Userspace. You need a local directory that you have write permissions for as your
mountpoint:</p>
<pre>duchess@pc:~$ <strong>mkdir <i>sshfs</i></strong></pre>

<p>Then mount your chosen remote directory in your local <em>sshfs</em> directory. This
example mounts the home directory for <em>duchess@server2</em> in the <em>sshfs</em> directory
at <em>duchess@pc</em>:</p>
<pre>duchess@pc:~$ <strong>sshfs <i>duchess@server2: sshfs/</i></strong></pre>

<p>The remote filesystem is just as accessible as your local filesystems:</p>
<pre>duchess@pc:~$ <strong>ls sshfs</strong>
Desktop
Documents
Downloads
[...]</pre>

<p>Access these files from the command line or with your graphical file manager,
just like your local files.</p>

<p>Your command prompt will not change to the remote prompt.</p>

<p>When you’re finished, unmount the remote filesystem:</p>
<pre>duchess@pc:~$ <strong>fusermount -u sshfs/</strong></pre>

<p>That mounts Duchess’s entire home directory. Specify a subdirectory instead:</p>
<pre>duchess@pc:~$ <strong>sshfs <i>duchess@server2:/home/duchess/arias sshfs/</i></strong></pre>

<p>You cannot use the tilde, ~, as a shortcut for <em>/home/user</em> because <em>sshfs</em> does
not support it.</p>

<p>If your network connection is not reliable, tell <em>sshfs</em> to automatically
reconnect after an interruption:</p>
<pre>duchess@pc:~$ <strong>sshfs <i>duchess@server2:/home/duchess/arias sshfs/ -o reconnect</i></strong></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157147928">
<h2>Discussion</h2>

<p>Users who are new to <em>sshfs</em> always ask these questions: why not just run X
over SSH, or why not just use NFS? The answers are: it is faster than
running X over SSH, it is easier to set up than NFS, and you may use
NFS, Samba, or whatever your heart <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="sshfs command" data-startref="authenticate-openssh-sshfs" id="idm46466157130536"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="remote filesystems, mounting with sshfs" data-startref="openssh-remote-mount" id="idm46466157129208"/><a data-type="indexterm" data-primary="remote filesystems, mounting with sshfs command" data-startref="remote-mount-sshfs" id="idm46466157128120"/><a data-type="indexterm" data-primary="filesystems" data-secondary="remote, mounting with sshfs" data-startref="filesystem-remote-mount-sshfs" id="idm46466157127272"/><a data-type="indexterm" data-primary="sshfs command" data-startref="sshfs" id="idm46466157125608"/><a data-type="indexterm" data-primary="mounting" data-secondary="remote filesystems with sshfs command" data-startref="mount-remote-sshfs" id="idm46466157124600"/>desires.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157122632">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 1 sshfs</em></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.15 Customizing the Bash Prompt for SSH"><div class="sect1" id="idm46466157159224">
<h1>12.15 Customizing the Bash Prompt for SSH</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157118936">
<h2>Problem</h2>

<p>Sure, <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="customizing Bash prompt" id="authenticate-openssh-bash-custom"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="Bash prompt, customizing" id="openssh-bash-custom"/><a data-type="indexterm" data-primary="Bash prompt, customizing" id="bash-custom"/><a data-type="indexterm" data-primary="customizing" data-secondary="Bash prompt" id="custom-bash"/>you know that the prompt changes to display the remote hostname when
you’re logged in via SSH. But it’s just a plain prompt, and it’s easy to make
mistakes, so you want a customized, colorful prompt to indicate when you have an
active SSH login.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157108424">
<h2>Solution</h2>

<p>Customize the Bash prompt on the remote machines. This example turns the prompt
purple and adds “ssh” to it.</p>

<p>Copy these lines into the <em>.bashrc</em> file for the remote account you want to log
in to:</p>

<pre data-type="programlisting">if [ -n "$SSH_CLIENT" ]; then text=" ssh"
fi
export PS1='\[\e[0;36m\]\u@\h:\w${text}$\[\e[0m\] '</pre>

<p>When you log in to this machine, the prompt will look like what’s shown in <a data-type="xref" href="#fig-ssh-prompt">Figure 12-2</a>.</p>

<figure><div id="fig-ssh-prompt" class="figure">
<img src="Images/lcb2_1202.png" alt="Customized SSH prompt" width="630" height="142"/>
<h6><span class="label">Figure 12-2. </span>A customized SSH prompt</h6>
</div></figure>

<p>Only the prompt is purple, and all the other text will be your normal shell
colors.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157104632">
<h2>Discussion</h2>

<p>Customizing the Bash prompt is practically a book topic in itself. The example
in this recipe can be edited to suit your preferences. You don’t have to
use the term “ssh” or name the variable “text”; these can be anything you like.
You could say “super duper encrypted session” and name your variable
“sekkret-squirl” if you want.</p>

<p><em>[\e[0;31m\]</em> is the code block that determines the text color. All you have to
do is change the numbers to change the colors.</p>

<p><em>[\e[0m\]</em> turns off the custom colors, so that your commands and command
output will return to the normal shell colors. Here are the color codes:</p>

<ul class="two-col">
<li>
<p>Black 0;30</p>
</li>
<li>
<p>Blue 0;34</p>
</li>
<li>
<p>Green 0;32</p>
</li>
<li>
<p>Cyan 0;36</p>
</li>
<li>
<p>Red 0;31</p>
</li>
<li>
<p>Purple 0;35</p>
</li>
<li>
<p>Brown 0;33</p>
</li>
<li>
<p>Light Gray 0;37</p>
</li>
<li>
<p>Dark Gray 1;30</p>
</li>
<li>
<p>Light Blue 1;34</p>
</li>
<li>
<p>Light Green 1;32</p>
</li>
<li>
<p>Light Cyan 1;36</p>
</li>
<li>
<p>Light Red 1;31</p>
</li>
<li>
<p>Light Purple 1;35</p>
</li>
<li>
<p>Yellow 1;33</p>
</li>
<li>
<p>White 1;37</p>
</li>
</ul>

<p>This customization works by checking for the presence of the <em>SSH_CLIENT</em>
environment variable, which is present only when there is an active SSH
connection. You can see this for yourself on the remote host:</p>
<pre>$ <strong>echo $SSH_CLIENT</strong>
192.168.43.234 51414 22</pre>

<p>Then Bash knows to use the custom SSH prompt instead of the default prompt.
When you run this command on a machine without any active SSH sessions, it
returns an <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="customizing Bash prompt" data-startref="authenticate-openssh-bash-custom" id="idm46466157083816"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="Bash prompt, customizing" data-startref="openssh-bash-custom" id="idm46466157082168"/><a data-type="indexterm" data-primary="Bash prompt, customizing" data-startref="bash-custom" id="idm46466157081032"/><a data-type="indexterm" data-primary="customizing" data-secondary="Bash prompt" data-startref="custom-bash" id="idm46466157079864"/>empty line.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157078168">
<h2>See Also</h2>

<ul>
<li>
<p><em>man 1 bash</em></p>
</li>
<li>
<p>Bash Prompt HOWTO, <a href="https://oreil.ly/QXWmT">Chapter 6</a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="12.16 Listing Supported Encryption Algorithms"><div class="sect1" id="rec-list-algorithms">
<h1>12.16 Listing Supported Encryption Algorithms</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm46466157072760">
<h2>Problem</h2>

<p>You <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="encryption algorithms" id="authenticate-openssh-encrypt"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="encryption algorithms" id="openssh-encrypt"/><a data-type="indexterm" data-primary="encryption" data-secondary="in OpenSSH" data-secondary-sortas="OpenSSH" id="encrypt-openssh"/><a data-type="indexterm" data-primary="ssh command" id="ssh-command"/>have compliance rules to follow and need to know what encryption algorithms
OpenSSH supports.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm46466157065416">
<h2>Solution</h2>

<p>OpenSSH includes a command to query and list all supported algorithms,
<em>ssh -Q &lt;query_option&gt;</em>. List them with the <em>help</em> option:</p>
<pre>$ <strong>ssh -Q help</strong>
cipher
cipher-auth
compression
kex
kex-gss
key
key-cert
key-plain
key-sig
mac
protocol-version
sig</pre>

<p>The following example lists the <em>sig</em> signature algorithms:</p>
<pre>$ <strong>ssh -Q sig</strong>
ssh-ed25519
sk-ssh-ed25519@openssh.com
ssh-rsa
rsa-sha2-256
rsa-sha2-512
ssh-dss
ecdsa-sha2-nistp256
ecdsa-sha2-nistp384
ecdsa-sha2-nistp521
sk-ecdsa-sha2-nistp256@openssh.com
</pre>
</div></section>













<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Discussion"><div class="sect2" id="idm46466157065160">
<h2>Discussion</h2>

<p>The following list briefly describes each option:</p>

<ul>
<li>
<p><em>cipher</em> lists supported symmetric ciphers.</p>
</li>
<li>
<p><em>cipher-auth</em> lists supported symmetric ciphers that also support authenticated encryption.</p>
</li>
<li>
<p><em>compression</em> lists supported compression types.</p>
</li>
<li>
<p><em>mac</em> lists supported message integrity codes. These protect your message’s
data integrity and its authenticity.</p>
</li>
<li>
<p><em>kex</em> lists key exchange algorithms.</p>
</li>
<li>
<p><em>kex-gss</em> lists GSSAPI (Generic Security Service Application Program Interface) key exchange algorithms.</p>
</li>
<li>
<p><em>key</em> lists key types.</p>
</li>
<li>
<p><em>key-cert</em> lists certificate key types.</p>
</li>
<li>
<p><em>key-plain</em> lists noncertificate key types.</p>
</li>
<li>
<p><em>key-sig</em> lists all key types and signature algorithms.</p>
</li>
<li>
<p><em>protocol-version</em> lists supported SSH protocol versions, which is
only version 2 at the time of writing.</p>
</li>
<li>
<p><em>sig</em> lists supported signature <a data-type="indexterm" data-primary="authentication" data-secondary="OpenSSH" data-tertiary="encryption algorithms" data-startref="authenticate-openssh-encrypt" id="idm46466157042088"/><a data-type="indexterm" data-primary="OpenSSH" data-secondary="encryption algorithms" data-startref="openssh-encrypt" id="idm46466157040760"/><a data-type="indexterm" data-primary="encryption" data-secondary="in OpenSSH" data-secondary-sortas="OpenSSH" data-startref="encrypt-openssh" id="idm46466157039672"/><a data-type="indexterm" data-primary="ssh command" data-startref="ssh-command" id="idm46466157038344"/>algorithms.</p>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm46466157042968">
<h2>See Also</h2>

<ul>
<li>
<p><a href="https://openssh.com">OpenSSH</a></p>
</li>
<li>
<p><em>Serious Cryptography</em> by Jean-Philippe Aumasson (No Starch Press)</p>
</li>
</ul>
</div></section>





</div></section>







</div></section></div></body></html>