<html><head></head><body><section data-pdf-bookmark="Chapter 11. Ensuring Reliability with Linkerd" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="LUAR_reliability">
<h1 class="calibre7"><span class="calibre">Chapter 11. </span>Ensuring Reliability with Linkerd</h1>


<p class="author1">As discussed from the very beginning, <a data-primary="reliability" data-secondary="about" data-type="indexterm" id="id1449" class="calibre4"/><a data-primary="microservices architecture" data-secondary="reliability" data-type="indexterm" id="id1450" class="calibre4"/>back in <a data-type="xref" href="ch01.html#LUAR_service_mesh_101" class="calibre4">Chapter 1</a>,
microservices applications are utterly reliant on the network for all of their
communications. Networks are slower and less reliable than in-process
communication, which introduces new failure modes and presents new challenges
to our applications.</p>

<p class="author1">For service mesh users, where<a data-primary="communication" data-secondary="unreliable as microservice norm" data-tertiary="reliability benefit" data-type="indexterm" id="id1451" class="calibre4"/> the mesh mediates all your application traffic,
the reliability benefit is that the mesh can make intelligent choices about
what to do when things go wrong. In this chapter, we’ll talk about the
mechanisms that Linkerd provides to mitigate the problems of unreliability in
the network, helping to address the inherent instability of microservices
applications.</p>






<section data-pdf-bookmark="Load Balancing" data-type="sect1" class="preface"><div class="preface" id="id83">
<h1 class="calibre8">Load Balancing</h1>

<p class="author1">Load balancing might seem like an<a data-primary="reliability" data-secondary="load balancing" data-type="indexterm" id="id1452" class="calibre4"/><a data-primary="load balancing" data-secondary="reliability" data-type="indexterm" id="id1453" class="calibre4"/> odd reliability feature to lead with, since
many people think that Kubernetes already handles it. <a data-primary="IP addresses" data-secondary="Pod IP addresses as endpoints of Service" data-type="indexterm" id="id1454" class="calibre4"/><a data-primary="Pods" data-secondary="IP addresses" data-tertiary="as endpoints of Service" data-tertiary-sortas="endpoints of Service" data-type="indexterm" id="id1455" class="calibre4"/><a data-primary="Services" data-secondary="Pod IP addresses as endpoints of Service" data-type="indexterm" id="id1456" class="calibre4"/><a data-primary="endpoints of a Service" data-type="indexterm" id="id1457" class="calibre4"/>As we first discussed in
<a data-type="xref" href="ch05.html#LUAR_ingress_and_linkerd" class="calibre4">Chapter 5</a>, Kubernetes Services make a distinction
between the IP address of the Service and the IP addresses of the Pods
associated with the Service. When traffic is sent to the ClusterIP, it ends up
being redirected to one of the endpoint IPs.</p>

<p class="author1">However, in Kubernetes, the built-in load balancing is limited to entire
connections. Linkerd improves on this by using the proxy, which understands
more about the protocol involved in the connection, to choose an endpoint for
each request, as shown in <a data-type="xref" href="#service-discovery-in-linkerd" class="calibre4">Figure 11-1</a>.</p>

<figure class="calibre23"><div class="figure" id="service-discovery-in-linkerd">
<img alt="luar 1101" src="assets/luar_1101.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 11-1. </span>Service discovery in Linkerd</h6>
</div></figure>

<p class="author1">As you can see from <a data-type="xref" href="#service-discovery-in-linkerd" class="calibre4">Figure 11-1</a>, Linkerd will use the destination
address from a given request and, depending on the object type it refers to,
will adjust its endpoint selection algorithm to select a target.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Request-Level Load Balancing</h1>
<p class="author1">This distinction between <a data-primary="load balancing" data-secondary="request-level versus connection-level" data-type="indexterm" id="id1458" class="calibre4"/>connection-level load balancing and request-level
load balancing is more important than it might appear at first glance. Under
the hood, Linkerd actually maintains a pool of connections between your
workloads, letting it rapidly dispatch requests to whichever workload it
thinks appropriate without connection overhead, load balancing the individual
requests so that the load is evenly and efficiently distributed.</p>

<p class="author1">You can learn more about <a data-primary="load balancing" data-secondary="request-level versus connection-level" data-tertiary="connection-level blog URL" data-type="indexterm" id="id1459" class="calibre4"/><a data-primary="resources online" data-secondary="connection-level load balancing blog" data-type="indexterm" id="id1460" class="calibre4"/>connection-level load balancing in Kubernetes on the <a href="https://oreil.ly/FMALe" class="calibre4">Kubernetes blog</a>.</p>
</div>

<p class="author1">The aptly named destination controller in the Linkerd control plane makes this
all possible. For each service in the mesh, it maintains a list of the
service’s current endpoints as well as their health and relative performance.
The Linkerd proxy uses that information to make intelligent decisions about
where and how to send a given request.</p>
</div></section>






<section data-pdf-bookmark="Retries" data-type="sect1" class="preface"><div class="preface" id="id167">
<h1 class="calibre8">Retries</h1>

<p class="author1">Sometimes, due to network issues<a data-primary="reliability" data-secondary="retries" data-type="indexterm" id="id1461" class="calibre4"/><a data-primary="retries" data-secondary="reliability" data-type="indexterm" id="id1462" class="calibre4"/> or intermittent application failures, a
request might fail. In this situation, the Linkerd proxy can <em class="hyperlink">retry</em> the
request for you, automatically repeating it to give the workload another
chance to handle it successfully. Of course, it’s not always safe to retry
every request, so the Linkerd proxy will only do automatic retries if you’ve
explicitly configured retries for a given route, and you should only configure
retries when you know they’re safe.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Don’t Blindly Retry!</h1>
<p class="author1">Think before you enable retries<a data-primary="reliability" data-secondary="retries" data-tertiary="not always the answer" data-type="indexterm" id="id1463" class="calibre4"/><a data-primary="retries" data-secondary="not always the answer" data-type="indexterm" id="id1464" class="calibre4"/> for a particular request! Not all requests can
be safely retried—consider a request that withdraws money from an account,
and imagine retrying it in a scenario where the request succeeds but somehow
the response gets lost, or the withdrawal service crashes before it can send a
reply but after the money is moved. This is not a request that should be
retried.</p>
</div>








<section data-pdf-bookmark="Retry Budgets" data-type="sect2" class="preface"><div class="preface" id="id84">
<h2 class="calibre27">Retry Budgets</h2>

<p class="author1">Many service meshes and <a data-primary="reliability" data-secondary="retries" data-tertiary="budgeted retries" data-type="indexterm" id="id1465" class="calibre4"/><a data-primary="budgeted retries" data-type="indexterm" id="id1466" class="calibre4"/><a data-primary="budgeted retries" data-secondary="counted retries versus" data-type="indexterm" id="id1467" class="calibre4"/><a data-primary="counted retries versus budgeted retries" data-type="indexterm" id="id1468" class="calibre4"/><a data-primary="retries" data-secondary="reliability" data-tertiary="budgeted retries" data-type="indexterm" id="id1469" class="calibre4"/>API gateways use <em class="hyperlink">counted retries</em>, where you define a
maximum number of times a request can be retried before a failure is returned to the caller.
Linkerd, by contrast, uses <em class="hyperlink">budgeted retries</em>, where retrying continues as
long as the ratio of retries to original requests doesn’t exceed the budget.</p>

<p class="author1">By default, the budget is 20%, plus 10 more “free” retries per second,
averaged over 10 seconds. For example, if your workload is taking 100 requests per second (RPS),
then Linkerd would allow adding 30 more retries per second (20% of 100 is 20,
plus an additional 10).</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Budgeted Retries Versus Counted Retries</h1>
<p class="author1">Linkerd uses budgeted retries because they tend to let you more directly
control the thing you really care about: how much extra load will retries add
to the system? Usually, choosing a specific number of retries doesn’t really
help control load: if you’re taking 10 RPS and allow 3 retries, you’re up to
40 RPS, but if you’re at 100 RPS and allow 3 retries, you might be up to <em class="hyperlink">400</em>
RPS. 
<span class="calibre">Budgeted</span> retries control the added load much more directly, while also
tending to avoid the retry storms that can happen under high load (where large
amounts of retries can themselves crash a Pod, thus causing more retries…).</p>
</div>
</div></section>








<section data-pdf-bookmark="Configuring Retries" data-type="sect2" class="preface"><div class="preface" id="id85">
<h2 class="calibre27">Configuring Retries</h2>

<p class="author1">Take a minute to examine the traffic<a data-primary="reliability" data-secondary="retries" data-tertiary="configuring" data-type="indexterm" id="ch11-conre" class="calibre4"/><a data-primary="retries" data-secondary="reliability" data-tertiary="configuring retries" data-type="indexterm" id="ch11-conre2" class="calibre4"/> from <code class="calibre9">books</code> to <code class="calibre9">authors</code> using <code class="calibre9">linkerd viz</code>:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code>routes<code class="w"> </code>deploy/books<code class="w"> </code>--to<code class="w"> </code>svc/authors<code class="w"/></pre>

<p class="author1">You’ll see that the <code class="calibre9">books</code> workload is only sending requests to a single
route over on the <code class="calibre9">authors</code> service: <code class="calibre9">HEAD /authors/{id}.json</code>. Those requests
are failing half the time, making them a great candidate for retries—<code class="calibre9">HEAD</code>
requests are always idempotent (that is, they can always be repeated without the result changing), so we can always safely enable retries on that route.</p>

<p class="author1">In Linkerd, we control retry behavior<a data-primary="ServiceProfile resources" data-secondary="reliability" data-tertiary="retry behavior control" data-type="indexterm" id="ch11-sp" class="calibre4"/> with ServiceProfile resources. In this
case, we’ll be using the ServiceProfile for the <code class="calibre9">authors</code> service, since we’re
going to enable retries when talking <em class="hyperlink">to</em> the <code class="calibre9">authors</code> workload.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Retries, ServiceProfiles, HTTPRoutes, and Linkerd</h1>
<p class="author1">As mentioned earlier, the Linkerd project<a data-primary="Gateway API" data-secondary="Linkerd project toward fully adopting" data-type="indexterm" id="id1470" class="calibre4"/><a data-primary="APIs" data-secondary="Gateway API" data-tertiary="Linkerd project toward fully adopting" data-type="indexterm" id="id1471" class="calibre4"/><a data-primary="Linkerd" data-secondary="Gateway API full adoption" data-type="indexterm" id="id1472" class="calibre4"/><a data-primary="ServiceProfile resources" data-secondary="deprecation beginning" data-type="indexterm" id="id1473" class="calibre4"/> is in the midst of a transition to fully adopting
<a href="https://oreil.ly/a-Xug" class="calibre4">Gateway API</a>, which means you’ll soon see a few Linkerd custom resources, including
ServiceProfile, begin to be deprecated.</p>

<p class="author1">In Linkerd 2.13 and 2.14, ServiceProfile and HTTPRoute often have mutually
exclusive functionality, which makes it particularly important to review the<a data-primary="retries" data-secondary="documentation URL" data-type="indexterm" id="id1474" class="calibre4"/><a data-primary="reliability" data-secondary="retries" data-tertiary="documentation URL" data-type="indexterm" id="id1475" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="retries and timeouts" data-type="indexterm" id="id1476" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="retries and timeouts" data-type="indexterm" id="id1477" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="retries and timeouts" data-type="indexterm" id="id1478" class="calibre4"/>
<a href="https://oreil.ly/1EPEX" class="calibre4">retry and timeout
documentation</a> to verify the current state of ServiceProfile as you begin
building retries into your applications.</p>
</div>

<p class="author1">Start by looking at the existing ServiceProfile using <code class="calibre9">kubectl get</code>:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>serviceprofile<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code><code class="se">\</code>
<code class="w">    </code>authors.booksapp.svc.cluster.local<code class="w"/></pre>

<p class="author1">This ServiceProfile should look a lot like the one in <a data-type="xref" href="#EX-rel-authors-sp" class="calibre4">Example 11-1</a>.</p>
<div data-type="example" id="EX-rel-authors-sp" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-1. </span>The <code class="calibre9">authors</code> ServiceProfile</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">linkerd.io/v1alpha2</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">ServiceProfile</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">authors.booksapp.svc.cluster.local</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">booksapp</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">routes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET /authors.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">POST</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">POST /authors.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">DELETE</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">DELETE /authors/{id}.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET /authors/{id}.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">HEAD</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">HEAD /authors/{id}.json</code><code class="w"/></pre></div>

<p class="author1">You can see five routes listed in the ServiceProfile. We’re going to focus on the last route, <code class="calibre9">HEAD /authors/{id}.json</code>.</p>

<p class="author1">We can configure retries independently for each route by adding the
<code class="calibre9">isRetryable: true</code> property to the ServiceProfile entry for the route. In
addition to that, each ServiceProfile object can define the retry budget for
the all the routes in the ServiceProfile.</p>

<p class="author1">The easiest way to add this property is to interactively edit the ServiceProfile:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>kubectl<code class="w"> </code>edit<code class="w"> </code>serviceprofiles<code class="w"> </code>authors.booksapp.svc.cluster.local<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"/></pre>

<p class="author1">Use your editor to change the ServiceProfile so that the <code class="calibre9">HEAD
/authors/{id}.json</code> route has the <code class="calibre9">isRetryable</code> property set to <code class="calibre9">true</code>, as
shown in <a data-type="xref" href="#EX-rel-edited-authors" class="calibre4">Example 11-2</a>.</p>
<div data-type="example" id="EX-rel-edited-authors" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-2. </span>The <code class="calibre9">authors</code> ServiceProfile with retries</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">linkerd.io/v1alpha2</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">ServiceProfile</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">authors.booksapp.svc.cluster.local</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">booksapp</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">routes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET /authors.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">POST</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">POST /authors.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">DELETE</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">DELETE /authors/{id}.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET /authors/{id}.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">HEAD</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/authors/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">HEAD /authors/{id}.json</code><code class="w"/>
<code class="w">    </code><code class="nt">isRetryable</code><code class="p">:</code><code class="w"> </code><code class="calibre9">true</code><code class="w"/></pre></div>

<p class="author1">Save your changes to the <code class="calibre9">authors</code> ServiceProfile<a data-primary="Linkerd Viz extension" data-secondary="routes" data-tertiary="-o wide parameter" data-type="indexterm" id="id1479" class="calibre4"/> and examine the routes using 
<span class="calibre"><code class="calibre9">linkerd viz routes</code></span> once again, as shown here:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code>routes<code class="w"> </code>deploy/books<code class="w"> </code>--to<code class="w"> </code>svc/authors<code class="w"> </code>-o<code class="w"> </code>wide<code class="w"/></pre>

<p class="author1">Switching the output format using <code class="calibre9">-o wide</code> tells the <code class="calibre9">linkerd viz routes</code> command to show
the effective success rate (after retries) as well as the actual success rate
(before retries are taken into consideration). If you run this command repeatedly
after enabling retries, you’ll see that the effective success rate will climb
as the overall latency goes up. Over time, the effective success
rate should climb to 100%, even though the actual success rate stays
consistent at about 50%: the <code class="calibre9">authors</code> workload is still failing about half
the time, even though retries are able to mask that from the caller.<a data-startref="ch11-sp" data-type="indexterm" id="id1480" class="calibre4"/></p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">The watch Command</h1>
<p class="author1">If you have the <code class="calibre9">watch</code> command,<a data-primary="watch command" data-type="indexterm" id="id1481" class="calibre4"/><a data-primary="Linkerd Viz extension" data-secondary="routes" data-tertiary="watch command with" data-type="indexterm" id="id1482" class="calibre4"/> this is a great time to use it. It will rerun
the command every two seconds until interrupted, giving you an easy way to see
things changing:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre56">$<code class="w"> </code>watch<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code><code class="se">\</code>
<code class="w">    </code>routes<code class="w"> </code>deploy/books<code class="w"> </code>--to<code class="w"> </code>svc/authors<code class="w"> </code>-o<code class="w"> </code>wide<code class="w"/></pre>
</div>

<p class="author1">You can also see the difference in the effective and actual RPS.
The effective RPS is about 2.2, but the actual RPS will hover near
double that—that’s because <em class="hyperlink">retries add load to the failing service</em> by
making additional requests to mask the failures.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Why Are We Seeing a Factor of Two?</h1>
<p class="author1">We often quote the <a data-primary="retries" data-secondary="reliability" data-tertiary="default retry budget" data-type="indexterm" id="id1483" class="calibre4"/><a data-primary="reliability" data-secondary="retries" data-tertiary="default retry budget" data-type="indexterm" id="id1484" class="calibre4"/><a data-primary="budgeted retries" data-secondary="default retry budget" data-type="indexterm" id="id1485" class="calibre4"/>default retry budget as 20%—so how is it possible that
we’re seeing twice the traffic in this situation? For that matter, how is it
possible that we’re seeing Linkerd mask all the failures when <em class="hyperlink">50%</em> of
requests are failing?</p>

<p class="author1">The answer to both questions lies with the “free” 10 requests per second
included in the default budget. Since the actual load is significantly less
than 10 RPS, the extra 10 “free” requests per second are plenty to effectively
allow retrying 100% of the actual traffic, permitting Linkerd to mask all the
failures…at the cost of doubling the traffic.</p>

<p class="author1">Those “free” 10 RPS also mean that you don’t have to worry about Linkerd’s
budget letting failures leak through on a lightly used service, even while the
budget protects you from retry storms on a heavily used service.<a data-startref="ch11-conre" data-type="indexterm" id="id1486" class="calibre4"/><a data-startref="ch11-conre2" data-type="indexterm" id="id1487" class="calibre4"/></p>
</div>
</div></section>








<section data-pdf-bookmark="Configuring the Budget" data-type="sect2" class="preface"><div class="preface" id="id168">
<h2 class="calibre27">Configuring the Budget</h2>

<p class="author1">Linkerd’s default budget actually<a data-primary="reliability" data-secondary="retries" data-tertiary="configuring the budget" data-type="indexterm" id="id1488" class="calibre4"/><a data-primary="retries" data-secondary="reliability" data-tertiary="configuring the budget" data-type="indexterm" id="id1489" class="calibre4"/><a data-primary="budgeted retries" data-secondary="configuring the budget" data-type="indexterm" id="id1490" class="calibre4"/> works out well for many applications,
but if you need to change it, you’ll need to edit the <code class="calibre9">retryBudget</code> stanza in
your ServiceProfile, as shown in <a data-type="xref" href="#EX-rel-retry-budget" class="calibre4">Example 11-3</a>.</p>
<div data-type="example" id="EX-rel-retry-budget" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-3. </span>An example retry budget</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="p">...</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p">...</code><code class="w"/>
<code class="w">  </code><code class="c"># This retryBudget stanza is AN EXAMPLE ONLY</code><code class="w"/>
<code class="w">  </code><code class="nt">retryBudget</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">retryRatio</code><code class="p">:</code><code class="w"> </code><code class="calibre9">0.3</code><code class="w"/>
<code class="w">    </code><code class="nt">minRetriesPerSecond</code><code class="p">:</code><code class="w"> </code><code class="calibre9">50</code><code class="w"/>
<code class="w">    </code><code class="nt">ttl</code><code class="p">:</code><code class="w"> </code><code class="calibre9">60s</code><code class="w"/>
<code class="w">  </code><code class="p">...</code><code class="w"/></pre></div>

<p class="author1">The <code class="calibre9">retryBudget</code> stanza shown in <a data-type="xref" href="#EX-rel-retry-budget" class="calibre4">Example 11-3</a> would allow retrying
30% of original requests, plus <em class="hyperlink">50</em> “free” requests per second, averaged over
a full minute.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Don’t Blindly Use This Budget!</h1>
<p class="author1">The budget shown in <a data-type="xref" href="#EX-rel-retry-budget" class="calibre4">Example 11-3</a> is <em class="hyperlink">just an example</em>. Please do
not assume that it will be helpful for any actual application!</p>
</div>
</div></section>
</div></section>






<section data-pdf-bookmark="Timeouts" data-type="sect1" class="preface"><div class="preface" id="id86">
<h1 class="calibre8">Timeouts</h1>

<p class="author1">Timeouts are a tool that allows<a data-primary="reliability" data-secondary="timeouts" data-type="indexterm" id="id1491" class="calibre4"/><a data-primary="timeouts" data-type="indexterm" id="id1492" class="calibre4"/> us to force a failure in the event a given
request is taking too long. They’re particularly effective when used hand-in-hand with
retries, so that a request that takes too long will be retried—but you
don’t have to use them together! There are a lot of situations where a
judiciously placed timeout can help return agency to an application, opening
the door to providing a better user experience by making intelligent decisions
about what to do if things are slow.</p>

<p class="author1">When timeouts are configured<a data-primary="timeouts" data-secondary="HTTP 504 returned" data-type="indexterm" id="id1493" class="calibre4"/><a data-primary="reliability" data-secondary="timeouts" data-tertiary="HTTP 504 returned" data-type="indexterm" id="id1494" class="calibre4"/><a data-primary="HTTP errors" data-secondary="HTTP 504" data-type="indexterm" id="id1495" class="calibre4"/> and a request takes too long, the Linkerd proxy
will return an HTTP 504 for the request. <a data-primary="retries" data-secondary="timeouts triggering" data-type="indexterm" id="id1496" class="calibre4"/><a data-primary="reliability" data-secondary="retries" data-tertiary="timeouts triggering" data-type="indexterm" id="id1497" class="calibre4"/><a data-primary="request failure" data-secondary="timeouts as" data-type="indexterm" id="id1498" class="calibre4"/>The timeout will look like any other
request failure as far as Linkerd’s observability functionality is concerned
(including triggering a retry, if retries are enabled), and it will be counted
toward the effective failure rate on a given route.</p>








<section class="preface" data-pdf-bookmark="Configuring Timeouts" data-type="sect2"><div class="preface" id="id87">
<h2 class="calibre27">Configuring Timeouts</h2>

<p class="author1">Let’s start things off by taking<a data-primary="reliability" data-secondary="timeouts" data-tertiary="configuring" data-type="indexterm" id="ch11-toc" class="calibre4"/><a data-primary="timeouts" data-secondary="configuring" data-type="indexterm" id="ch11-toc2" class="calibre4"/><a data-primary="ServiceProfile resources" data-secondary="reliability" data-tertiary="timeout configuration" data-type="indexterm" id="ch11-toc3" class="calibre4"/> a look at requests from <code class="calibre9">webapp</code> to <code class="calibre9">books</code>,
to see what the average latency for user requests looks like:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code>routes<code class="w"> </code>deploy/webapp<code class="w"> </code>--to<code class="w"> </code>svc/books<code class="w"/></pre>

<p class="author1">Let’s focus on the <code class="calibre9">PUT /books/{id}.json</code> route. Latency varies from
environment to environment, but we’ll start with a latency of 25 ms for our
example; this will probably result in some timeouts being triggered in most
environments. You can use the resulting success rates to tune the timeouts in
your cluster.</p>

<p class="author1">Just like retries, timeouts are configured via ServiceProfiles in Linkerd. As we did with retries, we’ll start by looking at the existing profile. We can get the <code class="calibre9">books</code> ServiceProfile with this command:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>sp/books.booksapp.svc.cluster.local<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code>-o<code class="w"> </code>yaml<code class="w"/></pre>

<p class="author1">This ServiceProfile should look very similar to the one in
<a data-type="xref" href="#EX-rel-books-sp" class="calibre4">Example 11-4</a>.</p>
<div data-type="example" id="EX-rel-books-sp" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-4. </span>The <code class="calibre9">books</code> ServiceProfile</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">linkerd.io/v1alpha2</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">ServiceProfile</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">books.booksapp.svc.cluster.local</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">booksapp</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">routes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET /books.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">POST</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">POST /books.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">DELETE</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">DELETE /books/{id}.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET /books/{id}.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">PUT</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">PUT /books/{id}.json</code><code class="w"/></pre></div>

<p class="author1">We configure timeouts by adding the <code class="calibre9">timeout</code> property to a route entry,
setting its value to a time specification that can be parsed by Go’s
<code class="calibre9">time.ParseDuration</code>.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Timeouts, ServiceProfiles, HTTPRoutes, and Linkerd</h1>
<p class="author1">As mentioned earlier, the Linkerd project<a data-primary="Gateway API" data-secondary="Linkerd project toward fully adopting" data-type="indexterm" id="id1499" class="calibre4"/><a data-primary="APIs" data-secondary="Gateway API" data-tertiary="Linkerd project toward fully adopting" data-type="indexterm" id="id1500" class="calibre4"/><a data-primary="Linkerd" data-secondary="Gateway API full adoption" data-type="indexterm" id="id1501" class="calibre4"/><a data-primary="ServiceProfile resources" data-secondary="deprecation beginning" data-type="indexterm" id="id1502" class="calibre4"/> is in the midst of a transition to fully adopting
<a href="https://oreil.ly/6XTtV" class="calibre4">Gateway API</a>, so a few Linkerd custom resources, including
ServiceProfile, will soon begin to be 
<span class="calibre">deprecated.</span></p>

<p class="author1">ServiceProfile and HTTPRoute have overlapping functionality for timeouts
starting with Gateway API 1.0.0, which at the time of writing is not yet supported by a stable
Linkerd version. <a data-primary="retries" data-secondary="documentation URL" data-type="indexterm" id="id1503" class="calibre4"/><a data-primary="reliability" data-secondary="retries" data-tertiary="documentation URL" data-type="indexterm" id="id1504" class="calibre4"/><a data-primary="timeouts" data-secondary="documentation URL" data-type="indexterm" id="id1505" class="calibre4"/><a data-primary="reliability" data-secondary="timeouts" data-tertiary="documentation URL" data-type="indexterm" id="id1506" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="retries and timeouts" data-type="indexterm" id="id1507" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="retries and timeouts" data-type="indexterm" id="id1508" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="retries and timeouts" data-type="indexterm" id="id1509" class="calibre4"/>It’s particularly important to review the
<a href="https://oreil.ly/41V-2" class="calibre4">retry and timeout
documentation</a> to verify the current state of ServiceProfile as you begin
building retries into your applications.</p>

<p class="author1">One particular note is that the<a data-primary="HTTPRoute resource" data-secondary="timeout syntax versus ServiceProfile timeouts" data-type="indexterm" id="id1510" class="calibre4"/><a data-primary="ServiceProfile resources" data-secondary="reliability" data-tertiary="timeout syntax future compatibility" data-type="indexterm" id="id1511" class="calibre4"/> syntax for HTTPRoute timeouts, specified by
<a href="https://oreil.ly/lxLGa" class="calibre4">GEP-2257</a>, is rather more restrictive
than Go’s 
<span class="calibre"><code class="calibre9">time.ParseDu⁠ration</code></span>, which is used for 
<span class="calibre">ServiceProfile</span> timeouts.
For maximum compatibility in the future, you may want to consider updating
your ServiceProfile timeouts to conform to GEP-2257.</p>
</div>

<p class="author1">The simplest way to add a timeout to the <code class="calibre9">PUT /books/{id}.json</code> route is to
edit the ServiceProfile interactively, which you can do using the following command:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>kubectl<code class="w"> </code>edit<code class="w"> </code>serviceprofiles.linkerd.io<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>books.booksapp.svc.cluster.local<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"/></pre>

<p class="author1">You will need to add the <code class="calibre9">timeout</code> element to the <code class="calibre9">PUT /books/{id}.json</code>
route, with a value of <code class="calibre9">25ms</code>. This is shown in <a data-type="xref" href="#EX-rel-edited-books-sp" class="calibre4">Example 11-5</a>.</p>
<div data-type="example" id="EX-rel-edited-books-sp" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-5. </span>The <code class="calibre9">books</code> ServiceProfile with a timeout</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">linkerd.io/v1alpha2</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">ServiceProfile</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">books.booksapp.svc.cluster.local</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">booksapp</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">routes</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET /books.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">POST</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">POST /books.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">DELETE</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">DELETE /books/{id}.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">GET /books/{id}.json</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">condition</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">method</code><code class="p">:</code><code class="w"> </code><code class="calibre9">PUT</code><code class="w"/>
<code class="w">      </code><code class="nt">pathRegex</code><code class="p">:</code><code class="w"> </code><code class="calibre9">/books/[^/]*\.json</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">PUT /books/{id}.json</code><code class="w"/>
<code class="w">    </code><code class="nt">timeout</code><code class="p">:</code><code class="w"> </code><code class="calibre9">25ms</code><code class="w"/></pre></div>

<p class="author1">With the timeout set, you’ll want <a data-primary="Linkerd Viz extension" data-secondary="routes" data-tertiary="timeout impact" data-type="indexterm" id="id1512" class="calibre4"/>to observe the traffic going from the
<code class="calibre9">webapp</code> to the <code class="calibre9">books</code> service to see how the timeout is impacting the
overall availability of your service. Once again, <code class="calibre9">linkerd viz routes</code> is one
of the simplest ways to do this:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>-n<code class="w"> </code>booksapp<code class="w"> </code>routes<code class="w"> </code>deploy/webapp<code class="w"> </code>--to<code class="w"> </code>svc/books<code class="w"/></pre>

<p class="author1">(You can use <code class="calibre9">-o wide</code> if <a data-primary="Linkerd Viz extension" data-secondary="routes" data-tertiary="-o wide parameter" data-type="indexterm" id="id1513" class="calibre4"/>you want—it won’t directly help you when observing
latency, but it’s certainly not harmful.)</p>

<p class="author1">Timeouts provide a valuable tool to ensure the overall availability of your applications. They allow you to control latency and ensure applications don’t hang while waiting for responses from downstream services.<a data-startref="ch11-toc" data-type="indexterm" id="id1514" class="calibre4"/><a data-startref="ch11-toc2" data-type="indexterm" id="id1515" class="calibre4"/><a data-startref="ch11-toc3" data-type="indexterm" id="id1516" class="calibre4"/></p>
</div></section>
</div></section>






<section data-pdf-bookmark="Traffic Shifting" data-type="sect1" class="preface"><div class="preface" id="id88">
<h1 class="calibre8">Traffic Shifting</h1>

<p class="author1"><em class="hyperlink">Traffic shifting</em> refers to changing<a data-primary="reliability" data-secondary="traffic shifting" data-type="indexterm" id="id1517" class="calibre4"/><a data-primary="traffic shifting" data-type="indexterm" id="id1518" class="calibre4"/> the destination of a request based on
outside criteria. <a data-primary="traffic shifting" data-secondary="weight-based routing (canary)" data-type="indexterm" id="id1519" class="calibre4"/><a data-primary="reliability" data-secondary="traffic shifting" data-tertiary="weight-based routing (canary)" data-type="indexterm" id="id1520" class="calibre4"/><a data-primary="traffic shifting" data-secondary="header-based routing (A/B testing)" data-type="indexterm" id="id1521" class="calibre4"/><a data-primary="reliability" data-secondary="traffic shifting" data-tertiary="header-based routing (A/B testing)" data-type="indexterm" id="id1522" class="calibre4"/>Typically this is a weighted split between two or more
destinations (a <em class="hyperlink">canary</em>), or a split based on a header match, username, etc.
(an <em class="hyperlink">A/B split</em>), although many other types are possible. Traffic shifting is
a major part of progressive delivery, where you roll out new application
versions by carefully shifting traffic to the new version and verifying
functionality as you go. However, you needn’t do progressive delivery to benefit
from traffic shifting.</p>








<section data-pdf-bookmark="Traffic Shifting, Gateway API, and the Linkerd SMI Extension" data-type="sect2" class="preface"><div class="preface" id="id169">
<h2 class="calibre27">Traffic Shifting, Gateway API, and the Linkerd SMI Extension</h2>

<p class="author1">As of Linkerd 2.13, Linkerd natively <a data-primary="reliability" data-secondary="traffic shifting" data-tertiary="Gateway API HTTPRoute resource" data-type="indexterm" id="id1523" class="calibre4"/><a data-primary="traffic shifting" data-secondary="Gateway API HTTPRoute resource" data-type="indexterm" id="id1524" class="calibre4"/><a data-primary="Gateway API" data-secondary="traffic shifting" data-type="indexterm" id="id1525" class="calibre4"/><a data-primary="HTTPRoute resource" data-secondary="traffic shifting" data-type="indexterm" id="id1526" class="calibre4"/><a data-primary="APIs" data-secondary="Gateway API" data-tertiary="traffic shifting" data-type="indexterm" id="id1527" class="calibre4"/>supports traffic shifting using the

<span class="calibre">Gateway API</span> HTTPRoute resource, so traffic shifting is the first area where
we’ll use Gateway 
<span class="calibre">API resources</span> to configure Linkerd.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">HTTPRoutes Versus Linkerd SMI</h1>
<p class="author1">In Linkerd versions prior to 2.13, you can<a data-primary="Linkerd SMI (Service Mesh Interface) extension" data-secondary="HTTPRoutes unavailable for traffic shifting" data-type="indexterm" id="id1528" class="calibre4"/> still do traffic shifting, but you
need to use the Linkerd SMI extension (which we mentioned in
<a data-type="xref" href="ch02.html#LUAR_intro_to_linkerd" class="calibre4">Chapter 2</a>). <a data-primary="Linkerd SMI (Service Mesh Interface) extension" data-secondary="documentation URL" data-type="indexterm" id="id1529" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="SMI extension" data-type="indexterm" id="id1530" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="SMI extension" data-type="indexterm" id="id1531" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="SMI extension" data-type="indexterm" id="id1532" class="calibre4"/>For information about the SMI extension and its
legacy TrafficSplit resources, check out the <a href="https://oreil.ly/56HlN" class="calibre4">official Linkerd docs on SMI</a>. We recommend
using Gateway API in 2.13 and later, though.</p>
</div>

<p class="author1">As we explore traffic shifting in Linkerd, we’ll look at the two basic ways of doing it: weight-based and header-based.</p>
</div></section>








<section data-pdf-bookmark="Setting Up Your Environment" data-type="sect2" class="preface"><div class="preface" id="id89">
<h2 class="calibre27">Setting Up Your Environment</h2>

<p class="author1">In this section we’ll be demonstrating traffic shifting using an entirely<a data-primary="reliability" data-secondary="traffic shifting" data-tertiary="setting up podinfo" data-type="indexterm" id="ch11-pod" class="calibre4"/><a data-primary="traffic shifting" data-secondary="setting up podinfo" data-type="indexterm" id="ch11-pod2" class="calibre4"/><a data-primary="podinfo for traffic shifting" data-secondary="setting up" data-type="indexterm" id="ch11-pod3" class="calibre4"/>
different application called <a href="https://oreil.ly/1IL4K" class="calibre4">podinfo</a>. To follow along with the
traffic shifting demos, we recommend you start a new cluster; please refer to
the material in <a data-type="xref" href="ch03.html#LUAR_deploying_linkerd" class="calibre4">Chapter 3</a> if you need any help with that.</p>

<p class="author1">Once you have your new cluster, you can follow along with
<a data-type="xref" href="#EX-rel-setup-podinfo" class="calibre4">Example 11-6</a> to get started shifting traffic with podinfo.</p>
<div data-type="example" id="EX-rel-setup-podinfo" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-6. </span>Launching podinfo</h5>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Start in a clean working directory, as we will be cloning the</code>
<code class="c"># linkerd-book/luar Git repository.</code>
$<code class="w"> </code>git<code class="w"> </code>clone<code class="w"> </code>https://github.com/linkerd-book/luar.git<code class="w"/>

<code class="c"># First, we'll create our namespace, podinfo, with the</code>
<code class="c"># linkerd.io/inject: enabled annotation set on it. This will</code>
<code class="c"># ensure our Pods get Linkerd proxies attached to them.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>luar/reliability/ns.yaml<code class="w"/>

<code class="c"># Next, we'll install the podinfo application using Helm.</code>
$<code class="w"> </code>helm<code class="w"> </code>repo<code class="w"> </code>add<code class="w"> </code>podinfo<code class="w"> </code>https://stefanprodan.github.io/podinfo<code class="w"/>
$<code class="w"> </code>helm<code class="w"> </code>repo<code class="w"> </code>up<code class="w"/>

<code class="c"># Install 3 versions of podinfo:</code>
<code class="c"># - podinfo is our "version 1" Pod.</code>
<code class="c"># - podinfo-2 is our "version 2" Pod.</code>
<code class="c"># - frontend is a frontend to the whole thing.</code>
$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code>podinfo<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>--namespace<code class="w"> </code>podinfo<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>--set<code class="w"> </code>ui.message<code class="o">=</code><code class="s">"hello from v1"</code><code class="w"> </code><code class="se">\</code>
<code class="w">     </code>podinfo/podinfo<code class="w"/>
<code class="w"> </code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting">$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code>podinfo-2<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>--namespace<code class="w"> </code>podinfo<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>--set<code class="w"> </code>ui.message<code class="o">=</code><code class="s">"hello from v2"</code><code class="w"> </code><code class="se">\</code>
<code class="w">     </code>podinfo/podinfo<code class="w"/>

$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code>frontend<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>--namespace<code class="w"> </code>podinfo<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>--set<code class="w"> </code><code class="nv">backend</code><code class="o">=</code>http://podinfo:9898/env<code class="w"> </code><code class="se">\</code>
<code class="w">     </code>podinfo/podinfo<code class="w"/>

<code class="c"># Create a traffic generator for podinfo.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>luar/reliability/generator.yaml<code class="w"/>

<code class="c"># Check that the applications are ready.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>check<code class="w"> </code>--proxy<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"/>

<code class="c"># Verify that both versions of the podinfo workload are running.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"/>

<code class="c"># Verify that each version of podinfo has its own Service.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>svc<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"/></pre></div>

<p class="author1">With that, we have our base demo application ready for traffic splitting. The
basic layout of our application is shown in <a data-type="xref" href="#podinfo" class="calibre4">Figure 11-2</a>.</p>

<figure class="calibre23"><div class="figure" id="podinfo">
<img alt="luar 1102" src="assets/luar_1102.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 11-2. </span>podinfo application architecture</h6>
</div></figure>

<p class="author1">Next, you’ll want to watch how traffic is moving through your cluster. It’s
best to start this running in a separate window, as shown in
<a data-type="xref" href="#EX-rel-watch-podinfo" class="calibre4">Example 11-7</a>, so you can see what changes as you manipulate
resources.</p>
<div class="calibre40" data-type="example" id="EX-rel-watch-podinfo">
<h5 class="calibre41"><span class="calibre">Example 11-7. </span>Watching podinfo traffic</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># If you have the watch command, it works well for this.</code>
$<code class="w"> </code>watch<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"/>

<code class="c"># If you don't have watch, it's simple enough to emulate.</code>
$<code class="w"> </code><code class="k">while</code><code class="w"> </code>true<code class="p">;</code><code class="w"> </code><code class="k">do</code><code class="w"/>
<code class="w">  </code>clear<code class="w"/>
<code class="w">  </code>date<code class="w"/>
<code class="w">  </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>deploy<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"/>
<code class="w">  </code>sleep<code class="w"> </code><code class="m">2</code><code class="w"/>
<code class="k">done</code><code class="w"/></pre></div>

<p class="author1">This will show you how traffic is being routed in your cluster. You should see
two podinfo deployments, <code class="calibre9">podinfo</code> and <code class="calibre9">podinfo-v2</code>. <code class="calibre9">podinfo-v2</code> should be
receiving very little traffic at the moment since we haven’t yet shifted any
traffic to it.<a data-startref="ch11-pod" data-type="indexterm" id="id1533" class="calibre4"/><a data-startref="ch11-pod2" data-type="indexterm" id="id1534" class="calibre4"/><a data-startref="ch11-pod3" data-type="indexterm" id="id1535" class="calibre4"/></p>
</div></section>








<section data-pdf-bookmark="Weight-Based Routing (Canary)" data-type="sect2" class="preface"><div class="preface" id="id170">
<h2 class="calibre27">Weight-Based Routing (Canary)</h2>

<p class="author1"><em class="hyperlink">Weight-based routing</em> is a method<a data-primary="traffic shifting" data-secondary="weight-based routing (canary)" data-type="indexterm" id="ch11-canrt" class="calibre4"/><a data-primary="reliability" data-secondary="traffic shifting" data-tertiary="weight-based routing (canary)" data-type="indexterm" id="ch11-canrt2" class="calibre4"/><a data-primary="podinfo for traffic shifting" data-secondary="weight-based routing (canary)" data-type="indexterm" id="ch11-canrt3" class="calibre4"/> of shifting traffic that selects where a
given request will go based on simple percentages: a certain percentage of
available traffic goes to one destination, and the rest goes to another.
Weight-based routing allows us to shift a small percentage of traffic to the
new version of a service to see how it behaves.</p>

<p class="author1">In progressive delivery this is called <em class="hyperlink">canary routing</em>, named after the
proverbial “canary in a coal mine” that would warn miners when
the air was going bad by dying. Here, the idea is that you can shift a small
amount of traffic to test if the new version of your workload will die, or
work, before you shift more traffic. A successful canary ends when all the
traffic has been shifted and the old version can be retired.</p>

<p class="author1">To start the canary running, <a data-primary="HTTPRoute resource" data-secondary="traffic shifting" data-tertiary="weight-based routing (canary routing)" data-type="indexterm" id="ch11-htca" class="calibre4"/>we’ll need to create an HTTPRoute, as shown in

<span class="calibre"><a data-type="xref" href="#EX-rel-canary-route" class="calibre4">Example 11-8</a>.</span></p>
<div class="calibre18" data-type="warning" epub:type="warning" id="which_httproute_ch11_LUAR_reliability_1710429511809"><h1 class="calibre35">Which HTTPRoute?</h1>
<p class="author1">We’re going to use <code class="calibre9">policy.linkerd.io</code> HTTPRoutes to accommodate readers with
older versions of Linkerd. It’s important to be aware, though, that tools like
Flagger and Argo Rollouts <em class="hyperlink">do not</em> support <code class="calibre9">policy.linkerd.io</code>! If you’re using
one of these tools, you’ll need to use the <code class="calibre9">gateway.networking.k8s.io</code>
HTTPRoutes, which requires Linkerd 2.14 or higher.</p>
</div>
<div class="calibre40" data-type="example" id="EX-rel-canary-route">
<h5 class="calibre41"><span class="calibre">Example 11-8. </span>The canary HTTPRoute</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nn">---</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">policy.linkerd.io/v1beta2</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">HTTPRoute</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo-route</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">parentRefs</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo</code><code class="w"/>
<code class="w">      </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo</code><code class="w"/>
<code class="w">      </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">Service</code><code class="w"/>
<code class="w">      </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="calibre9">core</code><code class="w"/>
<code class="w">      </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">9898</code><code class="w"/>
<code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">backendRefs</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo</code><code class="w"/>
<code class="w">      </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo</code><code class="w"/>
<code class="w">      </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">9898</code><code class="w"/>
<code class="w">      </code><code class="nt">weight</code><code class="p">:</code><code class="w"> </code><code class="calibre9">5</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo-v2</code><code class="w"/>
<code class="w">      </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo</code><code class="w"/>
<code class="w">      </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">9898</code><code class="w"/>
<code class="w">      </code><code class="nt">weight</code><code class="p">:</code><code class="w"> </code><code class="calibre9">5</code><code class="w"/></pre></div>

<p class="author1">This HTTPRoute will split traffic between the <code class="calibre9">podinfo</code> and <code class="calibre9">podinfo-v2</code>
services. We set the weight to 5 for both services,
which will cause 50% of the traffic to shift over to <code class="calibre9">podinfo-v2</code>,
while leaving 50% with our original <code class="calibre9">podinfo</code>.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">The Ratio Is What Matters</h1>
<p class="author1">The absolute values of the weights don’t usually matter—they don’t need to
add up to any particular number. What does matter is the <em class="hyperlink">ratio</em> of weights, so
using weights of 5 and 5, or 100 and 100, or 1 and 1 would all give 50/50
splits.</p>

<p class="author1">On the other hand, a weight of 0 explicitly means <em class="hyperlink">not</em> to direct any traffic
to that backend—so don’t try to use 0/0 for a 50/50 split.</p>
</div>










<section data-pdf-bookmark="Service versus Service: ClusterIPs, endpoints, and HTTPRoutes" data-type="sect3" class="preface"><div class="preface" id="id90">
<h3 class="calibre33">Service versus Service: ClusterIPs, endpoints, and HTTPRoutes</h3>

<p class="author1">The astute reader will notice that<a data-primary="podinfo for traffic shifting" data-secondary="parentRefs versus backendRefs" data-type="indexterm" id="id1536" class="calibre4"/><a data-primary="HTTPRoute resource" data-secondary="traffic shifting" data-tertiary="parentRefs versus backendRefs" data-type="indexterm" id="id1537" class="calibre4"/><a data-primary="Services" data-secondary="parentRefs versus backendRefs" data-type="indexterm" id="id1538" class="calibre4"/><a data-primary="GAMMA initiative" data-secondary="Services and parentRefs versus backendRefs" data-type="indexterm" id="id1539" class="calibre4"/> we’re using <code class="calibre9">podinfo</code> twice: once in
<code class="calibre9">parentRefs</code> and once in <code class="calibre9">backendRefs</code>. Won’t this cause a routing loop? Aren’t
we arranging for traffic to come to <code class="calibre9">podinfo</code>, then get directed to <code class="calibre9">podinfo</code>
again, and do this forever until eventually it finally gets shuffled to
<code class="calibre9">podinfo-v2</code>?</p>

<p class="author1">Rest assured that that won’t happen. If we go back to the Kubernetes Service
architecture shown in <a data-type="xref" href="#k8s-service-architecture-3" class="calibre4">Figure 11-3</a>, the critical bits are that:</p>

<ul class="printings">
<li class="calibre6">
<p class="author1">When a Service is used in <code class="calibre9">parentRefs</code>, it means that the HTTPRoute will control traffic directed to the Service.</p>
</li>
<li class="calibre6">
<p class="author1">When a Service is used in <code class="calibre9">backendRefs</code>, it allows the HTTPRoute to direct traffic to the Pods attached to the Service.</p>
</li>
</ul>

<figure class="calibre23"><div class="figure" id="k8s-service-architecture-3">
<img alt="luar 1103" src="assets/luar_1103.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 11-3. </span>The three distinct parts of a Kubernetes Service</h6>
</div></figure>

<p class="author1">So what we’re really saying with <code class="calibre9">podinfo-route</code> is that 95% of the traffic
to the <code class="calibre9">podinfo</code> Service IP will be directed to the <code class="calibre9">podinfo</code> <em class="hyperlink">endpoints</em>,
and the other 5% will be directed to the <code class="calibre9">podinfo-v2</code> <em class="hyperlink">endpoints</em>, so there
are no loops. <a data-primary="GAMMA initiative" data-secondary="GEP-1426 URL" data-type="indexterm" id="id1540" class="calibre4"/><a data-primary="GEP-1426 URL" data-type="indexterm" id="id1541" class="calibre4"/><a data-primary="resources online" data-secondary="GAMMA initiative GEP-1426" data-type="indexterm" id="id1542" class="calibre4"/>This behavior is defined in
<a href="https://oreil.ly/uYWpL" class="calibre4">GEP-1426</a> from the GAMMA
initiative.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">You Can’t Route to a Route</h1>
<p class="author1">GEP-1426 also prevents HTTPRoutes from “stacking.” Suppose that we apply <code class="calibre9">podinfo-route</code> as shown in
<a data-type="xref" href="#EX-rel-canary-route" class="calibre4">Example 11-8</a>, then also apply another HTTPRoute
(<code class="calibre9">podinfo-v2-canary</code>) that tries to split traffic to <code class="calibre9">podinfo-v2</code>. In that case:</p>

<ul class="calibre43">
<li class="calibre6">
<p class="author1">Traffic sent directly to <code class="calibre9">podinfo-v2</code> <em class="hyperlink">will</em> be split by
<code class="calibre9">podinfo-v2-canary</code>.</p>
</li>
<li class="calibre6">
<p class="author1">Traffic sent to <code class="calibre9">podinfo</code> that <code class="calibre9">podinfo-route</code> then directs to <code class="calibre9">podinfo-v2</code>
will <em class="hyperlink">not</em> be split.</p>
</li>
</ul>

<p class="author1">This is because <code class="calibre9">podinfo-route</code> will send its traffic directly to the
<code class="calibre9">podinfo-v2</code> <em class="hyperlink">endpoints</em>. Since that traffic bypasses the <code class="calibre9">podinfo-v2</code>
Service IP, <code class="calibre9">podinfo-v2-canary</code> never gets a chance to work with it.</p>
</div>

<p class="author1">Apply <code class="calibre9">podinfo-route</code> to your cluster and take a look at how the traffic
shifts in your terminal window that’s watching traffic. You’ll see around 25
requests per second going to the v2 deployment (remember that it will take a
little time for the metrics that <code class="calibre9">linkerd viz</code> is watching to catch up).</p>

<p class="author1">You can modify the weights and see how traffic shifts around in real time:
just use <code class="calibre9">kubectl edit</code> as shown here:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>kubectl<code class="w"> </code>edit<code class="w"> </code>httproute<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"> </code>podinfo-route<code class="w"/></pre>

<p class="author1">As soon as you save an edited version, the new weights should instantly take
effect, changing what you see in your window that’s watching traffic.</p>

<p class="author1">Once you’re finished, go ahead and delete the <code class="calibre9">podinfo-route</code> route, using the following command:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>kubectl<code class="w"> </code>delete<code class="w"> </code>httproute<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"> </code>podinfo-route<code class="w"/></pre>

<p class="author1">You should see all the traffic shifting back to
<code class="calibre9">podinfo</code>, setting the stage for our header-based routing experiment.<a data-startref="ch11-canrt" data-type="indexterm" id="id1543" class="calibre4"/><a data-startref="ch11-canrt2" data-type="indexterm" id="id1544" class="calibre4"/><a data-startref="ch11-htca" data-type="indexterm" id="id1545" class="calibre4"/><a data-startref="ch11-canrt3" data-type="indexterm" id="id1546" class="calibre4"/></p>
</div></section>
</div></section>








<section data-pdf-bookmark="Header-Based Routing (A/B Testing)" data-type="sect2" class="preface"><div class="preface" id="id171">
<h2 class="calibre27">Header-Based Routing (A/B Testing)</h2>

<p class="author1"><em class="hyperlink">Header-based routing</em> allows you to<a data-primary="traffic shifting" data-secondary="header-based routing (A/B testing)" data-type="indexterm" id="id1547" class="calibre4"/><a data-primary="reliability" data-secondary="traffic shifting" data-tertiary="header-based routing (A/B testing)" data-type="indexterm" id="id1548" class="calibre4"/><a data-primary="podinfo for traffic shifting" data-secondary="header-based routing (A/B testing)" data-type="indexterm" id="id1549" class="calibre4"/> make routing decisions based on the headers
included in a request. This is commonly used for A/B testing. For example,
if you have two versions of a user interface, you typically don’t want to
randomly choose between them every time your user loads a page. Instead, you might use some
header that identifies the user to pick a version of the UI in a deterministic
way, so that a given user will always see a consistent UI, but different users
might get different UIs.</p>

<p class="author1">We’ll use header-based routing to allow selecting a version of <code class="calibre9">podinfo</code> using
a header. Start by applying a new <code class="calibre9">podinfo-route</code> HTTPRoute, as shown in
<a data-type="xref" href="#EX-rel-ab-route" class="calibre4">Example 11-9</a>. (Once again, we’re going to use <code class="calibre9">policy.linkerd.io</code> HTTPRoutes;
see <a data-type="xref" href="#which_httproute_ch11_LUAR_reliability_1710429511809" class="calibre4">“Which HTTPRoute?”</a> for a caveat on this choice.)</p>
<div data-type="example" id="EX-rel-ab-route" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-9. </span>Header-based routing</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">policy.linkerd.io/v1beta2</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">HTTPRoute</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo-route</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">parentRefs</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">podinfo</code><code class="w"/>
<code class="w">      </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">Service</code><code class="w"/>
<code class="w">      </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="calibre9">core</code><code class="w"/>
<code class="w">      </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">9898</code><code class="w"/>
<code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">matches</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">headers</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="s">"x-request-id"</code><code class="w"/>
<code class="w">          </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">"alternative"</code><code class="w"/>
<code class="w">      </code><code class="nt">backendRefs</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="s">"podinfo-v2"</code><code class="w"/>
<code class="w">          </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">9898</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">backendRefs</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="s">"podinfo"</code><code class="w"/>
<code class="w">        </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">9898</code><code class="w"/></pre></div>

<p class="author1">(If you were just following the instructions for weight-based routing, that’s
fine; this <code class="calibre9">podinfo-route</code> will overwrite the one from that section if you
didn’t already 
<span class="calibre">delete it.)</span></p>

<p class="author1">This version has a new <code class="calibre9">matches</code> section for header matches. We also move the
reference to <code class="calibre9">podinfo-v2</code> from the main <code class="calibre9">backendRefs</code> section to a new
<code class="calibre9">backendRefs</code> under <code class="calibre9">matches</code>. The effect is that traffic will be shifted
to <code class="calibre9">podinfo-v2</code> only if it has the header <code class="calibre9">x-request-id</code> with a value of
<code class="calibre9">alternative</code>.</p>

<p class="author1">Since the traffic generator we installed doesn’t send any requests with the
correct header, when you apply this HTTPRoute, you should immediately see all
the traffic fall away from <code class="calibre9">podinfo-v2</code>. We can use <code class="calibre9">curl</code> to send traffic with
the correct header to be routed to <code class="calibre9">podinfo-v2</code>, as shown in
<a data-type="xref" href="#EX-rel-curl-header" class="calibre4">Example 11-10</a>.</p>
<div data-type="example" id="EX-rel-curl-header" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-10. </span>Testing header-based routing with <code class="calibre9">curl</code></h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Start by forwarding traffic to your frontend service.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>port-forward<code class="w"> </code>svc/frontend-podinfo<code class="w"> </code><code class="m">9898</code>:9898<code class="w"> </code><code class="p">&amp;</code><code class="w"/>

<code class="c"># Now send a request to the service and see what message you get back.</code>
<code class="c"># You should see "hello from v1" since this request didn't include the</code>
<code class="c"># header.</code>
$<code class="w"> </code>curl<code class="w"> </code>-sX<code class="w"> </code>POST<code class="w"> </code>localhost:9898/echo<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>jq<code class="w"> </code>-r<code class="w"> </code><code class="s">".[]"</code><code class="w"> </code><code class="p">|</code><code class="w"> </code>grep<code class="w"> </code>MESSAGE<code class="w"/>

<code class="c"># Now try again, setting the x-request-id header.</code>
<code class="c"># You should see "hello from v2" since this request does include the</code>
<code class="c"># header.</code>
$<code class="w"> </code>curl<code class="w"> </code>-H<code class="w"> </code><code class="s">'x-request-id: alternative'</code><code class="w"> </code>-sX<code class="w"> </code>POST<code class="w"> </code>localhost:9898/echo<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>jq<code class="w"> </code>-r<code class="w"> </code><code class="s">".[]"</code><code class="w"> </code><code class="p">|</code><code class="w"> </code>grep<code class="w"> </code>MESSAGE<code class="w"/></pre></div>
</div></section>








<section data-pdf-bookmark="Traffic Shifting Summary" data-type="sect2" class="preface"><div class="preface" id="id172">
<h2 class="calibre27">Traffic Shifting Summary</h2>

<p class="author1">You now have a sense<a data-primary="traffic shifting" data-secondary="Gateway API HTTPRoute resource" data-type="indexterm" id="id1550" class="calibre4"/><a data-primary="reliability" data-secondary="traffic shifting" data-tertiary="Gateway API HTTPRoute resource" data-type="indexterm" id="id1551" class="calibre4"/><a data-primary="Gateway API" data-secondary="traffic shifting" data-type="indexterm" id="id1552" class="calibre4"/><a data-primary="APIs" data-secondary="Gateway API" data-tertiary="traffic shifting" data-type="indexterm" id="id1553" class="calibre4"/> of how to use HTTPRoute objects to manipulate
traffic in your cluster. While it’s still possible, for the moment, to use the
Linkerd SMI extension, we strongly recommend using Gateway API instead—and
if you’re using Linkerd with a progressive delivery tool like Flagger or Argo
Rollouts, using Gateway API can dramatically simplify the interface with that tool
(although, as noted earlier, you’ll likely need to use Linkerd 2.14 for its
support for the official Gateway API types).</p>
</div></section>
</div></section>






<section data-pdf-bookmark="Circuit Breaking" data-type="sect1" class="preface"><div class="preface" id="id91">
<h1 class="calibre8">Circuit Breaking</h1>

<p class="author1">When you run applications at scale,<a data-primary="reliability" data-secondary="circuit breaking" data-type="indexterm" id="id1554" class="calibre4"/><a data-primary="circuit breaking" data-type="indexterm" id="id1555" class="calibre4"/> it can be helpful to automatically isolate
and direct traffic away from any Pod that is experiencing issues. Linkerd tends
to route away from underperforming Pods automatically, by virtue of using an
exponentially weighted moving average of latency to select the Pod to receive a
given request. With circuit breaking, you can make Linkerd
explicitly avoid routing to any Pods that are experiencing issues.</p>








<section data-pdf-bookmark="Enabling Circuit Breaking" data-type="sect2" class="preface"><div class="preface" id="id173">
<h2 class="calibre27">Enabling Circuit Breaking</h2>

<p class="author1">When you enable circuit breaking<a data-primary="reliability" data-secondary="circuit breaking" data-tertiary="enabling" data-type="indexterm" id="id1556" class="calibre4"/><a data-primary="circuit breaking" data-secondary="enabling" data-type="indexterm" id="id1557" class="calibre4"/> on a Service, Linkerd will selectively
quarantine endpoints that experience multiple consecutive failures. As always
with advanced features, <a data-primary="circuit breaking" data-secondary="documentation URL" data-type="indexterm" id="id1558" class="calibre4"/><a data-primary="reliability" data-secondary="circuit breaking" data-tertiary="documentation URL" data-type="indexterm" id="id1559" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="circuit breaking" data-type="indexterm" id="id1560" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="circuit breaking" data-type="indexterm" id="id1561" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="circuit breaking" data-type="indexterm" id="id1562" class="calibre4"/>make sure you read the <a href="https://oreil.ly/33gHv" class="calibre4">latest Linkerd circuit breaking documentation</a> before implementing this in your environment.</p>

<p class="author1">We’ll demonstrate using Linkerd circuit breaking by installing a
deliberately bad Pod:</p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>luar/reliability/podinfo-v3.yaml<code class="w"/></pre>

<p class="author1">In your terminal that’s watching traffic, you should now see three <code class="calibre9">podinfo</code>
deployments running. Traffic should be roughly evenly split between <code class="calibre9">podinfo</code>
and <code class="calibre9">podinfo-v3</code>, because <code class="calibre9">podinfo-v3</code> is carefully set up to be part of the
same Service as <code class="calibre9">podinfo</code>.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Seeing podinfo-v2?</h1>
<p class="author1">If you’re seeing any traffic to <code class="calibre9">podinfo-v2</code>, check to make sure you don’t
have any HTTPRoutes still splitting traffic by running <code class="calibre9">kubectl get httproute -n podinfo</code>.</p>
</div>

<p class="author1">You should also note that <code class="calibre9">podinfo-v3</code> has a less than 100% success
rate. Adding a circuit breaker to the <code class="calibre9">podinfo</code> Service, as shown here, should improve things:<a data-primary="circuit breaking" data-secondary="annotations" data-type="indexterm" id="id1563" class="calibre4"/><a data-primary="reliability" data-secondary="circuit breaking" data-tertiary="annotations" data-type="indexterm" id="id1564" class="calibre4"/></p>

<pre data-code-language="bash" data-type="programlisting" class="calibre36">$<code class="w"> </code>kubectl<code class="w"> </code>annotate<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"> </code>svc/podinfo<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>balancer.linkerd.io/failure-accrual<code class="o">=</code>consecutive<code class="w"/></pre>

<p class="author1">This tells Linkerd to apply the circuit breaking policy to the <code class="calibre9">podinfo</code> Service.
It will look for consecutive failures and stop routing to any Pods that are
having issues. If you look back at your window that’s watching traffic, you’ll soon
see that <code class="calibre9">podinfo-v3</code> is no longer receiving much traffic.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Why Annotations?</h1>
<p class="author1">Circuit breakers are still rather new in Linkerd, so they’re currently
configurable only using annotations. Keep an eye on the <a href="https://oreil.ly/bdiFR" class="calibre4">latest Linkerd circuit breaking
documentation</a> to stay up-to-date as development proceeds!</p>
</div>
</div></section>








<section data-pdf-bookmark="Tuning Circuit Breaking" data-type="sect2" class="preface"><div class="preface" id="id174">
<h2 class="calibre27">Tuning Circuit Breaking</h2>

<p class="author1">We can further tune circuit breaking<a data-primary="reliability" data-secondary="circuit breaking" data-tertiary="tuning" data-type="indexterm" id="id1565" class="calibre4"/><a data-primary="circuit breaking" data-secondary="tuning" data-type="indexterm" id="id1566" class="calibre4"/> with additional annotations on the Service:</p>
<dl class="calibre10">
<dt class="calibre11"><code class="calibre14">balancer.linkerd.io/failure-accrual-consecutive-max-failures</code></dt>
<dd class="calibre12">
<p class="calibre13">Sets the number of failures that you’ll need to see before an endpoint is
quarantined. Defaults to <code class="calibre9">7</code>.</p>
</dd>
<dt class="calibre11"><code class="calibre14">balancer.linkerd.io/failure-accrual-consecutive-min-penalty</code></dt>
<dd class="calibre12">
<p class="calibre13">Sets the minimum time an endpoint should be put in quarantine. GEP-2257
Duration, defaults to one second (<code class="calibre9">1s</code>).</p>
</dd>
<dt class="calibre11"><code class="calibre14">balancer.linkerd.io/failure-accrual-consecutive-max-penalty</code></dt>
<dd class="calibre12">
<p class="calibre13">Sets the upper bound for the quarantine period (the maximum time that an
endpoint will be quarantined before the mesh tests it again). GEP-2257
Duration, defaults to one minute (<code class="calibre9">1m</code>).</p>
</dd>
<dt class="calibre11"><code class="calibre14">balancer.linkerd.io/failure-accrual-consecutive-jitter-ratio</code></dt>
<dd class="calibre12">
<p class="calibre13">Adds some randomness to the quarantine and test timeframes.
Defaults to <code class="calibre9">0.5</code>; tuning is only rarely appropriate.</p>
</dd>
</dl>

<p class="author1">Looking at the traffic, you’ll probably still see <code class="calibre9">podinfo-v3</code> showing too many
failures. Making it a bit more sensitive to failure, as shown in
<a data-type="xref" href="#EX-rel-tune-breaker" class="calibre4">Example 11-11</a>, will allow the circuit breaker to more aggressively
take <code class="calibre9">podinfo-v3</code> out of circulation, which should help the situation.</p>
<div data-type="example" id="EX-rel-tune-breaker" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 11-11. </span>Tuning circuit breaking</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># First, we'll set the number of failures we need to see to quarantine</code>
<code class="c"># the endpoints. In this case, we'll change it from the default of 7 to 3.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>annotate<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"> </code>svc/podinfo<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>balancer.linkerd.io/failure-accrual-consecutive-max-failures<code class="o">=</code><code class="m">3</code><code class="w"/>

<code class="c"># Next, we'll change the minimum quarantine time to 30 seconds from 1 second.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>annotate<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"> </code>svc/podinfo<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>balancer.linkerd.io/failure-accrual-consecutive-min-penalty<code class="o">=</code>30s<code class="w"/>

<code class="c"># Finally, we change the max penalty time to 2 minutes.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>annotate<code class="w"> </code>-n<code class="w"> </code>podinfo<code class="w"> </code>svc/podinfo<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>balancer.linkerd.io/failure-accrual-consecutive-max-penalty<code class="o">=</code>2m<code class="w"/></pre></div>

<p class="author1">With that, we should see far fewer errors making it through to <code class="calibre9">podinfo-v3</code>.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Circuit Breaking Won’t Hide All Failures</h1>
<p class="author1">When Linkerd checks to see if a<a data-primary="circuit breaking" data-secondary="not all failures hidden" data-type="indexterm" id="id1567" class="calibre4"/><a data-primary="reliability" data-secondary="circuit breaking" data-tertiary="not all failures hidden" data-type="indexterm" id="id1568" class="calibre4"/> given endpoint has recovered, it does so by
allowing an actual user request through. If this request fails, the failure will get all the way back to the caller (unless retries are also enabled).</p>

<p class="author1">In our example, this would mean that a potentially failing request will make
it to <code class="calibre9">podinfo-v3</code> every 30 seconds, in order for Linkerd to check to see if
the circuit breaker can be reset.</p>
</div>
</div></section>
</div></section>






<section data-pdf-bookmark="Summary" data-type="sect1" class="preface"><div class="preface" id="id327">
<h1 class="calibre8">Summary</h1>

<p class="author1">With that, we’ve covered how Linkerd can help reliability in your
applications. You can retry in the event of transient failures in the network
and in your APIs, add timeouts to requests to preserve overall availability,
split traffic between versions of a service to perform safer
rollouts, and set up circuit breakers to protect services from failing
Pods. With all this, you’re well on your way to being able to run a
reliable and resilient platform with Linkerd.</p>
</div></section>
</div></section></body></html>