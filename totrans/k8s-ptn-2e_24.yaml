- en: Chapter 19\. EnvVar Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this *EnvVar Configuration* pattern, we look into the simplest way to configure
    applications. For small sets of configuration values, the easiest way to externalize
    configuration is by putting them into universally supported environment variables.
    We’ll see different ways of declaring environment variables in Kubernetes but
    also the limitations of using environment variables for complex configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every nontrivial application needs some configuration for accessing data sources,
    external services, or production-level tuning. And we knew well before the [twelve-factor
    app manifesto](https://12factor.net) that it is a bad thing to hardcode configurations
    within the application. Instead, the configuration should be *externalized* so
    that we can change it even after the application has been built. That provides
    even more value for containerized applications that enable and promote sharing
    of immutable application artifacts. But how can this be done best in a containerized
    world?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The twelve-factor app manifesto recommends using environment variables for storing
    application configurations. This approach is simple and works for any environment
    and platform. Every operating system knows how to define environment variables
    and how to propagate them to applications, and every programming language also
    allows easy access to these environment variables. It is fair to claim that environment
    variables are universally applicable. When using environment variables, a typical
    usage pattern is to define hardcoded default values during build time, which we
    can then overwrite at runtime. Let’s see some concrete examples of how this works
    in Docker and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: For Docker images, environment variables can be defined directly in Dockerfiles
    with the `ENV` directive. You can define them line by line or all in a single
    line, as shown in [Example 19-1](#ex-config-envvar).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-1\. Example Dockerfile with environment variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then a Java application running in such a container can easily access the variables
    with a call to the Java standard library, as shown in [Example 19-2](#ex-config-envvar-java).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-2\. Reading environment variables in Java
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_envvar_configuration_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Initializes a random-number generator with a seed from an EnvVar.
  prefs: []
  type: TYPE_NORMAL
- en: Directly running such an image will use the default hardcoded values. But in
    most cases, you want to override these parameters from outside the image.
  prefs: []
  type: TYPE_NORMAL
- en: When running such an image directly with Docker, environment variables can be
    set from the command line by calling Docker, as in [Example 19-3](#ex-config-envvar-docker).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-3\. Set environment variables when starting a Docker container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For Kubernetes, these types of environment variables can be set directly in
    the Pod specification of a controller like Deployment or ReplicaSet (as shown
    in [Example 19-4](#ex-config-envvar-replicaset)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-4\. Deployment with environment variables set
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_envvar_configuration_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: EnvVar with a literal value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_envvar_configuration_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: EnvVar from a ConfigMap.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_envvar_configuration_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMap’s name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_envvar_configuration_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Key within the ConfigMap to look for the EnvVar value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_envvar_configuration_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: EnvVar from a Secret (lookup semantic is the same as for a ConfigMap).
  prefs: []
  type: TYPE_NORMAL
- en: In such a Pod template, you not only can attach values directly to environment
    variables (as for `LOG_FILE`), but also can use a delegation to Kubernetes Secrets
    and ConfigMaps. The advantage of ConfigMap and Secret indirection is that the
    environment variables can be managed independently from the Pod definition. Secret
    and ConfigMap and their pros and cons are explained in detail in [Chapter 20,
    “Configuration Resource”](ch20.html#ConfigurationResource).
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, the `SEED` variable comes from a Secret resource.
    While that is a perfectly valid use of Secret, it is also important to point out
    that environment variables are not secure. Putting sensitive, readable information
    into environment variables makes this information easy to read, and it may even
    leak into logs.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of individually referring to configuration values from Secrets or ConfigMaps,
    you can also import *all* values of a particular Secret or ConfigMap with `envFrom`.
    We explain this field in [Chapter 20, “Configuration Resource”](ch20.html#ConfigurationResource),
    when we talk about ConfigMaps and Secrets in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Two other valuable features that can be used with environment variables are
    the downward API and *dependent variables*. You learned all about the downward
    API in [Chapter 14, “Self Awareness”](ch14.html#SelfAwareness), so let’s have
    a look at dependent variables in [Example 19-5](#ex-config-envvar-dependent) that
    allow you to reference previously defined variables in the value definition of
    other entries.
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-5\. Dependent environment variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_envvar_configuration_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the downward API to pick up the Pod’s IP. The downward API is discussed
    in detail in [Chapter 14, “Self Awareness”](ch14.html#SelfAwareness).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_envvar_configuration_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Include the previously defined environment variables `IP` and `PORT` to build
    up a URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a `$(...)` notation, you can reference environment variables defined earlier
    in the `env` list or coming from an `envFrom` import. Kubernetes will resolve
    those references during the startup of the container. Be careful about the ordering,
    though: if you reference a variable defined later in the list, it will not be
    resolved, and the `$(...)` reference will be taken over literally. In addition,
    you can also reference environment variables with this syntax for Pod commands,
    as shown in [Example 19-6](#ex-config-envvar-command-subst).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 19-6\. Using environment variables in a container’s command definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_envvar_configuration_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference environment variables for the startup command of a container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_envvar_configuration_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Definition of the environment variables substituted in the commands.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Environment variables are easy to use, and everybody knows about them. This
    concept maps smoothly to containers, and every runtime platform supports environment
    variables. But environment variables are not secure, and are good only for a decent
    number of configuration values. And when there are a lot of different parameters
    to configure, the management of all these environment variables becomes unwieldy.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, many people use an extra level of indirection and put configuration
    into various configuration files, one for each environment. Then a single environment
    variable is used to select one of these files. *Profiles* from Spring Boot are
    an example of this approach. Since these profile configuration files are typically
    stored within the application itself, which is within the container, it couples
    the configuration tightly with the application. This often leads to configuration
    for development and production ending up side by side in the same Docker image,
    which requires an image rebuild for every change in either environment. We do
    not recommend this setup (configuration should always be external to the application),
    but this solution indicates that environment variables are suitable for small
    to medium sets of configurations only.
  prefs: []
  type: TYPE_NORMAL
- en: The patterns *Configuration Resource*, *Immutable Configuration*, and *Configuration
    Template* described in the following chapters are good alternatives when more
    complex configuration needs come up.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables are universally applicable, and because of that, we can
    set them at various levels. This option leads to fragmentation of the configuration
    definitions and makes it hard to track for a given environment variable where
    it is set. When there is no central place where all environments variables are
    defined, it is hard to debug configuration issues.
  prefs: []
  type: TYPE_NORMAL
- en: Another disadvantage of environment variables is that they can be set only *before*
    an application starts, and we cannot change them later. On the one hand, it’s
    a drawback that you can’t change configuration “hot” during runtime to tune the
    application. However, many see this as an advantage, as it promotes *immutability*
    even to the configuration. Immutability here means you throw away the running
    application container and start a new copy with a modified configuration, very
    likely with a smooth Deployment strategy like rolling updates. That way, you are
    always in a defined and well-known configuration state.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables are simple to use, but are applicable mainly for simple
    use cases and have limitations for complex configuration requirements. The next
    patterns show how to overcome those limitations.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[EnvVar Configuration Example](https://oreil.ly/W25g0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Twelve-Factor App](https://oreil.ly/DzBTm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Expose Pod Information to Containers Through Environment Variables](https://oreil.ly/KxFtr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Define Dependent Environment Variables](https://oreil.ly/YoUVj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Spring Boot Profiles for Using Sets of Configuration Values](https://oreil.ly/3XVe9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
