["```\n$ git clone git@github.com:falcosecurity/falco.git\n```", "```\n$ cd falco\n```", "```\n$ mkdir -p build\n$ cd build\n```", "```\n$ cmake -DUSE_BUNDLED_DEPS=On ..\n$ make falco\n```", "```\n$ make driver\n```", "```\n$ cmake -DBUILD_BPF=True ..\n$ make bpf\n```", "```\npackage main\n\nimport (\n   \"context\"\n   \"fmt\"\n   \"time\"\n\n   \"github.com/falcosecurity/client-go/pkg/api/outputs\" ![1](Images/1.png)\n   \"github.com/falcosecurity/client-go/pkg/client\"  ![1](Images/1.png)\n)\n\nfunc main() {\n\n   // Set up a connection to Falco via a Unix socket\n   c, err := client.NewForConfig(context.Background(), &client.Config{\n      UnixSocketPath: \"unix:///var/run/falco.sock\", ![2](Images/2.png)\n   })\n   if err != nil {\n      panic(err)\n   }\n   defer c.Close()\n\n   // Subscribe to a stream of Falco notifications\n   err = c.OutputsWatch(context.Background(), ![3](Images/3.png)\n      func(res *outputs.Response) error {\n         // Put your business logic here\n         fmt.Println(res.Output, res.OutputFields) ![4](Images/4.png)\n         return nil\n      }, time.Second)\n   if err != nil {\n      panic(err)\n   }\n}\n```", "```\npackage main\n\nimport (\n   \"encoding/json\"\n   \"fmt\"\n   \"io\"\n   \"os\"\n   \"time\"\n\n   \"github.com/hpcloud/tail\"\n\n   \"github.com/falcosecurity/plugin-sdk-go/pkg/sdk\"\n   \"github.com/falcosecurity/plugin-sdk-go/pkg/sdk/plugins\"\n   \"github.com/falcosecurity/plugin-sdk-go/pkg/sdk/plugins/extractor\"\n   \"github.com/falcosecurity/plugin-sdk-go/pkg/sdk/plugins/source\"\n)\n```", "```\n// bashPluginCfg represents the plugin configuration.\ntype bashPluginCfg struct {\n   Path string\n}\n\n// bashPlugin holds the state of the plugin.\ntype bashPlugin struct {\n   plugins.BasePlugin\n   config bashPluginCfg\n}\n```", "```\nfunc (b *bashPlugin) Info() *plugins.Info {\n   return &plugins.Info{\n      ID:          999,\n      Name:        \"bash\",\n      Description: \"A Plugin that reads from ~/.bash_history\",\n      Version:     \"0.1.0\",\n      EventSource: \"bash\",\n   }\n}\n```", "```\nfunc (b *bashPlugin) Init(config string) error {\n\n   // default value\n   homeDir, _ := os.UserHomeDir()\n   b.config.Path = homeDir + \"/.bash_history\"\n\n   // skip empty config\n   if config == \"\" {\n       return nil\n   }\n\n   // else parse the provided config\n   return json.Unmarshal([]byte(config), &b.config)\n}\n```", "```\n// bashInstance holds the state of the current session.\ntype bashInstance struct {\n   source.BaseInstance\n   t      *tail.Tail\n   ticker *time.Ticker\n}\n\nfunc (b *bashPlugin) Open(params string) (source.Instance, error) {\n   t, err := tail.TailFile(b.config.Path, tail.Config{\n      Follow: true,\n      Location: &tail.SeekInfo{\n         Offset: 0,\n         Whence: os.SEEK_END,\n      },\n   })\n   if err != nil {\n      return nil, err\n   }\n\n   return &bashInstance{\n      t:      t,\n      ticker: time.NewTicker(time.Millisecond * 30),\n   }, nil\n}\n```", "```\nfunc (b *bashInstance) NextBatch(\n\tbp sdk.PluginState,\n\tevts sdk.EventWriters,\n) (int, error) {\n   i := 0\n   b.ticker.Reset(time.Millisecond * 30)\n\n   for i < evts.Len() {\n      select {\n      case line := <-b.t.Lines:\n         if line.Err != nil {\n            return i, line.Err\n         }\n\n         // Add an event to the batch\n         evt := evts.Get(i)\n         if _, err := evt.Writer().Write([]byte(line.Text)); err != nil {\n            return i, err\n         }\n         i++\n      case <-b.ticker.C:\n         // Timeout occurred, return early\n         return i, sdk.ErrTimeout\n      }\n   }\n\n   // The batch is full\n   return i, nil\n}\n```", "```\nfunc (b *bashPlugin) Fields() []sdk.FieldEntry {\n   return []sdk.FieldEntry{\n      {Type: \"string\", Name: \"shell.command\", Display: \"Shell command line\", \n       Desc: \"The command line typed by user in the shell\"},\n   }\n}\n```", "```\nfunc (m *bashPlugin) Extract(req sdk.ExtractRequest, evt sdk.EventReader) error {\n   bb, err := io.ReadAll(evt.Reader())\n   if err != nil {\n      return err\n   }\n\n   switch req.FieldID() {\n   case 0: // shell.command\n      req.SetValue(string(bb))\n      return nil\n   default:\n      return fmt.Errorf(\"unsupported field: %s\", req.Field())\n   }\n}\n```", "```\nfunc init() {\n   plugins.SetFactory(func() plugins.Plugin {\n      p := &bashPlugin{}\n      extractor.Register(p)\n      source.Register(p)\n      return p\n   })\n}\n\nfunc main() {}\n```", "```\n$ go mod init *example.com/my/plugin*\n$ go mod tidy\n```", "```\n$ go build -buildmode=c-shared -o libmyplugin.so\n```", "```\nplugins:\n  - name: bash\n    library_path: /path/to/your/plugin/libmyplugin.so\n    init_config: \"\"\n\nload_plugins: [bash]\n```", "```\n- rule: Cat in the shell\n  desc: Match command lines starting with \"cat\".\n  condition: shell.command startswith \"cat \"\n  output: Cat in shell detected (command=%shell.command)\n  priority: DEBUG\n  source: bash\n```", "```\n$ falco -c falco.yaml -r myplugin_rules.yaml\n```", "```\n$ bash\n$ cat --version\n$ exit\n```"]