- en: Chapter 9\. Sorting Query Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 9.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers sorting, an extremely important operation for controlling
    how MySQL displays results from `SELECT` statements. To sort a query result, add
    an `ORDER` `BY` clause to the query. Without such a clause, MySQL is free to return
    rows in any order, so sorting helps bring order to disorder and makes query results
    easier to examine and understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can sort rows of a query result several ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a single column, a combination of columns, or even parts of columns or
    expression results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using ascending or descending order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using case-sensitive or case-insensitive string comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using temporal ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Several examples in this chapter use the `driver_log` table, which contains
    columns for recording daily mileage logs for a set of truck drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Many other examples use the `mail` table (used in earlier chapters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Other tables are used occasionally as well. To create them, use scripts found
    in the *tables* directory of the `recipes` distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 9.1 Using ORDER BY to Sort Query Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rows in a query result don’t appear in the order you want.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add an `ORDER` `BY` clause to the query to sort its result.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The contents of the `driver_log` and `mail` tables shown in the chapter introduction
    are disorganized and difficult to make sense of. The values in the `id` and `t`
    columns are in order only by a coincident.
  prefs: []
  type: TYPE_NORMAL
- en: When you select rows, they’re returned from the database in whatever order the
    server happens to use. A relational database makes no guarantee about the order
    in which it returns rows—unless you tell it how, by adding an `ORDER` `BY` clause
    to your `SELECT` statement. Without `ORDER` `BY`, you may find that the retrieval
    order changes over time as you modify the table contents. With an `ORDER` `BY`
    clause, MySQL always sorts rows as you indicate.
  prefs: []
  type: TYPE_NORMAL
- en: '`ORDER` `BY` has the following general characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: You can sort using one or more column or expression values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can sort columns independently in ascending order (the default) or descending
    order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can refer to sort columns by name or by using an alias.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe shows some basic sorting techniques, such as how to name the sort
    columns and specify the sort direction. Recipes later in this chapter illustrate
    how to perform more complex sorts. Paradoxically, you can even use `ORDER` `BY`
    to *disorder* a result set, which is useful for randomizing the rows or (in conjunction
    with `LIMIT`) for picking a row at random from a result set (see [Recipe 17.7](ch17.xhtml#nch-stats-stats-rand-rows)
    and [Recipe 17.8](ch17.xhtml#nch-stats-stats-rand-items)).
  prefs: []
  type: TYPE_NORMAL
- en: The following examples demonstrate how to sort on a single column or multiple
    columns and how to sort in ascending or descending order. The examples select
    the rows in the `driver_log` table but sort them in different orders to demonstrate
    the effect of the different `ORDER` `BY` clauses.
  prefs: []
  type: TYPE_NORMAL
- en: 'This query produces a single-column sort using the driver name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The default sort direction is ascending. To make the direction for an ascending
    sort explicit, add `ASC` after the sorted column’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The opposite (or reverse) of ascending order is descending order, specified
    by adding `DESC` after the sorted column’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Closely examine the output from the queries just shown and you’ll notice that
    although rows are sorted by name, rows for any given name are in no special order.
    (The `trav_date` values aren’t in date order for Henry or Ben, for example.) That’s
    because MySQL doesn’t sort something unless you tell it to:'
  prefs: []
  type: TYPE_NORMAL
- en: The overall order of rows returned by a query is indeterminate unless you specify
    an `ORDER` `BY` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within a group of rows that sort together based on the values in a given column,
    the order of values in other columns also is indeterminate unless you name them
    in the `ORDER` `BY` clause.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To more fully control output order, specify a multiple-column sort by listing
    each column to use for sorting, separated by commas. The following query sorts
    in ascending order by `name` and by `trav_date` within the rows for each name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Multiple-column sorts can be descending as well, but `DESC` must be specified
    after *each* column name to perform a fully descending sort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple-column `ORDER` `BY` clauses can perform mixed-order sorting where
    some columns are sorted in ascending order and others in descending order. The
    following query sorts by `name` in descending order, then by `trav_date` in ascending
    order for each name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ORDER` `BY` clauses in the queries shown thus far refer to the sorted
    columns by name. You can also name the columns by using aliases. That is, if an
    output column has an alias, you can refer to the alias in the `ORDER` `BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 9.2 Using Expressions for Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort a query result based on values calculated from a column rather
    than the values actually stored in the column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Put the expression that calculates the values in the `ORDER` `BY` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the `mail` table columns shows how large each mail message is, in bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that you want to retrieve rows for <q>big</q> mail messages (defined
    as those larger than 50,000 bytes), but you want them to be displayed and sorted
    by sizes in terms of kilobytes, not bytes. In this case, the values to sort are
    calculated by an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `+1023` in the `FLOOR()` expression groups `size` values to the nearest
    upper boundary of the 1,024-byte categories. Without it, the values group by lower
    boundaries (for example, a 2,047-byte message is reported as having a size of
    1 kilobyte rather than 2). [Recipe 10.13](ch10.xhtml#nch-sum-sum-noncat) discusses
    this technique in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort by that expression, put it directly in the `ORDER` `BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if the sorting expression appears in the output column list,
    you can alias it there and refer to the alias in the `ORDER` `BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You might prefer the alias method for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s easier to write the alias in the `ORDER` `BY` clause than to repeat the
    (cumbersome) expression.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without the alias, if you change the expression one place, you must change it
    in the other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alias may be useful for display purposes, to provide a better column label.
    Note how the third column heading is much more meaningful in the second of the
    two preceding queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9.3 Displaying One Set of Values While Sorting by Another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort a result set using values that don’t appear in the output column
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That’s not a problem. The `ORDER` `BY` clause can refer to columns you don’t
    display.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ORDER` `BY` is not limited to sorting only those columns named in the output
    column list. It can sort using values that are <q>hidden</q> (that is, not displayed
    in the query output). This technique is commonly used when you have values that
    can be represented different ways and you want to display one type of value but
    sort by another. For example, you may want to display mail message sizes not in
    terms of bytes, but as strings such as `103K` for 103 kilobytes. You can convert
    a byte count to that kind of value using this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'However, such values are strings, so they sort lexically, not numerically.
    If you use them for sorting, a value such as `96K` sorts after `2339K`, even though
    it represents a smaller number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve the desired output order, display the string, but use actual numeric
    size for sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Displaying values as strings but sorting them as numbers helps solve some otherwise
    difficult problems. Members of sports teams typically are assigned a jersey number,
    which normally you might think should be stored using a numeric column. Not so
    fast! Some players like to have a jersey number of zero (`0`), and some like double-zero
    (`00`). If a team happens to have players with both numbers, you cannot represent
    them using a numeric column because both values will be treated as the same number.
    To solve this problem, store jersey numbers as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the jersey numbers will display the same way you enter them, and `0` and
    `00` will be treated as distinct values. Unfortunately, although representing
    numbers as strings solves the problem of distinguishing `0` and `00`, it introduces
    a different problem. Suppose that a team has the following players:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now try to sort the team members by jersey number. If those numbers are stored
    as strings, they sort lexically, and lexical order often differs from numeric
    order. That’s certainly true for the team in question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The values `100` and `8` are out of place, but that’s easily solved: display
    the string values and use the numeric values for sorting. To accomplish this,
    add zero to the `jersey_num` values to force a string-to-number conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that because this method performs string-to-number conversion it cannot
    use indexes and will run slower as the table gets bigger. As alternative solution
    you may create a column that will hold result of this calculation and use it in
    the `ORDER BY` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique of displaying one value but sorting by another is also useful
    when you display values composed from multiple columns that don’t sort the way
    you want. For example, the `mail` table lists message senders using separate `srcuser`
    and `srchost` values. To display message senders from the `mail` table as email
    addresses in `srcuser@srchost` format with the username first, construct those
    values using the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'However, those values are no good for sorting if you want to treat the hostname
    as more significant than the username. Instead, sort the results using the underlying
    column values rather than the displayed composite values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The same idea commonly applies to sorting people’s names. Suppose that a `names`
    table contains last and first names. To display rows sorted by last name first,
    the query is straightforward when the columns are displayed separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If instead you want to display each name as a single string composed of the
    first name, a space, and the last name, begin the query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'But then how do you sort the names so they come out in last-name order? Display
    composite names, but refer to the constituent values in the `ORDER` `BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 9.4 Controlling Case Sensitivity of String Sorts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: String-sorting operations are case sensitive when you don’t want them to be,
    or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alter the comparison characteristics of the sorted values.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 7.1](ch07.xhtml#nch-strings-strings-properties) discusses how string-comparison
    properties depend on whether the strings are binary or nonbinary:'
  prefs: []
  type: TYPE_NORMAL
- en: Binary strings are sequences of bytes. They are compared byte by byte using
    numeric byte values. Character set and lettercase have no meaning for comparisons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonbinary strings are sequences of characters. They have a character set and
    collation and are compared character by character using the order defined by the
    collation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties also apply to string sorting because sorting is based on comparison.
    To alter the sorting properties of a string column, alter its comparison properties.
    (For a summary of which string data types are binary and nonbinary, see [Recipe
    7.2](ch07.xhtml#nch-strings-strings-types).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples in this section use a table that has case-insensitive and case-sensitive
    nonbinary columns, and a binary column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose that the table has these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of MySLQ 8.0.19 *mysql* client prints binary data in hexademical format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To print values in ASCII format start *mysql* with option `--binary-as-hex=0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each column contains the same values, but the natural sort orders for the column
    data types produce three different results:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The case-insensitive collation sorts `a` and `A` together, placing them before
    `b` and `B`. However, for a given letter, it does not necessarily order one lettercase
    before another, as shown by the following result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The case-sensitive collation puts `a` and `A` before `b` and `B`, and sorts
    lowercase before uppercase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The binary strings sort numerically. Assuming that uppercase letters have numeric
    values less than those of lowercase letters, a binary sort results in the following
    ordering:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You get the same result for a nonbinary string column that has a binary collation,
    as long as the column contains single-byte characters (for example, `CHAR(3)`
    `CHARACTER` `SET` `latin1` `COLLATE` `latin1_bin`). For multibyte characters,
    a binary collation still produces a numeric sort, but the character values use
    multibyte numbers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To alter the sorting properties of each column, use the techniques described
    in [Recipe 7.7](ch07.xhtml#nch-strings-strings-compare) for controlling string
    comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort case-insensitive strings in case-sensitive fashion, order the sorted
    values using a case-sensitive collation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To sort case-sensitive strings in case-insensitive fashion, order the sorted
    values using a case-insensitive collation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, sort using values that have been converted to the same lettercase,
    which makes lettercase irrelevant:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Binary strings sort using numeric byte values, so there is no concept of lettercase
    involved. However, because letters in different cases have different byte values,
    comparisons of binary strings effectively are case sensitive. (That is, `a` and
    `A` are unequal.) To sort binary strings using a case-insensitive ordering, convert
    them to nonbinary strings and apply an appropriate collation. For example, to
    perform a case-insensitive sort, use a statement like this:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the character-set default collation is case insensitive (as is true for `utf8mb4`),
    you can omit the `COLLATE` clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 9.5 Sorting in Temporal Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort rows in temporal order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sort using a date or time column. If some parts of the values are irrelevant
    for the sort that you want to accomplish, ignore them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many database tables include date or time information and it’s very often necessary
    to sort results in temporal order. MySQL knows how to sort temporal data types,
    so there’s no special trick to ordering them. The next few examples use the `mail`
    table, which contains a `DATETIME` column, but the same sorting principles apply
    to `DATE`, `TIME`, and `TIMESTAMP` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the messages sent by `phil`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To display the messages, most recently sent ones first, use `ORDER` `BY` with
    `DESC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes a temporal sort uses only part of a date or time column. In that case,
    use an expression that extracts the part or parts you need and sort the result
    using the expression. Some examples of this are given in the following discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by time of day
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can do time-of-day sorting different ways, depending on your column type.
    If the values are stored in a `TIME` column named `timecol`, just sort them directly
    using `ORDER` `BY` `timecol`. To put `DATETIME` or `TIMESTAMP` values in time-of-day
    order, extract the time parts and sort them. For example, the `mail` table contains
    `DATETIME` values, which can be sorted by time of day like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Sorting by calendar day
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To sort date values in calendar order, ignore the year part of the dates and
    use only the month and day to order values by where they fall during the calendar
    year. Suppose that an `occasion` table looks like this when values are ordered
    by date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To put these items in calendar order, sort them by month and day within month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'MySQL has a `DAYOFYEAR()` function that you might suspect would be useful for
    calendar-day sorting. However, it can generate the same value for different calendar
    days. For example, February 29 of leap years and March 1 of nonleap years have
    the same day-of-year value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This means that `DAYOFYEAR()` can group dates that actually occur on different
    calendar days.
  prefs: []
  type: TYPE_NORMAL
- en: If a table represents dates using separate year, month, and day columns, calendar
    sorting does not require to extract date parts. Just sort the relevant columns
    directly. For large datasets, sorting using separate date-part columns can be
    much faster than sorts based on extracting pieces of `DATE` values. There’s no
    overhead for part extraction, but more importantly, you can index the date-part
    columns separately—something not possible with a `DATE` column. The principle
    here is that you should design the table to make it easy to extract or sort by
    the values that you expect to use a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by day of week
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Day-of-week sorting is similar to calendar-day sorting, except that you use
    different functions to obtain the relevant ordering values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the day of the week using `DAYNAME()`, but that produces strings
    that sort lexically rather than in day-of-week order (Sunday, Monday, Tuesday,
    and so forth). Here the technique of displaying one value but sorting by another
    is useful (see [Recipe 9.3](#nch-sort-sort-one-display-other)). Display day names
    using `DAYNAME()`, but sort in day-of-week order using `DAYOFWEEK()`, which returns
    numeric values from 1 to 7 for Sunday through Saturday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort rows in day-of-week order but treat Monday as the first day of the
    week and Sunday as the last, use the modulo operation and the `MOD()` function
    to map Monday to 0, Tuesday to 1, …, Sunday to 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The [Table 9-1](#nch-sort-sort-date-mod) shows the `DAYOFWEEK()` expressions
    for putting any day of the week first in the sort order:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-1\. Using modulo to properly order days of a week
  prefs: []
  type: TYPE_NORMAL
- en: '| Day to list first | DAYOFWEEK() expression |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sunday | `DAYOFWEEK(date)` |'
  prefs: []
  type: TYPE_TB
- en: '| Monday | `MOD(DAYOFWEEK(date)+5, 7)` |'
  prefs: []
  type: TYPE_TB
- en: '| Tuesday | `MOD(DAYOFWEEK(date)+4, 7)` |'
  prefs: []
  type: TYPE_TB
- en: '| Wednesday | `MOD(DAYOFWEEK(date)+3, 7)` |'
  prefs: []
  type: TYPE_TB
- en: '| Thursday | `MOD(DAYOFWEEK(date)+2, 7)` |'
  prefs: []
  type: TYPE_TB
- en: '| Friday | `MOD(DAYOFWEEK(date)+1, 7)` |'
  prefs: []
  type: TYPE_TB
- en: '| Saturday | `MOD(DAYOFWEEK(date)+0, 7)` |'
  prefs: []
  type: TYPE_TB
- en: You can also use `WEEKDAY()` for day-of-week sorting, although it returns a
    different set of values (0 for Monday through 6 for Sunday).
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Sorting by Substrings of Column Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort a set of values using one or more substrings of each value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Extract the pieces you want and sort them separately.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a specific application of sorting by expression value (see [Recipe 9.2](#nch-sort-sort-expr)).
    To sort rows using just a particular portion of a column’s values, extract the
    substring you need and use it in the `ORDER` `BY` clause. This is easiest if the
    substrings are at a fixed position and length within the column. For substrings
    of variable position or length, you can still use them for sorting if you have
    a reliable way to identify them. The next several recipes show how to use substring
    extraction to produce specialized sort orders.
  prefs: []
  type: TYPE_NORMAL
- en: 9.7 Sorting by Fixed-Length Substrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort using parts of a column that occur at a given position within
    the column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pull out the parts you need with `LEFT()`, `SUBSTRING()` (`MID()`), or `RIGHT()`,
    and sort them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that a `housewares` table catalogs houseware furnishings, each identified
    by 10-character ID values consisting of three subparts: a three-character category
    abbreviation (such as `DIN` for <q>dining room</q> or `KIT` for <q>kitchen</q>),
    a five-digit serial number, and a two-character country code indicating where
    the part is manufactured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is not necessarily a good way to store complex ID values, and later we’ll
    consider how to represent them using separate columns. For now, assume that the
    values must be stored as shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort rows from this table based on the `id` values, use the entire column
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But you might also have a need to sort on any of the three subparts (for example,
    to sort by country of manufacture). For that kind of operation, functions such
    as `LEFT()`, `MID()`, and `RIGHT()` are useful to extract `id` value components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Function `MID()` is a synonym of the function `SUBSTRING()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Those fixed-length substrings of the `id` values can be used for sorting, either
    alone or in combination. For example, to sort by product category, extract and
    use the category in the `ORDER` `BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To sort by product serial number, use `MID()` to extract the middle five characters
    from the `id` values, beginning with the fourth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This appears to be a numeric sort, but it’s actually a string sort because `MID()`
    returns strings. The lexical and numeric sort order are the same in this case
    because the <q>numbers</q> have leading zeros to make them all the same length.
  prefs: []
  type: TYPE_NORMAL
- en: To sort by country code, use the rightmost two characters of the `id` values
    (`ORDER` `BY` `RIGHT(id,2)`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also sort using combinations of substrings; for example, by country
    code and serial number within country:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ORDER` `BY` clauses just shown suffice to sort by substrings of the `id`
    values, but if such operations on the table are common, it might be worth representing
    houseware IDs differently; for example, using separate columns for the ID components.
    This table, `housewares2`, is like `housewares` but uses `category`, `serial`,
    and `country` columns generated from the `id` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this example we used generated columns that are generated based on the expressions,
    defined at the column creation time.
  prefs: []
  type: TYPE_NORMAL
- en: With the ID values split into separate parts, sorting operations are easier
    to specify; refer to individual columns directly rather than pulling out substrings
    of the original `id` column. You can also make operations that sort the `serial`
    and `country` columns more efficient by adding indexes on those columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This example illustrates an important principle: you might think about values
    one way (`id` values as single strings), but you need not necessarily represent
    them that way in the database. If an alternative representation (separate columns)
    is more efficient or easier to work with, it may well be worth using—even if you
    must reformat the underlying columns so they appear as people expect.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.8 Sorting by Variable-Length Substrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort using parts of a column that do *not* occur at a given position
    within the column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Determine how to identify the parts you need so that you can extract them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If substrings to be used for sorting vary in length, you need a reliable means
    of extracting just the part you want. To see how this works, let’s create a `housewares3`
    table that is like the `housewares` table used in [Recipe 9.7](#nch-sort-sort-substr-fixed),
    except that it has no leading zeros in the serial number part of the `id` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The category and country parts of the `id` values can be extracted and sorted
    using `LEFT()` and `RIGHT()`, just as for the `housewares` table. But now the
    numeric segments of the values have different lengths and cannot be extracted
    and sorted using a simple `MID()` call. Instead, use its full version `SUBSTRING()`
    to skip the first three characters. Of the remainder beginning with the fourth
    character (the first digit), take everything but the rightmost two columns. One
    way to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'But that’s more complex than necessary. The `SUBSTRING()` function takes an
    optional third argument specifying a desired result length, and we know that the
    length of the middle part is equal to the length of the string minus five (three
    for the characters at the beginning and two for the characters at the end). The
    following query demonstrates how to get the numeric middle part by beginning with
    the ID, and then stripping the rightmost suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, although the final expression correctly extracts the numeric
    part from the IDs, the resulting values are strings. Consequently, they sort lexically
    rather than numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'How to deal with that? One way is to add zero, which tells MySQL to perform
    a string-to-number conversion that results in a numeric sort of the serial number
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the ability to extract variable-length substrings
    is based on the different kinds of characters in the middle of the `id` values,
    compared to the characters on the ends (that is, digits versus nondigits). In
    other cases, you may be able to use delimiter characters to pull apart column
    values. For the next examples, assume a `housewares4` table with `id` values that
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract segments from these values, use `SUBSTRING_INDEX(`*`str`*`,`*`c`*`,`*`n`*`)`.
    It searches a string *`str`* for the *`n`*-th occurrence of a given character
    *`c`* and returns everything to the left of that character. For example, the following
    call returns `13-478`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'If *`n`* is negative, the search for *`c`* proceeds from the right and returns
    the rightmost string. This call returns `478-92-2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'By combining `SUBSTRING_INDEX()` calls with positive and negative indexes,
    it’s possible to extract successive pieces from each `id` value: extract the first
    *`n`* segments of the value and pull off the rightmost one. By varying *`n`* from
    1 to 4, we get the successive segments from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The first of those expressions can be optimized because the inner `SUBSTRING_INDEX()`
    call returns a single-segment string and is sufficient by itself to return the
    leftmost `id` segment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to obtain substrings is to extract the rightmost *`n`* segments
    of the value and pull off the first one. Here we vary *`n`* from –4 to –1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, an optimization is possible. For the fourth expression, the inner `SUBSTRING_INDEX()`
    call is sufficient to return the final substring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'These expressions can be difficult to read and understand, and experimenting
    with a few to see how they work may be useful. Here is an example that shows how
    to get the second and fourth segments from the `id` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the substrings for sorting, use the appropriate expressions in the `ORDER`
    `BY` clause. (Remember to force a string-to-number conversion by adding zero if
    you want a numeric rather than lexical sort.) The following two queries order
    the results based on the second `id` segment. The first sorts lexically, the second
    numerically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The substring-extraction expressions here are messy, but at least the column
    values to which we apply the expressions have a consistent number of segments.
    To sort values that have varying numbers of segments, the job can be more difficult.
    [Recipe 9.9](#nch-sort-sort-domain) shows an example illustrating why that is.
  prefs: []
  type: TYPE_NORMAL
- en: 9.9 Sorting Hostnames in Domain Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort hostnames in domain order, with the rightmost parts of the
    names more significant than the leftmost parts.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Break apart the names, and sort the pieces from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hostnames are strings and therefore their natural sort order is lexical. However,
    it’s often desirable to sort hostnames in domain order, where the rightmost segments
    of the hostname values are more significant than the leftmost segments. Suppose
    that a `hostname` table contains the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query demonstrates the natural lexical sort order of the `name`
    values. That differs from domain order, as the [Table 9-2](#nch-sort-sort-domain-domain)
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 9-2\. Lexical versus Domain sort order
  prefs: []
  type: TYPE_NORMAL
- en: '| Lexical order | Domain order |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `dbi.perl.org` | `www.kitebird.com` |'
  prefs: []
  type: TYPE_TB
- en: '| `jakarta.apache.org` | `mysql.com` |'
  prefs: []
  type: TYPE_TB
- en: '| `lists.mysql.com` | `lists.mysql.com` |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql.com` | `svn.php.net` |'
  prefs: []
  type: TYPE_TB
- en: '| `svn.php.net` | `jakarta.apache.org` |'
  prefs: []
  type: TYPE_TB
- en: '| `www.kitebird.com` | `dbi.perl.org` |'
  prefs: []
  type: TYPE_TB
- en: Producing domain-ordered output is a substring-sorting problem for which it’s
    necessary to extract each segment of the names so they can be sorted in right-to-left
    fashion. There is also an additional complication if your values contain different
    numbers of segments, as our example hostnames do. (Most of them have three segments,
    but `mysql.com` has only two.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the pieces of the hostnames, begin by using `SUBSTRING_INDEX()`
    in a manner similar to that described previously in [Recipe 9.8](#nch-sort-sort-substr-variable).
    The hostname values have a maximum of three segments, from which the pieces can
    be extracted left to right like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'These expressions work properly as long as all the hostnames have three components.
    But if a name has fewer than three, you don’t get the correct result, as the following
    query demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the output for the `mysql.com` row; it has `mysql` for the value of
    the `leftmost` column, where it should have an empty string. The segment-extraction
    expressions work by pulling off the rightmost *`n`* segments, and then returning
    the leftmost segment of the result. The source of the problem for `mysql.com`
    is that if there aren’t *`n`* segments, the expression simply returns the leftmost
    segment of however many there are. To fix this problem, add a sufficient number
    of periods at the beginning of the hostname values to guarantee that they have
    the requisite number of segments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s pretty ugly. But the expressions do serve to extract the substrings
    that are needed for sorting hostname values correctly in right-to-left fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If your hostnames have a maximum of four segments rather than three, add to
    the `ORDER` `BY` clause another `SUBSTRING_INDEX()` expression that adds three
    dots at the beginning of the hostname values.
  prefs: []
  type: TYPE_NORMAL
- en: 9.10 Sorting Dotted-Quad IP Values in Numeric Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort in numeric order strings that represent IP numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Break apart the strings, and sort the pieces numerically. Or just use `INET_ATON()`.
    Or consider storing the values as numbers instead.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a table contains IP numbers represented as strings in dotted-quad notation
    (`192.168.1.10`), they sort lexically rather than numerically. To produce a numeric
    ordering instead, sort them as four-part values with each part sorted numerically.
    Or, to be more efficient, represent the IP numbers as 32-bit unsigned integers,
    which take less space and can be ordered by a simple numeric sort. This section
    shows both methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort string-valued dotted-quad IP numbers, use a technique similar to that
    for sorting hostnames (see [Recipe 9.9](#nch-sort-sort-domain)), but with the
    following differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Dotted quads always have four segments. There’s no need to add dots to the value
    before extracting substrings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dotted quads sort left to right. The order of the substrings used in the `ORDER`
    `BY` clause is opposite to that used for hostname sorting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The segments of dotted-quad values are numbers. Add zero to each substring to
    force a numeric rather than lexical sort.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that a `hostip` table has a string-valued `ip` column containing IP
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding query produces output sorted in lexical order. To sort the `ip`
    values numerically, extract each segment and add zero to convert it to a number
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'However, although that `ORDER` `BY` clause produces a correct result, it’s
    complicated. A simpler solution uses the `INET_ATON()` function to convert network
    addresses in string form to their underlying numeric values, then sorts those
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re tempted to sort by simply adding zero to the `ip` value and using
    `ORDER` `BY` on the result, consider the values that kind of string-to-number
    conversion actually produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The conversion retains only as much of each value as can be interpreted as a
    valid number (hence the warnings). The remainder becomes unavailable for sorting
    purposes, even though it’s required for a correct ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use of `INET_ATON()` in the `ORDER` `BY` clause is more efficient than six
    `SUBSTRING_INDEX()` calls. Moreover, if you storing IP addresses as numbers rather
    than as strings, you can avoid performing any conversion at all when sorting.
    You gain other benefits as well: numeric IP addresses have 32 bits, so you can
    use a 4-byte `INT` `UNSIGNED` column to store them, which requires less storage
    than the string form. Also, if you index the column, the query optimizer may be
    able to use the index for certain queries. For cases requiring display of numeric
    IP values in dotted-quad notation, convert them with the `INET_NTOA()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: 9.11 Floating Values to the Head or Tail of the Sort Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a column to sort the way it normally does, except for a few values
    that should appear at the beginning or end of the sort order. For example, you
    want to sort a list in lexical order except for certain high-priority values that
    should appear first no matter where they fall in the normal sort order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add an initial sort column to the `ORDER` `BY` clause that places those few
    values where you want them. The remaining sort columns have their usual effect
    for the other values.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To sort a result set normally *except* that you want particular values first,
    create an additional sort column that is 0 for those values and 1 for everything
    else. This enables you to float the values to the head of the ascending sort order.
    To put the values at the tail instead, use descending sort order or store 1 for
    rows that you want to be in the end of the list and 0 for others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that a column contains `NULL` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, sorting groups the `NULL` values at the beginning for an ascending
    sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To put them at the end instead, without changing the order of other values,
    introduce an extra `ORDER` `BY` column that maps `NULL` values to a higher value
    than non-`NULL` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The `IF()` expression creates a new column for the sort that is used as the
    primary sort value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For descending sorts, `NULL` values group at the end. To put them at the beginning
    instead, use the same technique, but reverse the second and third arguments of
    the `IF()` function to map `NULL` values to a lower value than non-`NULL` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The same technique is useful for floating values other than `NULL` to either
    end of the sort order. Suppose that you want to sort `mail` table messages in
    sender/recipient order, but you want to put messages for a particular sender first.
    In the real world, the most interesting sender might be `postmaster` or `root`.
    Those names don’t appear in the table, so let’s use `phil` as the name of interest
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The value of the extra sort column is `0` for rows in which the `srcuser` value
    is `phil`, and `1` for all other rows. By making that the most significant sort
    column, rows for messages sent by `phil` float to the top of the output. (To sink
    them to the bottom instead, either sort the column in reverse order using `DESC`,
    or reverse the order of the second and third arguments of the `IF()` function.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use this technique for particular conditions, not only specific
    values. To put first those rows where people sent messages to themselves, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a pretty good idea about the contents of your table, it’s sometimes
    possible to eliminate the extra sort column. For example, `srcuser` is never `NULL`
    in the `mail` table, so the previous query can be rewritten as follows to use
    one less column in the `ORDER` `BY` clause (this relies on the property that `NULL`
    values sort ahead of all non-`NULL` values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 9.12 Defining a Custom Sort Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort values in a nonstandard order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `FIELD()` to map column values to a sequence that places the values in the
    desired order.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 9.11](#nch-sort-sort-float) shows how to make a specific group of rows
    float to the head of the sort order. To impose a specific order on *all* values
    in a column, use the `FIELD()` function to map them to a list of numeric values
    and use the numbers for sorting. `FIELD()` compares its first argument to the
    following arguments and returns an integer indicating which one it matches. (This
    works best when the column contains a small number of distinct values.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `FIELD()` call compares *`value`* to *`str1`*, *`str2`*, *`str3`*,
    and *`str4`*, and returns 1, 2, 3, or 4, depending on which of them *`value`*
    is equal to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: If *`value`* is `NULL` or none of the values match, `FIELD()` returns 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `FIELD()` to sort an arbitrary set of values into any order you
    please. For example, to display `driver_log` rows for Henry, Suzi, and Ben, in
    that order, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 9.13 Sorting ENUM Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ENUM` values don’t sort like other string columns, and you want them to retrieve
    results in the order you expect.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Study how `ENUM` stores data and use those properties to your advantage. You
    can, for example, define your own sort order for strings, stored in the `ENUM`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ENUM` is a string data type, but `ENUM` values actually are stored numerically
    with values ordered the same way they are listed in the table definition. These
    numeric values affect how enumerations are sorted, which can be very useful. Suppose
    that a table named `weekday` contains an enumeration column named `day` that has
    weekday names as its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Internally, MySQL defines the enumeration values `Sunday` through `Saturday`
    in that definition to have numeric values from 1 to 7\. To see this for yourself,
    create the table using the definition just shown, and then insert into it a row
    for each day of the week. To make the insertion order differ from sorted order
    (so that you can see the effect of sorting), add the days in random order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Then select the values, both as strings and as the internal numeric value (obtain
    the latter using `+0` to force a string-to-number conversion):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that because the query includes no `ORDER` `BY` clause, the rows are
    returned in unsorted order. If you add an `ORDER` `BY` `day` clause, it becomes
    apparent that MySQL uses the internal numeric values for sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'What about occasions when you want to sort `ENUM` values in lexical order?
    Force them to be treated as strings for sorting using the `CAST()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'If you always (or nearly always) sort a non-enumeration column in a specific
    nonlexical order, consider changing the data type to `ENUM`, with its values listed
    in the desired sort order. To see how this works, create a `color` table containing
    a string column, and populate it with some sample rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Sorting by the `name` column at this point produces lexical order because the
    column contains `CHAR` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Now suppose that you want to sort the column by the order in which colors occur
    in the rainbow. (This is <q>Roy G. Biv</q> order; successive letters of that name
    indicate the first letters of the corresponding color names.) One way to produce
    a rainbow sort is to use `FIELD()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'To accomplish the same end without `FIELD()`, use `ALTER` `TABLE` to convert
    the `name` column to an `ENUM` that lists the colors in the desired sort order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'After converting the table, sorting on the `name` column produces rainbow sorting
    naturally with no special treatment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note that once you switched to the `ENUM` data type you would not be able to
    insert any value that does not belong to list. If you need to change `ENUM` definition,
    for example, by adding new color, you will have to perform one more `ALTER` command.
  prefs: []
  type: TYPE_NORMAL
