<html><head></head><body><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. BPF Maps"><div class="chapter" id="bpf_maps">
<h1><span class="label">Chapter 3. </span>BPF Maps</h1>


<p>Message passing to invoke behavior in a program is a widely used technique in software engineering.<a data-type="indexterm" data-primary="maps (BPF)" id="ix_mps"/> A program can modify another program’s behavior by sending messages; this also allows the exchange of information between those programs. One of the most fascinating aspects about BPF, is that the code running on the kernel and the program that loaded said code can communicate with each other at runtime using message passing.</p>

<p>In this chapter we cover how BPF programs and user-space programs can talk to one another. We describe the different channels of communication between the kernel and user-space, and how they store information. We also show you use cases for those channels and how to make the data in those channels persistent between programs initialization.</p>

<p>BPF maps are key/value stores that reside in the kernel. They can be accessed by any BPF program that knows about them. Programs that run in user-space can also access these maps by using file descriptors. You can store any kind of data in a map, as long as you specify the data size correctly beforehand. The kernel treats keys and values as binary blobs, and it doesn’t care about what you keep in a map.</p>

<p>The BPF verifier includes several safeguards to ensure that the way you create and access maps is safe. We talk about these guarantees when we explain how to access data in these maps.</p>






<section data-type="sect1" data-pdf-bookmark="Creating BPF Maps"><div class="sect1" id="idm46623561324744">
<h1>Creating BPF Maps</h1>

<p>The most direct way to create a BPF map is by using the <code>bpf</code> syscall.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="creating" id="ix_mpscr"/> When the first argument in the call is <code>BPF_MAP_CREATE</code>, you’re telling the kernel that you want to create a new map. This call will return the file descriptor identifier associated with the map you just created. The second argument in the syscall is the configuration for this map:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">union</code> <code class="n">bpf_attr</code> <code class="p">{</code>
  <code class="k">struct</code> <code class="p">{</code>
    <code class="n">__u32</code> <code class="n">map_type</code><code class="p">;</code>     <code class="cm">/* one of the values from bpf_map_type */</code>
    <code class="n">__u32</code> <code class="n">key_size</code><code class="p">;</code>     <code class="cm">/* size of the keys, in bytes */</code>
    <code class="n">__u32</code> <code class="n">value_size</code><code class="p">;</code>   <code class="cm">/* size of the values, in bytes */</code>
    <code class="n">__u32</code> <code class="n">max_entries</code><code class="p">;</code>  <code class="cm">/* maximum number of entries in the map */</code>
    <code class="n">__u32</code> <code class="n">map_flags</code><code class="p">;</code>    <code class="cm">/* flags to modify how we create the map */</code>
  <code class="p">};</code>
<code class="p">}</code></pre>

<p>The third argument in the syscall is the size of this configuration attribute.</p>

<p>For example, you can create a hash-table map <a data-type="indexterm" data-primary="hash-table maps" id="idm46623561262472"/>to store unsigned integers as keys and values as follows:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">union</code> <code class="n">bpf_attr</code> <code class="n">my_map</code> <code class="p">{</code>
  <code class="p">.</code><code class="n">map_type</code> <code class="o">=</code> <code class="n">BPF_MAP_TYPE_HASH</code><code class="p">,</code>
  <code class="p">.</code><code class="n">key_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
  <code class="p">.</code><code class="n">value_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
  <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">100</code><code class="p">,</code>
  <code class="p">.</code><code class="n">map_flags</code> <code class="o">=</code> <code class="n">BPF_F_NO_PREALLOC</code><code class="p">,</code>
<code class="p">};</code>

<code class="kt">int</code> <code class="n">fd</code> <code class="o">=</code> <code class="n">bpf</code><code class="p">(</code><code class="n">BPF_MAP_CREATE</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">my_map</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">my_map</code><code class="p">));</code></pre>

<p>If the <a data-type="indexterm" data-primary="errors" data-secondary="in creation of hash-table map" id="idm46623561259704"/>call fails, the kernel returns a value of <code>-1</code>. There might be three reasons why it fails. If one of the attributes is invalid, the kernel sets the <code>errno</code> variable to <code>EINVAL</code>. If the user executing the operation doesn’t have enough privileges, the kernel sets the <code>errno</code> variable to <code>EPERM</code>. Finally, if there is not enough memory to store the map, the kernel sets the <code>errno</code> variable to <code>ENOMEM</code>.</p>

<p>In the following sections, we guide you through different examples to show you how to perform more advanced operations with BPF maps; let’s begin with a more direct way to create any type of map.</p>








<section data-type="sect2" data-pdf-bookmark="ELF Conventions to Create BPF Maps"><div class="sect2" id="idm46623561170440">
<h2>ELF Conventions to Create BPF Maps</h2>

<p>The kernel includes several conventions and helpers to generate and work with BPF maps.<a data-type="indexterm" data-primary="ELF (Executable and Linkable Format)" data-secondary="conventions for creating BPF maps" id="idm46623561168744"/> You’ll probably find these conventions more frequently presented than direct syscall executions because they are more readable and easier to follow. Keep in mind that these conventions still use the <code>bpf</code> syscall to create the maps, even when run directly in the kernel, and you’ll find using the syscall directly more useful if you don’t know which kind of maps you’re going to need beforehand.</p>

<p>The helper function <code>bpf_map_create</code> wraps the code you just saw to make it easier to initialize maps on demand.<a data-type="indexterm" data-primary="bpf_map_create helper function" id="idm46623561166024"/> We can use it to create the previous map with only one line of code:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">fd</code><code class="p">;</code>
<code class="n">fd</code> <code class="o">=</code> <code class="n">bpf_create_map</code><code class="p">(</code><code class="n">BPF_MAP_TYPE_HASH</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code> <code class="mi">100</code><code class="p">,</code>
    <code class="n">BPF_F_NO_PREALOC</code><code class="p">);</code></pre>

<p>If you know which kind of map you’re going to need in your program, you can also predefine it. This is helpful to get more visibility in the maps your program is using beforehand:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">my_map</code> <code class="o">=</code> <code class="p">{</code>
      <code class="p">.</code><code class="n">type</code>        <code class="o">=</code> <code class="n">BPF_MAP_TYPE_HASH</code><code class="p">,</code>
      <code class="p">.</code><code class="n">key_size</code>    <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
      <code class="p">.</code><code class="n">value_size</code>  <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
      <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">100</code><code class="p">,</code>
      <code class="p">.</code><code class="n">map_flags</code>   <code class="o">=</code> <code class="n">BPF_F_NO_PREALLOC</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>When you define a map in this way, you’re using what’s called a <em>section attribute</em>, in this case <code>SEC("maps")</code>. This macro tells the kernel that this structure is a BPF map and it should be created accordingly.<a data-type="indexterm" data-primary="section attribute" id="idm46623561048216"/></p>

<p>You might have noticed that we don’t have the file descriptor identifier associated with the map in this new example.<a data-type="indexterm" data-primary="file descriptors" data-secondary="for BPF maps" data-secondary-sortas="BPF maps" id="idm46623561047064"/> In this case, the kernel uses a global variable called <code>map_data</code> to store information about the maps in your program. This variable is an array of structures, and it’s ordered by how you specified each map in your code. For example, if the previous map was the first one specified in your code, you’d get the file descriptor identifier from the first element in the array:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">fd</code> <code class="o">=</code> <code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code><code class="p">;</code></pre>

<p>You can also access the map’s name and its definition from this structure; this information is sometimes useful for debugging and tracing purposes.</p>

<p>After you have initialized the map, you can begin sending messages between the kernel and user-space with them. Let’s see now how to work with the data that these maps store.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="creating" data-startref="ix_mpscr" id="idm46623561037176"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Working with BFP Maps"><div class="sect1" id="idm46623561169816">
<h1>Working with BFP Maps</h1>

<p>Communication between the kernel and user-space is going to be a fundamental piece in every BPF program you write.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" id="ix_mpswk"/> The APIs to access maps differ when you’re writing the code for the kernel than when you’re writing the code for the user-space program. This section introduces the semantics and specific details of each <span class="keep-together">implementation</span>.</p>








<section data-type="sect2" data-pdf-bookmark="Updating Elements in a BPF Map"><div class="sect2" id="idm46623561027256">
<h2>Updating Elements in a BPF Map</h2>

<p>After creating any map, you’ll probably want to populate it with information.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" data-tertiary="updating map elements" id="idm46623561025432"/> The kernel helpers provide the function <code>bpf_map_update_elem</code> for this purpose. This function’s signature is different if you load it from <em>bpf/bpf_helpers.h</em>, within the program running on the kernel, than if you load it from <em>tools/lib/bpf/bpf.h</em>, within the program running in user-space. This is because you can access maps directly when you’re working in the kernel, but you reference them with file descriptors when you’re working in user-space. Its behavior is also slightly different; the code running on the kernel can access the map in memory directly, and it will be able to update elements atomically in place. However, the code running in user-space has to send the message to the kernel, which copies the value supplied before updating the map; this makes the update operation not atomic. This function returns 0 when the operation succeeds, and it returns a negative number when it fails. In case of failure, the global variable <code>errno</code> is populated with the failure cause. We list failure cases later in this chapter with more context.</p>

<p>The <code>bpf_map_update_elem</code> function within the kernel takes four arguments. The first one is the pointer to the map we’ve already defined.<a data-type="indexterm" data-primary="bpf_map_update_elem function" id="idm46623561020728"/> The second one is a pointer to the key we want to update. Because the kernel doesn’t know the type of key we’re updating, this method is defined as an opaque pointer to <code>void</code>, which means we can pass any data. The third argument is the value we want to insert. This argument uses the same semantics as the key argument. We show some advanced examples of how to take advantage of opaque pointers throughout this book. You can use the fourth argument in this function to change the way the map is updated. This argument can take three values:</p>

<ul>
<li>
<p>If you pass <code>0</code>, you’re telling the kernel that you want to update the element if it exists or that it should create the element in the map if it doesn’t exist.</p>
</li>
<li>
<p>If you pass <code>1</code>, you’re telling the kernel to create the element only when it doesn’t exist.</p>
</li>
<li>
<p>If you pass <code>2</code>, the kernel will update the element only when it exists.</p>
</li>
</ul>

<p>These values are defined as constants that you can also use, instead of having to remember the integer semantics. The values are <code>BPF_ANY</code> for <code>0</code>, <code>BPF_NOEXIST</code> for <code>1</code>, and <code>BPF_EXIST</code> for <code>2</code>.</p>

<p>Let’s use the map we defined in the previous section to write some examples. In our first example, we add a new value to the map. Because the map is empty, we can assume that any update behavior is good for us:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="n">value</code> <code class="o">=</code> <code class="mi">1234</code><code class="p">;</code>

<code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">my_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Map updated with new element</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
<code class="k">else</code>
  <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to update map with new value: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code></pre>

<p>In this example we’re using <code>strerror</code> to describe the error set in the <code>errno</code> variable.<a data-type="indexterm" data-primary="errors" data-secondary="in updating map elements" id="idm46623560905912"/><a data-type="indexterm" data-primary="strerror function" id="idm46623560904968"/> You can learn more about this function on the manual pages using <code>man strerror</code>.</p>

<p>Now let’s see which result we get when we try to create an element with the same key:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="n">value</code> <code class="o">=</code> <code class="mi">5678</code><code class="p">;</code>

<code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">my_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">,</code> <code class="n">BPF_NOEXIST</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Map updated with new element</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
<code class="k">else</code>
  <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to update map with new value: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code></pre>

<p>Because we have already created an element with key <code>1</code> in our map, the result from calling <code>bpf_map_update_elem</code> will be <code>-1</code>, and the <code>errno</code> value will be <code>EEXIST</code>. This program will print the following on the screen:</p>

<p><code>Failed to update map with new value: -1 (File  exists)</code></p>

<p>Similarly, let’s change this program to try to update an element that doesn’t exist yet:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1234</code><code class="p">,</code> <code class="n">value</code> <code class="o">=</code> <code class="mi">5678</code><code class="p">;</code>

<code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">my_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">,</code> <code class="n">BPF_EXIST</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Map updated with new element</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
<code class="k">else</code>
  <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to update map with new value: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code></pre>

<p>With the flag <code>BPF_EXIST</code>, the result of this operation is going to be <code>-1</code> again. The kernel will set the <code>errno</code> variable to <code>ENOENT</code>, and the program will print the following:</p>

<p><code>Failed to update map with new value: -1 (No such file or directory)</code></p>

<p>These examples show how you can update maps from within the kernel program. You can also update maps from within user-space programs. The helpers to do this are similar to the ones we just saw; the only difference is that they use the file descriptor to access the map, rather than using the pointer to the map directly. As you remember, user-space programs always access maps using file descriptors. <a data-type="indexterm" data-primary="file descriptors" data-secondary="in user-space programs accessing maps" id="idm46623560719016"/><a data-type="indexterm" data-primary="user-space" data-secondary="programs accessing maps, use of file descriptors" id="idm46623560718072"/>So in our examples, we’d replace the argument <code>my_map</code> with the global file descriptor identifier <code>map_data[0].fd</code>. Here is what the original code looks like in this case:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="n">value</code> <code class="o">=</code> <code class="mi">1234</code><code class="p">;</code>

<code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Map updated with new element</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
<code class="k">else</code>
  <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to update map with new value: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code></pre>

<p>Although the type of information that you can store in a map is directly related to the type of map that you’re working with, the method to populate the information will remain the same, as you saw in this previous example. We discuss the types of keys and values accepted for each type of map later; let’s first see how to manipulate the store data.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Reading Elements from a BPF Map"><div class="sect2" id="idm46623561026600">
<h2>Reading Elements from a BPF Map</h2>

<p>Now that we’ve populated our map with new elements, we can begin reading them from other points in our code. <a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" data-tertiary="reading elements" id="idm46623560624952"/>The reading API will look familiar after learning about <code>bpf_map_update_element</code>.</p>

<p>BPF also provides two different helpers to read from a map depending on where your code is running.<a data-type="indexterm" data-primary="bpf_map_lookup_elem helper function" id="idm46623560622632"/> Both helpers are called <code>bpf_map_lookup_elem</code>. Like the update helpers, they differ in their first argument; the kernel method takes a reference to the map, whereas the user-space helper takes the map’s file descriptor identifier as its first argument. Both methods return an integer to represent whether the operation failed or succeeded, just like the update helpers. The third argument in these helpers is a pointer to the variable in your code that’s going to store the value read from the map. We present two examples based on the code you saw in the previous section.</p>

<p>The first example reads the value inserted in the map when the BPF program is running on the kernel:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code> <code class="c1">// value is going to store the expected element's value</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

<code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">my_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Value read from the map: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">value</code><code class="p">);</code>
<code class="k">else</code>
  <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to read value from the map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code></pre>

<p>If the key we were trying to read, <code>bpf_map_lookup_elem</code>, returned a negative number, it would set the error in the <code>errno</code> variable. For example, if we had not inserted the value before trying to read it, the kernel would have returned the “not found” error <code>ENOENT</code>.</p>

<p>This second example is similar to the one you just saw, but this time we’re reading the map from the program running in user-space:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code> <code class="c1">// value is going to store the expected element's value</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

<code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Value read from the map: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">value</code><code class="p">);</code>
<code class="k">else</code>
  <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to read value from the map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code></pre>

<p>As you can see, we’ve replaced the first argument in <code>bpf_map_lookup_elem</code> with the map’s file descriptor identifier. The helper behavior is the same as the previous <span class="keep-together">example</span>.</p>

<p>That’s all we need to be able to access information within a BPF map. We examine how this has been streamlined by different toolkits to make accessing data even simpler in later chapters. Let’s talk about deleting data from maps next.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Removing an Element from a BPF Map"><div class="sect2" id="idm46623560625832">
<h2>Removing an Element from a BPF Map</h2>

<p>The third operation we can execute on maps is to remove elements.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" data-tertiary="removing elements" id="idm46623560432968"/> Like with writing and reading elements, BPF gives us two different helpers to remove elements, both called <code>bpf_map_delete_element</code>. Like in the previous examples, these helpers use the direct reference to the map when you use them in the program running on the kernel, and they use the map’s file descriptor identifier when you use them in the program running on user-space.</p>

<p>The first example deletes<a data-type="indexterm" data-primary="bpf_map_delete_element function" id="idm46623560430408"/> the value inserted in the map when the BPF program is running on the kernel:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

<code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_delete_element</code><code class="p">(</code><code class="o">&amp;</code><code class="n">my_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Element deleted from the map</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
<code class="k">else</code>
  <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to delete element from the map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code></pre>

<p>If the element that you’re trying to delete doesn’t exist, the kernel returns a negative number. In that case, it also populates the <code>errno</code> variable with the “not found” error <code>ENOENT</code>.<a data-type="indexterm" data-primary="errors" data-secondary="in deleting map elements" id="idm46623560344472"/></p>

<p class="pagebreak-before">This second example deletes the value when the BPF program is running on <span class="keep-together">user-space</span>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

<code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_delete_element</code><code class="p">(</code><code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Element deleted from the map</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
<code class="k">else</code>
  <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to delete element from the map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
      <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code></pre>

<p>You can see that we’ve changed the first argument again to use the file descriptor identifier. Its behavior is going to be consistent with the kernel’s helper.</p>

<p>This concludes what could be considered the create/read/update/delete (CRUD) operations of the BPF map. The kernel exposes some additional functions to help you with other common operations; we’ll talk about some of them in the next two <span class="keep-together">sections</span>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Iterating Over Elements in a BPF Map"><div class="sect2" id="idm46623560265912">
<h2>Iterating Over Elements in a BPF Map</h2>

<p>The final operation we look at in this section can help you to find arbitrary elements in a BPF program.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="iterating over elements" id="ix_mpswkitr"/> There will be occasions when you don’t know exactly the key for the element you’re looking for or you just want to see what’s inside a map. BPF provides an instruction for this called <code>bpf_map_get_next_key</code>. Unlike the helpers you’ve seen up to now, this instruction is available only for programs running on user-space.</p>

<p>This helper gives you a deterministic way to iterate over the elements on a map, but its behavior is less intuitive than iterators in most programming languages. It takes three arguments. The first one is the map’s file descriptor identifier, like the other user-space helpers you’ve already seen. The next two arguments are where it becomes tricky. According to the official documentation, the second argument, <code>key</code>, is the identifier you’re looking for, and the third one, <code>next_key</code>, is the next key in the map. We prefer to call the first argument <code>lookup_key</code>—it’s going to become apparent why in a second. When you call this helper, BPF tries to find the element in this map with the key that you’re passing as the lookup key; then, it sets the <code>next_key</code> argument with the adjacent key in the map. So if you want to know which key comes after key <code>1</code>, you need to set <code>1</code> as your lookup key, and if the map has an adjacent key to this one, BPF will set it as the value for the <code>next_key</code> argument.</p>

<p>Before seeing how <code>bpf_map_get_next_key</code> works in an example, let’s add a few more elements to our map:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">new_key</code><code class="p">,</code> <code class="n">new_value</code><code class="p">,</code> <code class="n">it</code><code class="p">;</code>

<code class="k">for</code> <code class="p">(</code><code class="n">it</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code> <code class="n">it</code> <code class="o">&lt;</code> <code class="mi">6</code> <code class="p">;</code> <code class="n">it</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">new_key</code> <code class="o">=</code> <code class="n">it</code><code class="p">;</code>
  <code class="n">new_value</code> <code class="o">=</code> <code class="mi">1234</code> <code class="o">+</code> <code class="n">it</code><code class="p">;</code>
  <code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">new_key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">new_value</code><code class="p">,</code> <code class="n">BPF_NOEXIST</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>If you want to print all of the values in the map, you can use <code>bpf_map_get_next_key</code> with a lookup key that doesn’t exist in the map.<a data-type="indexterm" data-primary="bpf_map_get_next_key function" id="idm46623560172776"/> This forces BPF to start from the beginning of the map:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">next_key</code><code class="p">,</code> <code class="n">lookup_key</code><code class="p">;</code>
<code class="n">lookup_key</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>

<code class="k">while</code><code class="p">(</code><code class="n">bpf_map_get_next_key</code><code class="p">(</code><code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">lookup_key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">next_key</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"The next key in the map is: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">next_key</code><code class="p">);</code>
  <code class="n">lookup_key</code> <code class="o">=</code> <code class="n">next_key</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>This code prints something like this:</p>
<pre>The next key in the map is: '1'
The next key in the map is: '2'
The next key in the map is: '3'
The next key in the map is: '4'
The next key in the map is: '5'</pre>

<p>You can see that we’re assigning the next key to <code>lookup_key</code> at the end of the loop; that way, we continue iterating over the map until we reach the end. When <code>bpf_map_get_next_key</code> arrives at the end of the map, the value returned is a negative number, and the <code>errno</code> variable is set to <code>ENOENT</code>. This will abort the loop execution.</p>

<p>As you can imagine, <code>bpf_map_get_next_key</code> can look up keys starting at any point in the map; you don’t need to start at the beginning of the map if you want only the next key for another specific key.</p>

<p>The tricks that <code>bpf_map_get_next_key</code> can play on you don’t end here; there is another behavior that you need to be aware of. Many programming languages copy the values in a map before iterating over its elements. This prevents unknown behaviors if some other code in your program decides to mutate the map. This is especially dangerous if that code deletes elements from the map. BPF doesn’t copy the values in a map before looping over them with <code>bpf_map_get_next_key</code>. If another part of your program deletes an element from the map while you’re looping over the values, <code>bpf_map_get_next_key</code> will start over when it tries to find the next value for the element’s key that was removed. Let’s see this with an example:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">next_key</code><code class="p">,</code> <code class="n">lookup_key</code><code class="p">;</code>
<code class="n">lookup_key</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>

<code class="k">while</code><code class="p">(</code><code class="n">bpf_map_get_next_key</code><code class="p">(</code><code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">lookup_key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">next_key</code><code class="p">)</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"The next key in the map is: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">next_key</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">next_key</code> <code class="o">==</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"Deleting key '2'</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
    <code class="n">bpf_map_delete_element</code><code class="p">(</code><code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code> <code class="o">&amp;</code><code class="n">next_key</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="n">lookup_key</code> <code class="o">=</code> <code class="n">next_key</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>This program prints the next output:</p>

<pre data-type="programlisting" data-code-language="bash">The next key in the map is: <code class="s1">'1'</code>
The next key in the map is: <code class="s1">'2'</code>
Deleteing key <code class="s1">'2'</code>
The next key in the map is: <code class="s1">'1'</code>
The next key in the map is: <code class="s1">'3'</code>
The next key in the map is: <code class="s1">'4'</code>
The next key in the map is: <code class="s1">'5'</code></pre>

<p>This behavior is not very intuitive, so keep it in mind when you use <code>bpf_map_get_next_key</code>.</p>

<p>Because most of the map types that we cover in this chapter behave like arrays, iterating over them is going to be a key operation when you want to access the information that they store. However, there are additional functions to access data, as you’ll see next.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" data-tertiary="iterating over elements" data-startref="ix_mpswkitr" id="idm46623559983688"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Looking Up and Deleting Elements"><div class="sect2" id="idm46623560265320">
<h2>Looking Up and Deleting Elements</h2>

<p>Another interesting function that the kernel exposes to work with maps is <code>bpf_map_lookup_and_delete_elem</code>. <a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" data-tertiary="looking up and deleting elements" id="idm46623559980264"/>This function searches for a given key in the map and deletes the element from it. At the same time, it writes the value of the element in a variable for your program to use. This function comes in handy when you use queue and stack maps, which we describe in the next section. However, it’s not restricted for use only with those types of maps. Let’s see an example of how to use it with the map we’ve been using in our previous examples:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">,</code> <code class="n">result</code><code class="p">,</code> <code class="n">it</code><code class="p">;</code>
<code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>

<code class="k">for</code> <code class="p">(</code><code class="n">it</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">it</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="p">;</code> <code class="n">it</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_lookup_and_delete_element</code><code class="p">(</code><code class="n">map_data</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="n">fd</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"Value read from the map: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">value</code><code class="p">);</code>
  <code class="k">else</code>
    <code class="nf">printf</code><code class="p">(</code><code class="s">"Failed to read value from the map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
        <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code>
<code class="p">}</code></pre>

<p>In this example, we try to fetch the same element from the map twice.<a data-type="indexterm" data-primary="bpf_map_lookup_and_delete_element function" id="idm46623559971576"/> In the first iteration, this code will print the value of the element in the map. However, because we’re using <code>bpf_map_lookup_and_delete_element</code>, this first iteration will also delete the element from the map. The second time the loop tries to fetch the element, this code will fail, and it will populate the <code>errno</code> variable with the “not found” error <code>ENOENT</code>.<a data-type="indexterm" data-primary="errors" data-secondary="in looking up and deleting map elements" id="idm46623559830456"/></p>

<p>Until now, we haven’t paid much attention to what happens when concurrent operations try to access the same piece of information within a BPF map. Let’s talk about this next.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Concurrent Access to Map Elements"><div class="sect2" id="idm46623559828824">
<h2>Concurrent Access to Map Elements</h2>

<p>One of the challenges of working with BPF maps is that many programs can access the same maps concurrently.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" data-tertiary="concurrent access to map elements" id="ix_mpswkcon"/><a data-type="indexterm" data-primary="race conditions, avoiding in concurrent access to map elements" id="idm46623559825640"/> This can introduce race conditions in our BPF programs, and make accessing resources in maps unpredictable. To prevent race conditions, BPF introduced the concept of BPF spin locks, which allow you to lock access to a map’s element while you’re operating on it. <a data-type="indexterm" data-primary="spin locks" id="idm46623559824584"/>Spin locks work only on array, hash, and cgroup storage maps.</p>

<p>There are two BPF helper functions to work with spin locks: <code>bpf_spin_lock</code> locks an element, and <code>bpf_spin_unlock</code> unlocks that element.<a data-type="indexterm" data-primary="bpf_spin_unlock function" id="idm46623559822312"/><a data-type="indexterm" data-primary="bpf_spin_lock function" id="idm46623559821608"/><a data-type="indexterm" data-primary="locks" data-secondary="spin locks for concurrent access to BPF map elements" id="idm46623559820936"/> These helpers work with a structure that acts as a semaphone to access an element that includes this semaphore. When the semaphore is locked, other programs cannot access the element’s value, and they wait until the semaphore is unlocked. At the same time, BPF spin locks introduce a new flag that user-space programs can use to change the state of that lock; that flag is called <code>BPF_F_LOCK</code>.</p>

<p>The first thing we need to do to work with spin locks is create the element that we want to lock access to and then add our semaphore:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">concurrent_element</code> <code class="p">{</code>
  <code class="k">struct</code> <code class="n">bpf_spin_lock</code> <code class="n">semaphore</code><code class="p">;</code>
  <code class="kt">int</code> <code class="n">count</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>We’ll store this structure in our BPF map, and we’ll use the semaphore within the element to prevent undesired access to it. Now, we can declare the map that’s going to hold these elements.<a data-type="indexterm" data-primary="BTF (BPF Type Format)" data-secondary="annotating a map with" id="idm46623559808888"/> This map must be annotated with BPF Type Format (BTF) so the verifier knows how to intepret the structure. The type format gives the kernel and other tools a much richer understanding of BPF data structures by adding debug information to binary objects. Because this code will run within the kernel, we can use the kernel macros that <code>libbpf</code> provides to annotate this concurrent map:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">concurrent_map</code> <code class="o">=</code> <code class="p">{</code>
      <code class="p">.</code><code class="n">type</code>        <code class="o">=</code> <code class="n">BPF_MAP_TYPE_HASH</code><code class="p">,</code>
      <code class="p">.</code><code class="n">key_size</code>    <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
      <code class="p">.</code><code class="n">value_size</code>  <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code> <code class="n">concurrent_element</code><code class="p">),</code>
      <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">100</code><code class="p">,</code>
<code class="p">};</code>

<code class="n">BPF_ANNOTATE_KV_PAIR</code><code class="p">(</code><code class="n">concurrent_map</code><code class="p">,</code> <code class="kt">int</code><code class="p">,</code> <code class="k">struct</code> <code class="n">concurrent_element</code><code class="p">);</code></pre>

<p>Within a BPF program we can use the two locking helpers to protect from race conditions on those elements. Even though the semaphore is locked, our program is guaranteed to be able to modify the element’s value safely:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="nf">bpf_program</code><code class="p">(</code><code class="k">struct</code> <code class="n">pt_regs</code> <code class="o">*</code><code class="n">ctx</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">key</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">concurrent_element</code> <code class="n">init_value</code> <code class="o">=</code> <code class="p">{};</code>
  <code class="k">struct</code> <code class="n">concurrent_element</code> <code class="o">*</code><code class="n">read_value</code><code class="p">;</code>

  <code class="n">bpf_map_create_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">concurrent_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">init_value</code><code class="p">,</code> <code class="n">BPF_NOEXIST</code><code class="p">);</code>

  <code class="n">read_value</code> <code class="o">=</code> <code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">concurrent_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">);</code>
  <code class="n">bpf_spin_lock</code><code class="p">(</code><code class="o">&amp;</code><code class="n">read_value</code><code class="o">-&gt;</code><code class="n">semaphore</code><code class="p">);</code>
  <code class="n">read_value</code><code class="o">-&gt;</code><code class="n">count</code> <code class="o">+=</code> <code class="mi">100</code><code class="p">;</code>
  <code class="n">bpf_spin_unlock</code><code class="p">(</code><code class="o">&amp;</code><code class="n">read_value</code><code class="o">-&gt;</code><code class="n">semaphore</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This example initializes our concurrent map with a new entry that can lock access to its value. Then, it fetches that value from the map and locks its semaphore so that it can hold the count value, preventing data races. When it’s done using the value, it releases the lock so other maps can access the element safely.</p>

<p>From user-space, we can hold the reference to an element in our concurrent map by using the flag <code>BPF_F_LOCK</code>.<a data-type="indexterm" data-primary="BPF_F_LOCK flag" id="idm46623559601704"/> You can use this flag with the <code>bpf_map_update_elem</code> and <code>bpf_map_lookup_elem_flags</code> helper functions. This flag allows you to update elements in place without having to worry about data races.<a data-type="indexterm" data-primary="bpf_map_lookup_elem_flags function" id="idm46623559599976"/><a data-type="indexterm" data-primary="bpf_map_update_elem function" data-secondary="BPF_F_LOCK flag" id="idm46623559599336"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>BPF_F_LOCK</code> has a slightly different behavior when updating hash map and updating array and cgroup storage maps.<a data-type="indexterm" data-primary="BPF_F_LOCK flag" data-secondary="different behaviors with different types of maps" id="idm46623559597304"/> With the latter two, the updates happen in place, and the elements that you’re updating must exist in the map before executing the update. In the case of hash maps, if the element doesn’t exist already, the program locks the bucket in the map for the element and inserts a new <span class="keep-together">element</span>.</p>
</div>

<p>Spin locks are not always necessary. You don’t need them if you’re only aggregating values in a map. However, they are useful if you want to ensure that concurrent programs don’t change elements in a map when you’re performing several operations on them, preserving atomicity.</p>

<p>In this section you’ve seen the possible operations you can do with BPF maps; however, we’ve worked with only one type of map so far. BPF includes many more map types that you can use in different situations.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" data-tertiary="concurrent access to map elements" data-startref="ix_mpswkcon" id="idm46623559593688"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="working with" data-startref="ix_mpswk" id="idm46623559592152"/> We explain all types of maps that BPF defines and show you specific examples on how to use them for different <span class="keep-together">situations</span>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Types of BPF Maps"><div class="sect1" id="idm46623559828200">
<h1>Types of BPF Maps</h1>

<p>The <a href="https://oreil.ly/XfoqK">Linux documentation</a> defines maps as generic data structures where you can store different types of data.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" id="ix_mpstyp"/> Over the years, the kernel developers have added many specialized data structures that are more efficient in specific use cases. This section explores each type of map and how you can use them.</p>








<section data-type="sect2" data-pdf-bookmark="Hash-Table Maps"><div class="sect2" id="idm46623559585608">
<h2>Hash-Table Maps</h2>

<p>Hash-table maps were the first generic map added to BPF.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="hash-table maps" id="idm46623559583848"/><a data-type="indexterm" data-primary="hash-table maps" id="idm46623559582600"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_HASH type" id="idm46623559581928"/> They are defined with the type <code>BPF_MAP_TYPE_HASH</code>. Their implementation and usage are similar to other hash tables you might be familiar with. You can use keys and values of any size; the kernel takes care of allocating and freeing them for you as needed. When you use <code>bpf_map_update_elem</code> on a hash-table map, the kernel replaces the elements <span class="keep-together">atomically</span>.</p>

<p>Hash-table maps are optimized to be very fast at lookup; they are useful for keeping structured data that’s read frequently. <a data-type="indexterm" data-primary="structured data" data-secondary="in hash-table maps" id="idm46623559578936"/>Let’s see an example program that uses them to keep track of network IPs and their rate limits:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#define IPV4_FAMILY 1</code>
<code class="k">struct</code> <code class="n">ip_key</code> <code class="p">{</code>
  <code class="k">union</code> <code class="p">{</code>
    <code class="n">__u32</code> <code class="n">v4_addr</code><code class="p">;</code>
    <code class="n">__u8</code> <code class="n">v6_addr</code><code class="p">[</code><code class="mi">16</code><code class="p">];</code>
  <code class="p">};</code>
  <code class="n">__u8</code> <code class="n">family</code><code class="p">;</code>
<code class="p">};</code>

<code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">counters</code> <code class="o">=</code> <code class="p">{</code>
      <code class="p">.</code><code class="n">type</code>        <code class="o">=</code> <code class="n">BPF_MAP_TYPE_HASH</code><code class="p">,</code>
      <code class="p">.</code><code class="n">key_size</code>    <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code> <code class="n">ip_key</code><code class="p">),</code>
      <code class="p">.</code><code class="n">value_size</code>  <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">uint64_t</code><code class="p">),</code>
      <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">100</code><code class="p">,</code>
      <code class="p">.</code><code class="n">map_flags</code>   <code class="o">=</code> <code class="n">BPF_F_NO_PREALLOC</code>
<code class="p">};</code></pre>

<p>In this code we’ve declared a structured key, and we’re going to use it to keep information about IP addresses. We define the map that our program will use to keep track of rate limits. You can see that we’re using the IP addresses as keys in this map. The values are going to be the number of times that our BPF program receives a network packet from a specific IP address.</p>

<p>Let’s write a small code snippet that updates those counters in the kernel:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">uint64_t</code> <code class="nf">update_counter</code><code class="p">(</code><code class="kt">uint32_t</code> <code class="n">ipv4</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">uint64_t</code> <code class="n">value</code><code class="p">;</code>
  <code class="k">struct</code> <code class="n">ip_key</code> <code class="n">key</code> <code class="o">=</code> <code class="p">{};</code>
  <code class="n">key</code><code class="p">.</code><code class="n">v4_addr</code> <code class="o">=</code> <code class="n">ip4</code><code class="p">;</code>
  <code class="n">key</code><code class="p">.</code><code class="n">family</code> <code class="o">=</code> <code class="n">IPV4_FAMILY</code><code class="p">;</code>

  <code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="n">counters</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">);</code>
  <code class="p">(</code><code class="o">*</code><code class="n">value</code><code class="p">)</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>This function takes an IP address extracted from a network packet<a data-type="indexterm" data-primary="bpf_map_lookup_elem helper function" id="idm46623559458472"/> and performs the map lookup with the compound key that we’re declaring. In this case, we’re assuming that we’ve previously initialized the counter with a zero value; otherwise, the <code>bpf_map_lookup_elem</code> call would return a negative number.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Array Maps"><div class="sect2" id="idm46623559393592">
<h2>Array Maps</h2>

<p>Array maps were the second type of BPF map added to the kernel.<a data-type="indexterm" data-primary="array maps" id="idm46623559392152"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="array maps" id="idm46623559391448"/> They are defined with the type <code>BPF_MAP_TYPE_ARRAY</code>. When you initialize an array map, all of its elements are preallocated in memory and set to their zero value. Because these maps are backed by a slice of elements, the keys are indexes in the array, and their size must be exactly four bytes.</p>

<p>A disadvantage of using array maps is that the elements in the map cannot be removed and you cannot make the array smaller than it is. If you try to use <code>map_delete_elem</code> on an array map, the call will fail, and you’ll get an error <code>EINVAL</code> as a result.</p>

<p>Array maps are commonly used to store information that can change in value, but it’s usually fixed in behavior. People use them to store global variables with a predefined assignment rule. Because you cannot remove elements, you can assume that the element in a specific position always represents the same element.</p>

<p>Something else to keep in mind is that <code>map_update_elem</code> is not atomic, like you saw with hash-table maps. The same program can read different values from the same position at the same time if there is an update in process. If you’re storing counters in an array map, you can use the kernel’s built-in function <code>__sync_fetch_and_add</code> to perform atomic operations on the map’s values.<a data-type="indexterm" data-primary="__sync_fetch_and_add function" data-primary-sortas="sync_fetch" id="idm46623559385736"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Program Array Maps"><div class="sect2" id="idm46623559384616">
<h2>Program Array Maps</h2>

<p>Program array maps were the first specialized map added to the kernel.<a data-type="indexterm" data-primary="program array maps" id="idm46623559382920"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="program array maps" id="idm46623559382216"/> They are defined with the type <code>BPF_MAP_TYPE_PROG_ARRAY</code>.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_PROG_ARRAY type" id="idm46623559380488"/> You can use this type of map to store references to BPF programs using their file descriptor identifiers. In conjunction with the helper <code>bpf_tail_call</code>, this map allows you to jump between programs, bypassing the maximum instruction limit of single BPF programs and reducing implementation complexity.</p>

<p>There are a few things you need to consider when you use this specialized map. The first aspect to remember is that both key and value sizes must be four bytes. The <span class="keep-together">second</span> aspect to remember is that when you jump to a new program, the new program will reuse the same memory stack, so your program doesn’t consume all the available memory. Finally, if you try to jump to a program that doesn’t exist in the map, the tail call will fail, and the current program will continue its execution.</p>

<p>Let’s dive into a detailed example to understand how to use this type of map better:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">programs</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">.</code><code class="n">type</code> <code class="o">=</code> <code class="n">BPF_MAP_TYPE_PROG_ARRAY</code><code class="p">,</code>
  <code class="p">.</code><code class="n">key_size</code> <code class="o">=</code> <code class="mi">4</code><code class="p">,</code>
  <code class="p">.</code><code class="n">value_size</code> <code class="o">=</code> <code class="mi">4</code><code class="p">,</code>
  <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">1024</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>First, we need to declare our new program map (as we mentioned earlier, the key and value sizes are always four bytes):</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="k">struct</code> <code class="n">bpf_insn</code> <code class="n">prog</code><code class="p">[]</code> <code class="o">=</code> <code class="p">{</code>
  <code class="n">BPF_MOV64_IMM</code><code class="p">(</code><code class="n">BPF_REG_0</code><code class="p">,</code> <code class="mi">0</code><code class="p">),</code> <code class="c1">// assign r0 = 0</code>
  <code class="n">BPF_EXIT_INSN</code><code class="p">(),</code>  <code class="c1">// return r0</code>
<code class="p">};</code>

<code class="n">prog_fd</code> <code class="o">=</code> <code class="n">bpf_prog_load</code><code class="p">(</code><code class="n">BPF_PROG_TYPE_KPROBE</code><code class="p">,</code> <code class="n">prog</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">prog</code><code class="p">),</code> <code class="s">"GPL"</code><code class="p">);</code>
<code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">programs</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">prog_fd</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code></pre>

<p>We need to declare the program that we’re going to jump to. In this case, we’re writing a BPF program, and its only purpose is to return 0. We use <code>bpf_prog_load</code> to load it in the kernel, and then we add its file descriptor identifier to our program map.<a data-type="indexterm" data-primary="file descriptors" data-secondary="in program array map" id="idm46623559245352"/></p>

<p>Now that we have that program stored, we can write another BPF program that will jump to it. BPF programs can jump to other programs only if they are of the same type; in this case, we’re attaching the program to a kprobe trace,<a data-type="indexterm" data-primary="kprobe programs" data-secondary="attaching program to kprobe trace" id="idm46623559243880"/><a data-type="indexterm" data-primary="tail calls" data-secondary="jumping from one program to another" id="idm46623559242936"/> like we saw in <span class="keep-together"><a data-type="xref" href="ch02.html#running_your_first_BPF_programs">Chapter 2</a></span>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">SEC</code><code class="p">(</code><code class="s">"kprobe/seccomp_phase1"</code><code class="p">)</code>
<code class="kt">int</code> <code class="n">bpf_kprobe_program</code><code class="p">(</code><code class="k">struct</code> <code class="n">pt_regs</code> <code class="o">*</code><code class="n">ctx</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
  <code class="cm">/* dispatch into next BPF program */</code>
  <code class="n">bpf_tail_call</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">programs</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">);</code>

  <code class="cm">/* fall through when the program descriptor is not in the map */</code>
  <code class="kt">char</code> <code class="n">fmt</code><code class="p">[]</code> <code class="o">=</code> <code class="s">"missing program in prog_array map</code><code class="se">\n</code><code class="s">"</code><code class="p">;</code>
  <code class="n">bpf_trace_printk</code><code class="p">(</code><code class="n">fmt</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">fmt</code><code class="p">));</code>
  <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>With <code>bpf_tail_call</code> and <code>BPF_MAP_TYPE_PROG_ARRAY</code>, you can chain up to 32 nested calls.<a data-type="indexterm" data-primary="bpf_tail_call function" id="idm46623559159544"/><a data-type="indexterm" data-primary="chaining nested calls, limits on" id="idm46623559158984"/> This is an explicit limit to prevent infinite loops and memory exhaustion.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Perf Events Array Maps"><div class="sect2" id="idm46623559384024">
<h2>Perf Events Array Maps</h2>

<p>These types of maps store <code>perf_events</code> data in a buffer ring that communicates between BPF programs and user-space programs in real time. They are defined with the type <code>BPF_MAP_TYPE_PERF_EVENT_ARRAY</code>.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_PERF_EVENT_ARRAY type" id="idm46623559155496"/><a data-type="indexterm" data-primary="Perf events array maps" id="idm46623559154728"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="Perf events array map" id="idm46623559154056"/> They are designed to forward events that the kernel’s tracing tools emit to user-space programs for further processing. This is one of the most interesting types of maps and is the base for many observability tools that we’ll talk about in the next chapters. The user-space program acts as a listener that waits for events coming from the kernel, so you need to make sure that your code starts listening before the BPF program in the kernel is initialized.</p>

<p>Let’s see an example of how we can trace all the programs that our computer executes. Before jumping into the BPF program code, we need to declare the event structure that we’re going to send from the kernel to user-space:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="kt">data_t</code> <code class="p">{</code>
  <code class="n">u32</code> <code class="n">pid</code><code class="p">;</code>
  <code class="kt">char</code> <code class="n">program_name</code><code class="p">[</code><code class="mi">16</code><code class="p">];</code>
<code class="p">};</code></pre>

<p>Now, we need to create the map that’s going to send the events to user-space:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">events</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">.</code><code class="n">type</code> <code class="o">=</code> <code class="n">BPF_MAP_TYPE_PERF_EVENT_ARRAY</code><code class="p">,</code>
  <code class="p">.</code><code class="n">key_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
  <code class="p">.</code><code class="n">value_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">u32</code><code class="p">),</code>
  <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>After we have our data type and map declared, we can create the BPF program that captures the data<a data-type="indexterm" data-primary="bpf_capture_exec function" id="idm46623559002824"/> and sends it to user-space:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">SEC</code><code class="p">(</code><code class="s">"kprobe/sys_exec"</code><code class="p">)</code>
<code class="kt">int</code> <code class="n">bpf_capture_exec</code><code class="p">(</code><code class="k">struct</code> <code class="n">pt_regs</code> <code class="o">*</code><code class="n">ctx</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">data_t</code> <code class="n">data</code><code class="p">;</code>
  <code class="c1">// bpf_get_current_pid_tgid returns the current process identifier</code>
  <code class="n">data</code><code class="p">.</code><code class="n">pid</code> <code class="o">=</code> <code class="n">bpf_get_current_pid_tgid</code><code class="p">()</code> <code class="o">&gt;&gt;</code> <code class="mi">32</code><code class="p">;</code>
  <code class="c1">// bpf_get_current_comm loads the current executable name</code>
  <code class="n">bpf_get_current_comm</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">.</code><code class="n">program_name</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">program_name</code><code class="p">));</code>
  <code class="n">bpf_perf_event_output</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">events</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">data</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">));</code>
  <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>In this snippet, we’re using <code>bpf_perf_event_output</code> to append the data to the map. Because this is a real-time buffer, you don’t need worry about keys for the elements in the map; the kernel takes care of adding the new element to the map and flushing it after the user-space program processes it.</p>

<p>In <a data-type="xref" href="ch04.html#tracing_with_bpf">Chapter 4</a> we talk about more advanced usages for these types of maps, and we present examples of processing programs in user-space.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Per-CPU Hash Maps"><div class="sect2" id="idm46623559157624">
<h2>Per-CPU Hash Maps</h2>

<p>This type of map is a refined version of <code>BPF_MAP_TYPE_HASH</code>. These maps are defined with the type <code>BPF_MAP_TYPE_PERCPU_HASH</code>. <a data-type="indexterm" data-primary="BPF_MAP_TYPE_PERCPU_HASH type" id="idm46623558955880"/><a data-type="indexterm" data-primary="per-cpu hash maps" id="idm46623558955112"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="per-cpu hash map" id="idm46623558954440"/>When you allocate one of these maps, each CPU sees its own isolated version of the map, which makes it much more efficient for high-performant lookups and aggregations. This type of map is useful if your BPF program collects metrics and aggregates them in hash-table maps.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Per-CPU Array Maps"><div class="sect2" id="idm46623558952552">
<h2>Per-CPU Array Maps</h2>

<p>This type of map is also a refined version of <code>BPF_MAP_TYPE_ARRAY</code>.<a data-type="indexterm" data-primary="per-cpu array maps" id="idm46623558950776"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="per-cpu array map" id="idm46623558950040"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_PERCPU_ARRAY type" id="idm46623558948824"/> They are defined with the type <code>BPF_MAP_TYPE_PERCPU_ARRAY</code>. Just like the previous map, when you allocate one of these maps, each CPU sees its own isolated version of the map, which makes it much more efficient for high-performant lookups and aggregations.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Stack Trace Maps"><div class="sect2" id="idm46623558947112">
<h2>Stack Trace Maps</h2>

<p>This type of map stores stack traces from the running process.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="stack trace map" id="idm46623558945816"/><a data-type="indexterm" data-primary="stack trace maps" id="idm46623558944568"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_STACK_TRACE type" id="idm46623558943896"/> They are defined with the type <code>BPF_MAP_TYPE_STACK_TRACE</code>. Along with this map, the kernel developers already added the helper <code>bpf_get_stackid</code> to help you populate this map with stack traces. This helper takes the map as an argument and a series of flags so that you can specify whether you want traces only from the kernel, only from user-space, or both. The helper returns the key associated with the element added to the map.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Cgroup Array Maps"><div class="sect2" id="idm46623558941656">
<h2>Cgroup Array Maps</h2>

<p>This type of map stores references to cgroups.<a data-type="indexterm" data-primary="cgroup array maps" id="idm46623558940088"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="cgroup array map" id="idm46623558939384"/> Cgroup array maps are defined with the type <code>BPF_MAP_TYPE_CGROUP_ARRAY</code>. In essence, their behavior is similar to <code>BPF_MAP_TYPE_PROG_ARRAY</code>, but they store file descriptor identifiers that point to cgroups.</p>

<p>This map is useful when you want to share cgroup references between BPF maps for controlling traffic, debugging, and testing. Let’s see an example of how to populate this map. We start with the map definition:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">cgroups_map</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">.</code><code class="n">type</code> <code class="o">=</code> <code class="n">BPF_MAP_TYPE_CGROUP_ARRAY</code><code class="p">,</code>
  <code class="p">.</code><code class="n">key_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">uint32_t</code><code class="p">),</code>
  <code class="p">.</code><code class="n">value_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">uint32_t</code><code class="p">),</code>
  <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>We can retrieve a cgroup’s file descriptor by opening the file containing its information.<a data-type="indexterm" data-primary="file descriptors" data-secondary="retrieving for cgroups" id="idm46623558814040"/> We’re going to open the cgroup that controls the base CPU shares for Docker containers and store that cgroup in our map:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">cgroup_fd</code><code class="p">,</code> <code class="n">key</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="n">cgroup_fd</code> <code class="o">=</code> <code class="n">open</code><code class="p">(</code><code class="s">"/sys/fs/cgroup/cpu/docker/cpu.shares"</code><code class="p">,</code> <code class="n">O_RDONLY</code><code class="p">);</code>

<code class="n">bpf_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">cgroups_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">cgroup_fd</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="LRU Hash and Per-CPU Hash Maps"><div class="sect2" id="idm46623558852952">
<h2>LRU Hash and Per-CPU Hash Maps</h2>

<p>These two types of map are hash-table maps, like the ones you saw earlier, but they also implement an internal LRU cache.<a data-type="indexterm" data-primary="LRU (least recently used) hash and per-cpu hash maps" id="idm46623558825224"/> LRU stands for least recently used, which means that if the map is full, these maps will erase elements that are not used frequently to make room for new elements in the map. Therefore, you can use these maps to insert elements beyond the maximum limit, as long as you don’t mind loosing elements that have not been used recently.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_LRU_HASH type" id="idm46623558823976"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_LRU_PERCPU_HASH type" id="idm46623558823336"/> They are defined with the types <code>BPF_MAP_TYPE_LRU_HASH</code> and <code>BPF_MAP_TYPE_LRU_PERCPU_HASH</code>.</p>

<p>The <code>per cpu</code> version of this map is slightly different than the other <code>per cpu</code> maps you saw earlier.<a data-type="indexterm" data-primary="CPUs" data-secondary="LRU per-cpu hash maps" id="idm46623558820456"/> This map keeps only one hash table to store all the elements in the map, and it uses different LRU caches per CPU, that way, it ensures that the most used elements in each CPU remain in the map.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="LPM Trie Maps"><div class="sect2" id="idm46623558791000">
<h2>LPM Trie Maps</h2>

<p>LPM trie maps are types of map that use longest prefix match (LPM) to look up elements in the map.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="LPM trie map" id="idm46623558789192"/><a data-type="indexterm" data-primary="LPM (longest prefix match) trie maps" id="idm46623558787944"/> LPM is an algorithm that selects the element in a tree that matches with the longest lookup key from any other match in the tree. This algorithm is used in routers and other devices that keep traffic forwarding tables to match IP addresses with specific routes. These maps are defined with the type <code>BPF_MAP_TYPE_LPM_TRIE</code>.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_LPM_TRIE type" id="idm46623558786376"/></p>

<p>These maps require their key sizes to be multiples of eight and in a range from 8 to 2,048. If you don’t want to implement your own key, the kernel provides a struct that you can use for these keys called <code>bpf_lpm_trie_key</code>.<a data-type="indexterm" data-primary="bpf_lpm_trie_key struct" id="idm46623558784600"/></p>

<p>In this next example, we add two forwarding routes to the map and try to match an IP address to the correct route. First we need to create the map:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">routing_map</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">.</code><code class="n">type</code> <code class="o">=</code> <code class="n">BPF_MAP_TYPE_LPM_TRIE</code><code class="p">,</code>
  <code class="p">.</code><code class="n">key_size</code> <code class="o">=</code> <code class="mi">8</code><code class="p">,</code>
  <code class="p">.</code><code class="n">value_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">uint64_t</code><code class="p">),</code>
  <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">10000</code><code class="p">,</code>
  <code class="p">.</code><code class="n">map_flags</code> <code class="o">=</code> <code class="n">BPF_F_NO_PREALLOC</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>We’re going to populate this map with three forwarding routes: <code>192.168.0.0/16</code>, <code>192.168.0.0/24</code>, and <code>192.168.1.0/24</code>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">uint64_t</code> <code class="n">value_1</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="k">struct</code> <code class="n">bpf_lpm_trie_key</code> <code class="n">route_1</code> <code class="o">=</code> <code class="p">{.</code><code class="n">data</code> <code class="o">=</code> <code class="p">{</code><code class="mi">192</code><code class="p">,</code> <code class="mi">168</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">},</code> <code class="p">.</code><code class="n">prefixlen</code> <code class="o">=</code> <code class="mi">16</code><code class="p">};</code>
<code class="kt">uint64_t</code> <code class="n">value_2</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="k">struct</code> <code class="n">bpf_lpm_trie_key</code> <code class="n">route_2</code> <code class="o">=</code> <code class="p">{.</code><code class="n">data</code> <code class="o">=</code> <code class="p">{</code><code class="mi">192</code><code class="p">,</code> <code class="mi">168</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">},</code> <code class="p">.</code><code class="n">prefixlen</code> <code class="o">=</code> <code class="mi">24</code><code class="p">};</code>
<code class="kt">uint64_t</code> <code class="n">value_3</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="k">struct</code> <code class="n">bpf_lpm_trie_key</code> <code class="n">route_3</code> <code class="o">=</code> <code class="p">{.</code><code class="n">data</code> <code class="o">=</code> <code class="p">{</code><code class="mi">192</code><code class="p">,</code> <code class="mi">168</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">},</code> <code class="p">.</code><code class="n">prefixlen</code> <code class="o">=</code> <code class="mi">24</code><code class="p">};</code>

<code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">routing_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">route_1</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value_1</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code>
<code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">routing_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">route_2</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value_2</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code>
<code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">routing_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">route_3</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value_3</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code></pre>

<p>Now, we use the same key structure to look up the correct match for the IP <code>192.168.1.1/32</code>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">uint64_t</code> <code class="n">result</code><code class="p">;</code>
<code class="k">struct</code> <code class="n">bpf_lpm_trie_key</code> <code class="n">lookup</code> <code class="o">=</code> <code class="p">{.</code><code class="n">data</code> <code class="o">=</code> <code class="p">{</code><code class="mi">192</code><code class="p">,</code> <code class="mi">168</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">},</code> <code class="p">.</code><code class="n">prefixlen</code> <code class="o">=</code> <code class="mi">32</code><code class="p">};</code>

<code class="kt">int</code> <code class="n">ret</code> <code class="o">=</code> <code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">routing_map</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">lookup</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">result</code><code class="p">);</code>
<code class="k">if</code> <code class="p">(</code><code class="n">ret</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Value read from the map: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">result</code><code class="p">);</code></pre>

<p>In this example, both <code>192.168.0.0/24</code> and <code>192.168.1.0/24</code> could match the lookup IP because it’s within both ranges. However, because this map uses the LPM algorithm, the result will be populated with the value for the key <code>192.168.1.0/24</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Array of Maps and Hash of Maps"><div class="sect2" id="idm46623558790408">
<h2>Array of Maps and Hash of Maps</h2>

<p><code>BPF_MAP_TYPE_ARRAY_OF_MAPS</code> and <code>BPF_MAP_TYPE_HASH_OF_MAPS</code> are two types of maps that store references to other maps. <a data-type="indexterm" data-primary="BPF_MAP_TYPE_HASH_OF_MAPS type" id="idm46623558510472"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_ARRAY_OF_MAPS type" id="idm46623558509944"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="array of maps and hash of maps" id="idm46623558509304"/><a data-type="indexterm" data-primary="array of maps" id="idm46623558508120"/><a data-type="indexterm" data-primary="hash of maps" id="idm46623558507448"/>They support only one level of indirection, so you cannot use them to store maps of maps of maps, and so on. This ensures that you don’t consume all of the memory by accidentally storing infinite chained maps.</p>

<p>These types of maps are useful when you want to be able to replace entire maps at runtime. You can create full-state snapshots if all of your maps are children of a global map. The kernel ensures that any update operation in the parent map waits until all the references to old children maps are dropped before completing the operation.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Device Map Maps"><div class="sect2" id="idm46623558505432">
<h2>Device Map Maps</h2>

<p>This specialized type of map stores references to network devices.<a data-type="indexterm" data-primary="device map maps" id="idm46623558503880"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="device map maps" id="idm46623558503176"/> These maps are defined with the type <code>BPF_MAP_TYPE_DEVMAP</code>.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_DEVMAP type" id="idm46623558501448"/> They are useful for network applications that want to manipulate traffic at the kernel level.<a data-type="indexterm" data-primary="bpf_redirect_map function" id="idm46623558500456"/> You can build a virtual map of ports that point to specific network devices and then redirect packets by using the helper <code>bpf_redirect_map</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="CPU Map Maps"><div class="sect2" id="idm46623558498984">
<h2>CPU Map Maps</h2>

<p><code>BPF_MAP_TYPE_CPUMAP</code> is another type of map that allows you to forward network traffic.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_CPUMAP type" id="idm46623558497336"/><a data-type="indexterm" data-primary="cpu map maps" id="idm46623558496664"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="cpu map maps" id="idm46623558495992"/> In this case, the map stores references to different CPUs in your host. Like the previous type of map, you can use it with the <code>bpf_redirect_map</code> helper to redirect packets. However, this map sends packets to a different CPU. This allows you to assign specific CPUs to network stacks for scalability and isolation purposes.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Open Socket Maps"><div class="sect2" id="idm46623558493672">
<h2>Open Socket Maps</h2>

<p><code>BPF_MAP_TYPE_XSKMAP</code> is a type of map that stores references to open sockets. Like the previous maps, these maps are useful for forwarding packets, between sockets in this case.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_XSKMAP type" id="idm46623558491880"/><a data-type="indexterm" data-primary="open socket maps" id="idm46623558491160"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="open socket maps" id="idm46623558490488"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Socket Array and Hash Maps"><div class="sect2" id="idm46623558489016">
<h2>Socket Array and Hash Maps</h2>

<p><code>BPF_MAP_TYPE_SOCKMAP</code> and <code>BPF_MAP_TYPE_SOCKHASH</code> are two specialized maps that store references to open sockets in the kernel. <a data-type="indexterm" data-primary="BPF_MAP_TYPE_SOCKHASH type" id="idm46623558486792"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_SOCKMAP type" id="idm46623558486072"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="socket array and hash maps" id="idm46623558485384"/><a data-type="indexterm" data-primary="socket array maps" id="idm46623558484152"/><a data-type="indexterm" data-primary="socket hash maps" id="idm46623558483480"/>Like the previous maps, this type of maps is used in conjunction with the helper <code>bpf_redirect_map</code> to forward socket buffers from the current XDP program to a different socket.</p>

<p>Their main difference is that one of them uses an array to store the sockets and the other one uses a hash table. The advantage of using a hash table is that you can access a socket directly by its key without the need to traverse the full map to find it. Each socket in the kernel is identified by a five-tuple key. These five tuples include the necessary information to establish bidirectional network connections. You can use this key as the lookup key in your map when you use the hash-table version of this map.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Cgroup Storage and Per-CPU Storage Maps"><div class="sect2" id="idm46623558481032">
<h2>Cgroup Storage and Per-CPU Storage Maps</h2>

<p>These two types of maps were introduced to help developers work with BPF programs attached to cgroups.<a data-type="indexterm" data-primary="cgroup storage maps" id="idm46623558479160"/><a data-type="indexterm" data-primary="per-cpu cgroup storage maps" id="idm46623558478456"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="cgroup storage and per-cpu cgroup storage maps" id="idm46623558477816"/> As you saw in <a data-type="xref" href="ch02.html#running_your_first_BPF_programs">Chapter 2</a>, you can attach and detach BPF programs from control groups and isolate their runtime to specific cgroups with <code>BPF_PROG_TYPE_CGROUP_SKB</code>. These two maps are defined with the types <code>BPF_MAP_TYPE_CGROUP_STORAGE</code> and <code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code>.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_PERCPU_CGROUP_ STORAGE type" id="idm46623558474248"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_CGROUP_STORAGE type" id="idm46623558473448"/></p>

<p>These types of maps are similar to hash-table maps from the developer point of view. The kernel provides a structure helper to generate keys for this map, <code>bpf_cgroup_storage_key</code>, which includes information about the cgroup node identifier and the attachment type. You can add any value you want to this map; its access will be restricted to the BPF program inside the attached cgroup.</p>

<p>There are two limitations with these maps. The first is that you cannot create new elements in the map from user-space.<a data-type="indexterm" data-primary="user-space" data-secondary="limitations of cgroup storage and per-cpu cgroup storage maps in" id="idm46623558470872"/> The BPF program in the kernel can create elements with <code>bpf_map_update_elem</code>, but if you use this method from user-space and the key doesn’t exist already, <code>bpf_map_update_elem</code> will fail, and <code>errno</code> will be set to <code>ENOENT</code>. The second limitation is that you cannot remove elements from this map. <code>bpf_map_delete_elem</code> always fails and sets <code>errno</code> to <code>EINVAL</code>.</p>

<p>The main difference between these two types of maps, as you saw with other similar maps earlier, is that <code>BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE</code> keeps a different hash table per CPU.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Reuseport Socket Maps"><div class="sect2" id="idm46623558381016">
<h2>Reuseport Socket Maps</h2>

<p>This specialized type of map stores references to sockets that can be reused by an open port in the system.<a data-type="indexterm" data-primary="reuseport socket maps" id="idm46623558379560"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="reuseport socket maps" id="idm46623558378856"/> They are defined with the type <code>BPF_MAP_TYPE_REUSEPORT_SOCKARRAY</code>.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_REUSEPORT_SOCKARRAY type" id="idm46623558377032"/> These maps are mainly used with <code>BPF_PROG_TYPE_SK_REUSEPORT</code> program types. Combined, they give you control to decide how to filter and serve incoming packets from the network device. For example, you can decide which packets go to which socket, even though both sockets are attached to the same port.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Queue Maps"><div class="sect2" id="idm46623558375240">
<h2>Queue Maps</h2>

<p>Queue maps use a first-in, first-out (FIFO) storage to keep the elements in the map.<a data-type="indexterm" data-primary="queue maps" id="idm46623558373608"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="queue maps" id="idm46623558372904"/> They are defined with the type <code>BPF_MAP_TYPE_QUEUE</code>.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_QUEUE type" id="idm46623558371128"/><a data-type="indexterm" data-primary="FIFO" data-secondary="in queue maps" id="idm46623558370392"/> FIFO means that when you fetch an element from the map, the result is going to be the element that has been in the map for the longest time.</p>

<p>The <code>bpf</code> map helpers work in a predictable way for this data structure. When you use <code>bpf_map_lookup_elem</code>, this map always looks for the oldest element in the map. When you use <code>bpf_map_update_elem</code>, this map always appends the element to the end of the queue, so you’ll need to read the rest elements in the map before being able to fetch this element. You can also use the helper <code>bpf_map_lookup_and_delete</code> to fetch the older element and remove it from the map in an atomic way. This map doesn’t support the helpers <code>bpf_map_delete_elem</code> and <code>bpf_map_get_next_key</code>. If you try to use them, they will fail and set the <code>errno</code> variable to <code>EINVAL</code> as a result.</p>

<p>Something else that you need to keep in mind about these types of map is that they don’t use the map keys for lookups, and the key size must always be 0 when you initialize these maps. When you push elements to these maps, the key must be a null value.</p>

<p>Let’s see an example of how to use this type of map:</p>

<pre data-type="programlisting" data-code-language="c"> <code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">queue_map</code> <code class="o">=</code> <code class="p">{</code>
   <code class="p">.</code><code class="n">type</code> <code class="o">=</code> <code class="n">BPF_MAP_TYPE_QUEUE</code><code class="p">,</code>
   <code class="p">.</code><code class="n">key_size</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
   <code class="p">.</code><code class="n">value_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
   <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">100</code><code class="p">,</code>
   <code class="p">.</code><code class="n">map_flags</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
 <code class="p">};</code></pre>

<p>Let’s insert several elements in this map and retrieve<a data-type="indexterm" data-primary="bpf_map_lookup_and_delete function" id="idm46623558336488"/><a data-type="indexterm" data-primary="bpf_map_update_elem function" data-secondary="using with queue maps" id="idm46623558321704"/> them in the same order in which we inserted them:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">i</code><code class="p">;</code>
<code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code><code class="p">)</code>
  <code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">queue_map</code><code class="p">,</code> <code class="nb">NULL</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">i</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code>

<code class="kt">int</code> <code class="n">value</code><code class="p">;</code>
<code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">bpf_map_lookup_and_delete</code><code class="p">(</code><code class="o">&amp;</code><code class="n">queue_map</code><code class="p">,</code> <code class="nb">NULL</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Value read from the map: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">value</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This program prints the following:</p>

<pre data-type="programlisting" data-code-language="bash">Value <code class="nb">read </code>from the map: <code class="s1">'0'</code>
Value <code class="nb">read </code>from the map: <code class="s1">'1'</code>
Value <code class="nb">read </code>from the map: <code class="s1">'2'</code>
Value <code class="nb">read </code>from the map: <code class="s1">'3'</code>
Value <code class="nb">read </code>from the map: <code class="s1">'4'</code></pre>

<p>If we try to pop a new element from the map, <code>bpf_map_lookup_and_delete</code> will return a negative number, and the <code>errno</code> variable will be set to <code>ENOENT</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Stack Maps"><div class="sect2" id="idm46623558374648">
<h2>Stack Maps</h2>

<p>Stack maps use a last-in, first-out (LIFO) storage to keep the elements in the map. They are defined with the type <code>BPF_MAP_TYPE_STACK</code>.<a data-type="indexterm" data-primary="stack maps" id="idm46623558165512"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-tertiary="stack maps" id="idm46623558164776"/> LIFO means that when you fetch an element from the map, the result is going to be the element that was added to the map most recently.<a data-type="indexterm" data-primary="BPF_MAP_TYPE_STACK type" id="idm46623558163288"/></p>

<p>The <code>bpf</code> map helpers also work in a predictable way for this data structure. When you use <code>bpf_map_lookup_elem</code>, this map always looks for the newest element in the map. When you use <code>bpf_map_update_elem</code>, this map always appends the element to the top of the stack, so it’s the first one to fetch. You can also use the helper <code>bpf_map_lookup_and_delete</code> to fetch the newest element and remove it from the map in an atomic way. This map doesn’t support the helpers <code>bpf_map_delete_elem</code> and <code>bpf_map_get_next_key</code>. If you try to use them, they will always fail and set the <code>errno</code> variable to <code>EINVAL</code> as a result.</p>

<p>Let’s see an example of how to use this map:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">struct</code> <code class="n">bpf_map_def</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"maps"</code><code class="p">)</code> <code class="n">stack_map</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">.</code><code class="n">type</code> <code class="o">=</code> <code class="n">BPF_MAP_TYPE_STACK</code><code class="p">,</code>
  <code class="p">.</code><code class="n">key_size</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
  <code class="p">.</code><code class="n">value_size</code> <code class="o">=</code> <code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">),</code>
  <code class="p">.</code><code class="n">max_entries</code> <code class="o">=</code> <code class="mi">100</code><code class="p">,</code>
  <code class="p">.</code><code class="n">map_flags</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>Let’s insert several elements in this map and retrieve them in the same order in which we<a data-type="indexterm" data-primary="bpf_map_lookup_and_delete function" data-secondary="using with stack maps" id="idm46623558066264"/><a data-type="indexterm" data-primary="bpf_map_update_elem function" data-secondary="using with stack maps" id="idm46623558106808"/> inserted them:</p>

<pre data-type="programlisting" data-code-language="c"><code class="kt">int</code> <code class="n">i</code><code class="p">;</code>
<code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code><code class="p">)</code>
  <code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">stack_map</code><code class="p">,</code> <code class="nb">NULL</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">i</code><code class="p">,</code> <code class="n">BPF_ANY</code><code class="p">);</code>

<code class="kt">int</code> <code class="n">value</code><code class="p">;</code>
<code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="n">i</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">;</code> <code class="n">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="n">bpf_map_lookup_and_delete</code><code class="p">(</code><code class="o">&amp;</code><code class="n">stack_map</code><code class="p">,</code> <code class="nb">NULL</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">);</code>
  <code class="n">printf</code><code class="p">(</code><code class="s">"Value read from the map: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">value</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>This program prints the following:</p>
<pre>Value read from the map: '4'
Value read from the map: '3'
Value read from the map: '2'
Value read from the map: '1'
Value read from the map: '0'</pre>

<p>If we try to pop a new element from the map, <code>bpf_map_lookup_and_delete</code> will return a negative number, and the <code>errno</code> variable will be set to <code>ENOENT</code>.</p>

<p>These are all the map types that you can use in a BPF program. You’ll find some of them more useful than others; it will depend on the kind of program that you’re writing. We’ll see more usage examples throughout the book that will help you cement the fundamentals that you just saw.</p>

<p>As we mentioned earlier, BPF maps are stored as regular files in your operating system. We have not talked about the specific characteristics of the filesystem that the kernel uses to save maps and programs. The next section guides you through the BPF filesystem, and the type of persistence that you can expect from it.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="types of" data-startref="ix_mpstyp" id="idm46623558002056"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="The BPF Virtual Filesystem"><div class="sect1" id="idm46623559589240">
<h1>The BPF Virtual Filesystem</h1>

<p>A fundamental characteristic of BPF maps is that being based on file descriptors means that when a descriptor is closed, the map and all the information it holds disappear.<a data-type="indexterm" data-primary="filesystems" data-secondary="BPF virtual filesystem" id="ix_fsBPF"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="persisting in BPF virtual filesystem" id="ix_mpsstor"/><a data-type="indexterm" data-primary="file descriptors" data-secondary="closing, maps and" id="idm46623557997160"/> The original implementation of BPF maps was focused on short-lived isolated programs that didn’t share any information among one another. Erasing all data when the file descriptor was closed made a lot of sense in those scenarios. However, with the introduction of more complex maps and integrations within the kernel, its developers realized that they needed a way to save the information that maps held, even after a program terminated and closed the map’s file descriptor.<a data-type="indexterm" data-primary="programs (BPF)" data-secondary="persisting in virtual filesystem" id="idm46623557995592"/> Version 4.4 of the Linux kernel introduced two new syscalls to allow pinning and fetching maps and BPF programs from a virtual filesystem. Maps and BPF programs pinned to this filesystem will remain in memory after the program that created them terminates. In this section we explain how to work with this virtual filesystem.</p>

<p>The default directory where BPF expects to find this virtual filesystem is <em>/sys/fs/bpf</em>.<a data-type="indexterm" data-primary="/sys/fs/bpf_  directory" data-primary-sortas="sys/fs/bpf" id="idm46623557993368"/> Some Linux distributions don’t mount this filesystem by default because they don’t assume that the kernel supports BPF. <a data-type="indexterm" data-primary="mount command, mounting BPF virtual filesystem" id="idm46623557992088"/>You can mount it yourself by using the <code>mount</code> command:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c"># mount -t bpf /sys/fs/bpf /sys/fs/bpf</code></pre>

<p>Like any other file hierarchy, persistent BPF objects in the filesystem are identified by paths.<a data-type="indexterm" data-primary="paths" data-secondary="persistent BPF objects in filesystem" id="idm46623557938504"/> You can organize these paths in any way that makes sense for your programs. For example, if you want to share a specific map with IP information between programs, you might want to store it in <em>/sys/fs/bpf/shared/ips</em>. <a data-type="indexterm" data-primary="/sys/fs/bpf/shared/ips_ directory" data-primary-sortas="sys/fs/bpf/shared" id="idm46623557988584"/>As we mentioned earlier, there are two types of objects that you can save in this filesystem: BPF maps and full BPF programs. Both of these are identified by file descriptors, so the interface to work with them is the same. These objects can be manipulated only by the <code>bpf</code> syscall.<a data-type="indexterm" data-primary="bpf system calls" data-secondary="manipulating persisten BPF objects in filesystem" id="idm46623557986904"/> Although the kernel provides high-level helpers to assist you in interacting with them, you cannot do things like trying to open these files with the <code>open</code> syscall.</p>

<p><code>BPF_PIN_FD</code> is the command to save BPF objects in this filesystem.<a data-type="indexterm" data-primary="BPF_PIN_FD command" id="idm46623557947208"/> When the command succeeds, the object will be visible in the filesystem in the path that you specified. If the command fails, it returns a negative number, and the global <code>errno</code> variable is set with the error code.</p>

<p><code>BPF_OBJ_GET</code> is the command to fetch BPF objects that have been pinned to the filesystem.<a data-type="indexterm" data-primary="BPF_OBJ_GET command" id="idm46623557945096"/> This command uses the path you assigned the object to to load it. When this command succeeds, it returns the file descriptor identifier associated to the object. If it fails, it returns a negative number, and the global <code>errno</code> variable is set with the specific error code.</p>

<p>Let’s see an example of how to take advantage of these two commands in different programs using the helper functions that the kernel provides.</p>

<p>First, we’re going to write a program that creates a map, populates it with several elements, and saves it in the filesystem:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">static</code><code> </code><code class="k">const</code><code> </code><code class="kt">char</code><code> </code><code class="o">*</code><code> </code><code class="n">file_path</code><code> </code><code class="o">=</code><code> </code><code class="s">"</code><code class="s">/sys/fs/bpf/my_array</code><code class="s">"</code><code class="p">;</code><code>
</code><code>
</code><code class="kt">int</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="kt">int</code><code> </code><code class="n">argc</code><code class="p">,</code><code> </code><code class="kt">char</code><code> </code><code class="o">*</code><code class="o">*</code><code class="n">argv</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>  </code><code class="kt">int</code><code> </code><code class="n">key</code><code class="p">,</code><code> </code><code class="n">value</code><code class="p">,</code><code> </code><code class="n">fd</code><code class="p">,</code><code> </code><code class="n">added</code><code class="p">,</code><code> </code><code class="n">pinned</code><code class="p">;</code><code>
</code><code>
</code><code>  </code><code class="n">fd</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_create_map</code><code class="p">(</code><code class="n">BPF_MAP_TYPE_ARRAY</code><code class="p">,</code><code> </code><code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="p">,</code><code> </code><code class="k">sizeof</code><code class="p">(</code><code class="kt">int</code><code class="p">)</code><code class="p">,</code><code> </code><code class="mi">100</code><code class="p">,</code><code> </code><code class="mi">0</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" id="co_bpf_maps_CO1-1" href="#callout_bpf_maps_CO1-1"><img src="assets/1.png" alt="1"/></a><code>
  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="n">fd</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">0</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>    </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">Failed to create map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code> </code><code class="n">fd</code><code class="p">,</code><code> </code><code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="o">-</code><code class="mi">1</code><code class="p">;</code><code>
</code><code>  </code><code class="p">}</code><code>
</code><code>
</code><code>  </code><code class="n">key</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">,</code><code> </code><code class="n">value</code><code> </code><code class="o">=</code><code> </code><code class="mi">1234</code><code class="p">;</code><code>
</code><code>  </code><code class="n">added</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_map_update_elem</code><code class="p">(</code><code class="n">fd</code><code class="p">,</code><code> </code><code class="o">&amp;</code><code class="n">key</code><code class="p">,</code><code> </code><code class="o">&amp;</code><code class="n">value</code><code class="p">,</code><code> </code><code class="n">BPF_ANY</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="n">added</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">0</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>    </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">Failed to update map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code> </code><code class="n">added</code><code class="p">,</code><code> </code><code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="o">-</code><code class="mi">1</code><code class="p">;</code><code>
</code><code>  </code><code class="p">}</code><code>
</code><code>
</code><code>  </code><code class="n">pinned</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_obj_pin</code><code class="p">(</code><code class="n">fd</code><code class="p">,</code><code> </code><code class="n">file_path</code><code class="p">)</code><code class="p">;</code><code>
</code><code>  </code><code class="k">if</code><code> </code><code class="p">(</code><code class="n">pinned</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">0</code><code class="p">)</code><code> </code><code class="p">{</code><code>
</code><code>    </code><code class="n">printf</code><code class="p">(</code><code class="s">"</code><code class="s">Failed to pin map to the file system: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code>
</code><code>        </code><code class="n">pinned</code><code class="p">,</code><code> </code><code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>
</code><code>    </code><code class="k">return</code><code> </code><code class="o">-</code><code class="mi">1</code><code class="p">;</code><code>
</code><code>  </code><code class="p">}</code><code>
</code><code>
</code><code>  </code><code class="k">return</code><code> </code><code class="mi">0</code><code class="p">;</code><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_bpf_maps_CO1-1" href="#co_bpf_maps_CO1-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>This section of code should already look familiar to you from our previous examples. First, we create a hash-table map with a fixed size of one element. Then we update the map to add only that element. If we tried to add more elements, <code>bpf_map_update_elem</code> would fail because we would be overflowing the map.</p></dd>
</dl>

<p>We use the helper function <code>pbf_obj_pin</code> to save the map in the filesystem. You can actually check that you have a new file under that path in your machine after the program has terminated:</p>
<pre>ls -la /sys/fs/bpf
total 0
drwxrwxrwt 2 root  root  0 Nov 24 13:56 .
drwxr-xr-x 9 root  root  0 Nov 24 09:29 ..
-rw------- 1 david david 0 Nov 24 13:56 my_map</pre>

<p>Now we can write a similar program that loads that map from the file system and prints the elements we inserted. That way we can verify that we saved the map <span class="keep-together">correctly</span>:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">static</code> <code class="k">const</code> <code class="kt">char</code> <code class="o">*</code> <code class="n">file_path</code> <code class="o">=</code> <code class="s">"/sys/fs/bpf/my_array"</code><code class="p">;</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">(</code><code class="kt">int</code> <code class="n">argc</code><code class="p">,</code> <code class="kt">char</code> <code class="o">**</code><code class="n">argv</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">int</code> <code class="n">fd</code><code class="p">,</code> <code class="n">key</code><code class="p">,</code> <code class="n">value</code><code class="p">,</code> <code class="n">result</code><code class="p">;</code>

  <code class="n">fd</code> <code class="o">=</code> <code class="n">bpf_obj_get</code><code class="p">(</code><code class="n">file_path</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">fd</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"Failed to fetch the map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">fd</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code>
    <code class="k">return</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="n">key</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
  <code class="n">result</code> <code class="o">=</code> <code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="n">fd</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">key</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">value</code><code class="p">);</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">result</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"Failed to read value from the map: %d (%s)</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code>
        <code class="n">result</code><code class="p">,</code> <code class="n">strerror</code><code class="p">(</code><code class="n">errno</code><code class="p">));</code>
    <code class="k">return</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="n">printf</code><code class="p">(</code><code class="s">"Value read from the map: '%d'</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="n">value</code><code class="p">);</code>
  <code class="k">return</code> <code class="mi">0</code><code class="p">;</code></pre>

<p>Being able to save BPF objects in the filesystem opens the door to more interesting applications. Your data and programs are no longer tied to a single execution thread. Information can be shared by different applications, and BPF programs can run even after the application that created them terminates. This gives them an extra level or availability that would have not been possible without the BPF filesystem.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="persisting in BPF virtual filesystem" data-startref="ix_mpsstor" id="idm46623557268424"/><a data-type="indexterm" data-primary="filesystems" data-secondary="BPF virtual filesystem" data-startref="ix_fsBPF" id="idm46623557267240"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46623558000664">
<h1>Conclusion</h1>

<p>Establishing communication channels between the kernel and user-space is fundamental to take full advantage of any BPF program. In this chapter you learned how to create BPF maps to establish that communication and how to work with them. We’ve also described the types of maps that you can use in your programs. As you progress in the book, you’ll see more specific map examples. Finally, you learned how to pin entire maps to the system to make them and the information they hold durable to crashes and interruptions.</p>

<p>BPF maps are the central bus of communication between the kernel and user-space. In this chapter, we established the fundamental concepts that you need to know to understand them. In the next chapter we make more extensive use of these data structures to share data. We also introduce you to additional tools that will make working with BPF maps more efficient.<a data-type="indexterm" data-primary="maps (BPF)" data-startref="ix_mps" id="idm46623557640248"/></p>

<p>In the next chapter you’ll see how BPF programs and maps work together to give you tracing capabilities on your systems from the kernel point of view. We explore different ways to attach programs to different entry points in the kernel. Finally, we cover how to represent multiple data points in a way that makes your applications easier to debug and observe.</p>
</div></section>







</div></section></body></html>