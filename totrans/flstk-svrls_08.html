<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. AWS AppSync In-Depth"><div class="chapter" id="ch8">
<h1><span class="label">Chapter 8. </span>AWS AppSync In-Depth</h1>


<p><a data-type="indexterm" data-primary="GraphQL" data-secondary="about" id="idm45364346939704"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="about" id="idm45364346938728"/>In <a data-type="xref" href="ch03.xhtml#ch3">Chapter 3</a>, we learned about GraphQL and created a basic GraphQL API. In this chapter, we’ll expand upon these concepts to create a music festival app using <a href="https://github.com/dabit3/full-stack-serverless-code/tree/master/appsync-in-depth">AWS AppSync</a>, from this book’s GitHub repo.</p>

<p>This app will require the following:</p>

<ul>
<li>
<p>Amazon DynamoDB tables will be used for shows and stages.</p>
</li>
<li>
<p>GraphQL API will be used for creating, reading, updating, deleting, and listing shows and stages.</p>
</li>
<li>
<p>Only admins should be able to create, update, or delete a show or a stage.</p>
</li>
<li>
<p>All users should be able to view shows and stages.</p>
</li>
<li>
<p>Relationships should be enabled between shows and stages.</p>
</li>
<li>
<p>Users should be able to view all shows as well as navigate to view show details.</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="Building Skills for GraphQL, AppSync API, and React Router"><div class="sect1" id="idm45364346929432">
<h1>Building Skills for GraphQL, AppSync API, and <span class="keep-together">React Router</span></h1>

<p>In this section, we’ll cover how to model relationships between GraphQL types, how to implement authorization rules on GraphQL types and fields, how to enable multiple authorization modes for an AppSync API, and how to enable route parameters using React Router.</p>

<p class="less_space pagebreak-before">First we’ll briefly cover each of these topics, and when we start building out the app, we will get into them in greater depth.</p>








<section data-type="sect2" data-pdf-bookmark="Relationships Between GraphQL Types"><div class="sect2" id="idm45364346926120">
<h2>Relationships Between GraphQL Types</h2>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="relationships between GraphQL types" id="idm45364346924776"/><a data-type="indexterm" data-primary="GraphQL" data-secondary="types" id="idm45364346923736"/>When creating a GraphQL API, or any API, modeling relationships between data becomes very important to understand. For example, the app that we are building will have the following two types:</p>
<dl>
<dt>Stage</dt>
<dd>
<p><a data-type="indexterm" data-primary="Stage type" id="idm45364346921016"/>This type will hold the stage information for individual performances, including the stage name and stage ID. Each stage will have a number of performances that are associated with it.</p>
</dd>
<dt>Performance</dt>
<dd>
<p><a data-type="indexterm" data-primary="Performance type" id="idm45364346918824"/>This type will hold the individual performance information, including the performer, the description, the stage of the performance, and the time of the <span class="keep-together">performance.</span></p>
</dd>
</dl>

<p>For this type of API, ideally you would want to have at least the following access <span class="keep-together">patterns:</span></p>

<ul>
<li>
<p>Query for a single stage and performances for the stage</p>
</li>
<li>
<p>Query for all stages and performances for each stage</p>
</li>
<li>
<p>Query for an individual performance and the corresponding stage info</p>
</li>
<li>
<p>Query for all performances and the corresponding stage info</p>
</li>
</ul>

<p>The question is now usually this: how can you enable these different relationships and access patterns? And in our case, how can we do this using a NoSQL database like DynamoDB? There are two ways to accomplish this<a data-type="indexterm" data-primary="primary key" id="idm45364346911128"/>:</p>

<ul>
<li>
<p>Pattern your data in DynamoDB in a way that enables all of these access patterns to be performed using a single table by taking advantage of a combination of primary keys, sort keys, and local secondary indexes. For this to work with AppSync, we would have to write and maintain all of the resolver logic by hand and from scratch.</p>
</li>
<li>
<p>Enable these relationships directly at the resolver level. Because we are using GraphQL, and GraphQL enables per-field resolvers, this can be done. To understand this better let’s take a look at one of the types we will be working with.</p>
</li>
</ul>










<section data-type="sect3" class="less_space pagebreak-before" data-pdf-bookmark="Stage type in GraphQL"><div class="sect3" id="idm45364346907384">
<h3>Stage type in GraphQL</h3>

<p>To better understand these concepts, let’s take a look at one of the types we will be working with:</p>

<pre data-type="programlisting">type Stage {
  id: ID!
  name: String!
  performances: [Performance]
}</pre>

<p>When creating a resolver, or resolvers, for this type, here is an example chain of actions that you could assume would happen when a request is made for stages and corresponding performances:</p>
<ol>
<li>
<p>The main <code>Stage</code> GraphQL resolver will use the stage ID to retrieve the stage information from the Stage table in the database.</p>
</li>
<li>
<p>The field of <code>performances</code> on the <code>Stage</code> type will have its own GraphQL resolver. This resolver should use the stage ID to retrieve the related performances by querying the database using a GSI, returning only the performances for that <em>stage</em> ID.</p>
</li>

</ol>
</div></section>













<section data-type="sect3" data-pdf-bookmark="GraphQL Transform: @connection"><div class="sect3" id="idm45364346899592">
<h3>GraphQL Transform: @connection</h3>

<p><a data-type="indexterm" data-primary="Amplify GraphQL Transform library" id="idm45364346898424"/><a data-type="indexterm" data-primary="@model directive" id="idm45364346897656"/><a data-type="indexterm" data-primary="@connection directive" id="idm45364346896984"/><a data-type="indexterm" data-primary="GraphQL Transform library" id="idm45364346896312"/>In <a data-type="xref" href="ch03.xhtml#ch3">Chapter 3</a>, we used the <code>@model</code> directive of the GraphQL Transform library to scaffold out an entire backend, including resolvers, databases, and additional GraphQL schema. As a recap, the GraphQL Transform is a library of directives that allow us to “decorate” a GraphQL schema and add additional functionality.</p>

<p>Here, we’ll be introducing a couple of new directives, including <code>@connection</code>, which enables us to model these relationships and generate the necessary resolvers with only a few lines of code.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Multiple Authentication Types"><div class="sect2" id="idm45364346892648">
<h2>Multiple Authentication Types</h2>

<p><a data-type="indexterm" data-primary="GraphQL API" data-secondary="multiple authentication types" id="idm45364346891304"/><a data-type="indexterm" data-primary="authentication" data-secondary="multiple types" id="idm45364346890312"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="multiple authentication types" id="idm45364346889368"/>In <a data-type="xref" href="ch03.xhtml#ch3">Chapter 3</a>, we created a GraphQL API using the API key as the authentication type. This is fine for certain circumstances, like when you want to have a GraphQL query available to all users of your app.</p>

<p>AppSync supports four main authentication methods:</p>
<dl>
<dt>The API key</dt>
<dd>
<p>The <a data-type="indexterm" data-primary="API key authentication method" id="idm45364346885064"/>API key requires that, when making an HTTP request, you send the API key in the header in the form of <code>x-api-key</code> in some form or fashion. If you are using the Amplify client as we have done so far in this book, then this is automatically sent for you.</p>
</dd>
<dt>Amazon Cognito user pools</dt>
<dd>
<p><a data-type="indexterm" data-primary="Cognito" data-secondary="user pools authentication type" id="idm45364346882424"/><a data-type="indexterm" data-primary="Cognito user pool" id="idm45364346881384"/><a data-type="indexterm" data-primary="Amazon Cognito" data-secondary="user pools authentication type" id="idm45364346880712"/>Amazon Cognito, the managed authentication service we’ve used throughout this book, is one of the mechanisms we will be using in this chapter. Using Amazon Cognito, we can configure private and group access to the API itself and to GraphQL types and fields.</p>
</dd>
<dt>OpenID Connect</dt>
<dd>
<p><a data-type="indexterm" data-primary="Auth0" id="idm45364346878200"/><a data-type="indexterm" data-primary="OpenID Connect authentication type" id="idm45364346877496"/>OpenID Connect enables you to bring your own authentication provider, so if you prefer another authentication service like Auth0, or your company has its own authentication implementation, you can still use it to authenticate against an AppSync API.</p>
</dd>
<dt>IAM</dt>
<dd>
<p><a data-type="indexterm" data-primary="Cognito identity pools" id="idm45364346875256"/><a data-type="indexterm" data-primary="AWS Signature Version 4 signing process" id="idm45364346874552"/><a data-type="indexterm" data-primary="IAM (identity and access management)" data-secondary="authentication type" id="idm45364346873864"/>AWS IAM type enforces the AWS Signature Version 4 signing process on the GraphQL API. You can use an AWS IAM UnAuthenticated Role from Cognito identity pools for public access, allowing a more secure way to enable public access against your AppSync API versus an API key.</p>
</dd>
</dl>

<p>Here we will use a combination of the API key and Amazon Cognito to provide multiple authentication types for the API, enabling public read access and private read and write access.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Authorization"><div class="sect2" id="idm45364346871656">
<h2>Authorization</h2>

<p><a data-type="indexterm" data-primary="GraphQL API" data-secondary="authorization" id="idm45364346870280"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="authorization" id="idm45364346869304"/><a data-type="indexterm" data-primary="authorization" id="idm45364346868360"/><a data-type="indexterm" data-primary="@auth directive" id="idm45364346867688"/>Using the GraphQL Transform library, we can also define different authorization rules for the API by using the <code>@auth</code> directive.</p>

<p>Using <code>@auth</code>, we can define different types of rules, including (but not limited to) the following:</p>

<ul>
<li>
<p>Enable all users to create and read, but only the owner of the created item to update and delete.</p>
</li>
<li>
<p>Enable only users of a certain group to be able to create, update, or delete.</p>
</li>
<li>
<p>Enable all users to read, but not perform any other actions.</p>
</li>
<li>
<p>A combination of the preceding rules.</p>
</li>
</ul>

<p><a data-type="indexterm" data-primary="Cognito groups" id="idm45364346861000"/>In this instance, the app we will be building will support both private and public access, but we will need to also enable more control over these rules. We need to support the following:</p>

<ul>
<li>
<p>Authenticated users who are part of the Amazon Cognito group named Admin will be able to perform all actions: create, read, update, and delete.</p>
</li>
<li>
<p>Users who are not authenticated will have access, but will only be able to read.</p>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Custom Data Access Patterns Using GSIs"><div class="sect2" id="idm45364346857528">
<h2>Custom Data Access Patterns Using GSIs</h2>

<p><a data-type="indexterm" data-primary="data access patterns" id="idm45364346856360"/><a data-type="indexterm" data-primary="GSIs (global secondary indexes)" id="idm45364346855656"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="custom data access patterns using GSIs" id="idm45364346855016"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="custom data access patterns using GSIs" id="idm45364346854056"/>One of the most powerful things about DynamoDB is that it allows (at the time of this writing) 20 additional GSIs per table. Using either a GSI or a combination of GSI + sort key (also think of this as a filter key), you are able to create extremely flexible and powerful data access patterns for your data. The GraphQL Transform library also has a directive, <code>@key</code>, that makes it simple to configure custom index structures for <code>@model</code> types.</p>

<p>We’ll use the <code>@key</code> directive to create an access pattern that will allow us to query performances for a given stage ID by setting the stage ID as the GSI on the <code>Performance</code> table. Doing this will allow us to be able to request stages and their corresponding performances in a single GraphQL query.</p>

<p>That completes our skills overview; let’s get started building the app.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Starting to Build the App"><div class="sect1" id="idm45364346849320">
<h1>Starting to Build the App</h1>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="getting started" id="idm45364346847976"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="getting started" id="idm45364346847000"/>To get started, we’ll again be walking through the steps of creating a new React project, installing dependencies, initializing a new Amplify app, and adding features via the CLI.</p>

<p>Change into the directory where you would like the app to live, and create a new React project:</p>

<pre data-type="programlisting">~ npx create-react-app festivalapp
~ cd festivalapp</pre>

<p>Next, install the dependencies:</p>

<pre data-type="programlisting">~ npm install aws-amplify antd @aws-amplify/ui-react react-router-dom</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Creating the Amplify App and Adding the Features"><div class="sect1" id="idm45364346843256">
<h1>Creating the Amplify App and Adding the Features</h1>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="creating Amplify app" id="idm45364346841944"/><a data-type="indexterm" data-primary="Amplify" data-secondary="creating" id="idm45364346840968"/><a data-type="indexterm" data-primary="creating" data-secondary="Amplify app" id="idm45364346840024"/>Next, initialize a new Amplify project in the root of the project directory:</p>

<pre data-type="programlisting">~ amplify init

# Follow the steps to give the project a name, environment name, and set the
  default text editor.
# Accept defaults for everything else and choose your AWS Profile.</pre>

<p>Now, the Amplify project has been initialized and we can go ahead and start adding features.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Building the Backend"><div class="sect1" id="idm45364346837224">
<h1>Building the Backend</h1>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="building backend" id="aws_be"/><a data-type="indexterm" data-primary="backend" id="be_ab"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="building backend" id="gql_be"/><a data-type="indexterm" data-primary="creating" data-secondary="backend" id="cre_be"/>The first feature we will add is authentication. This app will need to have basic authentication but will also need to have the ability to add admin users dynamically via a Lambda post-confirmation trigger like we did in <a data-type="xref" href="ch06.xhtml#ch6">Chapter 6</a>. To enable this, we will create the authentication service as well as a Lambda trigger that will allow us to add a predefined set of users into an Admin group as they sign up.</p>








<section data-type="sect2" data-pdf-bookmark="Authentication"><div class="sect2" id="idm45364346829880">
<h2>Authentication</h2>

<p><a data-type="indexterm" data-primary="GraphQL API" data-secondary="authentication" id="idm45364346828536"/><a data-type="indexterm" data-primary="authentication" data-secondary="GraphQL API" id="idm45364346827560"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="authentication" id="idm45364346826616"/>To add authentication with Cognito, we’ll again use the <code>auth</code> category:</p>

<pre data-type="programlisting">~ amplify add auth

? Do you want to use the default authentication and security configuration?
  Default configuration
? How do you want users to be able to sign in? Username
? Do you want to configure advanced settings? Yes
? What attributes are required for signing up? Email
? Do you want to enable any of the following capabilities? Add User to Group
? Enter the name of the group to which users will be added. Admin
? Do you want to edit your add-to-group function now? Y</pre>

<p>Update the function with the following code and configure the <code>adminEmails</code> array:</p>

<pre data-type="programlisting">// amplify/backend/function/&lt;function_name&gt;/src/add-to-group.js

const aws = require('aws-sdk');

exports.handler = async (event, context, callback) =&gt; {
  const cognitoProvider = new
  aws.CognitoIdentityServiceProvider({
    apiVersion: '2016-04-18'
  });

  let isAdmin = false
  /* set your admin emails here */
  const adminEmails = ['user1@somedomain.com', 'user2@somedomain.com']

  // If the user is one of the admins, set the isAdmin variable to true
  if (adminEmails.indexOf(event.request.userAttributes.email) !== -1) {
    isAdmin = true
  }

  const groupParams = {
    UserPoolId: event.userPoolId,
  }

  const userParams = {
    UserPoolId: event.userPoolId,
    Username: event.userName,
  }

  if (isAdmin) {
    groupParams.GroupName = 'Admin',
    userParams.GroupName = 'Admin'

    // First check to see if the groups exists, and if not create the group
    try {
      await cognitoProvider.getGroup(groupParams).promise();
    } catch (e) {
      await cognitoProvider.createGroup(groupParams).promise();
    }

    // If the user is an administrator, place them in the Admin group
    try {
      await cognitoProvider.adminAddUserToGroup(userParams).promise();
      callback(null, event);
    } catch (e) {
      callback(e);
    }
  } else {
    // If the user is in neither group, proceed with no action
    callback(null, event)
  }
}</pre>

<p>Now, the authentication service has been set up and we can continue on to the next step: creating the AppSync API.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The AppSync API"><div class="sect2" id="idm45364346820120">
<h2>The AppSync API</h2>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="API" id="idm45364346818680"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="about" id="idm45364346817704"/>Next, we’ll create the AppSync GraphQL API. Remember that for this API, we will need to enable multiple authentication types for both public and protected access. This can all be enabled by the CLI.</p>

<p>To add the AppSync API, we’ll use the <code>api</code> category:</p>

<pre data-type="programlisting">~ amplify add api

? Please select from one of the below mentioned services: GraphQL
? Provide API name: festivalapi
? Choose an authorization type for the API: Amazon Cognito User Pool
Do you want to configure advanced settings for the GraphQL API: Yes
? Configure additional auth types? Y
? Choose the additional authorization types you want to configure for the API:
  API key
? Enter a description for the API key: public (or a custom description)
? After how many days from now the API key should expire: 365 (or a custom
  expiration date)
? Configure conflict detection? N
? Do you have an annotated GraphQL schema? N
? Do you want a guided schema creation? Y
? What best describes your project: Single object with fields
? Do you want to edit the schema now? Y</pre>

<p>This should open the GraphQL schema, located at <em>amplify/backend/api/festivalapi/schema.graphql</em>, in your text editor.</p>

<p>The schema we will be using has two main types, a <code>Stage</code> and a <code>Performance</code>. Use the following schema and continue (we will walk through how it works in the next step):</p>

<pre data-type="programlisting">type Stage @model
  @auth(rules: [
  { allow: public, operations: [read] },
  { allow: groups, groups: ["Admin"] }
]) {
  id: ID!
  name: String!
  performances: [Performance] @connection(keyName: "byStageId", fields: ["id"])
}

type Performance @model
  @key(name: "byStageId", fields: ["performanceStageId"])
  @auth(rules: [
  { allow: public, operations: [read] },
  { allow: groups, groups: ["Admin"] }
]) {
  id: ID!
  performanceStageId: ID!
  productID: ID
  performer: String!
  imageUrl: String
  description: String!
  time: String
  stage: Stage @connection
}</pre>

<p>Let’s look at the directives we used and how they work.</p>










<section data-type="sect3" data-pdf-bookmark="@auth"><div class="sect3" id="idm45364346809704">
<h3>@auth</h3>

<p><a data-type="indexterm" data-primary="pass in" id="idm45364346808424"/><a data-type="indexterm" data-primary="@auth directive" id="idm45364346807720"/>First, the <code>@auth</code> directive allows us to pass in an array of authorization rules. Each rule has an <code>allow</code> field (required) as well as other metadata (optional), including things like specifying the provider if it is different than the default authorization type.</p>

<p>In the <code>Stage</code> and <code>Performance</code> type, we’ve used two authorization types, one for group access (<code>groups</code>) and another for public access (<code>public</code>). You’ll notice that for the public access, we’ve also set an array of operations. This array should contain a list of the operations we would like to enable on the API. If there are no operations listed, then by default all operations would be enabled.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="@key"><div class="sect3" id="idm45364346802968">
<h3>@key</h3>

<p><a data-type="indexterm" data-primary="Amazon DynamoDB tables" id="idm45364346801768"/><a data-type="indexterm" data-primary="@key directive" id="idm45364346800840"/>The <code>@key</code> directive enables us to add GSIs and sort keys to a DynamoDB table for custom data access patterns. In the preceding schema, we’ve created a <code>key</code> called <code>byStageId</code> that will allow us to query the Performance table for performances by stage ID using a field called <code>performanceStageId</code> (on the <code>Performance</code> table). The resolver for the <code>performances</code> field will then use the ID of the stage to query for performances by stage ID.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="@connection"><div class="sect3" id="idm45364346797080">
<h3>@connection</h3>

<p><a data-type="indexterm" data-primary="@connection directive" id="idm45364346795880"/>The <code>@connection</code> directive allows us to model relationships between types. Types of relationships that can be created are belongs to, one to many, many to one, or many to many. In this example, we’ve created two relationships<a data-type="indexterm" data-primary="" data-startref="aws_be" id="idm45364346794312"/><a data-type="indexterm" data-primary="" data-startref="be_ab" id="idm45364346793336"/><a data-type="indexterm" data-primary="" data-startref="gql_be" id="idm45364346792392"/><a data-type="indexterm" data-primary="" data-startref="cre_be" id="idm45364346791448"/>:</p>

<ul>
<li>
<p>A relationship between a stage and a performance (one stage has many <span class="keep-together">performances)</span></p>
</li>
<li>
<p>A relationship between a performance and a stage (a performance belongs to a stage)</p>
</li>
</ul>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Deploying the Services"><div class="sect1" id="idm45364346787112">
<h1>Deploying the Services</h1>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="deploying services" id="idm45364346785912"/><a data-type="indexterm" data-primary="deploying" data-secondary="services" id="idm45364346784936"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="deploying services" id="idm45364346783992"/><a data-type="indexterm" data-primary="services" data-secondary="deploying" id="idm45364346783048"/>With all of the services configured, we’re ready to deploy the backend:</p>

<pre data-type="programlisting">~ amplify push</pre>

<p>The services have been deployed and we can begin writing the client code.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Building the Frontend"><div class="sect1" id="idm45364346780616">
<h1>Building the Frontend</h1>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="building frontend" id="aws_fe"/><a data-type="indexterm" data-primary="creating" data-secondary="frontend" id="cre_fe"/><a data-type="indexterm" data-primary="frontend" id="fe_ab"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="building frontend" id="gql_fe"/>Now that the project has been created and configured and the backend has been deployed, we can start setting up the client!</p>

<p>The first thing we will do is create the files we will need for this app:</p>

<pre data-type="programlisting">~ cd src
~ touch Container.js Footer.js Nav.js Admin.js Router.js Performance.js Home.js</pre>

<p>The next thing we will need to do is open <em>src/index.js</em> to add the Amplify configuration, import the Ant Design styles, and replace the main component with the Router that we will be creating soon. Update the file with the following code:</p>

<pre data-type="programlisting">/* src/index.js */
import React from 'react';
import ReactDOM from 'react-dom';
import Router from './Router';
import 'antd/dist/antd.css';

import Amplify from 'aws-amplify'
import config from './aws-exports'
Amplify.configure(config)

ReactDOM.render(&lt;Router /&gt;, document.getElementById('root'));</pre>








<section data-type="sect2" data-pdf-bookmark="Container"><div class="sect2" id="idm45364346770776">
<h2>Container</h2>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="Container component" id="idm45364346769576"/><a data-type="indexterm" data-primary="Container component" id="idm45364346768600"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="Container component" id="idm45364346767928"/>Now, let’s create the <code>Container</code> component that will serve as a reusable component to add padding and styling for our views:</p>

<pre data-type="programlisting">/* src/Container.js */
import React from 'react'

export default function Container({ children }) {
  return (
    &lt;div style={container}&gt;
      {children}
    &lt;/div&gt;
  )
}

const container = {
  padding: '30px 40px',
  minHeight: 'calc(100vh - 120px)'
}</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Footer"><div class="sect2" id="idm45364346765048">
<h2>Footer</h2>

<p><a data-type="indexterm" data-primary="GraphQL API" data-secondary="Footer component" id="idm45364346763848"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="Footer component" id="idm45364346762872"/><a data-type="indexterm" data-primary="Footer component" id="idm45364346761928"/>Here, we’ll create the <code>Footer</code> component that will serve as a reusable component to add a basic footer, as well as a link for admins to be able to sign up and sign in:</p>

<pre data-type="programlisting">/* src/Footer.js */
import React from 'react'
import { Link } from 'react-router-dom'

function Footer() {
  return (
    &lt;div style={footerStyle}&gt;
      &lt;Link to="/admin"&gt;
        Admins
      &lt;/Link&gt;
    &lt;/div&gt;
  )
}

const footerStyle = {
  borderTop: '1px solid #ddd',
  display: 'flex',
  alignItems: 'center',
  padding: 20
}

export default Footer</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Nav"><div class="sect2" id="idm45364346759272">
<h2>Nav</h2>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="Nav component" id="idm45364346758072"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="Nav component" id="idm45364346757096"/><a data-type="indexterm" data-primary="Nav component" id="idm45364346756152"/>Now, open <em>src/Nav.js</em> to create the basic navigation. There will only be one link: a link back to the main view that will hold all of the shows and performances:</p>

<pre data-type="programlisting">/* src/Nav.js */
import React from 'react'
import { Link } from 'react-router-dom'
import { Menu } from 'antd'
import { HomeOutlined } from '@ant-design/icons'

const Nav = (props) =&gt; {
  const { current } = props
  return (
    &lt;div&gt;
      &lt;Menu selectedKeys={[current]} mode="horizontal"&gt;
        &lt;Menu.Item key='home'&gt;
          &lt;Link to={`/`}&gt;
            &lt;HomeOutlined /&gt;Home
          &lt;/Link&gt;
        &lt;/Menu.Item&gt;
      &lt;/Menu&gt;
    &lt;/div&gt;
  )
}

export default Nav</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Admin"><div class="sect2" id="idm45364346753352">
<h2>Admin</h2>

<p><a data-type="indexterm" data-primary="Admin component" id="idm45364346751976"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="Admin component" id="idm45364346751272"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="Admin component" id="idm45364346750328"/>The Admin component we’ll create will only do three things for now: allow a user to sign up, sign in, and sign out. The idea for this component is to give admins a way to sign up so they can then create and manage the API as an admin.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Remember, when someone signs up, if their email is enabled in the Lambda trigger, they will be placed in the Admin group after signing up. They will then be able to perform mutations to create, update, and delete stages and performances.</p>
</div>

<p>If you ever need to update your backend code like the GraphQL schema or Lambda function, you can make the changes locally, then run <code>amplify push</code> to deploy the changes to the backend:</p>

<pre data-type="programlisting">/* src/Admin.js */
import React from 'react'
import { withAuthenticator, AmplifySignOut } from '@aws-amplify/ui-react'
import { Auth } from 'aws-amplify'
import { Button } from 'antd'

function Admin() {
  return (
    &lt;div&gt;
      &lt;h1 style={titleStyle}&gt;Admin&lt;/h1&gt;
      &lt;AmplifySignOut /&gt;
    &lt;/div&gt;
  )
}

const titleStyle = {
  fontWeight: 'normal',
  margin: '0px 0px 10px 0px'
}

export default withAuthenticator(Admin)</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Router"><div class="sect2" id="idm45364346745400">
<h2>Router</h2>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="Router component" id="idm45364346743864"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="Router component" id="idm45364346742888"/><a data-type="indexterm" data-primary="Router component" id="idm45364346741944"/>Now let’s create the Router:</p>

<pre data-type="programlisting">/* src/Router.js */
import React, { useState, useEffect } from 'react'
import { HashRouter, Switch, Route } from 'react-router-dom'

import Home from './Home'
import Admin from './Admin'
import Nav from './Nav'
import Footer from './Footer'
import Container from './Container'
import Performance from './Performance'

const Router = () =&gt; {
  const [current, setCurrent] = useState('home')
  useEffect(() =&gt; {
    setRoute()
    window.addEventListener('hashchange', setRoute)
    return () =&gt;  window.removeEventListener('hashchange', setRoute)
  }, [])
  function setRoute() {
    const location = window.location.href.split('/')
    const pathname = location[location.length-1]
    setCurrent(pathname ? pathname : 'home')
  }
  return (
    &lt;HashRouter&gt;
      &lt;Nav current={current} /&gt;
      &lt;Container&gt;
        &lt;Switch&gt;
          &lt;Route exact path="/" component={Home}/&gt;
          &lt;Route exact path="/performance/:id" component={Performance} /&gt;
          &lt;Route exact path="/admin" component={Admin}/&gt;
        &lt;/Switch&gt;
      &lt;/Container&gt;
      &lt;Footer /&gt;
    &lt;/HashRouter&gt;
  )
}

export default Router</pre>

<p>In this component, we combine the router with the persistent UI components like the Container and Footer.</p>

<p>The app has three routes:</p>
<dl>
<dt>Home</dt>
<dd>
<p><a data-type="indexterm" data-primary="Home route" id="idm45364346736856"/>This is the main route that will render the stages and performances.</p>
</dd>
<dt>Performance</dt>
<dd>
<p><a data-type="indexterm" data-primary="Performance route" id="idm45364346734792"/>This is this is the route that will render an individual performance and details around the performance.</p>
</dd>
<dt>Admin</dt>
<dd>
<p><a data-type="indexterm" data-primary="Admin route" id="idm45364346732680"/>This is the route that will render the sign-up/sign-in page for admins.</p>
</dd>
</dl>

<p>In the Performance route, you will see that we are using a path that looks like this:</p>

<pre data-type="programlisting">/performance/:id</pre>

<p>Doing this allows us to have URL parameters, so if we hit a route like this, we will be able to easily extract the ID from the URL:</p>

<pre data-type="programlisting">/performance/100</pre>

<p>Hitting a route with URL parameters will allow us to access them in the component itself. This is useful because we will be using the ID of the performance to fetch the performance details, and having them easily accessible in the route parameters enables this. It also enables you to easily build apps that support deep linking.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Performance"><div class="sect2" id="idm45364346744808">
<h2>Performance</h2>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="Performance component" id="idm45364346727176"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="Performance component" id="idm45364346726200"/><a data-type="indexterm" data-primary="Performance component" id="idm45364346725256"/>Next, let’s create the <code>Performance</code> component:</p>

<pre data-type="programlisting">/* src/Performance.js */
import React, { useState, useEffect } from 'react'
import { useParams } from 'react-router-dom'
import { getPerformance } from './graphql/queries'
import { API } from 'aws-amplify'

function Performance() {
  const [performance, setPerformance] = useState(null)
  const [loading, setLoading] = useState(true)

  let { id } = useParams()
  useEffect(() =&gt; {
    fetchPerformanceInfo()
  }, [])
  async function fetchPerformanceInfo() {
    try {
      const talkInfo = await API.graphql({
        query: getPerformance,
        variables: { id },
        authMode: 'API_KEY'
      })
      setPerformance(talkInfo.data.getPerformance)
      setLoading(false)
    } catch (err) {
      console.log('error fetching talk info...', err)
      setLoading(false)
    }
  }

  return (
    &lt;div&gt;
      &lt;p&gt;Performance&lt;/p&gt;
      { loading &amp;&amp; &lt;h3&gt;Loading...&lt;/h3&gt;}
      {
        performance &amp;&amp; (
          &lt;div&gt;
            &lt;h1&gt;{performance.performer}&lt;/h1&gt;
            &lt;h3&gt;{performance.time}&lt;/h3&gt;
            &lt;p&gt;{performance.description}&lt;/p&gt;
          &lt;/div&gt;
        )
      }
    &lt;/div&gt;
  )
}

export default Performance</pre>

<p><a data-type="indexterm" data-primary="render method" id="idm45364346721976"/>The render method of this component is pretty basic; it’s just rendering the performance <code>performer</code>, <code>time</code>, and <code>description</code>. What is interesting about this component is how we get that information. We do so with the following flow:</p>
<ol>
<li>
<p>We create<a data-type="indexterm" data-primary="useState hook" id="idm45364346718232"/> two pieces of state using the <code>useState</code> hook: <code>loading</code> (set to true) and <code>performance</code> (set to null). We also create a variable called <code>id</code> that uses the <code>useParams</code> helper from React Router to get the route parameter of <code>id</code>.</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="useEffect hook" id="idm45364346713992"/>When the component loads, we use the <code>useEffect</code> hook to immediately call the <code>fetchPerformanceInfo</code> function.</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="Cognito user pool" id="idm45364346711368"/><a data-type="indexterm" data-primary="fetchPerformanceInfo function" id="idm45364346710440"/>The <code>fetchPerformanceInfo</code> function will use the <code>id</code> from the route params to call the AppSync API. The API call here uses <code>API.graphql</code>, passing in the <code>variables</code>, <code>query</code>, and the <code>authMode</code>. By default, our API is using Cognito User Pools as the auth mode. Any time we would like to override this, like in this case to make a public API call, we need to specify the <code>authMode</code> in the API call itself.</p>
</li>
<li>
<p>Once the data is returned from the API, we call <code>setLoading</code> and <code>setPerformance</code> to update the UI and render the data coming back from the API.</p>
</li>

</ol>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Home"><div class="sect2" id="idm45364346704312">
<h2>Home</h2>

<p><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="Home component" id="idm45364346702696"/><a data-type="indexterm" data-primary="GraphQL API" data-secondary="Home component" id="idm45364346701720"/><a data-type="indexterm" data-primary="Home component" id="idm45364346700776"/>Now, let’s create the last component, the <code>Home</code> component:</p>

<pre data-type="programlisting">/* src/Home.js */
import React, { useEffect, useState } from 'react'
import { API } from 'aws-amplify'
import { listStages } from './graphql/queries'
import { Link } from 'react-router-dom'
import { List } from 'antd';

function Home() {
  const [stages, setStages] = useState([])
  const [loading, setLoading] = useState(true)
  useEffect(() =&gt; {
    getStages()
  }, [])
  async function getStages() {
    const apiData = await API.graphql({
      query: listStages,
      authMode: 'API_KEY'
    })
    const { data: { listStages: { items }}} = apiData
    setLoading(false)
    setStages(items)
  }

  return (
    &lt;div&gt;
     &lt;h1 style={heading}&gt;Stages&lt;/h1&gt;
      { loading &amp;&amp; &lt;h2&gt;Loading...&lt;/h2&gt;}
      {
        stages.map(stage =&gt; (
          &lt;div key={stage.id} style={stageInfo}&gt;
            &lt;p style={infoHeading}&gt;{stage.name}&lt;/p&gt;
            &lt;p style={infoTitle}&gt;Performances&lt;/p&gt;
            &lt;List
              itemLayout="horizontal"
              dataSource={stage.performances.items}
              renderItem={performance =&gt; (
                &lt;List.Item&gt;
                  &lt;List.Item.Meta
                   title={&lt;Link style={performerInfo}
                   to={`/performance/${
                         performance.id}`}&gt;{
                         performance.performer}&lt;/Link&gt;
                   }
                   description={performance.time}
                  /&gt;
                &lt;/List.Item&gt;
              )}
            /&gt;
          &lt;/div&gt;
        ))
      }
    &lt;/div&gt;
  )
}

const heading = { fontSize: 44, fontWeight: 300, marginBottom: 5 }
const stageInfo = { padding: '20px 0px 10px', borderBottom: '2px solid #ddd' }
const infoTitle = { fontWeight: 'bold' , fontSize: 18 }
const infoHeading = { fontSize: 30, marginBottom: 5 }
const performerInfo = { fontSize: 24 }

export default Home</pre>

<p>The logic in this component is actually very similar to what we did in the <span class="keep-together"><code>Performance</code></span> component:</p>
<ol>
<li>
<p>Create two main pieces of state using the <code>useState</code> hook: <code>stages</code> (set to an empty array), and <code>loading</code> (set to <code>true</code>).</p>
</li>
<li>
<p>When the app loads, we use the <code>API</code> class with a custom <code>authMode</code> of <code>API_KEY</code> to call the AppSync API.</p>
</li>
<li>
<p>When the data comes back from the API, set the state for the stages and set loading to false.</p>
</li>

</ol>

<p>Now, the app is finished, but there’s just one more thing. Because we have created a custom access pattern for the performances resolver, we need to update the <code>listStages</code> query definition to also return the performances. To do this, update the <code>listStages</code> query with the following:</p>

<pre data-type="programlisting">/* src/graphql/queries.js */

export const listStages = /* GraphQL */ `
  query ListStages(
    $filter: ModelStageFilterInput
    $nextToken: String
  ) {
    listStages(filter: $filter, limit: 500, nextToken: $nextToken) {
      items {
        id
        name
        performances {
          items {
            id
            time
            performer
            description
          }
        }
      }
      nextToken
    }
  }
`;</pre>

<p>Now, the app is completed and we can populate some data. Start the app and sign up with an admin user:</p>

<pre data-type="programlisting">~ npm start</pre>

<p>Click the <code>Admins</code> link in the footer to sign up. Once you’ve signed up, open the AppSync console:</p>

<pre data-type="programlisting">~ amplify console api

&gt; Choose GraphQL</pre>

<p>In the Queries panel of the console, you will need to click Login with User Pools to sign in using the username and password of the user you just created. When prompted for the ClientID, use the <code>aws_user_pools_web_client_id</code> located in the <em>aws-exports.js</em> file of your local project.</p>

<p>Next, create at least one stage and one performance:</p>

<pre data-type="programlisting">mutation createStage {
  createStage(input: {
    id: "stage-1"
    name: "Stage 1"
  }) {
    id name
  }
}

mutation createPerformance {
  createPerformance(input: {
    performanceStageId: "stage-1"
    performer: "Dreek"
    description: "Dreek LIVE in NYC! Don't miss out, performing
                  all of the hits with a few surprise performances!"
    time: "Monday, May 4 2022"
  }) {
    id performer description
  }
}</pre>

<p>Now, our database has some data, and we should be able to view it in our app and navigate between the main view and the detail view for each performance<a data-type="indexterm" data-primary="" data-startref="aws_fe" id="idm45364346679816"/><a data-type="indexterm" data-primary="" data-startref="cre_fe" id="idm45364346678840"/><a data-type="indexterm" data-primary="" data-startref="fe_ab" id="idm45364346677896"/><a data-type="indexterm" data-primary="" data-startref="gql_fe" id="idm45364346676952"/><a data-type="indexterm" data-primary="GraphQL Transform library" id="idm45364346676008"/><a data-type="indexterm" data-primary="Amplify GraphQL Transform library" id="idm45364346675320"/><a data-type="indexterm" data-primary="@auth directive" id="idm45364346674632"/><a data-type="indexterm" data-primary="pass in" id="idm45364346673960"/><a data-type="indexterm" data-primary="@connection directive" id="idm45364346673288"/><a data-type="indexterm" data-primary="@key directive" id="idm45364346672616"/>!</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45364346780120">
<h1>Summary</h1>

<p>Here are a few things to keep in mind from this chapter:</p>

<ul>
<li>
<p>The GraphQL Transform directive enables you to add powerful features to your GraphQL API like authorization rules, relationships, and custom indexes for additional data access patterns.</p>
</li>
<li>
<p>The <code>@auth</code> directive allows you to pass in an array of rules to define authorization rules on types and fields.</p>
</li>
<li>
<p>The <code>@connection</code> directive enables you to model relationships between GraphQL types.</p>
</li>
<li>
<p>The <code>@key</code> directive enables you to define custom indexes for custom data access patterns and to enhance existing relationships.</p>
</li>
<li>
<p>When creating an API with multiple authorization types, you will have a <code>Primary</code> authorization type that will be the default when making API calls. Whenever you need to override the <code>Primary</code> authorization type, you must pass in the <code>authMode</code> parameter to the <code>API</code> class defining the authorization type you would like to use.</p>
</li>
</ul>
</div></section>







</div></section></div>



  </body></html>