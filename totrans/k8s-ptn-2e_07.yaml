- en: Chapter 5\. Managed Lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerized applications managed by cloud native platforms have no control
    over their lifecycle, and to be good cloud native citizens, they have to listen
    to the events emitted by the managing platform and adapt their lifecycles accordingly.
    The *Managed Lifecycle* pattern describes how applications can and should react
    to these lifecycle events.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4, “Health Probe”](ch04.html#HealthProbe), we explained why containers
    have to provide APIs for the different health checks. Health-check APIs are read-only
    endpoints the platform is continually probing to get application insight. It is
    a mechanism for the platform to extract information from the application.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to monitoring the state of a container, the platform sometimes may
    issue commands and expect the application to react to them. Driven by policies
    and external factors, a cloud native platform may decide to start or stop the
    applications it is managing at any moment. It is up to the containerized application
    to determine which events are important to react to and how to react. But in effect,
    this is an API that the platform is using to communicate and send commands to
    the application. Also, applications are free to either benefit from lifecycle
    management or ignore it if they don’t need this service.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw that checking only the process status is not a good enough indication
    of the health of an application. That is why there are different APIs for monitoring
    the health of a container. Similarly, using only the process model to run and
    stop a process is not good enough. Real-world applications require more fine-grained
    interactions and lifecycle management capabilities. Some applications need help
    to warm up, and some applications need a gentle and clean shutdown procedure.
    For this and other use cases, some events, as shown in [Figure 5-1](#img-events),
    are emitted by the platform that the container can listen to and react to if desired.
  prefs: []
  type: TYPE_NORMAL
- en: '![Managed container lifecycle](assets/kup2_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Managed container lifecycle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The deployment unit of an application is a Pod. As you already know, a Pod is
    composed of one or more containers. At the Pod level, there are other constructs
    such as init containers, which we cover in [Chapter 15, “Init Container”](ch15.html#InitContainer),
    that can help manage the container lifecycle. The events and hooks we describe
    in this chapter are all applied at an individual container level rather than the
    Pod level.
  prefs: []
  type: TYPE_NORMAL
- en: SIGTERM Signal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever Kubernetes decides to shut down a container, whether that is because
    the Pod it belongs to is shutting down or simply because a failed liveness probe
    causes the container to be restarted, the container receives a SIGTERM signal.
    SIGTERM is a gentle poke for the container to shut down cleanly before Kubernetes
    sends a more abrupt SIGKILL signal. Once a SIGTERM signal has been received, the
    application should shut down as quickly as possible. For some applications, this
    might be a quick termination, and some other applications may have to complete
    their in-flight requests, release open connections, and clean up temp files, which
    can take a slightly longer time. In all cases, reacting to SIGTERM is the right
    moment to shut down a container in a clean way.
  prefs: []
  type: TYPE_NORMAL
- en: SIGKILL Signal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a container process has not shut down after a SIGTERM signal, it is shut
    down forcefully by the following SIGKILL signal. Kubernetes does not send the
    SIGKILL signal immediately but waits 30 seconds by default after it has issued
    a SIGTERM signal. This grace period can be defined per Pod via the `.spec.terminationGrace​Per⁠iodSeconds`
    field, but it cannot be guaranteed as it can be overridden while issuing commands
    to Kubernetes. The aim should be to design and implement containerized applications
    to be ephemeral with quick startup and shutdown processes.
  prefs: []
  type: TYPE_NORMAL
- en: PostStart Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using only process signals for managing lifecycles is somewhat limited. That
    is why additional lifecycle hooks such as `postStart` and `preStop` are provided
    by Kubernetes. A Pod manifest containing a `postStart` hook looks like the one
    in [Example 5-1](#ex-post-start).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. A container with `postStart` hook
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_managed_lifecycle_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `postStart` command waits 30 seconds. `sleep` is just a simulation for any
    lengthy startup code that might run at this point. Also, it uses a trigger file
    to sync with the main application, which starts in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: The `postStart` command is executed after a container is created, asynchronously
    with the primary container’s process. Even if much of the application initialization
    and warm-up logic can be implemented as part of the container startup steps, `postStart`
    still covers some use cases. The `postStart` action is a blocking call, and the
    container status remains *Waiting* until the `postStart` handler completes, which
    in turn keeps the Pod status in the *Pending* state. This nature of `postStart`
    can be used to delay the startup state of the container while allowing time for
    the main container process to initialize.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of `postStart` is to prevent a container from starting when the
    Pod does not fulfill certain preconditions. For example, when the `postStart`
    hook indicates an error by returning a nonzero exit code, Kubernetes kills the
    main container process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `postStart` and `preStop` hook invocation mechanisms are similar to the
    health probes described in [Chapter 4, “Health Probe”](ch04.html#HealthProbe),
    and support these handler types:'
  prefs: []
  type: TYPE_NORMAL
- en: exec
  prefs: []
  type: TYPE_NORMAL
- en: Runs a command directly in the container
  prefs: []
  type: TYPE_NORMAL
- en: httpGet
  prefs: []
  type: TYPE_NORMAL
- en: Executes an HTTP GET request against a port opened by one Pod container
  prefs: []
  type: TYPE_NORMAL
- en: You have to be very careful what critical logic you execute in the `postStart`
    hook as there are no guarantees for its execution. Since the hook is running in
    parallel with the container process, it is possible that the hook may be executed
    before the container has started. Also, the hook is intended to have at-least-once
    semantics, so the implementation has to take care of duplicate executions. Another
    aspect to keep in mind is that the platform does not perform any retry attempts
    on failed HTTP requests that didn’t reach the handler.
  prefs: []
  type: TYPE_NORMAL
- en: PreStop Hook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `preStop` hook is a blocking call sent to a container before it is terminated.
    It has the same semantics as the SIGTERM signal and should be used to initiate
    a graceful shutdown of the container when reacting to SIGTERM is not possible.
    The `preStop` action in [Example 5-2](#ex-pre-stop) must complete before the call
    to delete the container is sent to the container runtime, which triggers the SIGTERM
    notification.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. A container with a `preStop` hook
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_managed_lifecycle_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Call out to a `/shutdown` endpoint running within the application.
  prefs: []
  type: TYPE_NORMAL
- en: Even though `preStop` is blocking, holding on it or returning an unsuccessful
    result does not prevent the container from being deleted and the process killed.
    The `preStop` hook is only a convenient alternative to a SIGTERM signal for graceful
    application shutdown and nothing more. It also offers the same handler types and
    guarantees as the `postStart` hook we covered previously.
  prefs: []
  type: TYPE_NORMAL
- en: Other Lifecycle Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, so far we have focused on the hooks that allow you to execute
    commands when a container lifecycle event occurs. But another mechanism that is
    not at the container level but at the Pod level allows you to execute initialization
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: We describe the *Init Container* pattern in [Chapter 15](ch15.html#InitContainer)
    in depth, but here we describe it briefly to compare it with lifecycle hooks.
    Unlike regular application containers, init containers run sequentially, run until
    completion, and run before any of the application containers in a Pod start up.
    These guarantees allow you to use init containers for Pod-level initialization
    tasks. Both lifecycle hooks and init containers operate at a different granularity
    (at the container level and Pod level, respectively) and can be used interchangeably
    in some instances, or complement one another in other cases. [Table 5-1](#table-lifecycle-hooks)
    summarizes the main differences between the two.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Lifecycle hooks and init containers
  prefs: []
  type: TYPE_NORMAL
- en: '| Aspect | Lifecycle hooks | Init containers |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Activates on | Container lifecycle phases. | Pod lifecycle phases. |'
  prefs: []
  type: TYPE_TB
- en: '| Startup phase action | A `postStart` command. | A list of `initContainers`
    to execute. |'
  prefs: []
  type: TYPE_TB
- en: '| Shutdown phase action | A `preStop` command. | No equivalent feature. |'
  prefs: []
  type: TYPE_TB
- en: '| Timing guarantees | A `postStart` command is executed at the same time as
    the container’s `ENTRYPOINT`. | All init containers must be completed successfully
    before any application container can start. |'
  prefs: []
  type: TYPE_TB
- en: '| Use cases | Perform noncritical startup/shutdown cleanups specific to a container.
    | Perform workflow-like sequential operations using containers; reuse containers
    for task executions. |'
  prefs: []
  type: TYPE_TB
- en: If even more control is required to manage the lifecycle of your application
    containers, there is an advanced technique for rewriting the container entrypoints,
    sometimes also referred to as the [*Commandlet* pattern](https://oreil.ly/CVZX6).
    This pattern is especially useful when the main containers within a Pod have to
    be started in a certain order and need an extra level of control. Kubernetes-based
    pipeline platforms like Tekton and Argo CD require the sequential execution of
    containers that share data and support the inclusion of additional sidecar containers
    running in parallel (we talk more about sidecars in [Chapter 16, “Sidecar”](ch16.html#Sidecar)).
  prefs: []
  type: TYPE_NORMAL
- en: For these scenarios, a sequence of init containers is not good enough because
    init containers don’t allow sidecars. As an alternative, an advanced technique
    called *entrypoint* *rewriting* can be used to allow fine-grained lifecycle control
    for the Pod’s main containers. Every container image defines a command that is
    executed by default when the container starts. In a Pod specification, you can
    also define this command directly in the Pod spec. The idea of entrypoint rewriting
    is to replace this command with a generic wrapper command that calls the original
    command and takes care of lifecycle concerns. This generic command is injected
    from another container image before the application container starts.
  prefs: []
  type: TYPE_NORMAL
- en: This concept is best explained by an example. [Example 5-3](#ex-entrypoint-rewriting-before)
    shows a typical Pod declaration that starts a single container with the given
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Simple Pod starting an image with a command and arguments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_managed_lifecycle_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The command executed when the container starts.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_managed_lifecycle_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Additional arguments provided to the entrypoint command.
  prefs: []
  type: TYPE_NORMAL
- en: The trick is now to wrap the given command `random-generator-runner` with a
    generic supervisor program that takes care of lifecycle aspects, like reacting
    on `SIGTERM` or other external signals. [Example 5-4](#ex-entrypoint-rewriting)
    demonstrates a Pod declaration that includes an init container for installing
    a supervisor, which is then started to monitor the main application.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. Pod that wraps the original entrypoint with a supervisor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_managed_lifecycle_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A fresh `emptyDir` volume is created to share the supervisor daemon.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_managed_lifecycle_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Init container used for copying the supervisor daemon to the application containers.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_managed_lifecycle_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The original command `randomGenerator` as defined in [Example 5-3](#ex-entrypoint-rewriting-before)
    is replaced with supervisor daemon from the shared volume.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_managed_lifecycle_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The original command specification becomes the arguments for the supervisor
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: This entrypoint rewriting is especially useful for Kubernetes-based applications
    that create and manage Pods programmatically, like Tekton, which creates Pods
    when running a continuous integration (CI) pipeline. That way, they gain much
    better control of when to start, stop, or chain containers within a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: There are no strict rules about which mechanism to use except when you require
    a specific timing guarantee. We could skip lifecycle hooks and init containers
    entirely and use a bash script to perform specific actions as part of a container’s
    startup or shutdown commands. That is possible, but it would tightly couple the
    container with the script and turn it into a maintenance nightmare. We could also
    use Kubernetes lifecycle hooks to perform some actions, as described in this chapter.
    Alternatively, we could go even further and run containers that perform individual
    actions using init containers or inject supervisor daemons for even more sophisticated
    control. In this sequence, the options require increasingly more effort, but at
    the same time offer stronger guarantees and enable reuse.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the stages and available hooks of containers and Pod lifecycles
    is crucial for creating applications that benefit from being managed by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main benefits the cloud native platform provides is the ability to
    run and scale applications reliably and predictably on top of potentially unreliable
    cloud infrastructure. These platforms provide a set of constraints and contracts
    for an application running on them. It is in the interest of the application to
    honor these contracts to benefit from all of the capabilities offered by the cloud
    native platform. Handling and reacting to these events ensures that your application
    can gracefully start up and shut down with minimal impact on the consuming services.
    At the moment, in its basic form, that means the containers should behave as any
    well-designed POSIX process should. In the future, there might be even more events
    giving hints to the application when it is about to be scaled up or asked to release
    resources to prevent being shut down. It is essential to understand that the application
    lifecycle is no longer in the control of a person but is fully automated by the
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: Besides managing the application lifecycle, the other big duty of orchestration
    platforms like Kubernetes is to distribute containers over a fleet of nodes. The
    next pattern, *Automated Placement*, explains the options to influence the scheduling
    decisions from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Managed Lifecycle Example](https://oreil.ly/2T2jc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Container Lifecycle Hooks](https://oreil.ly/xzeMi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Attach Handlers to Container Lifecycle Events](https://oreil.ly/NTi1h)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubernetes Best Practices: Terminating with Grace](https://oreil.ly/j-5yl)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Graceful Shutdown of Pods with Kubernetes](https://oreil.ly/TgjCp)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Argo and Tekton: Pushing the Boundaries of the Possible on Kubernetes](https://oreil.ly/CVZX6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Russian Doll: Extending Containers with Nested Processes](https://oreil.ly/iBhoQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
