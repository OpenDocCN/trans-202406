<html><head></head><body><section data-pdf-bookmark="Chapter 12. Trimming Down Resource Consumption with Performance Optimizations" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch12">&#13;
<h1><span class="label">Chapter 12. </span>Trimming Down Resource Consumption with Performance Optimizations</h1>&#13;
&#13;
&#13;
<p><a data-primary="performance optimizations" data-type="indexterm" id="ix_ch12-asciidoc0"/>In the previous chapter, you became familiar with ways to examine what’s going on “under the hood” using popular&#13;
Android profiling tools. This final chapter highlights a medley of performance optimization considerations. There’s&#13;
no one-size-fits-all approach, so it is helpful to become aware of potential performance pitfalls (and solutions). However,&#13;
performance issues can sometimes  be the result of many compounding problems that individually may not seem noteworthy.</p>&#13;
&#13;
<p>Performance considerations allow you to examine concerns that may impact your application’s ability to scale. If you&#13;
can use any of these strategies as “low-hanging fruit” in your code base, it’s well worth going for the biggest win&#13;
with the smallest amount of effort. Not every section of this chapter will be suitable for every project you work on,&#13;
but they are still useful considerations to be aware of when writing any Android application. These topics range from&#13;
view system performance optimizations to network data format, caching, and more.</p>&#13;
&#13;
<p>We are aware that the View system is to be replaced by Jetpack Compose: however, the View system is not going anywhere&#13;
for years, even with Jetpack. The first half of this chapter is dedicated to view topics every project could benefit from:&#13;
potential optimizations for the Android View system. The way you set up view hierarchies can end up having a substantial&#13;
impact on performance if you are not careful. For this reason, we look at two easy ways to optimize view performance:&#13;
reducing view hierarchy complexity with <code>ConstraintLayout</code>, and creating drawable resources for animation/customized&#13;
backgrounds.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Achieving Flatter View Hierarchy with ConstraintLayout" data-type="sect1"><div class="sect1" id="idm46669736488016">&#13;
<h1>Achieving Flatter View Hierarchy with ConstraintLayout</h1>&#13;
&#13;
<p><a data-primary="ConstraintLayout" data-secondary="achieving flatter view hierarchy" data-type="indexterm" id="ix_ch12-asciidoc1"/><a data-primary="flatter view hierarchy" data-type="indexterm" id="ix_ch12-asciidoc2"/><a data-primary="performance optimizations" data-secondary="achieving flatter view hierarchy with ConstraintLayout" data-type="indexterm" id="ix_ch12-asciidoc3"/>As a general rule, you want to keep your view hierarchies in Android as flat as possible. Deeply nested&#13;
hierarchies affect performance, both when a view first inflates and when the user interacts with the screen. When&#13;
view hierarchies are deeply nested, it can take longer to send instructions back up to the root <code>ViewGroup</code> containing&#13;
all your elements and traverse back down to make changes to particular views.</p>&#13;
&#13;
<p>In addition to the profiling tools mentioned in <a data-type="xref" href="ch11.html#android_profiling_tools">Chapter 11</a>, Android Studio offers<a data-primary="Layout Inspector" data-type="indexterm" id="idm46669736480416"/> <em>Layout Inspector</em>, which&#13;
analyzes your application at runtime and creates a 3D rendering of the view elements stacked on the screen. You can&#13;
open Layout Inspector by clicking the bottom corner tab of Android Studio, as shown in <a data-type="xref" href="#layout_inspector">Figure 12-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="layout_inspector">&#13;
<img alt="Layout Inspector" src="assets/pawk_1201.png"/>&#13;
<h6><span class="label">Figure 12-1. </span>Layout Inspector allows you to rotate the 3D rendering for devices running API 29+.</h6>&#13;
</div></figure>&#13;
&#13;
<p>When child components are drawn, they are drawn on top of the parent <code>View</code>, stacking one on top of the other. Layout&#13;
Inspector does provide a <em>Component Tree</em> pane to the left so that you are able to drill down the elements and inspect&#13;
their properties. To better understand what happens when users interact with Android UI widgets, <a data-type="xref" href="#view_hierarchy">Figure 12-2</a> shows&#13;
a bird’s-eye view of the very same layout hierarchy provided in the Component Tree.</p>&#13;
&#13;
<p>Even for a relatively simple layout, a view hierarchy can grow in complexity pretty quickly. Managing many nested layouts can&#13;
come with additional costs such as increased difficulty managing touch events, slower GPU rendering, and difficulty&#13;
guaranteeing the same spacing/size of views across different-sized screens.</p>&#13;
&#13;
<figure><div class="figure" id="view_hierarchy">&#13;
<img alt="Layout Inspector" src="assets/pawk_1202.png"/>&#13;
<h6><span class="label">Figure 12-2. </span>The elements of a running activity stretched out in their entirety.</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">On top of the visual changes your app might call for, the Android OS could also be affecting view properties on&#13;
its own. Changes on view properties, called by either you or the OS, could trigger a re-layout of your view hierarchy.&#13;
Whether this happens or not depends on how views are implemented (by yourself or by an external dependency), how often layout&#13;
components trigger dimension resizing, and where they are located in the view hierarchy.</p>&#13;
&#13;
<p>Not only must we worry about hierarchy complexity, but we also must be mindful of avoiding certain types of views that could&#13;
end up costing our application twice the number of traversals necessary to send instructions to the Android OS. Some older&#13;
layout types in Android are prone to “double taxation” when relative positioning is enabled:</p>&#13;
<dl>&#13;
<dt><code>RelativeLayout</code></dt>&#13;
<dd>&#13;
<p>Without<a data-primary="RelativeLayout" data-type="indexterm" id="idm46669736467280"/> fail, this always traverses its child elements at least twice: once for layout calculations for each position and size and once to finalize positioning.</p>&#13;
</dd>&#13;
<dt><code>LinearLayout</code></dt>&#13;
<dd>&#13;
<p>This<a data-primary="LinearLayout" data-type="indexterm" id="idm46669736464832"/> sets its orientation to horizontal or sets <code>android:setMeasureWithLargestChildEnabled="true"</code>&#13;
while in vertical orientation; both cases make two passes for each child element.</p>&#13;
</dd>&#13;
<dt><code>GridLayout</code></dt>&#13;
<dd>&#13;
<p>This<a data-primary="GridLayout" data-type="indexterm" id="idm46669736462048"/> can end up making double traversals if the layout uses weight distribution or sets&#13;
<code>android:layout_gravity</code> to any valid value.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The cost of double taxation can become far more severe when any one of these cases is located closer to the root&#13;
of the tree, and can even cause exponential traversals. The deeper the view hierarchy is, the longer it takes for input&#13;
events to be processed and for views to be updated accordingly.</p>&#13;
&#13;
<p>As a good practice, it’s best to lower the negative impact of view re-layout on app responsiveness. To keep hierarchies&#13;
flatter and more robust, Android advocates using<a data-primary="ConstraintLayout" data-type="indexterm" id="idm46669736459200"/> <code>ConstraintLayout</code>. <code>ConstraintLayout</code> helps create a responsive UI&#13;
for complex layouts with a flat-view hierarchy.</p>&#13;
&#13;
<p>There are a few rules of <code>ConstraintLayout</code> to remember:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Every view must have at least one horizontal and one vertical constraint.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Start/End of a view may only chain itself to the Start/End of other views.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Top/Bottom of a view may only chain itself to the Top/Bottom of other views.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Android Studio’s design preview shows how the parent ties the view to the designated end of the screen, as shown in&#13;
<a data-type="xref" href="#constraint_layout_attrs">Figure 12-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="constraint_layout_attrs">&#13;
<img alt="pawk 1203" src="assets/pawk_1203.png"/>&#13;
<h6><span class="label">Figure 12-3. </span>In this particular <code>ConstraintLayout</code>, the spinner button constrains all parent sides to the center of the screen. The text elements in the upper-left corner are only constrained to the top and left sides of the parent.</h6>&#13;
</div></figure>&#13;
&#13;
<p>When highlighted, the zigzagged lines appear on a view to indicate where a side is constrained to. A zigzag&#13;
indicates a constraint one way to a view while a squiggly line indicates that the two views constrain to each other.</p>&#13;
&#13;
<p>This book does not cover additional useful features of <code>ConstraintLayout</code>, like barriers, guidelines, groups, and&#13;
creating constraints. The best way to get to know <code>ConstraintLayout</code> is to experiment with the&#13;
elements yourself in <em>Split View</em> within the design panel, as shown in <a data-type="xref" href="#split_view">Figure 12-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="split_view">&#13;
<img alt="Split View" src="assets/pawk_1204.png"/>&#13;
<h6><span class="label">Figure 12-4. </span>The Split View of the design panel shows half code and half design for layout files.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Using <code>ConstraintLayout</code>, especially when <code>ViewGroup</code> elements might be deeply nested or inefficient, is an easy way to&#13;
address potential performance bottlenecks at runtime for any Android application. In the next section, we shift focus&#13;
on performance optimizations from views themselves to view animations.<a data-startref="ix_ch12-asciidoc3" data-type="indexterm" id="idm46669736442320"/><a data-startref="ix_ch12-asciidoc2" data-type="indexterm" id="idm46669736441616"/><a data-startref="ix_ch12-asciidoc1" data-type="indexterm" id="idm46669736440944"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reducing Programmatic Draws with Drawables" data-type="sect1"><div class="sect1" id="idm46669736487072">&#13;
<h1>Reducing Programmatic Draws with Drawables</h1>&#13;
&#13;
<p><a data-primary="Drawables" data-type="indexterm" id="ix_ch12-asciidoc4"/><a data-primary="performance optimizations" data-secondary="reducing programmatic draws with Drawables" data-type="indexterm" id="ix_ch12-asciidoc5"/><a data-primary="programmatic draws" data-type="indexterm" id="ix_ch12-asciidoc6"/>Another potential performance issue for any Android project is programmatic draws at runtime. Once in a while,&#13;
Android developers run into a view element which does not have access to certain properties in a layout file. Suppose&#13;
you wanted to render a view with rounded corners only on the top two corners. One way to approach this is with a&#13;
programmatic draw via a Kotlin extension function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">View</code><code class="p">.</code><code class="n">roundCorners</code><code class="p">(</code><code class="n">resources</code><code class="p">:</code> <code class="n">Resources</code><code class="p">,</code> <code class="n">outline</code><code class="p">:</code> <code class="n">OutLine</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">adjusted</code> <code class="p">=</code> <code class="n">TypedValue</code><code class="p">.</code><code class="n">applyDimension</code><code class="p">(</code>&#13;
        <code class="n">TypedValue</code><code class="p">.</code><code class="n">COMPLEX_UNIT_SP</code><code class="p">,</code>&#13;
        <code class="m">25</code><code class="p">,</code>&#13;
        <code class="n">resources</code><code class="o">?.</code><code class="n">displayMetrics</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">newHeight</code> <code class="p">=</code>&#13;
        <code class="n">view</code><code class="p">.</code><code class="n">height</code><code class="p">.</code><code class="n">plus</code><code class="p">(</code><code class="n">cornerRadiusAdjusted</code><code class="p">).</code><code class="n">toInt</code><code class="p">()</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="n">run</code> <code class="p">{</code> <code class="n">outline</code><code class="o">?.</code><code class="n">setRoundRect</code><code class="p">(</code><code class="m">0</code><code class="p">,</code> <code class="m">0</code><code class="p">,</code> <code class="n">width</code><code class="p">,</code> <code class="n">newHeight</code><code class="p">,</code> <code class="n">adjusted</code><code class="p">)}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is fine and valid; however, too many programmatic draws can end up choking the RenderThread and subsequently&#13;
block the UI thread from being able to process further events until runtime drawings complete. Furthermore, the cost of&#13;
altering views programmatically becomes higher if a particular view needs to resize to meet constraints. Resizing a view&#13;
element at runtime means you won’t be able to use the<a data-primary="LayoutInflater" data-type="indexterm" id="idm46669736433792"/> <code>LayoutInflater</code> to adjust how the elements fit with the new&#13;
dimensions of the original altered view.</p>&#13;
&#13;
<p>You can offload overhead that would otherwise occur by using drawables, which are stored in the <em>/drawables</em> folder in your&#13;
resource assets. The following code shows how a <code>Drawable</code> XML file achieves the same goal of rounding the top two corners of&#13;
a view element:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;shape</code> <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
    <code class="na">android:shape =</code> <code class="s">"rectangle"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;corners</code> <code class="na">android:topLeftRadius=</code><code class="s">"25dp"</code> <code class="na">android:topRightRadius=</code><code class="s">"25dp"</code><code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;stroke</code> <code class="na">android:width=</code><code class="s">"1dp"</code> <code class="na">android:color=</code><code class="s">"#FFF"</code><code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;solid</code> <code class="na">android:color=</code><code class="s">"#FFF"</code><code class="nt">/&gt;</code>&#13;
<code class="nt">&lt;/shape&gt;</code></pre>&#13;
&#13;
<p>You can then add the name of the file as a <code>Drawable</code> type to the background attribute in the View’s layout file the name of the <code>Drawable</code> file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting">android:background="@drawable/rounded_top_corners_background"</pre>&#13;
&#13;
<p>In the previous section, we briefly touched on the initial stages of how user interaction sends instructions&#13;
to the Android OS. To understand where animations come in, we will now dive a little further into the full process of&#13;
how Android renders the UI. Let’s consider the case where a user in TrekMe presses the “Create a Map” button.</p>&#13;
&#13;
<p>The stages we cover in the remainder of this section show how the OS processes user events with a screen and how it is&#13;
able to execute draw instructions from software to hardware. We explain all the phases the Android OS performs in a draw&#13;
up to where animations occur in the <em>Sync</em> stage, as shown in <a data-type="xref" href="#android_ui_render_phases">Figure 12-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="android_ui_render_phases">&#13;
<img alt="How Android UI renders" src="assets/pawk_1205.png"/>&#13;
<h6><span class="label">Figure 12-5. </span>Animation occurs at the Sync stage, after traversal is performed.</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="VSync" data-type="indexterm" id="idm46669736307072"/><em>VSync</em> represents the time given between frame draws on the screen. In an app, when a user touches a view element&#13;
on the screen, <em>input handling</em> occurs. In the <em>Input</em> stage, the Android OS makes a call to <em>invalidate</em> all the parent&#13;
view element nodes up the tree by copying a set of instructions to keep track of dirtied state. Invalidation&#13;
does not redraw the view itself, but rather, indicates to the system later on which marked view must be redrawn later.&#13;
This is done by propagating the copied information up the view hierarchy so that it can all be executed on the way back&#13;
down at a later stage. <a data-type="xref" href="#display_list">Figure 12-6</a> shows what invalidation looks like after user input occurs when someone touches a button: traversing up the node, then copying a set of <code>DisplayList</code> instructions up each parent view. Even though the arrow points down the elements, indicating child elements, the traversal and the copying of <code>getDisplayList()</code> actually goes up to the root before going back down.</p>&#13;
&#13;
<figure><div class="figure" id="display_list">&#13;
<img alt="DisplayList" src="assets/pawk_1206.png"/>&#13;
<h6><span class="label">Figure 12-6. </span>The <code>DisplayList</code> object is a set of compact instructions used to instruct which views need to be redrawn on the Canvas. These instructions are copied up every parent view element to the root hierarchy during invalidation and then executed during traversal.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The Android UI system then schedules the next stage, known as <em>traversal</em>, which contains its own subset of rendering stages:</p>&#13;
<dl>&#13;
<dt>Measure</dt>&#13;
<dd>&#13;
<p>This calculates <code>MeasureSpecs</code> and passes it to the child element for measuring. It does this recursively, all the way down to the leaf nodes.</p>&#13;
</dd>&#13;
<dt>Layout</dt>&#13;
<dd>&#13;
<p>This sets the view position and sizing of a child layout.</p>&#13;
</dd>&#13;
<dt>Draw</dt>&#13;
<dd>&#13;
<p>This renders the views using a set of instructions given by a set of <code>DisplayList</code> instructions.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In the next stage, <em>Sync</em>, the Android OS syncs the <code>DisplayList</code> info between the CPU and GPU. When the CPU&#13;
starts talking to the GPU in Android, the JNI takes its set of instructions in the Java Native layer within the UI&#13;
thread and sends a synthetic copy, along with some other information, to the GPU from the RenderThread. The&#13;
RenderThread is responsible for animations and offloading work from the UI thread (instead of having to send&#13;
the work to the GPU). From there, the CPU and GPU communicate with each other to determine what instructions ought&#13;
to be executed and then combined visually to render on the screen. Finally, we reach the <em>Execute</em> stage, where&#13;
the OS finally executes <code>DisplayList</code> operations in optimized fashion (like drawing similar operations together at once).&#13;
<a href="https://oreil.ly/P5WbO">“Drawn Out: How Android Renders”</a> is an excellent talk that provides more detail on Android rendering at the system level.<sup><a data-type="noteref" href="ch12.html#idm46669736237984" id="idm46669736237984-marker">1</a></sup></p>&#13;
&#13;
<p>As of Android Oreo, animations, such as circular reveals, ripples, and vector drawable animations, live only in the&#13;
<code>RenderThread</code>, meaning that these kinds of animations are nonblocking for the UI thread. You can create these&#13;
animations with custom drawables. Consider the case where we wish to animate a shadowed ripple in the View background&#13;
whenever a user presses some kind of  <code>ViewGroup</code>. You can combine a set of drawables to make this happen, starting with&#13;
<code>RippleDrawable</code> type <code>Drawable</code> to create the ripple animation itself:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;ripple</code> <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
        <code class="na">android:color=</code><code class="s">"@color/primary"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;item</code> <code class="na">android:id=</code><code class="s">"@android:id/mask"</code><code class="nt">&gt;</code>&#13;
        <code class="nt">&lt;shape</code> <code class="na">android:shape=</code><code class="s">"rectangle"</code><code class="nt">&gt;</code>&#13;
            <code class="nt">&lt;solid</code> <code class="na">android:color=</code><code class="s">"@color/ripple_mask"</code> <code class="nt">/&gt;</code>&#13;
        <code class="nt">&lt;/shape&gt;</code>&#13;
    <code class="nt">&lt;/item&gt;</code>&#13;
<code class="nt">&lt;/ripple&gt;</code></pre>&#13;
&#13;
<p><code>RippleDrawable</code>, whose equivalent on XML is <code>ripple</code>, requires a color attribute for ripple effects.&#13;
To apply this animation to a background, we can use another drawable file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;shape</code> <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
        <code class="na">android:shape=</code><code class="s">"rectangle"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;solid</code> <code class="na">android:color=</code><code class="s">"@color/background_pressed"</code> <code class="nt">/&gt;</code>&#13;
<code class="nt">&lt;/shape&gt;</code></pre>&#13;
&#13;
<p>We can use <a data-primary="DrawableStates" data-type="indexterm" id="idm46669736173280"/>DrawableStates, a set of framework-provided states that can be specified on a&#13;
<code>Drawable</code>. In this case, we use DrawableStates on a selector to determine the animation as well as whether the&#13;
animation occurs on press or not. Finally, we create a <code>Drawable</code> used to render different states. Each state&#13;
is represented by a child drawable. In this case, we apply the ripple drawable animation&#13;
only when the view has been pressed:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;selector</code> <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
    <code class="na">android:enterFadeDuration=</code><code class="s">"@android:integer/config_shortAnimTime"</code>&#13;
    <code class="na">android:exitFadeDuration=</code><code class="s">"@android:integer/config_shortAnimTime"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;item</code>&#13;
        <code class="na">android:state_pressed=</code><code class="s">"true"</code> <code class="na">android:state_enabled=</code><code class="s">"true"</code>&#13;
        <code class="na">android:drawable=</code><code class="s">"@drawable/background_pressed_ripple"</code><code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;item</code>&#13;
        <code class="na">android:state_pressed=</code><code class="s">"false"</code>&#13;
        <code class="na">android:drawable=</code><code class="s">"@android:color/transparent"</code><code class="nt">/&gt;</code>&#13;
<code class="nt">&lt;/selector&gt;</code></pre>&#13;
<div class="jetpack" data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As mentioned in the beginning of the chapter, the view system build around Jetpack Compose is completely different from&#13;
the view system in Android, with its own sets of UI management, graphics, runtime/compile time behavior, and more.&#13;
If Jetpack Compose is done with programmatic draws, would that mean using Jetpack Compose is not efficient for&#13;
drawing?  While XML currently renders faster than Compose rendering itself, optimizations are underway for&#13;
closing the gap on render time. However, you should  keep in mind the major advantage Compose holds is the ability to update, or recompose, Composable views quickly and far more efficiently than the current Android view framework.</p>&#13;
</div>&#13;
&#13;
<p>We’re done talking about view performance optimizations, and we’ll move on to more performance optimization tips around&#13;
various parts of an Android application for the remainder of the chapter.<a data-startref="ix_ch12-asciidoc6" data-type="indexterm" id="idm46669736124208"/><a data-startref="ix_ch12-asciidoc5" data-type="indexterm" id="idm46669736123504"/><a data-startref="ix_ch12-asciidoc4" data-type="indexterm" id="idm46669736122832"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Minimizing Asset Payload in Network Calls" data-type="sect1"><div class="sect1" id="idm46669736439360">&#13;
<h1>Minimizing Asset Payload in Network Calls</h1>&#13;
&#13;
<p><a data-primary="network calls" data-secondary="minimizing asset payload in" data-type="indexterm" id="idm46669736121360"/><a data-primary="performance optimizations" data-secondary="minimizing asset payload in network calls" data-type="indexterm" id="idm46669736120320"/>In Android, it’s important to use minimal payload to avoid slower loads, battery drainage, and using too much data.&#13;
In the previous chapter, we started looking at network payload data formats. Both images and serialized data formats are&#13;
the usual suspects for causing the most bloat, so it’s important to check your payload’s data format.</p>&#13;
&#13;
<p>If you don’t need transparency for the images you work with in your Android project, it’s better to work with&#13;
JPG/JPEG since this format intrinsically doesn’t support transparency and compresses better than PNG. When it comes&#13;
to blowing up bitmaps for thumbnails, it probably makes sense to render the image in much lower resolution.</p>&#13;
&#13;
<p>In the industry, <a data-primary="JSON" data-type="indexterm" id="idm46669736117616"/>JSON is commonly used as the data payload in networking. Unfortunately, JSON and XML payloads are horrible&#13;
for compression since the data format accounts for spaces, quotes, returns, acmes, and more. Binary serialization&#13;
formats like <em>protocol buffers</em>, an accessible data format in Android which might serve as a cheaper alternative. You can define the data structs, which Protobuf is able to compress much smaller than XML and JSON data. Check out <a href="https://oreil.ly/6dUL0">Google Developers</a> for more on protocol buffers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bitmap Pooling and Caching" data-type="sect1"><div class="sect1" id="idm46669736085152">&#13;
<h1>Bitmap Pooling and Caching</h1>&#13;
&#13;
<p><a data-primary="Bitmap pooling" data-type="indexterm" id="idm46669736083760"/><a data-primary="caching" data-type="indexterm" id="idm46669736082832"/><a data-primary="performance optimizations" data-secondary="Bitmap pooling and caching" data-type="indexterm" id="idm46669736082160"/>TrekMe uses Bitmap pooling to avoid allocating too many <code>Bitmap</code> objects. Bitmap pooling reuses an existing instance,&#13;
when possible. Where does this “existing instance” come from? After a <code>Bitmap</code> is no longer visible, instead of&#13;
making it available for garbage collection (by just not keeping a reference on it), you can put the no-longer-used&#13;
<code>Bitmap</code> into a “bitmap pool.” Such a pool is just a container for available bitmaps for later use. For example, TrekMe&#13;
uses a simple in-memory dequeue as a bitmap pool. To load an image into an existing bitmap, you have to specify which&#13;
&#13;
<span class="keep-together">bitmap</span> instance you want to use. You can do that using the <code>inBitmap</code> parameter<sup><a data-type="noteref" href="ch12.html#idm46669736078176" id="idm46669736078176-marker">2</a></sup> of &#13;
<span class="keep-together"><code>BitMapFactory.Options</code>:</span></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// we get an instance of bitmap from the pool</code>&#13;
 <code class="n">BitmapFactory</code><code class="p">.</code><code class="n">Options</code><code class="p">().</code><code class="n">inBitmap</code> <code class="p">=</code> <code class="n">pool</code><code class="p">.</code><code class="k">get</code><code class="p">()</code></pre>&#13;
&#13;
<p>It’s worth noting that image-loading libraries like Glide can save you from having to handle bitmap craziness&#13;
yourself. Using these libraries results in bitmap caching for free in your applications. In cases where network calls&#13;
are slow, fetching a fresh instance of a <code>Bitmap</code> could be costly. This is when fetching from a bitmap cache can&#13;
save a lot of time and resources. If a user revisits a screen, the screen is able to load almost immediately instead&#13;
of having to make another network request. We can distinguish two kinds of caches:<a data-primary="in-memory caches" data-type="indexterm" id="idm46669736068896"/> <em>in-memory</em> and<a data-primary="filesystem caches" data-type="indexterm" id="idm46669736067744"/> <em>filesystem</em>&#13;
caches. In-memory caches provide the fastest object retrieval, at the cost of using more memory. Filesystem caches&#13;
are typically slower, but they do have a low memory footprint. Some applications rely on in-memory LRU&#13;
cache,<sup><a data-type="noteref" href="ch12.html#idm46669736066224" id="idm46669736066224-marker">3</a></sup> while others use filesystem-based cache or a mix of the two approaches.</p>&#13;
&#13;
<p>As an example, if you perform HTTP requests in your application, you can use <em>OkHttp</em> to expose a nice API to use&#13;
a filesystem cache. <a data-primary="OkHttp" data-type="indexterm" id="idm46669736064608"/><em>OkHttp</em> (which is also included as a transitive dependency of the popular library, <em>Retrofit</em>) is a&#13;
popular client library widely used in Android for networking. Adding caching is relatively easy:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">cacheSize</code> <code class="p">=</code> <code class="m">10</code> <code class="p">*</code> <code class="m">1024</code> <code class="p">*</code> <code class="m">1024</code>&#13;
<code class="k">val</code> <code class="py">cache</code> <code class="p">=</code> <code class="n">Cache</code><code class="p">(</code><code class="n">rootDir</code><code class="p">,</code> <code class="n">cacheSize</code><code class="p">)</code>&#13;
&#13;
<code class="k">val</code> <code class="py">client</code> <code class="p">=</code> <code class="n">OkHttpClient</code><code class="p">.</code><code class="n">Builder</code><code class="p">()</code>&#13;
                <code class="p">.</code><code class="n">cache</code><code class="p">(</code><code class="n">cache</code><code class="p">)</code>&#13;
                <code class="p">.</code><code class="n">build</code><code class="p">()</code></pre>&#13;
&#13;
<p>With <em>OkHttp</em> client building, it is easy to create configurations with custom interceptors to better suit the use case&#13;
of an application. For example, interceptors can force the cache to refresh at a designated interval. Caching is a&#13;
great tool for a device working with limited resources in its environment. For this reason, Android developers ought&#13;
to use cache to keep track of calculated computations.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>A nice open source library that supports both <em>in-memory</em> and <em>filesystem</em> cache is&#13;
<a href="https://oreil.ly/urfwv">Dropbox Store</a>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reducing Unnecessary Work" data-type="sect1"><div class="sect1" id="idm46669735971408">&#13;
<h1>Reducing Unnecessary Work</h1>&#13;
&#13;
<p><a data-primary="performance optimizations" data-secondary="reducing unnecessary work" data-type="indexterm" id="ix_ch12-asciidoc7"/>For your application to consume resources frugally, you want to avoid leaving in code that is doing&#13;
unnecessary work. Even senior developers commonly make these kinds of mistakes, causing extra work and memory to be&#13;
allocated unnecessarily. For &#13;
<span class="keep-together">example,</span> custom views in Android require particular attention. Let’s consider a custom&#13;
view with a circular shape. For a custom view implementation, you can subclass any kind of <code>View</code> and override the&#13;
<code>onDraw</code> method. Here is one possible implementation of<a data-primary="CircleView" data-type="indexterm" id="idm46669735966240"/> <code>CircleView</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// Warning: this is an example of what NOT to do!</code>&#13;
<code class="k">class</code> <code class="nc">CircleView</code> <code class="n">@JvmOverloads</code> <code class="n">constructor</code><code class="p">(</code>&#13;
    <code class="n">context</code><code class="p">:</code> <code class="n">Context</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="p">:</code> <code class="n">View</code><code class="p">(</code><code class="n">context</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">onDraw</code><code class="p">(</code><code class="n">canvas</code><code class="p">:</code> <code class="n">Canvas</code><code class="p">)</code> <code class="p">{</code>&#13;
       <code class="k">super</code><code class="p">.</code><code class="n">onDraw</code><code class="p">(</code><code class="n">canvas</code><code class="p">)</code>&#13;
       <code class="n">canvas</code><code class="p">.</code><code class="n">save</code><code class="p">()</code>&#13;
       <code class="c1">// Never initialize object allocation here!</code>&#13;
       <code class="k">val</code> <code class="py">paint</code><code class="p">:</code> <code class="n">Paint</code> <code class="p">=</code> <code class="n">Paint</code><code class="p">().</code><code class="n">apply</code> <code class="p">{</code>&#13;
           <code class="n">color</code> <code class="p">=</code> <code class="n">Color</code><code class="p">.</code><code class="n">parseColor</code><code class="p">(</code><code class="s">"#55448AFF"</code><code class="p">)</code>&#13;
           <code class="n">isAntiAlias</code> <code class="p">=</code> <code class="k">true</code>&#13;
       <code class="p">}</code>&#13;
       <code class="n">canvas</code><code class="p">.</code><code class="n">drawCircle</code><code class="p">(</code><code class="m">100f</code><code class="p">,</code> <code class="m">100f</code><code class="p">,</code> <code class="m">50f</code><code class="p">,</code> <code class="n">paint</code><code class="p">)</code>&#13;
       <code class="n">canvas</code><code class="p">.</code><code class="n">restore</code><code class="p">()</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <a data-primary="onDraw" data-type="indexterm" id="idm46669735964704"/><code>onDraw</code> method is invoked every time the view needs to be redrawn. That can happen quite frequently, especially&#13;
if the view is animated or moved. Therefore, you should never instantiate new objects in <code>onDraw</code>. Such mistakes result in&#13;
unnecessarily allocating a lot of objects, which puts high pressure on the garbage collector. In the previous example,&#13;
a new <code>Paint</code> instance is created every time the rendering layer draws <code>CircleView</code>. You should never do that.</p>&#13;
&#13;
<p>Instead, it is better to instantiate the <code>Paint</code> object once as a class attribute:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">CircleView</code> <code class="n">@JvmOverloads</code> <code class="n">constructor</code><code class="p">(</code>&#13;
    <code class="n">context</code><code class="p">:</code> <code class="n">Context</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="p">:</code> <code class="n">View</code><code class="p">(</code><code class="n">context</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">var</code> <code class="py">paint</code><code class="p">:</code> <code class="n">Paint</code> <code class="p">=</code> <code class="n">Paint</code><code class="p">().</code><code class="n">apply</code> <code class="p">{</code>&#13;
        <code class="n">color</code> <code class="p">=</code> <code class="n">Color</code><code class="p">.</code><code class="n">parseColor</code><code class="p">(</code><code class="s">"#55448AFF"</code><code class="p">)</code>&#13;
        <code class="n">isAntiAlias</code> <code class="p">=</code> <code class="k">true</code>&#13;
    <code class="p">}</code>&#13;
        <code class="k">set</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">field</code> <code class="p">=</code> <code class="n">value</code>&#13;
            <code class="n">invalidate</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">onDraw</code><code class="p">(</code><code class="n">canvas</code><code class="p">:</code> <code class="n">Canvas</code><code class="p">)</code> <code class="p">{</code>&#13;
       <code class="k">super</code><code class="p">.</code><code class="n">onDraw</code><code class="p">(</code><code class="n">canvas</code><code class="p">)</code>&#13;
       <code class="n">canvas</code><code class="p">.</code><code class="n">save</code><code class="p">()</code>&#13;
       <code class="n">canvas</code><code class="p">.</code><code class="n">drawCircle</code><code class="p">(</code><code class="m">100f</code><code class="p">,</code> <code class="m">100f</code><code class="p">,</code> <code class="m">50f</code><code class="p">,</code> <code class="n">paint</code><code class="p">)</code>&#13;
       <code class="n">canvas</code><code class="p">.</code><code class="n">restore</code><code class="p">()</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now the <code>paint</code> object is allocated only once. For the purposes of this existing class, sometimes the <code>paint</code> value&#13;
would be set to different colors. However, if the assignment is not dynamic, you can take it a step further by evaluating&#13;
the <code>paint</code> value lazily.</p>&#13;
&#13;
<p>You want to keep your inject balanced and your dependencies light whenever possible. For repositories, services,&#13;
and other singleton dependencies (dependencies that are single objects in memory, like <code>object</code>), it makes sense to&#13;
make use of <code>lazy</code> delegation so that there is a singleton instance rather than copies of the same object sitting in the heap.</p>&#13;
&#13;
<p>Consider the code we examined earlier in <a data-type="xref" href="ch11.html#Detecting_Memory_Leaks_with_LeakCanary_id">“Detecting Memory Leaks with LeakCanary”</a>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MapImportViewModel</code> <code class="n">@ViewModelInject</code> <code class="n">constructor</code><code class="p">(</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">settings</code><code class="p">:</code> <code class="n">Settings</code><code class="p">,</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">app</code><code class="p">:</code> <code class="n">Application</code>&#13;
<code class="p">):</code> <code class="n">ViewModel</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="cm">/* removed for brevity */</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">unarchiveAsync</code><code class="p">(</code><code class="n">item</code><code class="p">:</code> <code class="n">ItemData</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">viewModelScope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">inputStream</code> <code class="p">=</code> <code class="n">app</code><code class="p">.</code><code class="n">contentResolve</code><code class="p">.</code>&#13;
                <code class="n">openInputStream</code><code class="p">(</code><code class="n">item</code><code class="p">.</code><code class="n">uri</code><code class="p">)</code> <code class="o">?:</code> <code class="k">return</code><code class="n">@launch</code>&#13;
            <code class="k">val</code> <code class="py">rootFolder</code> <code class="p">=</code> <code class="n">settings</code><code class="p">.</code><code class="n">getAppDir</code><code class="p">()</code> <code class="o">?:</code> <code class="k">return</code><code class="n">@launch</code>&#13;
            <code class="k">val</code> <code class="py">outputFolder</code> <code class="p">=</code> <code class="n">File</code><code class="p">(</code><code class="n">rootFolder</code><code class="p">,</code> <code class="s">"imported"</code><code class="p">)</code>&#13;
            <code class="cm">/* removed for brevity */</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this class, the <code>settings</code> dependency is injected using Hilt—you can tell that by the <a data-primary="@ViewModelInject" data-primary-sortas="ViewModelInject" data-type="indexterm" id="idm46669735680800"/><code>@ViewModelInject</code>.&#13;
At the time we wrote this example, we were using Hilt 2.30.1-alpha and only dependencies available in the&#13;
activity scope could be injected into the <code>ViewModel</code>. In other words, a newly created <code>MapImportViewModel</code> is always&#13;
injected into the same <code>Settings</code> instance, as long as the activity isn’t re-created. So the bottom line is: a dependency&#13;
injection framework such as Hilt can assist you in scoping the lifecycle of your dependencies. In TrekMe, <code>Settings</code> is&#13;
scoped in the application. Therefore, <code>Settings</code> is technically a singleton.</p>&#13;
<div class="jetpack" data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a data-primary="Hilt" data-type="indexterm" id="idm46669735561168"/>Hilt is a dependency injection (DI) framework that provides a standard way to use DI in your application. The framework&#13;
also has the benefit of managing lifecycles automatically, and has extensions available for use with Jetpack&#13;
components like ViewModels and WorkManager.</p>&#13;
</div>&#13;
&#13;
<p>The avoidance of unnecessary work expands into every scope of Android development. When drawing objects to render on the UI, it&#13;
makes sense to recycle already-drawn pixels. Likewise, since we know that making network calls in Android drains the battery,&#13;
it’s good to examine how many calls are made and how frequently they’re called. Perhaps you have a shopping cart in&#13;
your application. It may make good business sense to make updates to the remote server so that a user can access their&#13;
cart cross-platform. On the other hand, it may also be worth exploring updating a user’s cart in local storage (save&#13;
for a periodic network update). Of course, these kinds of business decisions exist outside the scope of this book,&#13;
but technical consideration can always help to make for more thoughtful features.<a data-startref="ix_ch12-asciidoc7" data-type="indexterm" id="idm46669735558704"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Static Functions" data-type="sect1"><div class="sect1" id="idm46669735970784">&#13;
<h1>Using Static Functions</h1>&#13;
&#13;
<p><a data-primary="performance optimizations" data-secondary="using static functions" data-type="indexterm" id="idm46669735556688"/><a data-primary="static functions" data-type="indexterm" id="idm46669735555744"/>When a method or a property isn’t tied to any class instance (e.g., doesn’t alter an object state), it sometimes makes&#13;
sense to use <em>static functions</em>/<em>properties</em>. We’ll show different scenarios where using static functions is more&#13;
appropriate than using &#13;
<span class="keep-together">inheritance.</span></p>&#13;
&#13;
<p>Kotlin makes it very easy to use static functions. A <code>companion object</code> within a class declaration holds static constants, properties, and functions that can be referenced anywhere in the project. For example, an Android service can expose a static property <code>isStarted</code>, which can only be modified by the service itself, as shown in <a data-type="xref" href="#gpx_recording_service_ex">Example 12-1</a>.</p>&#13;
<div data-type="example" id="gpx_recording_service_ex">&#13;
<h5><span class="label">Example 12-1. </span><code>GpxRecordingService.isStarted</code></h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">GpxRecordingService</code> <code class="p">{</code>&#13;
&#13;
    <code class="cm">/* Removed for brevity */</code>&#13;
&#13;
    <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
        <code class="k">var</code> <code class="py">isStarted</code><code class="p">:</code> <code class="n">Boolean</code> <code class="p">=</code> <code class="k">false</code>&#13;
            <code class="k">private</code> <code class="k">set</code><code class="p">(</code><code class="n">value</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="n">EventBus</code><code class="p">.</code><code class="n">getDefault</code><code class="p">().</code><code class="n">post</code><code class="p">(</code><code class="n">GpxRecordServiceStatus</code><code class="p">(</code><code class="n">value</code><code class="p">))</code>&#13;
                <code class="n">field</code> <code class="p">=</code> <code class="n">value</code>&#13;
            <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>In <a data-type="xref" href="#gpx_recording_service_ex">Example 12-1</a>, <code>GpxRecordingService</code> can internally change the value of &#13;
<span class="keep-together"><code>isStarted</code></span>. While doing&#13;
so, an event is sent through the event bus, notifying all registered components. Moreover, the status of the&#13;
<code>GpxRecordingService</code> is accessible from anywhere in the app as a read-only <code>GpxRecordingService.isStarted</code> property.&#13;
But remember to avoid accidentally saving an <code>Activity</code>, <code>Fragment</code>, <code>View</code>, or <code>Context</code> to a static member: that could end in&#13;
a hefty memory leak!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Minification and Obfuscation with R8 and ProGuard" data-type="sect1"><div class="sect1" id="idm46669735477936">&#13;
<h1>Minification and Obfuscation with R8 and ProGuard</h1>&#13;
&#13;
<p><a data-primary="minification, with R8 and ProGuard" data-type="indexterm" id="idm46669735476528"/><a data-primary="obfuscation, with R8 and ProGuard" data-type="indexterm" id="idm46669735475632"/><a data-primary="performance optimizations" data-secondary="minification and obfuscation with R8 and ProGuard" data-type="indexterm" id="idm46669735474992"/><a data-primary="ProGuard" data-type="indexterm" id="idm46669735473936"/><a data-primary="R8" data-type="indexterm" id="idm46669735473264"/>It is a common practice to <em>minify</em>, or shrink, release builds for production so that unused code and resources can be&#13;
removed. Minifying your code allows you to ship smaller APKs to Google PlayStore more securely. <em>Minification</em> shrinks&#13;
your code by removing unused methods. Minifying your code also gives you the power of <em>obfuscation</em> as an additional&#13;
security feature. Obfuscation garbles the names of classes/fields/methods and removes debugging attributes in order to&#13;
discourage reverse &#13;
<span class="keep-together">engineering.</span></p>&#13;
&#13;
<p>For Android users, R8 is now the default minification tool provided by the Android Gradle plug-in 5.4.1+. ProGuard,&#13;
R8’s stricter and more powerful predecessor, had a heavier focus on optimizing heavy reflection like the ones found in Gson. In comparison,&#13;
the newer minification tool R8 does not support this feature. However, R8 is successful in achieving smaller compression&#13;
and optimization for Kotlin.</p>&#13;
&#13;
<p>Configurations can be done through <code>proguardFile</code> (you will see an example at the end of the section). R8 reads&#13;
the rules provided for the <code>proguardFile</code> and executes shrinking and obfuscation accordingly. You can then assign a&#13;
<em>proguardFile</em> to a certain flavor and build type in <em>build.gradle</em>:</p>&#13;
&#13;
<pre data-code-language="groovy" data-type="programlisting"><code class="n">buildTypes</code> <code class="o">{</code>&#13;
    <code class="n">release</code> <code class="o">{</code>&#13;
        <code class="n">minifyEnabled</code> <code class="kc">true</code>&#13;
        <code class="n">shrinkResources</code> <code class="kc">true</code>&#13;
        <code class="n">proguardFile</code> <code class="nf">getDefaultProguardFile</code><code class="o">(</code><code class="s1">'proguard-android-optimize.txt'</code><code class="o">),</code> <code class="s1">'proguard-rules.pro'</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>It’s common practice to shrink your APK to upload to the PlayStore. However, it’s important to be watchful and prevent unintentionally shrinking/obfuscating code&#13;
that might need to be used by a third-party library at runtime. Kotlin uses metadata in Java classes for Kotlin&#13;
constructs. However, when R8 shrinks Kotlin classes, it is unable to keep state with the Kotlin metadata. In a best-case&#13;
scenario, shrinking/obfuscating such classes might cause wonky behavior; in a worst-case scenario, it might cause inexplicable&#13;
crashes.</p>&#13;
&#13;
<p>To demonstrate a scenario where ProGuard accidentally obfuscates too much application code, we observe some wonky&#13;
behavior on the popular open source library, Retrofit. Perhaps your application works perfectly fine in debugging mode, but in release mode, a networking call inexplicably returns a <code>NullPointerException</code>. Unfortunately, &#13;
<span class="keep-together">Kotlin</span> Gson models&#13;
go blank even while annotating properties/fields with Retrofit’s <code>@SerializedName</code>, thanks to Kotlin reflection. As a result, you must add a rule in your proguard file to prevent the Kotlin model class from obfuscating. Oftentimes, you may end up having to include your model classes by adding them directly in your <code>proguardFile</code>. Here is an example of adding model domain classes to a &#13;
<span class="keep-together"><code>proguardFile</code></span> so that release builds don’t accidentally obfuscate the aforementioned classes:</p>&#13;
&#13;
<pre data-type="programlisting"># Retrofit 2.X&#13;
-dontwarn retrofit2.**&#13;
-keep class retrofit2.** { *; }&#13;
# Kotlin source code whitelisted here&#13;
-keep class com.some.kotlin.network.model.** { *; }&#13;
-keepattributes Signature&#13;
-keepattributes Exceptions&#13;
-keepclasseswithmembers class * {&#13;
    @retrofit2.http.* &lt;methods&gt;;&#13;
}</pre>&#13;
&#13;
<p>A good piece of advice is: always test the release build!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669735445888">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter covered the following important performance optimization tips:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>In the Android view framework, deeply nested view hierarchies take longer to draw and traverse than flatter hierarchies. Consider using&#13;
<code>ConstraintLayout</code>, where you can flatten nested views.</p>&#13;
</li>&#13;
<li>&#13;
<p>In the Android view framework, it is better to move programmatic draws and animations to drawable resources to offload the work on the RenderThread&#13;
at runtime.</p>&#13;
</li>&#13;
<li>&#13;
<p>Using JSON and XML formats for network data payload is horrible for compression. Use protocol buffers for much&#13;
smaller data compression.</p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid unnecessary work whenever possible: make sure you’re not ringing off unnecessary network calls for constant&#13;
updates, and try to recycle drawn objects.</p>&#13;
</li>&#13;
<li>&#13;
<p>Optimizations in performance and memory can come from taking an honest look at the code you write. Are you unintentionally&#13;
creating objects within a loop that could be created once outside a loop? What expensive operations could be reduced&#13;
to less-intensive operations?</p>&#13;
</li>&#13;
<li>&#13;
<p>You can use a ProGuard file to make your application as small as possible and add custom rules for shrinking,&#13;
obfuscating, and optimizing your app.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s face it: Android can be a challenge to keep up with. It’s OK to take information in stride as it becomes&#13;
relevant for you. Such a strategy guarantees learning opportunities that stay with you for a long time. No matter&#13;
where you’re at in your journey, one of your best resources for both Kotlin and Android (besides this book) is the&#13;
open source community. Both Android and Kotlin are living, breathing communities from which you can ascertain the&#13;
newest and most relevant information. To keep yourself current, you can turn to additional resources like Twitter,&#13;
<a href="https://oreil.ly/m853Y">Slack</a>, and <a href="https://oreil.ly/KZPlx">KEEP</a>. You may well also find&#13;
that you can return to this book to revisit popular, evergreen problems that show up in Android from time to time.&#13;
We hope you enjoyed this book.<a data-startref="ix_ch12-asciidoc0" data-type="indexterm" id="idm46669735408448"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669736237984"><sup><a href="ch12.html#idm46669736237984-marker">1</a></sup> Chet Haase and Romain Guy. “Drawn Out: How Android Renders.” Google I/O ’18, 2017.</p><p data-type="footnote" id="idm46669736078176"><sup><a href="ch12.html#idm46669736078176-marker">2</a></sup> The instance of <code>Bitmap</code> that you supply must be a mutable bitmap.</p><p data-type="footnote" id="idm46669736066224"><sup><a href="ch12.html#idm46669736066224-marker">3</a></sup> LRU stands for Least Recently Used. As you can’t cache objects indefinitely, caching is always related to an eviction strategy to maintain the cache at a target or acceptable size. In an LRU cache, the “oldest” objects are evicted first.</p></div></div></section></body></html>