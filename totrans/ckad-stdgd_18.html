<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Resource Requirements, Limits, and Quotas" class="praise"><div class="dedication" id="resource_requirements_limits_quotas">
<h1 class="calibre14"><span class="keep-together">Chapter 18. </span>Resource Requirements, Limits, and Quotas</h1>


<p class="author1">Workload executed in Pods will consume a certain amount of resources (e.g., CPU and memory). You should define resource requirements for those applications. On a container level, you can define a minimum amount of resources needed to run the application, as well as the maximum amount of resources the application is allowed to consume. Application developers should determine the right-sizing with load tests or at runtime by monitoring the resource consumption.</p>
<div data-type="note" epub:type="note" class="calibre26"><h6 class="calibre27">Note</h6>
<p class="author1">Kubernetes measures CPU resources in millicores and memory resources in bytes. That’s why you might see resources defined as 600m or 100Mi. For a deep dive on those resource units, it’s worth cross-referencing the section <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#resource-units-in-kubernetes" class="calibre10">“Resource units in Kubernetes”</a> in the official documentation.</p>
</div>

<p class="author1">Kubernetes  administrators  can  put  measures  in  place  to  enforce  the  use  of  available resource capacity. We’ll discuss two Kubernetes primitives in this realm, the ResourceQuota and the LimitRange. The ResourceQuota defines aggregate resource constraints on a namespace level. A LimitRange is a policy that constrains or defaults the resource allocations for a single object of a specific type (such as for a Pod or a 
<span class="keep-together">PersistentVolumeClaim).</span></p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id487">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objective:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Understand and define resource requirements, limits, and quotas</p>
</li>
</ul>
</div></aside>






<section data-type="sect1" data-pdf-bookmark="Working with Resource Requirements" class="praise"><div class="dedication" id="container_resource_requirements">
<h1 class="calibre17">Working with Resource Requirements</h1>

<p class="author1">It’s recommended practice that you specify resource requests and limits for every container. Determining those resource expectations is not always easy, specifically for applications that haven’t been exercised in a production environment yet. Load testing the application early during the development cycle can help with analyzing the resource needs. Further adjustments can be made by monitoring the application’s resource consumption after deploying it to the cluster.</p>








<section data-type="sect2" data-pdf-bookmark="Defining Container Resource Requests" class="praise"><div class="dedication" id="id363">
<h2 class="calibre33">Defining Container Resource Requests</h2>

<p class="author1">One metric that comes into play for workload scheduling is the <em class="calibre3">resource request</em> defined by the containers in a Pod. Commonly used resources that can be specified are CPU and memory. The scheduler ensures that the node’s resource capacity can fulfill the resource requirements of the Pod. More specifically, the scheduler determines the sum of resource requests per resource type across all containers defined in the Pod and compares them with the node’s available resources.</p>

<p class="author1">Each container in a Pod can define its own resource requests. <a data-type="xref" href="#options_resource_requests" class="calibre10">Table 18-1</a> describes the available options including an example value.</p>
<table id="options_resource_requests" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 18-1. </span>Options for resource requests</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">YAML attribute</th>
<th class="calibre63">Description</th>
<th class="calibre63">Example value</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">spec.containers[].resources.requests.cpu</code></p></td>
<td class="calibre65"><p class="author1">CPU resource type</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">500m</code> (five hundred millicpu)</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">spec.containers[].resources.requests.memory</code></p></td>
<td class="calibre65"><p class="author1">
<span class="keep-together">Memory resource type</span></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">64Mi</code> (2^26 bytes)</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">spec.containers[].resources.requests.hugepages-&lt;size&gt;</code></p></td>
<td class="calibre65"><p class="author1">Huge page resource type</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">hugepages-2Mi: 60Mi</code></p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">spec.containers[].resources.requests.ephemeral-storage</code></p></td>
<td class="calibre65"><p class="author1">Ephemeral storage resource type</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">4Gi</code></p></td>
</tr>
</tbody>
</table>

<p class="author1">To clarify the uses of these resource requests, we’ll look at an example definition. The Pod YAML manifest shown in <a data-type="xref" href="#setting_container_resource_requests" class="calibre10">Example 18-1</a> defines two containers, each with its own resource requests. Any node that is allowed to run the Pod needs to be able to support a minimum memory capacity of 320Mi and 1250m CPU, the sum of resources across both containers.</p>
<div id="setting_container_resource_requests" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-1. </span>Setting container resource requests</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">rate-limiter</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">business-app</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-business-app:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w"></code>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"256Mi"</code><code class="w"></code>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1"</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ambassador</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-ambassador:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8081</code><code class="w"></code>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"64Mi"</code><code class="w"></code>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"250m"</code><code class="w"></code></pre></div>

<p class="author1">It’s certainly possible that a Pod cannot be scheduled due to insufficient resources available on the nodes. In those cases, the event log of the Pod will indicate this situation with the reasons <code class="calibre15">PodExceedsFreeCPU</code> or <code class="calibre15">PodExceedsFreeMemory</code>. For more information on how to troubleshoot and resolve this situation, see the relevant <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#troubleshooting" class="calibre10">section in the documentation</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Defining Container Resource Limits" class="praise"><div class="dedication" id="id364">
<h2 class="calibre33">Defining Container Resource Limits</h2>

<p class="author1">Another metric you can set for a container is the <em class="calibre3">resource limits</em>. Resource limits ensure that the container cannot consume more than the allotted resource amounts. For example, you could express that the application running in the container should be constrained to 1000m of CPU and 512Mi of memory.</p>

<p class="author1">Depending on the container runtime used by the cluster, exceeding any of the allowed resource limits results in a termination of the application process running in the container or results in the system preventing the allocation of resources beyond the limits. For an in-depth discussion on how resource limits are treated by the container runtime Docker Engine, see the <a href="https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/#how-pods-with-resource-limits-are-run" class="calibre10">documentation</a>.</p>

<p class="author1"><a data-type="xref" href="#options_resource_limits" class="calibre10">Table 18-2</a> describes the available options including an example value.</p>
<table id="options_resource_limits" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 18-2. </span>Options for resource limits</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">YAML attribute</th>
<th class="calibre63">Description</th>
<th class="calibre63">Example value</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">spec.containers[].resources.limits.cpu</code></p></td>
<td class="calibre65"><p class="author1">CPU resource type</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">500m</code> (500 millicpu)</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">spec.containers[].resources.limits.memory</code></p></td>
<td class="calibre65"><p class="author1">
<span class="keep-together">Memory resource type</span></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">64Mi</code> (2^26 bytes)</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">spec.containers[].resources.limits.hugepages-&lt;size&gt;</code></p></td>
<td class="calibre65"><p class="author1">Huge page resource type</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">hugepages-2Mi: 60Mi</code></p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">spec.containers[].resources.limits.ephemeral-storage</code></p></td>
<td class="calibre65"><p class="author1">Ephemeral storage resource type</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">4Gi</code></p></td>
</tr>
</tbody>
</table>

<p class="author1"><a data-type="xref" href="#setting_container_resource_limits" class="calibre10">Example 18-2</a> shows the definition of limits in action. Here, the container named <code class="calibre15">business-app</code> cannot use more than 512Mi of memory. The container named <code class="calibre15">ambassador</code> defines a limit of 128Mi of memory.</p>
<div id="setting_container_resource_limits" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-2. </span>Setting container resource limits</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">rate-limiter</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">business-app</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-business-app:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w"></code>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"256Mi"</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ambassador</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-ambassador:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8081</code><code class="w"></code>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"64Mi"</code><code class="w"></code></pre></div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Defining Container Resource Requests and Limits" class="praise"><div class="dedication" id="id365">
<h2 class="calibre33">Defining Container Resource Requests and Limits</h2>

<p class="author1">To provide Kubernetes with the full picture of your application’s resource expectations, you must specify resource requests and limits for every container. <a data-type="xref" href="#settings_container_resource_requests_limits" class="calibre10">Example 18-3</a> combines resource requests and limits in a single YAML manifest.</p>
<div id="settings_container_resource_requests_limits" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-3. </span>Setting container resource requests and limits</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">rate-limiter</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">business-app</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-business-app:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w"></code>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"256Mi"</code><code class="w"></code>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1"</code><code class="w"></code>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"256Mi"</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ambassador</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-ambassador:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8081</code><code class="w"></code>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"64Mi"</code><code class="w"></code>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"250m"</code><code class="w"></code>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"64Mi"</code><code class="w"></code></pre></div>

<p class="author1">Assigning static container resource requirements is an approximation process. You want maximizing an efficient utilization of resources in your Kubernetes cluster. Unfortunately, the Kubernetes documentation does not offer a lot of guidance on best practices. The blog post <a href="https://home.robusta.dev/blog/stop-using-cpu-limits" class="calibre10">“For the Love of God, Stop Using CPU Limits on Kubernetes”</a> provides the following guidance:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Always define memory requests.</p>
</li>
<li class="calibre13">
<p class="author1">Always define memory limits.</p>
</li>
<li class="calibre13">
<p class="author1">Always set your memory requests equal to your limit.</p>
</li>
<li class="calibre13">
<p class="author1">Always define CPU requests.</p>
</li>
<li class="calibre13">
<p class="author1">Do not use CPU limits.</p>
</li>
</ul>

<p class="author1">After launching your application to production, you still need to monitor your application resource consumption patterns. Review resource consumption at runtime and keep track of actual scheduling behavior and potential undesired behaviors once the application receives load. Finding a happy medium can be frustrating. Projects like <a href="https://www.fairwinds.com/blog/introducing-goldilocks-a-tool-for-recommending-resource-requests" class="calibre10">Goldilocks</a> and <a href="https://github.com/robusta-dev/krr" class="calibre10">KRR</a> emerged to provide recommendations and guidance on appropriately determining resource requests. Other options, like the <a href="https://kubernetes.io/docs/tasks/configure-pod-container/resize-container-resources/#container-resize-policies" class="calibre10">container resize policies</a> introduced in Kubernetes 1.27, allow for more fine-grained control over how containers’ CPU and memory resources are resized automatically at runtime.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Working with Resource Quotas" class="praise"><div class="dedication" id="resource_quotas">
<h1 class="calibre17">Working with Resource Quotas</h1>

<p class="author1">The Kubernetes primitive ResourceQuota establishes the usable, maximum amount of resources per namespace. Once put in place, the Kubernetes scheduler will take care of enforcing those rules. The following list should give you an idea of the rules that can be defined:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Setting an upper limit for the number of objects that can be created for a specific type (e.g., a maximum of three Pods).</p>
</li>
<li class="calibre13">
<p class="author1">Limiting the total sum of compute resources (e.g., 3Gi of RAM).</p>
</li>
<li class="calibre13">
<p class="author1">Expecting a Quality of Service (QoS) class for a Pod (e.g., <code class="calibre15">BestEffort</code> to indicate that the Pod must not make any memory or CPU limits or requests).</p>
</li>
</ul>








<section data-type="sect2" data-pdf-bookmark="Creating ResourceQuotas" class="praise"><div class="dedication" id="id367">
<h2 class="calibre33">Creating ResourceQuotas</h2>

<p class="author1">Creating a ResourceQuota object is usually a task that a Kubernetes administrator would take on, but it’s relatively easy to define and create such an object. First, create the namespace the quota should apply to:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create namespace team-awesome</strong>
namespace/team-awesome created
</pre>

<p class="author1">Next, define the ResourceQuota in YAML. To demonstrate the functionality of a ResourceQuota, add constraints to the namespace, as shown in <a data-type="xref" href="#resource_quota" class="calibre10">Example 18-4</a>.</p>
<div id="resource_quota" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-4. </span>Defining hard resource limits with a ResourceQuota</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ResourceQuota</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">awesome-quota</code><code class="w">
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre15">team-awesome</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">hard</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">pods</code><code class="p">:</code><code class="w"> </code><code class="calibre15">2</code><code class="w">                   </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO1-1" href="#callout_resource_requirements__limits__and_quotas_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">requests.cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">1</code><code class="s">"</code><code class="w">         </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO1-2" href="#callout_resource_requirements__limits__and_quotas_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">requests.memory</code><code class="p">:</code><code class="w"> </code><code class="calibre15">1024Mi</code><code class="w">   </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO1-3" href="#callout_resource_requirements__limits__and_quotas_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">limits.cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">4</code><code class="s">"</code><code class="w">           </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO1-4" href="#callout_resource_requirements__limits__and_quotas_CO1-3"><img src="Images/3.png" alt="3" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">limits.memory</code><code class="p">:</code><code class="w"> </code><code class="calibre15">4096Mi</code><code class="w">     </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO1-5" href="#callout_resource_requirements__limits__and_quotas_CO1-3"><img src="Images/3.png" alt="3" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_resource_requirements__limits__and_quotas_CO1-1" href="#co_resource_requirements__limits__and_quotas_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Limit the number of Pods to 2.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_resource_requirements__limits__and_quotas_CO1-2" href="#co_resource_requirements__limits__and_quotas_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Define the minimum resources requested across all Pods in a non-terminal state to 1 CPU and 1024Mi of RAM.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_resource_requirements__limits__and_quotas_CO1-3" href="#co_resource_requirements__limits__and_quotas_CO1-4"><img src="Images/3.png" alt="3" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Define the maximum resources used by all Pods in a non-terminal state to 4 CPUs and 4096Mi of RAM.</p></dd>
</dl>

<p class="author1">You’re ready to create a ResourceQuota for the namespace:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create -f awesome-quota.yaml</strong>
resourcequota/awesome-quota created
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Rendering ResourceQuota Details" class="praise"><div class="dedication" id="id368">
<h2 class="calibre33">Rendering ResourceQuota Details</h2>

<p class="author1">You can render a table overview of used resources vs. hard limits using the <code class="calibre15">kubectl describe</code> command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl describe resourcequota awesome-quota -n team-awesome</strong>
Name:            awesome-quota
Namespace:       team-awesome
Resource         Used  Hard
--------         ----  ----
limits.cpu       0     4
limits.memory    0     4Gi
pods             0     2
requests.cpu     0     1
requests.memory  0     1Gi
</pre>

<p class="author1">The Hard column lists the same values you provided with the ResourceQuota definition. Those values won’t change also long as you don’t modify the object’s specification. Under the Used column, you can find the actual aggregate resource consumption within the namespace. At this time, all values are 0 given that no Pods have been created yet.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Exploring a ResourceQuota’s Runtime Behavior" class="praise"><div class="dedication" id="id369">
<h2 class="calibre33">Exploring a ResourceQuota’s Runtime Behavior</h2>

<p class="author1">With the quota rules in place for the namespace <code class="calibre15">team-awesome</code>, we’ll want to see its enforcement in action. We’ll start by creating more than the maximum number of Pods, which is two. To test this, we can create Pods with any definition we like. For example, we use a bare-bones definition that runs the image <code class="calibre15">nginx:1.25.3</code> in the container, as shown in <a data-type="xref" href="#pod_without_resource_requirements" class="calibre10">Example 18-5</a>.</p>
<div id="pod_without_resource_requirements" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-5. </span>A Pod without resource requirements</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre15">team-awesome</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx:1.25.3</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code></pre></div>

<p class="author1">From that YAML definition stored in <em class="calibre3">nginx-pod.yaml</em>, let’s create a Pod and see what happens. In fact, Kubernetes will reject the creation of the object with the following error message:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f nginx-pod.yaml</strong>
Error from server (Forbidden): error when creating "nginx-pod.yaml": \
pods "nginx" is forbidden: failed quota: awesome-quota: must specify \
limits.cpu for: nginx; limits.memory for: nginx; requests.cpu for: \
nginx; requests.memory for: nginx
</pre>

<p class="author1">Because we defined minimum and maximum resource quotas for objects in the namespace, we have to ensure that Pod objects actually define resource requests and limits. Modify the initial definition by updating the instruction under <code class="calibre15">resources</code>, as shown in <a data-type="xref" href="#pod_with_resource_requirements" class="calibre10">Example 18-6</a>.</p>
<div id="pod_with_resource_requirements" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-6. </span>A Pod with resource requirements</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre15">team-awesome</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx:1.25.3</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"0.5"</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"512Mi"</code><code class="w"></code>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1"</code><code class="w"></code>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"1024Mi"</code><code class="w"></code></pre></div>

<p class="author1">We should be able to create two uniquely named Pods—<code class="calibre15">nginx1</code> and <code class="calibre15">nginx2</code>—with that manifest; the combined resource requirements still fit with the boundaries defined in the ResourceQuota:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f nginx-pod1.yaml</strong>
pod/nginx1 created
<strong class="calibre38">$ kubectl apply -f nginx-pod2.yaml</strong>
pod/nginx2 created
<strong class="calibre38">$ kubectl describe resourcequota awesome-quota -n team-awesome</strong>
Name:            awesome-quota
Namespace:       team-awesome
Resource         Used  Hard
--------         ----  ----
limits.cpu       2     4
limits.memory    2Gi   4Gi
pods             2     2
requests.cpu     1     1
requests.memory  1Gi   1Gi
</pre>

<p class="author1">You may be able to imagine what would happen if we tried to create another Pod with the definition of <code class="calibre15">nginx1</code> and <code class="calibre15">nginx2</code>. It will fail for two reasons. The first reason is that we’re not allowed to create a third Pod in the namespace, as the maximum number is set to two. The second reason is that we’d exceed the allotted maximum for <code class="calibre15">requests.cpu</code> and <code class="calibre15">requests.memory</code>. The following error message provides us with this information:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f nginx-pod3.yaml</strong>
Error from server (Forbidden): error when creating "nginx-pod3.yaml": \
pods "nginx3" is forbidden: exceeded quota: awesome-quota, requested: \
pods=1,requests.cpu=500m,requests.memory=512Mi, used: pods=2,requests.cpu=1,\
requests.memory=1Gi, limited: pods=2,requests.cpu=1,requests.memory=1Gi
</pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Working with Limit Ranges" class="praise"><div class="dedication" id="limit_ranges">
<h1 class="calibre17">Working with Limit Ranges</h1>

<p class="author1">In the previous section, you learned how a resource quota can restrict the consumption of resources within a specific namespace in aggregate. For individual Pod objects, the resource quota cannot set any constraints. That’s where the limit range comes in. The enforcement of LimitRange rules happens during the <a href="ch17.xhtml#admission_control_phase" class="calibre10">admission control phase</a> when processing an API request.</p>

<p class="author1">The LimitRange is a Kubernetes primitive that constrains or defaults the resource allocations for specific object types:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Enforces minimum and maximum compute resources usage per Pod or container in a namespace</p>
</li>
<li class="calibre13">
<p class="author1">Enforces minimum and maximum storage request per PersistentVolumeClaim in a namespace</p>
</li>
<li class="calibre13">
<p class="author1">Enforces a ratio between request and limit for a resource in a namespace</p>
</li>
<li class="calibre13">
<p class="author1">Sets default requests/limits for compute resources in a namespace and automatically injects them into containers at runtime</p>
</li>
</ul>
<div data-type="warning" epub:type="warning" class="calibre28"><h1 class="calibre68">Defining more than one LimitRange in a namespace</h1>
<p class="author1">It is best to create only a single LimitRange object per namespace. Default resource requests and limits specified by multiple LimitRange objects in the same namespace causes non-deterministic selection of those rules. Only one of the default definitions will win, but you can’t predict which one.</p>
</div>








<section data-type="sect2" class="praise" data-pdf-bookmark="Creating LimitRanges"><div class="dedication" id="id371">
<h2 class="calibre33">Creating LimitRanges</h2>

<p class="author1">The LimitRange offers a list of configurable constraint attributes. All are described in great detail in the Kubernetes API documentation for a <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#limitrangeitem-v1-core" class="calibre10">LimitRangeSpec</a>. <a data-type="xref" href="#limit_range" class="calibre10">Example 18-7</a> shows a YAML manifest for a LimitRange that uses some of the constraint attributes.</p>
<div id="limit_range" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-7. </span>A limit range defining multiple constraint criteria</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">LimitRange</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">cpu-resource-constraint</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">limits</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Container</code><code class="w">   </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO2-1" href="#callout_resource_requirements__limits__and_quotas_CO2-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">defaultRequest</code><code class="p">:</code><code class="w">   </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO2-2" href="#callout_resource_requirements__limits__and_quotas_CO2-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="calibre15">200m</code><code class="w">
</code><code class="w">    </code><code class="nt">default</code><code class="p">:</code><code class="w">          </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO2-3" href="#callout_resource_requirements__limits__and_quotas_CO2-3"><img src="Images/3.png" alt="3" class="calibre51"/></a><code class="w">
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="calibre15">200m</code><code class="w">
</code><code class="w">    </code><code class="nt">min</code><code class="p">:</code><code class="w">              </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO2-4" href="#callout_resource_requirements__limits__and_quotas_CO2-4"><img src="Images/4.png" alt="4" class="calibre51"/></a><code class="w">
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="calibre15">100m</code><code class="w">
</code><code class="w">    </code><code class="nt">max</code><code class="p">:</code><code class="w">              </code><a class="calibre10" id="co_resource_requirements__limits__and_quotas_CO2-5" href="#callout_resource_requirements__limits__and_quotas_CO2-4"><img src="Images/4.png" alt="4" class="calibre51"/></a><code class="w">
</code><code class="w">      </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">2</code><code class="s">"</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_resource_requirements__limits__and_quotas_CO2-1" href="#co_resource_requirements__limits__and_quotas_CO2-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The context to apply the constraints to. In this case, to a container running in a Pod.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_resource_requirements__limits__and_quotas_CO2-2" href="#co_resource_requirements__limits__and_quotas_CO2-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The default CPU resource request value assigned to a container if not provided.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_resource_requirements__limits__and_quotas_CO2-3" href="#co_resource_requirements__limits__and_quotas_CO2-3"><img src="Images/3.png" alt="3" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The default CPU resource limit value assigned to a container if not provided.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_resource_requirements__limits__and_quotas_CO2-4" href="#co_resource_requirements__limits__and_quotas_CO2-4"><img src="Images/4.png" alt="4" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The minimum and maximum CPU resource request and limit value assignable to a container.</p></dd>
</dl>

<p class="author1">As usual, we can create an object from the manifest with the <code class="calibre15">kubectl create</code> or <code class="calibre15">kubectl apply</code> command. The definition of the LimitRange has been stored in the file <em class="calibre3">cpu-resource-constraint-limitrange.yaml</em>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f cpu-resource-constraint.yaml</strong>
limitrange/cpu-resource-constraint created
</pre>

<p class="author1">The constraints will be applied automatically when creating new objects. Changing the constraints for an existing LimitRange object won’t have any effect on already running Pods.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Rendering LimitRange Details" class="praise"><div class="dedication" id="id372">
<h2 class="calibre33">Rendering LimitRange Details</h2>

<p class="author1">Live LimitRange objects can be inspected using the <code class="calibre15">kubectl describe</code> command. The following command renders the details of the LimitRange object named <code class="calibre15">cpu-resource-constraint</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl describe limitrange cpu-resource-constraint</strong>
Name:       cpu-resource-constraint
Namespace:  default
Type        Resource  Min   Max  Default Request  Default Limit   ...
----        --------  ---   ---  ---------------  -------------
Container   cpu       100m  2    200m             200m            ...
</pre>

<p class="author1">The output of the command renders each limit constraint on a single line. Any constraint attribute that has not been set explicitly by the object will show a dash character (<code class="calibre15">-</code>) as the assigned value.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Exploring a LimitRange’s Runtime Behavior" class="praise"><div class="dedication" id="id373">
<h2 class="calibre33">Exploring a LimitRange’s Runtime Behavior</h2>

<p class="author1">Let’s demonstrate what effect the LimitRange has on the creation of Pods. We will walk through two different use cases:</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Automatically setting resource requirements if they have not been provided by the Pod definition.</p>
</li>
<li class="calibre56">
<p class="author1">Preventing the creation of a Pod if the declared resource requirements are forbidden by the LimitRange.</p>
</li>

</ol>










<section data-type="sect3" data-pdf-bookmark="Setting default resource requirements" class="praise"><div class="dedication" id="id374">
<h3 class="calibre44">Setting default resource requirements</h3>

<p class="author1">The LimitRange defines a default CPU resource request of 200m and a default CPU resource limit of 200m. That means if a Pod is about to be created, and it doesn’t define a CPU resource request and limit, the LimitRange will automatically assign the default values.</p>

<p class="author1"><a data-type="xref" href="#pod_no_resource_requirements" class="calibre10">Example 18-8</a> shows a Pod definition without resource requirements.</p>
<div id="pod_no_resource_requirements" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-8. </span>A Pod defining no resource requirements</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx-without-resource-requirements</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx:1.25.3</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code></pre></div>

<p class="author1">Creating the object from the contents stored in the file <em class="calibre3">nginx-without-resource-requirements.yaml</em> will work as expected:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f nginx-without-resource-requirements.yaml</strong>
pod/nginx-without-resource-requirements created
</pre>

<p class="author1">The Pod object will be mutated in two ways. First, the default resource requirements set by the LimitRange are applied. Second, an annotation with the key <code class="calibre15">kubernetes.io/limit-ranger</code> will be added that provides meta information on what has been changed. You can find both pieces of information in the output of the <code class="calibre15">describe</code> command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl describe pod nginx-without-resource-requirements</strong>
...
Annotations:      kubernetes.io/limit-ranger: LimitRanger plugin set: cpu \
request for container nginx; cpu limit for container nginx
...
Containers:
  nginx:
    ...
    Limits:
      cpu: 200m
    Requests:
      cpu: 200m
...
</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Enforcing resource requirements" class="praise"><div class="dedication" id="id375">
<h3 class="calibre44">Enforcing resource requirements</h3>

<p class="author1">The LimitRange can enforce resource limits as well. For the LimitRange object we created earlier, the minimum amount of CPU was set to 100m, and the maximum amount of CPU was set to 2. To see the enforcement behavior in action, we’ll create a new Pod as shown in <a data-type="xref" href="#pod_with_resource_requirements2" class="calibre10">Example 18-9</a>.</p>
<div id="pod_with_resource_requirements2" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 18-9. </span>A Pod defining CPU resource requests and limits</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx-with-resource-requirements</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx:1.25.3</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"50m"</code><code class="w"></code>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"3"</code><code class="w"></code></pre></div>

<p class="author1">The resource requirements of this Pod do not follow the constraints expected by the LimitRange object. The CPU resource request is less than 100m, and the CPU resource limit is higher than 2. As a result, the object won’t be created and an appropriate error message will be rendered:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f nginx-with-resource-requirements.yaml</strong>
Error from server (Forbidden): error when creating "nginx-with-resource-\
requirements.yaml": pods "nginx-with-resource-requirements" is forbidden: \
[minimum cpu usage per Container is 100 m, but request is 50 m, maximum cpu \
usage per Container is 2, but limit is 3]
</pre>

<p class="author1">The error message provides some guidance on expected resource definitions. Unfortunately, the message doesn’t point to the name of the LimitRange object enforcing those expectations. Proactively check if a LimitRange object has been created for the namespace and what parameters have been set using <code class="calibre15">kubectl get limitranges</code>.</p>
</div></section>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id376">
<h1 class="calibre17">Summary</h1>

<p class="author1">Resource requests are one of the many factors that the kube-scheduler algorithm 
<span class="keep-together">considers</span> when making decisions on which node a Pod can be scheduled. A 
<span class="keep-together">container</span> can specify requests using <code class="calibre15">spec.containers[].resources.requests</code>. 
<span class="keep-together">The scheduler</span> chooses a node based on its available hardware capacity. The resource limits ensure that the container cannot consume more than the allotted resource amounts. Limits can be defined for a container using the attribute <code class="calibre15">spec.con⁠tainers[].resources.limits</code>. Should an application consume more than the allowed amount of resources (e.g., due to a memory leak in the implementation), the container runtime will likely terminate the application process.</p>

<p class="author1">A resource quota defines the computing resources (e.g., CPU, RAM, and ephemeral storage) available to a namespace to prevent unbounded consumption by Pods running it. Accordingly, Pods have to work within those resource boundaries by declaring their minimum and maximum resource expectations. You can also limit the number of resource types (like Pods, Secrets, or ConfigMaps) that are allowed to be created. The Kubernetes scheduler will enforce those boundaries upon a request for object creation.</p>

<p class="author1">The limit range is different from the ResourceQuota in that it defines resource constraints for a single object of a specific type. It can also help with governance for objects by specifying resource default values that should be applied automatically should the API create request not provide the information.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id377">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Experience the effects of resource requirements on scheduling and autoscaling</dt>
<dd class="calibre20">
<p class="calibre21">A container defined by a Pod can specify resource requests and limits. Work through scenarios where you define those requirements individually and together for single- and multi-container Pods. Upon creation of the Pod, you should be able to see the effects on scheduling the object on a node. Furthermore, practice how to identify the available resource capacity of a node.</p>
</dd>
<dt class="calibre19">Understand the purpose and runtime effects of resource quotas</dt>
<dd class="calibre20">
<p class="calibre21">A ResourceQuota defines the resource boundaries for objects living within a namespace. The most commonly used boundaries apply to computing resources. Practice defining them and understand their effect on the creation of Pods. It’s important to know the command for listing the hard requirements of a 
<span class="keep-together">ResourceQuota</span> and the resources currently in use. You will find that a ResourceQuota offers other options. Discover them in more detail for a broader exposure to the topic.</p>
</dd>
<dt class="calibre19">Understand the purpose and runtime effects of limit ranges</dt>
<dd class="calibre20">
<p class="calibre21">A LimitRange can specify resource constraints and defaults of specific primitives. Should you run into a situation where you receive an error message upon creation of an object, check if a limit range object enforces those constraints. Unfortunately, the error message does not point out the object that enforces it so you may have to proactively list LimitRange objects to identify the constraints.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id378">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_014.xhtml#appendix_a_resource_requirements_limits_quotas" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">You have been tasked with creating a Pod for running an application in a container. During application development, you ran a load test for figuring out the minimum amount of resources needed and the maximum amount of resources the application is allowed to grow to. Define those resource requests and limits for the Pod.</p>

<p class="author1">Define a Pod named <code class="calibre15">hello-world</code> running the container image <code class="calibre15">bmuschko/nodejs-hello-world:1.0.0</code>. The container exposes the port 3000.</p>

<p class="author1">Add a Volume of type <code class="calibre15">emptyDir</code> and mount it in the container path <code class="calibre15">/var/log</code>.</p>

<p class="author1">For the container, specify the following minimum number of resources:</p>
<ul class="printings">
<li class="calibre13">
<p class="author1">CPU: 100m</p>
</li>
<li class="calibre13">
<p class="author1">Memory: 500Mi</p>
</li>
<li class="calibre13">
<p class="author1">Ephemeral storage: 1Gi</p>
</li>
</ul>

<p class="author1">For the container, specify the following maximum number of resources:</p>
<ul class="printings">
<li class="calibre13">
<p class="author1">Memory: 500Mi</p>
</li>
<li class="calibre13">
<p class="author1">Ephemeral storage: 2Gi</p>
</li>
</ul>

<p class="author1">Create the Pod from the YAML manifest. Inspect the Pod details. Which node does the Pod run on?</p>
</li>
<li class="calibre56">
<p class="author1">In this exercise, you will create a resource quota with specific CPU and memory limits for a new namespace. Pods created in the namespace will have to adhere to those limits.</p>

<p class="author1">Create a ResourceQuota named <code class="calibre15">app</code> under the namespace <code class="calibre15">rq-demo</code> using the following YAML definition in the file <em class="calibre3">resourcequota.yaml</em>:</p>

<pre data-type="programlisting" data-code-language="yaml" class="calibre37"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ResourceQuota</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">app</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">hard</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="nt">pods</code><code class="p">:</code><code class="w"> </code><code class="s">"2"</code><code class="w"></code>
<code class="w">    </code><code class="nt">requests.cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"2"</code><code class="w"></code>
<code class="w">    </code><code class="nt">requests.memory</code><code class="p">:</code><code class="w"> </code><code class="calibre15">500Mi</code><code class="w"></code></pre>

<p class="author1">Create a new Pod that exceeds the limits of the resource quota requirements, e.g., by defining 1Gi of memory but stays below the CPU, e.g., 0.5. Write down the error message.</p>

<p class="author1">Change the request limits to fulfill the requirements to ensure that the Pod can be created successfully. Write down the output of the command that renders the used amount of resources for the namespace.</p>
</li>
<li class="calibre56">
<p class="author1">A LimitRange can restrict resource consumption for Pods in a namespace, and assign default computing resources if no resource requirements have been defined. You will practice the effects of a LimitRange on the creation of a Pod in different scenarios.</p>

<p class="author1">Navigate to the directory <em class="calibre3">app-a/ch18/limitrange</em> of the checked-out GitHub repository <a href="https://github.com/bmuschko/ckad-study-guide" class="calibre10"><em class="calibre3">bmuschko/ckad-study-guide</em></a>. Inspect the YAML manifest definition in the file <em class="calibre3">setup.yaml</em>. Create the objects from the YAML manifest file.</p>

<p class="author1">Create a new Pod named <code class="calibre15">pod-without-resource-requirements</code> in the namespace <code class="calibre15">d92</code> that uses the container image <code class="calibre15">nginx:1.23.4-alpine</code> without any resource requirements. Inspect the Pod details. What resource definitions do you expect to be assigned?</p>

<p class="author1">Create a new Pod named <code class="calibre15">pod-with-more-cpu-resource-requirements</code> in the namespace <code class="calibre15">d92</code> that uses the container image <code class="calibre15">nginx:1.23.4-alpine</code> with a CPU resource request of 400m and limits of 1.5. What runtime behavior do you expect to see?</p>

<p class="author1">Create a new Pod named <code class="calibre15">pod-with-less-cpu-resource-requirements</code> in the namespace <code class="calibre15">d92</code> that uses the container image <code class="calibre15">nginx:1.23.4-alpine</code> with a CPU resource request of 350m and limits of 400m. What runtime behavior do you expect to see?</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>