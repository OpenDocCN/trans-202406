- en: 'Chapter 9\. Life and Death of an Object: Constructors and Garbage Collection'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0237-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Objects are born and objects die.** You’re in charge of an object’s lifecycle.
    You decide when and how to **construct** it. You decide when to **destroy** it.
    Except you don’t actually *destroy* the object yourself, you simply *abandon*
    it. But once it’s abandoned, the heartless **Garbage Collector (gc)** can vaporize
    it, reclaiming the memory that object was using. If you’re gonna write Java, you’re
    gonna create objects. Sooner or later, you’re gonna have to let some of them go,
    or risk running out of RAM. In this chapter we look at how objects are created,
    where they live while they’re alive, and how to keep or abandon them efficiently.
    That means we’ll talk about the heap, the stack, scope, constructors, superclass
    constructors, null references, and more. Warning: this chapter contains material
    about object death that some may find disturbing. Best not to get too attached.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Stack and the Heap: where things live'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can understand what really happens when you create an object, we have
    to step back a bit. We need to learn more about where everything lives (and for
    how long) in Java. That means we need to learn more about two areas of memory—the
    Stack and the Heap. When a JVM starts up, it gets a chunk of memory from the underlying
    OS and uses it to run your Java program. How *much* memory, and whether or not
    you can tweak it, is dependent on which version of the JVM (and on which platform)
    you’re running. But usually you *won’t* have any say in the matter. And with good
    programming, you probably won’t care (more on that a little later).
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we (programmers) care about the area of memory where objects live (the
    heap) and the one where method invocations and local variables live (the stack).
  prefs: []
  type: TYPE_NORMAL
- en: We know that all *objects* live on the garbage-collectible heap, but we haven’t
    yet looked at where *variables* live. And where a variable lives depends on what
    *kind* of variable it is. And by “kind,” we don’t mean *type* (i.e., primitive
    or object reference). The two *kinds* of variables whose lives we care about now
    are *instance* variables and *local* variables. Local variables are also known
    as *stack* variables, which is a big clue for where they live.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Stack**'
  prefs: []
  type: TYPE_NORMAL
- en: Where method invocations and local variables live
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0238-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The Heap**'
  prefs: []
  type: TYPE_NORMAL
- en: Where ***ALL*** objects live
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0238-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Methods are stacked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0239-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you call a method, the method lands on the top of a call stack. That new
    thing that’s actually pushed onto the stack is the stack *frame*, and it holds
    the state of the method including which line of code is executing, and the values
    of all local variables.
  prefs: []
  type: TYPE_NORMAL
- en: The method at the *top* of the stack is always the currently running method
    for that stack (for now, assume there’s only one stack, but in [Chapter 14](ch14.xhtml#a_very_graphic_story_getting_gui),
    *A Very Graphic Story*, we’ll add more.) A method stays on the stack until the
    method hits its closing curly brace (which means the method’s done). If method
    foo() calls method bar(), method bar() is stacked on top of method foo().
  prefs: []
  type: TYPE_NORMAL
- en: A call stack with two methods
  prefs: []
  type: TYPE_NORMAL
- en: '**The method on the top of the stack is always the currently executing method.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A stack scenario
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code on the left is a snippet (we don’t care what the rest of the class
    looks like) with three methods. The first method (doStuff()) calls the second
    method (go()), and the second method calls the third (crazy()). Each method declares
    one local variable within the body of the method (*b*, *z*, and *c*), and method
    go() also declares a parameter variable (which means go() has two local variables,
    *x* and *z*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Code from another class calls `**doStuff(),**` and
    `**doStuff()**` goes into a stack frame at the top of the stack. The boolean variable
    named **“b”** goes on the `**doStuff()**` stack frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0239-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) `**doStuff()**` calls `**go()**`, and `**go()**` is
    *pushed* on top of the stack. Variables “`**x**`” and “`**z**`” are in the `**go()**`
    stack frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0239-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) `go()` calls `crazy(), crazy()` is now on the top of
    the stack, with variable `“c”` in the frame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0239-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4.png) `crazy()` completes, and its stack frame is *popped*
    off the stack. Execution goes back to the `**go()**` method and picks up at the
    line following the call to **`crazy().`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0239-06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: What about local variables that are objects?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember, a non-primitive variable holds a reference to an object, not the object
    itself. You already know where objects live—on the heap. It doesn’t matter where
    they’re declared or created. ***If the local variable is a reference to an object,
    only the variable (the reference/remote control) goes on the stack.***
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0240-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If local variables live on the stack, where do instance variables live?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you say new CellPhone(), Java has to make space on the Heap for that CellPhone.
    But how *much* space? Enough for the object, which means enough to house all of
    the object’s instance variables. That’s right, instance variables live on the
    Heap, *inside* the object they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that the *values* of an object’s instance variables live inside the
    object. If the instance variables are all primitives, Java makes space for the
    instance variables based on the primitive type. An int needs 32 bits, a long 64
    bits, etc. Java doesn’t care about the value inside primitive variables; the bit-size
    of an int variable is the same (32 bits) whether the value of the int is 32,000,000
    or 32.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the instance variables are *objects*? What if CellPhone HAS-A Antenna?
    In other words, CellPhone has a reference variable of type Antenna.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the new object has instance variables that are object references rather
    than primitives, the real question is: does the object need space for all of the
    objects it holds references to? The answer is, *not exactly*. No matter what,
    Java has to make space for the instance variable values. But remember that a reference
    variable value is not the whole *object*, but merely a *remote control* to the
    object. So if CellPhone has an instance variable declared as the non-primitive
    type Antenna, Java makes space within the CellPhone object only for the Antenna’s
    *remote control* (i.e., reference variable) but not the Antenna *object.*'
  prefs: []
  type: TYPE_NORMAL
- en: Well, then, when does the Antenna *object* get space on the Heap? First we have
    to find out *when* the Antenna object itself is created. That depends on the instance
    variable declaration. If the instance variable is declared but no object is assigned
    to it, then only the space for the reference variable (the remote control) is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: No actual Antenna object is made on the heap unless or until the reference variable
    is assigned a new Antenna object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0241-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Object with two primitive instance variables. Space for the variables lives
    in the object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0241-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Object with one non-primitive instance variable—a reference to an Antenna object,
    but no actual Antenna object. This is what you get if you declare the variable
    but don’t initialize it with an actual Antenna object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0241-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Object with one non-primitive instance variable, and the Antenna variable is
    assigned a new Antenna object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The miracle of object creation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you know where variables and objects live, we can dive into the mysterious
    world of object creation. Remember the three steps of object declaration and assignment:
    declare a reference variable, create an object, and assign the object to the reference.'
  prefs: []
  type: TYPE_NORMAL
- en: But until now, step two—where a miracle occurs and the new object is “born”—has
    remained a Big Mystery. Prepare to learn the facts of object life. *Hope you’re
    not squeamish.*
  prefs: []
  type: TYPE_NORMAL
- en: '**Let’s review the 3 steps of object declaration, creation and assignment:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0242-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Are we calling a method named Duck()? Because it sure *looks* like it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0243-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**No.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**We’re calling the Duck *constructor.***'
  prefs: []
  type: TYPE_NORMAL
- en: A constructor *does* look and feel a lot like a method, but it’s not a method.
    It’s got the code that runs when you say `new.` In other words, *the code that
    runs when you instantiate an object.*
  prefs: []
  type: TYPE_NORMAL
- en: The only way to invoke a constructor is with the keyword `new` followed by the
    class name. The JVM finds that class and invokes the constructor in that class.
    (OK, technically this isn’t the *only* way to invoke a constructor. But it’s the
    only way to do it from *outside* a constructor. You *can* call a constructor from
    within another constructor, with restrictions, but we’ll get into all that later
    in the chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: '**But where is the constructor?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If we didn’t write it, who did?**'
  prefs: []
  type: TYPE_NORMAL
- en: You can write a constructor for your class (we’re about to do that), but if
    you don’t, ***the compiler writes one for you!***
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the compiler’s default constructor looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Notice something missing? How is this different from a method?**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0243-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Construct a Duck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0244-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The key feature of a constructor is that it runs *before* the object can be
    assigned to a reference. That means you get a chance to step in and do things
    to get the object ready for use. In other words, before anyone can use the remote
    control for an object, the object has a chance to help construct itself. In our
    Duck constructor, we’re not doing anything useful, just demonstrating the sequence
    of events.
  prefs: []
  type: TYPE_NORMAL
- en: '**The constructor gives you a chance to step into the middle of `new.`**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0244-02.png)![image](Images/f0244-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Yours to solve.**'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the state of a new Duck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most people use constructors to initialize the state of an object. In other
    words, to make and assign values to the object’s instance variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That’s all well and good when the Duck class *developer* knows how big the Duck
    object should be. But what if we want the programmer who is *using* Duck to decide
    how big a particular Duck should be?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine the Duck has a size instance variable, and you want the programmer using
    your Duck class to set the size of the new Duck. How could you do it?
  prefs: []
  type: TYPE_NORMAL
- en: Well, you could add a setSize() setter method to the class. But that leaves
    the Duck temporarily without a size* and forces the Duck user to write *two* statements—one
    to create the Duck, and one to call the setSize() method. The code below uses
    a setter method to set the initial size of the new Duck.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0245-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Instance variables do have a default value. 0 or 0.0 for numeric primitives,
    false for booleans, and null for references.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the constructor to initialize important Duck state*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0246-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If an object shouldn’t be used until one or more parts of its state (instance
    variables) have been initialized, don’t let anyone get hold of a Duck object until
    you’re finished initializing! It’s usually way too risky to let someone make—and
    get a reference to—a new Duck object that isn’t quite ready for use until that
    someone turns around and calls the setSize() method. How will the Duck user even
    *know* that he’s required to call the setter method after making the new Duck?
  prefs: []
  type: TYPE_NORMAL
- en: The best place to put initialization code is in the constructor. And all you
    need to do is make a constructor with arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0246-02.png)![image](Images/f0246-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '*Not to imply that not all Duck state is not unimportant.'
  prefs: []
  type: TYPE_NORMAL
- en: Make it easy to make a Duck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be sure you have a no-arg constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What happens if the Duck constructor takes an argument? Think about it. On the
    previous page, there’s only *one* Duck constructor—and it takes an int argument
    for the size of the Duck. That might not be a big problem, but it does make it
    harder for a programmer to create a new Duck object, especially if the programmer
    doesn’t *know* what the size of a Duck should be. Wouldn’t it be helpful to have
    a default size for a Duck so that if the user doesn’t know an appropriate size,
    they can still make a Duck that works?
  prefs: []
  type: TYPE_NORMAL
- en: '***Imagine that you want Duck users to have TWO options for making a Duck—one
    where they supply the Duck size (as the constructor argument) and one where they
    don’t specify a size and thus get your default Duck size.***'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t do this cleanly with just a single constructor. Remember, if a method
    (or constructor—same rules) has a parameter, you *must* pass an appropriate argument
    when you invoke that method or constructor. You can’t just say, “If someone doesn’t
    pass anything to the constructor, then use the default size” because they won’t
    even be able to compile without sending an int argument to the constructor call.
    You *could* do something clunky like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0247-01.png)'
  prefs: []
  type: TYPE_IMG
- en: But that means the programmer making a new Duck object has to *know* that passing
    a “0” is the protocol for getting the default Duck size. Pretty ugly. What if
    the other programmer doesn’t know that? Or what if they really *do* want a zero-sized
    Duck? (Assuming a zerosized Duck is allowed. If you don’t want zero-sized Duck
    objects, put validation code in the constructor to prevent it.) The point is,
    it might not always be possible to distinguish between a genuine “I want zero
    for the size” constructor argument and a “I’m sending zero so you’ll give me the
    default size, whatever that is” constructor argument.
  prefs: []
  type: TYPE_NORMAL
- en: Doesn’t the compiler always make a no-arg constructor for you? No!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0248-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You might think that if you write *only* a constructor with arguments, the compiler
    will see that you don’t have a no-arg constructor and stick one in for you. But
    that’s not how it works. The compiler gets involved with constructor-making *only
    if you don’t say anything at all about constructors.*
  prefs: []
  type: TYPE_NORMAL
- en: '**If you write a constructor that takes arguments and you *still* want a no-arg
    constructor, you’ll have to build the no-arg constructor yourself!**'
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you provide a constructor, ANY kind of constructor, the compiler
    backs off and says, “OK fair enough, looks like you’re in charge of constructors
    now.”
  prefs: []
  type: TYPE_NORMAL
- en: '**If you have more than one constructor in a class, the constructors MUST have
    different argument lists.**'
  prefs: []
  type: TYPE_NORMAL
- en: The argument list includes the order and types of the arguments. As long as
    they’re different, you can have more than one constructor. You can do this with
    methods as well, but we’ll get to that in another chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Overloaded constructors means you have more than one constructor in your
    class.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**To compile, each constructor must have a *different* argument list!**'
  prefs: []
  type: TYPE_NORMAL
- en: The class below is legal because all five constructors have different argument
    lists. If you had two constructors that took only an int, for example, the class
    wouldn’t compile. What you name the parameter variable doesn’t count. It’s the
    variable *type* (int, Dog, etc.) and *order* that matters. You *can* have two
    constructors that have identical types, ***as long as the order is different.***
    A constructor that takes a String followed by an int is not the same as one that
    takes an int followed by a String.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0249-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Nanoreview: four things to remember about constructors'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) A constructor is the code that runs when somebody says
    `new` on a class type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/2.png) A constructor must have the same name as the class,
    and `**no**` return type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3.png) If you don’t put a constructor in your class, the compiler
    puts in a default constructor. The default constructor is always a no-arg constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/4.png) You can have more than one constructor in your class,
    as long as the argument lists are different. Having more than one constructor
    in a class means you have overloaded constructors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Doing all the Brain Power exercises has been shown to produce a 42% increase
    in neuron size. And you know what they say, “Big neurons...”'
  prefs: []
  type: TYPE_NORMAL
- en: Wait a minute...we never DID talk about superclasses and inheritance and how
    that all fits in with constructors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here’s where it gets fun. Remember in the previous chapter we looked at the
    Snowboard object wrapping around an inner core representing the Object portion
    of the Snowboard class? The Big Point there was that every object holds not just
    its *own* declared instance variables, but also *everything from its superclasses*
    (which, at a minimum, means class Object, since *every* class extends Object).
  prefs: []
  type: TYPE_NORMAL
- en: So when an object is created (because somebody said `new`; there is ***no other
    way*** to create an object other than someone, somewhere saying `**new**` on the
    class type), the object gets space for *all* the instance variables, from all
    the way up the inheritance tree. Think about it for a moment... a superclass might
    have setter methods encapsulating a private variable. But that variable has to
    live *somewhere*. When an object is created, it’s almost as though *multiple*
    objects materialize—the object being new’d and one object per each superclass.
    Conceptually, though, it’s much better to think of it like the picture below,
    where the object being created has *layers* of itself representing each superclass.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0252-01.png)![image](Images/f0252-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The role of superclass constructors in an object’s life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0253-01.png)![image](Images/f0253-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '***All the constructors in an object’s inheritance tree must run when you make
    a new object.***'
  prefs: []
  type: TYPE_NORMAL
- en: Let that sink in.
  prefs: []
  type: TYPE_NORMAL
- en: That means every superclass has a constructor (because every class has a constructor),
    and each constructor up the hierarchy runs at the time an object of a subclass
    is created.
  prefs: []
  type: TYPE_NORMAL
- en: Saying `**new**` is a Big Deal. It starts the whole constructor chain reaction.
    And yes, even abstract classes have constructors. Although you can never say new
    on an abstract class, an abstract class is still a superclass, so its constructor
    runs when someone makes an instance of a concrete subclass.
  prefs: []
  type: TYPE_NORMAL
- en: The superclass constructors run to build out the superclass parts of the object.
    Remember, a subclass might inherit methods that depend on superclass state (in
    other words, the value of instance variables in the superclass). For an object
    to be fully formed, all the superclass parts of itself *must* be fully formed,
    and that’s why the superclass constructor must run. All instance variables from
    every class in the inheritance tree have to be declared and initialized. Even
    if Animal has instance variables that Hippo doesn’t inherit (if the variables
    are private, for example), the Hippo still depends on the Animal methods that
    *use* those variables.
  prefs: []
  type: TYPE_NORMAL
- en: When a constructor runs, it immediately calls its superclass constructor, all
    the way up the chain until you get to the class Object constructor.
  prefs: []
  type: TYPE_NORMAL
- en: On the next few pages, you’ll learn how superclass constructors are called,
    and how you can call them yourself. You’ll also learn what to do if your superclass
    constructor has arguments!
  prefs: []
  type: TYPE_NORMAL
- en: '**A new Hippo object also IS-A Animal and IS-A Object. If you want to make
    a Hippo, you must also make the Animal and Object parts of the Hippo.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**This all happens in a process called Constructor Chaining.**'
  prefs: []
  type: TYPE_NORMAL
- en: Making a Hippo means making the Animal and Object parts too...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0254-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Given the class hierarchy in the code above, we can step through the process
    of creating a new Hippo object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Code from another class calls new `**Hippo()**`, and
    the `**Hippo()**` constructor goes into a stack frame at the top of the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0254-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) `**Hippo()**` invokes the superclass constructor, which
    pushes the `**Animal()**` constructor onto the top of the stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0254-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) `**Animal()**` invokes the superclass constructor,
    which pushes the `**Object()**` constructor onto the top of the stack, since Object
    is the superclass of Animal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0254-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4.png) `**Object()**` completes, and its stack frame is popped
    off the stack. Execution goes back to the `**Animal()**` constructor and picks
    up at the line following Animal’s call to its superclass constructor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0254-06.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The first one, A. The Hippo() constructor is invoked first, but it’s the Animal
    constructor that finishes first.
  prefs: []
  type: TYPE_NORMAL
- en: '*How* do you invoke a superclass constructor?'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might think that somewhere in, say, a Duck constructor, if Duck extends
    Animal you’d call Animal(). But that’s not how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0255-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The only way to call a superclass constructor is by calling ***super().*** That’s
    right—***super()*** calls the ***superclass constructor.***
  prefs: []
  type: TYPE_NORMAL
- en: What are the odds?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0255-02.png)'
  prefs: []
  type: TYPE_IMG
- en: A call to super() in your constructor puts the superclass constructor on the
    top of the Stack. And what do you think that superclass constructor does? *Calls
    its superclass constructor.* And so it goes until the Object constructor is on
    the top of the Stack. Once Object() finishes, it’s popped off the Stack, and the
    next thing down the Stack (the subclass constructor that called Object()) is now
    on top. *That* constructor finishes and so it goes until the original constructor
    is on the top of the Stack, where it can now finish.
  prefs: []
  type: TYPE_NORMAL
- en: Can the child exist before the parents?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0256-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If you think of a superclass as the parent to the subclass child, you can figure
    out which has to exist first. ***The superclass parts of an object have to be
    fully formed (completely built) before the subclass parts can be constructed.***
    Remember, the subclass object might depend on things it inherits from the superclass,
    so it’s important that those inherited things be finished. No way around it. The
    superclass constructor must finish before its subclass constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the Stack series in [“Making a Hippo means making the Animal and Object
    parts too...”](#making_a_hippo_means_making_the_animal_a) again, and you can see
    that while the Hippo constructor is the *first* to be invoked (it’s the first
    thing on the Stack), it’s the *last* one to complete! Each subclass constructor
    immediately invokes its own superclass constructor, until the Object constructor
    is on the top of the Stack. Then Object’s constructor completes, and we bounce
    back down the Stack to Animal’s constructor. Only after Animal’s constructor completes
    do we finally come back down to finish the rest of the Hippo constructor. For
    that reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The call to super() must be the *first* statement in each constructor!***'
  prefs: []
  type: TYPE_NORMAL
- en: '*There’s an exception to this rule; you’ll learn it in [“Invoking one overloaded
    constructor from another”](#invoking_one_overloaded_constructor_from).'
  prefs: []
  type: TYPE_NORMAL
- en: Superclass constructors with arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if the superclass constructor has arguments? Can you pass something in
    to the super() call? Of course. If you couldn’t, you’d never be able to extend
    a class that didn’t have a no-arg constructor. Imagine this scenario: all animals
    have a name. There’s a getName() method in class Animal that returns the value
    of the name instance variable. The instance variable is marked private, but the
    subclass (in this case, Hippo) inherits the getName() method. So here’s the problem:
    Hippo has a getName() method (through inheritance) but does not have the name
    instance variable. Hippo has to depend on the Animal part of himself to keep the
    name instance variable, and return it when someone calls getName() on a Hippo
    object. But...how does the Animal part get the name? The only reference Hippo
    has to the Animal part of himself is through super(), so that’s the place where
    Hippo sends the Hippo’s name up to the Animal part of himself, so that the Animal
    part can store it in the private name instance variable.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0257-01.png)![image](Images/f0257-02.png)![image](Images/f0257-03.png)![image](Images/f0257-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Invoking one overloaded constructor from another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0258-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'What if you have overloaded constructors that, with the exception of handling
    different argument types, all do the same thing? You know that you don’t want
    *duplicate* code sitting in each of the constructors (pain to maintain, etc.),
    so you’d like to put the bulk of the constructor code (including the call to super())
    in only *one* of the overloaded constructors. You want whichever constructor is
    first invoked to call The Real Constructor and let The Real Constructor finish
    the job of construction. It’s simple: just say *this()*. Or *this(aString)*. Or
    *this(27, x)*. In other words, just imagine that the keyword *this* is a reference
    to **the current object.**'
  prefs: []
  type: TYPE_NORMAL
- en: You can say *this()* only within a constructor, and it must be the first statement
    in the constructor!
  prefs: []
  type: TYPE_NORMAL
- en: But that’s a problem, isn’t it? Earlier we said that super() must be the first
    statement in the constructor. Well, that means you get a choice.
  prefs: []
  type: TYPE_NORMAL
- en: '**Every constructor can have a call to super() or this(), but never both!**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll need to choose which to call based on which values you have, which ones
    you need to set, and which constructors are provided in this class or the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0258-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we know how an object is born, but how long does an object *live*?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An *object’s* life depends entirely on the life of references referring to it.
    If the reference is considered “alive,” the object is still alive on the Heap.
    If the reference dies (and we’ll look at what that means in just a moment), the
    object will die.
  prefs: []
  type: TYPE_NORMAL
- en: '**So if an object’s life depends on the reference variable’s life, how long
    does a *variable* live?**'
  prefs: []
  type: TYPE_NORMAL
- en: That depends on whether the variable is a *local* variable or an *instance*
    variable. The code below shows the life of a local variable. In the example, the
    variable is a primitive, but variable lifetime is the same whether it’s a primitive
    or reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0260-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The difference between life and scope for local variables:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Life**'
  prefs: []
  type: TYPE_NORMAL
- en: A local variable is *alive* as long as its Stack frame is on the Stack. In other
    words, *until the method completes.*
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope**'
  prefs: []
  type: TYPE_NORMAL
- en: A local variable is in *scope* only within the method in which the variable
    was declared. When its own method calls another, the variable is alive, but not
    in scope until its method resumes. ***You can use a variable only when it is in
    scope.***
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through what happens on the stack when something calls the doStuff()
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0261-01.png)![image](Images/f0261-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1circle.png) ***doStuff()* goes on the Stack. Variable “b”
    is alive and in scope.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0261-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/2circle.png) ***go()* plops on top of the Stack. “x” and “z”
    are alive and in scope, and “b” is alive but not in scope.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0261-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/3circle.png) ***crazy()* is pushed onto the Stack, with “c”
    now alive and in scope. The other three variables are alive but out of scope.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0261-05.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/4circle.png) ***crazy()* completes and is popped off the Stack,
    so ‘c’ is out of scope and dead. When go() resumes where it left off, “x” and
    “x” are both alive and back in scope. Variable “b” is still alive but out of scope
    (until go() completes).**'
  prefs: []
  type: TYPE_NORMAL
- en: While a local variable is alive, its state persists. As long as method doStuff()
    is on the Stack, for example, the “b” variable keeps its value. But the “b” variable
    can be used only while doStuff()’s Stack frame is at the top. In other words,
    you can use a local variable *only* while that local variable’s method is actually
    running (as opposed to waiting for higher Stack frames to complete).
  prefs: []
  type: TYPE_NORMAL
- en: What about reference variables?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rules are the same for primitives and references. A reference variable
    can be used only when it’s in scope, which means you can’t use an object’s remote
    control unless you’ve got a reference variable that’s in scope. The *real* question
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**“How does *variable* life affect *object* life?”**'
  prefs: []
  type: TYPE_NORMAL
- en: An object is alive as long as there are live references to it. If a reference
    variable goes out of scope but is still alive, the object it *refers* to is still
    alive on the Heap. And then you have to ask...“What happens when the Stack frame
    holding the reference gets popped off the Stack at the end of the method?”
  prefs: []
  type: TYPE_NORMAL
- en: If that was the *only* live reference to the object, the object is now abandoned
    on the Heap. The reference variable disintegrated with the Stack frame, so the
    abandoned object is now, *officially*, toast. The trick is to know the point at
    which an object becomes ***eligible for garbage collection.***
  prefs: []
  type: TYPE_NORMAL
- en: Once an object is eligible for garbage collection (GC), you don’t have to worry
    about reclaiming the memory that object was using. If your program gets low on
    memory, GC will destroy some or all of the eligible objects, to keep you from
    running out of RAM. You can still run out of memory, but *not* before all eligible
    objects have been hauled off to the dump. Your job is to make sure that you abandon
    objects (i.e., make them eligible for GC) when you’re done with them, so that
    the garbage collector has something to reclaim. If you hang on to objects, GC
    can’t help you, and you run the risk of your program dying a painful out-of-memory
    death.
  prefs: []
  type: TYPE_NORMAL
- en: '**An object’s life has no value, no meaning, no point, unless somebody has
    a reference to it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you can’t get to it, you can’t ask it to do anything and it’s just a big
    fat waste of bits.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**But if an object is unreachable, the Garbage Collector will figure that out.
    Sooner or later, that object’s goin’ down.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-killer #1**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reference goes out of scope, permanently.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0263-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0263-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1-circle.png) ***foof()* is pushed onto the Stack; no variables
    are declared.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0263-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2-circle.png) **2 *barf()* is pushed onto the Stack, where
    it declares a reference variable, and creates a new object assigned to that reference.
    The object is created on the Heap, and the reference is alive and in scope.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0263-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3-circle.png) **3 *barf()* completes and pops off the Stack.
    Its frame disintegrates, so “d” is now dead and gone. Execution returns to foof(),
    but foof() can’t use “d.”**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0263-06.png)![image](Images/f0263-07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Object-killer #2**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assign the reference to another object**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0264-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0264-03.png)![image](Images/f0264-04.png)![image](Images/f0264-05.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Object-killer #3**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicitly set the reference to null**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0265-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0265-03.png)![image](Images/f0265-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common-03.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the Garbage Collector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/common-05.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Which of the lines of code on the right, if added to the class on the left
    at point A, would cause exactly one additional object to be eligible for the Garbage
    Collector? (Assume that point A (//call more methods) will execute for a long
    time, giving the Garbage Collector time to do its stuff.)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](Images/arr.png) **Answers in [“Be the Garbage Collector”](#be_the_garbage_collector_left_parenthesi).**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1** `copyGC = null;`'
  prefs: []
  type: TYPE_NORMAL
- en: '**2** `gc2 = null;`'
  prefs: []
  type: TYPE_NORMAL
- en: '**3** `newGC = gc3;`'
  prefs: []
  type: TYPE_NORMAL
- en: '**4** `gc1 = null;`'
  prefs: []
  type: TYPE_NORMAL
- en: '**5** `newGC = null;`'
  prefs: []
  type: TYPE_NORMAL
- en: '**6** `gc4 = null;`'
  prefs: []
  type: TYPE_NORMAL
- en: '**7** `gc3 = gc2;`'
  prefs: []
  type: TYPE_NORMAL
- en: '**8** `gc1 = gc4;`'
  prefs: []
  type: TYPE_NORMAL
- en: '**9** `gc3 = null;`'
  prefs: []
  type: TYPE_NORMAL
- en: Popular Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this code example, several new objects are created. Your challenge is to
    find the object that is “most popular,” i.e., the one that has the most reference
    variables referring to it. Then list how many total references there are for that
    object, and what they are! We’ll start by pointing out one of the new objects
    and its reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: Good luck!
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arr.png) **Answers in [“Popular Objects”](#popular_objects_left_parenthesis_from_pa).**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0269-01.png)![image](Images/common-04.png)'
  prefs: []
  type: TYPE_IMG
- en: “We’ve run the simulation four times, and the main module’s temperature consistently
    drifts out of nominal toward cold,” Sarah said, exasperated. “We installed the
    new temp-bots last week. The readings on the radiator bots, designed to cool the
    living quarters, seem to be within spec, so we’ve focused our analysis on the
    heat retention bots, the bots that help to warm the quarters.” Tom sighed, at
    first it had seemed that nanotechnology was going to really put them ahead of
    schedule. Now, with only five weeks left until launch, some of the orbiter’s key
    life support systems were still not passing the simulation gauntlet.
  prefs: []
  type: TYPE_NORMAL
- en: “What ratios are you simulating?” Tom asked.
  prefs: []
  type: TYPE_NORMAL
- en: Five-Minute Mystery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/common-07.png)'
  prefs: []
  type: TYPE_IMG
- en: “Well, if I see where you’re going, we already thought of that,” Sarah replied.
    “Mission control will not sign off on critical systems if we run them out of spec.
    We are required to run the v3 radiator bot’s SimUnits in a 2:1 ratio with the
    v2 radiator’s SimUnits,” Sarah continued. “Overall, the ratio of retention bots
    to radiator bots is supposed to run 4:3.”
  prefs: []
  type: TYPE_NORMAL
- en: “How’s power consumption, Sarah?” Tom asked. Sarah paused, “Well, that’s another
    thing, power consumption is running higher than anticipated. We’ve got a team
    tracking that down too, but because the nanos are wireless, it’s been hard to
    isolate the power consumption of the radiators from the retention bots.” “Overall
    power consumption ratios,” Sarah continued, “are designed to run 3:2 with the
    radiators pulling more power from the wireless grid.”
  prefs: []
  type: TYPE_NORMAL
- en: “OK, Sarah,” Tom said. “Let’s take a look at some of the simulation initiation
    code. We’ve got to find this problem, and find it quick!”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tom gave the code a quick look, and a small smile crept across his lips. “I
    think I’ve found the problem, Sarah, and I bet I know by what percentage your
    power usage readings are off too!”
  prefs: []
  type: TYPE_NORMAL
- en: '***What did Tom suspect? How could he guess the power readings errors, and
    what few lines of code could you add to help debug this program?***'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arr.png) **Answers in [“Five-Minute Mystery”](#five-minute_mystery_left_parent-id01000).**'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Be the Garbage Collector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Exercise”](#exercise-id000015))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0272-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Popular Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Popular Objects”](#popular_objects-id0100010))
  prefs: []
  type: TYPE_NORMAL
- en: It probably wasn’t too hard to figure out that the Honey object first referred
    to by the honeyPot variable is by far the most “popular” object in this class.
    But maybe it was a little trickier to see that all of the variables that point
    from the code to the Honey object refer to the ***same object!*** There are a
    total of 12 active references to this object right before the main( ) method completes.
    The *kit.honeyPot* variable is valid for a while, but kit gets nulled at the end.
    Since *raccoon.rk* still refers to the Kit object, *raccoon.kit.honeyPot* (although
    never explicitly declared) refers to the object!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0272-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Five-Minute Mystery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Five-Minute Mystery”](#five-minute_mystery-id00002))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Tom noticed that the constructor for the V2Radiator class took an ArrayList.
    That meant that every time the V3Radiator constructor was called, it passed an
    ArrayList in its super() call to the V2Radiator constructor. That meant that an
    extra five V2Radiator SimUnits were created. If Tom was right, total power use
    would have been 120, not the 100 that Sarah’s expected ratios predicted.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the Bot classes create SimUnits, writing a constructor for the SimUnit
    class, which printed out a line every time a SimUnit was created, would have quickly
    highlighted the problem!
  prefs: []
  type: TYPE_NORMAL
