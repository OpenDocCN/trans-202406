- en: Chapter 2\. JavaScript for React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since its release in 1995, JavaScript has gone through many changes. At first,
    we used JavaScript to add interactive elements to web pages: button clicks, hover
    states, form validation, etc.. Later, JavaScript got more robust with DHTML and
    AJAX. Today, with Node.js, JavaScript has become a real software language that’s
    used to build full-stack applications. JavaScript is everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript’s evolution has been guided by a group of individuals from companies
    that use JavaScript, browser vendors, and community leaders. The committee in
    charge of shepherding the changes to JavaScript over the years is the European
    Computer Manufacturers Association (ECMA). Changes to the language are community-driven,
    originating from proposals written by community members. Anyone [can submit a
    proposal](https://tc39.github.io/process-document) to the ECMA committee. The
    responsibility of the ECMA committee is to manage and prioritize these proposals
    to decide what’s included in each spec.
  prefs: []
  type: TYPE_NORMAL
- en: The first release of ECMAScript was in 1997, ECMAScript1\. This was followed
    in 1998 by ECMAScript2\. ECMAScript3 came out in 1999, adding regular expressions,
    string handling, and more. The process of agreeing on an ECMAScript4 became a
    chaotic, political mess that proved to be impossible. It was never released. In
    2009, ECMAScript5(ES5) was released, bringing features like new array methods,
    object properties, and library support for JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, there has been a lot more momentum in this space. After ES6 or ES2015
    was released in, yes, 2015, there have been yearly releases of new JS features.
    Anything that’s part of the stage proposals is typically called ESNext, which
    is a simplified way of saying this is the next stuff that will be part of the
    JavaScript spec.
  prefs: []
  type: TYPE_NORMAL
- en: Proposals are taken through clearly defined stages, from stage 0, which represents
    the newest proposals, up through stage 4, which represents the finished proposals.
    When a proposal gains traction, it’s up to the browser vendors like Chrome and
    Firefox to implement the features. Consider the `const` keyword. When creating
    variables, we used to use `var` in all cases. The ECMA committee decided there
    should be a `const` keyword to declare constants (more on that later in the chapter).
    When `const` was first introduced, you couldn’t just write `const` in JavaScript
    code and expect it to run in a browser. Now you can because browser vendors have
    changed the browser to support it.
  prefs: []
  type: TYPE_NORMAL
- en: Many of the features we’ll discuss in this chapter are already supported by
    the newest browsers, but we’ll also be covering how to compile your JavaScript
    code. This is the process of transforming new syntax that the browser doesn’t
    recognize into older syntax that the browser understands. The [kangax compatibility
    table](https://oreil.ly/oe7la) is a great place to stay informed about the latest
    JavaScript features and their varying degrees of support by browsers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll show you all the JavaScript syntax we’ll be using throughout
    the book. We hope to provide a good baseline of JavaScript syntax knowledge that
    will carry you through all of your work with React. If you haven’t made the switch
    to the latest syntax yet, now would be a good time to get started. If you’re already
    comfortable with the latest language features, skip to the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to ES2015, the only way to declare a variable was with the `var` keyword.
    We now have a few different options that provide improved functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The const Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A constant is a variable that cannot be overwritten. Once declared, you cannot
    change its value. A lot of the variables that we create in JavaScript should not
    be overwritten, so we’ll be using `const` a lot. Like other languages had done
    before it, JavaScript introduced constants with ES6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before constants, all we had were variables, and variables could be overwritten:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot reset the value of a constant variable, and it will generate a console
    error (as shown in [Figure 2-1](#overwrite_constant)) if we try to overwrite the
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Overwriting a constant](assets/lrc2_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. An attempt at overwriting a constant
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The let Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript now has *lexical variable scope*. In JavaScript, we create code blocks
    with curly braces (`{}`). In functions, these curly braces block off the scope
    of any variable declared with `var`. On the other hand, consider `if/else` statements.
    If you’re coming from other languages, you might assume that these blocks would
    also block variable scope. This was not the case until `let` came along.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a variable is created inside of an `if/else` block, that variable is not
    scoped to the block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `topic` variable inside the `if` block resets the value of `topic` outside
    of the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `let` keyword, we can scope a variable to any code block. Using `let`
    protects the value of the global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The value of `topic` is not reset outside of the block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another area where curly braces don’t block off a variable’s scope is in `for`
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this loop, we create five `div`s to appear within a container. Each `div`
    is assigned an `onclick` handler that creates an alert box to display the index.
    Declaring `i` in the `for` loop creates a global variable named `i`, then iterates
    over it until its value reaches `5`. When you click on any of these boxes, the
    alert says that `i` is equal to `5` for all `div`s, because the current value
    for the global `i` is `5` (see [Figure 2-2](#i_equal_5)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/lrc2_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. i is equal to 5 for each box
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Declaring the loop counter `i` with `let` instead of `var` does block off the
    scope of `i`. Now clicking on any box will display the value for `i` that was
    scoped to the loop iteration (see [Figure 2-3](#loop_counter_i)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/lrc2_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. The scope of `i` is protected with `let`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The scope of `i` is protected with `let`.
  prefs: []
  type: TYPE_NORMAL
- en: Template Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template strings provide us with an alternative to string concatenation. They
    also allow us to insert variables into a string. You’ll hear these referred to
    as template strings, template literals, or string templates interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditional string concatenation uses plus signs to compose a string using
    variable values and strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With a template, we can create one string and insert the variable values by
    surrounding them with `${ }`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Any JavaScript that returns a value can be added to a template string between
    the `${ }` in a template string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template strings honor whitespace, making it easier to draft up email templates,
    code examples, or anything else that contains whitespace. Now you can have a string
    that spans multiple lines without breaking your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, using an HTML string directly in our JavaScript code was not so
    easy to do because we’d need to run it together on one line. Now that the whitespace
    is recognized as text, you can insert formatted HTML that is easy to read and
    understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we can include variables for the page title and article text as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any time you want to perform some sort of repeatable task with JavaScript, you
    can use a function. Let’s take a look at some of the different syntax options
    that can be used to create a function and the anatomy of those functions.
  prefs: []
  type: TYPE_NORMAL
- en: Function Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function declaration or function definition starts with the `function` keyword,
    which is followed by the name of the function, `logCompliment`. The JavaScript
    statements that are part of the function are defined between the curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve declared the function, you’ll invoke or call it to see it execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once invoked, you’ll see the compliment logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Function Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another option is to use a function expression. This just involves creating
    the function as a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The result is the same, and `You're doing great!` is logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to be aware of when deciding between a function declaration and a
    function expression is that function declarations are hoisted and function expressions
    are not. In other words, you can invoke a function before you write a function
    declaration. You cannot invoke a function created by a function expression. This
    will cause an error. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This works. You’ll see the alert appear in the browser. It works because the
    function is hoisted, or moved up, to the top of the file’s scope. Trying the same
    exercise with a function expression will cause an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is obviously a small example, but this TypeError can occasionally arise
    when importing files and functions in a project. If you see it, you can always
    refactor as a declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Passing arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `logCompliment` function currently takes in no arguments or parameters.
    If we want to provide dynamic variables to the function, we can pass named parameters
    to a function simply by adding them to the parentheses. Let’s start by adding
    a `firstName` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now when we call the `logCompliment` function, the `firstName` value sent will
    be added to the console message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could add to this a bit by creating another argument called `message`. Now,
    we won’t hard-code the message. We’ll pass in a dynamic value as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Function returns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `logCompliment` function currently logs the compliment to the console,
    but more often, we’ll use a function to return a value. Let’s add a `return` statement
    to this function. A `return` statement specifies the value returned by the function.
    We’ll rename the function `createCompliment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to check to see if the function is executing as expected, just
    wrap the function call in a `console.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Default Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Languages including C++ and Python allow developers to declare default values
    for function arguments. Default parameters are included in the ES6 spec, so in
    the event that a value is not provided for the argument, the default value will
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can set up default strings for the parameters `name` and `activity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If no arguments are provided to the `logActivity` function, it will run correctly
    using the default values. Default arguments can be any type, not just strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Arrow Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrow functions are a useful new feature of ES6\. With arrow functions, you
    can create functions without using the `function` keyword. You also often do not
    have to use the `return` keyword. Let’s consider a function that takes in a `firstName`
    and returns a string, turning the person into a lord. Anyone can be a lord:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With an arrow function, we can simplify the syntax tremendously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the arrow, we now have an entire function declaration on one line. The
    `function` keyword is removed. We also remove `return` because the arrow points
    to what should be returned. Another benefit is that if the function only takes
    one argument, we can remove the parentheses around the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'More than one argument should be surrounded by parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can keep this as a one-line function because there is only one statement
    that needs to be returned. If there are multiple lines, you’ll use curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These `if/else` statements are surrounded with brackets but still benefit from
    the shorter syntax of the arrow function.
  prefs: []
  type: TYPE_NORMAL
- en: Returning objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What happens if you want to return an object? Consider a function called `person`
    that builds an object based on parameters passed in for `firstName` and `lastName`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you run this, you’ll see the error: `Uncaught SyntaxError: Unexpected
    token :`. To fix this, just wrap the object you’re returning with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: These missing parentheses are the source of countless bugs in JavaScript and
    React apps, so it’s important to remember this one!
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions and scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regular functions do not block `this`. For example, `this` becomes something
    else in the `setTimeout` callback, not the `tahoe` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This error is thrown because it’s trying to use the `.join` method on what
    `this` is. If we log `this`, we’ll see that it refers to the `Window` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve this problem, we can use the arrow function syntax to protect the
    scope of `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This works as expected, and we can `.join` the resorts with a comma. Be careful
    that you’re always keeping scope in mind. Arrow functions do not block off the
    scope of `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Changing the `print` function to an arrow function means that `this` is actually
    the window.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a new JavaScript feature is proposed and gains support, the community often
    wants to use it before it’s supported by all browsers. The only way to be sure
    that your code will work is to convert it to more widely compatible code before
    running it in the browser. This process is called *compiling*. One of the most
    popular tools for JavaScript compilation is [Babel](http://www.babeljs.io).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, the only way to use the latest JavaScript features was to wait
    weeks, months, or even years until browsers supported them. Now, Babel has made
    it possible to use the latest features of JavaScript right away. The compiling
    step makes JavaScript similar to other languages. It’s not quite traditional compiling:
    our code isn’t compiled to binary. Instead, it’s transformed into syntax that
    can be interpreted by a wider range of browsers. Also, JavaScript now has source
    code, meaning that there will be some files that belong to your project that don’t
    run in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let’s look at an arrow function with some default arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run Babel on this code, it will generate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Babel added a “use strict” declaration to run in strict mode. The variables
    `x` and `y` are defaulted using the `arguments` array, a technique you may be
    familiar with. The resulting JavaScript is more widely supported.
  prefs: []
  type: TYPE_NORMAL
- en: A great way to learn more about how Babel works is to check out the [Babel REPL](https://babeljs.io/repl)
    on the documentation website. Type some new syntax on the left side, then see
    some older syntax created.
  prefs: []
  type: TYPE_NORMAL
- en: The process of JavaScript compilation is typically automated by a build tool
    like webpack or Parcel. We’ll discuss that in more detail later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since ES2016, JavaScript syntax has supported creative ways of scoping variables
    within objects and arrays. These creative techniques are widely used among the
    React community. Let’s take a look at a few of them, including destructuring,
    object literal enhancement, and the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Destructuring assignment allows you to locally scope fields within an object
    and to declare which values will be used. Consider the `sandwich` object. It has
    four keys, but we only want to use the values of two. We can scope `bread` and
    `meat` to be used locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The code pulls `bread` and `meat` out of the object and creates local variables
    for them. Also, since we declared these destructed variables using `let`, the
    `bread` and `meat` variables can be changed without changing the original sandwich:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also destructure incoming function arguments. Consider this function
    that would log a person’s name as a lord:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of using dot notation syntax to dig into objects, we can destructure
    the values we need out of `regularPerson`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take this one level farther to reflect a data change. Now, the `regularPerson`
    object has a new nested object on the `spouse` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to lordify the spouse’s first name, we’d adjust the function’s
    destructured arguments slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Using the colon and nested curly braces, we can destructure the `firstname`
    from the `spouse` object.
  prefs: []
  type: TYPE_NORMAL
- en: Destructuring Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values can also be destructured from arrays. Imagine that we wanted to assign
    the first value of an array to a variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also pass over unnecessary values with *list matching* using commas.
    List matching occurs when commas take the place of elements that should be skipped.
    With the same array, we can access the last value by replacing the first two values
    with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Later in this section, we’ll take this example a step farther by combining array
    destructuring and the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: Object Literal Enhancement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Object literal enhancement* is the opposite of destructuring. It’s the process
    of restructuring or putting the object back together. With object literal enhancement,
    we can grab variables from the global scope and add them to an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`name` and `elevation` are now keys of the `funHike` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also create object methods with object literal enhancement or restructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice we use `this` to access the object keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'When defining object methods, it’s no longer necessary to use the `function`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Object literal enhancement allows us to pull global variables into objects and
    reduces typing by making the `function` keyword unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: The Spread Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The spread operator is three dots (`...`) that perform several different tasks.
    First, the spread operator allows us to combine the contents of arrays. For example,
    if we had two arrays, we could make a third array that combines the two arrays
    into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: All of the items from `peaks` and `canyons` are pushed into a new array called
    `tahoe`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how the spread operator can help us deal with a problem.
    Using the `peaks` array from the previous sample, let’s imagine that we wanted
    to grab the last item from the array rather than the first. We could use the `Array.reverse`
    method to reverse the array in combination with array destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'See what happened? The `reverse` function has actually altered or mutated the
    array. In a world with the spread operator, we don’t have to mutate the original
    array. Instead, we can create a copy of the array and then reverse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Since we used the spread operator to copy the array, the `peaks` array is still
    intact and can be used later in its original form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spread operator can also be used to get the remaining items in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the three-dot syntax to collect function arguments as an array.
    When used in a function, these are called `rest parameters`. Here, we build a
    function that takes in *n* number of arguments using the spread operator, then
    uses those arguments to print some console messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `directions` function takes in the arguments using the spread operator.
    The first argument is assigned to the `start` variable. The last argument is assigned
    to a `finish` variable using `Array.reverse`. We then use the length of the `arguments`
    array to display how many towns we’re going through. The number of stops is the
    length of the `arguments` array minus the `finish` stop. This provides incredible
    flexibility because we could use the `directions` function to handle any number
    of stops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spread operator can also be used for objects (see the GitHub page for [Rest/Spread
    Properties](https://oreil.ly/kCpEL)). Using the spread operator with objects is
    similar to using it with arrays. In this example, we’ll use it the same way we
    combined two arrays into a third array, but instead of arrays, we’ll use objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code samples that have been part of this chapter so far have been synchronous.
    When we write synchronous JavaScript code, we’re providing a list of instructions
    that execute immediately in order. For example, if we wanted to use JavaScript
    to handle some simple DOM manipulation, we’d write the code to do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: These are instructions. “Yo, go select that element with an id of `heading`.
    Then when you’re done with that, how about you set that inner HTML to *Hey*.”
    It works synchronously. While each operation is happening, nothing else is happening.
  prefs: []
  type: TYPE_NORMAL
- en: With the modern web, we need to perform asynchronous tasks. These tasks often
    have to wait for some work to finish before they can be completed. We might need
    to access a database. We might need to stream video or audio content. We might
    need to fetch data from an API. With JavaScript, asynchronous tasks do not block
    the main thread. JavaScript is free to do something else while we wait for the
    API to return data. JavaScript has evolved a lot over the past few years to make
    handling these asynchronous actions easier. Let’s explore some of the features
    that make this possible.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Promises with Fetch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Making a request to a REST API used to be pretty cumbersome. We’d have to write
    20+ lines of nested code just to load some data into our app. Then the `fetch()`
    function showed up and simplified our lives. Thanks to the ECMAScript committee
    for making fetch happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get some data from the randomuser.me API. This API has information like
    email address, name, phone number, location, and so on for fake members and is
    great to use as dummy data. `fetch` takes in the URL for this resource as its
    only parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When we log this, we see that there is a pending promise. *Promises* give us
    a way to make sense out of asynchronous behavior in JavaScript. The promise is
    an object that represents whether the async operation is pending, has been completed,
    or has failed. Think of this like the browser saying, “Hey, I’m going to try my
    best to go get this data. Either way, I’ll come back and let you know how it went.”
  prefs: []
  type: TYPE_NORMAL
- en: So back to the `fetch` result. The pending promise represents a state before
    the data has been fetched. We need to chain on a function called `.then()`. This
    function will take in a callback function that will run if the previous operation
    was successful. In other words, fetch some data, then do something else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The something else we want to do is turn the response into JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `then` method will invoke the callback function once the promise has resolved.
    Whatever you return from this function becomes the argument of the next `then`
    function. So we can chain together `then` functions to handle a promise that has
    been successfully resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: First, we use `fetch` to make a GET request to randomuser.me. If the request
    is successful, we’ll then convert the response body to JSON. Next, we’ll take
    the JSON data and return the results, then we’ll send the results to the `console.log`
    function, which will log them to the console. Finally, there is a `catch` function
    that invokes a callback if the `fetch` did not resolve successfully. Any error
    that occurred while fetching data from randomuser.me will be based on that callback.
    Here, we simply log the error to the console using `console.error`.
  prefs: []
  type: TYPE_NORMAL
- en: Async/Await
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another popular approach for handling promises is to create an async function.
    Some developers prefer the syntax of async functions because it looks more familiar,
    like code that’s found in a synchronous function. Instead of waiting for the results
    of a promise to resolve and handling it with a chain of `then` functions, `async`
    functions can be told to wait for the promise to resolve before further executing
    any code found in the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make another API request but wrap the functionality with an async function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `getFakePerson` function is declared using the `async` keyword.
    This makes it an asynchronous function that can wait for promises to resolve before
    executing the code any further. The `await` keyword is used before promise calls.
    This tells the function to wait for the promise to resolve. This code accomplishes
    the exact same task as the code in the previous section that uses `then` functions.
    Well, almost the exact same task…
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There we go—now this code accomplishes the exact same task as the code in the
    previous section that uses `then` functions. If the `fetch` call is successful,
    the results are logged to the console. If it’s unsuccessful, then we’ll log the
    error to the console using `console.error`. When using `async` and `await`, you
    need to surround your promise call in a `try`…`catch` block to handle any errors
    that may occur due to an unresolved promise.
  prefs: []
  type: TYPE_NORMAL
- en: Building Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When making an asynchronous request, one of two things can happen: everything
    goes as we hope, or there’s an error. There can be many different types of successful
    or unsuccessful requests. For example, we could try several ways to obtain the
    data to reach success. We could also receive multiple types of errors. Promises
    give us a way to simplify back to a simple pass or fail.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getPeople` function returns a new promise. The promise makes a request
    to the API. If the promise is successful, the data will load. If the promise is
    unsuccessful, an error will occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the promise has been created, but it hasn’t been used yet. We can
    use the promise by calling the `getPeople` function and passing in the number
    of members that should be loaded. The `then` function can be chained on to do
    something once the promise has been fulfilled. When a promise is rejected, any
    details are passed back to the `catch` function, or the `catch` block if using
    `async/await` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Promises make dealing with asynchronous requests easier, which is good, because
    we have to deal with a lot of asynchronicity in JavaScript. A solid understanding
    of asynchronous behavior is essential for the modern JavaScript engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Prior to ES2015, there was no official class syntax in the JavaScript spec.
    When classes were introduced, there was a lot of excitement about how similar
    the syntax of classes was to traditional object-oriented languages like Java and
    C++. The past few years saw the React library leaning on classes heavily to construct
    user interface components. Today, React is beginning to move away from classes,
    instead using functions to construct components. You’ll still see classes all
    over the place, particularly in legacy React code and in the world of JavaScript,
    so let’s take a quick look at them.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript uses something called `prototypical inheritance`. This technique
    can be wielded to create structures that feel object-oriented. For example, we
    can create a `Vacation` constructor that needs to be invoked with a `new` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates something that feels like a custom type in an object-oriented
    language. A `Vacation` has properties (destination, length), and it has a method
    (print). The `maui` instance inherits the `print` method through the prototype.
    If you are or were a developer accustomed to more standard classes, this might
    fill you with a deep rage. ES2015 introduced class declaration to quiet that rage,
    but the dirty secret is that JavaScript still works the same way. Functions are
    objects, and inheritance is handled through the prototype. Classes provide a syntactic
    sugar on top of that gnarly prototype syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re creating a class, the class name is typically capitalized. Once
    you’ve created the class, you can create a new instance of the class using the
    `new` keyword. Then you can call the custom method on the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Now that a class object has been created, you can use it as many times as you’d
    like to create new vacation instances. Classes can also be extended. When a class
    is extended, the subclass inherits the properties and methods of the superclass.
    These properties and methods can be manipulated from here, but as a default, all
    will be inherited.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `Vacation` as an abstract class to create different types of vacations.
    For instance, an `Expedition` can extend the `Vacation` class to include gear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s simple inheritance: the subclass inherits the properties of the superclass.
    By calling the `print` method of `Vacation`, we can append some new content onto
    what is printed in the `print` method of `Expedition`. Creating a new instance
    works the exact same way—create a variable and use the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: ES6 Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A JavaScript *module* is a piece of reusable code that can easily be incorporated
    into other JavaScript files without causing variable collisions. JavaScript modules
    are stored in separate files, one file per module. There are two options when
    creating and exporting a module: you can export multiple JavaScript objects from
    a single module or one JavaScript object per module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *text-helpers.js*, two functions are exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '`export` can be used to export any JavaScript type that will be consumed in
    another module. In this example, the `print` function and `log` function are being
    exported. Any other variables declared in *text-helpers.js* will be local to that
    module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules can also export a single main variable. In these cases, you can use
    `export default`. For example, the *mt-freel.js* file can export a specific expedition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`export default` can be used in place of `export` when you wish to export only
    one type. Again, both `export` and `export default` can be used on any JavaScript
    type: primitives, objects, arrays, and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules can be consumed in other JavaScript files using the `import` statement.
    Modules with multiple exports can take advantage of object destructuring. Modules
    that use `export default` are imported into a single variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You can scope module variables locally under different variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also import everything into a single variable using `*`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This `import` and `export` syntax is not yet fully supported by all browsers
    or by Node. However, like any emerging JavaScript syntax, it’s supported by Babel.
    This means you can use these statements in your source code and Babel will know
    where to find the modules you want to include in your compiled JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: CommonJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CommonJS is the module pattern that’s supported by all versions of Node (see
    the [Node.js documentation on modules](https://oreil.ly/CN-gA)). You can still
    use these modules with Babel and webpack. With CommonJS, JavaScript objects are
    exported using `module.exports`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in CommonJS, we can export the `print` and `log` functions as
    an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'CommonJS does not support an `import` statement. Instead, modules are imported
    with the `require` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript is indeed moving quickly and adapting to the increasing demands that
    engineers are placing on the language, and browsers are quickly implementing new
    features. For up-to-date compatibility information, see the [ESNext compatibility
    table](https://oreil.ly/rxTcg). Many of the features that are included in the
    latest JavaScript syntax are present because they support functional programming
    techniques. In functional JavaScript, we can think of our code as being a collection
    of functions that can be composed into applications. In the next chapter, we’ll
    explore functional techniques in more detail and will discuss why you might want
    to use them.
  prefs: []
  type: TYPE_NORMAL
