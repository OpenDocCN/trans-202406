<html><head></head><body><section data-pdf-bookmark="Chapter 8. Migrating to TypeScript" data-type="chapter" epub:type="chapter" class="praise"><div class="praise" id="ch-migrate">
<h1 class="calibre14"><span class="calibre">Chapter 8. </span>Migrating to TypeScript</h1>


<p class="author1">You’ve<a data-primary="TypeScript" data-secondary="migrating to" data-type="indexterm" id="TSmig08" class="calibre9"/><a data-primary="JavaScript" data-secondary="migrating to TypeScript" data-type="indexterm" id="JSmig08" class="calibre9"/><a data-primary="migration" data-secondary="overview of" data-type="indexterm" id="idm45331644011704" class="calibre9"/> heard that TypeScript is great. You also know from painful experience that maintaining your 15-year-old, 100,000-line JavaScript library isn’t. If only it could become a TypeScript library!</p>

<p class="author1">This chapter offers some advice about migrating your JavaScript project to TypeScript without losing your sanity and abandoning the effort.</p>

<p class="author1">Only the smallest codebases can be migrated in one fell swoop. The key for larger projects is to migrate gradually. <a href="#allowjs" class="calibre9">Item 60</a> discusses how to do this. For a long migration, it’s essential to track your progress and make sure you don’t backslide. This creates a sense of momentum and inevitability to the change. <a href="#convert-up-the-graph" class="calibre9">Item 61</a> discusses ways to do this.</p>

<p class="author1">Migrating a large project to TypeScript won’t necessarily be easy, but it does offer a huge potential upside. A 2017 study found that 15% of bugs fixed in JavaScript projects on GitHub could have been prevented with TypeScript.<sup class="calibre44"><a data-type="noteref" href="ch08.html#idm45331644007096" id="idm45331644007096-marker" class="calibre45">1</a></sup> Even more impressive, a survey of six months’ worth of postmortems at AirBnb found that 38% of them could have been prevented by TypeScript.<sup class="calibre44"><a data-type="noteref" href="ch08.html#idm45331644005032" id="idm45331644005032-marker" class="calibre45">2</a></sup> If you’re advocating for TypeScript at your organization, stats like these will help! So will running some experiments and finding early adopters. <a href="#jsdoc-tscheck" class="calibre9">Item 59</a> discusses how to experiment with TypeScript before you begin migration.</p>

<p class="author1">Since this chapter is largely about JavaScript, many of the code samples are either pure JavaScript (and not expected to pass the type checker) or checked with looser settings (e.g., with <code class="calibre18">noImplicitAny</code> off).</p>






<section data-pdf-bookmark="Item 58: Write Modern JavaScript" data-type="sect1" class="praise"><div class="praise" id="write-modern-js">
<h1 class="calibre16">Item 58: Write Modern JavaScript</h1>

<p class="author1">In<a data-primary="ES2015" data-secondary="writing modern JavaScript" data-type="indexterm" id="idm45331643999368" class="calibre9"/><a data-primary="migration" data-secondary="writing modern JavaScript" data-type="indexterm" id="Mmodern08" class="calibre9"/><a data-primary="JavaScript" data-secondary="writing modern" data-type="indexterm" id="JSmodern08" class="calibre9"/> addition to checking your code for type safety, TypeScript compiles your TypeScript code to any version of JavaScript code, all the way back to 1999 vintage ES3. Since TypeScript is a superset of the <em class="calibre3">latest</em> version of JavaScript, this means that you can use <code class="calibre18">tsc</code> as a “transpiler”: something that takes new JavaScript and converts it to older, more widely supported JavaScript.</p>

<p class="author1">Taking a different perspective, this means that when you decide to convert an existing JavaScript codebase to TypeScript, there’s no downside to adopting all the latest JavaScript features. In fact, there’s quite a bit of upside: because TypeScript is designed to work with modern JavaScript, modernizing your JS is a great first step toward adopting TypeScript.</p>

<p class="author1">And because TypeScript is a superset of JavaScript, learning to write more modern and idiomatic JavaScript means you’re learning to write better TypeScript, too.</p>

<p class="author1">This item gives a quick tour of some of the features in modern JavaScript, which I’m defining here as everything introduced in ES2015 (aka ES6) and after. This material is covered in much greater detail in other books and online. If any of the topics mentioned here are unfamiliar, you owe it to yourself to learn more about them. TypeScript can be tremendously helpful when you’re learning a new language feature like <code class="calibre18">async</code>/<code class="calibre18">await</code>: it almost certainly understands the feature better than you do and can guide you toward correct usage.</p>

<p class="author1">These are all worth understanding, but by far the most important for adopting TypeScript are ECMAScript Modules and ES2015 classes.</p>








<section class="praise" data-pdf-bookmark="Use ECMAScript Modules" data-type="sect2"><div class="praise" id="idm45331643990696">
<h2 class="calibre31">Use ECMAScript Modules</h2>

<p class="author1">Before<a data-primary="ECMAScript" data-type="indexterm" id="idm45331643927576" class="calibre9"/><a data-primary="callbacks" data-secondary="ECMAScript modules" data-type="indexterm" id="idm45331643926744" class="calibre9"/> the 2015 version of ECMAScript there was no standard way to break your code into separate modules. There were many solutions, from multiple <code class="calibre18">&lt;script&gt;</code> tags, manual concatenation, and Makefiles to node.js-style <code class="calibre18">require</code> statements or AMD-style <code class="calibre18">define</code> callbacks. TypeScript even had its own module system (<a href="ch07.html#avoid-non-ecma" class="calibre9">Item 53</a>).</p>

<p class="author1">Today there is one standard: ECMAScript modules, aka <code class="calibre18">import</code> and <code class="calibre18">export</code>. If your JavaScript codebase is still a single file, if you use concatenation or one of the other module systems, it’s time to switch to ES modules. This may require setting up a tool like<a data-primary="webpack" data-type="indexterm" id="idm45331643922184" class="calibre9"/><a data-primary="ts-node" data-type="indexterm" id="idm45331643921480" class="calibre9"/> webpack or ts-node. TypeScript works best with ES modules, and adopting them will facilitate your transition, not least because it will allow you to migrate modules one at a time (see <a href="#convert-up-the-graph" class="calibre9">Item 61</a>).</p>

<p class="author1">The details will vary depending on your setup, but if you’re using CommonJS like this:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// CommonJS</code>
<code class="c">// a.js</code>
<code class="kd">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'./b'</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>

<code class="c">// b.js</code>
<code class="kd">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s">'Module B'</code><code class="p">;</code>
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code><code class="nx">name</code><code class="p">};</code></pre>

<p class="author1">then the ES module equivalent would look like:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// ECMAScript module</code>
<code class="c">// a.ts</code>
<code class="kd">import</code> <code class="o">*</code> <code class="nx">as</code> <code class="nx">b</code> <code class="nx">from</code> <code class="s">'./b'</code><code class="p">;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>

<code class="c">// b.ts</code>
<code class="kd">export</code> <code class="kd">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s">'Module B'</code><code class="p">;</code></pre>
</div></section>













<section class="praise" data-pdf-bookmark="Use Classes Instead of Prototypes" data-type="sect2"><div class="praise" id="idm45331643892872">
<h2 class="calibre31">Use Classes Instead of Prototypes</h2>

<p class="author1">JavaScript<a data-primary="prototypes" data-type="indexterm" id="idm45331643880536" class="calibre9"/><a data-primary="classes" data-secondary="ES2015" data-type="indexterm" id="idm45331643830360" class="calibre9"/><a data-primary="classes, versus prototypes" data-type="indexterm" id="idm45331643829416" class="calibre9"/> has a flexible prototype-based object model. But by and large JS developers have ignored this in favor of a more rigid class-based model. This was officially enshrined into the language with the introduction<a data-primary="ES2015" data-secondary="class keyword" data-type="indexterm" id="idm45331643828424" class="calibre9"/> of the <code class="calibre18">class</code> keyword in ES2015.</p>

<p class="author1">If<a data-primary="Curie, Marie" data-type="indexterm" id="idm45331643826488" class="calibre9"/> your code uses prototypes in a straightforward way, switch to using classes. That is, instead of:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">Person</code><code class="p">(</code><code class="nx">first</code><code class="p">,</code> <code class="nx">last</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">this</code><code class="p">.</code><code class="nx">first</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
  <code class="kd">this</code><code class="p">.</code><code class="nx">last</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">Person</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">getName</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">first</code> <code class="o">+</code> <code class="s">' '</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">last</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">marie</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s">'Marie'</code><code class="p">,</code> <code class="s">'Curie'</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">personName</code> <code class="o">=</code> <code class="nx">marie</code><code class="p">.</code><code class="nx">getName</code><code class="p">();</code></pre>

<p class="author1">write:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Person</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="kd">string</code><code class="p">;</code>

  <code class="kd">constructor</code><code class="p">(</code><code class="nx">first</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">last</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">first</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">last</code> <code class="o">=</code> <code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">getName() {</code>
    <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">first</code> <code class="o">+</code> <code class="s">' '</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">last</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>

<code class="kd">const</code> <code class="nx">marie</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Person</code><code class="p">(</code><code class="s">'Marie'</code><code class="p">,</code> <code class="s">'Curie'</code><code class="p">);</code>
<code class="kd">const</code> <code class="nx">personName</code> <code class="o">=</code> <code class="nx">marie</code><code class="p">.</code><code class="nx">getName</code><code class="p">();</code></pre>

<p class="author1">TypeScript struggles with the prototype version of <code class="calibre18">Person</code> but understands the class-based version with minimal annotations. If you’re unfamiliar with the syntax, TypeScript will help you get it right.</p>

<p class="author1">For<a data-primary="ES2015" data-secondary="Convert function" data-type="indexterm" id="idm45331643657096" class="calibre9"/> code that uses older-style classes, the TypeScript language service offers a “Convert function to an ES2015 class” quick fix that can speed this up (<a data-type="xref" href="#efts-08in01" class="calibre9">Figure 8-1</a>).</p>

<figure class="width"><div class="figure" id="efts-08in01">
<img alt="efts 08in01" src="assets/efts_08in01.png" class="calibre49"/>
<h6 class="calibre29"><span class="calibre">Figure 8-1. </span>The TypeScript language service offers a quick fix to convert older-style classes to ES2015 classes.</h6>
</div></figure>
</div></section>













<section class="praise" data-pdf-bookmark="Use let/const Instead of var" data-type="sect2"><div class="praise" id="idm45331643881752">
<h2 class="calibre31">Use let/const Instead of var</h2>

<p class="author1">JavaScript’s<a data-primary="var" data-type="indexterm" id="idm45331643650728" class="calibre9"/><a data-primary="let/const" data-type="indexterm" id="idm45331643649992" class="calibre9"/> <code class="calibre18">var</code> has some famously quirky scoping rules. If you’re curious to learn more about them, read <em class="calibre3">Effective JavaScript</em>. But better to avoid <code class="calibre18">var</code> and not worry! Instead, use <code class="calibre18">let</code> and <code class="calibre18">const</code>. They’re truly block-scoped and work in much more intuitive ways than <code class="calibre18">var</code>.</p>

<p class="author1">Again, TypeScript will help you here. If changing <code class="calibre18">var</code> to <code class="calibre18">let</code> results in an error, then you’re almost certainly doing something you shouldn’t be.</p>

<p class="author1">Nested function statements also have <code class="calibre18">var</code>-like scoping rules:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">foo() {</code>
  <code class="nx">bar</code><code class="p">();</code>
  <code class="kd">function</code> <code class="nx">bar() {</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'hello'</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">When you call <code class="calibre18">foo()</code>, it logs <code class="calibre18">hello</code> because the definition of <code class="calibre18">bar</code> is hoisted to the top of <code class="calibre18">foo</code>. This is surprising! Prefer function expressions (<code class="calibre18">const bar = () =&gt; { ... }</code>) instead.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Use for-of or Array Methods Instead of for(;;)" data-type="sect2"><div class="praise" id="idm45331643634248">
<h2 class="calibre31">Use for-of or Array Methods Instead of for(;;)</h2>

<p class="author1">In<a data-primary="for-of" data-type="indexterm" id="idm45331643632600" class="calibre9"/><a data-primary="for(;;)" data-type="indexterm" id="idm45331643624600" class="calibre9"/><a data-primary="array methods" data-type="indexterm" id="idm45331643623928" class="calibre9"/> classic JavaScript you used a C-style for loop to iterate over an array:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">In modern JavaScript you can use a for-of loop instead:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">el</code> <code class="nx">of</code> <code class="nx">array</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">This is less prone to typos and doesn’t introduce an index variable. If you want the index variable, you can use <code class="calibre18">forEach</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">array</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">el</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">});</code></pre>

<p class="author1">Avoid using the for-in construct to iterate over arrays as it has many surprises (see <a href="ch02_split_001.html#number-index" class="calibre9">Item 16</a>).</p>
</div></section>













<section class="praise" data-pdf-bookmark="Prefer Arrow Functions Over Function Expressions" data-type="sect2"><div class="praise" id="idm45331643507896">
<h2 class="calibre31">Prefer Arrow Functions Over Function Expressions</h2>

<p class="author1">The<a data-primary="arrow functions" data-type="indexterm" id="idm45331643506152" class="calibre9"/><a data-primary="functions" data-secondary="arrow functions" data-type="indexterm" id="idm45331643505416" class="calibre9"/><a data-primary="function expressions" data-type="indexterm" id="idm45331643504472" class="calibre9"/><a data-primary="this keyword" data-type="indexterm" id="idm45331643503800" class="calibre9"/><a data-primary="JavaScript" data-secondary="this keyword" data-type="indexterm" id="idm45331643503128" class="calibre9"/> <code class="calibre18">this</code> keyword is one of the most famously confusing aspects of JavaScript because it has different scoping rules than other variables:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Foo</code> <code class="p">{</code>
  <code class="nx">method() {</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
    <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">].</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Foo</code><code class="p">();</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">method</code><code class="p">();</code>
<code class="c">// Prints Foo, undefined, undefined in strict mode</code>
<code class="c">// Prints Foo, window, window (!) in non-strict mode</code></pre>

<p class="author1">Generally you want <code class="calibre18">this</code> to refer to the relevant instance of whichever class you’re in. Arrow functions help you do that by keeping the <code class="calibre18">this</code> value from their enclosing scope:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Foo</code> <code class="p">{</code>
  <code class="nx">method() {</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
    <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">].</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kd">this</code><code class="p">);</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">new</code> <code class="nx">Foo</code><code class="p">();</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">method</code><code class="p">();</code>
<code class="c">// Always prints Foo, Foo, Foo</code></pre>

<p class="author1">In addition to having simpler semantics, arrow functions are more concise. You should use them whenever possible. For more on <code class="calibre18">this</code> binding, see <a href="ch06.html#this-in-callbacks" class="calibre9">Item 49</a>. With<a data-primary="noImplicitThis" data-type="indexterm" id="idm45331643293272" class="calibre9"/> the <code class="calibre18">noImplicitThis</code> (or <code class="calibre18">strict</code>) compiler<a data-primary="compiling" data-secondary="compiler options" data-type="indexterm" id="idm45331643291608" class="calibre9"/> option, TypeScript will help you get your <code class="calibre18">this</code>-binding right.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Use Compact Object Literals and Destructuring Assignment" data-type="sect2"><div class="praise" id="idm45331643290088">
<h2 class="calibre31">Use Compact Object Literals and Destructuring Assignment</h2>

<p class="author1">Instead<a data-primary="destructuring assignment" data-type="indexterm" id="idm45331643287720" class="calibre9"/><a data-primary="compact object literals" data-type="indexterm" id="idm45331643287128" class="calibre9"/><a data-primary="objects" data-secondary="compact object literals" data-type="indexterm" id="idm45331643286456" class="calibre9"/> of writing:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">x</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">y</code><code class="p">,</code>
  <code class="nx">z</code>: <code class="nx">z</code>
<code class="p">};</code></pre>

<p class="author1">you can simply write:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">pt</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">};</code></pre>

<p class="author1">In addition to being more concise, this encourages consistent naming of variables and properties, something your human readers will appreciate as well (<a href="ch04.html#language-of-domain" class="calibre9">Item 36</a>).</p>

<p class="author1">To return an object literal from an arrow function, wrap it in parentheses:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="p">[</code><code class="s">'A'</code><code class="p">,</code> <code class="s">'B'</code><code class="p">,</code> <code class="s">'C'</code><code class="p">].</code><code class="nx">map</code><code class="p">((</code><code class="kd">char</code><code class="p">,</code> <code class="nx">idx</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="kd">char</code><code class="p">,</code> <code class="nx">idx</code><code class="p">}));</code>
<code class="c">// [ { char: 'A', idx: 0 },  { char: 'B', idx: 1 }, { char: 'C', idx: 2 } ]</code></pre>

<p class="author1">There is also shorthand for properties whose values are functions:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">obj</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">onClickLong</code>: <code class="nx">function</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">},</code>
  <code class="nx">onClickCompact</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">}</code>
<code class="p">};</code></pre>

<p class="author1">The inverse of compact object literals is object destructuring. Instead of writing:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">props</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">props</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">props</code><code class="p">.</code><code class="nx">a</code><code class="p">;</code>
<code class="kd">const</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">props</code><code class="p">.</code><code class="nx">b</code><code class="p">;</code></pre>

<p class="author1">you can write:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">props</code><code class="p">}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">;</code>
<code class="kd">const</code> <code class="p">{</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">}</code> <code class="o">=</code> <code class="nx">props</code><code class="p">;</code></pre>

<p class="author1">or even:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">props</code><code class="o">:</code> <code class="p">{</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">}}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">;</code></pre>

<p class="author1">In this last example only <code class="calibre18">a</code> and <code class="calibre18">b</code> become variables, not <code class="calibre18">props</code>.</p>

<p class="author1">You may specify default values when destructuring. Instead of writing:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="p">{</code><code class="nx">a</code><code class="p">}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">props</code><code class="p">;</code>
<code class="kd">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">===</code> <code class="kd">undefined</code><code class="p">)</code> <code class="nx">a</code> <code class="o">=</code> <code class="s">'default'</code><code class="p">;</code></pre>

<p class="author1">write this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="p">{</code><code class="nx">a</code> <code class="o">=</code> <code class="s">'default'</code><code class="p">}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">props</code><code class="p">;</code></pre>

<p class="author1">You can also destructure arrays. This is particularly useful with tuple types:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
<code class="kd">const</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">]</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>
<code class="kd">const</code> <code class="p">[,</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="nx">point</code><code class="p">;</code>  <code class="c">// Ignore the first one</code></pre>

<p class="author1">Destructuring can also be used in function parameters:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">points</code> <code class="o">=</code> <code class="p">[</code>
  <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code>
  <code class="p">[</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code>
<code class="p">];</code>
<code class="nx">points</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">z</code><code class="p">));</code>
<code class="c">// Logs 6, 15</code></pre>

<p class="author1">As with compact object literal syntax, destructuring is concise and encourages consistent variable naming. Use it!</p>
</div></section>













<section class="praise" data-pdf-bookmark="Use Default Function Parameters" data-type="sect2"><div class="praise" id="idm45331643289240">
<h2 class="calibre31">Use Default Function Parameters</h2>

<p class="author1">In<a data-primary="functions" data-secondary="default function parameters" data-type="indexterm" id="idm45331642758200" class="calibre9"/> JavaScript, all function parameters are optional:</p>

<pre data-code-language="js" data-type="programlisting" id="log2" class="calibre17"><code class="kd">function</code> <code class="nx">log2</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">log2</code><code class="p">();</code></pre>

<p class="author1">This outputs:</p>

<pre data-type="programlisting" id="log2-output" class="calibre17">undefined undefined</pre>

<p class="author1">This is often used to implement default values for parameters:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseNum</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">base</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">base</code> <code class="o">=</code> <code class="nx">base</code> <code class="o">||</code> <code class="mi">10</code><code class="p">;</code>
  <code class="kd">return</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">base</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">In modern JavaScript, you can specify the default value directly in the parameter list:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">parseNum</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">base</code><code class="o">=</code><code class="mi">10</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">str</code><code class="p">,</code> <code class="nx">base</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">In addition to being more concise, this makes it clear that <code class="calibre18">base</code> is an optional parameter. Default parameters have another benefit when you migrate to TypeScript: they help the type checker infer the type of the parameter, removing the need for a type annotation. See <a href="ch03.html#avoid-inferable" class="calibre9">Item 19</a>.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Use async/await Instead of Raw Promises or Callbacks" data-type="sect2"><div class="praise" id="idm45331642759048">
<h2 class="calibre31">Use async/await Instead of Raw Promises or Callbacks</h2>

<p class="author1"><a href="ch03.html#use-async-await" class="calibre9">Item 25</a> explains<a data-primary="async/await" data-type="indexterm" id="idm45331642614552" class="calibre9"/><a data-primary="Promises" data-type="indexterm" id="idm45331642613928" class="calibre9"/><a data-primary="callbacks" data-secondary="versus async/await" data-secondary-sortas="async/await" data-type="indexterm" id="idm45331642613256" class="calibre9"/><a data-primary="await keyword" data-type="indexterm" id="idm45331642612040" class="calibre9"/> why <code class="calibre18">async</code> and <code class="calibre18">await</code> are preferable, but the gist is that they’ll simplify your code, prevent bugs, and help types flow through your asynchronous code.</p>

<p class="author1">Instead of either of these:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">getJSONCallback</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">,</code> <code class="nx">cb</code><code class="o">:</code> <code class="p">(</code><code class="nx">result</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kd">void</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">write this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">async</code> <code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code>: <code class="kd">string</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">response</code> <code class="o">=</code> <code class="kd">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
<code class="p">}</code></pre>
</div></section>













<section class="praise" data-pdf-bookmark="Don’t Put use strict in TypeScript" data-type="sect2"><div class="praise" id="idm45331642479064">
<h2 class="calibre31">Don’t Put use strict in TypeScript</h2>

<p class="author1">ES5<a data-primary="ES5" data-secondary="strict mode" data-type="indexterm" id="idm45331642472456" class="calibre9"/><a data-primary="use strict" data-type="indexterm" id="idm45331642471448" class="calibre9"/><a data-primary="strict mode" data-type="indexterm" id="idm45331642470776" class="calibre9"/> introduced “strict mode” to make some suspect patterns more explicit errors. You enable it by putting <code class="calibre18">'use strict'</code> in your code:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="s">'use strict'</code><code class="p">;</code>
<code class="kd">function</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
  <code class="nx">x</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>  <code class="c">// Throws in strict mode, defines a global in non-strict.</code>
<code class="p">}</code></pre>

<p class="author1">If you’ve never used strict mode in your JavaScript codebase, then give it a try. The errors it finds are likely to be ones that the TypeScript compiler will find, too.</p>

<p class="author1">But as you transition to TypeScript, there’s not much value in keeping <code class="calibre18">'use strict'</code> in your source code. By and large, the sanity checks that TypeScript provides are far stricter than those offered by strict mode.</p>

<p class="author1">There<a data-primary="compiling" data-secondary="compiler options" data-type="indexterm" id="idm45331642433032" class="calibre9"/> is some value in having a <code class="calibre18">'use strict'</code> in the JavaScript that <code class="calibre18">tsc</code> emits. If you set the <code class="calibre18">alwaysStrict</code> or <code class="calibre18">strict</code> compiler options, TypeScript will parse your code in strict mode and put a <code class="calibre18">'use strict'</code> in the JavaScript output for you.</p>

<p class="author1">In short, don’t write <code class="calibre18">'use strict'</code> in your TypeScript. Use <code class="calibre18">alwaysStrict</code> instead.</p>

<p class="author1">These are just a few of the many new JavaScript features that TypeScript lets you use. TC39, the body that governs JS standards, is very active, and new features are added year to year. The TypeScript team is currently committed to implementing any feature that reaches stage 3 (out of 4) in the standardization process, so you don’t even have to wait for the ink to dry. Check out the TC39 GitHub repo<sup class="calibre44"><a data-type="noteref" href="ch08.html#idm45331642441688" id="idm45331642441688-marker" class="calibre45">3</a></sup> for the latest. As of this writing, the pipeline and decorators proposals in particular have great potential to impact TypeScript.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331642439896">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">TypeScript lets you write modern JavaScript whatever your runtime environment. Take advantage of this by using the language features it enables. In addition to improving your codebase, this will help TypeScript understand your code.</p>
</li>
<li class="calibre12">
<p class="author1">Use TypeScript to learn language features like classes, destructuring, and <code class="calibre18">async</code>/<code class="calibre18">await</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Don’t bother with <code class="calibre18">'use strict'</code>: TypeScript is stricter.</p>
</li>
<li class="calibre12">
<p class="author1">Check<a data-primary="TC39" data-type="indexterm" id="idm45331642513944" class="calibre9"/><a data-primary="TypeScript" data-secondary="release notes" data-type="indexterm" id="idm45331642513208" class="calibre9"/> the TC39 GitHub repo and TypeScript release notes to learn about all the latest language features.<a data-primary="" data-startref="Mmodern08" data-type="indexterm" id="idm45331642512024" class="calibre9"/><a data-primary="" data-startref="JSmodern08" data-type="indexterm" id="idm45331642511080" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 59: Use @ts-check and JSDoc to Experiment with TypeScript" data-type="sect1" class="praise"><div class="praise" id="jsdoc-tscheck">
<h1 class="calibre16">Item 59: Use @ts-check and JSDoc to Experiment with TypeScript</h1>

<p class="author1">Before<a data-primary="migration" data-secondary="experimenting with TypeScript" data-type="indexterm" id="Mexper08" class="calibre9"/><a data-primary="@ts-check" data-type="indexterm" id="attscheck08" class="calibre9"/><a data-primary="JSDoc-style comments" data-type="indexterm" id="jsdoc08" class="calibre9"/><a data-primary="TypeScript" data-secondary="experimenting with" data-type="indexterm" id="TSexper08" class="calibre9"/> you begin the process of converting your source files from JavaScript to TypeScript (<a href="#allowjs" class="calibre9">Item 60</a>), you may want to experiment with type checking to get an initial read on the sorts of issues that will come up. TypeScript’s <code class="calibre18">@ts-check</code> directive lets you do exactly this. It directs the type checker to analyze a single file and report whatever issues it finds. You can think of it as an extremely loose version of type checking: looser even than TypeScript with <code class="calibre18">noImplicitAny</code> off (<a href="ch01.html#which-ts" class="calibre9">Item 2</a>).<a data-primary="Hopper, Grace" data-type="indexterm" id="idm45331642404792" class="calibre9"/></p>

<p class="author1">Here’s how it works:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="kd">const</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code><code class="nx">first</code><code class="o">:</code> <code class="s">'Grace'</code><code class="p">,</code> <code class="nx">last</code><code class="o">:</code> <code class="s">'Hopper'</code><code class="p">};</code>
<code class="mi">2</code> <code class="o">*</code> <code class="nx">person</code><code class="p">.</code><code class="nx">first</code>
 <code class="c">// ~~~~~~~~~~~~ The right-hand side of an arithmetic operation must be of type</code>
 <code class="c">//              'any', 'number', 'bigint', or an enum type</code></pre>

<p class="author1">TypeScript infers the type of <code class="calibre18">person.first</code> as <code class="calibre18">string</code>, so <code class="calibre18">2 * person.first</code> is a type error, no type annotations required.</p>

<p class="author1">While it may surface this sort of blatant type error, or functions called with too many arguments, in practice, <code class="calibre18">// @ts-check</code> tends to turn up a few specific types of errors:</p>








<section class="praise" data-pdf-bookmark="Undeclared Globals" data-type="sect2"><div class="praise" id="idm45331642386216">
<h2 class="calibre31">Undeclared Globals</h2>

<p class="author1">If<a data-primary="global variables" data-type="indexterm" id="idm45331642381832" class="calibre9"/><a data-primary="undeclared globals" data-type="indexterm" id="idm45331642381096" class="calibre9"/> these are symbols that you’re defining, then declare them with <code class="calibre18">let</code> or <code class="calibre18">const</code>. If they are “ambient” symbols that are defined elsewhere (in a <code class="calibre18">&lt;script&gt;</code> tag in an HTML file, for instance), then you can create a type declarations file to describe them.</p>

<p class="author1">For example, if you have JavaScript like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">firstName</code><code class="p">);</code>
         <code class="c">// ~~~~ Cannot find name 'user'</code></pre>

<p class="author1">then you could create a file called <em class="calibre3">types.d.ts</em>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">UserData</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">lastName</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">declare</code> <code class="kd">let</code> <code class="nx">user</code>: <code class="nx">UserData</code><code class="p">;</code></pre>

<p class="author1">Creating this file on its own may fix the issue. If it does not, you may need to explicitly import it with a “triple-slash” reference:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="c">/// &lt;reference path="./types.d.ts" /&gt;</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">user</code><code class="p">.</code><code class="nx">firstName</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">This <em class="calibre3">types.d.ts</em> file is a valuable artifact that will become the basis for your project’s type declarations.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Unknown Libraries" data-type="sect2"><div class="praise" id="idm45331642385752">
<h2 class="calibre31">Unknown Libraries</h2>

<p class="author1">If<a data-primary="libraries" data-secondary="unknown third-party" data-type="indexterm" id="idm45331642285192" class="calibre9"/><a data-primary="unknown libraries" data-type="indexterm" id="idm45331642284184" class="calibre9"/> you’re using a third-party library, TypeScript needs to know about it. For example, you might use jQuery to set the size of an HTML element. With <code class="calibre18">@ts-check</code>, TypeScript will flag an error:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
   <code class="nx">$</code><code class="p">(</code><code class="s">'#graph'</code><code class="p">).</code><code class="nx">style</code><code class="p">({</code><code class="s">'width'</code><code class="o">:</code> <code class="s">'100px'</code><code class="p">,</code> <code class="s">'height'</code><code class="o">:</code> <code class="s">'100px'</code><code class="p">});</code>
<code class="c">// ~ Cannot find name '$'</code></pre>

<p class="author1">The<a data-primary="jQuery" data-secondary="type declarations for" data-type="indexterm" id="idm45331642245304" class="calibre9"/> solution is to install the type declarations for jQuery:</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">npm install --save-dev @types/jquery</strong></pre>

<p class="author1">Now the error is specific to jQuery:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="nx">$</code><code class="p">(</code><code class="s">'#graph'</code><code class="p">).</code><code class="nx">style</code><code class="p">({</code><code class="s">'width'</code><code class="o">:</code> <code class="s">'100px'</code><code class="p">,</code> <code class="s">'height'</code><code class="o">:</code> <code class="s">'100px'</code><code class="p">});</code>
         <code class="c">// ~~~~~ Property 'style' does not exist on type 'JQuery&lt;HTMLElement&gt;'</code></pre>

<p class="author1">In fact, it should be <code class="calibre18">.css</code>, not <code class="calibre18">.style</code>.</p>

<p class="author1"><code class="calibre18">@ts-check</code> lets you take advantage of the TypeScript declarations for popular JavaScript libraries without migrating to TypeScript yourself. This is one of the best reasons to use it.</p>
</div></section>













<section class="praise" data-pdf-bookmark="DOM Issues" data-type="sect2"><div class="praise" id="idm45331642286696">
<h2 class="calibre31">DOM Issues</h2>

<p class="author1">Assuming<a data-primary="DOM hierarchy" data-type="indexterm" id="idm45331642211528" class="calibre9"/> you’re writing code that runs in a web browser, TypeScript is likely to flag issues around your handling of DOM elements. For example:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="kd">const</code> <code class="nx">ageEl</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'age'</code><code class="p">);</code>
<code class="nx">ageEl</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s">'12'</code><code class="p">;</code>
   <code class="c">// ~~~~~ Property 'value' does not exist on type 'HTMLElement'</code></pre>

<p class="author1">The issue is that only <code class="calibre18">HTMLInputElement</code>s have a <code class="calibre18">value</code> property, but <code class="calibre18">document.getElementById</code> returns the more generic <code class="calibre18">HTMLElement</code> (see <a href="ch07.html#understand-the-dom" class="calibre9">Item 55</a>). If you know that the <code class="calibre18">#age</code> element really is an <code class="calibre18">input</code> element, then this is an appropriate time to use a type assertion (<a href="ch02_split_000.html#prefer-declarations-to-assertions" class="calibre9">Item 9</a>). But this is still a JS file, so you can’t write <code class="calibre18">as HTMLInputElement</code>. Instead, you can assert a type using JSDoc:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="kd">const</code> <code class="nx">ageEl</code> <code class="o">=</code> <code class="c">/** @type {HTMLInputElement} */</code><code class="p">(</code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'age'</code><code class="p">));</code>
<code class="nx">ageEl</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s">'12'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">If you mouse over <code class="calibre18">ageEl</code> in your editor, you’ll see that TypeScript now considers it an <code class="calibre18">HTMLInputElement</code>. Take care as you type the JSDoc <code class="calibre18">@type</code> annotation: the parentheses after the comment are required.</p>

<p class="author1">This leads to another type of error that comes up with <code class="calibre18">@ts-check</code>, inaccurate JSDoc, as explained next.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Inaccurate JSDoc" data-type="sect2"><div class="praise" id="idm45331642119848">
<h2 class="calibre31">Inaccurate JSDoc</h2>

<p class="author1">If your project already has JSDoc-style comments, TypeScript will begin checking them when you flip on <code class="calibre18">@ts-check</code>. If you previously used a system like the<a data-primary="Closure Compiler" data-type="indexterm" id="idm45331642117320" class="calibre9"/> Closure Compiler that used these comments to enforce type safety, then this shouldn’t cause major headaches. But you may be in for some surprises if your comments were more like “aspirational JSDoc”:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="c">/**</code>
<code class="c"> * Gets the size (in pixels) of an element.</code>
<code class="c"> * @param {Node} el The element</code>
<code class="c"> * @return {{w: number, h: number}} The size</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="nx">getSize</code><code class="p">(</code><code class="nx">el</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">bounds</code> <code class="o">=</code> <code class="nx">el</code><code class="p">.</code><code class="nx">getBoundingClientRect</code><code class="p">();</code>
                 <code class="c">// ~~~~~~~~~~~~~~~~~~~~~ Property 'getBoundingClientRect'</code>
                 <code class="c">//                       does not exist on type 'Node'</code>
  <code class="kd">return</code> <code class="p">{</code><code class="nx">width</code><code class="o">:</code> <code class="nx">bounds</code><code class="p">.</code><code class="nx">width</code><code class="p">,</code> <code class="nx">height</code><code class="o">:</code> <code class="nx">bounds</code><code class="p">.</code><code class="nx">height</code><code class="p">};</code>
       <code class="c">// ~~~~~~~~~~~~~~~~~~~ Type '{ width: any; height: any; }' is not</code>
       <code class="c">//                     assignable to type '{ w: number; h: number; }'</code>
<code class="p">}</code></pre>

<p class="author1">The first issue is a misunderstanding of the DOM: <code class="calibre18">getBoundingClientRect()</code> is defined on <code class="calibre18">Element</code>, not <code class="calibre18">Node</code>. So the <code class="calibre18">@param</code> tag should be updated. The second is a mismatch between proprties specified in the <code class="calibre18">@return</code> tag and the implementation. Presumably the rest of the project uses the <code class="calibre18">width</code> and <code class="calibre18">height</code> properties, so the <code class="calibre18">@return</code> tag should be updated.</p>

<p class="author1">You can use JSDoc to gradually add type annotations to your project. The TypeScript language service will offer to infer type annotations as a quick fix for code where it’s clear from usage, as shown here and in <a data-type="xref" href="#efts-08in02" class="calibre9">Figure 8-2</a>:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">val</code><code class="p">;</code>
<code class="p">}</code></pre>

<figure class="calibre28"><div class="figure" id="efts-08in02">
<img alt="efts 08in02" src="assets/efts_08in02.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 8-2. </span>The TypeScript Language Services offer a quick fix to infer paramter types from usage.</h6>
</div></figure>

<p class="author1">This results in a correct JSDoc annotation:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="c">/**</code>
<code class="c"> * @param {number} val</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">val</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This can be helpful to encourage types to flow through your code with <code class="calibre18">@ts-check</code>. But it doesn’t always work so well. For instance:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">loadData</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">data</code><code class="p">.</code><code class="nx">files</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">async</code> <code class="nx">file</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c">// ...</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

<p class="author1">If you use the quick fix to annotate <code class="calibre18">data</code>, you’ll wind up with:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * @param {{</code>
<code class="c"> *  files: { forEach: (arg0: (file: any) =&gt; Promise&lt;void&gt;) =&gt; void; };</code>
<code class="c"> * }} data</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="nx">loadData</code><code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">This is structural typing gone awry (<a href="ch01.html#structural" class="calibre9">Item 4</a>). While the function would technically work on any sort of object with a <code class="calibre18">forEach</code> method with that signature, the intent was most likely for the parameter to be <code class="calibre18">{files: string[]}</code>.</p>

<p class="author1">You can get much of the TypeScript experience in a JavaScript project using JSDoc annotations and <code class="calibre18">@ts-check</code>. This is appealing because it requires no changes in your tooling. But it’s best not to go too far in this direction. Comment boilerplate has real costs: it’s easy for your logic to get lost in a sea of JSDoc. TypeScript works best with <em class="calibre3">.ts</em> files, not <em class="calibre3">.js</em> files. The goal is ultimately to convert your project to TypeScript, not to JavaScript with JSDoc annotations. But <code class="calibre18">@ts-check</code> can be a useful way to experiment with types and find some initial errors, especially for projects that already have extensive JSDoc annotations.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331642119224">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Add "<code class="calibre18">// @ts-check</code>" to the top of a JavaScript file to enable type checking.</p>
</li>
<li class="calibre12">
<p class="author1">Recognize common errors. Know how to declare globals and add type declarations for third-party libraries.</p>
</li>
<li class="calibre12">
<p class="author1">Use JSDoc annotations for type assertions and better type inference.</p>
</li>
<li class="calibre12">
<p class="author1">Don’t spend too much time getting your code perfectly typed with JSDoc. Remember that the goal is to convert to <em class="calibre3">.ts</em>!<a data-primary="" data-startref="Mexper08" data-type="indexterm" id="idm45331641833928" class="calibre9"/><a data-primary="" data-startref="attscheck08" data-type="indexterm" id="idm45331641832920" class="calibre9"/><a data-primary="" data-startref="jsdoc08" data-type="indexterm" id="idm45331641831976" class="calibre9"/><a data-primary="" data-startref="TSexper08" data-type="indexterm" id="idm45331641831032" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 60: Use allowJs to Mix TypeScript and JavaScript" data-type="sect1" class="praise"><div class="praise" id="allowjs">
<h1 class="calibre16">Item 60: Use allowJs to Mix TypeScript and JavaScript</h1>

<p class="author1">For<a data-primary="migration" data-secondary="mixing TypeScript with JavaScript" data-type="indexterm" id="idm45331641827768" class="calibre9"/><a data-primary="allowJs" data-type="indexterm" id="idm45331641826792" class="calibre9"/><a data-primary="TypeScript" data-secondary="mixing with JavaScript" data-type="indexterm" id="idm45331641826120" class="calibre9"/><a data-primary="JavaScript" data-secondary="mixing with TypeScript" data-type="indexterm" id="idm45331641825176" class="calibre9"/> a small project, you may be able to convert from JavaScript to TypeScript in one fell swoop. But for a larger project this “stop the world” approach won’t work. You need to be able to transition gradually. That means you need a way for TypeScript and JavaScript to coexist.</p>

<p class="author1">The<a data-primary="compiling" data-secondary="compiler options" data-type="indexterm" id="idm45331641823192" class="calibre9"/> key to this is the <code class="calibre18">allowJs</code> compiler option. With <code class="calibre18">allowJs</code>, TypeScript files and JavaScript files may import one another. For JavaScript files this mode is extremely permissive. Unless you use <code class="calibre18">@ts-check</code> (<a href="#jsdoc-tscheck" class="calibre9">Item 59</a>), the only errors you’ll see are syntax errors. This is “TypeScript is a superset of JavaScript” in the most trivial sense.</p>

<p class="author1">While it’s unlikely to catch errors, <code class="calibre18">allowJs</code> does give you an opportunity to introduce TypeScript into your build chain before you start making code changes. This is a good idea because you’ll want to be able to run your tests as you convert modules to TypeScript (<a href="#convert-up-the-graph" class="calibre9">Item 61</a>).</p>

<p class="author1">If your bundler includes TypeScript integration or has a plug-in available, that’s usually the easiest path forward. With<a data-primary="browserify" data-type="indexterm" id="idm45331641800904" class="calibre9"/> <code class="calibre18">browserify</code>, for instance, you run <code class="calibre18">npm install --sav-dev tsify</code> and add it as a plug-in:</p>
<pre data-type="programlisting" class="calibre17">$ <strong class="calibre32">browserify index.ts -p [ tsify --noImplicitAny ] &gt; bundle.js</strong></pre>

<p class="author1">Most unit testing tools have an option like this as well. With the <code class="calibre18">jest</code> tool, for instance, you install <code class="calibre18">ts-jest</code> and pass TypeScript sources through it by specifying a <code class="calibre18">jest.config.js</code> like:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">transform</code><code class="o">:</code> <code class="p">{</code>
    <code class="s">'^.+\\.tsx?$'</code><code class="o">:</code> <code class="s">'ts-jest'</code><code class="p">,</code>
  <code class="p">},</code>
<code class="p">};</code></pre>

<p class="author1">If your build chain is custom, your task will be more involved. But there’s always a good fallback option: when you specify the <code class="calibre18">outDir</code> option, TypeScript will generate pure JavaScript sources in a directory that parallels your source tree. Usually your existing build chain can be run over that. You may need to tweak TypeScript’s JavaScript output so that it closely matches your original JavaScript source, (e.g., by specifying the <code class="calibre18">target</code> and <code class="calibre18">module</code> options).</p>

<p class="author1">Adding TypeScript into your build and test process may not be the most enjoyable task, but it is an essential one that will let you begin to migrate your code with <span class="calibre">confidence.</span></p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331641776184">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Use the <code class="calibre18">allowJs</code> compiler option to support mixed JavaScript and TypeScript as you transition your project.</p>
</li>
<li class="calibre12">
<p class="author1">Get your tests and build chain working with TypeScript before beginning large-scale migration.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 61: Convert Module by Module Up Your Dependency Graph" data-type="sect1" class="praise"><div class="praise" id="convert-up-the-graph">
<h1 class="calibre16">Item 61: Convert Module by Module Up Your Dependency Graph</h1>

<p class="author1">You’ve<a data-primary="migration" data-secondary="converting module by module" data-type="indexterm" id="Mconvert08" class="calibre9"/> adopted modern JavaScript, converting your project to use ECMAScript modules and classes (<a href="#write-modern-js" class="calibre9">Item 58</a>). You’ve integrated TypeScript into your build chain and have all your tests passing (<a href="#allowjs" class="calibre9">Item 60</a>). Now for the fun part: converting your JavaScript to TypeScript. But where to begin?</p>

<p class="author1">When you add types to a module, it’s likely to surface new type errors in all the modules that depend on it. Ideally you’d like to convert each module once and be done with it. This implies that you should convert modules going <em class="calibre3">up</em> the dependency graph: starting with the leaves (modules that depend on no others) and moving up to the root.</p>

<p class="author1">The very first modules to migrate are your third-party dependencies since, by definition, you depend on them but they do not depend on you. Usually this means installing <code class="calibre18">@types</code> modules. If you use the <code class="calibre18">lodash</code> utility library, for example, you’d run <code class="calibre18">npm install --save-dev @types/lodash</code>. These typings will help types flow through your code and surface issues in your use of the libraries.</p>

<p class="author1">If your code calls external APIs, you may also want to add type declarations for these early on. Although these calls may happen anywhere in your code, this is still in the spirit of moving up the dependency graph since you depend on the APIs but they do not depend on you. Many types flow from API calls, and these are generally difficult to infer from context. If you can find a spec for the API, generate types from that (see <a href="ch04.html#consider-codegen" class="calibre9">Item 35</a>).</p>

<p class="author1">As you migrate your own modules, it’s helpful to visualize the dependency graph. <a data-type="xref" href="#initial-dag" class="calibre9">Figure 8-3</a> shows an example graph from a medium-sized JavaScript project, made using the excellent <code class="calibre18">madge</code> tool.</p>

<figure class="calibre28"><div class="figure" id="initial-dag">
<img alt="efts 0801" src="assets/efts_0801.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 8-3. </span>The dependency graph for a medium-sized JavaScript project. Arrows indicate dependencies. Darker-shaded boxes indicate that a module is involved in a circular dependency.</h6>
</div></figure>

<p class="author1">The bottom of this dependency graph is the circular dependency between <em class="calibre3">utils.js</em> and <em class="calibre3">tickers.js</em>. There are many modules that depend on these two, but they only depend on one another. This pattern is quite common: most projects will have some sort of utility module at the bottom of the dependency graph.</p>

<p class="author1">As you migrate your code, focus on adding types rather than refactoring. If this is an old project, you’re likely to notice some strange things and want to fix them. Resist this urge! The immediate goal is to convert your project to TypeScript, not to improve its design. Instead, write down code smells as you detect them and make a list of future refactors.</p>

<p class="author1">There are a few common errors you’ll run into as you convert to TypeScript. Some of these were covered in <a href="#jsdoc-tscheck" class="calibre9">Item 59</a>, but new ones include:</p>








<section class="praise" data-pdf-bookmark="Undeclared Class Members" data-type="sect2"><div class="praise" id="idm45331641734216">
<h2 class="calibre31">Undeclared Class Members</h2>

<p class="author1">Classes in JavaScript do not need to declare their members, but classes in TypeScript do. When you rename a class’s <em class="calibre3">.js</em> file to <em class="calibre3">.ts</em>, it’s likely to show errors for every single property you reference:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Greeting</code> <code class="p">{</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">=</code> <code class="s">'Hello'</code><code class="p">;</code>
      <code class="c">// ~~~~~~~~ Property 'greeting' does not exist on type 'Greeting'</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
      <code class="c">// ~~~~ Property 'name' does not exist on type 'Greeting'</code>
  <code class="p">}</code>
  <code class="nx">greet() {</code>
    <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">+</code> <code class="s">' '</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
             <code class="c">// ~~~~~~~~              ~~~~ Property ... does not exist</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">There’s a helpful quick fix (see <a data-type="xref" href="#efts-08in03" class="calibre9">Figure 8-4</a>) for this that you should take advantage of.</p>

<figure class="calibre28"><div class="figure" id="efts-08in03">
<img alt="efts 08in03" src="assets/efts_08in03.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 8-4. </span>The quick fix to add declarations for missing members is particularly helpful in converting a class to TypeScript.</h6>
</div></figure>

<p class="author1">This will add declarations for the missing members based on usage:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Greeting</code> <code class="p">{</code>
  <code class="nx">greeting</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="nx">any</code><code class="p">;</code>
  <code class="kd">constructor</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">=</code> <code class="s">'Hello'</code><code class="p">;</code>
    <code class="kd">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nx">greet() {</code>
    <code class="kd">return</code> <code class="kd">this</code><code class="p">.</code><code class="nx">greeting</code> <code class="o">+</code> <code class="s">' '</code> <code class="o">+</code> <code class="kd">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript was able to get the type for <code class="calibre18">greeting</code> correct, but not the type for <code class="calibre18">name</code>. After applying this quick fix, you should look through the property list and fix the <code class="calibre18">any</code> types.</p>

<p class="author1">If<a data-primary="dygraph.js" data-type="indexterm" id="idm45331641607144" class="calibre9"/> this is the first time you’ve seen the full property list for your class, you may be in for a shock. When I converted the main class in <em class="calibre3">dygraph.js</em> (the root module in <a data-type="xref" href="#initial-dag" class="calibre9">Figure 8-3</a>), I discovered that it had no fewer than 45 member variables! Migrating to TypeScript has a way of surfacing bad designs like this that were previously implicit. It’s harder to justify a bad design if you have to look at it. But again, resist the urge to refactor now. Note the oddity and think about how you’d fix it some other day.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Values with Changing Types" data-type="sect2"><div class="praise" id="idm45331641733784">
<h2 class="calibre31">Values with Changing Types</h2>

<p class="author1">TypeScript will complain about code like this:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">state</code> <code class="o">=</code> <code class="p">{};</code>
<code class="nx">state</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s">'New York'</code><code class="p">;</code>
   <code class="c">// ~~~~ Property 'name' does not exist on type '{}'</code>
<code class="nx">state</code><code class="p">.</code><code class="nx">capital</code> <code class="o">=</code> <code class="s">'Albany'</code><code class="p">;</code>
   <code class="c">// ~~~~~~~ Property 'capital' does not exist on type '{}'</code></pre>

<p class="author1">This topic is covered in more depth in <a href="ch03.html#all-at-once" class="calibre9">Item 23</a>, so you may want to brush up on that item if you run into this error. If the fix is trivial, you can build the object all at once:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">state</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s">'New York'</code><code class="p">,</code>
  <code class="nx">capital</code><code class="o">:</code> <code class="s">'Albany'</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// OK</code></pre>

<p class="author1">If it is not, then this is an appropriate time to use a type assertion:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">State</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">capital</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">state</code> <code class="o">=</code> <code class="p">{}</code> <code class="kd">as</code> <code class="nx">State</code><code class="p">;</code>
<code class="nx">state</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s">'New York'</code><code class="p">;</code>  <code class="c">// OK</code>
<code class="nx">state</code><code class="p">.</code><code class="nx">capital</code> <code class="o">=</code> <code class="s">'Albany'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">You should fix this eventually (see <a href="ch02_split_000.html#prefer-declarations-to-assertions" class="calibre9">Item 9</a>), but this is expedient and will help you keep the migration going.</p>

<p class="author1">If you’ve been using JSDoc and <code class="calibre18">@ts-check</code> (<a href="#jsdoc-tscheck" class="calibre9">Item 59</a>), be aware that you can actually <em class="calibre3">lose</em> type safety by converting to TypeScript. For instance, TypeScript flags an error in this JavaScript:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="c">// @ts-check</code>
<code class="c">/**</code>
<code class="c"> * @param {number} num</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">num</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">double</code><code class="p">(</code><code class="s">'trouble'</code><code class="p">);</code>
    <code class="c">// ~~~~~~~~~ Argument of type '"trouble"' is not assignable to</code>
    <code class="c">//           parameter of type 'number'</code></pre>

<p class="author1">When you convert to TypeScript, the <code class="calibre18">@ts-check</code> and JSDoc stop being enforced. This means the type of <code class="calibre18">num</code> is implicitly <code class="calibre18">any</code>, so there’s no error:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="c">/**</code>
<code class="c"> * @param {number} num</code>
<code class="c"> */</code>
<code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">num</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">double</code><code class="p">(</code><code class="s">'trouble'</code><code class="p">);</code>  <code class="c">// OK</code></pre>

<p class="author1">Fortunately there’s a quick fix available to move JSDoc types to TypeScript types. If you have any JSDoc, you should use what’s shown in <a data-type="xref" href="#efts-08in04" class="calibre9">Figure 8-5</a>.</p>

<figure class="width1"><div class="figure" id="efts-08in04">
<img alt="efts 08in04" src="assets/efts_08in04.png" class="calibre30"/>
<h6 class="calibre29"><span class="calibre">Figure 8-5. </span>Quick fix to copy JSDoc annotations to TypeScript type annotations</h6>
</div></figure>

<p class="author1">Once you’ve copied type annotations to TypeScript, make sure to remove them from the JSDoc to avoid redundancy (see <a href="ch04.html#jsdoc-repeat" class="calibre9">Item 30</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="kd">double</code><code class="p">(</code><code class="nx">num</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">num</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">double</code><code class="p">(</code><code class="s">'trouble'</code><code class="p">);</code>
    <code class="c">// ~~~~~~~~~ Argument of type '"trouble"' is not assignable to</code>
    <code class="c">//           parameter of type 'number'</code></pre>

<p class="author1">This issue will also be caught when you turn on <code class="calibre18">noImplicitAny</code>, but you may as well add the types now.</p>

<p class="author1">Migrate your tests last. They should be at the top of your dependency graph (since your code doesn’t depend on them), and it’s extremely helpful to know that your tests continue to pass during the migration despite your not having changed them at all.</p>
</div></section>













<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331641603928">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Start migration by adding <code class="calibre18">@types</code> for third-party modules and external API calls.</p>
</li>
<li class="calibre12">
<p class="author1">Begin migrating your modules from the bottom of the dependency graph upwards. The first module will usually be some sort of utility code. Consider visualizing the dependency graph to help you track progress.</p>
</li>
<li class="calibre12">
<p class="author1">Resist the urge to refactor your code as you uncover odd designs. Keep a list of ideas for future refactors, but stay focused on TypeScript conversion.</p>
</li>
<li class="calibre12">
<p class="author1">Be aware of common errors that come up during conversion. Copy JSDoc annotations if necessary to avoid losing type safety as you convert.<a data-primary="" data-startref="Mconvert08" data-type="indexterm" id="idm45331641307336" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 62: Don’t Consider Migration Complete Until You Enable noImplicitAny" data-type="sect1" class="praise"><div class="praise" id="start-loose">
<h1 class="calibre16">Item 62: Don’t Consider Migration Complete Until You Enable noImplicitAny</h1>

<p class="author1">Converting<a data-primary="migration" data-secondary="noImplicitAny" data-type="indexterm" id="idm45331641303816" class="calibre9"/><a data-primary="noImplicitAny" data-type="indexterm" id="idm45331641302808" class="calibre9"/> your whole project to <em class="calibre3">.ts</em> is a big accomplishment. But your work isn’t done quite yet. Your next goal is to turn on the <code class="calibre18">noImplicitAny</code> option (<a href="ch01.html#which-ts" class="calibre9">Item 2</a>). TypeScript code without <code class="calibre18">noImplicitAny</code> is best thought of as transitional because it can mask real errors you’ve made in your type declarations.</p>

<p class="author1">For example, perhaps you’ve used the “Add all missing members” quick fix to add property declarations to a class (<a href="#convert-up-the-graph" class="calibre9">Item 61</a>). You’re left with an <code class="calibre18">any</code> type and would like to fix it:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Chart</code> <code class="p">{</code>
  <code class="nx">indices</code>: <code class="nx">any</code><code class="p">;</code>

  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1"><code class="calibre18">indices</code> sounds like it should be an array of numbers, so you plug in that type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">class</code> <code class="nx">Chart</code> <code class="p">{</code>
  <code class="nx">indices</code>: <code class="nx">number</code><code class="p">[];</code>

  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">No new errors result, so you then keep moving. Unfortunately, you’ve made a mistake: <code class="calibre18">number[]</code> is the wrong type. Here’s some code from elsewhere in the class:</p>

<pre data-code-language="ts" data-type="programlisting" id="get-ranges" class="calibre17"><code class="nx">getRanges() {</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">r</code> <code class="nx">of</code> <code class="kd">this</code><code class="p">.</code><code class="nx">indices</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">low</code> <code class="o">=</code> <code class="nx">r</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>  <code class="c">// Type is any</code>
    <code class="kd">const</code> <code class="nx">high</code> <code class="o">=</code> <code class="nx">r</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>  <code class="c">// Type is any</code>
    <code class="c">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">Clearly <code class="calibre18">number[][]</code> or <code class="calibre18">[number, number][]</code> would be a more accurate type. Does it surprise you that indexing into a <code class="calibre18">number</code> is allowed? Take this as an indication of just how loose TypeScript can be without <code class="calibre18">noImplicitAny</code>.</p>

<p class="author1">When you turn on <code class="calibre18">noImplicitAny</code>, this becomes an error:</p>

<pre data-code-language="ts" data-type="programlisting" id="get-ranges-no-implicit-any" class="calibre17"><code class="nx">getRanges() {</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">r</code> <code class="nx">of</code> <code class="kd">this</code><code class="p">.</code><code class="nx">indices</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">low</code> <code class="o">=</code> <code class="nx">r</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
             <code class="c">// ~~~~ Element implicitly has an 'any' type because</code>
             <code class="c">//      type 'Number' has no index signature</code>
    <code class="kd">const</code> <code class="nx">high</code> <code class="o">=</code> <code class="nx">r</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code>
              <code class="c">// ~~~~ Element implicitly has an 'any' type because</code>
              <code class="c">//      type 'Number' has no index signature</code>
    <code class="c">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">A<a data-primary="tsconfig.json" data-secondary="noImplicitAny" data-type="indexterm" id="idm45331641163256" class="calibre9"/> good strategy for enabling <code class="calibre18">noImplicitAny</code> is to set it in your local client and start fixing errors. The number of errors you get from the type checker gives you a good sense of your progress. You can commit the type corrections without committing the <em class="calibre3">tsconfig.json</em> change until you get the number of errors down to zero.</p>

<p class="author1">There are many other knobs you can turn to increase the strictness of type checking, culminating with <code class="calibre18">"strict": true</code>. But <code class="calibre18">noImplicitAny</code> is the most important one and your project will get most of the benefits of TypeScript even if you don’t adopt other settings like <code class="calibre18">strictNullChecks</code>. Give everyone on your team a chance to get used to TypeScript before you adopt stricter settings.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331641108856">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Don’t consider your TypeScript migration done until you adopt <code class="calibre18">noImplicitAny</code>. Loose type checking can mask real mistakes in type declarations.</p>
</li>
<li class="calibre12">
<p class="author1">Fix type errors gradually before enforcing <code class="calibre18">noImplicitAny</code>. Give your team a chance to get comfortable with TypeScript before adopting stricter checks.<a data-primary="" data-startref="JSmig08" data-type="indexterm" id="idm45331641104744" class="calibre9"/><a data-primary="" data-startref="TSmig08" data-type="indexterm" id="idm45331641103768" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>







<div data-type="footnotes" class="calibre46"><p data-type="footnote" id="idm45331644007096" class="calibre47"><sup class="calibre48"><a href="ch08.html#idm45331644007096-marker" class="calibre45">1</a></sup> Z. Gao, C. Bird, and E. T. Barr, “To Type or Not to Type: Quantifying Detectable Bugs in JavaScript,” ICSE 2017, <a href="http://earlbarr.com/publications/typestudy.pdf" class="calibre9"><em class="calibre3">http://earlbarr.com/publications/typestudy.pdf</em></a>.</p><p data-type="footnote" id="idm45331644005032" class="calibre47"><sup class="calibre48"><a href="ch08.html#idm45331644005032-marker" class="calibre45">2</a></sup> Brie Bunge, “Adopting TypeScript at Scale,” JSConf Hawaii 2019, <a href="https://youtu.be/P-J9Eg7hJwE" class="calibre9"><em class="calibre3">https://youtu.be/P-J9Eg7hJwE</em></a>.</p><p data-type="footnote" id="idm45331642441688" class="calibre47"><sup class="calibre48"><a href="ch08.html#idm45331642441688-marker" class="calibre45">3</a></sup> <a href="https://github.com/tc39/proposals" class="calibre9"><em class="calibre3">https://github.com/tc39/proposals</em></a></p></div></div></section></body></html>