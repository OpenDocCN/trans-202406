- en: Chapter 16\. Using Joins and Subqueries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 16.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most queries in earlier chapters used a single table, but for any application
    of even moderate complexity, you’ll likely need to use multiple tables. Some questions
    simply cannot be answered using a single table, and the real power of a relational
    database comes into play when you combine the information from multiple sources:'
  prefs: []
  type: TYPE_NORMAL
- en: Combine rows from tables to obtain more comprehensive information than can be
    obtained from individual tables alone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hold intermediate results for a multiple-stage operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify rows in one table based on information from another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter focuses on two types of statements that use multiple tables: joins
    between tables and subqueries that nest one `SELECT` within another. It covers
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Comparing tables to find matches or mismatches
  prefs: []
  type: TYPE_NORMAL
- en: To solve such problems, you should know which types of joins apply. Inner joins
    show which rows in one table match rows in another. Outer joins show matching
    rows, but also find rows in one table *not* matched by rows in another.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting unmatched rows
  prefs: []
  type: TYPE_NORMAL
- en: If two datasets are related, but imperfectly, you can determine which rows are
    unmatched and remove them as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing a table to itself
  prefs: []
  type: TYPE_NORMAL
- en: Some problems require comparing a table to itself. This is similar to performing
    a join between different tables, except that you must use table aliases to disambiguate
    table references.
  prefs: []
  type: TYPE_NORMAL
- en: Producing candidate-detail and many-to-many relationships
  prefs: []
  type: TYPE_NORMAL
- en: Joins enable production of lists or summaries when each item in one table can
    match many in the other, or when each item in either table can match many in the
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts that create tables used in this chapter are located in the *tables*
    directory of the `recipes` distribution. For scripts that implement techniques
    discussed here, look in the *joins* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 16.1 Finding Matches Between Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to perform a task that requires information from more than one table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a join—that is, a query that lists multiple tables in its `FROM` clause
    and tells MySQL how to match information from them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essential idea behind a join is that it matches rows in one table with rows
    in one or more other tables. Joins enable you to combine information from multiple
    tables when each one answers only part of the question in which you’re interested.
  prefs: []
  type: TYPE_NORMAL
- en: A complete join that produces all possible row combinations is called a Cartesian
    product. For example, joining each row in a 100-row table to each row in a 200-row
    table produces a result containing 100 × 200 = 20,000 rows. With larger tables,
    or joins between more than two tables, the result set for a Cartesian product
    easily becomes immense, so a join normally includes an `ON` or `USING` comparison
    clause to produce only the desired matches between tables. (This requires that
    each table have one or more columns of common information that link them together
    logically.) You can also include a `WHERE` clause that restricts which of the
    joined rows to select. Each clause narrows the focus of the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe introduces join syntax and demonstrates how joins answer specific
    types of questions when you are looking for matches between tables. Other sections
    show how to identify mismatches between tables (see [Recipe 16.2](#nch-multi-multi-outer-join))
    and how to compare a table to itself (see [Recipe 16.4](#nch-multi-multi-self-join)).
    The examples assume that you have an art collection and use the following two
    tables to record your acquisitions. `artist` lists those painters whose works
    you want to collect, and `painting` lists each painting you’ve actually purchased:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ve just begun the collection, so the tables contain only a few rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The low values in the `price` column of the `painting` table betray the fact
    that your collection actually contains only cheap imitations, not the originals.
    Well, that’s all right: who can afford the originals?'
  prefs: []
  type: TYPE_NORMAL
- en: Each table contains partial information about your collection. For example,
    the `artist` table doesn’t tell you which paintings each artist produced, and
    the `painting` table lists artist IDs but not their names. To use the information
    in both tables, write a query that performs a join. A join names two or more tables
    after the `FROM` keyword. In the output column list, use `*` to select all columns
    from all tables, *`tbl_name`*`.*` to select all columns from a given table, or
    name specific columns from the joined tables or expressions based on those columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest join involves two tables and selects all columns from each. The
    following join between the `artist` and `painting` tables shows this (the `ORDER`
    `BY` clause makes the result easier to read):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An `INNER` `JOIN` produces results that combine values in one table with values
    in another table. The preceding query specifies no restrictions on row matching,
    so the join generates all row combinations (that is, the Cartesian product). This
    result illustrates why such a join generally is not useful: it produces a lot
    of unmeaningful output. Clearly, you don’t maintain these tables to match every
    artist with every painting.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In MySQL, `JOIN`, `CROSS JOIN`, and `INNER JOIN` are syntactic equivalents and
    can replace each other. You can use `CROSS JOIN`, or simply `JOIN`, in all places
    where we use `INNER JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer questions meaningfully, produce only the relevant matches by including
    appropriate join conditions. For example, to produce a list of paintings together
    with the artist names, associate rows from the two tables using a simple `WHERE`
    clause that matches values based on the artist ID column that is common to both
    tables and serves to link them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The column names in the `WHERE` clause include table qualifiers to make it clear
    which `a_id` values to compare. The result indicates who painted each painting,
    and, conversely, which paintings by each artist are in your collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to write the same join indicates the matching conditions with an
    `ON` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the special case of equality comparisons between columns with the same name
    in both tables, you can use an `INNER` `JOIN` with a `USING` clause instead. This
    requires no table qualifiers and names each joined column only once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For `SELECT` `*` queries, the `USING` form produces a result that differs from
    the `ON` form: it returns only one instance of each join column, so `a_id` appears
    once, not twice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any of `ON`, `USING`, or `WHERE` can include comparisons, so how do you know
    which join conditions to put in each clause? As a rule of thumb, it’s conventional
    to use `ON` or `USING` to specify how to join the tables, and the `WHERE` clause
    to restrict which of the joined rows to select. For example, to join tables based
    on the `a_id` column, but select only rows for paintings obtained in Kentucky,
    use an `ON` (or `USING`) clause to match the rows in the two tables, and a `WHERE`
    clause to test the `state` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding queries use `SELECT` `*` to display all columns. To be more selective,
    name only those columns in which you’re interested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Joins can use more than two tables. Suppose that you prefer to see complete
    state names rather than abbreviations in the preceding query result. The `states`
    table used in earlier chapters maps state abbreviations to names; add it to the
    previous query to display name rather than abbreviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Another common use of three-way joins is enumerating many-to-many relationships
    (see [Recipe 16.6](#nch-multi-multi-many-to-many)).
  prefs: []
  type: TYPE_NORMAL
- en: 'By including appropriate conditions in your joins, you can answer very specific
    questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which paintings did Van Gogh paint? Use the `a_id` value to find matching rows,
    add a `WHERE` clause to restrict output to rows that contain the artist name,
    and select the title from those rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Who painted the *Mona Lisa*? Again, use the `a_id` column to join the rows,
    but this time use the `WHERE` clause to restrict output to rows that contain the
    title, and select the artist name from those rows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For which artists did you purchase paintings in Kentucky or Indiana? This is
    similar to the previous statement, but tests a different column in the `painting`
    table (`state`) to restrict output to rows for `KY` or `IN`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The statement also uses `DISTINCT` to display each artist name just once. Try
    it without `DISTINCT`; Van Gogh appears twice because you obtained two Van Goghs
    in Kentucky.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Joins used with aggregate functions produce summaries. This statement shows
    how many paintings you have per artist:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A more elaborate statement uses aggregates to also show how much you paid for
    each artist’s paintings, in total and on average:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding summary statements produce output only for those artists in the
    `artist` table for whom you actually have acquired paintings. (For example, Monet
    is listed in the `artist` table but is not present in the summary because you
    have none of his paintings yet.) To summarize all artists, including those for
    whom you have no paintings, you must use a different kind of join—specifically,
    an outer join:'
  prefs: []
  type: TYPE_NORMAL
- en: Joins written with `INNER` `JOIN` are inner joins. They produce a result only
    for values in one table that match values in another table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An outer join can produce those matches as well, but also can show you which
    values in one table are missing from the other. [Recipe 16.2](#nch-multi-multi-outer-join)
    introduces outer joins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *`tbl_name.col_name`* notation that qualifies a column name with a table
    name is always permitted in a join but can be shortened to just *`col_name`* if
    the name appears in only one of the joined tables. In that case, MySQL can determine
    without ambiguity which table the column comes from, and no table name qualifier
    is necessary. We can’t do that for the following join. Both tables have an `a_id`
    column, so the `ON` clause column references are ambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, the following query is unambiguous. Each instance of `a_id` is
    qualified with the appropriate table name, only `artist` has a `name` column,
    and only `painting` has `title` and `state` columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To make the meaning of a statement clearer to human readers, it’s often useful
    to qualify column names even when that’s not strictly necessary as far as MySQL
    is concerned. We tend to use qualified names in join examples for that reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid writing complete table names when qualifying column references, give
    each table a short alias and refer to its columns using the alias. The following
    two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In `AS` *`alias_name`* clauses, the `AS` is optional.
  prefs: []
  type: TYPE_NORMAL
- en: For complicated statements that select many columns, aliases can save a lot
    of typing. In addition, for some types of statements, aliases are not only convenient
    but necessary, as will become evident when we get to the topic of self-joins (see
    [Recipe 16.4](#nch-multi-multi-self-join)).
  prefs: []
  type: TYPE_NORMAL
- en: 16.2 Finding Mismatches Between Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find rows in one table that have no match in another. Or you want
    to produce a list on the basis of a join between tables, and you want the list
    to include an entry for every row in the first table, including those for which
    no match occurs in the second table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use an outer join (a `LEFT` `JOIN` or a `RIGHT` `JOIN`) or a `NOT` `IN` subquery.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 16.1](#nch-multi-multi-inner-join) focuses on inner joins, which find
    matches between two tables. However, the answers to some questions require determining
    which rows do *not* have a match (or, stated another way, which rows have values
    missing from the other table). For example, you might want to know artists in
    the `artist` table for whom you have no paintings yet. Similar questions occur
    in other contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a list of potential customers, and another list of people who have
    placed orders. To focus sales efforts on people who are not yet actual customers,
    produce the set of people who are in the first list but not the second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have one list of baseball players, and another list of players who have
    hit home runs. To determine which players in the first list have *not* hit a home
    run, produce the set of players who are in the first list but not the second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These types of questions require use of an outer join. Like inner joins, an
    outer join finds matches between tables. But unlike an inner join, an outer join
    also determines which rows in one table have no match in another. Two types of
    outer join are `LEFT` `JOIN` and `RIGHT` `JOIN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how outer joins are useful, consider the problem of determining which
    artists in the `artist` table are missing from the `painting` table. At present,
    the tables are small, so it’s easy to examine them visually and see that you have
    no paintings by Monet (there are no `painting` rows with an `a_id` value of 2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you acquire more paintings and the tables get larger, it won’t be so easy
    to eyeball them and answer questions by inspection. Can you answer it using SQL?
    Sure, although first attempts at a solution often look something like the following
    statement, which uses a not-equal condition to look for mismatches between the
    two tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The query may look plausible but its result obviously is not. For example, it
    falsely indicates that each painting was painted by several different artists.
    The problem is that the statement lists all combinations of values from the two
    tables in which the artist ID values aren’t the same. What you really need is
    a list of values in `artist` that aren’t present *at* *all* in `painting`, but
    an inner join can only produce results based on values that are present in both
    tables. It can’t tell you anything about values that are missing from one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When faced with the need to find values in one table with no match in (or missing
    from) another table, you should get in the habit of thinking, <q>Aha, that’s a
    `LEFT` `JOIN` problem.</q> A `LEFT` `JOIN` is one type of outer join: it’s similar
    to an inner join in that it matches rows in the first (left) table with rows in
    the second (right) table. In addition, if a left table row has no match in the
    right table, a `LEFT` `JOIN` still produces a row—one in which all the columns
    from the right table are set to `NULL`. This means you can find values that are
    missing from the right table by looking for `NULL`. It’s easier to understand
    how this happens by working in stages. Begin with an inner join that displays
    matching rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this output, the first `a_id` column comes from the `artist` table and the
    second one comes from the `painting` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now substitute `LEFT` for `INNER` to see the result you get from an outer join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Compared to the inner join, the outer join produces an additional row for every
    `artist` row that has no `painting` table match, with all `painting` columns set
    to `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to restrict the output only to the unnmatched `artist` rows, add a `WHERE`
    clause that looks for `NULL` values in any `painting` column that cannot otherwise
    contain `NULL`. This filters out the rows that the inner join produces, leaving
    those produced only by the outer join:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to show only the `artist` table values that are missing from the `painting`
    table, write the output column list to name only columns from the `artist` table.
    The result is that the `LEFT` `JOIN` lists those left-table rows containing `a_id`
    values not present in the right table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar kind of operation reports each left-table value along with an indicator
    as to whether it’s present in the right table. To do this, perform a `LEFT` `JOIN`
    that counts the number of times each left-table value occurs in the right table.
    A count of zero indicates that the value is not present. The following statement
    lists each artist from the `artist` table and shows whether you have any paintings
    by the artist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A `RIGHT` `JOIN` is an outer join that is like `LEFT` `JOIN` but reverses the
    roles of the left and right tables. Semantically, `RIGHT` `JOIN` forces the matching
    process to produce a row from each table in the right table, even in the absence
    of a corresponding row in the left table. Syntactically, *`tbl1`* `LEFT` `JOIN`
    *`tbl2`* is equivalent to *`tbl2`* `RIGHT` `JOIN` *`tbl1`*. Therefore, references
    to `LEFT` `JOIN` in this book apply to `RIGHT` `JOIN` as well if you reverse the
    roles of the tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to identify values present in one table but missing from another
    is to use a `NOT` `IN` subquery. The following example finds artists not represented
    in the `painting` table; compare it to the earlier `LEFT` `JOIN` that answers
    the same question:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in this section, `LEFT` `JOIN` is useful for finding values with no
    match in another table or for showing whether each value is matched. `LEFT` `JOIN`
    may also be used to produce a summary that includes all items in a list, even
    those for which there’s nothing to summarize. This is very common for relationships
    between a candidate table and a detail table. For example, a `LEFT` `JOIN` can
    produce <q>total sales per customer</q> reports that list all customers, even
    those who bought nothing during the summary period. (For information about candidate-detail
    lists, see [Recipe 16.5](#nch-multi-multi-one-to-many).)
  prefs: []
  type: TYPE_NORMAL
- en: '`LEFT` `JOIN` is also useful for consistency checking when you receive two
    datafiles that are supposed to be related, and you want to determine whether they
    really are. (That is, you want to check the integrity of their relationship.)
    Import each file into a MySQL table, and then run a couple `LEFT` `JOIN` statements
    to determine whether there are unattached rows in one table or the other—that
    is, rows that have no match in the other table. [Recipe 16.3](#nch-multi-multi-delete-unrelated)
    discusses how to identify (and optionally delete) these unattached rows.'
  prefs: []
  type: TYPE_NORMAL
- en: 16.3 Identifying and Removing Mismatched or Unattached Rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have two datasets that are related, but possibly imperfectly so. You want
    to determine whether there are records in either dataset that are <q>unattached</q>
    (not matched by any record in the other dataset), and perhaps remove them if so.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To identify unmatched values in each table, use a `LEFT` `JOIN` or a `NOT` `IN`
    subquery. To remove them, use `DELETE` with a `NOT` `IN` subquery.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inner joins are useful for identifying matches, and outer joins are useful for
    identifying mismatches. This property of outer joins is valuable when you have
    related datasets for which the relationship might be imperfect. Mismatches might
    be found, for example, when you must verify the integrity of two datafiles received
    from an external source.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have related tables with unmatched rows, you can analyze and modify
    them using SQL statements. Specifically, restoring their relationship is a matter
    of identifying the unattached rows and then deleting them:'
  prefs: []
  type: TYPE_NORMAL
- en: To identify unattached rows, use a `LEFT` `JOIN`, because this is a <q>find
    unmatched rows</q> problem; alternatively, use a `NOT` `IN` subquery (see [Recipe
    16.2](#nch-multi-multi-outer-join)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To delete rows that are unmatched, use `DELETE` with a `NOT` `IN` subquery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s useful to know about unmatched data because you can alert whoever gave
    you the data. The data collection method might have a flaw that must be corrected.
    For example, with sales data, a missing region might mean that some regional manager
    didn’t report in and the omission was overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to identify and remove mismatched rows using
    two datasets that describe sales regions and volume of sales per region. One dataset
    contains the ID and location of each region:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The other dataset contains sales volume figures. Each row contains the amount
    of sales for a given quarter of a year and indicates the sales region to which
    the row applies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: A little visual inspection reveals that neither table is fully matched by the
    other. Sales regions 2 and 4 are not represented in the sales volume table, and
    the sales volume table contains rows for region 5, which is not in the sales region
    table. But we don’t want to check the tables by inspection. We want to find unmatched
    rows by using SQL statements that do the work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mismatch identification is a matter of using outer joins. For example, to find
    sales regions for which there are no sales volume rows, use the following `LEFT`
    `JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, to find sales volume rows that are not associated with any known
    region, reverse the roles of the two tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, an ID appears more than once in the list if there are multiple
    volume rows for a missing region. To see each unmatched ID only once, use `SELECT`
    `DISTINCT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also identify mismatches using `NOT` `IN` subqueries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To get rid of unmatched rows, use a `NOT` `IN` subquery in a `DELETE` statement.
    To remove `sales_region` rows that match no `sales_volume` rows, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To remove mismatched `sales_volume` rows that match no `sales_region` rows,
    the statement is similar but with the table roles reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 16.4 Comparing a Table to Itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to compare rows in a table to other rows in the same table. For example,
    you want to find all paintings in your collection by the artist who painted *The
    Potato Eaters*. Or you want to know which states listed in the `states` table
    joined the Union in the same year as New York. Or you want to know which states
    did not join the Union in the same year as any other state.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Problems that require comparing a table to itself involve an operation known
    as a self-join. It’s performed much like other joins, except that you must use
    table aliases so that you can refer to the same table different ways within the
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A special case of joining one table to another occurs when both tables are the
    same. This is called a self-join. This may be confusing or strange to think about
    at first, but it’s perfectly legal. You’ll likely find yourself using self-joins
    quite often because they are so important.
  prefs: []
  type: TYPE_NORMAL
- en: 'A tip-off that a self-join is required is that you want to know which pairs
    of rows in a table satisfy some condition. Suppose that your favorite painting
    is *The Potato Eaters*, and you want to identify all items in your collection
    that were painted by the same artist. The artist ID and painting titles that we
    begin with look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Solve the problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify which `painting` table row contains the title *The Potato Eaters*,
    so that you can refer to its `a_id` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Match other rows in the table that have the same `a_id` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Display the titles from those matching rows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The trick lies in using the proper notation. First attempts at joining a table
    to itself often look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The column references in that statement are ambiguous because MySQL cannot
    tell which instance of the `painting` table any given column name refers to. The
    solution is to alias at least one instance of the table so that you can distinguish
    column references by using different table qualifiers. The following statement
    shows how to do this, using the aliases `p1` and `p2` to refer to the `painting`
    table different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement output illustrates something typical of self-joins: when you
    begin with a reference value in one table instance (*The Potato Eaters*) to find
    matching rows in a second table instance (paintings by the same artist), the output
    includes the reference value. That makes sense: after all, the reference matches
    itself. To find only *other* paintings by the same artist, explicitly exclude
    the reference value from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding statements use ID value comparisons to match rows in the two
    table instances, but any kind of value can be used. For example, to use the `states`
    table to answer the question <q>Which states joined the Union in the same year
    as New York?</q> perform a temporal pairwise comparison based on the year part
    of the dates in the table’s `statehood` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the example above we do not specify the year when New York joined the Union.
    Instead, we compare the value of the `statehood` column for the row where state
    name is “New York” and the same `statehood` column for other states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now suppose that you want to find *every* pair of states that joined the Union
    in the same year. In this case, the output potentially can include any pair of
    rows from the `states` table. A self-join is perfect for this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The condition in the `ON` clause that requires state pair names not to be identical
    eliminates the trivially duplicate rows showing that each state joined the Union
    in the same year as itself. But you’ll notice that each remaining pair of states
    still appears twice. For example, there is one row that lists Delaware and New
    Jersey, and another that lists New Jersey and Delaware. This is often the case
    with self-joins: they produce pairs of rows that contain the same values, but
    for which the values are not in the same order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the values are not listed in the same order within the rows, they are
    not identical and you can’t get rid of these <q>near duplicates</q> by adding
    `DISTINCT` to the statement. To solve this problem, select rows in such a way
    that only one row from each pair ever appears in the query result. Slightly modify
    the `ON` clause, from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `<` rather than `<>` selects only those rows in which the first state
    name is lexically less than the second, and eliminates rows in which the names
    appear in opposite order (as well as rows in which the state names are identical).
    The resulting query produces the desired output without duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'For self-join problems of the <q>Which values are *not* matched by other rows
    in the table?</q> variety, use a `LEFT` `JOIN` rather than an `INNER` `JOIN`.
    An instance of this is the question <q>Which states did not join the Union in
    the same year as any other state?</q> In this case, the solution uses a `LEFT`
    `JOIN` of the `states` table to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: For each row in the `states` table, the statement selects rows for which the
    state has a `statehood` value in the same year, not including that state itself.
    For rows having no such match, the `LEFT` `JOIN` forces the output to contain
    a row anyway, with all the `s2` columns set to `NULL`. Those rows identify the
    states with no other state that joined the Union in the same year.
  prefs: []
  type: TYPE_NORMAL
- en: 16.5 Producing Candidate-Detail Lists and Summaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two tables have a relationship such that row in one table, usually called parent
    table with a candidate key, is referenced by one or mor erows in another table,
    usually called the child table with a detail row. In this situation, you want
    to produce a list that shows each parent row with its detail rows or a list that
    produces a summary of the detail rows for each parent row.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a one-to-many relationship. The solution to this problem involves a
    join, but the type of join depends on the question you want answered. To produce
    a list containing only parent rows for which some detail row exists, use an inner
    join based on the primary key in the parent table. To produce a list that includes
    all parent rows, even those with no detail rows, use an outer join.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To produce a list from two tables that have a candidate-detail or parent-child
    relationship, a given row in one table might be matched by several rows in the
    other. These relationships occur frequently. For example, in business contexts,
    one-to-many relationships involve invoices per customer or items per invoice.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe suggests some candidate-detail questions that you can ask (and answer)
    using the `artist` and `painting` tables from earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'One form of candidate-detail question for these tables is, <q>Which paintings
    did each artist paint?</q> This is a simple inner join (see [Recipe 16.1](#nch-multi-multi-inner-join)).
    Match each `artist` row to its corresponding `painting` rows based on the artist
    ID values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To also list artists for whom you have no paintings, the join output should
    include rows in one table that have no match in the other. That’s a form of <q>find
    the nonmatching rows</q> problem that requires an outer join (see [Recipe 16.2](#nch-multi-multi-outer-join)).
    Thus, to list each `artist` row, whether or not any `painting` rows match, use
    a `LEFT` `JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Rows in the result that have `NULL` in the `title` column correspond to artists
    listed in the `artist` table for whom you have no paintings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same principles apply when producing summaries using candidate and detail
    tables. For example, to summarize your art collection by number of paintings per
    artist, you might ask, <q>How many paintings are there per artist in the `painting`
    table?</q> To find the answer based on artist ID but displaying the artist’s name
    (from the `artist` table), count the paintings with this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, you might ask, <q>How many paintings did each artist paint?</q>
    This is the same question as the previous one (and the same statement answers
    it), as long as every artist in the `artist` table has at least one corresponding
    `painting` table row. But if you have artists in the `artist` table not yet represented
    by any paintings in your collection, they do not appear in the statement output.
    To produce a summary that also includes artists with no paintings in the `painting`
    table, use a `LEFT` `JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Beware of a subtle error that is easy to make when writing that kind of statement.
    Suppose that you write the `COUNT()` function slightly differently, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Now every artist appears to have at least one painting. Why the difference?
    The problem is the use of `COUNT(*)` rather than `COUNT(painting.a_id)`. The way
    `LEFT` `JOIN` works for unmatched rows in the left table is that it generates
    a row with all the columns from the right table set to `NULL`. In the example,
    the right table is `painting`. The statement that uses `COUNT(painting.a_id)`
    works correctly because `COUNT(`*`expr`*`)` counts only non-`NULL` values. The
    statement that uses `COUNT(*)` is incorrect because it counts *rows*, including
    those containing `NULL` that correspond to missing artists.
  prefs: []
  type: TYPE_NORMAL
- en: '`LEFT` `JOIN` is suitable for other types of summaries as well. To produce
    additional columns showing the total and average prices of the paintings for each
    artist in the `artist` table, use this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that `COUNT()` is zero for artists that are not represented, but `SUM()`
    and `AVG()` are `NULL`. The latter two functions return `NULL` when applied to
    a set of values with no non-`NULL` values. To display a sum or average value of
    zero in that case, replace `SUM(`*`expr`*`)` and `AVG(`*`expr`*`)` with `IFNULL(SUM(`*`expr`*`),0)`
    and `IFNULL(AVG(`*`expr`*`),0)`.
  prefs: []
  type: TYPE_NORMAL
- en: 16.6 Enumerating a Many-to-Many Relationship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to display a relationship between tables when any row in either table
    might be matched by multiple rows in the other.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a many-to-many relationship. It requires a third table for associating
    your two primary tables and a three-way join to produce the correspondences between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `artist` and `painting` tables used in earlier sections have a one-to-many
    relationship: a given artist may have produced many paintings, but each painting
    was created by only one artist. One-to-many relationships are relatively simple
    and the two related tables can be joined using a column that is common to both.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A many-to-many relationship between tables is more complex. It occurs when
    a row in one table may have many matches in the other, and vice versa. An example
    is the relationship between movies and actors: each movie may have multiple actors,
    and each actor may have appeared in multiple movies. One way to represent this
    relationship uses a table structured as follows, with a row for each movie-actor
    combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The table captures the nature of this many-to-many relationship, but it’s also
    in nonnormal form because it unnecessarily stores repetitive information. For
    example, information for each movie is recorded multiple times. To better represent
    this many-to-many relationship, use multiple tables:'
  prefs: []
  type: TYPE_NORMAL
- en: Store each movie year and name once in a table named `movies`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store each actor name once in a table named `actors`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a third table, `movies_actors_link`, that stores movie-actor associations
    and serves as a link, or bridge, between the two primary tables. To minimize the
    information stored in this table, assign unique IDs to each movie and actor within
    their respective tables, and store only those IDs in the `movies_actors_link`
    table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The resulting `movie` and `actor` tables look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `movies_actors_link` table associates movies and actors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll surely notice that the content of the `movies_actors_link` table is
    entirely meaningless from a human perspective. That’s okay: we need never display
    it explicitly. Its utility derives from its ability to link the two primary tables
    in queries, without appearing in query output itself. The next few examples illustrate
    this principle. They answer questions about the movies or actors, using three-way
    joins that relate the two primary tables using the link table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'List all the pairings that show each movie and who acted in it. This statement
    enumerates all the correspondences between the `movie` and `actor` tables and
    reproduces the information that was originally in the nonnormal `movies_actors`
    table:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List the actors in a given movie:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'List the movies in which a given actor has acted:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 16.7 Finding Per-Group Minimum or Maximum Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find which row within each group of rows in a table contains the
    maximum or minimum value for a given column. For example, you want to determine
    the most expensive painting in your collection for each artist.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a temporary table to hold the per-group maximum or minimum values, then
    join the temporary table with the original one to pull out the matching row for
    each group. If you prefer a single-query solution, use a subquery in the `FROM`
    clause rather than a temporary table.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many questions involve finding largest or smallest values in a particular table
    column, but it’s also common to want to know other values in the row that contains
    the value. For example, using the `artist` and `painting` tables with the techniques
    from [Recipe 10.6](ch10.xhtml#nch-sum-sum-assoc), it’s possible to answer questions
    such as <q>What is the most expensive painting in the collection, and who painted
    it?</q> One solution is to store the highest price in a user-defined variable,
    then use the variable to identify the row containing the price so that you can
    retrieve other columns from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing can be done by creating a temporary table to hold the maximum
    price and joining it with the other tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: On the face of it, using a temporary table and a join is just a more complicated
    way of answering the question than with a user-defined variable. Does this technique
    have any practical value? Yes, it does, because it leads to a more general technique
    for answering more difficult questions. The previous statements show information
    only for the single most expensive painting in the entire `painting` table. What
    if your question is, <q>What is the most expensive painting *for each artist*?</q>
    You can’t use a user-defined variable to answer that question because the answer
    requires finding one price per artist, and a variable holds only a single value.
    But the technique of using a temporary table works well because the table can
    hold multiple rows, and a join can find matches for all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer the question, select each artist ID and the corresponding maximum
    painting price into a temporary table. This table contains not only the maximum
    painting price but the maximum within each group, where <q>group</q> is defined
    as <q>paintings by a given artist.</q> Then use the artist IDs and prices stored
    in the temporary table to match rows in the `painting` table, and join the result
    with the `artist` table to get the artist names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: To avoid explicitly creating temporary tables and obtain the same result with
    a single statement, use Common Table Expressions (CTEs).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We discuss CTEs in detail in [Recipe 10.18](ch10.xhtml#nch-sum-sum-with).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to obtain the same result with a single statement, is to use a
    subquery in the `FROM` clause that retrieves the same rows contained in the temporary
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet another way to answer maximum-per-group questions is to use a `LEFT` `JOIN`
    that joins a table to itself. The following statement identifies the highest-priced
    painting per artist ID (use `IS` `NULL` to select all the rows from `p1` for which
    there is *no* row in `p2` with a higher price):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'To display artist names rather than ID values, join the result of the `LEFT`
    `JOIN` to the `artist` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The self-`LEFT` `JOIN` method is perhaps less intuitive than using a temporary
    table, a CTE, or a subquery.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe showed how to answer maximum-per-group questions by selecting summary
    information into a temporary table and joining that table to the original one
    or by using a subquery in the `FROM` clause. These techniques have application
    in many contexts. One of them is calculation of team standings, where the standings
    for each group of teams are determined by comparing each team in the group to
    the team with the best record. [Recipe 17.12](ch17.xhtml#nch-stats-stats-standings)
    discusses how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 16.8 Using a Join to Fill or Identify Holes in a List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to produce a summary by category, but some categories are missing from
    the data to be summarized. Consequently, the summary has missing categories as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a reference table that lists each category and produce the summary based
    on a `LEFT` `JOIN` between the list and the table containing your data. Every
    category in the reference table will appear in the result, even those not present
    in the data to be summarized.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A summary query normally produces entries only for categories actually present
    in the data. Suppose that you want to summarize the `driver_log` table (introduced
    in [Chapter 9](ch09.xhtml#nch-sort)), to determine how many drivers were on the
    road each day. The table has these rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple summary showing the number of active drivers per day looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the summary category is date, but the summary is <q>incomplete</q> in
    the sense that it includes entries only for dates represented in the `driver_log`
    table. To produce a summary that includes all categories (all dates within the
    date range represented in the table), including those for which no driver was
    active, create a reference table that lists each date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then join the reference table to the `driver_log` table using a `LEFT` `JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Now the summary includes a row for every date in the range because the `LEFT`
    `JOIN` forces the output to include a row for every date in the reference table,
    even those missing from the `driver_log` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example just shown uses the reference table with a `LEFT` `JOIN` to fill
    holes in the summary. It’s also possible to use the reference table to *detect*
    holes in the dataset—that is, to determine which categories are not present in
    the data to be summarized. The following statement shows those dates on which
    no driver was active by looking for reference rows for which no `driver_log` table
    rows have a matching category value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Reference tables that contain a list of categories are quite useful in summary
    context, as just shown. But creating such tables manually is mind-numbing and
    error-prone. It is much easier to use recursive CTE for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: We discuss recursive CTEs in more details in [Recipe 15.16](ch15.xhtml#nch-sum-sum-recursive-cte)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need a very long list of dates that you expect to re-use often you may
    prefer to store them in a table instead of generating series each time you need
    them. In this case, a stored procedure that uses the endpoints of the range of
    category values to generate the reference table for you helps automate the process.
    In essence, this type of procedure acts as an iterator that generates a row for
    each value in the range. The following procedure, `make_date_list()`, shows an
    example of this approach. It creates a reference table containing a row for every
    date in a particular date range. It also indexes the table so that it will be
    fast in large joins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `make_date_list()` to generate the reference table, `dates`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Then use the `dates` table as shown earlier in this section to fill holes in
    the summary or to detect holes in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the `make_date_list()` procedure in the *joins* directory of the
    `recipes` distribution. It requires the `exec_stmt()` and `quote_identifier()`
    helper routines (see [Recipe 11.6](ch11.xhtml#nch-routines-dynamic-sql-helpers)),
    located in the *routines* directory. The *joins* directory also contains a Perl
    script, *make_date_list.pl*, that implements an alternate approach; it generates
    date reference tables from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 16.9 Using a Join to Control Query Sort Order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort a statement’s output using a characteristic of the output that
    cannot be specified using `ORDER` `BY`. For example, you want to sort a set of
    rows by subgroups, putting first those groups with the most rows and last those
    groups with the fewest rows. But <q>number of rows in each group</q> is not a
    property of individual rows, so you can’t use it for sorting.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Derive the ordering information and store it in an auxiliary table. Then join
    the original table to the auxiliary table, using the auxiliary table to control
    the sort order.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time you sort a query result using an `ORDER` `BY` clause that
    names which column or columns to use for sorting. But sometimes the values you
    want to sort by aren’t present in the rows to be sorted. This is the case when
    you want to use group characteristics to order the rows. The following example
    uses the `driver_log` table to illustrate this. The following query sorts the
    table using the ID column, which is present in the rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: But what if you want to display a list and sort it on the basis of a summary
    value not present in the rows? That’s a little trickier. Suppose that you want
    to show each driver’s rows by date, but place those drivers who drive the most
    miles first. You can’t do this with a summary query because then you wouldn’t
    get back the individual driver rows. But you can’t do it without a summary query,
    either, because the summary values are required for sorting. The way out of the
    dilemma is to create another table containing the summary value per driver and
    join it to the original table. That way you can produce the individual rows and
    also sort them by the summary values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize the driver totals into another table, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'That produces the values we need to put the names in the proper total-miles
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the `name` values to join the summary table to the `driver_log` table,
    and use the `driver_miles` values to sort the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement shows the mileage totals in the result. That’s only
    to clarify how the values are being sorted. It’s not actually necessary to display
    them; they’re needed only for the `ORDER` `BY` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid using the temporary table, use a CTE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, select the same rows using a subquery in the `FROM` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 16.10 Joining Results of Multiple Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to join results of two or more queries.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the queries and store results in the temporary tables, then access those
    temporary tables to obtain final result. Or, use named subqueries, then join their
    results. Or, use our favorite method: CTEs that will help you to perform this
    task in the easiest and clear manner.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may need to join not only tables but results of other queries. Assume you
    are working with tables `city` and `states` from the `recipes` distribution, and
    want to find capital names of the states that belong to the 10 states with the
    highest population. At the same time, you want to include into your search results
    only those states where the largest city is the same as the capital.
  prefs: []
  type: TYPE_NORMAL
- en: 'This task is very easy to solve if you first split it into three parts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find all states where the capital and the largest city are the same. You can
    do it with a query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find 10 states with the highest population:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Join the results to select rows that exist in both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are three ways to do this: by creating intermediate temporary tables,
    by joining subquery results, and by using CTEs.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Intermediate Temporary Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Store results of the queries into temporary tables, then select from them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Keyword `TEMPORARY` for the `CREATE TABLE` statement instructs MySQL to create
    a table, visible for the current session only and which will be destroyed after
    you close the session. See [Recipe 6.3](ch06.xhtml#nch-tblmgmt-tblmgmt-temp) for
    further details.
  prefs: []
  type: TYPE_NORMAL
- en: Using Named Subqueries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you only need to access the intermediate results once, you can avoid creating
    temporary tables by using subqueries and joining their results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-multi-multi-subquery-join-outer_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Start the query from selecting columns you need in the final result
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-multi-multi-subquery-join-lc_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Put the first subquery into brackets and assign it a unique name.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-multi-multi-subquery-join-ts_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Do the same for the second subquery.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-multi-multi-subquery-join-where_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Narrow the search with clause `WHERE`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Common Table Expressions (CTEs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With CTEs start by naming your subqueries, then join their results like if they
    were regular MySQL tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 16.11 Referring to Join Output Column Names in Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to process the result of a join from within a program, but column names
    in the result set aren’t unique.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rewrite the query using column aliases so that each column has a unique name.
    Alternatively, refer to the columns by position.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Joins typically retrieve columns from related tables and it’s not unusual for
    columns selected from different tables to have the same names. Consider the following
    join that shows the items in your art collection. For each painting, it displays
    artist name, painting title, the state in which you acquired the item, and its
    price:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement uses table qualifiers for each output column, but MySQL doesn’t
    include table names in the column headings, so not all column names in the output
    are distinct. If you process the join result from within a program and fetch rows
    into a data structure that references column values by name, nonunique column
    names cause values to become inaccessible. Suppose that you fetch rows in a Perl
    DBI script like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Fetching rows into the hash yields three hash elements (`name`, `title`, `price`);
    one of the `name` elements is lost. To solve this problem, supply aliases that
    make the column names unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Now fetching rows into a hash yields four hash elements (`painter`, `title`,
    `state`, `price`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To address the problem without column renaming, fetch the row into something
    other than a hash. For example, fetch the row into an array and refer to the columns
    by ordinal position within the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
