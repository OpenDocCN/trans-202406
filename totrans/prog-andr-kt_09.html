<html><head></head><body><section data-pdf-bookmark="Chapter 9. Channels" data-type="chapter" epub:type="chapter"><div class="chapter" id="channels_id">&#13;
<h1><span class="label">Chapter 9. </span>Channels</h1>&#13;
&#13;
&#13;
<p><a data-primary="channels" data-type="indexterm" id="ix_ch09-asciidoc0"/>In the previous chapter, you learned how to create coroutines, cancel them, and deal with exceptions. So you know&#13;
that if task B requires the result of task A, you can implement them as two suspending functions called sequentially.&#13;
What if task A produces a stream of values?&#13;
<code>async</code> and suspending functions don’t fit this use case. This is what <code>Channel</code>s<sup><a data-type="noteref" href="ch09.html#idm46669744579616" id="idm46669744579616-marker">1</a></sup> are meant for—making coroutines&#13;
communicate. In this chapter you’ll learn in detail what channels are and how to use them.</p>&#13;
&#13;
<p>Using nothing but channels and coroutines, we can design complex asynchronous logic using <a data-primary="communicating sequential processes (CSP)" data-secondary="about" data-type="indexterm" id="idm46669744577776"/><em>communicating sequential&#13;
processes</em> (CSP). What is CSP? Kotlin was inspired by several existing programming languages, such as Java, C#,&#13;
JavaScript, Scala, and Groovy. Notably, Go (the language) inspired coroutines with its &#13;
<span class="keep-together">“goroutines.”</span></p>&#13;
&#13;
<p>In computer science, CSP is a concurrent programming language which was first described by Tony Hoare in 1978. It has&#13;
evolved ever since, and the term CSP is now essentially used to describe a programming style. If you’re familiar with&#13;
the Actor model, CSP is quite similar—although there are some differences. If you’ve never heard of CSP, don’t&#13;
worry—we’ll briefly explain the <em>idea</em> behind it with practical examples. For now, you can think of CSP as a&#13;
programming style.</p>&#13;
&#13;
<p>As usual, we’ll start with a bit of theory, then implement a real-life problem. In the end, we’ll discuss the benefits&#13;
and trade-offs of CSP, using coroutines.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Channels Overview" data-type="sect1"><div class="sect1" id="idm46669744573520">&#13;
<h1>Channels Overview</h1>&#13;
&#13;
<p><a data-primary="channels" data-secondary="about" data-type="indexterm" id="ix_ch09-asciidoc1"/>Going back to our introductory example, imagine that one task asynchronously produces a list of three <code>Item</code> instances (the&#13;
producer), and another task acts on each of those items (the consumer). Since the producer doesn’t return immediately,&#13;
you could implement it like the following <code>getItems</code> suspending function:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">getItems</code><code class="p">():</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Item</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
     <code class="k">val</code> <code class="py">items</code> <code class="p">=</code> <code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">Item</code><code class="p">&gt;()</code>&#13;
     <code class="n">items</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">makeItem</code><code class="p">())</code>&#13;
     <code class="n">items</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">makeItem</code><code class="p">())</code>&#13;
     <code class="n">items</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">makeItem</code><code class="p">())</code>&#13;
     <code class="k">return</code> <code class="n">items</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">suspend</code> <code class="k">fun</code> <code class="nf">makeItem</code><code class="p">():</code> <code class="n">Item</code> <code class="p">{</code>&#13;
    <code class="n">delay</code><code class="p">(</code><code class="m">10</code><code class="p">)</code> <code class="c1">// simulate some asynchronism</code>&#13;
    <code class="k">return</code> <code class="n">Item</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As for the consumer, which consumes each of those items, you could simply implement it like so:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">consumeItems</code><code class="p">(</code><code class="n">items</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Item</code><code class="p">&gt;)</code> <code class="p">{</code>&#13;
     <code class="k">for</code> <code class="p">(</code><code class="n">item</code> <code class="k">in</code> <code class="n">items</code><code class="p">)</code> <code class="n">println</code><code class="p">(</code><code class="s">"Do something with $item"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Putting it all together:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
     <code class="k">val</code> <code class="py">items</code> <code class="p">=</code> <code class="n">getItems</code><code class="p">()</code>&#13;
     <code class="n">consumeItems</code><code class="p">(</code><code class="n">items</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you would expect, “Do something with ..” is printed three times. However, in this case, we’re most interested in the&#13;
order of execution. Let’s take a closer look at what’s really happening, as shown in <a data-type="xref" href="#process_all_at_once_fig">Figure 9-1</a>.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#process_all_at_once_fig">Figure 9-1</a>, item consumption only begins after all items have been produced. Producing items might&#13;
take quite some time, and waiting for all of them to be produced isn’t acceptable in some situations. Instead, we could&#13;
act on each asynchronously produced item, as shown in <a data-type="xref" href="#process_once_after_another_fig">Figure 9-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="process_all_at_once_fig">&#13;
<img alt="Execution schema" src="assets/pawk_0901.png"/>&#13;
<h6><span class="label">Figure 9-1. </span>Process all at once.</h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="process_once_after_another_fig">&#13;
<img alt="Process one after another" src="assets/pawk_0902.png"/>&#13;
<h6><span class="label">Figure 9-2. </span>Process one after another.</h6>&#13;
</div></figure>&#13;
&#13;
<p>To achieve this, we can’t implement <code>getItems</code> as a suspending function like before. A coroutine should act as a&#13;
producer of <code>Item</code> instances, and send them to the main coroutine.&#13;
It’s a typical producer-consumer problem.</p>&#13;
&#13;
<p class="pagebreak-before">In <a data-type="xref" href="ch05.html#thread_safety_id">Chapter 5</a>, we explained how<a data-primary="BlockingQueue" data-type="indexterm" id="idm46669744410832"/> <code>BlockingQueue</code>s can be used to implement <em>work queues</em>—or, in&#13;
this case, a data queue. As a reminder, a <code>BlockingQueue</code> has blocking methods <code>put</code> and <code>take</code> to respectively insert&#13;
and take an object from the queue. When the queue is used as the only means of communication between two threads&#13;
(a producer and a consumer), it offers the great benefit of avoiding a shared mutable state. Moreover, if the queue is&#13;
bounded (has a size limit), a too-fast producer will eventually get blocked in a <code>put</code> call if consumers are too slow.&#13;
This is known as back pressure: a blocked producer gives the consumers the opportunity to catch up, thus releasing&#13;
the producer.</p>&#13;
&#13;
<p>Using a <code>BlockingQueue</code> as a communication primitive between coroutines wouldn’t be a great idea, since a coroutine&#13;
shouldn’t involve blocking calls. Instead, coroutines can suspend. A <code>Channel</code> can be seen just like that: a queue with&#13;
suspending functions <code>send</code> and <code>receive</code>, as shown in <a data-type="xref" href="#channel_illustration_id">Figure 9-3</a>. A <code>Channel</code> also has nonsuspending counterparts: <code>trySend</code> and <code>tryReceive</code>. These two methods are also nonblocking. <code>trySend</code> tries to immediately add an element to the channel, and returns a wrapper class around the result. That&#13;
wrapper class, <code>ChannelResult&lt;T&gt;</code>, also indicates the success or the failure of the operation.&#13;
<code>tryReceive</code> tries to immediately retrieve an element from the channel, and returns a <code>ChannelResult&lt;T&gt;</code> instance.</p>&#13;
&#13;
<figure><div class="figure" id="channel_illustration_id">&#13;
<img alt="A channel can send and receive" src="assets/pawk_0903.png"/>&#13;
<h6><span class="label">Figure 9-3. </span>Channel.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Like queues, <code>Channel</code>s come in several flavors. We’ll cover each of those <code>Channel</code> variants with basic examples.<a data-startref="ix_ch09-asciidoc1" data-type="indexterm" id="idm46669744371424"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rendezvous Channel" data-type="sect2"><div class="sect2" id="idm46669744370592">&#13;
<h2>Rendezvous Channel</h2>&#13;
&#13;
<p><a data-primary="channels" data-secondary="rendezvous" data-type="indexterm" id="ix_ch09-asciidoc2"/><a data-primary="rendezvous channels" data-type="indexterm" id="ix_ch09-asciidoc3"/>“Rendezvous” is a French word that means “appointment” or “a date”—it depends on the context (we don’t mean <code>CoroutineContext</code> here). A rendezvous channel does not have any buffer at all. An element is transferred from sender to receiver only when <code>send</code> and <code>receive</code> invocations meet in time (rendezvous), so <code>send</code> suspends until another coroutine invokes <code>receive</code>, and <code>receive</code> suspends until another coroutine invokes <code>send</code>.</p>&#13;
&#13;
<p>As another way to put it, a rendezvous channel involves a back-and-forth communication between producers (coroutines&#13;
calling <code>send</code>) and consumers (coroutines calling <code>receive</code>). There can’t be two consecutive <code>send</code>s without a&#13;
<code>receive</code> in the middle.</p>&#13;
&#13;
<p>By default, when you create a channel using <code>Channel&lt;T&gt;()</code>, you get a rendezvous channel.</p>&#13;
&#13;
<p>We can use a rendezvous channel to correctly implement our previous example:</p>&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">runBlocking</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">channel</code><code> </code><code class="p">=</code><code> </code><code class="n">Channel</code><code class="p">&lt;</code><code class="n">Item</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="n">launch</code><code> </code><code class="p">{</code><code>                        </code><a class="co" id="callout_1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="n">channel</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">Item</code><code class="p">(</code><code class="m">1</code><code class="p">)</code><code class="p">)</code><code>       </code><a class="co" href="#para_3" id="callout_3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>        </code><code class="n">channel</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">Item</code><code class="p">(</code><code class="m">2</code><code class="p">)</code><code class="p">)</code><code>       </code><a class="co" href="#para_4" id="callout_4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>        </code><code class="n">println</code><code class="p">(</code><code class="s">"Done sending"</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="n">println</code><code class="p">(</code><code class="n">channel</code><code class="p">.</code><code class="n">receive</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>      </code><a class="co" href="#para_2" id="callout_2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>    </code><code class="n">println</code><code class="p">(</code><code class="n">channel</code><code class="p">.</code><code class="n">receive</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>      </code><a class="co" href="#para_5" id="callout_5"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="n">println</code><code class="p">(</code><code class="s">"Done!"</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="n">data</code><code> </code><code class="k">class</code><code> </code><code class="nc">Item</code><code class="p">(</code><code class="k">val</code><code> </code><code class="py">number</code><code class="p">:</code><code> </code><code class="n">Int</code><code class="p">)</code></pre>&#13;
&#13;
<p>The output of this program is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Item(number=1)&#13;
Item(number=2)&#13;
Done!&#13;
Done sending</pre>&#13;
<p>In this example, the main coroutine starts a child coroutine with <code>launch</code>, at <a href="#callout_1" id="para_1"><img alt="1" src="assets/1.png"/></a>, then reaches <a href="#callout_2" id="para_2"><img alt="2" src="assets/2.png"/></a> and suspends until some&#13;
coroutine sends an <code>Item</code> instance in the channel. Shortly after, the child coroutine sends the first item at <a href="#callout_3" id="para_3"><img alt="3" src="assets/3.png"/></a>,&#13;
then reaches and suspends at the second <code>send</code> call at <a href="#callout_4" id="para_4"><img alt="4" src="assets/4.png"/></a> until some coroutine is ready to receive an item.&#13;
Subsequently, the main coroutine (which is suspended at <a href="#callout_2"><img alt="2" src="assets/2.png"/></a>) is resumed and receives the first item from the channel&#13;
and prints it. Then the main coroutine reaches <a href="#callout_5" id="para_5"><img alt="5" src="assets/5.png"/></a> and immediately receives the second item since the child coroutine&#13;
was already suspended in a <code>send</code> call. Immediately after, the child coroutine continues its execution (prints&#13;
“Done sending”).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterating over a Channel" data-type="sect3"><div class="sect3" id="idm46669744250656">&#13;
<h3>Iterating over a Channel</h3>&#13;
&#13;
<p><a data-primary="iterating over a channel" data-type="indexterm" id="ix_ch09-asciidoc4"/><a data-primary="rendezvous channels" data-secondary="iterating over a channel" data-type="indexterm" id="ix_ch09-asciidoc5"/>A <code>Channel</code> can be iterated over, using a regular <code>for</code> loop. Note that since&#13;
channels aren’t regular collections,<sup><a data-type="noteref" href="ch09.html#idm46669744209856" id="idm46669744209856-marker">2</a></sup> you can’t use&#13;
<code>forEach</code> or other similar functions from the Kotlin Standard Library. Here, channel iteration is a specific language-level&#13;
feature that can only be done using the <code>for</code>-loop syntax:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">for</code> <code class="p">(</code><code class="n">x</code> <code class="k">in</code> <code class="n">channel</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="c1">// do something with x every time some coroutine sends an element in</code>&#13;
   <code class="c1">// the channel</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Implicitly, <code>x</code> is equal to<a data-primary="channel.receive()" data-type="indexterm" id="idm46669744198528"/> <code>channel.receive()</code> at each iteration.&#13;
Consequently, a coroutine iterating over a channel could do so indefinitely, unless it contains conditional logic to&#13;
break the loop. Fortunately, there’s a standard mechanism to break the loop: closing the channel. Here is an example:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">channel</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">Item</code><code class="p">&gt;()</code>&#13;
    <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="n">channel</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">Item</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>&#13;
        <code class="n">channel</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">Item</code><code class="p">(</code><code class="m">2</code><code class="p">))</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Done sending"</code><code class="p">)</code>&#13;
        <code class="n">channel</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">x</code> <code class="k">in</code> <code class="n">channel</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Done!"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This program has similar output, with a small difference:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Item(number=1)&#13;
Item(number=2)&#13;
Done sending&#13;
Done!</pre>&#13;
&#13;
<p>This time, “Done sending” appears before “Done!” This is because the main coroutine only leaves the <code>channel</code> iteration&#13;
when <code>channel</code> is closed. And that happens when the child coroutine is done sending all elements.</p>&#13;
&#13;
<p>Internally, closing a channel sends a special token into the channel to indicate that no other elements will be sent.&#13;
As items in the channel are consumed <em>serially</em> (one after another), all items sent to the rendezvous channel before the&#13;
close special token are guaranteed to be sent to the receiver.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Beware—trying to call <code>receive</code> from an already-closed channel will throw a <code>ClosedReceiveChannelException</code>. However, trying&#13;
to iterate on such a channel doesn’t throw any exception:<a data-startref="ix_ch09-asciidoc5" data-type="indexterm" id="idm46669744074992"/><a data-startref="ix_ch09-asciidoc4" data-type="indexterm" id="idm46669744074320"/></p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">channel</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;()</code>&#13;
    <code class="n">channel</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">x</code> <code class="k">in</code> <code class="n">channel</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Done!"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output is: <code>Done!</code></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other flavors of Channel" data-type="sect3"><div class="sect3" id="idm46669744213760">&#13;
<h3>Other flavors of Channel</h3>&#13;
&#13;
<p><a data-primary="rendezvous channels" data-secondary="other flavors of channel" data-type="indexterm" id="idm46669744044272"/>In the previous example, the <code>Channel</code> appears to be created using a class constructor. If you look at the source code,&#13;
you can see that it’s actually a public function named with a capital C, to give the illusion that you’re using a class&#13;
constructor:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">public</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">E</code><code class="p">&gt;</code> <code class="n">Channel</code><code class="p">(</code><code class="n">capacity</code><code class="p">:</code> <code class="n">Int</code> <code class="p">=</code> <code class="n">RENDEZVOUS</code><code class="p">):</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">E</code><code class="p">&gt;</code> <code class="p">=</code>&#13;
    <code class="k">when</code> <code class="p">(</code><code class="n">capacity</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">RENDEZVOUS</code> <code class="p">-&gt;</code> <code class="n">RendezvousChannel</code><code class="p">()</code>&#13;
        <code class="n">UNLIMITED</code> <code class="p">-&gt;</code> <code class="n">LinkedListChannel</code><code class="p">()</code>&#13;
        <code class="n">CONFLATED</code> <code class="p">-&gt;</code> <code class="n">ConflatedChannel</code><code class="p">()</code>&#13;
        <code class="n">BUFFERED</code> <code class="p">-&gt;</code> <code class="n">ArrayChannel</code><code class="p">(</code><code class="n">CHANNEL_DEFAULT_CAPACITY</code><code class="p">)</code>&#13;
        <code class="k">else</code> <code class="p">-&gt;</code> <code class="n">ArrayChannel</code><code class="p">(</code><code class="n">capacity</code><code class="p">)</code>&#13;
    <code class="p">}</code></pre>&#13;
&#13;
<p>You can see that this <code>Channel</code> function has a <code>capacity</code> parameter that defaults to &#13;
<span class="keep-together"><code>RENDEZVOUS</code>.</span> For the record, if&#13;
you step into the <code>RENDEZVOUS</code> declaration, you can see that it’s equal to 0. For each <code>capacity</code> value there is a corresponding channel implementation. There are four different flavors of channels: rendezvous, <em>unlimited</em>, <em>conflated</em>, and&#13;
<em>buffered</em>. Don’t pay too much attention to the concrete implementations (like &#13;
<span class="keep-together"><code>RendezvousChannel()</code>),</span> because those&#13;
classes are internal and may change in the future. On the other hand, the values <code>RENDEZVOUS</code>, <code>UNLIMITED</code>, <code>CONFLATED</code>,&#13;
and &#13;
<span class="keep-together"><code>BUFFERED</code></span> are part of the public API.</p>&#13;
&#13;
<p>We’ll cover each of those channel types in the next sections.<a data-startref="ix_ch09-asciidoc3" data-type="indexterm" id="idm46669743914912"/><a data-startref="ix_ch09-asciidoc2" data-type="indexterm" id="idm46669743914272"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Unlimited Channel" data-type="sect2"><div class="sect2" id="idm46669744370000">&#13;
<h2>Unlimited Channel</h2>&#13;
&#13;
<p><a data-primary="channels" data-secondary="unlimited" data-type="indexterm" id="ix_ch09-asciidoc6"/><a data-primary="unlimited channels" data-type="indexterm" id="ix_ch09-asciidoc7"/>An <em>unlimited</em> channel has a buffer that is only limited by the amount of available memory. Senders to this channel never suspend,&#13;
while receivers only suspend when the channel is empty. Coroutines exchanging data via an <em>unlimited</em> channel don’t need&#13;
to meet in time.</p>&#13;
&#13;
<p>At this point, you might be thinking that such a channel should have concurrent modification issues when senders and&#13;
receivers are executed from different threads. After all, coroutines are dispatched on threads, so a channel might very&#13;
well be used from different threads.&#13;
Let’s check the <code>Channel</code>’s robustness ourselves! In the following example, we send <code>Int</code>s from a coroutine dispatched&#13;
on <code>Dispatchers.Default</code> while another coroutine reads the same channel from the main thread, and if the <code>Channel</code>s aren’t&#13;
thread-safe, we will notice:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">channel</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;(</code><code class="n">UNLIMITED</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">childJob</code> <code class="p">=</code> <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Child executing from ${Thread.currentThread().name}"</code><code class="p">)</code>&#13;
        <code class="k">var</code> <code class="py">i</code> <code class="p">=</code> <code class="m">0</code>&#13;
        <code class="k">while</code> <code class="p">(</code><code class="n">isActive</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">channel</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">i</code><code class="p">++)</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Child is done sending"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Parent executing from ${Thread.currentThread().name}"</code><code class="p">)</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">x</code> <code class="k">in</code> <code class="n">channel</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
&#13;
        <code class="k">if</code> <code class="p">(</code><code class="n">x</code> <code class="p">==</code> <code class="m">1000</code><code class="n">_000</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">childJob</code><code class="p">.</code><code class="n">cancel</code><code class="p">()</code>&#13;
            <code class="k">break</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Done!"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">The output of this program is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Parent executing from main&#13;
Child executing from DefaultDispatcher-worker-2&#13;
0&#13;
1&#13;
..&#13;
1000000&#13;
Done!&#13;
Child is done sending</pre>&#13;
&#13;
<p>You can run this sample as much as you want, and it always completes without concurrent issues. That’s because a <code>Channel</code>&#13;
internally uses a lock-free algorithm.<sup><a data-type="noteref" href="ch09.html#idm46669743772336" id="idm46669743772336-marker">3</a></sup></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>Channel</code>s are thread-safe. Several threads can concurrently invoke <code>send</code> and <code>receive</code> methods in a thread-safe way.<a data-startref="ix_ch09-asciidoc7" data-type="indexterm" id="idm46669743768672"/><a data-startref="ix_ch09-asciidoc6" data-type="indexterm" id="idm46669743768064"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conflated Channel" data-type="sect2"><div class="sect2" id="idm46669743767136">&#13;
<h2>Conflated Channel</h2>&#13;
&#13;
<p><a data-primary="channels" data-secondary="conflated" data-type="indexterm" id="idm46669743765760"/><a data-primary="conflated channels" data-type="indexterm" id="idm46669743764784"/>This channel has a buffer of size 1, and only keeps the last sent element. To create a <em>conflated</em> channel, you invoke&#13;
<a data-primary="ChannelT(Channel.CONFLATED)" data-type="indexterm" id="idm46669743763600"/><code>Channel&lt;T&gt;(Channel.CONFLATED)</code>. For example:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">channel</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;(</code><code class="n">Channel</code><code class="p">.</code><code class="n">CONFLATED</code><code class="p">)</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">job</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="n">channel</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="s">"one"</code><code class="p">)</code>&#13;
        <code class="n">channel</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="s">"two"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">job</code><code class="p">.</code><code class="n">join</code><code class="p">()</code>&#13;
    <code class="k">val</code> <code class="py">elem</code> <code class="p">=</code> <code class="n">channel</code><code class="p">.</code><code class="n">receive</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Last value was: $elem"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">The output of this program is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Last value was: two</pre>&#13;
&#13;
<p>The first sent element is “one.” When “two” is sent, it replaces “one” in the channel. We wait until the coroutine-sending elements complete, using<a data-primary="job.join()" data-type="indexterm" id="idm46669743674560"/> <code>job.join()</code>. Then we read the value <code>two</code> from the channel.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Buffered Channel" data-type="sect2"><div class="sect2" id="idm46669743672720">&#13;
<h2>Buffered Channel</h2>&#13;
&#13;
<p><a data-primary="buffered channels" data-type="indexterm" id="idm46669743671344"/><a data-primary="channels" data-secondary="buffered" data-type="indexterm" id="idm46669743670416"/>A <em>buffered</em> channel is a <code>Channel</code> with a fixed capacity—an integer greater than 0. Senders to this channel don’t&#13;
suspend unless the buffer is full, and receivers from this channel don’t suspend unless the buffer is empty. To create&#13;
a buffered channel of <code>Int</code> with a buffer of size 2, you would invoke <code>Channel&lt;Int&gt;(2)</code>. Here is an example of usage:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">channel</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;(</code><code class="m">2</code><code class="p">)</code>&#13;
&#13;
    <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="k">in</code> <code class="m">0.</code><code class="p">.</code><code class="m">4</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Send $i"</code><code class="p">)</code>&#13;
            <code class="n">channel</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="k">in</code> <code class="n">channel</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Received $i"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output of this program is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Send 0&#13;
Send 1&#13;
Send 2&#13;
Received 0&#13;
Received 1&#13;
Received 2&#13;
Send 3&#13;
Send 4&#13;
Received 3&#13;
Received 4</pre>&#13;
&#13;
<p>In this example, we’ve defined a <code>Channel</code> with a fixed capacity of 2. A coroutine attempts to send five integers, while&#13;
another coroutine consumes elements from the channel. The sender coroutine manages to send 0 and 1 in one go, then&#13;
attempts to send 3. The <code>println("Send $i")</code> is executed for the value 3 but the sender coroutine gets suspended in the&#13;
<code>send</code> call. The same reasoning applies for the consumer coroutine: two elements are received consecutively with an&#13;
additional print before &#13;
<span class="keep-together">suspending.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Channel Producers" data-type="sect2"><div class="sect2" id="idm46669743569440">&#13;
<h2>Channel Producers</h2>&#13;
&#13;
<p><a data-primary="channels" data-secondary="produce builder with" data-type="indexterm" id="idm46669743567904"/>Until now, you’ve seen that a <code>Channel</code> can be used for both sending <em>and</em> receiving elements. Sometimes you might want&#13;
to be more explicit about how a channel should be used for either sending or receiving. When you’re implementing a&#13;
<code>Channel</code> that is meant to be read only by other coroutines, you can use the <code>produce</code> builder:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">produceValues</code><code class="p">():</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">produce</code> <code class="p">{</code>&#13;
    <code class="n">send</code><code class="p">(</code><code class="s">"one"</code><code class="p">)</code>&#13;
    <code class="n">send</code><code class="p">(</code><code class="s">"two"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As you can see, <code>produce</code> returns a <code>ReceiveChannel</code>—which only has methods relevant to receiving operations (<code>receive</code>&#13;
is among them). An instance of <code>ReceiveChannel</code> cannot be used to send elements.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Also, we’ve defined<a data-primary="produceValues()" data-type="indexterm" id="idm46669743544112"/> <code>produceValues()</code> as an extension function of <code>CoroutineScope</code>. Calling <code>produceValues</code> will start&#13;
a new coroutine that sends elements into a channel. There’s a convention in Kotlin: every function that starts&#13;
coroutines should be defined as an extension function of <code>CoroutineScope</code>. If you follow this convention, you can easily&#13;
distinguish in your code which functions are starting new coroutines from suspending functions.</p>&#13;
</div>&#13;
&#13;
<p>The main code that makes use of <code>produceValues</code> could be:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">receiveChannel</code> <code class="p">=</code> <code class="n">produceValues</code><code class="p">()</code>&#13;
&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">e</code> <code class="k">in</code> <code class="n">receiveChannel</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="n">e</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Conversely, a <code>SendChannel</code> only has methods relevant to sending operations. Actually, looking at the source code, a&#13;
<code>Channel</code> is an interface deriving from both <code>ReceiveChannel</code> and <code>SendChannel</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">public</code> <code class="n">interface</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">E</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">E</code><code class="p">&gt;,</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">E</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// code removed for brevity</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here is how you can use a <code>SendChannel</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">collectImages</code><code class="p">(</code><code class="n">imagesOutput</code><code class="p">:</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Image</code><code class="p">&gt;)</code> <code class="p">{</code>&#13;
    <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">image</code> <code class="p">=</code> <code class="n">readImage</code><code class="p">()</code>&#13;
        <code class="n">imagesOutput</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">image</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Communicating Sequential Processes" data-type="sect1"><div class="sect1" id="idm46669743440960">&#13;
<h1>Communicating Sequential Processes</h1>&#13;
&#13;
<p><a data-primary="channels" data-secondary="communicating sequential processes" data-type="indexterm" id="ix_ch09-asciidoc8"/><a data-primary="communicating sequential processes (CSP)" data-secondary="example" data-type="indexterm" id="ix_ch09-asciidoc9"/>Enough of the theory, let’s get started and see how channels can be used to implement a real-life problem.&#13;
Imagine that your Android application has to display “shapes” in a canvas. Depending on the inputs of the user, your&#13;
application has to display an arbitrary number of shapes. We’re purposely using generic terms—a shape could be a&#13;
point of interest on a map, an item in a game, anything that may require some background work like API calls, file&#13;
reads, database queries, etc. In our example, the main thread, which already handles user input, will simulate requests for&#13;
new shapes to be rendered. You can already foresee that it’s a producer-consumer problem: the main thread makes requests,&#13;
while some background task handles them and returns the results to the main thread.</p>&#13;
&#13;
<p>Our implementation should:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Be thread-safe</p>&#13;
</li>&#13;
<li>&#13;
<p>Reduce the risk of overwhelming the device memory</p>&#13;
</li>&#13;
<li>&#13;
<p>Have no thread contention (we won’t use locks)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Model and Architecture" data-type="sect2"><div class="sect2" id="idm46669743348496">&#13;
<h2>Model and Architecture</h2>&#13;
&#13;
<p><a data-primary="communicating sequential processes (CSP)" data-secondary="model and architecture" data-type="indexterm" id="idm46669743346720"/>A <code>Shape</code> is made of a <code>Location</code> and some useful <code>ShapeData</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Shape</code><code class="p">(</code><code class="k">val</code> <code class="py">location</code><code class="p">:</code> <code class="n">Location</code><code class="p">,</code> <code class="k">val</code> <code class="py">data</code><code class="p">:</code> <code class="n">ShapeData</code><code class="p">)</code>&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Location</code><code class="p">(</code><code class="k">val</code> <code class="py">x</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="k">val</code> <code class="py">y</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code>&#13;
<code class="k">class</code> <code class="nc">ShapeData</code></pre>&#13;
&#13;
<p>Given a <code>Location</code>, we need to fetch the corresponding <code>ShapeData</code> to build a <code>Shape</code>. So in this example, <code>Location</code>s&#13;
are the input, and <code>Shape</code>s the output. For brevity, we’ll use the words “location” for <code>Location</code> and “shape” for&#13;
<code>Shape</code>.</p>&#13;
&#13;
<p>In our implementation, we’ll distinguish two main components:</p>&#13;
<dl>&#13;
<dt>view-model</dt>&#13;
<dd>&#13;
<p>This holds most of the application logic related to shapes. As the user interacts with the UI, the&#13;
view gives the view-model a list of locations.</p>&#13;
</dd>&#13;
<dt><code>shapeCollector</code></dt>&#13;
<dd>&#13;
<p>This is responsible for fetching shapes given a list of locations.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#csp_highlevel_arch">Figure 9-4</a> illustrates the bidirectional relationship between the view-model and the shape collector.</p>&#13;
&#13;
<figure><div class="figure" id="csp_highlevel_arch">&#13;
<img alt="High-level architecture" src="assets/pawk_0904.png"/>&#13;
<h6><span class="label">Figure 9-4. </span>High-level architecture.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>ShapeCollector</code> follows a simple process:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">               fetchData&#13;
Location ---------------------&gt; ShapeData</pre>&#13;
&#13;
<p>As an additional prerequisite, our <code>ShapeCollector</code> should maintain an internal “registry” of locations being processed.&#13;
Upon receiving a location to process, the <code>ShapeCollector</code> shouldn’t attempt to download it if it’s already being processed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="A First Implementation" data-type="sect2"><div class="sect2" id="idm46669743347872">&#13;
<h2>A First Implementation</h2>&#13;
&#13;
<p><a data-primary="communicating sequential processes (CSP)" data-secondary="first implementation" data-type="indexterm" id="ix_ch09-asciidoc10"/>We can start with this first naïve implementation of the <code>ShapeCollector</code>, which is far from being complete, but you’ll get&#13;
the idea:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">ShapeCollector</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">locationsBeingProcessed</code> <code class="p">=</code> <code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;()</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">processLocation</code><code class="p">(</code><code class="n">location</code><code class="p">:</code> <code class="n">Location</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="n">locationsBeingProcessed</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">location</code><code class="p">))</code> <code class="p">{</code>&#13;
             <code class="c1">// fetch data, then send back a Shape instance to</code>&#13;
             <code class="c1">// the view-model</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we were programming with threads, we would have several threads sharing an instance of  <code>ShapeCollector</code>, executing&#13;
<code>processLocation</code> concurrently. Using this approach, however, leads to sharing mutable states. In the previous snippet,&#13;
<code>locationsBeingProcessed</code> is one example.</p>&#13;
&#13;
<p>As you learned in <a data-type="xref" href="ch05.html#thread_safety_id">Chapter 5</a>, making mistakes using locks is surprisingly easy.&#13;
Using coroutines, we don’t have to share mutable state. How? Using coroutines and channels, we can <em>share by communicating</em>&#13;
instead of <em>communicate by sharing</em>.</p>&#13;
&#13;
<p>The key idea is to encapsulate mutable states inside coroutines. In the case of the list of <code>Location</code>s being processed,&#13;
it can be done with:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">launch</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">locationsBeingProcessed</code><code> </code><code class="p">=</code><code> </code><code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>     </code><a class="co" href="#callout_channels_CO1-1" id="co_channels_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">for</code><code> </code><code class="p">(</code><code class="n">location</code><code> </code><code class="k">in</code><code> </code><code class="n">locations</code><code class="p">)</code><code> </code><code class="p">{</code><code>                               </code><a class="co" href="#callout_channels_CO1-2" id="co_channels_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="c1">// same code from previous figure&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_channels_CO1-1" id="callout_channels_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>In the preceding example, only the coroutine that started with <code>launch</code> can touch the mutable state, which is&#13;
<code>locationsBeingProcessed</code>.</p></dd>&#13;
<dt><a class="co" href="#co_channels_CO1-2" id="callout_channels_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>However, we now have a problem. How do we provide the <code>location</code>s? We have to somehow provide this iterable&#13;
to the coroutine. So we’ll use a <code>Channel</code>, and use it as input of a function we’ll declare. Since we’re launching a&#13;
coroutine inside a function, we declare this function as an extension function of <code>CoroutineScope</code>:</p></dd>&#13;
</dl>&#13;
&#13;
<pre data-type="programlisting">private fun CoroutineScope.collectShapes(&#13;
     locations: ReceiveChannel&lt;Location&gt;&#13;
) = launch {&#13;
     // code removed for brevity&#13;
}</pre>&#13;
&#13;
<p>As this coroutine will be receiving <code>Location</code>s from the view-model, we declare the <code>Channel</code> as a <code>ReceiveChannel</code>.&#13;
By the way, you’ve seen in the previous section that a <code>Channel</code> can be iterated over, just like a list.&#13;
So now, we can fetch the corresponding <code>ShapeData</code> for each <code>Location</code> instance received from the channel. As you’ll want&#13;
to do this in parallel, you might be tempted to write something like so:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">collectShapes</code><code class="p">(</code>&#13;
     <code class="n">locations</code><code class="p">:</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code>&#13;
<code class="p">)</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
     <code class="k">val</code> <code class="py">locationsBeingProcessed</code> <code class="p">=</code> <code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;()</code>&#13;
&#13;
     <code class="k">for</code> <code class="p">(</code><code class="n">loc</code> <code class="k">in</code> <code class="n">locations</code><code class="p">)</code> <code class="p">{</code>&#13;
         <code class="k">if</code> <code class="p">(!</code><code class="n">locationsBeingProcessed</code><code class="p">.</code><code class="n">contains</code><code class="p">(</code><code class="n">loc</code><code class="p">)</code> <code class="p">{</code>&#13;
              <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
                   <code class="c1">// fetch the corresponding `ShapeData`</code>&#13;
              <code class="p">}</code>&#13;
         <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Beware, as there’s a catch in this code. You see, for each received location, we start a new coroutine. Potentially, this&#13;
code might start a lot of coroutines if the <code>locations</code> channel debits a lot of items. For this reason, this situation&#13;
is also called <em>unlimited</em> &#13;
<span class="keep-together"><em>concurrency</em>.</span> When we introduced coroutines, we said that they are lightweight. It’s true, but the work they do might very well consume significant&#13;
resources. In this case, <code>launch(Dispatchers.IO)</code> in itself has an insignificant overhead, while fetching the&#13;
<code>ShapeData</code> could require a REST API call on a server with limited bandwidth.</p>&#13;
&#13;
<p>So we’ll have to find a way to limit concurrency—we don’t want to start an unlimited number of coroutines. When facing&#13;
this situation with threads, a common practice is to use a thread pool coupled with a work queue (see <a data-type="xref" href="ch05.html#thread_safety_id">Chapter 5</a>). Instead of a thread pool, we’ll create a <em>coroutine pool</em>, which we’ll name <em>worker pool</em>. Each coroutine from this worker pool will perform the actual fetch of <code>ShapeData</code> for a given location. To communicate&#13;
with this worker pool, <code>collectShapes</code> should use an additional channel to which it can send locations to the&#13;
worker pool, as shown in <a data-type="xref" href="#limit_concurrency_id">Figure 9-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="limit_concurrency_id">&#13;
<img alt="Limit Concurrency" src="assets/pawk_0905.png"/>&#13;
<h6><span class="label">Figure 9-5. </span>Limit concurrency.</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>When you use <code>Channel</code>s, <em>be careful not to have unlimited <a data-primary="concurrency, limiting" data-type="indexterm" id="idm46669743031232"/>concurrency</em>. Imagine that you have to instantiate a lot of <code>Bitmap</code> instances. The underlying memory buffer which stores pixel data takes a &#13;
<span class="keep-together">nonnegligible</span> amount of space in memory. When working with a lot of images, allocating a fresh instance of <code>Bitmap</code> every time you need to create an image causes significant pressure on the system (which has to allocate&#13;
memory in RAM while the garbage collector cleans up all the previously created instances that aren’t referenced anymore). A canonical solution to this problem is <code>Bitmap</code> pooling, which is only a particular case of the more general pattern of <em>object pooling</em>. Instead of creating a fresh instance of <code>Bitmap</code>, you can pick one from the pool (and reuse&#13;
the underlying buffer when possible).</p>&#13;
</div>&#13;
&#13;
<p>This is how you would modify <code>collectShapes</code> to take an additional channel &#13;
<span class="keep-together">parameter:</span></p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">collectShapes</code><code class="p">(</code>&#13;
     <code class="n">locations</code><code class="p">:</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;,</code>&#13;
     <code class="n">locationsToProcess</code><code class="p">:</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;,</code>&#13;
<code class="p">)</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
     <code class="k">val</code> <code class="py">locationsBeingProcessed</code> <code class="p">=</code> <code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;()</code>&#13;
&#13;
     <code class="k">for</code> <code class="p">(</code><code class="n">loc</code> <code class="k">in</code> <code class="n">locations</code><code class="p">)</code> <code class="p">{</code>&#13;
         <code class="k">if</code> <code class="p">(!</code><code class="n">locationsBeingProcessed</code><code class="p">.</code><code class="n">contains</code><code class="p">(</code><code class="n">loc</code><code class="p">)</code> <code class="p">{</code>&#13;
              <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
                   <code class="n">locationsToProcess</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">loc</code><code class="p">)</code>&#13;
              <code class="p">}</code>&#13;
         <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice how <code>collectShapes</code> now sends a location to the <code>locationsToProcess</code> channel, only if the location isn’t in the&#13;
list of locations currently being processed.</p>&#13;
&#13;
<p>As for the worker implementation, it simply reads from the channel we just created—except that from the worker&#13;
perspective, it’s a <code>ReceiveChannel</code>. Using the same &#13;
<span class="keep-together">pattern:</span></p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">worker</code><code class="p">(</code>&#13;
        <code class="n">locationsToProcess</code><code class="p">:</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;,</code>&#13;
<code class="p">)</code> <code class="p">=</code> <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">for</code> <code class="p">(</code><code class="n">loc</code> <code class="k">in</code> <code class="n">locationsToProcess</code><code class="p">)</code> <code class="p">{</code>&#13;
             <code class="c1">// fetch the ShapeData, see later</code>&#13;
        <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For now, we are not focusing on how to fetch a <code>ShapeData</code>. The most important notion to understand here is the&#13;
<code>for</code> loop.&#13;
Thanks to the iteration on the &#13;
<span class="keep-together"><code>locationsToProcess</code></span> channel, each individual <code>worker</code> coroutine will receive its own&#13;
location without interfering with the others. No matter how many workers we’ll start, a location sent from&#13;
<code>collectShapes</code> to the <code>locationsToProcess</code> channel will only be received by one worker. You’ll see that each worker&#13;
will be created with the same channel instance when we wire all those things up. In message-oriented software, this&#13;
pattern, which implies delivery of a message to multiple destinations, is called &#13;
<span class="keep-together"><em>fan-out</em>.</span></p>&#13;
&#13;
<p>Looking back at the missing implementation inside the <code>for</code> loop, this is what we’ll do:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Fetch the <code>ShapeData</code> (which from now on we’ll simply refer to as “data”).</p>&#13;
</li>&#13;
<li>&#13;
<p>Create a <code>Shape</code> from the location and the data.</p>&#13;
</li>&#13;
<li>&#13;
<p>Send the shape to some channel, which other components in our application will use to get the shapes from <code>ShapeCollector</code>. Obviously, we haven’t created such a channel yet.</p>&#13;
</li>&#13;
<li>&#13;
<p>Notify the <code>collectShapes</code> coroutine that the given location has been processed, by sending it back to its sender.&#13;
Again, such a channel has to be created.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Do note that this isn’t the only possible implementation. You could imagine other ways and adapt to your needs. After&#13;
all, this is what this chapter is all about: to give you examples and inspiration for your next developments.</p>&#13;
&#13;
<p>Back on our horse, <a data-type="xref" href="#csp_worker_impl_id">Example 9-1</a> shows the final implementation of the <code>worker</code> &#13;
<span class="keep-together">coroutine.</span></p>&#13;
<div class="less_space" data-type="example" id="csp_worker_impl_id">&#13;
<h5><span class="label">Example 9-1. </span>Worker coroutine</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">worker</code><code class="p">(</code>&#13;
    <code class="n">locationsToProcess</code><code class="p">:</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;,</code>&#13;
    <code class="n">locationsProcessed</code><code class="p">:</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;,</code>&#13;
    <code class="n">shapesOutput</code><code class="p">:</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Shape</code><code class="p">&gt;</code>&#13;
<code class="p">)</code> <code class="p">=</code> <code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">loc</code> <code class="k">in</code> <code class="n">locationsToProcess</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">try</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">data</code> <code class="p">=</code> <code class="n">getShapeData</code><code class="p">(</code><code class="n">loc</code><code class="p">)</code>&#13;
            <code class="k">val</code> <code class="py">shape</code> <code class="p">=</code> <code class="n">Shape</code><code class="p">(</code><code class="n">loc</code><code class="p">,</code> <code class="n">data</code><code class="p">)</code>&#13;
            <code class="n">shapesOutput</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">shape</code><code class="p">)</code>&#13;
        <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>&#13;
            <code class="n">locationsProcessed</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">loc</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Just like the <code>collectShapes</code> was adapted earlier to take one channel as an argument, this time we’re adding two more&#13;
channels: <code>locationsProcessed</code> and <code>shapesOutput</code>.</p>&#13;
&#13;
<p>Inside the <code>for</code> loop, we first get a <code>ShapeData</code> instance for a location. For the sake of this simple example, <a data-type="xref" href="#csp_getshapedata_impl_id">Example 9-2</a> shows our implementation.</p>&#13;
<div class="less_space" data-type="example" id="csp_getshapedata_impl_id">&#13;
<h5><span class="label">Example 9-2. </span><code>Getting shape data</code></h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="n">suspend</code> <code class="k">fun</code> <code class="nf">getShapeData</code><code class="p">(</code>&#13;
    <code class="n">location</code><code class="p">:</code> <code class="n">Location</code>&#13;
<code class="p">):</code> <code class="n">ShapeData</code> <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="cm">/* Simulate some remote API delay */</code>&#13;
        <code class="n">delay</code><code class="p">(</code><code class="m">10</code><code class="p">)</code>&#13;
        <code class="n">ShapeData</code><code class="p">()</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Since the <code>getShapeData</code> method might not return immediately, we implement it as a <code>suspend</code> function. Imagining that&#13;
the downstream code involves a remote API, we use <code>Dispatchers.IO</code>.</p>&#13;
&#13;
<p>The <code>collectShapes</code> coroutine has to be adapted again, since it has to accept one more channel—the one from which the&#13;
workers send back locations they’re done processing. You’re starting to get used to it—it’ll be a <code>ReceiveChannel</code>&#13;
from the &#13;
<span class="keep-together"><code>collectShapes</code></span> perspective. Now <code>collectShapes</code> accepts two <code>ReceiveChannel</code>s and one &#13;
<span class="keep-together"><code>SendChannel</code>.</span></p>&#13;
&#13;
<p class="pagebreak-before">Let’s try it:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">collectShapes</code><code class="p">(</code>&#13;
     <code class="n">locations</code><code class="p">:</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;,</code>&#13;
     <code class="n">locationsToProcess</code><code class="p">:</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;,</code>&#13;
     <code class="n">locationsProcessed</code><code class="p">:</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code>&#13;
<code class="p">):</code> <code class="n">Job</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
     <code class="p">...</code>&#13;
     <code class="k">for</code> <code class="p">(</code><code class="n">loc</code> <code class="k">in</code> <code class="n">locations</code><code class="p">)</code> <code class="p">{</code>&#13;
          <code class="c1">// same implementation, hidden for brevity</code>&#13;
     <code class="p">}</code>&#13;
     <code class="c1">// but.. how do we iterate over locationsProcessed?</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now we have a problem. How can you receive elements from multiple &#13;
<span class="keep-together"><code>ReceiveChannel</code>s</span> at the same time? If we add another&#13;
<code>for</code> loop right below the <code>locations</code> channel iteration, it wouldn’t work as intended as the first iteration only ends when&#13;
the <code>locations</code> channel is closed.</p>&#13;
&#13;
<p>For that purpose, you can use the <code>select</code> expression.<a data-startref="ix_ch09-asciidoc10" data-type="indexterm" id="idm46669742586800"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The select Expression" data-type="sect2"><div class="sect2" id="idm46669743271056">&#13;
<h2>The select Expression</h2>&#13;
&#13;
<p><a data-primary="channels" data-secondary="select expression" data-type="indexterm" id="ix_ch09-asciidoc11"/><a data-primary="communicating sequential processes (CSP)" data-secondary="select expression" data-type="indexterm" id="ix_ch09-asciidoc12"/><a data-primary="select expression" data-type="indexterm" id="ix_ch09-asciidoc13"/>The <code>select</code> expression waits for the result of multiple suspending functions simultaneously, which are specified using&#13;
<em>clauses</em> in the body of this select invocation. The caller is suspended until one of the clauses is either <em>selected</em>&#13;
or <em>fails</em>.</p>&#13;
&#13;
<p>In our case, it works like so:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">select</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="n">locations</code><code class="p">.</code><code class="n">onReceive</code> <code class="p">{</code> <code class="n">loc</code> <code class="p">-&gt;</code>&#13;
        <code class="c1">// do action 1</code>&#13;
    <code class="p">}</code>&#13;
    <code class="n">locationsProcessed</code><code class="p">.</code><code class="n">onReceive</code> <code class="p">{</code> <code class="n">loc</code> <code class="p">-&gt;</code>&#13;
        <code class="c1">// do action 2</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If the <code>select</code> expression could talk, it would say: “Whenever the <code>locations</code> channel receives an element, I’ll do&#13;
action 1. Or, if the <code>locationsProcessed</code> channel receives something, I’ll do action 2. I can’t do both actions at the&#13;
same time. By the way, I’m returning <code>Unit</code>.”</p>&#13;
&#13;
<p>The “I can’t do both actions at the same time” is important. You might wonder what would happen if action 1 takes&#13;
half an hour—or worse, if it never completes. We’ll describe a similar situation in <a data-type="xref" href="#deadlock_in_csp_id">“Deadlock in CSP”</a>. However, the&#13;
implementation that follows is guaranteed <em>never</em> to block for a long time in each action.</p>&#13;
&#13;
<p>Since <code>select</code> is an expression, it returns a result. The result type is inferred by the return type of the lambdas we&#13;
provide for each case of the <code>select</code>—pretty much like the <code>when</code> expression. In this particular example, we don’t&#13;
want any result, so the return type is <code>Unit</code>. As <code>select</code> returns after either the <code>locations</code> or <code>locationsProcessed</code>&#13;
channel receives an element, it doesn’t iterate over channels like our previous <code>for</code> loop. Consequently, we have to&#13;
wrap it inside a <code>while(true)</code>. The complete implementation of <code>collectShapes</code> is shown in <a data-type="xref" href="#csp_collectshapes_id">Example 9-3</a>.</p>&#13;
<div class="less_space" data-type="example" id="csp_collectshapes_id">&#13;
<h5><span class="label">Example 9-3. </span>Collecting shapes</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">private</code><code> </code><code class="k">fun</code><code> </code><code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">collectShapes</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="n">locations</code><code class="p">:</code><code> </code><code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="n">locationsToProcess</code><code class="p">:</code><code> </code><code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="n">locationsProcessed</code><code class="p">:</code><code> </code><code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">launch</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">locationsBeingProcessed</code><code> </code><code class="p">=</code><code> </code><code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">while</code><code> </code><code class="p">(</code><code class="k">true</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="n">select</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;</code><code> </code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="n">locationsProcessed</code><code class="p">.</code><code class="n">onReceive</code><code> </code><code class="p">{</code><code>                     </code><a class="co" href="#callout_channels_CO2-1" id="co_channels_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>                </code><code class="n">locationsBeingProcessed</code><code class="p">.</code><code class="n">remove</code><code class="p">(</code><code class="n">it</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>            </code><code class="n">locations</code><code class="p">.</code><code class="n">onReceive</code><code> </code><code class="p">{</code><code>                              </code><a class="co" href="#callout_channels_CO2-2" id="co_channels_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>                </code><code class="k">if</code><code> </code><code class="p">(</code><code class="p">!</code><code class="n">locationsBeingProcessed</code><code class="p">.</code><code class="n">any</code><code> </code><code class="p">{</code><code> </code><code class="n">loc</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>                    </code><code class="n">loc</code><code> </code><code class="p">=</code><code class="p">=</code><code> </code><code class="n">it</code><code> </code><code class="p">}</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                    </code><code class="cm">/* Add it to the list of locations being processed */</code><code>&#13;
</code><code>                    </code><code class="n">locationsBeingProcessed</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">it</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>                    </code><code class="cm">/* Now download the shape at location */</code><code>&#13;
</code><code>                    </code><code class="n">locationsToProcess</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">it</code><code class="p">)</code><code>&#13;
</code><code>                </code><code class="p">}</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_channels_CO2-1" id="callout_channels_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>When the <code>locationsProcessed</code> channel receives a location, we know that this location has been processed by a worker. It&#13;
should now be removed from the list of locations being processed.</p></dd>&#13;
<dt><a class="co" href="#co_channels_CO2-2" id="callout_channels_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>When the <code>locations</code> channel receives a location, we have to first check whether we’ve already been processing the same&#13;
location or not. If not, we’ll add the &#13;
<span class="keep-together">location</span> to the <code>locationsBeingProcessed</code> list, and then send it to the&#13;
&#13;
<span class="keep-together"><code>locationsToProcess</code></span> channel.<a data-startref="ix_ch09-asciidoc13" data-type="indexterm" id="idm46669742343664"/><a data-startref="ix_ch09-asciidoc12" data-type="indexterm" id="idm46669742342960"/><a data-startref="ix_ch09-asciidoc11" data-type="indexterm" id="idm46669742342288"/></p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Putting It All Together" data-type="sect2"><div class="sect2" id="idm46669742341488">&#13;
<h2>Putting It All Together</h2>&#13;
&#13;
<p><a data-primary="communicating sequential processes (CSP)" data-secondary="putting it all together" data-type="indexterm" id="idm46669742340112"/>The final architecture of the <code>ShapeCollector</code> takes shape, as shown in <a data-type="xref" href="#csp_final_arch_id">Figure 9-6</a>.</p>&#13;
&#13;
<figure><div class="figure" id="csp_final_arch_id">&#13;
<img alt="Final Architecture" src="assets/pawk_0906.png"/>&#13;
<h6><span class="label">Figure 9-6. </span>Final architecture.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Remember that all the channels we used to implement the <code>collectShapes</code> and <code>worker</code> methods have to be created&#13;
somewhere. To respect encapsulation, a good place to do that is in a <code>start</code> method, as shown in <a data-type="xref" href="#csp_shapecollector_impl_id">Example 9-4</a>.</p>&#13;
<div class="less_space" data-type="example" id="csp_shapecollector_impl_id">&#13;
<h5><span class="label">Example 9-4. </span>Shape collector</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">ShapeCollector</code><code class="p">(</code><code class="k">private</code> <code class="k">val</code> <code class="py">workerCount</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">start</code><code class="p">(</code>&#13;
        <code class="n">locations</code><code class="p">:</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;,</code>&#13;
        <code class="n">shapesOutput</code><code class="p">:</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Shape</code><code class="p">&gt;</code>&#13;
    <code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">locationsToProcess</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;()</code>&#13;
        <code class="k">val</code> <code class="py">locationsProcessed</code> <code class="p">=</code> <code class="n">Channel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;(</code><code class="n">capacity</code> <code class="p">=</code> <code class="m">1</code><code class="p">)</code>&#13;
&#13;
        <code class="n">repeat</code><code class="p">(</code><code class="n">workerCount</code><code class="p">)</code> <code class="p">{</code>&#13;
             <code class="n">worker</code><code class="p">(</code><code class="n">locationsToProcess</code><code class="p">,</code> <code class="n">locationsProcessed</code><code class="p">,</code> <code class="n">shapesOutput</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">collectShapes</code><code class="p">(</code><code class="n">locations</code><code class="p">,</code> <code class="n">locationsToProcess</code><code class="p">,</code> <code class="n">locationsProcessed</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">collectShapes</code> <code class="c1">// already implemented</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">worker</code>        <code class="c1">// already implemented</code>&#13;
&#13;
    <code class="k">private</code> <code class="n">suspend</code> <code class="k">fun</code> <code class="nf">getShapeData</code>         <code class="c1">// already implemented</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>This <code>start</code> method is responsible for starting the whole shape collection machinery. The two channels that are exclusively used inside the <code>ShapeCollector</code> are created: &#13;
<span class="keep-together"><code>locationsToProcess</code></span> and <code>locationsProcessed</code>. We are not explicitly creating &#13;
<span class="keep-together"><code>ReceiveChannel</code></span> or <code>SendChannel</code> instances here. We’re creating them as <code>Channel</code> instances because they’ll further be used either as <code>ReceiveChannel</code> or <code>SendChannel</code>. Then the worker pool is created and started, by calling the <code>worker</code> method as many times as &#13;
<span class="keep-together"><code>workerCount</code></span> was set. It’s achieved using the <code>repeat</code> function from the standard library.</p>&#13;
&#13;
<p>Finally, we call <code>collectShapes</code> once. Overall, we started <code>workerCount + 1</code> coroutines in this <code>start</code> method.</p>&#13;
&#13;
<p>You might have noticed that <code>locationsProcessed</code> is created with a capacity of 1. This is intended, and is an important detail. We’ll explain why in the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fan-Out and Fan-In" data-type="sect2"><div class="sect2" id="idm46669742176720">&#13;
<h2>Fan-Out and Fan-In</h2>&#13;
&#13;
<p><a data-primary="channels" data-secondary="fan-out and fan-in" data-type="indexterm" id="idm46669742175344"/><a data-primary="communicating sequential processes (CSP)" data-secondary="fan-out and fan-in" data-type="indexterm" id="idm46669742174144"/><a data-primary="fan-in" data-type="indexterm" id="idm46669742173104"/><a data-primary="fan-out" data-type="indexterm" id="idm46669742172432"/>You just saw an example of multiple coroutines receiving from the same channel. Indeed, all <code>worker</code> coroutines&#13;
receive from the same <code>locationsToProcess</code> channel.&#13;
A <code>Location</code> instance sent to the <code>locationsToProcess</code> channel will be processed by only one worker, without any risk of&#13;
concurrent issues. This particular interaction between coroutines is known as <em>fan-out</em>, as shown in <a data-type="xref" href="#fan_in_out_id">Figure 9-7</a>.&#13;
From the standpoint of the coroutine started with the <code>collectShapes</code> function, locations are fanned-out to the worker pool.</p>&#13;
&#13;
<figure><div class="figure" id="fan_in_out_id">&#13;
<img alt="Fan-Out and Fan-In" src="assets/pawk_0907.png"/>&#13;
<h6><span class="label">Figure 9-7. </span>Fan-out and fan-in.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Fan-out is achieved by launching several coroutines which all iterate over the same instance of <code>ReceiveChannel</code> (see the&#13;
 <code>worker</code> implementation in <a data-type="xref" href="#csp_worker_impl_id">Example 9-1</a>). If one of the workers fails, the other ones will continue to receive&#13;
from the channel—making the system resilient to some extent.</p>&#13;
&#13;
<p>Inversely, when several coroutines send elements to the same <code>SendChannel</code> instance, we’re talking about <em>fan-in</em>.&#13;
Again, you’ve got a good example since all workers send <code>Shape</code> instances to <code>shapesOutput</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performance Test" data-type="sect2"><div class="sect2" id="idm46669742161520">&#13;
<h2>Performance Test</h2>&#13;
&#13;
<p><a data-primary="channels" data-secondary="performance test" data-type="indexterm" id="ix_ch09-asciidoc14"/><a data-primary="communicating sequential processes (CSP)" data-secondary="performance test" data-type="indexterm" id="ix_ch09-asciidoc15"/><a data-primary="performance test" data-type="indexterm" id="ix_ch09-asciidoc16"/>Alright! Time to test the performance of our <code>ShapeCollector</code>. The following snippet has a <code>main</code> function, which calls&#13;
the functions <code>consumeShapes</code> and <code>sendLocations</code>. Those functions start a coroutine that, respectively, consumes&#13;
<code>Shape</code> instances from the <code>ShapeCollector</code> and sends <code>Location</code> instances. Overall, this code is close to what you’d&#13;
write in a real view-model, as shown in <a data-type="xref" href="#csp_perf_test_id">Example 9-5</a>.</p>&#13;
<div class="less_space" data-type="example" id="csp_perf_test_id">&#13;
<h5><span class="label">Example 9-5. </span>Shape collector</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">runBlocking</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">shapes</code><code> </code><code class="p">=</code><code> </code><code class="n">Channel</code><code class="p">&lt;</code><code class="n">Shape</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>                </code><a class="co" href="#callout_channels_CO3-1" id="co_channels_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">locations</code><code> </code><code class="p">=</code><code> </code><code class="n">Channel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="n">with</code><code class="p">(</code><code class="n">ShapeCollector</code><code class="p">(</code><code class="m">4</code><code class="p">)</code><code class="p">)</code><code> </code><code class="p">{</code><code>                    </code><a class="co" href="#callout_channels_CO3-2" id="co_channels_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">start</code><code class="p">(</code><code class="n">locations</code><code class="p">,</code><code> </code><code class="n">shapes</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="n">consumeShapes</code><code class="p">(</code><code class="n">shapes</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="n">sendLocations</code><code class="p">(</code><code class="n">locations</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="k">var</code><code> </code><code class="py">count</code><code> </code><code class="p">=</code><code> </code><code class="m">0</code><code>&#13;
</code><code>&#13;
</code><code class="k">fun</code><code> </code><code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">consumeShapes</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="n">shapesInput</code><code class="p">:</code><code> </code><code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Shape</code><code class="p">&gt;</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">launch</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">for</code><code> </code><code class="p">(</code><code class="n">shape</code><code> </code><code class="k">in</code><code> </code><code class="n">shapesInput</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="c1">// increment a counter of shapes&#13;
</code><code>        </code><code class="n">count</code><code class="p">+</code><code class="p">+</code><code>                                  </code><a class="co" href="#callout_channels_CO3-3" id="co_channels_CO3-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="k">fun</code><code> </code><code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">sendLocations</code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="n">locationsOutput</code><code class="p">:</code><code> </code><code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">launch</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="n">withTimeoutOrNull</code><code class="p">(</code><code class="m">3</code><code class="m">0</code><code class="m">0</code><code class="m">0</code><code class="p">)</code><code> </code><code class="p">{</code><code>                    </code><a class="co" href="#callout_channels_CO3-4" id="co_channels_CO3-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>        </code><code class="k">while</code><code> </code><code class="p">(</code><code class="k">true</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="cm">/* Simulate fetching some shape location */</code><code>&#13;
</code><code>            </code><code class="k">val</code><code> </code><code class="py">location</code><code> </code><code class="p">=</code><code> </code><code class="n">Location</code><code class="p">(</code><code class="n">Random</code><code class="p">.</code><code class="n">nextInt</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="n">Random</code><code class="p">.</code><code class="n">nextInt</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="n">locationsOutput</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">location</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="n">println</code><code class="p">(</code><code class="s">"Received $count shapes"</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_channels_CO3-1" id="callout_channels_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We set up the channels according to the needs of the <code>ShapeCollector</code>—see <a data-type="xref" href="#csp_highlevel_arch">Figure 9-4</a>.</p></dd>&#13;
<dt><a class="co" href="#co_channels_CO3-2" id="callout_channels_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We create a <code>ShapeCollector</code> with four workers.</p></dd>&#13;
<dt><a class="co" href="#co_channels_CO3-3" id="callout_channels_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>consumeShapes</code> function only increments a counter. That counter is declared globally—which is fine because&#13;
the coroutine started with <code>consumeShapes</code> is the only one to modify <code>count</code>.</p></dd>&#13;
<dt><a class="co" href="#co_channels_CO3-4" id="callout_channels_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>In the <code>sendLocations</code> functions, we set up a timeout of three seconds. &#13;
<span class="keep-together"><code>withTimeoutOrNull</code></span> is a suspending function that suspends until the provided time is out. Consequently, the coroutine started with <code>sendLocations</code> only prints the received count after three seconds.</p></dd>&#13;
</dl>&#13;
&#13;
<p>If you recall the implementation of <code>getShapeData</code> in <a data-type="xref" href="#csp_getshapedata_impl_id">Example 9-2</a>, we added <code>delay(10)</code> to simulate a suspending call of 10 ms long. Running four workers for three seconds, we would ideally receive 3,000 / 10 × 4 = 1,200 shapes, if our implementation had zero overhead. On our test machine, we got 1,170 shapes—that’s an efficiency of 98%.</p>&#13;
&#13;
<p>Playing a little bit with more workers (64), with <code>delay(5)</code> in each worker, we got 122,518 shapes in 10 seconds (the&#13;
ideal number being 128,000)—that’s an efficiency of 96%.</p>&#13;
&#13;
<p>Overall, the throughput of <code>ShapeCollector</code> is quite decent, event with a <code>sendLocations</code> function that continuously&#13;
sends <code>Location</code> instances without any pause between two sends.<a data-startref="ix_ch09-asciidoc16" data-type="indexterm" id="idm46669741891808"/><a data-startref="ix_ch09-asciidoc15" data-type="indexterm" id="idm46669741891200"/><a data-startref="ix_ch09-asciidoc14" data-type="indexterm" id="idm46669741890592"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Back Pressure" data-type="sect2"><div class="sect2" id="idm46669741889856">&#13;
<h2>Back Pressure</h2>&#13;
&#13;
<p><a data-primary="back pressure" data-type="indexterm" id="idm46669741888608"/><a data-primary="communicating sequential processes (CSP)" data-secondary="back pressure" data-type="indexterm" id="idm46669741887776"/>What happens if our workers are too slow? This could very well happen if a remote HTTP call takes time to&#13;
respond, or a backend server is overwhelmed—we don’t know.&#13;
To simulate this, we can dramatically increase the delay inside <code>getShapeData</code> (see <a data-type="xref" href="#csp_getshapedata_impl_id">Example 9-2</a>). Using&#13;
<a data-primary="delay function" data-type="indexterm" id="idm46669741885424"/><code>delay(500)</code>, we got only 20 shapes in three seconds, with four workers. The throughput decreased, but this isn’t the&#13;
interesting part. As always with producer-consumer problems, issues can arise when consumers slow down—as producers&#13;
might accumulate data and the system may ultimately run out of memory.&#13;
You can add <code>println()</code> logs inside the producer coroutine and run the program again:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">sendLocations</code><code class="p">(</code><code class="n">locationsOutput</code><code class="p">:</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">Location</code><code class="p">&gt;)</code> <code class="p">=</code> <code class="n">launch</code> <code class="p">{</code>&#13;
    <code class="n">withTimeoutOrNull</code><code class="p">(</code><code class="m">3000</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="cm">/* Simulate fetching some shape location */</code>&#13;
            <code class="k">val</code> <code class="py">location</code> <code class="p">=</code> <code class="n">Location</code><code class="p">(</code><code class="n">Random</code><code class="p">.</code><code class="n">nextInt</code><code class="p">(),</code> <code class="n">Random</code><code class="p">.</code><code class="n">nextInt</code><code class="p">())</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Sending a new location"</code><code class="p">)</code>&#13;
            <code class="n">locationsOutput</code><code class="p">.</code><code class="n">send</code><code class="p">(</code><code class="n">location</code><code class="p">)</code>      <code class="c1">// suspending call</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Received $count shapes"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, “Sending a new location” is printed only about 25 times in the console.</p>&#13;
&#13;
<p>So the producer is being slowed down. How?</p>&#13;
&#13;
<p>Because <code>locationsOutput.send(location)</code> is a suspending call. When workers are slow, the <code>collectShapes</code> function (see&#13;
<a data-type="xref" href="#csp_collectshapes_id">Example 9-3</a>) of the <code>ShapeCollector</code> class quickly becomes suspended at the line <code>locationsToProcess.send(it)</code>.&#13;
Indeed, <code>locationsToProcess</code> is a rendezvous channel. Consequently, when the coroutine started with <code>collectShapes</code>&#13;
reaches that line, it’s suspended until a worker is ready to receive the location from <code>locationsToProcess</code>. When the&#13;
previously mentioned coroutine is suspended, it can no longer receive from the <code>locations</code> channel—which corresponds&#13;
to <code>locationsOutput</code> in the previous example. This is the reason why the coroutine that started with <code>sendLocation</code> is in&#13;
turn suspended. When workers finally do their job, <code>collectShapes</code> can resume, and so does the producer coroutine.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Similarities with the Actor Model" data-type="sect2"><div class="sect2" id="idm46669741793680">&#13;
<h2>Similarities with the Actor Model</h2>&#13;
&#13;
<p><a data-primary="Actor model, CSP" data-type="indexterm" id="idm46669741786576"/><a data-primary="communicating sequential processes (CSP)" data-secondary="similarities with the actor model" data-type="indexterm" id="idm46669741785648"/>In CSP, you create coroutines that encapsulate mutable state. Instead of communicating by sharing their state, they share by communicating (using <code>Channel</code>s).&#13;
The coroutine started with the <code>collectShapes</code> function (see <a data-type="xref" href="#csp_collectshapes_id">Example 9-3</a>) uses three channels to communicate&#13;
with other coroutines—one <code>SendChannel</code> and two <code>ReceiveChannel</code>s, as shown in <a data-type="xref" href="#process_csp_id">Figure 9-8</a>.</p>&#13;
&#13;
<p>In CSP parlance, <code>collectShapes</code> and its three channels is a <em>process</em>. A process is a computational entity that communicates with other actors&#13;
using asynchronous message passing (channels). It can do only one thing at a time—reading, writing to channels, or processing.</p>&#13;
&#13;
<p>In the Actor model, an <em>actor</em> is quite similar. One noticeable difference is that an actor only has one channel—called a mailbox. If an actor needs to be responsive and nonblocking, it must delegate its long-running processing to child actors.&#13;
This similarity is the reason why CSP is sometimes referred to as an Actor model implementation.</p>&#13;
&#13;
<figure><div class="figure" id="process_csp_id">&#13;
<img alt="Process" src="assets/pawk_0908.png"/>&#13;
<h6><span class="label">Figure 9-8. </span>Process in CSP.</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Execution Is Sequential Inside a Process" data-type="sect2"><div class="sect2" id="idm46669741776320">&#13;
<h2>Execution Is Sequential Inside a Process</h2>&#13;
&#13;
<p><a data-primary="communicating sequential processes (CSP)" data-secondary="sequential execution inside a process" data-type="indexterm" id="idm46669741775152"/>We’ve just seen that a <em>process</em> is made of a single coroutine and channels. The very nature of a coroutine is for it to be&#13;
executed on some thread. So unless this coroutine starts other child coroutines (which run concurrently, and in some cases in parallel), all lines of that coroutine are executed sequentially. That&#13;
includes receiving from channels, sending objects to other channels, and mutating some private state. Consequently, the&#13;
actors implemented in this chapter could either receive from a channel or send to another channel, but not do both at&#13;
the same time. Under load, this kind of actor can be efficient because it doesn’t involve blocking calls, only&#13;
suspending functions. When a coroutine is suspended, the overall efficiency isn’t necessarily affected, because the thread&#13;
executing the suspended coroutine can then execute another coroutine which has something to do. This way, threads can&#13;
be used to their full potential, never contending to some lock.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Final Thoughts" data-type="sect2"><div class="sect2" id="idm46669741772192">&#13;
<h2>Final Thoughts</h2>&#13;
&#13;
<p><a data-primary="communicating sequential processes (CSP)" data-secondary="final thoughts" data-type="indexterm" id="idm46669741770960"/>This mechanism using CSP style has very little internal overhead. Thanks to <code>Channel</code>s and coroutines, our implementation&#13;
is lock-free. Therefore, there’s <em>no thread contention</em>—the <code>ShapeCollector</code> is less likely to impact other threads of&#13;
your application. Similarly, there’s a chance that the <code>Dispatchers</code> we use in the <code>ShapeCollector</code> might also be used&#13;
in other features in our application. By leveraging lock-free implementations, a coroutine suspended while receiving from&#13;
a channel won’t prevent the underlying thread from executing other coroutines. In other words, we can do more with the&#13;
same resources.</p>&#13;
&#13;
<p>Moreover, this architecture provides built-in back pressure. If some <code>ShapeData</code> instances suddenly take more time to&#13;
fetch, producers of <code>ShapeLocation</code> instances will be slowed down so that locations don’t accumulate—which reduces the&#13;
risk of running out of memory. This back pressure comes for free—you didn’t explicitly write code for such a feature.</p>&#13;
&#13;
<p>The example given in this chapter is generic enough to be taken as is and adapted to fit your needs. In the event that you&#13;
need to significantly deviate from our example, then we owe you a deeper explanation. For example, why did we set a&#13;
capacity of 1 for the <code>locationsProcessed</code> channel in <a data-type="xref" href="#csp_shapecollector_impl_id">Example 9-4</a>? The answer is admittedly&#13;
nontrivial. If we had created a regular rendezvous channel, our <code>ShapeCollector</code> would have suffered from a&#13;
<em>deadlock</em>—which brings us to the next section.<a data-startref="ix_ch09-asciidoc9" data-type="indexterm" id="idm46669741762480"/><a data-startref="ix_ch09-asciidoc8" data-type="indexterm" id="idm46669741761776"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deadlock in CSP" data-type="sect1"><div class="sect1" id="deadlock_in_csp_id">&#13;
<h1>Deadlock in CSP</h1>&#13;
&#13;
<p><a data-primary="communicating sequential processes (CSP)" data-secondary="deadlock" data-type="indexterm" id="ix_ch09-asciidoc17"/><a data-primary="deadlock" data-type="indexterm" id="ix_ch09-asciidoc18"/>Deadlocks are most commonly encountered when working with threads. When thread A holds lock 1 and attempts to seize&#13;
lock 2, while thread B holds lock 2 and attempts to seize lock 1, you have a deadlock. The two threads&#13;
indefinitely wait for each other and neither progresses. Deadlocks can have disastrous consequences when they happen in&#13;
critical components of an application. An efficient way to avoid such a situation is to ensure that a deadlock cannot&#13;
happen under any imaginable circumstances. Even when conditions are highly unlikely to be met, you can trust Murphy’s Law&#13;
to strike some day.</p>&#13;
&#13;
<p>However, deadlocks can also happen in CSP architecture. We can do a little experiment to illustrate this. Instead of&#13;
setting a capacity of 1 to the channel <code>locationsProcessed</code> in <a data-type="xref" href="#csp_shapecollector_impl_id">Example 9-4</a>, let’s use a channel with&#13;
no buffer (a rendezvous channel) and run the performance test sample in <a data-type="xref" href="#csp_perf_test_id">Example 9-5</a>.&#13;
The result printed in the console is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Received 4 shapes</pre>&#13;
&#13;
<p>For the record, we should have received 20 shapes. So, what’s going on?</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Fair warning: the following explanation goes into every necessary detail, and is quite long. We encourage you&#13;
to take the time to read it carefully until the end. It’s the ultimate challenge to test your understanding of channels.</p>&#13;
&#13;
<p>You might also skip it entirely and jump to <a data-type="xref" href="#tldr">“TL;DR”</a>.</p>&#13;
</div>&#13;
&#13;
<p>Let’s have a closer look at the internals of our <code>ShapeCollector</code> class and follow each step as though we were a live&#13;
debugger. Imagine that you’ve just started the performance test sample in <a data-type="xref" href="#csp_perf_test_id">Example 9-5</a>, and the first <code>Location</code>&#13;
instance is sent to the <code>locations</code> channel. That location goes through the <code>collectShapes</code> method with its <code>select</code> expression. At that moment, <code>locationsProcessed</code> has nothing to provide, so the <code>select</code> expression goes through the second case:&#13;
<code>locations.onReceive{..}</code>. If you look at what’s done inside this second case, you can see that a location is sent to the&#13;
<code>locationsToProcess</code> channel—which is a receive channel for each worker. Consequently, the coroutine started by the&#13;
<code>collectShapes</code> method (which we’ll refer to as the <code>collectShapes</code> coroutine) is suspended at the&#13;
<code>locationsToProcess.send(it)</code> invocation until a worker handshakes the <code>locationsToProcess</code> rendezvous channel.&#13;
This happens fairly quickly, since at that time all workers are idle.</p>&#13;
&#13;
<p>When a worker receives the first <code>Location</code> instance, the <code>collectShapes</code> coroutine is resumed and is able to receive&#13;
other locations. As in our worker implementation, we’ve added some delay to simulate a background processing, you can&#13;
consider workers slow compared to other coroutines—which are the <code>collectShapes</code> coroutine and the producer coroutine&#13;
started with the <code>sendLocations</code> method in the test sample (which we’ll refer to as the <code>sendLocations</code> coroutine).&#13;
Therefore, another location is received by the <code>collectShapes</code> coroutine while the worker that which took the first&#13;
location is still busy processing it. Similarly, a second worker quickly handles the second location, and a third&#13;
location is received by the <code>collectShapes</code> coroutine, etc.</p>&#13;
&#13;
<p>The execution continues until all four workers are busy, while a fifth location is received by the <code>collectShapes</code>&#13;
coroutine. Following the same logic as before, the &#13;
<span class="keep-together"><code>collectShapes</code></span> coroutine is suspended until a worker is ready to&#13;
take the <code>Location</code> instance. Unfortunately, all workers are busy. So the <code>collectShapes</code> coroutine isn’t able to take&#13;
incoming locations anymore. Since the <code>collectShapes</code> and &#13;
<span class="keep-together"><code>sendLocations</code></span> coroutines communicate through a rendezvous&#13;
channel, the &#13;
<span class="keep-together"><code>sendLocations</code></span> coroutine is in turn suspended until <code>collectShapes</code> is ready to take more locations.</p>&#13;
&#13;
<p>Time goes by until a worker makes itself available to receive the fifth location. &#13;
<span class="keep-together">Eventually,</span> a worker&#13;
(probably the first worker) is done processing its <code>Location</code> instance. Then it sends the result to the <code>shapesOutput</code> channel and it tries &#13;
<span class="keep-together">to send back the</span> processed location to the <code>collectShapes</code> coroutine, using the&#13;
&#13;
<span class="keep-together"><code>locationsProcessed</code></span> channel. Remember that this is our mechanism to notify &#13;
<span class="keep-together">the <code>collectShapes</code></span> coroutine when a location&#13;
has been processed. However, the &#13;
<span class="keep-together"><code>collectShapes</code></span> coroutine is suspended at the <code>locationsToProcess.send(it)</code> invocation.&#13;
So &#13;
<span class="keep-together"><code>collectShapes</code></span> can’t receive from the <code>locationsProcessed</code> channel. There’s no issue to this situation: this is a&#13;
<em>deadlock</em>,<sup><a data-type="noteref" href="ch09.html#idm46669741723728" id="idm46669741723728-marker">4</a></sup> as shown in <a data-type="xref" href="#deadlock_in_csp_diagram_id">Figure 9-9</a>.</p>&#13;
&#13;
<p>Eventually, the first four locations processed by the workers are processed and four <code>Shape</code> instances are sent to the&#13;
<code>shapesOutput</code> channel. The delay in each worker is only of 10 ms, so all workers have time to complete before the three-second&#13;
timeout. Hence the result:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Received 4 shapes</pre>&#13;
&#13;
<figure><div class="figure" id="deadlock_in_csp_diagram_id">&#13;
<img alt="Deadlock in CSP" src="assets/pawk_0909.png"/>&#13;
<h6><span class="label">Figure 9-9. </span>Deadlock in CSP.</h6>&#13;
</div></figure>&#13;
&#13;
<p>If the <code>locationsProcessed</code> channel had a capacity of at least 1, the first available worker would have been able to&#13;
send back its <code>Location</code> instance and then receive from the <code>locationsToProcess</code> channel—releasing the <code>collectShapes</code>&#13;
coroutine. Subsequently, in the <code>select</code> expression of the <code>collectShapes</code> coroutine, the <code>locationsToProcess</code> channel&#13;
is <em>always</em> checked before the <code>locations</code> channel. This ensures that when the <code>collectShapes</code> coroutine is eventually&#13;
suspended at the <code>locationsToProcess.send(it)</code> invocation, the buffer of the <code>locationsProcessed</code> channel is guaranteed&#13;
to be empty—so a worker can send a location without being suspended. If you’re curious, try to revert the two cases&#13;
<code>locationsProcessed.onReceive {..}</code> and <code>locations.onReceive {..}</code> while having a capacity of 1 for the&#13;
<code>locationsProcessed</code> channel. The result will be: “Received 5 shapes.”</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="TL;DR" data-type="sect1"><div class="sect1" id="tldr">&#13;
<h1>TL;DR</h1>&#13;
&#13;
<p>Not only is the capacity of 1 for the <code>locationsProcessed</code> channel extremely important, the order in which channels are read in the <code>select</code> expression of the &#13;
<span class="keep-together"><code>collectShapes</code></span> coroutine also matters.<sup><a data-type="noteref" href="ch09.html#idm46669741706464" id="idm46669741706464-marker">5</a></sup> What should you remember from this? Deadlocks are possible in CSP. Even more important, understanding what caused the deadlock is an excellent exercise to test your understanding of how channels work.</p>&#13;
&#13;
<p>If we look back at the structure of the <code>ShapeCollector</code>, we can represent the structure as a cyclic graph, as shown in&#13;
<a data-type="xref" href="#cyclic_graph_id">Figure 9-10</a>.</p>&#13;
&#13;
<figure class="less_space"><div class="figure" id="cyclic_graph_id">&#13;
<img alt="Cyclic Graph" src="assets/pawk_0910.png"/>&#13;
<h6><span class="label">Figure 9-10. </span>Cyclic graph.</h6>&#13;
</div></figure>&#13;
&#13;
<p>This new representation emphasizes an important property of the structure: it’s <em>cyclic</em>. <code>Location</code> instances travel&#13;
back and forth between the <code>collectShapes</code> coroutine and workers.</p>&#13;
&#13;
<p>Cycles in CSP are actually the cause of deadlocks. Without cycles, there’s no possibility of deadlock. Sometimes,&#13;
however, you’ll have no choice but to have those cycles. In this case, we gave you the key ideas to reason about CSP,&#13;
so you can find solutions by yourself.<a data-startref="ix_ch09-asciidoc18" data-type="indexterm" id="idm46669741697920"/><a data-startref="ix_ch09-asciidoc17" data-type="indexterm" id="idm46669741697216"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Limitations of Channels" data-type="sect1"><div class="sect1" id="idm46669741696416">&#13;
<h1>Limitations of Channels</h1>&#13;
&#13;
<p><a data-primary="channels" data-secondary="limitations of" data-type="indexterm" id="ix_ch09-asciidoc19"/>Up until now, we’ve held off on discussing the limitations of channels, so we’ll describe some of those limitations now.&#13;
Using notions from this chapter, creating a stream of <code>Int</code> values is typically done as shown in <a data-type="xref" href="#flows_channel_produce_id">Example 9-6</a>.</p>&#13;
<div class="less_space" data-type="example" id="flows_channel_produce_id">&#13;
<h5><span class="label">Example 9-6. </span>Producing numbers</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">numbers</code><code class="p">():</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">produce</code> <code class="p">{</code>&#13;
    <code class="n">send</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
    <code class="n">send</code><code class="p">(</code><code class="m">2</code><code class="p">)</code>&#13;
    <code class="c1">// send other numbers</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>On the receiving side, you can consume those numbers like so:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">channel</code> <code class="p">=</code> <code class="n">numbers</code><code class="p">()</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">x</code> <code class="k">in</code> <code class="n">channel</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Pretty straightforward. Now, what if you need to apply a transformation for each of those numbers? Imagine that your&#13;
transformation function was:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">transform</code><code class="p">(</code><code class="n">n</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">delay</code><code class="p">(</code><code class="m">10</code><code class="p">)</code> <code class="c1">// simulate some heavy CPU computations</code>&#13;
    <code class="n">n</code> <code class="p">+</code> <code class="m">1</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You could modify the <code>numbers</code> function like so:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">numbers</code><code class="p">():</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">produce</code> <code class="p">{</code>&#13;
    <code class="n">send</code><code class="p">(</code><code class="n">transform</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>&#13;
    <code class="n">send</code><code class="p">(</code><code class="n">transform</code><code class="p">(</code><code class="m">2</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It works, but it’s not elegant. A much nicer solution would look like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="cm">/* Warning - this doesn't compile */</code>&#13;
    <code class="k">val</code> <code class="py">channel</code> <code class="p">=</code> <code class="n">numbers</code><code class="p">().</code><code class="n">map</code> <code class="p">{</code>&#13;
        <code class="n">transform</code><code class="p">(</code><code class="n">it</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">x</code> <code class="k">in</code> <code class="n">channel</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="n">x</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Actually, as of Kotlin 1.4, this code doesn’t compile. In the early days of channels, we had “channel operators” such&#13;
as <code>map</code>. However, those operators have been deprecated in Kotlin 1.3, and removed in Kotlin 1.4.</p>&#13;
&#13;
<p>Why? Channels are communication primitives between coroutines. They are specifically designed to distribute values so that&#13;
every value is received by only one receiver. It’s not possible to use channels to broadcast values to multiple receivers.&#13;
The designers of coroutines have created <code>Flow</code>s specifically for asynchronous data streams on which we can use&#13;
transformation operators; we’ll see how in the next chapter.</p>&#13;
&#13;
<p>So, channels are not a convenient solution to implement pipelines of data &#13;
<span class="keep-together">transformations.</span><a data-startref="ix_ch09-asciidoc19" data-type="indexterm" id="idm46669741458320"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Channels Are Hot" data-type="sect1"><div class="sect1" id="idm46669741695824">&#13;
<h1>Channels Are Hot</h1>&#13;
&#13;
<p><a data-primary="channels" data-secondary="hot" data-type="indexterm" id="idm46669741421936"/><a data-primary="hot channels" data-type="indexterm" id="idm46669741420960"/>Let’s have a look at the source code of the <code>produce</code> channel builder. Two lines are interesting, as shown in the following:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">public</code><code> </code><code class="k">fun</code><code> </code><code class="err">&lt;</code><code class="nf">E</code><code class="p">&gt;</code><code> </code><code class="n">CoroutineScope</code><code class="p">.</code><code class="n">produce</code><code class="p">(</code><code>                           </code><a class="co" href="#callout_channels_CO4-1" id="co_channels_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="n">context</code><code class="p">:</code><code> </code><code class="n">CoroutineContext</code><code> </code><code class="p">=</code><code> </code><code class="n">EmptyCoroutineContext</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="n">capacity</code><code class="p">:</code><code> </code><code class="n">Int</code><code> </code><code class="p">=</code><code> </code><code class="m">0</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="n">@BuilderInference</code><code> </code><code class="n">block</code><code class="p">:</code><code> </code><code class="n">suspend</code><code> </code><code class="n">ProducerScope</code><code class="p">&lt;</code><code class="n">E</code><code class="p">&gt;</code><code class="p">.</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">Unit</code><code>&#13;
</code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">E</code><code class="p">&gt;</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">channel</code><code> </code><code class="p">=</code><code> </code><code class="n">Channel</code><code class="p">&lt;</code><code class="n">E</code><code class="p">&gt;</code><code class="p">(</code><code class="n">capacity</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">newContext</code><code> </code><code class="p">=</code><code> </code><code class="n">newCoroutineContext</code><code class="p">(</code><code class="n">context</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">coroutine</code><code> </code><code class="p">=</code><code> </code><code class="n">ProducerCoroutine</code><code class="p">(</code><code class="n">newContext</code><code class="p">,</code><code> </code><code class="n">channel</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="n">coroutine</code><code class="p">.</code><code class="n">start</code><code class="p">(</code><code class="n">CoroutineStart</code><code class="p">.</code><code class="n">DEFAULT</code><code class="p">,</code><code> </code><code class="n">coroutine</code><code class="p">,</code><code> </code><code class="n">block</code><code class="p">)</code><code>    </code><a class="co" href="#callout_channels_CO4-2" id="co_channels_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="n">coroutine</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_channels_CO4-1" id="callout_channels_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>produce</code> is an extension function on <code>CoroutineScope</code>. Remember the convention? It indicates that this function&#13;
starts a new coroutine.</p></dd>&#13;
<dt><a class="co" href="#co_channels_CO4-2" id="callout_channels_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We can confirm that with the<a data-primary="coroutine.start()" data-type="indexterm" id="idm46669741388016"/> <code>coroutine.start()</code> invocation. Don’t pay too much attention to how this&#13;
coroutine is started—it’s an internal implementation.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Consequently, when you invoke the <code>produce</code> channel builder, a new coroutine is started and immediately starts producing&#13;
elements and sending them to the returned channel even if no coroutine is consuming those elements.</p>&#13;
&#13;
<p>This is the reason why channels are said to be <em>hot</em>: a coroutine is actively running to produce or consume data. If you&#13;
know RxJava, this is the same concept as hot observables: they emit values independently of individual subscriptions.&#13;
Consider this simple stream:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">CoroutineScope</code><code class="p">.</code><code class="n">numbers</code><code class="p">():</code> <code class="n">ReceiveChannel</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">produce</code> <code class="p">{</code>&#13;
    <code class="n">use</code><code class="p">(</code><code class="n">openConnectionToDatabase</code><code class="p">())</code> <code class="p">{</code>&#13;
        <code class="n">send</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
        <code class="n">send</code><code class="p">(</code><code class="m">2</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Also, imagine that no other coroutines are consuming this stream. As this function returns a rendezvous channel, the&#13;
started coroutine will suspend on the first <code>send</code>. So you might say: “OK, we’re fine—no background processing is done&#13;
until we provide a consumer to this stream.” It’s true, but if you forget to consume the stream, the database connection&#13;
will remain open—notice that we used the <code>use</code> function from the standard library, which is the equivalent of the&#13;
<code>try</code>-with-<code>resources</code> statement in Java. While it might not be harmful as is, this piece of logic could be part of a retry loop, in&#13;
which case a significant amount of resources would leak.</p>&#13;
&#13;
<p>To sum up, channels are intercoroutine communication primitives. They work really well in a CSP-like architecture.&#13;
However, we don’t have handy operators such as <code>map</code> or <code>filter</code> to transform them. We can’t broadcast&#13;
values to multiple receivers. Moreover, their hot nature can cause memory leaks in some situations.</p>&#13;
&#13;
<p>Flows have been created to address those channels’ limitations. We’ll cover flows in the next chapter.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669741423120">&#13;
<h1>Summary</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Channels are communication primitives that provide a way to transfer streams of values between coroutines.</p>&#13;
</li>&#13;
<li>&#13;
<p>While channels are conceptually close to Java’s <code>BlockingQueue</code>, the fundamental difference is that <code>send</code> and <code>receive</code>&#13;
methods of a channel are suspending functions, not blocking calls.</p>&#13;
</li>&#13;
<li>&#13;
<p>Using channels and coroutines, you can <em>share by communicating</em> instead of the traditional&#13;
<em>communicate by sharing</em>. The goal is to avoid shared mutable-state and thread-safety issues.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can implement complex logic using CSP style, leveraging back pressure. This results in potentially excellent&#13;
performance since the nonblocking nature of suspending functions reduces thread contention to its bare minimum.</p>&#13;
</li>&#13;
<li>&#13;
<p>Beware that deadlock in CSP is possible, if your architecture has cycles (a coroutine sends objects to another&#13;
coroutine, while also receiving objects from the same coroutine). You can fix those deadlocks by, for example, tweaking the order&#13;
in which the <code>select</code> expression treats each cases, or by adjusting the capacity of some channels.</p>&#13;
</li>&#13;
<li>&#13;
<p>Channels should be considered low-level primitives. Deadlocks in CSP are one example of misuse of channels.&#13;
The next chapter will introduce <em>flows</em>—higher-level primitives that exchange streams of data between coroutines.&#13;
It doesn’t mean that you shouldn’t use channels—there are still situations where channels are necessary (the&#13;
<code>ShapeCollector</code> in this chapter is an example). However, you’ll see that in many situations, flows are a better choice.&#13;
In any case, it’s important to know about channels because (as you’ll see) flows sometimes use channels under the hood.<a data-startref="ix_ch09-asciidoc0" data-type="indexterm" id="idm46669741199280"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669744579616"><sup><a href="ch09.html#idm46669744579616-marker">1</a></sup> We’ll sometimes refer to <code>Channel</code>s as channels in the rest of this chapter.</p><p data-type="footnote" id="idm46669744209856"><sup><a href="ch09.html#idm46669744209856-marker">2</a></sup> Specifically, <code>Channel</code> doesn’t implement <code>Iterable</code>.</p><p data-type="footnote" id="idm46669743772336"><sup><a href="ch09.html#idm46669743772336-marker">3</a></sup> If you want to learn how such an algorithm works, we recommend that you read Section 15.4, “NonBlocking Algorithms,” in <em>Java Concurrency in Practice</em>, by Brian Goetz et al. There is also this interesting YouTube video, <a href="https://oreil.ly/WDE1F">Lock-Free Algorithms for Kotlin Coroutines (Part 1)</a> from Roman Elizarov, lead designer of Kotlin coroutines.</p><p data-type="footnote" id="idm46669741723728"><sup><a href="ch09.html#idm46669741723728-marker">4</a></sup> While there’s no lock or mutex involved here, the situation is very similar to a deadlock involving threads. This is why we use the same terminology.</p><p data-type="footnote" id="idm46669741706464"><sup><a href="ch09.html#idm46669741706464-marker">5</a></sup> Actually, our implementation, which uses a capacity of 1 for <code>locationsProcessed</code>, isn’t the only possible implementation that works without deadlocks. There’s at least one solution that uses <code>locationsProcessed</code> as a rendezvous channel. We leave this as an exercise for the reader.</p></div></div></section></body></html>