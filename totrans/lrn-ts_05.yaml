- en: Chapter 4\. Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object literals
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A set of keys and values
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Each with their own type
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Chapter 3, “Unions and Literals”](ch03.xhtml#unions_and_literals) fleshed
    out union and literal types: working with primitives such as `boolean` and literal
    values of them such as `true`. Those primitives only scratch the surface of the
    complex object shapes JavaScript code commonly uses. TypeScript would be pretty
    unusable if it weren’t able to represent those objects. This chapter will cover
    how to describe complex object shapes and how TypeScript checks their assignability.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Object Types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create an object literal with `{...}` syntax, TypeScript will consider
    it to be a new object type, or type shape, based on its properties. That object
    type will have the same property names and primitive types as the object’s values.
    Accessing properties of the value can be done with either `value.member` or the
    equivalent `value['member']` syntax.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript understands that the following `poet` variable’s type is that of
    an object with two properties: `born`, of type `number`, and `name`, of type `string`.
    Accessing those members would be allowed, but attempting to access any other member
    name would cause a type error for that name not existing:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Object types are a core concept for how TypeScript understands JavaScript code.
    Every value other than `null` and `undefined` has a set of members in its backing
    type shape, and so TypeScript must understand the object type for every value
    in order to type check it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Object Types
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inferring types directly from existing objects is all fine and good, but eventually
    you’ll want to be able to declare the type of an object explicitly. You’ll need
    a way to describe an object shape separately from objects that satisfy it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Object types may be described using a syntax that looks similar to object literals
    but with types instead of values for fields. It’s the same syntax that TypeScript
    shows in error messages about type assignability.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'This `poetLater` variable is the same type from before with `name: string`
    and `born: number`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Aliased Object Types
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constantly writing out object types like `{ born: number; name: string; }`
    would get tiresome rather quickly. It’s more common to use type aliases to assign
    each type shape a name.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet could be rewritten with a `type Poet`, which comes
    with the added benefit of making TypeScript’s assignability error message a little
    more direct and readable:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Most TypeScript projects prefer using the `interface` keyword to describe object
    types, which is a feature I won’t cover until [Chapter 7, “Interfaces”](ch07.xhtml#interfaces).
    Aliased object types and interfaces are almost identical: everything in this chapter
    applies to interfaces as well.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: I bring these object types up now because understanding how TypeScript interprets
    object literals is an important part of learning about TypeScript’s type system.
    These concepts will continue to be important once we switch over to features in
    the next section of this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在提到这些对象类型，因为理解TypeScript如何解释对象文字是学习TypeScript类型系统的重要部分。一旦我们转向本书下一节的功能，这些概念将继续非常重要。
- en: Structural Typing
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化类型
- en: 'TypeScript’s type system is *structurally typed*: meaning any value that happens
    to satisfy a type is allowed to be used as a value of that type. In other words,
    when you declare that a parameter or variable is of a particular object type,
    you’re telling TypeScript that whatever object(s) you use, they need to have those
    properties.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的类型系统是*结构化类型*的：意味着任何满足某个类型的值都允许用作该类型的值。换句话说，当您声明参数或变量为特定对象类型时，您告诉TypeScript，无论使用哪个对象（们），它们都必须具有这些属性。
- en: 'The following `WithFirstName` and `WithLastName` aliased object types both
    only declare a single member of type `string`. The `hasBoth` variable just so
    happens to have both of them—even though it wasn’t declared as such explicitly—so
    it can be provided to variables that are declared as either of the two aliased
    object types:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`WithFirstName`和`WithLastName`别名对象类型仅声明了一个名为`string`的成员。`hasBoth`变量恰好具有这两个成员，即使它没有明确声明为这样，因此可以提供给声明为两个别名对象类型之一的变量：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Structural typing not the same as *duck typing*, which comes from the phrase
    “If it looks like a duck and quacks like a duck, it’s probably a duck.”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化类型并不等同于*鸭子类型*，后者源自短语“如果它看起来像鸭子，叫起来像鸭子，那么它可能是鸭子”。
- en: Structural typing is when there is a static system checking the type—in TypeScript’s
    case, the type checker.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化类型是静态系统检查类型的一种情况，在TypeScript的情况下是类型检查器。
- en: Duck typing is when nothing checks object types until they’re used at runtime.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸭子类型是指在运行时使用对象类型之前没有任何检查。
- en: 'In summary: *JavaScript* is *duck typed* whereas *TypeScript* is *structurally
    typed*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：*JavaScript*是*鸭子类型*，而*TypeScript*是*结构化类型*。
- en: Usage Checking
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用检查
- en: When providing a value to a location annotated with an object type, TypeScript
    will check that the value is assignable to that object type. To start, the value
    must have the object type’s required properties. If any member required on the
    object type is missing in the object, TypeScript will issue a type error.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当向带有对象类型注释的位置提供值时，TypeScript会检查该值是否可以分配给该对象类型。首先，该值必须具有对象类型的必需属性。如果对象中缺少对象类型所需的任何成员，则TypeScript将发出类型错误。
- en: 'The following `FirstAndLastNames` aliased object type requires that both the
    `first` and `last` properties exist. An object containing both of those is allowed
    to be used in a variable declared to be of type `FirstAndLastNames`, but an object
    without them is not:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`FirstAndLastNames`别名对象类型要求`first`和`last`属性都存在。包含这两者的对象允许在声明为`FirstAndLastNames`类型的变量中使用，但没有它们的对象则不允许：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Mismatched types between the two are not allowed either. Object types specify
    both the names of required properties and the types those properties are expected
    to be. If an object’s property doesn’t match, TypeScript will report a type error.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间不允许类型不匹配。对象类型同时指定必需属性的名称和这些属性预期的类型。如果对象的属性不匹配，TypeScript将报告类型错误。
- en: 'The following `TimeRange` type expects the `start` member to be of type `Date`.
    The `hasStartString` object is causing a type error because its `start` is type
    `string` instead:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`TimeRange`类型期望`start`成员为`Date`类型。`hasStartString`对象引起类型错误，因为其`start`类型为`string`：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Excess Property Checking
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过量属性检查
- en: Typescript will report a type error if a variable is declared with an object
    type and its initial value has more fields than its type describes. Therefore,
    declaring a variable to be of an object type is a way of getting the type checker
    to make sure it has only the expected fields on that type.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript会在变量声明为对象类型并且其初始值的字段数超过其描述的类型时报告类型错误。因此，声明变量为对象类型是让类型检查器确保该类型仅具有预期字段的一种方式。
- en: 'The following `poetMatch` variable has exactly the fields described in the
    object type aliased by `Poet`, while `extraProperty` causes a type error for having
    an extra property:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`poetMatch`变量具有恰好与由`Poet`别名的对象类型描述的字段，而`extraProperty`因具有额外属性而导致类型错误：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that excess property checks only trigger for object literals being created
    in locations that are declared to be an object type. Providing an existing object
    literal bypasses excess property checks.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，多余属性检查仅在被声明为对象类型的位置创建对象文字时触发。提供现有对象文字会绕过多余属性检查。
- en: 'This `extraPropertyButOk` variable does not trigger a type error with the previous
    example’s `Poet` type because its initial value happens to structurally match
    `Poet`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `extraPropertyButOk` 变量不会触发前面示例中的 `Poet` 类型的类型错误，因为其初始值恰好与 `Poet` 结构匹配：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Excess property checks will trigger anywhere a new object is being created in
    a location that expects it to match an object type—which as you’ll see in later
    chapters includes array members, class fields, and function parameters. Banning
    excess properties is another way TypeScript helps make sure your code is clean
    and does what you expect. Excess properties not declared in their object types
    are often either mistyped property names or unused code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 多余属性检查将在任何创建新对象的位置触发，该位置预期该对象与对象类型匹配——正如您将在后面的章节中看到的那样，包括数组成员、类字段和函数参数。禁止多余属性是
    TypeScript 帮助确保代码清洁且符合您期望的另一种方式。未在其对象类型中声明的多余属性通常是拼写错误的属性名称或未使用的代码。
- en: Nested Object Types
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套对象类型
- en: As JavaScript objects can be nested as members of other objects, TypeScript’s
    object types must be able to represent nested object types in the type system.
    The syntax to do so is the same as before but with a `{ ... }` object type instead
    of a primitive name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 对象可以嵌套为其他对象的成员，因此 TypeScript 的对象类型必须能够在类型系统中表示嵌套对象类型。做到这一点的语法与之前相同，但使用
    `{ ... }` 对象类型而不是基本名称。
- en: '`Poem` type is declared to be an object whose `author` property has `firstName:
    string` and `lastName: string`. The `poemMatch` variable is assignable to `Poem`
    because it matches that structure, while `poemMismatch` is not because its `author`
    property includes `name` instead of `firstName` and `lastName`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Poem` 类型被声明为一个对象，其 `author` 属性具有 `firstName: string` 和 `lastName: string`。`poemMatch`
    变量可以分配给 `Poem`，因为它匹配该结构，而 `poemMismatch` 不行，因为其 `author` 属性包含 `name` 而不是 `firstName`
    和 `lastName`：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Another way of writing the `type Poem` would be to extract out the `author`
    property’s shape into its own aliased object type, `Author`. Extracting out nested
    types into their own type aliases also helps TypeScript give more informative
    type error messages. In this case, it can say `''Author''` instead of `''{ firstName:
    string; lastName: string; }''`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种编写`type Poem`的方法是将`author`属性的形状提取为其自己的别名对象类型`Author`。将嵌套类型提取为它们自己的类型别名也有助于
    TypeScript 提供更具信息性的类型错误消息。在这种情况下，它可以说 `''Author''` 而不是 `''{ firstName: string;
    lastName: string; }''`：'
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: It is generally a good idea to move nested object types into their own type
    name like this, both for more readable code and for more readable TypeScript error
    messages.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好像这样将嵌套对象类型移到它们自己的类型名称中，这样做不仅可以使代码更可读，还可以使 TypeScript 错误消息更易于理解。
- en: You’ll see in later chapters how object type members can be other types such
    as arrays and functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在后面的章节中看到，对象类型成员可以是其他类型，如数组和函数。
- en: Optional Properties
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选属性
- en: Object type properties don’t all have to be required in the object. You can
    include a `?` before the `:` in a type property’s type annotation to indicate
    that it’s an optional property.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对象类型属性并不都必须在对象中是必需的。您可以在类型属性的类型注释中的`:`之前包含`?`来指示它是一个可选属性。
- en: 'This `Book` type requires only a `pages` property and optionally allows an
    `author`. Objects adhering to it may provide `author` or leave it out as long
    as they provide `pages`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `Book` 类型仅需要一个 `pages` 属性，并可选允许一个 `author`。符合此类型的对象可以提供 `author` 或将其省略，只要它们提供
    `pages`：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Keep in mind there is a difference between optional properties and properties
    whose type happens to include `undefined` in a type union. A property declared
    as optional with `?` is allowed to not exist. A property declared as required
    and `| undefined` must exist, even if the value is `undefined`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，可选属性和类型联合中包含 `undefined` 的属性之间存在差异。用 `?` 声明的可选属性允许不存在。用 `| undefined` 声明为必需的属性必须存在，即使值为
    `undefined`。
- en: 'The `editor` property in the following `Writers` type may be skipped in declaring
    variables because it has a `?` in its declaration. The `author` property does
    not have a `?`, so it must exist, even if its value is just `undefined`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下 `Writers` 类型中，`editor` 属性可以在声明变量时被省略，因为在其声明中有 `?`。`author` 属性没有 `?`，因此它必须存在，即使其值只是
    `undefined`：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[Chapter 7, “Interfaces”](ch07.xhtml#interfaces) will cover more on other kinds
    of properties, while [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options)
    will describe TypeScript’s strictness settings around optional properties.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Unions of Object Types
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is reasonable in TypeScript code to want to be able to describe a type that
    can be one or more different object types that have slightly different properties.
    Furthermore, your code might want to be able to type narrow between those object
    types based on the value of a property.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Inferred Object-Type Unions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a variable is given an initial value that could be one of multiple object
    types, TypeScript will infer its type to be a union of object types. That union
    type will have a constituent for each of the possible object shapes. Each of the
    possible properties on the type will be present in each of those constituents,
    though they’ll be `?` optional types on any type that doesn’t have an initial
    value for them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'This `poem` value always has a `name` property of type `string`, and may or
    may not have `pages` and `rhymes` properties:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Explicit Object-Type Unions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alternately, you can be more explicit about your object types by being explicit
    with your own union of object types. Doing so requires writing a bit more code
    but comes with the advantage of giving you more control over your object types.
    Most notably, if a value’s type is a union of object types, TypeScript’s type
    system will only allow access to properties that exist on all of those union types.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'This version of the previous `poem` variable is explicitly typed to be a union
    type that always has the `always` property along with either `pages` or `rhymes`.
    Accessing `names` is allowed because it always exists, but `pages` and `rhymes`
    aren’t guaranteed to exist:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Restricting access to potentially nonexistent members of objects can be a good
    thing for code safety. If a value might be one of multiple types, properties that
    don’t exist on all of those types aren’t guaranteed to exist on the object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Just as how unions of literal and/or primitive types must be type narrowed to
    access properties that don’t exist on all type constituents, you’ll need to narrow
    those object type unions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing Object Types
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the type checker sees that an area of code can only be run if a union typed
    value contains a certain property, it will narrow the value’s type to only the
    constituents that contain that property. In other words, TypeScript’s type narrowing
    will apply to objects if you check their shape in code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing the explicitly typed `poem` example, check whether `"pages" in poem`
    acts as a type guard for TypeScript to indicate that it is a `PoemWithPages`.
    If `poem` is not a `PoemWithPages`, then it must be a `PoemWithRhymes`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that TypeScript won’t allow truthiness existence checks like `if (poem.pages)`.
    Attempting to access a property of an object that might not exist is considered
    a type error, even if used in a way that seems to behave like a type guard:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Discriminated Unions
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another popular form of union typed objects in JavaScript and TypeScript is
    to have a property on the object indicate what shape the object is. This kind
    of type shape is called a *discriminated union*, and the property whose value
    indicates the object’s type is a *discriminant*. TypeScript is able to perform
    type narrowing for code that type guards on discriminant properties.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this `Poem` type describes an object that can be either a new
    `PoemWithPages` type or a new `PoemWithRhymes` type, and the `type` property indicates
    which one. If `poem.type` is `"pages"`, then TypeScript is able to infer that
    the type of `poem` must be `PoemWithPages`. Without that type narrowing, neither
    property is guaranteed to exist on the value:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discriminated unions are my favorite feature in TypeScript because they beautifully
    combine a common elegant JavaScript pattern with TypeScript’s type narrowing.
    [Chapter 10, “Generics”](ch10.xhtml#generics_chapter) and its associated projects
    will show more around using discriminated unions for generic data operations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Intersection Types
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript’s `|` union types represent the type of a value that could be one
    of two or more different types. Just as JavaScript’s runtime `|` operator acts
    as a counterpart to its `&` operator, TypeScript allows representing a type that
    is multiple types at the same time: an `&` *intersection type*. Intersection types
    are typically used with aliased object types to create a new type that combines
    multiple existing object types.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Artwork` and `Writing` types are used to form a combined `WrittenArt`
    type that has the properties `genre`, `name`, and `pages`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Intersection types can be combined with union types, which is sometimes useful
    to describe discriminated unions in one type.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ShortPoem` type always has an `author` property, then is also a discriminated
    union on a `type` property:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Dangers of Intersection Types
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Intersection types are a useful concept, but it’s easy to use them in ways that
    confuse either yourself or the TypeScript compiler. I recommend trying to keep
    code as simple as possible when using them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Long assignability errors
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Assignability error messages from TypeScript get much harder to read when you
    create complex intersection types, such as one combined with a union type. This
    will be a common theme with TypeScript’s type system (and typed programming languages
    in general): the more complex you get, the harder it will be to understand messages
    from the type checker.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the previous code snippet’s `ShortPoem`, it would be much more
    readable to split the type into a series of aliased object types to allow TypeScript
    to print those names:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: never
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Intersection types are also easy to misuse and create an impossible type with.
    Primitive types cannot be joined together as constituents in an intersection type
    because it’s impossible for a value to be multiple primitives at the same time.
    Trying to `&` two primitive types together will result in the *never* type, represented
    by the keyword `never`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `never` keyword and type is what programming languages refer to as a *bottom
    type*, or empty type. A bottom type is one that can have no possible values and
    can’t be reached. No types can be provided to a location whose type is a bottom
    type:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Most TypeScript projects rarely—if ever—use the `never` type. It comes up once
    in a while to represent impossible states in code. Most of the time, though, it’s
    likely to be a mistake from misusing intersection types. I’ll cover it more in
    [Chapter 15, “Type Operations”](ch15.xhtml#type_operations).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you expanded your grasp of the TypeScript type system to be
    able to work with objects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: How TypeScript interprets types from object type literals
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing object literal types, including nested and optional properties
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring, inferring, and type narrowing with unions of object literal types
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discriminated unions and discriminants
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining object types together with intersection types
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/objects*](https://learningtypescript.com/objects).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: How does a lawyer declare their TypeScript type?
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “I object!”
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
