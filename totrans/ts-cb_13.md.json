["```\nconst defaultOptions = {\n  from: \"./src\",\n  to: \"./dest\",\n};\n\nfunction copy(options) {\n  // Let's merge default options and options\n  const allOptions = { ...defaultOptions, ...options};\n\n  // todo: Implementation of the rest\n}\n```", "```\ntype Options = {\n  from: string;\n  to: string;\n};\n\nconst defaultOptions: Options = {\n  from: \"./src\",\n  to: \"./dest\",\n};\n\ntype PartialOptions = {\n  from?: string;\n  to?: string;\n};\n\nfunction copy(options: PartialOptions) {\n  // Let's merge default options and options\n  const allOptions = { ...defaultOptions, ...options};\n\n  // todo: Implementation of the rest\n}\n```", "```\ntype Options = {\n  from: string;\n  to: string;\n  overwrite: boolean; // added\n};\n\nconst defaultOptions: Options = {\n  from: \"./src\",\n  to: \"./dest\",\n  overwrite: true, // added\n};\n\ntype PartialOptions = {\n  from?: string;\n  to?: string;\n  overwrite?: boolean; // added\n};\n```", "```\nconst defaultOptions = {\n  from: \"./src\",\n  to: \"./dest\",\n  overwrite: true,\n};\n\nfunction copy(options: Partial<typeof defaultOptions>) {\n  // Let's merge default options and options\n  const allOptions = { ...defaultOptions, ...options};\n\n  // todo: Implementation of the rest\n}\n```", "```\napp.get(\"/api/users/:userID\", function (req, res) {\n  if (req.method === \"POST\") {\n    res.status(20).send({\n      message: \"Got you, user \" + req.params.userId,\n    });\n  }\n});\n```", "```\napp.get(\"/api/users/:userID\", function (req, res) {\n  if (req.method === \"POST\") { /* Error 1 */\n    res.status(20).send({ /* Error 2 */\n      message: \"Welcome, user \" + req.params.userId /* Error 3 */,\n    });\n  }\n});\n```", "```\nconst app = {\n  get /* post, put, delete, ... to come! */,\n};\n\nfunction get(path: string, callback: CallbackFn) {\n  // to be implemented --> not important right now\n}\n```", "```\ntype CallbackFn = (req: ServerRequest, reply: ServerReply) => void;\n```", "```\ntype ServerRequest = {\n  method: string;\n  params: Record<string, string>;\n};\n```", "```\ntype ServerReply = {\n  send: (obj?: any) => void;\n  status: (statusCode: number) => ServerReply;\n};\n```", "```\napp.get(\"/api/users/:userID\", function(req, res) {\n  if(req.method === 2) {\n//   ^ This condition will always return 'false' since the types\n//     'string' and 'number' have no overlap.(2367)\n\n    res.status(\"200\").send()\n//             ^\n// Argument of type 'string' is not assignable to\n// parameter of type 'number'.(2345)\n  }\n});\n```", "```\ntype Methods = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\n\ntype ServerRequest = {\n  method: Methods;\n  params: Record<string, string>;\n};\n```", "```\ntype StatusCode =\n  100 | 101 | 102 | 200 | 201 | 202 | 203 | 204 | 205 |\n  206 | 207 | 208 | 226 | 300 | 301 | 302 | 303 | 304 |\n  305 | 306 | 307 | 308 | 400 | 401 | 402 | 403 | 404 |\n  405 | 406 | 407 | 408 | 409 | 410 | 411 | 412 | 413 |\n  414 | 415 | 416 | 417 | 418 | 420 | 422 | 423 | 424 |\n  425 | 426 | 428 | 429 | 431 | 444 | 449 | 450 | 451 |\n  499 | 500 | 501 | 502 | 503 | 504 | 505 | 506 | 507 |\n  508 | 509 | 510 | 511 | 598 | 599;\n\ntype ServerReply = {\n  send: (obj?: any) => void;\n  status: (statusCode: StatusCode) => ServerReply;\n};\n```", "```\napp.get(\"/api/user/:userID\", (req, res) => {\n if(req.method === \"POS\") {\n//   ^ This condition will always return 'false' since\n//     the types 'Methods' and '\"POS\"' have no overlap.(2367)\n    res.status(20)\n//             ^\n//  Argument of type '20' is not assignable to parameter of\n//  type 'StatusCode'.(2345)\n }\n})\n```", "```\ntype ServerRequest<Met extends Methods> = {\n  method: Met;\n  params: Record<string, string>;\n};\n```", "```\ntype OnlyGET = ServerRequest<\"GET\">;\ntype OnlyPOST = ServerRequest<\"POST\">;\ntype POSTorPUT = ServerRquest<\"POST\" | \"PUT\">;\n```", "```\ntype CallbackFn<Met extends Methods> = (\n  req: ServerRequest<Met>,\n  reply: ServerReply\n) => void;\n\nfunction get(path: string, callback: CallbackFn<\"GET\">) {\n  // to be implemented\n}\n```", "```\napp.get(\"/api/users/:userID\", function (req, res) {\n  req.method; // can only be GET\n});\n```", "```\nconst handler: CallbackFn<\"PUT\" | \"POST\"> = function(res, req) {\n  res.method // can be \"POST\" or \"PUT\"\n};\n\nconst handlerForAllMethods: CallbackFn<Methods> = function(res, req) {\n  res.method // can be all methods\n};\n\napp.get(\"/api\", handler);\n//              ^\n// Argument of type 'CallbackFn<\"POST\" | \"PUT\">' is not\n// assignable to parameter of type 'CallbackFn<\"GET\">'.\n\napp.get(\"/api\", handlerForAllMethods); // This works\n```", "```\ntype ServerRequest<Met extends Methods, Par extends string = string> = {\n  method: Met;\n  params: Record<Par, string>;\n};\n```", "```\n// request.method = \"GET\"\n// request.params = {\n//   userID: string\n// }\ntype WithUserID = ServerRequest<\"GET\", \"userID\">;\n```", "```\nfunction get<Par extends string = string>(\n  path: string,\n  callback: CallbackFn<\"GET\", Par>\n) {\n  // to be implemented\n}\n\nconst app = {\n  get /* post, put, delete, ... to come! */,\n};\n\ntype CallbackFn<Met extends Methods, Par extends string> = (\n  req: ServerRequest<Met, Par>,\n  reply: ServerReply\n) => void;\n```", "```\napp.get<\"userID\">(\"/api/users/:userID\", function (req, res) {\n  req.params.userID; // Works!!\n  req.params.anythingElse; // doesn't work!!\n});\n```", "```\ntype IncludesRouteParams<Par extends string> =\n  | `${string}/:${Par}`\n  | `${string}/:${Par}/${string}`;\n```", "```\nconst a: IncludesRouteParams<\"userID\"> = \"/api/user/:userID\"; // works\nconst b: IncludesRouteParams<\"userID\"> = \"/api/user/:userID/orders\"; // works\nconst c: IncludesRouteParams<\"userID\"> = \"/api/user/:userId\"; // breaks\nconst d: IncludesRouteParams<\"userID\"> = \"/api/user\"; // breaks\nconst e: IncludesRouteParams<\"userID\"> = \"/api/user/:userIDAndmore\"; // breaks\n```", "```\nfunction get<Par extends string = string>(\n  path: IncludesRouteParams<Par>,\n  callback: CallbackFn<\"GET\", Par>\n) {\n  // to be implemented\n}\n\napp.get<\"userID\">(\n  \"/api/users/:userID\",\n  function (req, res) {\n    req.params.userID; // Yes!\n  }\n);\n```", "```\nfunction get<Path extends string = string>(\n  path: Path,\n  callback: CallbackFn<\"GET\", ParseRouteParams<Path>>\n) {\n  // to be implemented\n}\n```", "```\ntype ParseRouteParams<Route> =\n  Route extends `${string}/:${infer P}`\n  ? P\n  : never;\n```", "```\ntype Params = ParseRouteParams<\"/api/user/:userID\">; // Params is \"userID\"\n\ntype NoParams = ParseRouteParams<\"/api/user\">; // NoParams is never: no params!\n```", "```\ntype ParseRouteParams<Route> = Route extends `${string}/:${infer P}/${infer R}`\n  ? P | ParseRouteParams<`/${R}`>\n  : Route extends `${string}/:${infer P}`\n  ? P\n  : never;\n```", "```\n// Params is \"userID\"\ntype Params = ParseRouteParams<\"/api/user/:userID\">;\n\n// MoreParams is \"userID\" | \"orderID\"\ntype MoreParams = ParseRouteParams<\"/api/user/:userID/orders/:orderId\">;\n```", "```\napp.get(\"/api/users/:userID/orders/:orderID\", function (req, res) {\n  req.params.userID; // Works\n  req.params.orderID; // Also available\n});\n```", "```\napp.get(\"/api/users/:userID\", function(req, res) {\n  if (req.method === \"POST\") {\n//   ^ This condition will always return 'false' since\n//     the types 'Methods' and '\"POST\"' have no overlap.(2367)\n    res.status(20).send({\n//             ^\n//  Argument of type '20' is not assignable to parameter of\n//  type 'StatusCode'.(2345)\n      message: \"Welcome, user \" + req.params.userId\n//                                           ^\n//    Property 'userId' does not exist on type\n//    '{ userID: string; }'. Did you mean 'userID'?\n    });\n  }\n});\n```", "```\ntype Messages =\n  | \"CHANNEL_OPEN\"\n  | \"CHANNEL_CLOSE\"\n  | \"CHANNEL_FAIL\"\n  | \"MESSAGE_CHANNEL_OPEN\"\n  | \"MESSAGE_CHANNEL_CLOSE\"\n  | \"MESSAGE_CHANNEL_FAIL\";\n\ntype ChannelDefinition = {\n  [key: string]: {\n    open: Messages;\n    close: Messages;\n    fail: Messages;\n  };\n};\n```", "```\nconst impl: ChannelDefinition = {\n  test: {\n    open: 'CHANNEL_OPEN',\n    close: 'CHANNEL_CLOSE',\n    fail: 'CHANNEL_FAIL'\n  },\n  message: {\n    open: 'MESSAGE_CHANNEL_OPEN',\n    close: 'MESSAGE_CHANNEL_CLOSE',\n    fail: 'MESSAGE_CHANNEL_FAIL'\n  }\n}\n```", "```\nfunction openChannel(\n  def: ChannelDefinition,\n  channel: keyof ChannelDefinition\n) {\n  // to be implemented\n}\n```", "```\n// Passes, even though \"massage\" is not part of impl\nopenChannel(impl, \"massage\");\n```", "```\nfunction openChannel<\n  T extends ChannelDefinition\n>(def: T, channel: keyof T) {\n  // to be implemented\n}\n```", "```\nconst impl = {\n  test: {\n    open: \"CHANNEL_OPEN\",\n    close: \"CHANNEL_CLOSE\",\n    fail: \"CHANNEL_FAIL\",\n  },\n  message: {\n    open: \"MESSAGE_CHANNEL_OPEN\",\n    close: \"MESSAGE_CHANNEL_CLOSE\",\n    fail: \"MESSAGE_CHANNEL_FAIL\",\n  },\n} as const;\n```", "```\n/// typeof impl\n{\n  test: {\n    open: string;\n    close: string;\n    fail: string;\n  };\n  message: {\n    open: string;\n    close: string;\n    fail: string;\n  };\n}\n```", "```\n/// typeof impl\n{\n  test: {\n    readonly open: \"CHANNEL_OPEN\";\n    readonly close: \"CHANNEL_CLOSE\";\n    readonly fail: \"CHANNEL_FAIL\";\n  };\n  message: {\n    readonly open: \"MESSAGE_CHANNEL_OPEN\";\n    readonly close: \"MESSAGE_CHANNEL_CLOSE\";\n    readonly fail: \"MESSAGE_CHANNEL_FAIL\";\n  };\n}\n```", "```\nopenChannel(impl, \"message\"); // satisfies contract\nopenChannel(impl, \"massage\");\n//                 ^\n// Argument of type '\"massage\"' is not assignable to parameter\n// of type '\"test\" | \"message\"'.(2345)\n```", "```\nconst impl = {\n  test: {\n    open: \"CHANNEL_OPEN\",\n    close: \"CHANNEL_CLOSE\",\n    fail: \"CHANNEL_FAIL\",\n  },\n  message: {\n    open: \"MESSAGE_CHANNEL_OPEN\",\n    close: \"MESSAGE_CHANNEL_CLOSE\",\n    fail: \"MESSAGE_CHANNEL_FAIL\",\n  },\n} satisfies ChannelDefinition;\n\nfunction openChannel<T extends ChannelDefinition>(\n  def: T,\n  channel: keyof T\n) {\n  // to be implemented\n}\n```", "```\nimpl.test.close = \"CHANEL_CLOSE_MASSAGE\";\n//                 ^\n// Type '\"CHANEL_CLOSE_MASSAGE\"' is not assignable\n// to type '\"CHANNEL_CLOSE\"'.(2322)\n```", "```\nexport type Expect<T extends true> = T;\nexport type ExpectTrue<T extends true> = T;\nexport type ExpectFalse<T extends false> = T;\nexport type IsTrue<T extends true> = T;\nexport type IsFalse<T extends false> = T;\n```", "```\nexport type Equal<X, Y> =\n  (<T>() => T extends X ? 1 : 2) extends\n  (<T>() => T extends Y ? 1 : 2) ? true : false;\nexport type NotEqual<X, Y> = true extends Equal<X, Y> ? false : true;\n```", "```\nexport type IsAny<T> = 0 extends 1 & T ? true : false;\nexport type NotAny<T> = true extends IsAny<T> ? false : true;\n```", "```\nexport type Debug<T> = { [K in keyof T]: T[K] };\nexport type MergeInsertions<T> = T extends object\n  ? { [K in keyof T]: MergeInsertions<T[K]> }\n  : T;\n\nexport type Alike<X, Y> = Equal<MergeInsertions<X>, MergeInsertions<Y>>;\n```", "```\nexport type ExpectExtends<VALUE, EXPECTED> = EXPECTED extends VALUE\n  ? true\n  : false;\nexport type ExpectValidArgs<\n  FUNC extends (...args: any[]) => any,\n  ARGS extends any[]\n> = ARGS extends Parameters<FUNC> ? true : false;\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n  profession?: string | undefined;\n  status: \"active\" | \"inactive\" | \"registered\";\n};\n\ntype Results = {\n  entries: Person[]\n};\n```", "```\nimport { z } from \"zod\";\n\nconst Person = z.object({\n  name: z.string(),\n  age: z.number().min(0).max(150),\n  profession: z.string().optional(),\n  status: z.union([\n    z.literal(\"active\"),\n    z.literal(\"inactive\"),\n    z.literal(\"registered\"),\n  ]),\n});\n\nconst Results = z.object({\n  entries: z.array(Person),\n});\n```", "```\ntype PersonType = z.infer<typeof Person>;\ntype ResultType = z.infer<typeof Results>;\n```", "```\ntype ResultType = z.infer<typeof Results>;\n\nasync function fetchData(): Promise<ResultType> {\n  const data = await fetch(\"/api/persons\").then((res) => res.json());\n  return Results.parse(data);\n}\n```", "```\nfetchData()\n  .then((res) => {\n    // do something with results\n  })\n  .catch((e) => {\n    // a potential zod error!\n  });\n\n// or\n\ntry {\n  const res = await fetchData();\n  // do something with results\n} catch (e) {\n  // a potential zod error!\n}\n```", "```\nasync function fetchData(): Promise<ResultType> {\n  const data = await fetch(\"/api/persons\").then((res) => res.json());\n  const results = Results.safeParse(data);\n  if (results.success) {\n    return results.data;\n  } else {\n    // Depending on your application, you might want to have a\n    // more sophisticated way of error handling than returning\n    // an empty result.\n    return { entries: [] };\n  }\n}\n```", "```\nconst Person = z.object({\n  name: z.string(),\n  age: z.number().min(0).max(150),\n  profession: z.string().optional(),\n  status: z\n    .union([\n      z.literal(\"active\"),\n      z.literal(\"inactive\"),\n      z.literal(\"registered\"),\n    ])\n    .transform((val) => {\n      if (val === \"registered\") {\n        return \"active\";\n      }\n      return val;\n    }),\n});\n```", "```\ntype PersonTypeIn = z.input<typeof Person>;\n/*\ntype PersonTypeIn = {\n name: string;\n age: number;\n profession?: string | undefined;\n status: \"active\" | \"inactive\" | \"registered\";\n};\n*/\n\ntype PersonTypeOut = z.output<typeof Person>;\n/*\ntype PersonTypeOut = {\n name: string;\n age: number;\n profession?: string | undefined;\n status: \"active\" | \"inactive\";\n};\n*/\n```", "```\nlet person = {\n  name: \"Stefan\",\n  age: 39,\n};\n\ntype Person = typeof person;\n\nlet anotherPerson: Person = {\n  name: \"Not Stefan\",\n  age: 20,\n};\n\nfunction update(key: keyof Person) {\n  person[key] = anotherPerson[key];\n//^ Type 'string | number' is not assignable to type 'never'.\n//  Type 'string' is not assignable to type 'never'.(2322)\n}\n\nupdate(\"age\");\n```", "```\nfunction updateAmbiguous(key: keyof Person, value: Person[keyof Person]) {\n  //...\n}\n\nupdateAmbiguous(\"age\", \"Stefan\");\n```", "```\ntype Switch = {\n  address: number,\n  on: 0 | 1\n};\n\ndeclare const switcher: Switch;\ndeclare const key: keyof Switch;\n```", "```\nswitcher[key] = 1; // This works\nswitcher[key] = 2; // Error\n// ^ Type '2' is not assignable to type '0 | 1'.(2322)\n```", "```\nfunction update<K extends keyof Person>(key: K) {\n  person[key] = anotherPerson[key]; // works\n}\n\nupdate(\"age\");\n```", "```\nupdate<\"age\" | \"name\">(\"age\");\n```", "```\nfunction concat(arr1, arr2) {\n  return [...arr1, ...arr2];\n}\n```", "```\n// 7 overloads for an empty second array\nfunction concat(arr1: [], arr2: []): [];\nfunction concat<A>(arr1: [A], arr2: []): [A];\nfunction concat<A, B>(arr1: [A, B], arr2: []): [A, B];\nfunction concat<A, B, C>(arr1: [A, B, C], arr2: []): [A, B, C];\nfunction concat<A, B, C, D>(arr1: [A, B, C, D], arr2: []): [A, B, C, D];\nfunction concat<A, B, C, D, E>(\n  arr1: [A, B, C, D, E],\n  arr2: []\n): [A, B, C, D, E];\nfunction concat<A, B, C, D, E, F>(\n  arr1: [A, B, C, D, E, F],\n  arr2: []\n): [A, B, C, D, E, F];\n// 7 more for arr2 having one element\nfunction concat<A2>(arr1: [], arr2: [A2]): [A2];\nfunction concat<A1, A2>(arr1: [A1], arr2: [A2]): [A1, A2];\nfunction concat<A1, B1, A2>(arr1: [A1, B1], arr2: [A2]): [A1, B1, A2];\nfunction concat<A1, B1, C1, A2>(\n  arr1: [A1, B1, C1],\n  arr2: [A2]\n): [A1, B1, C1, A2];\nfunction concat<A1, B1, C1, D1, A2>(\n  arr1: [A1, B1, C1, D1],\n  arr2: [A2]\n): [A1, B1, C1, D1, A2];\nfunction concat<A1, B1, C1, D1, E1, A2>(\n  arr1: [A1, B1, C1, D1, E1],\n  arr2: [A2]\n): [A1, B1, C1, D1, E1, A2];\nfunction concat<A1, B1, C1, D1, E1, F1, A2>(\n  arr1: [A1, B1, C1, D1, E1, F1],\n  arr2: [A2]\n): [A1, B1, C1, D1, E1, F1, A2];\n// and so on, and so forth\n```", "```\ntype Arr = readonly any[];\n\nfunction concat<T extends Arr, U extends Arr>(arr1: T, arr2: U): [...T, ...U] {\n  return [...arr1, ...arr2];\n}\n```", "```\nfunction fetchOrder(customer: Customer): Order[]\nfunction fetchOrder(product: Product): Order[]\nfunction fetchOrder(orderId: number): Order\n// the implementation\nfunction fetchOrder(param: any): Order | Order[] {\n  //...\n}\n```", "```\nfunction fetchOrder(customer: Customer): Order[]\nfunction fetchOrder(product: Product): Order[]\nfunction fetchOrder(orderId: number): Order\nfunction fetchOrder(param: Customer | Product): Order[]\nfunction fetchOrder(param: Customer | number): Order | Order[]\nfunction fetchOrder(param: number | Product): Order | Order[]\n// the implementation\nfunction fetchOrder(param: any): Order | Order[] {\n  //...\n}\n```", "```\ntype FetchParams = number | Customer | Product;\n\ntype FetchReturn<T> = T extends Customer\n  ? Order[]\n  : T extends Product\n  ? Order[]\n  : T extends number\n  ? Order\n  : never;\n\nfunction fetchOrder<T extends FetchParams>(params: T): FetchReturn<T> {\n  //...\n}\n```", "```\n// => (1)\ntype SearchArguments =\n  // Argument list one: a query and a callback\n  | [query: string, callback: (results: unknown[]) => void]\n  // Argument list two:: just a query\n  | [query: string];\n\n// A conditional type picking either void or a Promise depending\n// on the input => (2)\ntype ReturnSearch<T> = T extends [query: string]\n  ? Promise<Array<unknown>>\n  : void;\n\n// the actual function => (3)\ndeclare function search<T extends SearchArguments>(...args: T): ReturnSearch<T>;\n\n// z is void\nconst z = search(\"omikron\", (res) => {});\n\n// y is Promise<unknown>\nconst y = search(\"omikron\");\n```", "```\nfunction search(query: string): Promise<unknown[]>;\nfunction search(query: string, callback: (result: unknown[]) => void): void;\n// This is the implementation, it only concerns you\nfunction search(\n  query: string,\n  callback?: (result: unknown[]) => void\n): void | Promise<unknown> {\n  // Implement\n}\n```", "```\n// All the possible event handlers\ntype Handler =\n  | MouseEventHandler<HTMLButtonElement>\n  | KeyboardEventHandler<HTMLButtonElement>;\n\n// Map Handler to Event\ntype Ev<T> = T extends MouseEventHandler<infer R>\n  ? MouseEvent<R>\n  : T extends KeyboardEventHandler<infer R>\n  ? KeyboardEvent<R>\n  : never;\n\n// Create a\nfunction apply<T extends Handler>(handler: T, ev: Ev<T>): void {\n  handler(ev as any); // We need the assertion here\n}\n```", "```\ndeclare const mouseHandler: MouseEventHandler<HTMLButtonElement>;\ndeclare const mouseEv: MouseEvent<HTMLButtonElement>;\ndeclare const keyboardHandler: KeyboardEventHandler<HTMLButtonElement>;\ndeclare const keyboardEv: KeyboardEvent<HTMLButtonElement>;\n\napply(mouseHandler, mouseEv); // works\napply(keyboardHandler, keyboardEv); // woirks\napply(mouseHandler, keyboardEv); // breaks like it should!\n//                  ^\n// Argument of type 'KeyboardEvent<HTMLButtonElement>' is not assignable\n// to parameter of type 'MouseEvent<HTMLButtonElement, MouseEvent>'\n```", "```\ndeclare const mouseOrKeyboardHandler:\n  MouseEventHandler<HTMLButtonElement> |\n  KeyboardEventHandler<HTMLButtonElement>;;\n\n// This is accepted but can cause problems!\napply(mouseOrKeyboardHandler, mouseEv);\n```", "```\n// Overload 1: MouseEventHandler and MouseEvent\nfunction apply(\n  handler: MouseEventHandler<HTMLButtonElement>,\n  ev: MouseEvent<HTMLButtonElement>\n): void;\n// Overload 2: KeyboardEventHandler and KeyboardEvent\nfunction apply(\n  handler: KeyboardEventHandler<HTMLButtonElement>,\n  ev: KeyboardEvent<HTMLButtonElement>\n): void;\n// The implementation. Fall back to any. This is not a type!\n// TypeScript won't check for this line nor\n// will it show in the autocomplete.\n// This is just for you to implement your stuff.\nfunction apply(handler: any, ev: any): void {\n  handler(ev);\n}\n```", "```\napply(mouseHandler, mouseEv); // works!\napply(keyboardHandler, keyboardEv); // works!\napply(mouseHandler, keyboardEv); // breaks like it should!\n// ^ No overload matches this call.\napply(mouseOrKeyboardHandler, mouseEv); // breaks like it should\n// ^ No overload matches this call.\n```", "```\nfunction createLabel<T extends number | string | StringLabel | NumberLabel>(\n  input: T\n): GetLabel<T>;\nfunction createLabel(\n  input: number | string | StringLabel | NumberLabel\n): NumberLabel | StringLabel {\n  if (typeof input === \"number\") {\n    return { id: input };\n  } else if (typeof input === \"string\") {\n    return { name: input };\n  } else if (\"id\" in input) {\n    return { id: input.id };\n  } else {\n    return { name: input.name };\n  }\n}\n```", "```\ntype ParseRouteParameters<T> =\n  T extends `${string}/:${infer U}/${infer R}` ?\n    { [P in U | keyof ParseRouteParameters<`/${R}`>]: string } :\n  T extends `${string}/:${infer U}` ?\n    { [P in U]: string } : {}\n\ntype X = ParseRouteParameters<\"/api/:what/:is/notyou/:happening\">\n// type X = {\n//   what: string,\n//   is: string,\n//   happening: string,\n// }\n```", "```\ntype Foo<T extends string> = ...\n```", "```\ntype Foo<T extends string = \"hello\"> = ...\n```", "```\ntype Extract<From, Union> = ...\n```", "```\ntype ParseRouteParams<Route> =\n  Route extends `${string}/:${infer Param}/${infer Rest}` ?\n    { [Entry in Param | keyof ParseRouteParameters<`/${Rest}`>]: string } :\n  Route extends `${string}/:${infer Param}` ?\n    { [Entry in Param]: string } : {}\n```", "```\ntype ParseRouteParameters<TRoute> =\n  Route extends `${string}/:${infer TParam}/${infer TRest}` ?\n    { [TEntry in TParam | keyof ParseRouteParameters<`/${TRest}`>]: string } :\n  Route extends `${string}/:${infer TParam}` ?\n    { [TEntry in TParam]: string } : {}\n```", "```\n// @strictPropertyInitialization: false\n// @target: esnext\n// @module: nodenext\n// @lib: es2015,dom\n```", "```\nimport { render } from \"preact\"; // types: legacy\n```", "```\n// @jsxFactory: h\nimport { render, h } from \"preact\";\n\nfunction Heading() {\n    return <h1>Hello</h1>\n}\n\nconst elem = <Heading/>\n//    ^?\n// This line above triggers inline hints\n```", "```\nexport const a = 2;\n\n// @filename: a.ts\n\nimport { a } from \"./input.js\"\nconsole.log(a);\n```", "```\nimport { Connector } from \"lib\";\n\n// This exists in version 1\nconst connector = new Connector();\nconst connection = connector.connect(\"127.0.0.1:4000\");\n\nconnection.send(\"Hi!\");\n\n// This exists in version 2\nconnection.close();\n```", "```\n{\n  \"compilerOptions\": {\n    // ...\n    \"typeRoots\": [\n      \"@types\"\n    ],\n    \"rootDir\": \"./src\",\n    \"outDir\": \"dist\",\n  },\n  \"include\": [\"./src\", \"./@types\"]\n}\n```", "```\ndeclare module \"lib\" {\n  export interface ConnectorConstructor {\n    new (): Connector;\n  }\n  var Connector: ConnectorConstructor;\n\n  export interface Connector {\n    connect(stream: string): Connection;\n  }\n\n  export interface Connection {\n    send(msg: string): Connection;\n  }\n}\n```", "```\nexport interface ConnectorConstructor {\n  new (): Connector;\n}\nvar Connector: ConnectorConstructor;\n```", "```\n/// <reference path=\"lib.v1.d.ts\" />\n\ndeclare module \"lib\" {\n  export interface Connection {\n    close(): void;\n  }\n}\n```", "```\n/// <reference path=\"../@lib/lib.v2.d.ts\" />\n\ndeclare module \"lib\" {}\n```"]