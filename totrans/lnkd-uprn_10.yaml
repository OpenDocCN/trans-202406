- en: Chapter 10\. Observing Your Platform with Linkerd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the challenges of working with microservices applications is monitoring
    them. When dealing with multiple development teams, even in a single language,
    understanding which workloads are communicating and surfacing useful metrics from
    those communications can be a huge challenge. Every developer, language, and framework
    will prioritize different details, and organizations need a single way to view
    all those different services.
  prefs: []
  type: TYPE_NORMAL
- en: '*Observability* refers to this ability to understand a system by looking at
    it from the outside. An application can be more or less observable, so when we
    talk about observability in Linkerd we’re referring to how it impacts the observability
    of your applications. In this chapter, we’ll look at how Linkerd increases observability
    by providing all your apps with standard metrics, allowing you to see the relationships
    between your microservices, and allowing you to intercept and analyze interapp
    communications.'
  prefs: []
  type: TYPE_NORMAL
- en: Why Do We Need This?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with application security, microservices present new challenges for platform
    engineers. The ability to dynamically scale components, create and update services
    on demand, and dynamically provision infrastructure increases the difficulty of
    understanding the health of our applications. As your organization builds out
    your platform for application developers, it’s important that you make it easy
    for teams to do the right thing.
  prefs: []
  type: TYPE_NORMAL
- en: How Does Linkerd Help?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linkerd helps make observability part of your platform. When you add a workload
    to the mesh, it begins to automatically surface important information about that
    workload’s behavior. That means that when we add Linkerd to our platform, we make
    it easy for all our application teams to do the right thing in terms of observability.
    If you allow your application to join the mesh, you can automatically surface
    performance, health, and relationship data about your app in a standard way. If
    you go deeper and build service profiles, you can save and share critical information
    about the individual routes within your apps.
  prefs: []
  type: TYPE_NORMAL
- en: As we go through this chapter, we’ll explore how to observe your applications
    with Linkerd using the `linkerd` CLI. Everything we cover via the CLI can also
    be surfaced via the Linkerd Viz dashboard. We’ll cover the dashboard near the
    end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned in [Chapter 1](ch01.html#LUAR_service_mesh_101), there are
    three golden metrics that have repeatedly proven critical for understanding what’s
    going on in a microservices application: traffic, success rate, and latency (see
    [Figure 1-8](ch01.html#golden-metrics)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a microservices application, having these metrics available for every workload
    is critical: with just these golden metrics, you should be able to understand
    how well a given workload is performing as well as what areas of your system need
    special attention or optimization.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linkerd proxy automatically collects detailed metrics from every workload
    and request and makes them available via Prometheus, so that you can surface this
    information within your organization using a variety of widely available tools.
  prefs: []
  type: TYPE_NORMAL
- en: Observability in Linkerd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ll use the booksapp and emojivoto applications to demonstrate observability
    in Linkerd. Both of these applications deliberately include various failures:
    we’ll use Linkerd observability tools to find where, exactly, the failures are.
    (Fixing them is left as an exercise for the reader!)'
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Your Cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll need a cluster with Linkerd and Linkerd Viz already installed (please
    refer to [Chapter 3](ch03.html#LUAR_deploying_linkerd) if you want a refresher
    on setting up such a cluster). We’ll start by cloning the [booksapp sample application](https://oreil.ly/LJou0)
    and [emojivoto sample application](https://oreil.ly/0n5Gd) repositories, as shown
    in [Example 10-1](#EX12-clone), since we’ll need the repositories to appropriately
    profile these sample applications.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-1\. Cloning the repos
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can get the applications up and running in our cluster, as shown in
    [Example 10-2](#EX12-install-apps).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2\. Setting up our apps
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once our check returns healthy, we can start looking at our applications using
    the `linkerd viz` command, as shown in [Example 10-3](#EX12-linkerd-viz-basics).
    Note that it may take a minute or so for Linkerd Viz to start showing any data,
    since it has to start by collecting enough data to generate statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3\. Gathering application metrics
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can immediately see just from these basic queries that the emojivoto and
    book⁠sapp applications are both having reliability issues. In the following sections,
    we’ll dive deeper into our applications to isolate the source of the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Tap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linkerd Viz Tap allows authorized users to collect metadata about the requests
    flowing between your applications. It will surface details about request headers,
    URIs, response codes, and more, permitting you to access this data on demand for
    debugging, as shown in [Example 10-4](#EX12-basic-tap-command). Tap also provides
    convenient tooling for validating the TLS status of your interapp connections.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4\. Viewing Tap data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `linkerd viz tap` command will run until you send it the break signal. It
    displays live data from the proxy, which will give details about the individual
    requests that go to and from the web deployment. Each line will show the source
    and destination details, TLS status, any status information, and other metadata
    as available.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Tap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tap is built into the Linkerd Viz extension, so it will be automatically installed
    by the `linkerd viz install` command. However, if any of your workloads were running
    before you installed Viz, you’ll need to restart those workloads before Tap will
    be available.
  prefs: []
  type: TYPE_NORMAL
- en: Tap data is a powerful diagnostic tool that can provide insights into how exactly
    your apps are communicating with one another. If Tap is enabled when you view
    a workload in the Linkerd Viz dashboard, it will automatically display a summary
    of requests. Be sure to try to view the Tap data for emojivoto’s workloads when
    you look at the Viz dashboard later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Service Profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linkerd *service profiles*, embodied by the ServiceProfile resource, allow you
    to give the mesh detailed information about how a given workload is used. At its
    most basic level, a ServiceProfile defines what routes are allowed for a workload.
    Once routes are defined, you can configure per-route metrics, timeouts, and retries,
    as well as which HTTP statuses will be considered failures.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceProfile and HTTPRoute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linkerd project is in the midst of a transition to fully adopting [Gateway
    API](https://oreil.ly/Onjs9). As the project works toward that objective, you’ll
    see a few Linkerd custom resources, including ServiceProfile, begin to be deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: In Linkerd 2.13 and 2.14, ServiceProfile and HTTPRoute often have mutually exclusive
    functionality, which makes it particularly important to review the [ServiceProfile
    documentation](https://oreil.ly/zJk_j) to verify the current state of ServiceProfile
    as you begin using these resources in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: You can build out ServiceProfiles in a number of ways. The most flexible way
    is to write them by hand, but the Linkerd CLI provides a few different ways to
    generate them automatically, as you’ll see in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring routes for emojivoto
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The emojivoto application has three workloads:'
  prefs: []
  type: TYPE_NORMAL
- en: The `emoji` and `voting` workloads use gRPC for communication, with their gRPC
    messages defined in protobuf files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `web` workload uses HTTP to interact with a web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll start with `emoji` and `voting`, since they have *protobuf* files. Protobuf
    files work as a guide to our APIs, and they can be consumed by the Linkerd CLI
    to automatically create ServiceProfiles, as shown in [Example 10-5](#EX12-protobuf-to-serviceprofile).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-5\. Creating ServiceProfiles from protobuf files
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Storing Linkerd Viz Metrics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you’ve created ServiceProfiles for your applications, Linkerd’s Viz extension
    will store that data in Prometheus. A very important part of taking Linkerd to
    production is planning how you’ll manage this Prometheus data in the long term.
    The Prometheus component that ships with Linkerd Viz is *not* sufficient for long-term
    data collection: it stores data in memory, and it *will* lose data every time
    it restarts.'
  prefs: []
  type: TYPE_NORMAL
- en: With our routes created for `emoji` and `voting`, we have two-thirds of our
    application covered with ServiceProfiles. That leaves the `web` component. Although
    we know this must speak HTTP because we talk to it with a browser, unfortunately
    the authors of this component didn’t actually write any API documentation for
    it at all. This leaves us to figure out how to build a ServiceProfile with no
    information about how the API is structured.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we can use Linkerd’s Tap functionality to do just that, as shown
    in [Example 10-6](#EX12-tap-serviceprofiles).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-6\. Creating ServiceProfiles with Tap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Linkerd Default Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linkerd’s ServiceProfile objects are intended to define an entire API, but
    what happens when we make a mistake, or when an API changes without the profiles
    being updated? That’s where the default route comes in: any route that isn’t explicitly
    defined in a ServiceProfile is treated as a default route.'
  prefs: []
  type: TYPE_NORMAL
- en: Default routes are subject to default policies regarding retries and timeouts.
    Data about traffic on default routes is aggregated into the catchall `[DEFAULT]`
    route entry.
  prefs: []
  type: TYPE_NORMAL
- en: Building routes for booksapp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’re finished with the emojivoto application, we need to set things
    up for the booksapp application.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas emojivoto included protobuf files for some of its APIs, booksapp ships
    with OpenAPI definitions instead. Like protobuf files, OpenAPI definitions (often
    called “Swagger definitions,” after an earlier version of the standard) serve
    as definitions of how to use the API, and Linkerd knows how to read them to create
    ServiceProfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a ServiceProfile with an OpenAPI or Swagger definition is almost exactly
    like creating a ServiceProfile from a protobuf file, as shown in [Example 10-7](#EX12-openapi-to-serviceprofile).
    Please be sure to follow along, as we’ll be using these ServiceProfiles again
    in [Chapter 11](ch11.html#LUAR_reliability)!
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-7\. Creating ServiceProfiles with OpenAPI definitions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Topology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With routes, metrics, and Tap data, we have a lot of useful ways to understand
    what our apps are doing without requiring developers to include instrumentation
    in their applications. Another common challenge is figuring out which of all these
    possible calls are actually happening in the application, and from which workload
    to which workload. Linkerd can also surface that information for you.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 10-8](#EX12-viewing-edges), we’ll examine the relationships between
    the components of the booksapp application. You can, and should, try to explore
    emojivoto on your own.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-8\. Viewing edges in Linkerd
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is broken up into five columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SRC`'
  prefs: []
  type: TYPE_NORMAL
- en: The source of the traffic
  prefs: []
  type: TYPE_NORMAL
- en: '`DST`'
  prefs: []
  type: TYPE_NORMAL
- en: The destination of the traffic
  prefs: []
  type: TYPE_NORMAL
- en: '`SRC_NS`'
  prefs: []
  type: TYPE_NORMAL
- en: The namespace where the traffic originated
  prefs: []
  type: TYPE_NORMAL
- en: '`DST_NS`'
  prefs: []
  type: TYPE_NORMAL
- en: The namespace where the traffic went
  prefs: []
  type: TYPE_NORMAL
- en: '`SECURED`'
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not the traffic is encrypted via Linkerd’s mTLS
  prefs: []
  type: TYPE_NORMAL
- en: The resulting output gives you an overview of the relationships between the
    book⁠sapp components. It shows that the Prometheus instance in the `linkerd-viz`
    namespace is talking to each deployment in the `booksapp` namespace. Beyond that,
    we can see that `traffic` talks to `webapp`, `webapp` talks to `books` and `authors`,
    and `books` and `authors` talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: The `linkerd viz edges` command will work for Pods or any other workload type
    within Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd Viz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve likely noticed that a number of the commands we used in this chapter
    were `linkerd viz` commands. This is the Linkerd Viz extension that we introduced
    back in [Chapter 2](ch02.html#LUAR_intro_to_linkerd). It ships with the core Linkerd
    system because it’s often extremely useful, but it was split out from the core
    into an extension in Linkerd 2.10, so that not everyone is forced to run it.
  prefs: []
  type: TYPE_NORMAL
- en: The Viz extension provides a great many CLI tools for observing your Linkerd
    installation, along with a web-based dashboard that provides a graphical interface
    for exploring your Linkerd environment.
  prefs: []
  type: TYPE_NORMAL
- en: Protecting the Viz Dashboard Is Up to You
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in [Chapter 2](ch02.html#LUAR_intro_to_linkerd), there’s no user
    authentication built into the Linkerd Viz dashboard. You’ll need to tackle that
    using an API gateway or the like if you want to expose Linkerd Viz to the network—or,
    alternatively, leave the dashboard inaccessible from outside the cluster, and
    simply use the `linkerd viz dashboard` CLI command to bring up the dashboard in
    a web browser, via a port forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to open the Viz dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now explore it on your own. Try to find the per-namespace and per-workload metrics.
    Also take a look at an individual namespace, like `emojivoto`, and explore the
    topology.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd’s Viz dashboard includes Prometheus and can easily work with Grafana,
    as shown in [Example 10-9](#EX12-production-prometheus). As we’ve said a few times
    before, it’s *critical* to realize that the default Linkerd Viz install will create
    an in-memory Prometheus instance that is *only* viable for demo purposes, and
    *must not* be relied upon for production use. We recommend you use a separate
    Prometheus instance for collecting your Linkerd metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Linkerd and Grafana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier versions of Linkerd, `linkerd viz install` automatically installed
    Grafana. As of Linkerd 2.12, Grafana licensing changes mean that we’re no longer
    allowed to do that. Grafana still works beautifully with Linkerd Viz, but for
    Linkerd 2.12 and later you need to install it by hand and configure it to talk
    to the same Prometheus that Linkerd Viz uses.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-9\. Production-ready Linkerd Viz install
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Audit Trails and Access Logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hardening our environments against intrusion doesn’t end at reducing the risk
    and impact of an incident. Having a strong security posture also means being able
    to rapidly detect when something abnormal has occurred and providing data that
    allows your security team to understand exactly what you have in place. For Linkerd,
    much of this data is contained in the system logs of the control plane containers,
    accessible via `kubectl log`. It’s definitely worth ensuring that you have a strategy
    for collecting and analyzing log messages that is accessible to your security
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond normal log messages and events, some users need a detailed history of
    all the HTTP requests that transit the proxy. This requires *access logging*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Access Logging: The Good, the Bad, and the Ugly'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Access logging in Linkerd means the proxy will write a log message for every
    HTTP request it processes. In an environment where you have a number of services
    talking to each other, that can very quickly turn into a huge volume of log messages,
    so it’s definitely worth checking the [official Linkerd docs](https://oreil.ly/zEFj_)
    before you implement access logging. We will go into the high-level concepts and
    practical steps, but the logs are an area where things can change between versions
    of Linkerd, so be sure to test your setup after looking over the docs.
  prefs: []
  type: TYPE_NORMAL
- en: The good
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Access logging will give you hugely detailed information about the interactions
    between your applications. It is configurable; you can emit the messages in either
    `apache` or `json` format so that they’re easier to consume programmatically.
    With access logging enabled, your security teams will have tremendous amounts
    of data to help them understand the impact and extent of any security incident.
  prefs: []
  type: TYPE_NORMAL
- en: The bad
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storing and processing these logs is expensive, requires significant engineering
    overhead, and uses up significant resources in your cluster. Your platform or
    security teams will need to manage log aggregation tooling and log collection
    agents on your clusters. Access logging will increase the costs of running your
    platform.
  prefs: []
  type: TYPE_NORMAL
- en: The ugly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP access logging is disabled by default in Linkerd because it has a performance
    impact on the proxies in terms of both CPU and latency. That means your application
    response times and compute costs will increase when you enable it. To what extent
    will depend very much on your level and type of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Access Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can set the access logging configuration at the workload, namespace, or
    Pod level. In any case, you’ll need to set the following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After it’s set, you need to restart the targeted workloads to begin collecting
    logs.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you test the performance impacts of enabling access logging
    in your application before rolling it out to production. That will give your organization
    the data it needs to make an informed decision about access logging in Linkerd.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Observability in Linkerd ranges from simple metrics to access logging. Linkerd
    allows us to understand the behavior, performance, and characteristics of our
    apps without requiring application developers to make any modifications. The power
    of a service mesh lies in allowing the platform team to provide observability
    to app teams as a feature of the platform. It also ensures that all apps can be
    understood and compared in a uniform fashion.
  prefs: []
  type: TYPE_NORMAL
