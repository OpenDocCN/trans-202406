<html><head></head><body><section data-pdf-bookmark="Chapter 2. Views" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_views">&#13;
<h1><span class="label">Chapter 2. </span>Views</h1>&#13;
&#13;
&#13;
<p>In<a data-primary="views" data-secondary="purpose of" data-type="indexterm" id="idm46177243918952"/> most graphical UI (GUI) frameworks, visual elements on the screen are represented by objects generally called “views” in architectural parlance. In web applications, a view might be an HTML element, but in some web frameworks a view is an entire web page, or a fragment of a page. Java Swing, and a number of other frameworks, use “components” to represent the view portion of the application.</p>&#13;
&#13;
<p>In native mobile development, a view is exactly that—an instance of a <code>View</code> (Android) or <code>UIView</code> (iOS) subclass.</p>&#13;
&#13;
<p>Views can be atomic elements and represent a single visual element on a screen, like a piece of text or an image, but might also be a more complicated hierarchy of views for layout, like a list of rows, or even more sophisticated, like a calendar widget with significant, sophisticated behavior built into the view itself.</p>&#13;
&#13;
<p>Views are also necessary to receive user input. Buttons, switches and toggles, checkboxes, select boxes, and text inputs are all examples of views that enable your user to interact with your app.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177243914616">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="views" data-secondary="task overview" data-type="indexterm" id="idm46177243913288"/> this chapter, you’ll learn to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Create a new view.</p>&#13;
</li>&#13;
<li>&#13;
<p>Nest views.</p>&#13;
</li>&#13;
<li>&#13;
<p>Update a view’s state.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177243908824">&#13;
<h1>Android</h1>&#13;
&#13;
<p>In<a data-primary="Android" data-secondary="views" data-tertiary="View base class" data-type="indexterm" id="idm46177243907384"/><a data-primary="views" data-secondary="Android" data-tertiary="View base class" data-type="indexterm" id="idm46177243905768"/> Android, the base class is <code>View</code>, and it is <em>not</em> <code>abstract</code>—you can instantiate a simple <code>View</code> where needed, although it may not be that common. One example is that sometimes simple <code>View</code> instances are used as lines or shapes, by simply providing dimensions and a background color, or as hit areas without visual representation. Some common examples of actual android <code>View</code> subclasses are <code>TextView</code>, <code>ImageView</code>, <code>Button</code>, and <code>EditText</code>.</p>&#13;
&#13;
<p>A base <code>View</code> cannot contain another <code>View</code>, but a <code>ViewGroup</code> can (a <code>ViewGroup</code> is a subclass of <code>View</code>, so it is a <code>View</code> itself). There are a number of <code>ViewGroup</code> classes in the framework library that are intended for layout purposes only: <code>LinearLayout</code>, <code>FrameLayout</code>, <code>ConstraintLayout</code>, and many others. Most of your layout needs can be accomplished using these prepackaged <code>ViewGroup</code> subclasses, but since these classes are pure Java, you’re free to subclass <code>ViewGroup</code> and define your own logic; I do so very commonly.</p>&#13;
&#13;
<p>Other <code>ViewGroup</code> subclasses that aren’t strictly for layout include <code>ScrollView</code>, <code>RecyclerView</code>, <code>Spinner</code>, and <code>ViewPager</code>. Each of these components provides a great deal of functionality beyond displaying and laying out content—for example, the <code>RecyclerView</code> manages a scrolling list of items that are removed from the screen (and memory) when they’re off screen, and “recycled” (thus the name) when new items are scrolled into view. These are informally known as “widgets” in the Android ecosystem (not to be confused with device homescreen Widgets).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create a New View" data-type="sect2"><div class="sect2" id="idm46177243890488">&#13;
<h2>Create a New View</h2>&#13;
&#13;
<p><code>View</code> classes<a data-primary="Android" data-secondary="views" data-tertiary="creating new" data-type="indexterm" id="AVnew02"/><a data-primary="views" data-secondary="Android" data-tertiary="creating new" data-type="indexterm" id="VAnew02"/><a data-primary="Java" data-secondary="creating new view" data-type="indexterm" id="idm46177243884264"/><a data-primary="Kotlin" data-secondary="views" data-tertiary="creating new view" data-type="indexterm" id="idm46177243883320"/> can be constructed just like any other object instance by using the <code>new</code> keyword and the <code>View</code> subclass’s constructor in Java, or just invoking the class’s constructor when using Kotlin. In most cases, this will require at least a <code>Context</code> parameters, and possibly more:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177243880568">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">TextView</code> <code class="n">textView</code> <code class="o">=</code> <code class="k">new</code> <code class="n">TextView</code><code class="o">(</code><code class="n">context</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">textView</code> <code class="p">=</code> <code class="n">TextView</code><code class="p">(</code><code class="n">context</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>A more common way to create a <code>View</code>, and generally an entire hierarchy of nested <code>View</code> and <code>ViewGroup</code> instances, is to inflate an XML “layout.” “Inflate” simply means to parse the XML and its instructions and either add that view tree to an existing UI or simply return it.</p>&#13;
&#13;
<p>XML layouts in Android follow traditional XML rules, with a couple conventions you should be aware of.</p>&#13;
&#13;
<p>The XML declaration is optional, but recommended:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code></pre>&#13;
&#13;
<p>After that, the XML must have a <em>single</em> root node. This is almost always a <code>ViewGroup</code> (for a view tree) or a single <code>View</code> that represents the entire contents of the layout. I say “almost” because there are advanced mechanisms like the <code>merge</code> tag; this is not technically a <code>View</code> but provides an instruction to return the contents of the node.</p>&#13;
&#13;
<p>For example, you might have a view tree like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;LinearLayout...&gt;</code>&#13;
  <code class="nt">&lt;android.support.design.widget.AppBarLayout...&gt;</code>&#13;
    <code class="nt">&lt;android.support.v7.widget.Toolbar...</code> <code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;/android.support.design.widget.AppBarLayout&gt;</code>&#13;
  <code class="nt">&lt;FrameLayout...&gt;</code>&#13;
  <code class="nt">&lt;/FrameLayout&gt;</code>&#13;
<code class="nt">&lt;/LinearLayout&gt;</code></pre>&#13;
&#13;
<p>Or, your layout might be a single <code>View</code>, like so:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;TextView...</code> <code class="nt">/&gt;</code></pre>&#13;
&#13;
<p>Layout files are stored in the <em>res/layout/</em> folder and must follow the standard Android resource naming scheme (alphanumeric characters and underscores only). This folder is processed at compile time to make references to each layout a symbol that points to a numeric ID. It’s not critical to understand exactly how that happens right now; just know that if you save you layout file as <em>res/layout/my_activity.xml</em>, it will be available on the global <code>R</code> static configuration object as <code>R.layout.my_activity</code>, which is appropriate and available to pass to any method expecting a resource ID.</p>&#13;
&#13;
<p>Back to those conventions we mentioned earlier. Android packages a lot of functionality into the inflation process, but you’ll need to use their namespace to take advantage of that. This is simple enough: include a namespace attribute on the root node that points to the Android schema: <em>http://schemas.android.com/apk/res/android</em>. This namespace can be anything you’d like, but convention is to call it “android,” like so:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;LinearLayout</code>&#13;
  <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
  <code class="err">...</code><code class="nt">&gt;</code></pre>&#13;
&#13;
<p>Once that’s established, you can access Android framework properties by appending the property with that namespace, as seen in the following:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;LinearLayout</code>&#13;
  <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
  <code class="err">...</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;TextView</code>&#13;
    <code class="na">android:text=</code><code class="s">"Hello world!"</code>&#13;
    <code class="err">...</code><code class="nt">&gt;</code></pre>&#13;
&#13;
<p>With that namespace set up, when the framework inflates your XML to create a <span class="keep-together"><code>LinearLayout</code></span> with a <code>TextView</code> in it, the <code>TextView</code> will have its <code>text</code> property set to “Hello World!” (which will render on the screen in the system’s font, color, and size).</p>&#13;
&#13;
<p>Note that you’ll probably never see it, but it’s perfectly acceptable to use your own name for the namespace, simply by specifying it in the layout file:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;LinearLayout</code>&#13;
  <code class="na">xmlns:bob=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
  <code class="na">bob:layout_width=</code><code class="s">"match_parent"</code>&#13;
  <code class="na">bob:layout_height=</code><code class="s">"wrap_content"</code><code class="nt">&gt;</code>&#13;
&#13;
  <code class="nt">&lt;TextView</code>&#13;
    <code class="na">bob:text=</code><code class="s">"Hello world!"</code>&#13;
    <code class="na">bob:layout_width=</code><code class="s">"wrap_content"</code>&#13;
    <code class="na">bob:layout_height=</code><code class="s">"wrap_content"</code> <code class="nt">/&gt;</code>&#13;
&#13;
<code class="nt">&lt;/LinearLayout&gt;</code></pre>&#13;
&#13;
<p>Another important namespace to include is the “auto” namespace, which is required when using your own custom components, as well as when using certain support components. This must point to <em>http://schemas.android.com/apk/res-auto</em> and is generally named “app” (but again, any name that follows the XML format for a namespace name is acceptable):</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;LinearLayout</code>&#13;
  <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
  <code class="na">xmlns:app=</code><code class="s">"http://schemas.android.com/apk/res-auto"</code>&#13;
  <code class="err">...</code><code class="nt">&gt;</code></pre>&#13;
&#13;
<p>With those two namespaces on your root node, you should be ready to handle pretty much any XML layout functionality.</p>&#13;
&#13;
<p>As you write this, you might notice that all Android <code>Views</code> require a <code>layout_width</code> and <code>layout_height</code> property (which, in your namespaced XML, will look like <code>android:layout_width="100dp"</code>). This is not required for programmatically instantiated <code>Views</code>, which will always use the constant <code>WRAP_CONTENT</code> flag to indicate they should consume whatever size they require to display their content.</p>&#13;
&#13;
<p>The acceptable values are any dimensional value (<code>100dp</code>, <code>100px</code>, or <code>100sp</code>) or a few predefined constants: <code>LayoutParams.WRAP_CONTENT</code> and <code>LayoutParams.MATCH_PARENT</code>. The former is pretty self-explanatory—if you have a <code>TextView</code> with “Hello World” and both dimensions set to <code>WRAP_CONTENT</code>, the <code>TextView</code> will take as much space as is required to render those glyphs. <code>MATCH_PARENT</code> means the <code>View</code> will try to fill all the available space within its parent, along that dimension.</p>&#13;
&#13;
<p>So a final, workable layout file might look like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;LinearLayout</code>&#13;
    <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
    <code class="na">xmlns:app=</code><code class="s">"http://schemas.android.com/apk/res-auto"</code>&#13;
    <code class="na">android:layout_width=</code><code class="s">"match_parent"</code>&#13;
    <code class="na">android:layout_height=</code><code class="s">"match_parent"</code>&#13;
    <code class="na">android:orientation=</code><code class="s">"vertical"</code><code class="nt">&gt;</code>&#13;
&#13;
  <code class="nt">&lt;android.support.design.widget.AppBarLayout</code>&#13;
    <code class="na">android:layout_width=</code><code class="s">"match_parent"</code>&#13;
    <code class="na">android:layout_height=</code><code class="s">"wrap_content"</code><code class="nt">&gt;</code>&#13;
&#13;
    <code class="nt">&lt;android.support.v7.widget.Toolbar</code>&#13;
      <code class="na">android:layout_width=</code><code class="s">"match_parent"</code>&#13;
      <code class="na">android:layout_height=</code><code class="s">"wrap_content"</code>&#13;
      <code class="na">app:navigationIcon=</code><code class="s">"?attr/homeAsUpIndicator"</code> <code class="nt">/&gt;</code>&#13;
&#13;
  <code class="nt">&lt;/android.support.design.widget.AppBarLayout&gt;</code>&#13;
&#13;
  <code class="nt">&lt;FrameLayout</code>&#13;
      <code class="na">android:layout_width=</code><code class="s">"match_parent"</code>&#13;
      <code class="na">android:layout_height=</code><code class="s">"0dp"</code>&#13;
      <code class="na">android:layout_weight=</code><code class="s">"1"</code><code class="nt">&gt;</code>&#13;
  <code class="nt">&lt;/FrameLayout&gt;</code>&#13;
&#13;
<code class="nt">&lt;/LinearLayout&gt;</code></pre>&#13;
&#13;
<p>A quick note about this code: it’s common to want to have one element (in this case, the <code>AppBarLayout</code> containing the <code>Toolbar</code>) take up as much room as it needs and have another element fill up the rest (maybe a <code>LinearLayout</code> or <code>ScrollView</code>). In this case, a <code>FrameLayout</code> that will serve as a container for dynamically added and removed <code>Views</code> will consume whatever space is available within its parent.</p>&#13;
&#13;
<p>You might think to do this with <code>MATCH_PARENT</code> on the <code>FrameLayout</code>, but the parent is actually as tall as the screen (assuming this is a root view), so the <code>FrameLayout</code> would clip along the bottom of the screen by an amount equal to the height of the <code>Toolbar</code>. This trick with <code>LinearLayout</code> solves this common issue: set the dimension of the variable-sized <code>View</code> to <code>WRAP_CONTENT</code>; then for the <code>View</code> that should expand to fill <span class="keep-together">the remainder</span> of the space in the parent, set that dimension to <code>0dp</code> but add a <code>layout_weight</code> of <code>1</code> (or anything, really). Layout weight tells the <code>LinearLayout</code> what percentage of available space to apportion to a <code>View</code>.</p>&#13;
&#13;
<p>We finally have a usable layout in the resources file, precompiled and ready to go. How do we use it? There are a few ways, some of which we touched on in <a data-type="xref" href="ch01.html#topics_ui_controllers">Chapter 1</a> on UI controllers. For now, let’s concentrate on a couple common approaches, and explore a couple that are less common.</p>&#13;
&#13;
<p>One<a data-primary="Java" data-secondary="views" data-tertiary="layout access" data-type="indexterm" id="idm46177243456808"/><a data-primary="Kotlin" data-secondary="views" data-tertiary="layout access" data-type="indexterm" id="idm46177243455528"/> strategy would be to set the layout as the root view of your <code>Activity</code>. Simply call <code>Activity.setContentView</code> and pass the resource ID of your layout. In this example:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177243453224">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyActivity</code> <code class="kd">extends</code> <code class="n">Activity</code> <code class="o">{</code>&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">protected</code> <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">Bundle</code> <code class="n">savedInstanceState</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kd">super</code><code class="o">.</code><code class="na">onCreate</code><code class="o">(</code><code class="n">savedInstanceState</code><code class="o">);</code>&#13;
    <code class="n">setContentView</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">layout</code><code class="o">.</code><code class="na">my_activity</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyActivity</code> <code class="p">:</code> <code class="n">Activity</code><code class="p">()</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code>&#13;
    <code class="n">setContentView</code><code class="p">(</code><code class="n">R</code><code class="p">.</code><code class="n">layout</code><code class="p">.</code><code class="n">my_activity</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>That’s it! When <code>MyActivity</code> starts, you’ll immediately see the view tree described in the layout XML file.</p>&#13;
&#13;
<p>Another strategy would be to add your content to an existing view tree. If you’ve already set up a view tree in any other way, you can add or remove <code>View</code> instances using <code>ViewGroup</code> methods pretty easily, for example, <code>ViewGroup.addView</code> and <code>ViewGroup.removeView</code>. This works great for programmatically created views, but we can get access to layout inflation explicitly as well. There’s<a data-primary="Java" data-secondary="views" data-tertiary="layout inflation" data-type="indexterm" id="idm46177243331672"/><a data-primary="Kotlin" data-secondary="views" data-tertiary="layout inflation" data-type="indexterm" id="idm46177243330424"/> a system service that will do that for us, and there are two identical ways to get a reference to that service:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177243328952">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">LayoutInflater</code> <code class="n">inflater</code> <code class="o">=</code> <code class="o">(</code><code class="n">LayoutInflater</code><code class="o">)</code> <code class="n">context</code><code class="o">.</code><code class="na">getSystemService</code><code class="o">(</code>&#13;
<code class="n">Context</code><code class="o">.</code><code class="na">LAYOUT_INFLATER_SERVICE</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">inflater</code> <code class="p">=</code> <code class="n">context</code><code class="p">.</code><code class="n">getSystemService</code><code class="p">(</code>&#13;
<code class="n">Context</code><code class="p">.</code><code class="n">LAYOUT_INFLATER_SERVICE</code><code class="p">)</code> <code class="k">as</code> <code class="n">LayoutInflater</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Alternatively:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177243275096">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">LayoutInflater</code> <code class="n">inflater</code> <code class="o">=</code> <code class="n">LayoutInflater</code><code class="o">.</code><code class="na">from</code><code class="o">(</code><code class="n">context</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">inflater</code> <code class="p">=</code> <code class="n">LayoutInflater</code><code class="p">.</code><code class="n">from</code><code class="p">(</code><code class="n">context</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Once you have a reference on an inflater instance, you can call the <code>inflate</code> method directly. One option is to append the inflated <code>Views</code> to another <code>ViewGroup</code> passed as a parameter:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177243212840">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">inflater</code><code class="o">.</code><code class="na">inflate</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">layout</code><code class="o">.</code><code class="na">my_activity</code><code class="o">,</code> <code class="n">someViewGroup</code><code class="o">,</code> <code class="kc">true</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">inflater</code><code class="p">.</code><code class="n">inflate</code><code class="p">(</code><code class="n">R</code><code class="p">.</code><code class="n">layout</code><code class="p">.</code><code class="n">my_activity</code><code class="p">,</code> <code class="n">someViewGroup</code><code class="p">,</code> <code class="k">true</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>This signature will automatically add the inflated view tree to the second parameter, <code>someViewGroup</code>, and return that same root (<code>someViewGroup</code>). Alternatively, you can call it without a root:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177243143800">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">inflater</code><code class="o">.</code><code class="na">inflate</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">layout</code><code class="o">.</code><code class="na">my_activity</code><code class="o">,</code> <code class="kc">null</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">inflater</code><code class="p">.</code><code class="n">inflate</code><code class="p">(</code><code class="n">R</code><code class="p">.</code><code class="n">layout</code><code class="p">.</code><code class="n">my_activity</code><code class="p">,</code> <code class="k">null</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>The benefit to this version is that the view tree that was inflated is returned directly and does not need to be added to an existing view tree immediately.</p>&#13;
&#13;
<p>In addition, when using a <code>Fragment</code> (also covered in <a data-type="xref" href="ch01.html#topics_ui_controllers">Chapter 1</a>), your <code>Fragment</code> instances will want to return a <code>View</code> instance from its <code>onCreateView</code> callback (which is automatically called when the <code>Fragment</code> is created). Also, view manager classes like <code>RecyclerView</code> and <code>ViewPager</code> will provide hooks that should return (or decorate) a <code>View</code> as the needs of the display change (by scrolling or paging).<a data-primary="" data-startref="VAnew02" data-type="indexterm" id="idm46177243100824"/><a data-primary="" data-startref="AVnew02" data-type="indexterm" id="idm46177243099848"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Nesting Views" data-type="sect2"><div class="sect2" id="idm46177243096488">&#13;
<h2>Nesting Views</h2>&#13;
&#13;
<p>Any<a data-primary="views" data-secondary="Android" data-tertiary="nesting views" data-type="indexterm" id="idm46177243040248"/><a data-primary="Android" data-secondary="views" data-tertiary="nesting views" data-type="indexterm" id="idm46177243038968"/> <code>ViewGroup</code> can have any number of child <code>View</code> instances. Those children will be displayed within the containing <code>ViewGroup</code>, so if the container is removed or hidden, the children will also be removed or hidden.</p>&#13;
&#13;
<p>Child views will be positioned within the parent <code>ViewGroup</code> depending on the explicit layout logic of the <code>ViewGroup</code>. A <code>LinearLayout</code>, for example, will arrange its children in vertical or horizontal order, based on the size of each child, while a <code>FrameLayout</code> uses absolute pixel positioning.</p>&#13;
&#13;
<p>A <code>View</code> can be added to a <code>ViewGroup</code> with any of the <code>ViewGroup.addView</code> methods. Signatures exist to accommodate index of insertion and layout instructions. <code>Views</code> can be removed with <code>ViewGroup.removeView</code> method. Remember that <code>ViewGroup</code> instances inherit from <code>View</code>, so one <code>ViewGroup</code> can add or remove another.</p>&#13;
&#13;
<p>This is handled for you in XML layouts. When <code>Views</code> are represented in XML layout files, the parent–child relationship of the XML nodes is reflected in the view tree as well; that’s to say that a <code>LinearLayout</code> node with two <code>TextView</code> child nodes will be inflated to a <code>LinearLayout</code> as a <code>ViewGroup</code> instance with two <code>TextView</code> instances as children. However, it’s still possible to change these relationships with <code>addView</code> and <code>removeView</code> after a layout has been inflated.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Update a View’s State" data-type="sect2"><div class="sect2" id="idm46177243025560">&#13;
<h2>Update a View’s State</h2>&#13;
&#13;
<p>The<a data-primary="views" data-secondary="Android" data-tertiary="updating view state" data-type="indexterm" id="idm46177243023992"/><a data-primary="Android" data-secondary="views" data-tertiary="updating view state" data-type="indexterm" id="idm46177243005976"/> <code>View</code> API offers a number of methods for modifying the <code>View</code>’s visible properties. For example, <code>View.setLeft</code> will update the position of the <code>View</code> relative to its container, while <code>View.setAlpha</code> will adjust the transparency of the <code>View</code>. Very commonly you’ll use <code>setVisibility</code> to show or hide a <code>View</code>. When modifying position, it’s usually advisable to use <code>setTranslationX</code> or <code>setTranslationY</code> rather than <code>setLeft</code>, <code>setTop</code>, <code>setX</code>, or <code>setY</code>.  The translation-based properties are an “offset,” computed on top of whatever normal position is appropriate for the <code>View</code>. For example, if you had a <code>LinearLayout</code> with several rows of thumbnails and labels and called <code>setTop</code> on the second row, the entire flow of the list of rows might be impacted. On the other hand, if you wanted to slide it down briefly to reveal some UI beneath it, you could safely use <code>setTranslationY</code> without affecting the container’s overall layout math.</p>&#13;
&#13;
<p><code>View</code> subclasses are a mixed bag and generally have specific APIs. For example, <code>TextView</code> has methods like <code>setText</code> and <code>setTextSize</code>, while <code>ImageView</code> has <code>setImageBitmap</code> to update the image displayed.</p>&#13;
&#13;
<p>While most <code>View</code> properties can be set initially in XML, you almost always need to update programmatically. The Android framework uses getter and setter methods almost exclusively over direct property assignment. You would always use <span class="keep-together"><code>myView.setVisibility(View.GONE);</code></span> rather than using <code>myView.visibility = View.GONE;</code>. This has a rather long history (and equally long controversy) with the Java community specifically and more generally with any technology with access modifiers (<code>private</code> versus <code>public</code>). The nickel tour is that a bunch of smart people got together some time ago and said, basically, never (or at least, very rarely) use directly assignable properties; use getter and setter methods, so both the authors and consumers of an API could intercept these “events” and add logic before or after a read or write mutated the state of the program.</p>&#13;
&#13;
<p>That said, Kotlin <em>does</em> allow the appearance of direct property assignment:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">myView</code><code class="o">.</code><code class="na">visibility</code> <code class="o">=</code> <code class="n">View</code><code class="o">.</code><code class="na">GONE</code></pre>&#13;
&#13;
<p>But behind the scenes, setter methods are being invoked; indeed, if you add logic in Kotlin to a setter method but then directly assign the property a value as shown in the immediately preceding code block, the logic in the setter <em>will</em> be invoked.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177242985240">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>In iOS, the<a data-primary="views" data-secondary="iOS" data-tertiary="UIView instance" data-type="indexterm" id="idm46177242982536"/><a data-primary="iOS" data-secondary="views" data-tertiary="UIView instance" data-type="indexterm" id="idm46177242981256"/> term “view” typically refers to an instance of <code>UIView</code> or a subclass. Views can be anything displayed on-screen—a label, an image, a map, an inline web browser, and much more! That being said, all views are, in their simplest form, a simple rectangle positioned in the device’s screen at a set of coordinates.</p>&#13;
&#13;
<p>The<a data-primary="UIKit" data-secondary="UIWindow" data-type="indexterm" id="idm46177242978616"/><a data-primary="UIKit" data-secondary="UIViewController" data-type="indexterm" id="idm46177242977608"/><a data-primary="UIKit" data-secondary="UIView" data-type="indexterm" id="idm46177242976664"/><a data-primary="iOS methods" data-secondary="show(_:sender:)" data-type="indexterm" id="idm46177242972120"/> base view that all iOS applications start with is an instance of <code>UIWindow</code>. Every <code>UIViewController</code> has a <code>view</code> property that contains an instance of a <code>UIView</code>. An app’s window has its root view controller’s view nested within it. Changing the topmost presented view controller using segues and calls to <code>show(_:sender:)</code>, in their most basic form, simply swap one <code>UIView</code> (managed by a view controller) with another <code>UIView</code> (managed by another view controller) on the screen.</p>&#13;
&#13;
<p>Given the importance of <code>UIView</code> within iOS, let’s take a look at how to deal with this class.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create a New View" data-type="sect2"><div class="sect2" id="idm46177242966856">&#13;
<h2>Create a New View</h2>&#13;
&#13;
<p>The<a data-primary="views" data-secondary="iOS" data-tertiary="creating new" data-type="indexterm" id="idm46177242965288"/><a data-primary="iOS" data-secondary="views" data-tertiary="creating new" data-type="indexterm" id="idm46177242964008"/> first thing you might want to do is create a new view. In iOS, you do this by calling the initializer for a <code>UIView</code> and passing it a frame where that view will go on-screen like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">aView</code> <code class="p">=</code> <code class="bp">UIView</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="bp">CGRect</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="mf">10.0</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="mf">30.0</code><code class="p">,</code> <code class="n">width</code><code class="p">:</code> <code class="mf">100.0</code><code class="p">,</code> <code class="n">height</code><code class="p">:</code> <code class="mf">50.0</code><code class="p">))</code></pre>&#13;
&#13;
<p>The preceding code creates a view that is 100pt wide and 50pt high; it will be placed 10pt from the left of its containing view and 30pt from the top of its containing view. This is the view’s <code>frame</code>.</p>&#13;
&#13;
<p>Sometimes, you might not know where a view should be placed on the screen when it’s created. It’s possible to instantiate a view without a known frame size by instead passing in a <code>CGRect</code> that has all its values set to <code>0</code>. This is common enough, in fact, that <code>CGRect</code> has a static variable that outputs a zero value rectangle. You can instantiate a view using it as shown here:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">aView</code> <code class="p">=</code> <code class="bp">UIView</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="p">.</code><code class="n">zero</code><code class="p">)</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Frames versus bounds" data-type="sect3"><div class="sect3" id="idm46177242897496">&#13;
<h3>Frames versus bounds</h3>&#13;
&#13;
<p>Work<a data-primary="bounds property" data-type="indexterm" id="idm46177242908104"/> with <code>UIView</code>s long enough, and eventually you encounter the <code>bounds</code> property. This is also a <code>CGRect</code> and is incredibly similar to a view’s <code>frame</code> with an important distinction: a view’s <code>bounds</code> property is a rectangle that expresses its position relative to its <em>own</em> coordinate system, while a view’s <code>frame</code> property is a rectangle that expresses its location relative to its containing view (or “superview”). For example, the view in our first example would output the following for its <code>bounds</code> and <code>frame</code>:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">aView</code> <code class="p">=</code> <code class="bp">UIView</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="bp">CGRect</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="mf">10.0</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="mf">30.0</code><code class="p">,</code> <code class="n">width</code><code class="p">:</code> <code class="mf">100.0</code><code class="p">,</code> <code class="n">height</code><code class="p">:</code> <code class="mf">50.0</code><code class="p">))</code>&#13;
&#13;
<code class="bp">print</code><code class="p">(</code><code class="n">aView</code><code class="p">.</code><code class="n">bounds</code><code class="p">)</code> <code class="c1">// Outputs x: 0.0, y: 0.0, width: 100.0, height: 50.0</code>&#13;
&#13;
<code class="bp">print</code><code class="p">(</code><code class="n">aView</code><code class="p">.</code><code class="n">frame</code><code class="p">)</code> <code class="c1">// Outputs x: 10.0, y: 30.0, width: 100.0, height: 50.0</code></pre>&#13;
&#13;
<p>Notice in this example that the <code>width</code> and <code>height</code> are the same for each property. The difference is that <code>frame</code> contains position information for the view within its superview, while <code>bounds</code> does not.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Storyboards and XIBs" data-type="sect3"><div class="sect3" id="idm46177242807656">&#13;
<h3>Storyboards and XIBs</h3>&#13;
&#13;
<p>So<a data-primary="storyboards" data-secondary="creating new views" data-type="indexterm" id="idm46177242805896"/><a data-primary="XML Interface Builder (XIB)" data-type="indexterm" id="idm46177242804888"/> far, we’ve shown how to initialize a view only programmatically. However, views are often created behind the scenes after being defined within Xcode inside of a storyboard or an XML Interface Builder (XIB).</p>&#13;
&#13;
<p>Storyboard-based views are defined within the context of a view controller directly inside Interface Builder. The view controller’s scene contains one or more views nested and displayed together. Connecting the view to the view controller is done with a special compiler flag, <code>@IBOutlet</code>. This flag indicates that a property of type <code>UIView</code> within a class is eligible to be connected to a view contained within a XIB or storyboard. For example, to create a view controller that has a blue rectangular subview you would first create a view controller with an <code>IBOutlet</code>-flagged property like this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ExampleViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
	<code class="kr">@IBOutlet</code> <code class="kd">var</code> <code class="nv">blueRectangle</code><code class="p">:</code> <code class="bp">UIView</code><code class="p">!</code>&#13;
&#13;
	<code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Next, to link up the view controller with a view, you’d need to do the following:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Create a new view controller scene.</p>&#13;
</li>&#13;
<li>&#13;
<p>Change the view controller’s custom class via the Identity inspector to “ExampleViewController.”</p>&#13;
</li>&#13;
<li>&#13;
<p>Add a view to the scene within the main view and change its background color to blue via the Attributes inspector.</p>&#13;
</li>&#13;
<li>&#13;
<p>Control-click on the view controller and drag from that to the blue rectangle.</p>&#13;
</li>&#13;
<li>&#13;
<p>You should see a pop-up with the eligible Outlets in the view controller listed. Select <code>blueRectangle</code> and your blue rectangle view shown in Interface Builder is now directly linked to the <code>blueRectangle</code> property within your <code>ExampleViewController</code> class.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>XIBs function very similarly. A XIB is essentially equivalent to a single view controller scene within a storyboard, although this an oversimplification. Really, they’re an XML-based format (much like storyboards) used to store information about a view so that it can be created via a GUI instead of only through the code. They predate storyboards and are becoming rarer but are still somewhat commonplace.</p>&#13;
&#13;
<p>Creating a view from a XIB is similar to a storyboard; the work of configuring the view is done via Interface Builder, for example, but a XIB is set up and instantiated in a slightly different way. To create a XIB-based view, you would complete the following steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Create a <code>UIView</code> subclass named “CustomView.”</p>&#13;
</li>&#13;
<li>&#13;
<p>Add a new XIB (<em>CustomView.xib</em>) to your iOS project and set its custom class via the Identity inspector to the class we just created: <code>CustomView</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Inside a view controller, or other object, instantiate the object.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>How do you instantiate the object? You have to reference the XIB and then use that to instantiate the object itself like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">nib</code> <code class="p">=</code> <code class="bp">UINib</code><code class="p">(</code><code class="n">nibName</code><code class="p">:</code> <code class="s">"CustomView"</code><code class="p">,</code> <code class="n">bundle</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nv">view</code> <code class="p">=</code> <code class="n">nib</code><code class="p">.</code><code class="n">instantiate</code><code class="p">(</code><code class="n">withOwner</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">options</code><code class="p">:</code> <code class="kc">nil</code><code class="p">).</code><code class="bp">first</code> <code class="k">as</code><code class="p">?</code> <code class="n">CustomView</code></pre>&#13;
&#13;
<p>Unfortunately, <code>instantiate(withOwner:options:)</code> creates a generic <code>UIView</code> instance, so you have to cast to the intended subclass.</p>&#13;
&#13;
<p>We’ve learned how to create views, but the real power in UIs comes in nesting and composing the views together. Let’s see how to nest a view inside another view.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Nesting Views" data-type="sect2"><div class="sect2" id="idm46177242807000">&#13;
<h2>Nesting Views</h2>&#13;
&#13;
<p>Views<a data-primary="views" data-secondary="iOS" data-tertiary="nesting views" data-type="indexterm" id="idm46177242686664"/><a data-primary="iOS" data-secondary="views" data-tertiary="nesting views" data-type="indexterm" id="idm46177242685384"/> can be created and added to other views, which can hold other views that hold other views and so on and so forth—it truly is <code>UIView</code>s all the way down! Let’s create a view and add it as a child of another view.</p>&#13;
&#13;
<p>The following code block creates a parent view and a child view and then calls <code>addSubview(_:)</code> to add the child view to the parent’s array of subviews:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">parentView</code> <code class="p">=</code> <code class="bp">UIView</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="p">.</code><code class="n">zero</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nv">childView</code> <code class="p">=</code> <code class="bp">UIView</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="p">.</code><code class="n">zero</code><code class="p">)</code>&#13;
&#13;
<code class="n">parentView</code><code class="p">.</code><code class="n">addSubview</code><code class="p">(</code><code class="n">childView</code><code class="p">)</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177242663704">&#13;
<h5>Threading</h5>&#13;
<p>Working<a data-primary="views" data-secondary="iOS" data-tertiary="threading" data-type="indexterm" id="idm46177242622792"/><a data-primary="iOS" data-secondary="views" data-tertiary="threading" data-type="indexterm" id="idm46177242621512"/> on a different thread? Look out! View operations are performed only on the main thread. It’s best to use<a data-primary="Grand Central Dispatch (GCD)" data-type="indexterm" id="idm46177242620040"/> Grand Central Dispatch to dispatch the operation asynchronously like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">DispatchQueue</code><code class="p">.</code><code class="n">main</code><code class="p">.</code><code class="n">async</code> <code class="p">{</code>&#13;
    <code class="c1">// View-related operations go here</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>See <a data-type="xref" href="ch08.html#topics_concurrency">Chapter 8</a> for more information.</p>&#13;
</div></aside>&#13;
&#13;
<p>We’ve added a view, so let’s remove it now! Using the same example, we can have the child remove itself from its parent’s view like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">childView</code><code class="p">.</code><code class="n">removeFromSuperview</code><code class="p">()</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Constraints" data-type="sect3"><div class="sect3" id="idm46177242611080">&#13;
<h3>Constraints</h3>&#13;
&#13;
<p>Eventually<a data-primary="views" data-secondary="iOS" data-tertiary="constraints" data-type="indexterm" id="idm46177242574616"/><a data-primary="iOS" data-secondary="views" data-tertiary="constraints" data-type="indexterm" id="idm46177242573336"/><a data-primary="constraints" data-type="indexterm" id="idm46177242617320"/> you’ll run into an instance where you want a view to resize itself automatically. You do this by providing a set of constraints to a view relative to another view. Let’s say we have a button, a special type of view that can receive events, that we want positioned 16pt from the edge of the screen on either side and 100pt from the top of the screen. We could accomplish this layout using constraints within code like so:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ExampleViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
&#13;
    <code class="c1">// Set up the button whenever the view is loaded</code>&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
        <code class="n">setupButton</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Method that does the actual button setup</code>&#13;
    <code class="kd">func</code> <code class="nf">setupButton</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="c1">// Create a button</code>&#13;
        <code class="kd">let</code> <code class="nv">button</code> <code class="p">=</code> <code class="bp">UIButton</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="p">.</code><code class="n">zero</code><code class="p">)</code>&#13;
        <code class="n">button</code><code class="p">.</code><code class="n">translatesAutoresizingMaskIntoConstraints</code> <code class="p">=</code> <code class="kc">false</code>&#13;
&#13;
        <code class="c1">// Add background color to the button</code>&#13;
        <code class="n">button</code><code class="p">.</code><code class="n">backgroundColor</code> <code class="p">=</code> <code class="p">.</code><code class="n">blue</code>&#13;
&#13;
        <code class="c1">// Add it to the view controller's view</code>&#13;
        <code class="n">view</code><code class="p">.</code><code class="n">addSubview</code><code class="p">(</code><code class="n">button</code><code class="p">)</code>&#13;
&#13;
        <code class="c1">// Add the spacing from the top of the view</code>&#13;
        <code class="n">button</code><code class="p">.</code><code class="n">topAnchor</code><code class="p">.</code><code class="n">constraint</code><code class="p">(</code><code class="n">equalTo</code><code class="p">:</code> <code class="n">view</code><code class="p">.</code><code class="n">topAnchor</code><code class="p">,</code> <code class="n">constant</code><code class="p">:</code> <code class="mf">100.0</code><code class="p">).</code><code class="n">isActive</code> <code class="p">=</code>&#13;
        <code class="kc">true</code>&#13;
&#13;
        <code class="c1">// Add the spacing from the left edge of the view</code>&#13;
        <code class="n">button</code><code class="p">.</code><code class="n">leadingAnchor</code><code class="p">.</code><code class="n">constraint</code><code class="p">(</code><code class="n">equalTo</code><code class="p">:</code> <code class="n">view</code><code class="p">.</code><code class="n">leadingAnchor</code><code class="p">,</code>&#13;
           <code class="n">constant</code><code class="p">:</code> <code class="mf">16.0</code><code class="p">).</code><code class="n">isActive</code> <code class="p">=</code> <code class="kc">true</code>&#13;
&#13;
        <code class="c1">// Add the spacing from the right edge of the view</code>&#13;
        <code class="n">button</code><code class="p">.</code><code class="n">trailingAnchor</code><code class="p">.</code><code class="n">constraint</code><code class="p">(</code><code class="n">equalTo</code><code class="p">:</code> <code class="n">view</code><code class="p">.</code><code class="n">trailingAnchor</code><code class="p">,</code>&#13;
            <code class="n">constant</code><code class="p">:</code> <code class="o">-</code><code class="mf">16.0</code><code class="p">).</code><code class="n">isActive</code> <code class="p">=</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s walk through what’s happening here. First, we’re defining a view controller to hold a button that’s called <code>ExampleViewController</code>; it’s a subclass of <code>UIViewController</code> and, like every view controller, has a subview it manages called <code>view</code>. Within this class, we have a <code>setupButton()</code> method that’s called after the view is loaded to create the button and lay it out within the view. Next, inside of <code>setupButton()</code> we instantiate a button with an empty frame and set <code>translatesAutoresizingMaskIntoConstraints</code> to <code>false</code>.</p>&#13;
&#13;
<p>Looking at the constraints we’re setting, you can see we reference the top anchor of the button (i.e., the top of the button) and set it 100pt from the top anchor of the containing view. We do this with the leading anchor (the left side) and the trailing anchor (the right side) as well, but with a value of <code>16.0</code> instead.</p>&#13;
&#13;
<p>Running this code shows a view that looks something like <a data-type="xref" href="#topics_views_button">Figure 2-1</a>.</p>&#13;
&#13;
<figure class="width-30"><div class="figure" id="topics_views_button">&#13;
<img alt="Button with constraints" src="assets/nmdv_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Button with constraints on iPhone X</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>If you’re creating a view programmatically and adding constraints, you should set <code>translatesAutoresizingMaskIntoConstraints</code> to <code>false</code>. This property disables the system-created autoresizing constraints and allows us to specify our own constraints directly. In fact, it’s good practice to set it to <code>false</code> if you create the view programmatically at all. Not setting it to <code>false</code> often generates frustrating and mysterious view layout issues.</p>&#13;
</div>&#13;
&#13;
<p>Where the power in constraints lies is that this view is 100% resizable based on the constraints defined. So if you were to rotate the device, the button would maintain its spacing relative to the top, left, and right anchor points of the view like in <a data-type="xref" href="#topics_views_button_rotated">Figure 2-2</a>.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="topics_views_button_rotated">&#13;
<img alt="Button with constraints to fit landscape oritentation in iPhone X" src="assets/nmdv_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>Button with constraints that have adapted to fit landscape orientation on iPhone X</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Interface Builder to the Rescue" data-type="sect2"><div class="sect2" id="idm46177242575208">&#13;
<h2>Interface Builder to the Rescue</h2>&#13;
&#13;
<p>While<a data-primary="Interface Builder" data-type="indexterm" id="idm46177242406568"/><a data-primary="views" data-secondary="iOS" data-tertiary="Interface Builder" data-type="indexterm" id="idm46177242405832"/><a data-primary="iOS" data-secondary="views" data-tertiary="Interface Builder" data-type="indexterm" id="idm46177242404616"/><a data-primary="storyboards" data-secondary="constraints" data-type="indexterm" id="idm46177242403400"/> it’s possible to create constraints entirely in code, it quickly becomes complex when views have multiple relationships and behavior based on the size classes of the device. More commonly, constraints are created from within Interface Builder. To re-create the same button, we might follow a process similar to the following:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Open up a storyboard and add a new view controller scene.</p>&#13;
</li>&#13;
<li>&#13;
<p>Change the custom class of the view controller in the Identity inspector to “ExampleViewController.”</p>&#13;
</li>&#13;
<li>&#13;
<p>Add a button to the view controller’s view.</p>&#13;
</li>&#13;
<li>&#13;
<p>Click the Add New Constraints button in the lower-right corner of the storyboard editor.</p>&#13;
</li>&#13;
<li>&#13;
<p>Set the margins within the pop-up that displays to our desired values. In this case, it would be a top value of 100pt with left and right values of 16pt.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Running the code would create a view that looks exactly the same as the one defined in code, but without any of the code.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Auto Layout" data-type="sect3"><div class="sect3" id="idm46177242396040">&#13;
<h3>Auto Layout</h3>&#13;
&#13;
<p>Constraints<a data-primary="Auto Layout" data-type="indexterm" id="idm46177242394712"/><a data-primary="views" data-secondary="iOS" data-tertiary="Auto Layout" data-type="indexterm" id="idm46177242393976"/><a data-primary="iOS" data-secondary="views" data-tertiary="Auto Layout" data-type="indexterm" id="idm46177242392760"/> are part of a technology within iOS called Auto Layout. It’s an <em>incredibly</em> powerful and complex tool that, used thoughtfully, can ease the amount of work required to make complex and responsive user interfaces. The scope of Auto Layout is too big for this section, so check out <a href="https://oreil.ly/dYJcl">the documentation</a> for more information on how to use it effectively within your app.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Update a View’s State" data-type="sect2"><div class="sect2" id="idm46177242389864">&#13;
<h2>Update a View’s State</h2>&#13;
&#13;
<p>Creating<a data-primary="views" data-secondary="iOS" data-tertiary="updating state" data-type="indexterm" id="idm46177242388216"/><a data-primary="iOS" data-secondary="views" data-tertiary="updating state" data-type="indexterm" id="idm46177242386936"/> a view and adding it to a super view will get you only so far. There are a ton of properties available to all views to make their display more dynamic and to stylize them beyond basic, white rectangles. Let’s take a look at how to update some of the more commonly used properties.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Alpha" data-type="sect3"><div class="sect3" id="idm46177242385160">&#13;
<h3>Alpha</h3>&#13;
&#13;
<p>You can update the alpha value, or transparency, of your view as follows:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">myView</code><code class="p">.</code><code class="n">alpha</code> <code class="p">=</code> <code class="mf">0.5</code></pre>&#13;
&#13;
<p>This changes the value to 50% transparency. If you wanted to hide the view completely, you could do so with the following snippet:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">myView</code><code class="p">.</code><code class="n">alpha</code> <code class="p">=</code> <code class="mf">0.0</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hiding views" data-type="sect3"><div class="sect3" id="idm46177242378232">&#13;
<h3>Hiding views</h3>&#13;
&#13;
<p>Setting<a data-primary="views" data-secondary="iOS" data-tertiary="hiding views" data-type="indexterm" id="idm46177242367464"/><a data-primary="iOS" data-secondary="views" data-tertiary="hiding views" data-type="indexterm" id="idm46177242366184"/> a view’s alpha to <code>0.0</code> won’t actually remove the view from the screen. It’ll still respond to touch events and block other views if it’s overlaid on top of them. In order to truly hide a view, use the following code:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">myView</code><code class="p">.</code><code class="n">isHidden</code> <code class="p">=</code> <code class="kc">true</code> <code class="c1">// Hides the view</code>&#13;
<code class="n">myView</code><code class="p">.</code><code class="n">isHidden</code> <code class="p">=</code> <code class="kc">false</code> <code class="c1">// Un-hides the view</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Background color" data-type="sect3"><div class="sect3" id="idm46177242253800">&#13;
<h3>Background color</h3>&#13;
&#13;
<p>All<a data-primary="views" data-secondary="iOS" data-tertiary="background color" data-type="indexterm" id="idm46177242336984"/><a data-primary="iOS" data-secondary="views" data-tertiary="background color" data-type="indexterm" id="idm46177242335736"/> views have a background color. The default background color for views on iOS is white. This is expressed as a <code>UIColor</code> object, or more specifically <code>UIColor.white</code>. You can set the background color to blue like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">myView</code><code class="p">.</code><code class="n">backgroundColor</code> <code class="p">=</code> <code class="bp">UIColor</code><code class="p">.</code><code class="n">blue</code></pre>&#13;
&#13;
<p>Or, if you’d rather set it to a custom color you’ve defined, you can do so like this:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="n">myView</code><code class="p">.</code><code class="n">backgroundColor</code> <code class="p">=</code> <code class="bp">UIColor</code><code class="p">(</code><code class="n">red</code><code class="p">:</code> <code class="mf">223.0</code><code class="p">,</code> <code class="n">green</code><code class="p">:</code> <code class="mf">23.0</code><code class="p">,</code> <code class="n">blue</code><code class="p">:</code> <code class="mf">0.0</code><code class="p">,</code> <code class="n">alpha</code><code class="p">:</code> <code class="mf">1.0</code><code class="p">)</code></pre>&#13;
&#13;
<p>The <code>alpha</code> value in the <code>UIColor</code> affects only the background color. This does make it possible to have a view that is semi-transparent without affecting the view’s contents like setting the view’s <code>alpha</code> property directly would. In other words:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="c1">// Changes a view's background color to a semi-transparent color</code>&#13;
<code class="n">myView</code><code class="p">.</code><code class="n">backgroundColor</code> <code class="p">=</code> <code class="bp">UIColor</code><code class="p">(</code><code class="n">red</code><code class="p">:</code> <code class="mf">223.0</code><code class="p">,</code> <code class="n">green</code><code class="p">:</code> <code class="mf">23.0</code><code class="p">,</code> <code class="n">blue</code><code class="p">:</code> <code class="mf">0.0</code><code class="p">,</code> <code class="n">alpha</code><code class="p">:</code> <code class="mf">0.5</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Changes the entire view to be semi-transparent</code>&#13;
<code class="n">myView</code><code class="p">.</code><code class="n">alpha</code> <code class="p">=</code> <code class="mf">0.5</code></pre>&#13;
&#13;
<p>One important thing to note about colors within iOS is that “clear” is itself a color. For example, to create a view without a background color at all, you need to set the view’s background color to clear like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// Give the view a fully transparent background</code>&#13;
<code class="n">myView</code><code class="p">.</code><code class="n">backgroundColor</code> <code class="p">=</code> <code class="bp">UIColor</code><code class="p">.</code><code class="n">clear</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Modifying Position" data-type="sect2"><div class="sect2" id="idm46177242389448">&#13;
<h2>Modifying Position</h2>&#13;
&#13;
<p>Want<a data-primary="views" data-secondary="iOS" data-tertiary="modifying position" data-type="indexterm" id="idm46177242068904"/><a data-primary="iOS" data-secondary="views" data-tertiary="modifying position" data-type="indexterm" id="idm46177242067624"/> to modify the position of a view? You have two options, and the choice is based on if you used constraints or not. If constraints were not used, you can interact with the view through its <code>frame</code>. For example, to change a view’s position via the frame, do something like the following:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// Create a 100x100 view at (0,0)</code>&#13;
<code class="kd">let</code> <code class="nv">view</code> <code class="p">=</code> <code class="bp">UIView</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="bp">CGRect</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="mf">0.0</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="mf">0.0</code><code class="p">,</code> <code class="n">width</code><code class="p">:</code> <code class="mf">100.0</code><code class="p">,</code> <code class="n">height</code><code class="p">:</code> <code class="mf">100.0</code><code class="p">))</code>&#13;
&#13;
<code class="c1">// Resize the view to 50x50 and move it to (130, 55)</code>&#13;
<code class="n">view</code><code class="p">.</code><code class="n">frame</code> <code class="p">=</code> <code class="bp">CGRect</code><code class="p">(</code><code class="n">x</code><code class="p">:</code> <code class="mf">130.0</code><code class="p">,</code> <code class="n">y</code><code class="p">:</code> <code class="mf">55.0</code><code class="p">,</code> <code class="n">width</code><code class="p">:</code> <code class="mf">50.0</code><code class="p">,</code> <code class="n">height</code><code class="p">:</code> <code class="mf">50.0</code><code class="p">)</code></pre>&#13;
&#13;
<p>If you used constraints to position the view, you’ll need to update the constraints directly. This can be done programmatically by creating a constraint within Interface Builder and assigning it to an <code>@IBOutlet</code> created within a class to edit the constraint’s value. If you have a width constraint defined in Interface Builder as <code>100.0</code>, you could change it to <code>50.0</code> in the code like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ExampleViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
&#13;
    <code class="kr">@IBOutlet</code> <code class="kd">var</code> <code class="nv">widthConstraint</code><code class="p">:</code> <code class="bp">NSLayoutConstraint</code><code class="p">!</code>&#13;
&#13;
    <code class="p">...</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">resizeWidth</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">widthConstraint</code><code class="p">.</code><code class="n">constant</code> <code class="p">=</code> <code class="mf">50.0</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You could also avoid setting values in the code and have two constraints added directly to the object in Interface Builder with one constraint turned off. Then, when the time is right, you could switch the constraints like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ExampleViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
&#13;
    <code class="kr">@IBOutlet</code> <code class="kd">var</code> <code class="nv">widthConstraint</code><code class="p">:</code> <code class="bp">NSLayoutConstraint</code><code class="p">!</code>&#13;
    <code class="kr">@IBOutlet</code> <code class="kd">var</code> <code class="nv">otherWidthConstraint</code><code class="p">:</code> <code class="bp">NSLayoutConstraint</code><code class="p">!</code>&#13;
&#13;
    <code class="c1">/// ...</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">resizeWidth</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">widthConstraint</code><code class="p">.</code><code class="n">isActive</code> <code class="p">=</code> <code class="kc">false</code>&#13;
        <code class="n">otherWidthConstraint</code><code class="p">.</code><code class="n">isActive</code> <code class="p">=</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>These are the most common ways to adjust constraints, but honestly, there are a number of different ways to go about changing the constraints an object has connected to it. That is the power, and complexity, of Auto Layout.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other properties" data-type="sect3"><div class="sect3" id="idm46177241894888">&#13;
<h3>Other properties</h3>&#13;
&#13;
<p>This only scratches the surface of the number of properties available within views. Other views, like <code>UILabel</code>, have font options available. Views like <code>UIImageView</code> can have <code>UIImage</code>s assigned to them. Views like <code>WKWebView</code>, the built-in web view provided by iOS, have yet even more complex states that can be enabled and toggled. It’s best to look at the documentation for a particular class on Apple’s documentation site to get a full understanding of the properties available for control.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Core Animation" data-type="sect3"><div class="sect3" id="idm46177241891400">&#13;
<h3>Core Animation</h3>&#13;
&#13;
<p>One<a data-primary="Core Animation" data-type="indexterm" id="idm46177241890072"/> thing that wasn’t discussed in this chapter was Core Animation layers. This is a wholly different and complementary way to change and alter the appearance of a view. Things like <code>borderRadius</code> and <code>mask</code> make it possible to create complex user interfaces that are able to be animated.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SwiftUI" data-type="sect3"><div class="sect3" id="idm46177241887928">&#13;
<h3>SwiftUI</h3>&#13;
&#13;
<p>A<a data-primary="SwiftUI library" data-type="indexterm" id="idm46177241886600"/><a data-primary="UIKit" data-secondary="successor to" data-type="indexterm" id="idm46177241885864"/> successor to UIKit has arrived in the form of SwiftUI. This is a new library with which to build user interfaces within Swift. It’s a declarative syntax that has tons of promise for the next generation of UI development. It’s still early and a bit rough around the edges right now, but given the investment Apple is making in this technology, it’s a safe bet that it will become much more relevant and—if Apple has its way—the predominant way to build apps in a few short years.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177242069880">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>Android and iOS have very different mechanisms for displaying views on a device’s screen, but fundamentally they have the same goal: display content to a user for interaction. In order to achieve that, we’ve covered the following items:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to create a new view in both the platforms to display on the screen</p>&#13;
</li>&#13;
<li>&#13;
<p>The differences in creating views with raw XML in Android and storyboards in iOS, which are ultimately represented using XML as the underlying file structure</p>&#13;
</li>&#13;
<li>&#13;
<p>How to deal with changing device sizes in iOS through the use of constraints</p>&#13;
</li>&#13;
<li>&#13;
<p>The ease with which views can be nested and updated</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This information gives us a good amount of base knowledge to understand the next chapter on custom views. Let’s get started!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>