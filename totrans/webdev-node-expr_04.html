<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Tidying Up"><div class="chapter" id="ch_tidying_up">
<h1><span class="label">Chapter 4. </span>Tidying Up</h1>


<p>In the previous two chapters, we were just experimenting: dipping our toes into
the waters, so to speak. Before we proceed to more complex functionality,
we’re going to do some housekeeping and build some good habits into our
work.</p>

<p>In this chapter, we’ll start our Meadowlark Travel project in earnest.
Before we start building the website itself, though, we’re going to make
sure we have the tools we need to produce a high-quality product.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The running example in this book is not necessarily one you have
to follow. If you’re anxious to build your own website, you could
<span class="keep-together">follow</span> the framework of the
running example but modify it accordingly so that by the time you finish
this book, you could have a finished <span class="keep-together">website!</span></p>
</div>






<section data-type="sect1" data-pdf-bookmark="File and Directory Structure"><div class="sect1" id="idm45053607477880">
<h1>File and Directory Structure</h1>

<p><a data-type="indexterm" data-primary="directory structure conventions" id="idm45053607476472"/><a data-type="indexterm" data-primary="file structure conventions" id="idm45053607475800"/>Structuring applications has spawned many a religious debate, and there’s
no one right way to do it. However, there are some common conventions that
are helpful to know about.</p>

<p>It’s typical to try to restrict the number of files in your project root.
Typically, you’ll find configuration files (like <em>package.json</em>), a
<em>README.md</em> file, and a bunch of directories. Most source code goes under
a directory often called <em>src</em>. For the sake of brevity, we won’t be using
that convention in this book (nor does the Express scaffolding application
do this, surprisingly). For real-world projects, you’ll probably
eventually find that your project root gets cluttered if you’re putting
source code there, and you’ll want to collect those files under a directory
like <em>src</em>.</p>

<p>I’ve also mentioned that I prefer to name my main application file
(sometimes called the <em>entry point</em>) after the project itself
(<em>meadowlark.js</em>) as opposed to something generic like <em>index.js</em>,
<em>app.js</em>, or <em>server.js</em>.</p>

<p>It’s largely up to you how to structure your application, and I recommend
providing a road map to your structure in the <em>README.md</em> file (or a readme
linked from it).</p>

<p>At minimum, I recommend you always have the following two files in
your project root: <em>package.json</em> and <em>README.md</em>. The rest is up to your
imagination.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Best Practices"><div class="sect1" id="idm45053607466920">
<h1>Best Practices</h1>

<p><a data-type="indexterm" data-primary="best practices" id="idm45053607465832"/>The phrase <em>best practices</em> is one you hear thrown around a lot these days,
and it means that you should “do things right” and not cut corners (we’ll
talk about what this means specifically in a moment).
No doubt you’ve heard the engineering adage that your options are “fast,”
“cheap,” and “good,” and you can pick any two. <a data-type="indexterm" data-primary="accrual value" id="idm45053607464248"/>The thing that’s always
bothered me about this model is that it doesn’t take into account the
<em>accrual value</em> of doing things correctly. The first time you do something
correctly, it may take five times as long to do it as it would have to do
it quick and dirty. The second time, though, it’s going to take only three
times as long. By the time you’ve done it correctly a dozen times, you’ll
be doing it almost as fast as the quick and dirty way.</p>

<p>I had a fencing coach who would always remind us that practice doesn’t make
perfect; practice makes <em>permanent</em>. That is, if you do something over and
over again, eventually it will become automatic, rote. That is true, but
it says nothing about the quality of the thing you are practicing. If you
practice bad habits, then bad habits become rote. Instead, you should
follow the rule that <em>perfect</em> practice makes perfect. In that spirit, I
encourage you to follow the rest of the examples in this book as if you
were making a real-live website, as if your reputation and remuneration
were depending on the quality of the outcome. Use this book to not only
learn new skills but to practice building good habits.</p>

<p>The practices we will be focusing on are version control and QA. In this
chapter, we’ll be discussing version control, and we’ll discuss QA in the
next chapter.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Version Control"><div class="sect1" id="idm45053607459736">
<h1>Version Control</h1>

<p><a data-type="indexterm" data-primary="version control" data-seealso="source control" id="idm45053607458296"/>I hope I don’t have to convince you of the value of version control (if
I did, that might take a whole book itself).
Broadly speaking, version control offers these benefits:</p>
<dl>
<dt>Documentation</dt>
<dd>
<p><a data-type="indexterm" data-primary="documentation" data-secondary="version control and" id="idm45053607455432"/>Being able to go back through the history of a project to
see the decisions that were made and the order in which components were
developed can be valuable documentation. Having a
technical history of your project can be quite useful.</p>
</dd>
<dt>Attribution</dt>
<dd>
<p><a data-type="indexterm" data-primary="attribution, version control and" id="idm45053607452920"/>If you work on a team, attribution can be hugely
important. Whenever you find something in code that is
opaque or questionable, knowing who made that change can save you many
hours. It could be that the comments associated with the change are
sufficient to answer your questions, and if not, you’ll know who to talk
to.</p>
</dd>
<dt>Experimentation</dt>
<dd>
<p>A good version control system enables experimentation.
You can go off on a tangent, trying something new, without fear of
affecting the stability of your project. If the experiment is successful,
you can fold it back into the project, and if it is not successful, you can
abandon it.</p>
</dd>
</dl>

<p><a data-type="indexterm" data-primary="distributed version control systems (DVCSs)" id="idm45053607449784"/><a data-type="indexterm" data-primary="DVCSs (distributed version control systems)" id="idm45053607449112"/>Years ago, I made the switch to distributed version control systems
(DVCSs). I narrowed my choices down to Git and
Mercurial and went with Git, because of its ubiquity and
flexibility. Both are excellent and free
version control systems, and I recommend you use one of them. In this
book, we will be using Git, but you are welcome to substitute Mercurial (or
another version control system altogether).</p>

<p>If you are unfamiliar with Git, I recommend Jon Loeliger’s excellent
<em><a class="orm:hideurl" href="http://bit.ly/Version_Ctrl_Git">Version Control with Git</a></em>
(O’Reilly). Also, GitHub has a good listing of <a href="https://try.github.io">Git
learning resources</a>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="How to Use Git with This Book"><div class="sect1" id="idm45053607427224">
<h1>How to Use Git with This Book</h1>

<p><a data-type="indexterm" data-primary="Git" data-secondary="basics" id="ix_ch-04-tidying_up-asciidoc0"/>First, make sure you have Git. Type <code>git --version</code>. If it doesn’t
respond with a version number, you’ll need to install Git. See the
<a href="https://git-scm.com">Git documentation</a> for installation <span class="keep-together">instructions.</span></p>

<p>There are two ways to follow along with the examples in this book. One is
to type out the examples yourself and follow along with the Git commands.
The other is to clone the companion repository I am using for all of the
examples and check out the associated files for each example. Some people
learn better by typing out examples, while some prefer to just see and run
the changes without having to type it all in.</p>








<section data-type="sect2" data-pdf-bookmark="If You’re Following Along by Doing It Yourself"><div class="sect2" id="idm45053607421816">
<h2>If You’re Following Along by Doing It Yourself</h2>

<p>We already have a very rough framework for our project: some views, a
layout, a logo, a main application file, and a <em>package.json</em> file.
Let’s go ahead and create a Git repository and add all those
files.</p>

<p>First, we go to the project directory and initialize a Git repository there:</p>

<pre data-type="programlisting">git init</pre>

<p>Now before we add all the files, we’ll create a <em>.gitignore</em> file to help
prevent us from accidentally adding things we don’t want to add. Create a text file called <em>.gitignore</em> in
your project directory in which you can add any files or directories you
want Git to ignore by default (one per line). It also supports wildcards.
For example, if your editor creates backup files with a tilde at the end
(like <em>meadowlark.js~</em>), you might put <code>*~</code> in the <em>.gitignore</em> file.
If you’re on a Mac, you’ll want to put <code>.DS_Store</code> in there. You’ll also
want to put <code>node_modules</code> in there (for reasons that will be discussed
soon). So for now, the file
might look like this:</p>

<pre data-type="programlisting">node_modules
*~
.DS_Store</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Entries in the <em>.gitignore</em> file also apply to
subdirectories. So if you put <code>*~</code> in the <em>.gitignore</em> in the project
root, all such backup files will be ignored even if they are in
subdirectories.</p>
</div>

<p>Now we can add all of our existing files. There are many ways to do this
in Git. I generally favor <code>git add -A</code>, which is the most sweeping of all
the variants. If you are new to Git, I recommend you either add files one
by one (<code>git add meadowlark.js</code>, for example) if you want to commit
only one or two files, or add all of your changes (including any files you might have deleted) using <code>git add -A</code>. Since we want to add all the work we’ve
already done, we’ll use the following:</p>

<pre data-type="programlisting">git add -A</pre>
<div data-type="tip"><h6>Tip</h6>
<p><a data-type="indexterm" data-primary="git add command" id="idm45053607407432"/>Newcomers to Git are commonly confused by the <code>git add</code>
<span class="keep-together">command;</span> it adds <em>changes</em>, not
files. So if you’ve modified <em>meadowlark.js</em>, and then you type <code>git add
meadowlark.js</code> ,what you’re really doing is adding the changes you’ve made.</p>
</div>

<p>Git has a “staging area,” where changes go when you run <code>git add</code>. So the
changes we’ve added haven’t actually been committed yet, but they’re ready
to go. To commit the changes, use <code>git commit</code>:</p>

<pre data-type="programlisting">git commit -m "Initial commit."</pre>

<p>The <code>-m "Initial commit."</code> allows you to write a message associated with
this commit. Git won’t even let you make a commit without a message, and
for good reason. Always strive to make meaningful commit messages; they
should briefly but concisely describe the work you’ve done.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="If You’re Following Along by Using the Official Repository"><div class="sect2" id="idm45053607421192">
<h2>If You’re Following Along by Using the Official Repository</h2>

<p>To get the official repository for this book, run <code>git clone</code>:</p>

<pre data-type="programlisting">git clone https://github.com/EthanRBrown/web-development-with-node-and-express-2e</pre>

<p>This repository has a directory for each chapter that contains code
samples. For example, the source code for this chapter can be found in the
<code>ch04</code> directory. The code samples in each chapter are generally numbered
for ease of reference. Throughout the repository, I have liberally added
<em>README.md</em> files containing additional notes about the samples.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In the first version of this book, I took a different approach
with the repository, with a linear history as if you were developing an
increasingly sophisticated project. While this approach pleasantly
mirrored the way a project in the real world might develop, it caused a lot
of headache, both for me and for my readers. As npm packages changed, the code
samples would change, and short of rewriting the entire history of the
repo, there was no good way to update the repository or note the changes
in the text. While the chapter-per-directory approach is more artificial,
it allows the text to be synced more closely with the repository and also
enables easier community contribution.</p>
</div>

<p>As this book is updated and improved, the repository will also be updated,
and when it is, I will add a version tag so you can check out a version of
the repository that corresponds to the version of the book you’re reading
now. The current version of the repository is 2.0.0. I am roughly
following <em>semantic versioning</em> principles here (more on this later in this
chapter); the PATCH increment (the last number) represents minor changes
that shouldn’t impact your ability to follow along with the book. That is,
if the repo is at version 2.0.15, that should still correspond with this
version of the book. However, if the MINOR increment (the second number)
is different (2.1.0), that indicates that the content in the companion repo
may have diverged from what you’re reading, and you may want to check out a
tag starting with 2.0.</p>

<p>The companion repo liberally makes use of <em>README.md</em> files to add
additional explanation to the code samples.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If at any point you want to experiment, keep in mind that the
tag you have checked out puts you in what Git calls a “detached HEAD”
state. While you are free to
edit any files, it is unsafe to commit anything you do without creating a
branch first. So if you do want to base an experimental branch off of a
tag, simply create a new branch and check it out, which you can do with one
command: <code>git checkout</code> <code class="keep-together">-b</code>
<code>experiment</code> (where <code>experiment</code> is the name of your branch; you can use
whatever you want). Then you can safely edit and commit on that branch as
much as you want.<a data-type="indexterm" data-startref="ix_ch-04-tidying_up-asciidoc0" id="idm45053607388200"/></p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="npm Packages"><div class="sect1" id="idm45053607387272">
<h1>npm Packages</h1>

<p><a data-type="indexterm" data-primary="node modules" id="idm45053607385864"/><a data-type="indexterm" data-primary="npm (package manager)" data-secondary="packages for" id="idm45053607385160"/>The npm packages that your project relies on reside in a directory called
<em>node_modules</em>. (It’s unfortunate that this is called <em>node_modules</em> and
not <em>npm_packages</em>, as Node modules are a related but different
concept.) Feel free to explore that directory
to satisfy your curiosity or to debug your program, but you should never
modify any code in this directory. In addition to that being bad practice,
all of your changes could easily be undone by npm.</p>

<p>If you need to make a
modification to a package your project depends on, the correct course of
action would be to create your own fork of the package. If you do go this
route and feel that your improvements would be useful to others,
congratulations: you’re now involved in an open source project! You can
submit your changes, and if they meet the project standards, they’ll be
included in the official package. Contributing to existing packages and
creating customized builds is beyond the scope of this book, but there is a
vibrant community of developers out there to help you if you want to
contribute to existing packages.</p>

<p><a data-type="indexterm" data-primary="package.json file" data-secondary="dependencies listed in" id="idm45053607381192"/>Two of the main purposes of the <em>package.json</em> file are to describe your
project and to list its dependencies. Go ahead and look at your
<em>package.json</em> file now. You should see
something like this (the exact version numbers will probably be different,
as these packages get updated often):</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code>
  <code class="nt">"dependencies"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"express"</code><code class="p">:</code> <code class="s2">"^4.16.4"</code><code class="p">,</code>
    <code class="nt">"express-handlebars"</code><code class="p">:</code> <code class="s2">"^3.0.0"</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>Right now, our <em>package.json</em> file contains only information about
dependencies. The caret (<code>^</code>) in front of the package versions indicates
that any version that starts with the specified version number—up to the
next major version number—will work. For example, this <em>package.json</em>
indicates that any version of Express that starts with 4.0.0 will work, so
4.0.1 and 4.9.9 would both work, but 3.4.7 would not, nor would 5.0.0.
This is the default version specificity when you use <code>npm install</code>,
and is generally a pretty safe bet. The consequence of this approach is
that if you want to move up to a newer version, you will have to edit the
file to specify the new version. Generally, that’s a good thing because it
prevents changes in dependencies from breaking your project without your
knowing about it. <a data-type="indexterm" data-primary="semantic versioning" id="idm45053608240840"/>Version numbers in npm
are parsed by a component called
<em>semver</em> (for “semantic versioning”). If you want more information about
versioning in npm, consult the
<a href="http://try.github.io/">Semantic Versioning Specification</a> and <a href="http://bit.ly/34Vr3lX">this article
by Tamas Piros</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The Semantic Versioning Specification states that software using semantic
versioning must declare a “public API.” I’ve always found this wording to
be confusing; what they really mean is “someone must care about interfacing
with your software.” If you consider this in the broadest sense, it could
really be construed to mean anything. So don’t get hung up on that part of
the specification; the important details are in the format.</p>
</div>

<p>Since the <em>package.json</em> file lists all the dependencies, the
<em>node_modules</em> directory is really a derived artifact. That is, if you
were to delete it, all you would have to do to get the project working
again would be to run <code>npm install</code>, which will re-create the directory and
put all the necessary dependencies in it. It is for this reason that I
recommend putting <code>node_modules</code> in your <em>.gitignore</em> file and not
including it in source control. However, some people feel that your
repository should contain everything necessary to run the project and
prefer to keep <code>node_modules</code> in source control. I find that this is
“noise” in the repository, and I prefer to omit it.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="indexterm" data-primary="package-lock.json" id="idm45053599489800"/>As of version of 5 of npm, an additional file, <em>package-lock.json</em>, will
be created. Whereas <em>package.json</em> can be “loose” in its specification
of dependency versions (with the <code>^</code> and <code>~</code> version modifiers),
<em>package-lock.json</em> records the <em>exact</em> versions that were installed,
which can be helpful if you need to re-create the exact dependency versions
in your project. I recommend you check this file into source control and don’t modify it by hand. See the
<a href="http://bit.ly/2O8IjNK"><em>package-lock.json</em>
documentation</a> for more information.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Project Metadata"><div class="sect1" id="idm45053607017432">
<h1>Project Metadata</h1>

<p><a data-type="indexterm" data-primary="metadata storage" id="idm45053608708728"/><a data-type="indexterm" data-primary="package.json file" data-secondary="project metadata storage" id="idm45053606223576"/>The other purpose of the <em>package.json</em> file is to store project
metadata, such as the name of the project, authors, license information,
and so on. If you use <code>npm init</code> to initially create your <em>package.json</em>
file, it will populate the file with the necessary fields for you, and you
can update them at any time. If you intend to make your project available
on npm or GitHub, this metadata becomes critical. If you would like more
information about the fields in <em>package.json</em>, see the
<a href="http://bit.ly/2X7GVPs"><em>package.json</em> documentation</a>. The other
important piece of metadata is the <em>README.md</em> file. This file can be a handy place to describe the overall
architecture of the website, as well as any critical information that
someone new to the project might need. It is in a text-based wiki format
called Markdown. Refer to the
<a href="http://bit.ly/2q7BQur">Markdown documentation</a> for
more information.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Node Modules"><div class="sect1" id="idm45053598296552">
<h1>Node Modules</h1>

<p><a data-type="indexterm" data-primary="modules" data-secondary="Node" id="ix_ch-04-tidying_up-asciidoc1"/><a data-type="indexterm" data-primary="Node modules" id="ix_ch-04-tidying_up-asciidoc2"/>As mentioned earlier, Node modules and npm packages are related but
different concepts. <em>Node modules</em>, as the name implies,
offer a mechanism for modularization and encapsulation. <em>npm packages</em>
provide a standardized scheme for storing, versioning, and referencing
projects (which are not restricted to modules). For example, we import
Express itself as a module in our main application file:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express'</code><code class="p">)</code></pre>

<p><a data-type="indexterm" data-primary="require() function" id="idm45053599022248"/><code>require</code> is a Node function for importing a module. By default, Node looks for modules
in the directory <em>node_modules</em> (it should be no surprise, then, that
there’s an <em>express</em> directory inside of <em>node_modules</em>). However, Node
also provides a mechanism for <span class="keep-together">creating</span> your own modules (you should never
create your own modules in the <em>node_modules</em> directory). In addition to
modules installed into <em>node_modules</em> via a package manager, there are
more than 30 “core modules” provided by Node, such as <code>fs</code>, <code>http</code>, <code>os</code>,
and <code>path</code>. To see the whole list,
<a href="http://bit.ly/2NDIkKH">see
this illuminating Stack Overflow question</a> and refer to the
<a href="https://nodejs.org/en/docs/">official Node documentation</a>.</p>

<p>Let’s see how we can modularize the fortune cookie functionality we
implemented in the previous chapter.</p>

<p>First let’s create a directory to store our modules. You can call it
whatever you want, but <em>lib</em> (short for “library”) is a common choice.
In that folder, create a file called <em>fortune.js</em>
(<em>ch04/lib/fortune.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fortuneCookies</code> <code class="o">=</code> <code class="p">[</code>
  <code class="s2">"Conquer your fears or they will conquer you."</code><code class="p">,</code>
  <code class="s2">"Rivers need springs."</code><code class="p">,</code>
  <code class="s2">"Do not fear what you don't know."</code><code class="p">,</code>
  <code class="s2">"You will have a pleasant surprise."</code><code class="p">,</code>
  <code class="s2">"Whenever possible, keep it simple."</code><code class="p">,</code>
<code class="p">]</code>

<code class="nx">exports</code><code class="p">.</code><code class="nx">getFortune</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">idx</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code><code class="o">*</code><code class="nx">fortuneCookies</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code>
  <code class="k">return</code> <code class="nx">fortuneCookies</code><code class="p">[</code><code class="nx">idx</code><code class="p">]</code>
<code class="p">}</code></pre>

<p><a data-type="indexterm" data-primary="exports variable" id="idm45053606022824"/>The important thing to note here is the use of the global variable
<code>exports</code>. If you want
something to be visible outside of the module, you have to add it to
<code>exports</code>. In this
example, the function <code>getFortune</code> will be available from outside this
module, but our array <code>fortuneCookies</code> will be <em>completely hidden</em>.
 This is a good thing:
encapsulation allows for less error-prone and fragile code.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are several ways to export functionality from a module.
We will be covering different methods throughout the book and summarizing
them in <a data-type="xref" href="ch22.xhtml#ch_maintenance">Chapter 22</a>.</p>
</div>

<p>Now in <em>meadowlark.js</em>, we can remove the <code>fortuneCookies</code> array (though
there would be no harm in leaving it; it can’t conflict in any way with the
array of the same name defined in <em>lib/fortune.js</em>). It is traditional
(but not required) to specify imports at the top of the file, so at the top
of the <em>meadowlark.js</em> file, add the following line
(<em>ch04/meadowlark.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fortune</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./lib/fortune'</code><code class="p">)</code></pre>

<p>Note that we prefix our module name with <code>./</code>. This signals to Node that
it should not look for the module in the <em>node_modules</em> directory; if we
omitted that prefix, this would fail.</p>

<p>Now in our route for the About page, we can utilize the <code>getFortune</code> method
from our module:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/about'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'about'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">fortune</code><code class="o">:</code> <code class="nx">fortune</code><code class="p">.</code><code class="nx">getFortune</code><code class="p">()</code> <code class="p">}</code> <code class="p">)</code>
<code class="p">})</code></pre>

<p>If you’re following along, let’s commit those changes:</p>

<pre data-type="programlisting">git add -A git commit -m "Moved 'fortune cookie' into module."</pre>

<p>You will find modules to be a powerful and easy way to encapsulate
functionality, which will improve the overall design and maintainability of
your project, as well as make testing easier. Refer to the
<a href="https://nodejs.org/api/modules.html">official Node module documentation</a> for
more <span class="keep-together">information.</span></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="indexterm" data-primary="CJS (CommonJS) modules" data-seealso="Node modules" id="idm45053598263848"/><a data-type="indexterm" data-primary="CommonJS (CJS) modules" data-seealso="Node modules" id="idm45053598262472"/>Node modules are sometimes called <em>CommonJS (CJS) modules</em>, in reference to
an older specification that Node took inspiration from. <a data-type="indexterm" data-primary="ECMAScript Modules (ESM)" id="idm45053598261016"/><a data-type="indexterm" data-primary="ESM (ECMAScript Modules)" id="idm45053598260344"/>The JavaScript
language is adopting an official packaging mechanism, called ECMAScript
Modules (ESM). If you’ve been writing JavaScript in React or another
progressive frontend language, you may already be familiar with ESM, which
uses <code>import</code> and <code>export</code> (instead of <code>exports</code>, <code>module.exports</code>, and
<code>require</code>). For more information, see Dr. Axel Rauschmayer’s blog post
<a href="http://bit.ly/2X8ZSkM">“ECMAScript 6 modules: the
final syntax”</a>.<a data-type="indexterm" data-startref="ix_ch-04-tidying_up-asciidoc2" id="idm45053605933496"/><a data-type="indexterm" data-startref="ix_ch-04-tidying_up-asciidoc1" id="idm45053605932776"/></p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45053607093448">
<h1>Conclusion</h1>

<p>Now that we’re armed with some more information about Git, npm, and
modules, we’re ready to discuss how we can produce a better product by
employing good quality assurance (QA) practices in our coding.</p>

<p>I encourage you to keep in mind the following lessons from this chapter:</p>

<ul>
<li>
<p>Version control makes the software development process safer and more
predictable, and I encourage you to use it even for small projects; it
builds good habits!</p>
</li>
<li>
<p>Modularization is an important technique for managing the complexity of
software. In addition to providing a rich ecosystem of modules others have
developed through npm, you can package your own code in modules to better
organize your project.</p>
</li>
<li>
<p>Node modules (also called CJS) use a different syntax than ECMAScript
modules (ESM), and you may have to switch between the two syntaxes when you
go between frontend and backend code. It’s a good idea to be familiar
with both.</p>
</li>
</ul>
</div></section>







</div></section></div>



  </body></html>