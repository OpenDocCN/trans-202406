- en: Chapter 2\. The Life of a Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to use the ready-made DOM components, it’s time to learn
    how to make some of your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to define a custom component, both accomplishing the same
    result but using different syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a function (components created this way are referred to as *function*
    *components*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a class that extends `React.Component` (commonly referred to as *class*
    *components*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Custom Function Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s an example of a function component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But wait, this is just a function! Yes, the custom component is just a function
    that returns the UI that you want. In this case, the UI is only text but you’ll
    often need a little bit more, most likely a composition of other components. Here’s
    an example of using a `span` to wrap the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using your shiny new component in an application is similar to using the DOM
    components from [Chapter 1](ch01.xhtml#ch1), except you *call* the function that
    defines the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The result of rendering your custom component is shown in [Figure 2-1](#FIG0201).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0201](Images/rur2_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Your first custom component (*02.01.custom-functional.html* in
    the book’s repository)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A JSX Version
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The same example using JSX will look a little easier to read. Defining the
    component looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the component the JSX way looks like this, regardless of how the component
    itself was defined (with JSX or not):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that in the self-closing tag `<MyComponent />`, the slash is not optional.
    That applies to HTML elements used in JSX too. `<br>` and `<img>` are not going
    to work; you need to close them like `<br/>` and `<img/>`.
  prefs: []
  type: TYPE_NORMAL
- en: A Custom Class Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The second way to create a component is to define a class that extends `React.Component`
    and implements a `render()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Rendering the component on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use JSX, you don’t need to know how the component was defined (using
    a class or a function). In both cases using the component is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Which Syntax to Use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may be wondering: with all these options (JSX vs. pure JavaScript, a class
    component vs. a function one), which one to use? JSX is the most common. And,
    unless you dislike the XML syntax in your JavaScript, the path of least resistance
    and of less typing is to go with JSX. This book uses JSX from now on, unless to
    illustrate a concept. Why then even talk about a no-JSX way? Well, you should
    know that there *is* another way and also that JSX is not magic but rather a thin
    syntax layer that transforms XML into plain JavaScript function calls like `React.createElement()`
    before sending the code to the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: What about *class* versus *function* components? This is a question of preference.
    If you’re comfortable with object-oriented programming (OOP) and you like how
    classes are laid out, then by all means, go for it. Function components are a
    little lighter on the computer’s CPU and involve a little less typing. They also
    feel more native to JavaScript. Actually *classes* didn’t exist in early versions
    of the JavaScript language; they are an afterthought and merely a syntactical
    sugar on top of functions and prototypes.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, as far as React is concerned, function components were not able
    to accomplish everything that classes could. Until the invention of *hooks*, that
    is, which you’ll get to in due time. As for the future, one can only speculate,
    but it’s likely that React will move more and more toward function components.
    However it’s highly unlikely that class components are going to be deprecated
    any time soon. This book teaches you both ways and doesn’t decide for you, though
    you may sense a slight preference toward function components. Why do we even bother
    with classes in this book, you may ask (as did most technical editors of the manuscript)?
  prefs: []
  type: TYPE_NORMAL
- en: Well, there is a lot of code out there in the real world written with classes
    and a lot of online tutorials. In fact, at the time of writing, even React’s official
    documentation shows most examples as class components. Therefore it’s the author’s
    opinion that the readers should be familiar with both syntaxes so they can read
    and understand all the code presented to them and not be confused as soon as a
    non-function component shows up.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering *hard-coded* UI in your custom components is perfectly fine and has
    its uses. But the components can also take *properties* and render or behave differently,
    depending on the values of the properties. Think about the `<a>` element in HTML
    and how it acts differently based on the value of the `href` attribute. The idea
    of properties in React is similar (and so is the JSX syntax).
  prefs: []
  type: TYPE_NORMAL
- en: 'In class components all properties are available via the `this.props` object.
    Let’s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As demonstrated in this example, you can open curly braces and sprinkle JavaScript
    values (and expressions too) within your JSX. You’ll learn more about this behavior
    as you progress with the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a value for the `name` property when rendering the component looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown in [Figure 2-2](#FIG0202).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0202](Images/rur2_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Using component properties (*02.05.this.props.html*)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s important to remember that `this.props` is read-only. It’s meant to carry
    on configuration from parent components to children, but it’s not a general-purpose
    storage of values. If you feel tempted to set a property of `this.props`, just
    use additional local variables or properties of your component’s class instead
    (meaning use `this.thing` as opposed to `this.props.thing`).
  prefs: []
  type: TYPE_NORMAL
- en: Properties in Function Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In function components, there’s no `this` (in JavaScript’s *strict* mode),
    or `this` refers to the global object (in non-strict, dare we say *sloppy*, mode).
    So instead of `this.props`, you get a `props` object passed to your function as
    the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A common pattern is to use JavaScript’s *destructuring assignment* and assign
    the property values to local variables. In other words the preceding example becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can have as many properties as you want. If, for example, you need two
    properties (`name` and `job`), you can use them like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Default Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your component may offer a number of properties, but sometimes a few of the
    properties may have default values that work well for the most common cases. You
    can specify default property values using `defaultProps` property for both function
    and class components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Function component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Class component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the result is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice how the `render()` method’s `return` statement wraps the returned value
    in parentheses. This is just because of JavaScript’s *automatic semi-colon insertion*
    (ASI) mechanism. A `return` statement followed by a new line is the same as `return;`
    which is the same as `return undefined;` which is definitely not what you want.
    Wrapping the returned expression in parentheses allows for better code formatting
    while retaining the correctness.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The examples so far were pretty static (or “stateless”). The goal was just to
    give you an idea of the building blocks of composing your UI. But where React
    really shines (and where old-school browser DOM manipulation and maintenance gets
    complicated) is when the data in your application changes. React has the concept
    of *state*, which is any data that components want to use to render themselves.
    When state changes, React rebuilds the UI in the DOM without you having to do
    anything. After you build your UI initially in your `render()` method (or in the
    rendering function in case of a function component) all you care about is updating
    the data. You don’t need to worry about UI changes at all. After all, your render
    method/function has already provided the blueprint of what the component should
    look like.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: “Stateless” is not a bad word, not at all. Stateless components are much easier
    to manage and think about. However, while going stateless whenever you can is
    usually preferable, applications are complicated and you do need state.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to how you access properties via `this.props`, you *read* the state
    via the object `this.state`. To *update* the state, you use `this.setState()`.
    When `this.setState()` is called, React calls the render method of your component
    (and all of its children) and updates the UI.
  prefs: []
  type: TYPE_NORMAL
- en: The updates to the UI after calling `this.setState()` are done using a queuing
    mechanism that efficiently batches changes. Updating `this.state` directly can
    have unexpected behavior and you shouldn’t do it. As with `this.props`, consider
    the `this.state` object read-only, not only because it’s semantically a bad idea,
    but because it can act in ways you don’t expect. Similarly, don’t ever call `this.render()`
    yourself—instead, leave it to React to batch changes, figure out the least amount
    of work, and call `render()` when and if appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: A textarea Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s build a new component—a `textarea` that keeps count of the number of characters
    typed in (as shown in [Figure 2-3](#FIG0203)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0203](Images/rur2_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. The end result of the custom `textarea` component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You (as well as other future consumers of this amazingly reusable component)
    can use the new component like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s implement the component. Start first by creating a “stateless” version
    that doesn’t handle updates; this is not too different from all the previous examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may have noticed that the `<textarea>` in the preceding snippet takes a
    `defaultValue` property, as opposed to a text child node, as you’re accustomed
    to in regular HTML. This is because there are some slight differences between
    React and old-school HTML when it comes to form elements. These are discussed
    further in the book but rest assured, there are not too many of them. Additionally,
    you’ll find that these differences make your life as a developer easier.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the `TextAreaCounter` component takes an optional `text` string
    property and renders a `textarea` with the given value, as well as an `<h3>` element
    that displays the string’s `length`. If the `text` property is not supplied, the
    default “Count me as I type” value is used.
  prefs: []
  type: TYPE_NORMAL
- en: Make It Stateful
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to turn this *stateless* component into a *stateful* one. In
    other words, let’s have the component maintain some data (state) and use this
    data to render itself initially and later on update itself (re-render) when data
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to set the initial state in the class constructor using `this.state`.
    Bear in mind that the constructor is the only place where it’s OK to set the state
    directly without calling `this.setState()`.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing `this.state` is required; if you don’t do it, consecutive access
    to `this.state` in the `render()` method will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case it’s not necessary to initialize `this.state.text` with a value
    as you can fallback to the property `this.prop.text` (try *02.12.this.state.html*
    in the book’s repo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Calling `super()` in the constructor is required before you can use `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data this component maintains is the contents of the `textarea`, so the
    state has only one property called `text`, which is accessible via `this.state.text`.
    Next you need to update the state. You can use a helper method for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You always update the state with `this.setState()`, which takes an object and
    merges it with the already existing data in `this.state`. As you might guess,
    `onTextChange()` is an event handler that takes an `event` object and reaches
    into it to get the contents of the `textarea` input.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing left to do is update the `render()` method to set up the event
    handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now whenever the user types into the `textarea`, the value of the counter updates
    to reflect the contents (see [Figure 2-4](#FIG0204)).
  prefs: []
  type: TYPE_NORMAL
- en: Note that before you had `<textarea defaultValue...>`, which is now `<textarea
    value...>` in the preceding code. This is because of the way inputs work in HTML
    where their state is maintained by the browser. But React can do better. In this
    example implementing `onChange` means that the `textarea` is now *controlled*
    by React. More on *controlled components* is coming later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0204](Images/rur2_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. Typing in the `textarea` (*02.12.this.state.html*)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A Note on DOM Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To avoid any confusion, a few clarifications are in order regarding the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: React uses its own *synthetic* events system for performance (as well as convenience
    and sanity). To help understand why, you need to consider how things are done
    in the pure DOM world.
  prefs: []
  type: TYPE_NORMAL
- en: Event Handling in the Olden Days
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s convenient to use *inline* event handlers to do things like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: While convenient and easy to read (the event listener is right there with the
    UI code), it’s inefficient to have too many event listeners scattered like this.
    It’s also hard to have more than one listener on the same button, especially if
    said button is in somebody else’s “component” or library and you don’t want to
    go in there and “fix” or fork their code. That’s why in the DOM world it’s common
    to use `element.addEventListener` to set up listeners (which now leads to having
    code in two places or more) and *event delegation* (to address the performance
    issues). Event delegation means you listen to events at some parent node, say
    a `<div>` that contains many buttons, and you set up one listener for all the
    buttons, instead of one listener per button. Hence you *delegate* the event handling
    to a parent authority.
  prefs: []
  type: TYPE_NORMAL
- en: 'With event delegation you do something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This works and performs fine, but there are drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the listener is further away from the UI component, which makes code
    harder to find and debug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using delegation and always `switch`-ing creates unnecessary boilerplate code
    even before you get to do the actual work (responding to a button click in this
    case).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Browser inconsistencies (omitted here) actually require this code to be longer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unfortunately, when it comes to taking this code live in front of real users,
    you need a few more additions if you want to support old browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: You need `attachEvent` in addition to `addEventListener`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need `const event = event || window.event;` at the top of the listener.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need `const button = event.target || event.srcElement;`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these are necessary and annoying enough that you end up using an event
    library of some sort. But why add another library (and study more APIs) when React
    comes bundled with a solution to the event-handling nightmares?
  prefs: []
  type: TYPE_NORMAL
- en: Event Handling in React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React uses *synthetic events* to wrap and normalize the browser events, which
    means no more browser inconsistencies. You can always rely on the fact that `event.target`
    is available to you in all browsers. That’s why in the `TextAreaCounter` snippet
    you only need `event.target.value` and it just works. It also means the API to
    cancel events is the same in all browsers; in other words, `event.stopPropagation()`
    and `event.preventDefault()` work even in old versions of Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax makes it easy to keep the UI and the event listeners together. It
    looks like old-school inline event handlers, but behind the scenes it’s not. Actually,
    React uses event delegation for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: React uses camelCase syntax for the event handlers, so you use `onClick` instead
    of `onclick`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need the original browser event for whatever reason, it’s available to
    you as `event.nativeEvent`, but it’s unlikely that you’ll ever need to go there.
  prefs: []
  type: TYPE_NORMAL
- en: 'And one more thing: the `onChange` event (as used in the `textarea` example)
    behaves as you’d expect: it fires when the user types, as opposed to after they’ve
    finished typing and have navigated away from the field, which is the behavior
    in plain DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: Event-Handling Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding example used an arrow function to call the helper `onTextChange`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is because the shorter `onChange={this.onTextChange}` wouldn’t have worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to bind the method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And yet another option, and a common pattern, is to bind all the event-handling
    methods in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It’s a bit of necessary boilerplate, but this way the event handler is bound
    only once, as opposed to every time the `render()` method is called, which helps
    reduce the memory footprint of your app.
  prefs: []
  type: TYPE_NORMAL
- en: This common pattern was largely superseded once it became possible to use functions
    as class properties in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'After:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See *02.12.this.state2.html* in the book’s repo for a complete example.
  prefs: []
  type: TYPE_NORMAL
- en: Props Versus State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know that you have access to `this.props` and `this.state` when it comes
    to displaying your component in your `render()` method. You may be wondering when
    you should use one versus the other.
  prefs: []
  type: TYPE_NORMAL
- en: Properties are a mechanism for the outside world (users of the component) to
    configure your component. State is your internal data maintenance. So if you consider
    an analogy with object-oriented programming, `this.props` is like a collection
    of all the arguments passed to a class constructor, while `this.state` is a bag
    of your private properties.
  prefs: []
  type: TYPE_NORMAL
- en: In general, prefer to split your application in a way that you have fewer *stateful*
    components and more *stateless* ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Props in Initial State: an Antipattern'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding `textarea` example, it’s tempting to use `this.props` to set
    the initial `this.state`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is considered an antipattern. Ideally, you use any combination of `this.state`
    and `this.props` as you see fit to build your UI in your `render()` method. But
    sometimes you want to take a value passed to your component and use it to construct
    the initial state. There’s nothing wrong with this, except that the callers of
    your component may expect the property (`text` in the preceding example) to always
    have the latest value, and the preceding code would violate this expectation.
    To set the expectation straight, a simple naming change is sufficient—for example,
    calling the property something like `defaultText` or `initialValue` instead of
    just `text`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Chapter 4](ch04.xhtml#ch4) illustrates how React solves this for its implementation
    of inputs and `textarea`s where people may have expectations coming from their
    prior HTML knowledge.'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Component from the Outside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don’t always have the luxury of starting a brand new React app from scratch.
    Sometimes you need to hook into an existing application or a website and migrate
    to React one piece at a time. Luckily, React was designed to work with any preexisting
    codebase you might have. After all, the original creators of React couldn’t stop
    the world and rewrite an entire huge application (Facebook.com) completely from
    scratch, especially in the early days when React was young.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way your React app can communicate with the outside world is to get a reference
    to a component you render with `ReactDOM.render()` and use it from outside of
    the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now you can use `myTextAreaCounter` to access the same methods and properties
    you normally access with `this` when inside the component. You can even play with
    the component using your JavaScript console (as shown in [Figure 2-5](#FIG0205)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0205](Images/rur2_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Accessing the rendered component by keeping a reference
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this example, `myTextAreaCounter.state` checks the current state (initially
    empty); `myTextAreaCounter.props` checks the properties and this line sets a new
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This line gets a reference to the main parent DOM node that React created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is the first child of the `<div id="app">`, which is where you told React
    to do its magic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You have access to the entire component API from outside of your component.
    But you should use your new superpowers sparingly, if at all. It may be tempting
    to fiddle with the state of components you don’t own and “fix” them, but you’d
    be violating expectations and cause bugs down the road because the component doesn’t
    anticipate such intrusions.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React offers several so-called *lifecycle* methods. You can use the lifecycle
    methods to listen to changes in your component as far as the DOM manipulation
    is concerned. The life of a component goes through three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Mounting
  prefs: []
  type: TYPE_NORMAL
- en: The component is added to the DOM initially.
  prefs: []
  type: TYPE_NORMAL
- en: Updating
  prefs: []
  type: TYPE_NORMAL
- en: The component is updated as a result of calling `setState()` and/or a prop provided
    to the component has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Unmounting
  prefs: []
  type: TYPE_NORMAL
- en: The component is removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'React does part of its work before updating the DOM. This is also called the
    *rendering phase*. Then it updates the DOM and this phase is called a *commit
    phase*. With this background, let’s consider some lifecycle methods:'
  prefs: []
  type: TYPE_NORMAL
- en: After the initial mounting and after the commit to the DOM, your component’s
    `componentDidMount()` method is called, if it exists. This is the place to do
    any initialization work that requires the DOM. Any initialization work that *does
    not* require the DOM should be in the constructor. And most of your initialization
    shouldn’t require the DOM. But in this method you can, for example, measure the
    height of the component that was just rendered, add any event listeners (e.g.
    `addEventListener('resize')`), or fetch data from the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Right before the component is removed from the DOM, the method `componentWillUnmount()`
    is called. This is the place to do any cleanup work you may need. Any event handlers,
    or anything else that may leak memory, should be cleaned up here. After this,
    the component is gone forever.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before the component is updated (e.g., as a result of `setState()`), you can
    use `getSnapshotBeforeUpdate()`. This method receives the previous properties
    and state as arguments. And it can return a “snapshot” value, which is any value
    you want to pass over to the next lifecycle method called `componentDidUpdate()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componentDidUpdate(previousProps, previousState, snapshot)`. This is called
    whenever the component was updated. Since at this point `this.props` and `this.state`
    have updated values, you get a copy of the previous ones. You can use this information
    to compare the old and the new state and potentially make more network requests
    if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And then there’s `shouldComponentUpdate(newProps, newState)`, which is an opportunity
    for an optimization. You’re given the state-to-be, which you can compare with
    the current state and decide not to update the component, in which case its `render()`
    method is not called.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these, `componentDidMount()` and `componentDidUpdate()` are the most common
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lifecycle Example: Log It All'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To better understand the life of a component, let’s add some logging in the
    `TextAreaCounter` component. Simply implement all of the lifecycle methods to
    log to the console when they are invoked, together with any arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: After loading the page, the only message in the console is `componentDidMount`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, what happens when you type “b” to make the text “Bobb” (see [Figure 2-6](#FIG0206))?
    `shouldComponentUpdate()` is called with the new props (same as the old) and the
    new state. Since this method returns `true`, React proceeds with calling `getSnapshotBeforeUpdate()`
    passing the old props and state. This is your chance to do something with them
    and with the old DOM and pass any resulting information as a snapshot to the next
    method. For example, this is an opportunity to do some element measurements or
    a scroll position and snapshot them to see if they change after the update. Finally,
    `componentDidUpdate()` is called with the old info (you have the new one in `this.state`
    and `this.props`) and any snapshot defined by the previous method.
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0206](Images/rur2_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Updating the component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s update the `textarea` one more time, this time typing “y”. The result
    is shown in [Figure 2-7](#FIG0207).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0207](Images/rur2_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. One more update to the component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, to demonstrate `componentWillUnmount()` in action (using the example
    *02.14.lifecycle.html* from this book’s GitHub repo) you can type in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This replaces the whole `textarea` component with a new `<p>` component. Then
    you can see the log message `componentWillUnmount` in the console (shown in [Figure 2-8](#FIG0208)).
  prefs: []
  type: TYPE_NORMAL
- en: '![rur2 0208](Images/rur2_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Removing the component from the DOM
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Paranoid State Protection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Say you want to restrict the number of characters to be typed in the `textarea`.
    You should do this in the event handler `onTextChange()`, which is called as the
    user types. But what if someone (a younger, more naive you?) calls `setState()`
    from the outside of the component (which, as mentioned earlier, is a bad idea)?
    Can you still protect the consistency and well-being of your component? Sure.
    You can do the validation in `componentDidUpdate()` and if the number of characters
    is greater than allowed, revert the state back to what it was. Something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The condition `prevState.text || this.props.text` is in place for the very first
    update when there’s no previous state.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may seem overly paranoid, but it’s still possible to do. Another way to
    accomplish the same protection is by leveraging `shouldComponentUpdate()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See *02.15.paranoid.html* in the book’s repo to play with these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the preceding code, using `_` as a name of a function argument is a convention
    signaling to a future reader of the code, “I know there’s another argument in
    the function’s signature, but I’m not going to use it.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Lifecycle Example: Using a Child Component'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You know you can mix and nest React components as you see fit. So far you’ve
    only seen `ReactDOM` components (as opposed to custom ones) in the `render()`
    methods. Let’s take a look at another simple custom component to be used as a
    child.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s isolate the part responsible for the counter into its own component. After
    all, divide and conquer is what it’s all about!
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s isolate the lifestyle logging into a separate class and have the
    two components inherit it. Inheritance is almost never warranted when it comes
    to React because for UI work, *composition* is preferable, and for non-UI work,
    a regular JavaScript module would do. Still, it’s useful to know how it works,
    and it helps you to avoid copy-pasting the logging methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `Counter` component simply shows the count. It doesn’t maintain state
    but displays the `count` property given by the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `textarea` component sets up a static `getName()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, the `textarea`’s `render()` gets to use `<Counter/>` and use it
    conditionally; if the count is 0, nothing is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice the conditional statement in JSX. You wrap the expression in `{}` and
    conditionally render either `<Counter/>` or nothing (`null`). And just for demonstration:
    another option is to move the condition outside the `return`. Assigning the result
    of a JSX expression to a variable is perfectly fine.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now you can observe the lifecycle methods being logged for both components.
    Open *02.16.child.html* from the book’s repo in your browser to see what happens
    when you load the page and then change the contents of the `textarea`.
  prefs: []
  type: TYPE_NORMAL
- en: 'During initial load, the child component is mounted and updated before the
    parent. You see in the console log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'After deleting two characters you see how the child is updated, then the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After deleting the last character, the child component is completely removed
    from the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, typing a character brings back the counter component to the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Performance Win: Prevent Component Updates'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You already know about `shouldComponentUpdate()` and saw it in action. It’s
    especially important when building performance-critical parts of your app. It’s
    invoked before `componentWillUpdate()` and gives you a chance to cancel the update
    if you decide it’s not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There is a class of components that use only `this.props` and `this.state` in
    their `render()` methods and no additional function calls. These components are
    called “pure” components. They can implement `shouldComponentUpdate()` and compare
    the state and the properties before and after an update and if there aren’t any
    changes, return `false` and save some processing power. Additionally, there can
    be pure static components that use neither props nor state. These can straight
    out return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'React can make it easier to use the common (and generic) case of checking all
    props and state in `shouldComponentUpdate()`: instead of repeating this work,
    you can have your components inherit `React.PureComponent` instead of `React.Component`.
    This way you don’t need to implement `shouldComponentUpdate()`—it’s done for you.
    Let’s take advantage and tweak the previous example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since both components inherit the logger, all you need is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now both components are *pure*. Let’s also add a log message in the `render()`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now loading the page (*02.17.pure.html* from the repo) prints out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing “Bob” to “Bobb” gives us the expected result of rendering and updating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you *paste* the string “LOLz” replacing “Bobb” (or any string with 4
    characters), you see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you see there’s no reason to re-render `<Counter>`, because its props have
    not changed. The new string has the same number of characters.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever Happened to Function Components?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have noticed that function components dropped out of this chapter by
    the time `this.state` got involved. They come back later in the book, when you’ll
    also learn the concept of *hooks*. Since there’s no `this` in functions, there
    needs to be another way to approach the management of state in a component. The
    good news is that once you understand the concepts of state and props, the function
    component differences are just syntax.
  prefs: []
  type: TYPE_NORMAL
- en: As much “fun” as it was to spend all this time on a `textarea`, let’s move on
    to something more challenging. In the next chapter, you’ll see where React’s benefits
    come into play—namely, focusing on your *data* and having React take care of any
    and all UI updates.
  prefs: []
  type: TYPE_NORMAL
