<!DOCTYPE html>
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<link href="Styles/Style00.css" rel="stylesheet" type="text/css" />
<link href="Styles/Style01.css" rel="stylesheet" type="text/css" />

<style type="text/css">body{margin:1em;background-color:transparent!important;}#sbo-rt-content *{text-indent:0pt!important;}#sbo-rt-content .bq{margin-right:1em!important;}</style></head>
<body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. The Life of a Component"><div class="chapter" id="ch2">
<h1><span class="label">Chapter 2. </span>The Life of a Component</h1>


<p>Now that you know how to use the ready-made DOM components, it’s time to learn how to make some of your own.</p>

<p>There are <a data-type="indexterm" data-primary="class components" data-secondary="versus function components" data-secondary-sortas="function components" id="ch2_term2"/><a data-type="indexterm" data-primary="components, custom" data-secondary="class versus function for" id="ch2_term3"/><a data-type="indexterm" data-primary="function components" data-secondary="versus class components" data-secondary-sortas="class components" id="ch2_term4"/><a data-type="indexterm" data-primary="components, custom" id="ch2_term6"/>two ways to define a custom component, both accomplishing the same result but using different syntax:</p>

<ul>
<li>
<p>Using a function (components created this way are referred to as <em>function</em> <span class="keep-together"><em>components</em></span>)</p>
</li>
<li>
<p>Using a class that extends <code>React.Component</code> (commonly referred to as <em>class</em> <span class="keep-together"><em>components</em></span>)</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="A Custom Function Component"><div class="sect1" id="idm45779453983808">
<h1>A Custom Function Component</h1>

<p>Here’s an <a data-type="indexterm" data-primary="components, custom" data-secondary="function" id="ch2_term1"/><a data-type="indexterm" data-primary="function components" data-secondary="examples of" id="ch2_term5"/>example of a function component:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="s1">'I am so custom'</code><code class="o">;</code>
<code class="p">};</code></pre>

<p>But wait, this is just a function! Yes, the custom component is just a function that returns the UI that you want. In this case, the UI is only text but you’ll often need a little bit more, most likely a composition of other components. Here’s an example of using a <code>span</code> to wrap the text:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s1">'span'</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="s1">'I am so custom'</code><code class="p">);</code>
<code class="p">};</code></pre>

<p class="pagebreak-before">Using your shiny new component in an application is similar to using the DOM components from <a data-type="xref" href="ch01.xhtml#ch1">Chapter 1</a>, except you <em>call</em> the function that defines the component:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="nx">MyComponent</code><code class="p">()</code><code class="o">,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>

<p>The result of rendering your custom component is shown in <a data-type="xref" href="#FIG0201">Figure 2-1</a>.</p>

<figure><div id="FIG0201" class="figure">
<img src="Images/rur2_0201.png" alt="rur2 0201" width="600" height="192"/>
<h6><span class="label">Figure 2-1. </span>Your first custom component (<em>02.01.custom-functional.html</em> in the book’s repository)</h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="A JSX Version"><div class="sect2" id="idm45779453886288">
<h2>A JSX Version</h2>

<p>The same example <a data-type="indexterm" data-primary="JSX (JavaScript XML)" data-secondary="for custom function components" data-secondary-sortas="custom function components" id="idm45779453884752"/>using JSX will look a little easier to read. Defining the component looks like this:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">span</code><code class="o">&gt;</code><code class="nx">I</code> <code class="nx">am</code> <code class="nx">so</code> <code class="nx">custom</code><code class="o">&lt;/</code><code class="nx">span</code><code class="o">&gt;;</code>
<code class="p">};</code></pre>

<p>Using the component the JSX way looks like this, regardless of how the component itself was defined (with JSX or not):</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="o">&lt;</code><code class="nx">MyComponent</code> <code class="o">/&gt;,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Notice that in the <a data-type="indexterm" data-primary="/ (slash) in JSX" id="idm45779453802528"/><a data-type="indexterm" data-primary="slash (/) in JSX" id="idm45779453801856"/>self-closing tag <code>&lt;MyComponent /&gt;</code>, the slash is not optional. That applies to HTML elements used in JSX too. <code>&lt;br&gt;</code> and <code>&lt;img&gt;</code> are not going to work; you need to <a data-type="indexterm" data-startref="ch2_term1" id="idm45779453799776"/><a data-type="indexterm" data-startref="ch2_term5" id="idm45779453799072"/>close them like <code>&lt;br/&gt;</code> and <code>&lt;img/&gt;</code>.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="A Custom Class Component"><div class="sect1" id="idm45779453983184">
<h1>A Custom Class Component</h1>

<p>The second way to <a data-type="indexterm" data-primary="React.Component" id="idm45779453795872"/><a data-type="indexterm" data-primary="render() method/function" id="idm45779453795136"/><a data-type="indexterm" data-primary="rendering" data-secondary="of custom components" data-secondary-sortas="custom components" id="idm45779453794448"/><a data-type="indexterm" data-primary="components, custom" data-secondary="class" id="ch2_term7"/>create a component is to define a class that extends <code>React.<span class="keep-together">Component</span></code> and implements a <code>render()</code> function:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">MyComponent</code> <code class="kd">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s1">'span'</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="s1">'I am so custom'</code><code class="p">);</code>
    <code class="c1">// or with JSX:</code>
    <code class="c1">// return &lt;span&gt;I am so custom&lt;/span&gt;;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>Rendering the component on the page:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="nx">MyComponent</code><code class="p">)</code><code class="o">,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>

<p>If you use JSX, you don’t need to know how the component was defined (using a class or a function). In both cases using the component is the same:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="o">&lt;</code><code class="nx">MyComponent</code> <code class="o">/&gt;,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>








<section data-type="sect2" data-pdf-bookmark="Which Syntax to Use?"><div class="sect2" id="idm45779453695856">
<h2>Which Syntax to Use?</h2>

<p>You may be wondering: with all these <a data-type="indexterm" data-primary="JavaScript" data-secondary="JSX and" id="idm45779453659216"/><a data-type="indexterm" data-primary="JSX (JavaScript XML)" data-secondary="for custom class components" data-secondary-sortas="custom class components" id="idm45779453658240"/><a data-type="indexterm" data-primary="syntax, choice of" id="idm45779453657008"/><a data-type="indexterm" data-primary="XML" id="idm45779453656336"/>options (JSX vs. pure JavaScript, a class component vs. a function one), which one to use? JSX is the most common. And, unless you dislike the XML syntax in your JavaScript, the path of least resistance and of less typing is to go with JSX. This book uses JSX from now on, unless to illustrate a concept. Why then even talk about a no-JSX way? Well, you should know that there <em>is</em> another way and also that JSX is not magic but rather a thin syntax layer that transforms XML into plain JavaScript function calls like <code>React.createElement()</code> before sending the code to the browser.</p>

<p>What about <em>class</em> versus <em>function</em> components? This is a question of preference. If you’re comfortable with object-oriented programming (OOP) and you like how classes are laid out, then by all means, go for it. <a data-type="indexterm" data-primary="components, custom" data-secondary="function" id="idm45779453652608"/>Function components are a little lighter on the computer’s CPU and involve a little less typing. They also feel more native to JavaScript. Actually <em>classes</em> didn’t exist in early versions of the JavaScript language; they are an afterthought and merely a syntactical sugar on top of functions and prototypes.</p>

<p>Historically, as far as React is concerned, <a data-type="indexterm" data-primary="function components" data-secondary="hooks as necessary for" id="idm45779453650304"/><a data-type="indexterm" data-primary="hooks" data-secondary="as necessary for function components" data-secondary-sortas="necessary for function components" id="idm45779453649328"/>function components were not able to accomplish everything that classes could. Until the invention of <em>hooks</em>, that is, which you’ll get to in due time. As for the future, one can only speculate, but it’s likely that React will move more and more toward function components. However it’s highly unlikely that class components are going to be deprecated any time soon. This book teaches you both ways and doesn’t decide for you, though you may sense a slight preference toward function components. Why do we even bother with classes in this book, you may ask (as did most technical editors of the manuscript)?</p>

<p>Well, there is a lot of code out there in the real world written with classes and a lot of online tutorials. In fact, at the time of writing, even React’s official documentation shows most examples as class components. Therefore it’s the author’s opinion that the readers should be familiar with both syntaxes so they can read and understand all the code presented to them and not be confused as soon as a non-function component <a data-type="indexterm" data-startref="ch2_term2" id="idm45779453624656"/><a data-type="indexterm" data-startref="ch2_term3" id="idm45779453624048"/><a data-type="indexterm" data-startref="ch2_term4" id="idm45779453623440"/><a data-type="indexterm" data-startref="ch2_term7" id="idm45779453622768"/>shows up.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Properties"><div class="sect1" id="idm45779453621840">
<h1>Properties</h1>

<p>Rendering <em>hard-coded</em> UI in your <a data-type="indexterm" data-primary="rendering" data-secondary="of custom components" data-secondary-sortas="custom components" id="idm45779453619504"/><a data-type="indexterm" data-primary="components, custom" data-secondary="properties (props) for" id="ch2_term9"/><a data-type="indexterm" data-primary="properties (props)" data-secondary="custom components and" id="ch2_term10"/>custom components is perfectly fine and has its uses. But the components can also take <em>properties</em> and render or behave differently, depending on the values of the properties. Think about the <code>&lt;a&gt;</code> element in HTML and how it acts differently based on the value of the <code>href</code> attribute. The idea of properties in React is similar (and so is the JSX syntax).</p>

<p>In class <a data-type="indexterm" data-primary="this.props object" id="ch2_term8"/>components all properties are available via the <code>this.props</code> object. Let’s see an example:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">MyComponent</code> <code class="kd">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="o">&lt;</code><code class="nx">span</code><code class="o">&gt;</code><code class="nx">My</code> <code class="nx">name</code> <code class="nx">is</code> <code class="o">&lt;</code><code class="nx">em</code><code class="o">&gt;</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">em</code><code class="o">&gt;&lt;/</code><code class="nx">span</code><code class="o">&gt;;</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As demonstrated in this example, you can <a data-type="indexterm" data-primary="JSX (JavaScript XML)" data-secondary="curly braces, use of" id="idm45779453583968"/><a data-type="indexterm" data-primary="curly braces ({})" id="idm45779453583024"/><a data-type="indexterm" data-primary="{} (curly braces)" id="idm45779453582352"/>open curly braces and sprinkle JavaScript values (and expressions too) within your JSX. You’ll learn more about this behavior as you progress with the book.</p>
</div>

<p>Passing a value for the <code>name</code> property when rendering the component looks like this:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="o">&lt;</code><code class="nx">MyComponent</code> <code class="nx">name</code><code class="o">=</code><code class="s2">"Bob"</code> <code class="o">/&gt;,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>

<p class="pagebreak-before">The result is shown in <a data-type="xref" href="#FIG0202">Figure 2-2</a>.</p>

<figure><div id="FIG0202" class="figure">
<img src="Images/rur2_0202.png" alt="rur2 0202" width="600" height="272"/>
<h6><span class="label">Figure 2-2. </span>Using component properties (<em>02.05.this.props.html</em>)</h6>
</div></figure>

<p>It’s important to remember that <code>this.props</code> is read-only. It’s meant to carry on configuration from parent components to children, but it’s not a general-purpose storage of values. If you feel tempted to set a property of <code>this.props</code>, just use additional local variables or properties of your component’s class instead (meaning use <code>this.thing</code> as opposed to <code>this.props.thing</code>).</p>








<section data-type="sect2" data-pdf-bookmark="Properties in Function Components"><div class="sect2" id="idm45779453524208">
<h2>Properties in Function Components</h2>

<p>In function <a data-type="indexterm" data-startref="ch2_term8" id="idm45779453522368"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="properties in" id="idm45779453521632"/><a data-type="indexterm" data-primary="strict mode" id="idm45779453493968"/><a data-type="indexterm" data-primary="components, custom" data-secondary="function" id="ch2_term11"/><a data-type="indexterm" data-primary="function components" data-secondary="properties in" id="ch2_term12"/>components, there’s no <code>this</code> (in JavaScript’s <em>strict</em> mode), or <code>this</code> refers to the global object (in non-strict, dare we say <em>sloppy</em>, mode). So instead of <code>this.props</code>, you get a <code>props</code> object passed to your function as the first argument:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">props</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">span</code><code class="o">&gt;</code><code class="nx">My</code> <code class="nx">name</code> <code class="nx">is</code> <code class="o">&lt;</code><code class="nx">em</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">em</code><code class="o">&gt;&lt;/</code><code class="nx">span</code><code class="o">&gt;;</code>
<code class="p">};</code></pre>

<p>A common pattern is to <a data-type="indexterm" data-primary="destructuring assignment" id="idm45779453464192"/>use JavaScript’s <em>destructuring assignment</em> and assign the property values to local variables. In other words the preceding example becomes:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="c1">// 02.07.props.destructuring.html in the book's repository</code>
<code class="kd">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="kd">function</code><code class="p">({</code><code class="nx">name</code><code class="p">})</code> <code class="p">{</code>
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">span</code><code class="o">&gt;</code><code class="nx">My</code> <code class="nx">name</code> <code class="nx">is</code> <code class="o">&lt;</code><code class="nx">em</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">em</code><code class="o">&gt;&lt;/</code><code class="nx">span</code><code class="o">&gt;;</code>
<code class="p">};</code></pre>

<p class="pagebreak-after">You can have as many properties as you want. If, for example, you need two properties (<code>name</code> and <code>job</code>), you can use them like:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="c1">// 02.08.props.destruct.multi.html in the book's repository</code>
<code class="kd">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="kd">function</code><code class="p">({</code><code class="nx">name</code><code class="o">,</code> <code class="nx">job</code><code class="p">})</code> <code class="p">{</code>
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">span</code><code class="o">&gt;</code><code class="nx">My</code> <code class="nx">name</code> <code class="nx">is</code> <code class="o">&lt;</code><code class="nx">em</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">em</code><code class="o">&gt;,</code> <code class="nx">the</code> <code class="p">{</code><code class="nx">job</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">span</code><code class="o">&gt;;</code>
<code class="p">};</code>
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="o">&lt;</code><code class="nx">MyComponent</code> <code class="nx">name</code><code class="o">=</code><code class="s2">"Bob"</code> <code class="nx">job</code><code class="o">=</code><code class="s2">"engineer"</code><code class="o">/&gt;,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Default Properties"><div class="sect2" id="idm45779453405952">
<h2>Default Properties</h2>

<p>Your component may offer a number of properties, but <a data-type="indexterm" data-primary="class components" data-secondary="default properties for" id="idm45779453285120"/><a data-type="indexterm" data-primary="class components" data-secondary="versus function components" data-secondary-sortas="function components" id="idm45779453284144"/><a data-type="indexterm" data-primary="components, custom" data-secondary="class" id="idm45779453282960"/><a data-type="indexterm" data-primary="components, custom" data-secondary="class versus function for" id="idm45779453282016"/><a data-type="indexterm" data-primary="defaultProps property" id="idm45779453281056"/><a data-type="indexterm" data-primary="function components" data-secondary="versus class components" data-secondary-sortas="class components" id="idm45779453280384"/>sometimes a few of the properties may have default values that work well for the most common cases. You can specify default property values using <code>defaultProps</code> property for both function and class components.</p>

<p>Function component:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="kd">function</code><code class="p">({</code><code class="nx">name</code><code class="o">,</code> <code class="nx">job</code><code class="p">})</code> <code class="p">{</code>
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">span</code><code class="o">&gt;</code><code class="nx">My</code> <code class="nx">name</code> <code class="nx">is</code> <code class="o">&lt;</code><code class="nx">em</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">em</code><code class="o">&gt;,</code> <code class="nx">the</code> <code class="p">{</code><code class="nx">job</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">span</code><code class="o">&gt;;</code>
<code class="p">};</code>
<code class="nx">MyComponent</code><code class="p">.</code><code class="nx">defaultProps</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">job</code><code class="o">:</code> <code class="s1">'engineer'</code><code class="o">,</code>
<code class="p">};</code>
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="o">&lt;</code><code class="nx">MyComponent</code> <code class="nx">name</code><code class="o">=</code><code class="s2">"Bob"</code> <code class="o">/&gt;,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>

<p>Class component:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">MyComponent</code> <code class="kd">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">(</code>
      <code class="o">&lt;</code><code class="nx">span</code><code class="o">&gt;</code><code class="nx">My</code> <code class="nx">name</code> <code class="nx">is</code> <code class="o">&lt;</code><code class="nx">em</code><code class="o">&gt;</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">name</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">em</code><code class="o">&gt;,</code>
      <code class="nx">the</code> <code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">job</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">span</code><code class="o">&gt;</code>
    <code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nx">MyComponent</code><code class="p">.</code><code class="nx">defaultProps</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">job</code><code class="o">:</code> <code class="s1">'engineer'</code><code class="o">,</code>
<code class="p">};</code>
<code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="o">&lt;</code><code class="nx">MyComponent</code> <code class="nx">name</code><code class="o">=</code><code class="s2">"Bob"</code> <code class="o">/&gt;,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>

<p>In both cases, the <a data-type="indexterm" data-startref="ch2_term11" id="idm45779453175280"/><a data-type="indexterm" data-startref="ch2_term12" id="idm45779453174784"/>result is the output:</p>
<pre data-type="programlisting">
My name is <em>Bob</em>, the engineer
</pre>
<div data-type="tip"><h6>Tip</h6>
<p>Notice how <a data-type="indexterm" data-primary="JavaScript" data-secondary="return statements in" id="idm45779453065792"/><a data-type="indexterm" data-primary="render() method/function" id="idm45779453064400"/>the <code>render()</code> method’s <code>return</code> statement wraps the returned value in parentheses. This is just because of JavaScript’s <em>automatic semi-colon insertion</em> (ASI) mechanism. A <code>return</code> statement followed by a new line is the same as <code>return;</code> which is the same as <code>return undefined;</code> which is definitely not what you want. <a data-type="indexterm" data-primary="wrappers" id="idm45779453060832"/><a data-type="indexterm" data-primary="() (parentheses), for wrapping" id="idm45779453060128"/><a data-type="indexterm" data-primary="parentheses (), for wrapping" id="idm45779453059392"/>Wrapping the returned expression in parentheses allows for better code formatting while retaining the <a data-type="indexterm" data-startref="ch2_term9" id="idm45779453058464"/><a data-type="indexterm" data-startref="ch2_term10" id="idm45779453057792"/>correctness.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="State"><div class="sect1" id="idm45779453621248">
<h1>State</h1>

<p>The examples so far were pretty static (or “stateless”). The goal was just to give you an idea of the building blocks of composing your UI. But where <a data-type="indexterm" data-primary="optimization of performance" id="idm45779453055344"/><a data-type="indexterm" data-primary="React" data-secondary="UI-building and DOM capabilities of" id="idm45779453054672"/><a data-type="indexterm" data-primary="React app" data-secondary="efficiency with" id="idm45779453053728"/><a data-type="indexterm" data-primary="rendering" data-secondary="React's efficiency with" id="idm45779453052784"/><a data-type="indexterm" data-primary="components, custom" data-secondary="state and" id="ch2_term13"/><a data-type="indexterm" data-primary="state" data-secondary="in class components" data-secondary-sortas="class components" id="ch2_term14"/>React really shines (and where old-school browser DOM manipulation and maintenance gets complicated) is when the data in your application changes. React has the concept of <em>state</em>, which is any data that components want to use to render themselves. When state changes, React rebuilds the UI in the DOM without you having to do anything. After you build your UI initially in your <code>render()</code> method (or in the rendering function in case of a function component) all you care about is updating the data. You don’t need to worry about UI changes at all. After all, your render method/function has already provided the blueprint of what the component should look like.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>“Stateless” is <a data-type="indexterm" data-primary="stateless components" id="idm45779453046624"/>not a bad word, not at all. Stateless components are much easier to manage and think about. However, while going stateless whenever you can is usually preferable, applications are complicated and you do need state.</p>
</div>

<p>Similarly to <a data-type="indexterm" data-primary="this.setState() method/function" id="idm45779453044800"/><a data-type="indexterm" data-primary="this.state object" id="idm45779453044128"/>how you access properties via <code>this.props</code>, you <em>read</em> the state via the object <code>this.state</code>. To <em>update</em> the state, you use <code>this.setState()</code>. When <code>this.setState()</code> is called, React calls the render method of your component (and all of its children) and updates the UI.</p>

<p>The updates to the UI after calling <code>this.setState()</code> are done using a queuing mechanism that efficiently batches changes. Updating <code>this.state</code> directly can have unexpected behavior and you shouldn’t do it. As with <code>this.props</code>, consider the <code>this.state</code> object read-only, not only because it’s semantically a bad idea, but because it can act in ways you don’t expect. <a data-type="indexterm" data-primary="this.render() method/function" id="idm45779453038240"/>Similarly, don’t ever call <code>this.render()</code> yourself—instead, leave it to React to batch changes, figure out the least amount of work, and call <code>render()</code> when and if appropriate.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="A textarea Component"><div class="sect1" id="idm45779453036480">
<h1>A textarea Component</h1>

<p>Let’s build a <a data-type="indexterm" data-primary="components, custom" data-secondary="textareas, building" id="ch2_term15"/><a data-type="indexterm" data-primary="inputs" data-secondary="character counter" id="ch2_term16"/><a data-type="indexterm" data-primary="textareas" data-secondary="updating counter in" id="ch2_term17"/>new component—a <code>textarea</code> that keeps count of the number of characters typed in (as shown in <a data-type="xref" href="#FIG0203">Figure 2-3</a>).</p>

<figure><div id="FIG0203" class="figure">
<img src="Images/rur2_0203.png" alt="rur2 0203" width="600" height="236"/>
<h6><span class="label">Figure 2-3. </span>The end result of the custom <code>textarea</code> component</h6>
</div></figure>

<p>You (as well as other future consumers of this amazingly reusable component) can use the new component like so:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="o">&lt;</code><code class="nx">TextAreaCounter</code> <code class="nx">text</code><code class="o">=</code><code class="s2">"Bob"</code> <code class="o">/&gt;,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>

<p>Now, let’s implement the component. Start first by <a data-type="indexterm" data-primary="stateless components" id="idm45779453013280"/>creating a “stateless” version that doesn’t handle updates; this is not too different from all the previous examples:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">TextAreaCounter</code> <code class="kd">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">text</code><code class="o">;</code>
    <code class="k">return</code> <code class="p">(</code>
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>
        <code class="o">&lt;</code><code class="nx">textarea</code> <code class="nx">defaultValue</code><code class="o">=</code><code class="p">{</code><code class="nx">text</code><code class="p">}</code><code class="o">/&gt;</code>
        <code class="o">&lt;</code><code class="nx">h3</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">h3</code><code class="o">&gt;</code>
      <code class="o">&lt;/</code><code class="nx">div</code><code class="o">&gt;</code>
    <code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nx">TextAreaCounter</code><code class="p">.</code><code class="nx">defaultProps</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">text</code><code class="o">:</code> <code class="s1">'Count me as I type'</code><code class="o">,</code>
<code class="p">};</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You may have <a data-type="indexterm" data-primary="defaultValue property" id="idm45779453007824"/><a data-type="indexterm" data-primary="HTML" data-secondary="versus React" data-secondary-sortas="React" id="idm45779452888960"/><a data-type="indexterm" data-primary="text child node" id="idm45779452887744"/>noticed that the <code>&lt;textarea&gt;</code> in the preceding snippet takes a <code>defaultValue</code> property, as opposed to a text child node, as you’re accustomed to in regular HTML. This is because there are some slight differences between React and old-school HTML when it comes to form elements. These are discussed further in the book but rest assured, there are not too many of them. Additionally, you’ll find that these differences make your life as a developer <span class="keep-together">easier</span>.</p>
</div>

<p>As you <a data-type="indexterm" data-primary="TextAreaCounter component" id="idm45779452884400"/>can see, the <code>TextAreaCounter</code> component takes an optional <code>text</code> string property and renders a <code>textarea</code> with the given value, as well as an <code>&lt;h3&gt;</code> element that displays the string’s <code>length</code>. If the <code>text</code> property is not supplied, the default “Count me as I type” value is used.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Make It Stateful"><div class="sect1" id="idm45779452880848">
<h1>Make It Stateful</h1>

<p>The next step is to turn this <em>stateless</em> component into a <em>stateful</em> one. In other words, let’s have the <a data-type="indexterm" data-primary="render() method/function" id="ch2_term18"/><a data-type="indexterm" data-primary="stateful components" id="ch2_term19"/>component maintain some data (state) and use this data to render itself initially and later on update itself (re-render) when data changes.</p>

<p>First, you need to <a data-type="indexterm" data-primary="constructor()" id="idm45779452875664"/><a data-type="indexterm" data-primary="this.state object" id="ch2_term20"/>set the initial state in the class constructor using <code>this.state</code>. Bear in mind that the constructor is the only place where it’s OK to set the state directly without calling <code>this.setState()</code>.</p>

<p>Initializing <code>this.state</code> is required; if you don’t do it, consecutive access to <code>this.state</code> in the <code>render()</code> method will fail.</p>

<p>In this case it’s not necessary to initialize <code>this.state.text</code> with a value as you can fallback to the property <code>this.prop.text</code> (try <em>02.12.this.state.html</em> in the book’s repo):</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">TextAreaCounter</code> <code class="kd">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">super</code><code class="p">();</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">=</code> <code class="p">{};</code>
  <code class="p">}</code>
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
    <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="s1">'text'</code> <code class="k">in</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">?</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">.</code><code class="nx">text</code> <code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">text</code><code class="o">;</code>
    <code class="k">return</code> <code class="p">(</code>
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>
        <code class="o">&lt;</code><code class="nx">textarea</code> <code class="nx">defaultValue</code><code class="o">=</code><code class="p">{</code><code class="nx">text</code><code class="p">}</code> <code class="o">/&gt;</code>
        <code class="o">&lt;</code><code class="nx">h3</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">h3</code><code class="o">&gt;</code>
      <code class="o">&lt;/</code><code class="nx">div</code><code class="o">&gt;</code>
    <code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Calling <code>super()</code> in the constructor is required before you can use <code>this</code>.</p>
</div>

<p>The data this component maintains is the contents of the <code>textarea</code>, so the state has only <a data-type="indexterm" data-primary="this.state object" data-secondary="this.state.text" id="idm45779452753904"/>one property called <code>text</code>, which is accessible via <code>this.state.text</code>. Next you need to update the state. You can use a helper method for this purpose:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">onTextChange</code><code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">setState</code><code class="p">({</code>
    <code class="nx">text</code><code class="o">:</code> <code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="o">,</code>
  <code class="p">});</code>
<code class="p">}</code></pre>

<p>You always <a data-type="indexterm" data-primary="onTextChange() event handler" id="idm45779452735760"/><a data-type="indexterm" data-primary="this.setState() method/function" id="idm45779452735056"/><a data-type="indexterm" data-primary="events handlers" id="ch2_term22"/><a data-type="indexterm" data-primary="event object" id="idm45779452733488"/>update the state with <code>this.setState()</code>, which takes an object and merges it with the already existing data in <code>this.state</code>. As you might guess, <code>onTextChange()</code> is an event handler that takes an <code>event</code> object and reaches into it to get the contents of the <code>textarea</code> input.</p>

<p>The last thing left to do is update the <code>render()</code> method to set up the event handler:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="s1">'text'</code> <code class="k">in</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">?</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">.</code><code class="nx">text</code> <code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">text</code><code class="o">;</code>
  <code class="k">return</code> <code class="p">(</code>
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>
      <code class="o">&lt;</code><code class="nx">textarea</code>
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">text</code><code class="p">}</code>
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">event</code> <code class="o">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">(</code><code class="nx">event</code><code class="p">)}</code>
      <code class="o">/&gt;</code>
      <code class="o">&lt;</code><code class="nx">h3</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">h3</code><code class="o">&gt;</code>
    <code class="o">&lt;/</code><code class="nx">div</code><code class="o">&gt;</code>
  <code class="p">);</code>
<code class="p">}</code></pre>

<p>Now whenever the user types into the <code>textarea</code>, the value of the counter updates to reflect the contents (see <a data-type="xref" href="#FIG0204">Figure 2-4</a>).</p>

<p>Note that before you had <code>&lt;textarea defaultValue...&gt;</code>, which is now <code>&lt;textarea value...&gt;</code> in the preceding code. This is because of the way inputs work in HTML where their state is maintained by the browser. But React can do better. In this <a data-type="indexterm" data-primary="components" data-secondary="controlled" id="idm45779452599376"/><a data-type="indexterm" data-primary="controlled components" id="idm45779452598400"/><a data-type="indexterm" data-primary="onChange() event handler" id="idm45779452597728"/>example implementing <code>onChange</code> means that the <code>textarea</code> is now <em>controlled</em> by React. More on <em>controlled components</em> is coming <a data-type="indexterm" data-startref="ch2_term18" id="idm45779452595104"/><a data-type="indexterm" data-startref="ch2_term19" id="idm45779452594368"/>later in the book.</p>

<figure><div id="FIG0204" class="figure">
<img src="Images/rur2_0204.png" alt="rur2 0204" width="600" height="247"/>
<h6><span class="label">Figure 2-4. </span>Typing in the <code>textarea</code> (<em>02.12.this.state.html</em>)</h6>
</div></figure>
</div></section>













<section data-type="sect1" data-pdf-bookmark="A Note on DOM Events"><div class="sect1" id="idm45779452880224">
<h1>A Note on DOM Events</h1>

<p>To avoid any <a data-type="indexterm" data-startref="ch2_term13" id="idm45779452589328"/><a data-type="indexterm" data-startref="ch2_term14" id="idm45779452588592"/><a data-type="indexterm" data-startref="ch2_term15" id="idm45779452587920"/><a data-type="indexterm" data-startref="ch2_term16" id="idm45779452587248"/><a data-type="indexterm" data-startref="ch2_term17" id="idm45779452586576"/><a data-type="indexterm" data-startref="ch2_term20" id="idm45779452585904"/>confusion, a few clarifications are in order regarding the following line:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">event</code> <code class="o">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">(</code><code class="nx">event</code><code class="p">)}</code></pre>

<p>React uses <a data-type="indexterm" data-primary="DOM (Document Object Model)" data-secondary="events and" id="ch2_term26"/><a data-type="indexterm" data-primary="synthetic events system" id="ch2_term27"/>its own <em>synthetic</em> events system for performance (as well as convenience and sanity). To help understand why, you need to consider how things are done in the pure DOM world.</p>








<section data-type="sect2" data-pdf-bookmark="Event Handling in the Olden Days"><div class="sect2" id="idm45779452575872">
<h2>Event Handling in the Olden Days</h2>

<p>It’s <a data-type="indexterm" data-primary="inline event handlers" id="idm45779452574176"/><a data-type="indexterm" data-primary="inputs" data-secondary="inline" id="idm45779452573440"/><a data-type="indexterm" data-primary="components, custom" data-secondary="event handling in" id="ch2_term25"/>convenient to use <em>inline</em> event handlers to do things like this:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;button</code> <code class="na">onclick=</code><code class="s">"doStuff"</code><code class="nt">&gt;</code></pre>

<p>While convenient and easy to read (the event listener is right there with the UI code), it’s <a data-type="indexterm" data-primary="addEventListener" id="ch2_term23"/><a data-type="indexterm" data-primary="event delegation" id="ch2_term24"/>inefficient to have too many event listeners scattered like this. It’s also hard to have more than one listener on the same button, especially if said button is in somebody else’s “component” or library and you don’t want to go in there and “fix” or fork their code. That’s why in the DOM world it’s common to use <code>element.addEventListener</code> to set up listeners (which now leads to having code in two places or more) and <em>event delegation</em> (to address the performance issues). Event delegation means you listen to events at some parent node, say a <code>&lt;div&gt;</code> that contains many buttons, and you set up one listener for all the buttons, instead of one listener per button. Hence you <em>delegate</em> the event handling to a parent authority.</p>

<p class="pagebreak-before">With event delegation you do something like:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;div</code> <code class="na">id=</code><code class="s">"parent"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;button</code> <code class="na">id=</code><code class="s">"ok"</code><code class="nt">&gt;</code>OK<code class="nt">&lt;/button&gt;</code>
  <code class="nt">&lt;button</code> <code class="na">id=</code><code class="s">"cancel"</code><code class="nt">&gt;</code>Cancel<code class="nt">&lt;/button&gt;</code>
<code class="nt">&lt;/div&gt;</code>

<code class="nt">&lt;script&gt;</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'parent'</code><code class="p">).</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s1">'click'</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">button</code> <code class="o">=</code> <code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">;</code>

  <code class="c1">// do different things based on which button was clicked</code>
  <code class="k">switch</code> <code class="p">(</code><code class="nx">button</code><code class="p">.</code><code class="nx">id</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">case</code> <code class="s1">'ok'</code><code class="o">:</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'OK!'</code><code class="p">);</code>
      <code class="k">break</code><code class="p">;</code>
    <code class="k">case</code> <code class="s1">'cancel'</code><code class="o">:</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Cancel'</code><code class="p">);</code>
      <code class="k">break</code><code class="p">;</code>
    <code class="k">default</code><code class="o">:</code>
      <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s1">'Unexpected button ID'</code><code class="p">);</code>
  <code class="p">};</code>
<code class="p">});</code>
<code class="nt">&lt;/script&gt;</code></pre>

<p>This works and performs fine, but there are drawbacks:</p>

<ul>
<li>
<p>Declaring the listener is further away from the UI component, which makes code harder to find and debug.</p>
</li>
<li>
<p>Using delegation and always <code>switch</code>-ing creates unnecessary boilerplate code even before you get to do the actual work (responding to a button click in this case).</p>
</li>
<li>
<p>Browser inconsistencies (omitted here) actually require this code to be longer.</p>
</li>
</ul>

<p>Unfortunately, when it comes to taking this code live in front of real users, you need a <a data-type="indexterm" data-primary="browsers, older" id="idm45779452391344"/>few more additions if you want to support old browsers:</p>

<ul>
<li>
<p>You need <code>attachEvent</code> in addition to <code>addEventListener</code>.</p>
</li>
<li>
<p>You need <code>const event = event || window.event;</code> at the top of the listener.</p>
</li>
<li>
<p>You need <code>const button = event.target || event.srcElement;</code>.</p>
</li>
</ul>

<p>All of these are necessary and annoying enough that you end up using an event library of some sort. But why add another library (and study more APIs) when React comes bundled with a solution to the <a data-type="indexterm" data-startref="ch2_term23" id="idm45779452384816"/><a data-type="indexterm" data-startref="ch2_term24" id="idm45779452384112"/>event-handling nightmares?</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Event Handling in React"><div class="sect2" id="idm45779452575248">
<h2>Event Handling in React</h2>

<p>React uses <em>synthetic events</em> to wrap and normalize the browser events, which means no more browser inconsistencies. You <a data-type="indexterm" data-primary="event.target.value" id="idm45779452381104"/><a data-type="indexterm" data-primary="target.value" id="idm45779452380368"/><a data-type="indexterm" data-primary="TextAreaCounter component" id="idm45779452379696"/>can always rely on the fact that <code>event.target</code> is available to you in all browsers. That’s why in the <code>TextAreaCounter</code> snippet you only need <code>event.target.value</code> and it just works. It also means the API to cancel events is the same in all browsers; in <a data-type="indexterm" data-primary="event.preventDefault()" id="idm45779452377520"/><a data-type="indexterm" data-primary="preventDefault()" id="idm45779452376816"/>other words, <code>event.stopPropagation()</code> and <code>event.preventDefault()</code> work even in old versions of Internet Explorer.</p>

<p>The syntax makes it easy to keep the UI and the event listeners together. It looks like old-school inline event handlers, but behind the scenes it’s not. Actually, React uses event delegation for performance reasons.</p>

<p>React uses <a data-type="indexterm" data-primary="camelCase attributes" id="idm45779452374112"/><a data-type="indexterm" data-primary="clicks, event handling with" id="idm45779452373376"/><a data-type="indexterm" data-primary="onClick handler" id="idm45779452372736"/>camelCase syntax for the event handlers, so you use <code>onClick</code> instead of <code>onclick</code>.</p>

<p>If you <a data-type="indexterm" data-primary="event.nativeEvent" id="idm45779452370592"/>need the original browser event for whatever reason, it’s available to you as <code>event.nativeEvent</code>, but it’s unlikely that you’ll ever need to go there.</p>

<p>And one <a data-type="indexterm" data-primary="onChange() event handler" id="idm45779452368928"/>more thing: the <code>onChange</code> event (as used in the <code>textarea</code> example) behaves as you’d expect: it fires when the user types, as opposed to after they’ve finished typing and have navigated away from the field, which is the behavior in plain DOM.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Event-Handling Syntax"><div class="sect2" id="idm45779452366848">
<h2>Event-Handling Syntax</h2>

<p>The preceding <a data-type="indexterm" data-primary="onTextChange() event handler" id="ch2_term28"/><a data-type="indexterm" data-primary="textareas" data-secondary="updating counter in" id="ch2_term29"/>example used an arrow function to call the helper <code>onTextChange</code> event:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">event</code> <code class="o">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">(</code><code class="nx">event</code><code class="p">)}</code></pre>

<p>This is because the shorter <code>onChange={this.onTextChange}</code> wouldn’t have worked.</p>

<p>Another option is to bind the method, like so:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="k">this</code><code class="p">)}</code></pre>

<p>And yet <a data-type="indexterm" data-primary="binding of method" id="idm45779452300560"/><a data-type="indexterm" data-primary="method, binding of" id="idm45779452299952"/><a data-type="indexterm" data-primary="constructor()" id="idm45779452299312"/>another option, and a common pattern, is to bind all the event-handling methods in the constructor:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
  <code class="kd">super</code><code class="p">();</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">=</code> <code class="p">{};</code>
  <code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
<code class="p">}</code>
<code class="c1">// ....</code>
<code class="o">&lt;</code><code class="nx">textarea</code>
  <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">text</code><code class="p">}</code>
  <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">}</code>
<code class="o">/&gt;</code></pre>

<p>It’s a bit of necessary boilerplate, but this way the <a data-type="indexterm" data-primary="render() method/function" id="ch2_term30"/>event handler is bound only once, as opposed to every time the <code>render()</code> method is called, which helps reduce the memory footprint of your app.</p>

<p>This common pattern was largely superseded once it became possible to use functions as class properties in JavaScript.</p>

<p>Before:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">class</code> <code class="nx">TextAreaCounter</code> <code class="kr">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="k">this</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="nx">onTextChange</code><code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>After:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">class</code> <code class="nx">TextAreaCounter</code> <code class="kr">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">}</code>

  <code class="nx">onTextChange</code> <code class="o">=</code> <code class="p">(</code><code class="nx">event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// ...</code>
  <code class="p">};</code>
<code class="p">}</code></pre>

<p>See <em>02.12.this.state2.html</em> in the book’s repo for a <a data-type="indexterm" data-startref="ch2_term22" id="idm45779452142832"/><a data-type="indexterm" data-primary="" data-startref="ch2_term25" id="idm45779452142224"/><a data-type="indexterm" data-startref="ch2_term26" id="idm45779452141280"/><a data-type="indexterm" data-startref="ch2_term27" id="idm45779452140608"/><a data-type="indexterm" data-startref="ch2_term28" id="idm45779452139936"/><a data-type="indexterm" data-startref="ch2_term29" id="idm45779452139264"/>complete example.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Props Versus State"><div class="sect1" id="idm45779452366256">
<h1>Props Versus State</h1>

<p>Now you <a data-type="indexterm" data-primary="components, custom" data-secondary="properties (props) for" id="idm45779452136912"/><a data-type="indexterm" data-primary="components, custom" data-secondary="state and" id="idm45779452135904"/><a data-type="indexterm" data-primary="properties (props)" data-secondary="custom components and" id="idm45779452106224"/><a data-type="indexterm" data-primary="properties (props)" data-secondary="versus state" data-secondary-sortas="state" id="idm45779452105376"/><a data-type="indexterm" data-primary="state" data-secondary="versus props" data-secondary-sortas="props" id="idm45779452104256"/><a data-type="indexterm" data-primary="this.props object" id="idm45779452103040"/><a data-type="indexterm" data-primary="this.state object" id="idm45779452102368"/>know that you have access to <code>this.props</code> and <code>this.state</code> when it comes to displaying your component in your <code>render()</code> method. You may be wondering when you should use one versus the other.</p>

<p>Properties are a mechanism for the outside world (users of the component) to configure your component. State is your internal data maintenance. So if you consider an analogy with object-oriented programming, <code>this.props</code> is like a collection of all the arguments passed to a class constructor, while <code>this.state</code> is a bag of your private properties.</p>

<p>In general, prefer to <a data-type="indexterm" data-primary="stateful components" id="idm45779452098496"/><a data-type="indexterm" data-primary="stateless components" id="idm45779452097760"/>split your application in a way that you have fewer <em>stateful</em> components and more <em>stateless</em> ones.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Props in Initial State: an Antipattern"><div class="sect1" id="idm45779452095808">
<h1>Props in Initial State: an Antipattern</h1>

<p>In the preceding <code>textarea</code> example, it’s <a data-type="indexterm" data-primary="properties (props)" data-secondary="antipattern with" id="idm45779452093856"/>tempting to use <code>this.props</code> to set the initial <code>this.state</code>:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="c1">// Warning: Anti-pattern</code>
<code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">text</code><code class="o">:</code> <code class="nx">props</code><code class="p">.</code><code class="nx">text</code><code class="o">,</code>
<code class="p">};</code></pre>

<p>This is considered an antipattern. Ideally, you use any combination of <code>this.state</code> and <code>this.props</code> as you see fit to build your UI in your <code>render()</code> method. But sometimes you want to take a value passed to your component and use it to construct the initial state. There’s nothing wrong with this, except that the callers of your component may expect the property (<code>text</code> in the preceding example) to always have the latest value, and the preceding code would violate this expectation. To <a data-type="indexterm" data-startref="ch2_term30" id="idm45779452081680"/>set the expectation straight, a simple naming change is sufficient—for example, calling the property something like <code>defaultText</code> or <code>initialValue</code> instead of just <code>text</code>:</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="xref" href="ch04.xhtml#ch4">Chapter 4</a> illustrates how React solves this for its implementation of inputs and <code>textarea</code>s where people may have expectations coming from their prior HTML knowledge.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Accessing the Component from the Outside"><div class="sect1" id="idm45779452077184">
<h1>Accessing the Component from the Outside</h1>

<p>You don’t always <a data-type="indexterm" data-primary="components, custom" data-secondary="accessing from outside" id="ch2_term31"/><a data-type="indexterm" data-primary="inputs" data-secondary="character counter" id="ch2_term32"/><a data-type="indexterm" data-primary="textareas" data-secondary="updating counter in" id="ch2_term33"/>have the luxury of starting a brand new React app from scratch. Sometimes you need to hook into an existing application or a website and migrate to React one piece at a time. Luckily, React was designed to work with any preexisting codebase you might have. After all, the original creators of React couldn’t stop the world and rewrite an entire huge application (Facebook.com) completely from scratch, especially in the early days when React was young.</p>

<p>One way your <a data-type="indexterm" data-primary="ReactDOM.render() function" id="idm45779452042480"/>React app can communicate with the outside world is to get a reference to a component you render with <code>ReactDOM.render()</code> and use it from outside of the component:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">const</code> <code class="nx">myTextAreaCounter</code> <code class="o">=</code> <code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code>
  <code class="o">&lt;</code><code class="nx">TextAreaCounter</code> <code class="nx">text</code><code class="o">=</code><code class="s2">"Bob"</code> <code class="o">/&gt;,</code>
  <code class="nx">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'app'</code><code class="p">)</code>
<code class="p">);</code></pre>

<p>Now you <a data-type="indexterm" data-primary="TextAreaCounter component" id="idm45779452024368"/>can use <code>myTextAreaCounter</code> to access the same methods and properties you normally access with <code>this</code> when inside the component. You can even play with the component using your JavaScript console (as shown in <a data-type="xref" href="#FIG0205">Figure 2-5</a>).</p>

<figure><div id="FIG0205" class="figure">
<img src="Images/rur2_0205.png" alt="rur2 0205" width="600" height="141"/>
<h6><span class="label">Figure 2-5. </span>Accessing the rendered component by keeping a reference</h6>
</div></figure>

<p>In this example, <code>myTextAreaCounter.state</code> checks the current state (initially empty); <code>myTextAreaCounter.props</code> checks the properties and this line sets a new state:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">myTextAreaCounter</code><code class="p">.</code><code class="nx">setState</code><code class="p">({</code><code class="nx">text</code><code class="o">:</code> <code class="s2">"Hello outside world!"</code><code class="p">});</code></pre>

<p>This line gets a reference to the main parent DOM node that React created:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">const</code> <code class="nx">reactAppNode</code> <code class="o">=</code> <code class="nx">ReactDOM</code><code class="p">.</code><code class="nx">findDOMNode</code><code class="p">(</code><code class="nx">myTextAreaCounter</code><code class="p">);</code></pre>

<p>This is the first child of the <code>&lt;div id="app"&gt;</code>, which is where you told React to do its magic.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You have <a data-type="indexterm" data-primary="APIs with React" id="idm45779451939920"/>access to the entire component API from outside of your component. But you should use your new superpowers sparingly, if at all. It may be tempting to fiddle with the state of components you don’t own and “fix” them, but you’d be violating expectations and cause bugs down the road because the component doesn’t anticipate <a data-type="indexterm" data-startref="ch2_term31" id="idm45779451938704"/><a data-type="indexterm" data-startref="ch2_term32" id="idm45779451938032"/><a data-type="indexterm" data-startref="ch2_term33" id="idm45779451982160"/>such intrusions.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Lifecycle Methods"><div class="sect1" id="idm45779452076560">
<h1>Lifecycle Methods</h1>

<p>React offers <a data-type="indexterm" data-primary="DOM (Document Object Model)" data-secondary="lifecycle methods and" id="ch2_term37"/><a data-type="indexterm" data-primary="components, custom" data-secondary="lifecycle methods with" id="ch2_term38"/><a data-type="indexterm" data-primary="lifecycle methods" id="ch2_term39"/>several so-called <em>lifecycle</em> methods. You can use the lifecycle methods to listen to changes in your component as far as the DOM manipulation is concerned. The life of a <a data-type="indexterm" data-primary="mounting of components" id="ch2_term34"/><a data-type="indexterm" data-primary="unmounting of components" id="ch2_term35"/><a data-type="indexterm" data-primary="updating of components" id="ch2_term36"/>component goes through three steps:</p>
<dl>
<dt>Mounting</dt>
<dd>
<p>The component is added to the DOM initially.</p>
</dd>
<dt>Updating</dt>
<dd>
<p>The component is <a data-type="indexterm" data-primary="setState()" id="idm45779451915536"/>updated as a result of calling <code>setState()</code> and/or a prop provided to the component has changed.</p>
</dd>
<dt>Unmounting</dt>
<dd>
<p>The component is removed from the DOM.</p>
</dd>
</dl>

<p>React does part of its work before updating the DOM. This is <a data-type="indexterm" data-primary="rendering" data-secondary="in React lifecycle" data-secondary-sortas="React lifecycle" id="idm45779451912576"/>also called the <em>rendering phase</em>. Then it updates the DOM and this phase is called a <em>commit phase</em>. With this background, let’s consider some lifecycle methods:</p>

<ul>
<li>
<p>After the initial mounting and after the commit to the DOM, <a data-type="indexterm" data-primary="componentDidMount() method" id="idm45779451909024"/>your component’s <code>componentDidMount()</code> method is called, if it exists. This is the place to do any initialization work that requires the DOM. Any initialization work that <em>does not</em> require the DOM should be in the constructor. And most of your initialization shouldn’t require the DOM. But in this method you can, for example, measure the height of the component that was just rendered, add any event listeners (e.g. <code>addEventListener('resize')</code>), or fetch data from the server.</p>
</li>
<li>
<p>Right before the component is removed from the DOM, the <a data-type="indexterm" data-primary="componentWillUnmount() method" id="idm45779451905616"/>method <code>componentWillUnmount()</code> is called. This is the <a data-type="indexterm" data-primary="cleanup work" id="idm45779451904352"/>place to do any cleanup work you may need. Any event handlers, or anything else that may leak memory, should be cleaned up here. After this, the component is gone forever.</p>
</li>
<li>
<p>Before the <a data-type="indexterm" data-primary="getSnapshotBeforeUpdate() method" id="idm45779451902272"/>component is updated (e.g., as a result of <code>setState()</code>), you can use <span class="keep-together"><code>getSnapshotBeforeUpdate()</code></span>. This method receives the previous properties and state as arguments. And it can return a “snapshot” value, which is any value you want to pass over to the <a data-type="indexterm" data-primary="componentDidUpdate() method" id="idm45779451899840"/>next lifecycle method called <code>componentDidUpdate()</code>.</p>
</li>
<li>
<p><code>componentDidUpdate(previousProps, previousState, snapshot)</code>. This is called whenever the component was updated. Since at this point <code>this.props</code> and <code>this.state</code> have updated values, you get a copy of the previous ones. You can use this information to compare the old and the new state and potentially make more network requests if necessary.</p>
</li>
<li>
<p>And then <a data-type="indexterm" data-primary="components, custom" data-secondary="updating, optimization of" id="idm45779451895728"/><a data-type="indexterm" data-primary="optimization of performance" id="idm45779451894704"/><a data-type="indexterm" data-primary="shouldComponentUpdate() method" id="idm45779451894016"/>there’s <code>shouldComponentUpdate(newProps, newState)</code>, which is an opportunity for an optimization. You’re given the state-to-be, which you can compare with the current state and decide not to update the component, in which case its <code>render()</code> method is not called.</p>
</li>
</ul>

<p>Of these, <code>componentDidMount()</code> and <code>componentDidUpdate()</code> are the most <a data-type="indexterm" data-startref="ch2_term34" id="idm45779451890704"/><a data-type="indexterm" data-startref="ch2_term35" id="idm45779451889968"/><a data-type="indexterm" data-startref="ch2_term36" id="idm45779451889296"/>common ones.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Lifecycle Example: Log It All"><div class="sect1" id="idm45779451888368">
<h1>Lifecycle Example: Log It All</h1>

<p>To better understand the life of a component, let’s add <a data-type="indexterm" data-primary="logging state of components" id="ch2_term40"/><a data-type="indexterm" data-primary="components, custom" data-secondary="updating, examples of" id="ch2_term41"/><a data-type="indexterm" data-primary="inputs" data-secondary="character counter" id="ch2_term42"/><a data-type="indexterm" data-primary="TextAreaCounter component" id="ch2_term43"/><a data-type="indexterm" data-primary="textareas" data-secondary="updating counter in" id="ch2_term44"/>some logging in the <code>TextAreaCounter</code> component. Simply implement all of the lifecycle methods to log to the console when they are invoked, together with any arguments:</p>

<pre data-type="programlisting" data-code-language="actionscript" class="pagebreak-before"><code class="kd">class</code> <code class="nx">TextAreaCounter</code> <code class="kd">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="c1">// ...</code>

  <code class="nx">componentDidMount</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'componentDidMount'</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">componentWillUnmount</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'componentWillUnmount'</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">componentDidUpdate</code><code class="p">(</code><code class="nx">prevProps</code><code class="o">,</code> <code class="nx">prevState</code><code class="o">,</code> <code class="nx">snapshot</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'componentDidUpdate     '</code><code class="o">,</code> <code class="nx">prevProps</code><code class="o">,</code> <code class="nx">prevState</code><code class="o">,</code> <code class="nx">snapshot</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">getSnapshotBeforeUpdate</code><code class="p">(</code><code class="nx">prevProps</code><code class="o">,</code> <code class="nx">prevState</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'getSnapshotBeforeUpdate'</code><code class="o">,</code> <code class="nx">prevProps</code><code class="o">,</code> <code class="nx">prevState</code><code class="p">);</code>
    <code class="k">return</code> <code class="s1">'hello'</code><code class="o">;</code>
  <code class="p">}</code>
  <code class="nx">shouldComponentUpdate</code><code class="p">(</code><code class="nx">newProps</code><code class="o">,</code> <code class="nx">newState</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'shouldComponentUpdate  '</code><code class="o">,</code> <code class="nx">newProps</code><code class="o">,</code> <code class="nx">newState</code><code class="p">);</code>
    <code class="k">return</code> <code class="kc">true</code><code class="o">;</code>
  <code class="p">}</code>

  <code class="c1">// ...</code>
<code class="p">}</code></pre>

<p>After loading the page, the <a data-type="indexterm" data-primary="componentDidMount() method" id="idm45779451879360"/>only message in the console is <code>componentDidMount</code>.</p>

<p>Next, what <a data-type="indexterm" data-primary="shouldComponentUpdate() method" id="idm45779451736432"/><a data-type="indexterm" data-primary="getSnapshotBeforeUpdate() method" id="idm45779451735728"/>happens when you type “b” to make the text “Bobb” (see <a data-type="xref" href="#FIG0206">Figure 2-6</a>)? <code>shouldComponentUpdate()</code> is called with the new props (same as the old) and the new state. Since this method returns <code>true</code>, React proceeds with calling <code>getSnapshotBeforeUpdate()</code> passing the old props and state. This is your chance to do something with them and with the old DOM and pass any resulting information as a snapshot to the next method. For example, this is an opportunity to do some element measurements or a scroll position and snapshot them to see if they change after the update. <a data-type="indexterm" data-primary="componentDidUpdate() method" id="idm45779451732368"/>Finally, <code>componentDidUpdate()</code> is called with the old info (you have the new one in <code>this.state</code> and <code>this.props</code>) and any snapshot defined by the previous method.</p>

<figure><div id="FIG0206" class="figure">
<img src="Images/rur2_0206.png" alt="rur2 0206" width="600" height="101"/>
<h6><span class="label">Figure 2-6. </span>Updating the component</h6>
</div></figure>

<p>Let’s update the <code>textarea</code> one more time, this time typing “y”. The result is shown in <a data-type="xref" href="#FIG0207">Figure 2-7</a>.</p>

<figure><div id="FIG0207" class="figure">
<img src="Images/rur2_0207.png" alt="rur2 0207" width="600" height="137"/>
<h6><span class="label">Figure 2-7. </span>One more update to the component</h6>
</div></figure>

<p>Finally, <a data-type="indexterm" data-primary="componentWillUnmount() method" id="idm45779451724624"/>to demonstrate <code>componentWillUnmount()</code> in action (using the example <em>02.14.lifecycle.html</em> from this book’s GitHub repo) you can type in the console:</p>

<pre data-type="programlisting">ReactDOM.render(React.createElement('p', null, 'Enough counting!'), app);</pre>

<p>This replaces the whole <code>textarea</code> component with a new <code>&lt;p&gt;</code> component. Then you can see the log message <code>componentWillUnmount</code> in the console (shown in <a data-type="xref" href="#FIG0208">Figure 2-8</a>).</p>

<figure><div id="FIG0208" class="figure">
<img src="Images/rur2_0208.png" alt="rur2 0208" width="600" height="89"/>
<h6><span class="label">Figure 2-8. </span>Removing the component from the DOM</h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="Paranoid State Protection"><div class="sect2" id="idm45779451717424">
<h2>Paranoid State Protection</h2>

<p>Say you <a data-type="indexterm" data-startref="ch2_term37" id="idm45779451715904"/><a data-type="indexterm" data-startref="ch2_term40" id="idm45779451714784"/><a data-type="indexterm" data-primary="events handlers" id="idm45779451714112"/><a data-type="indexterm" data-primary="onTextChange() event handler" id="idm45779451713440"/><a data-type="indexterm" data-primary="state" data-secondary="protection of" id="idm45779451712752"/><a data-type="indexterm" data-primary="this.setState() method/function" id="idm45779451711808"/>want to restrict the number of characters to be typed in the <code>textarea</code>. You should do this in the event handler <code>onTextChange()</code>, which is called as the user types. But <a data-type="indexterm" data-primary="components, custom" data-secondary="state  and" id="idm45779451709984"/><a data-type="indexterm" data-primary="setState()" id="idm45779451709008"/>what if someone (a younger, more naive you?) calls <code>setState()</code> from the outside of the component (which, as mentioned earlier, is a bad idea)? Can you still protect the consistency and well-being of your component? Sure. You <a data-type="indexterm" data-primary="componentDidUpdate() method" id="idm45779451707584"/>can do the validation in <code>componentDidUpdate()</code> and if the number of characters is greater than allowed, revert the state back to what it was. Something like:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">componentDidUpdate</code><code class="p">(</code><code class="nx">prevProps</code><code class="o">,</code> <code class="nx">prevState</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">.</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">3</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">this</code><code class="p">.</code><code class="nx">setState</code><code class="p">({</code>
      <code class="nx">text</code><code class="o">:</code> <code class="nx">prevState</code><code class="p">.</code><code class="nx">text</code> <code class="o">||</code> <code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">text</code><code class="o">,</code>
    <code class="p">});</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>The condition <code>prevState.text || this.props.text</code> is in place for the very first update when there’s no previous state.</p>

<p>This may seem overly paranoid, but it’s still possible to do. Another way to accomplish the <a data-type="indexterm" data-primary="shouldComponentUpdate() method" id="idm45779451635968"/>same protection is by leveraging <code>shouldComponentUpdate()</code>:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">shouldComponentUpdate</code><code class="p">(</code><code class="nx">_</code><code class="o">,</code> <code class="nx">newState</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">return</code> <code class="nx">newState</code><code class="p">.</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">3</code> <code class="o">?</code> <code class="kc">false</code> <code class="o">:</code> <code class="kc">true</code><code class="o">;</code>
<code class="p">}</code></pre>

<p>See <em>02.15.paranoid.html</em> in the book’s repo to play with these concepts.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In the preceding <a data-type="indexterm" data-primary="underscore (“_”) as function argument" id="idm45779451615392"/><a data-type="indexterm" data-primary="“_” (underscore) as function argument" data-primary-sortas="_ (underscore) as function argument" id="idm45779451614560"/><a data-type="indexterm" data-primary="function argument, “_” as" id="idm45779451613520"/>code, using <code>_</code> as a name of a function argument is a convention signaling to a future reader of the code, “I know there’s another argument in the function’s signature, but I’m not going to use it.”</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Lifecycle Example: Using a Child Component"><div class="sect1" id="idm45779451887744">
<h1>Lifecycle Example: Using a Child Component</h1>

<p>You know you can mix and nest React components as you see fit. So far you’ve only seen <code>ReactDOM</code> components (as opposed to custom ones) in the <code>render()</code> methods. Let’s take a look at <a data-type="indexterm" data-primary="components, custom" data-secondary="child, example of" id="ch2_term45"/><a data-type="indexterm" data-primary="child component example" id="ch2_term46"/><a data-type="indexterm" data-primary="Counter component example" id="ch2_term47"/>another simple custom component to be used as a child.</p>

<p>Let’s isolate the part responsible for the counter into its own component. After all, divide and conquer is what it’s all about!</p>

<p>First, let’s isolate the lifestyle logging into a separate class and have the two components <a data-type="indexterm" data-primary="inheritance as logging method" id="idm45779451576160"/>inherit it. Inheritance is almost never warranted when it comes to React because for UI work, <em>composition</em> is preferable, and for non-UI work, a regular JavaScript module would do. Still, it’s useful to know how it works, and it helps you to avoid copy-pasting the logging methods.</p>

<p>This is the parent:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">LifecycleLoggerComponent</code> <code class="kd">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code> <code class="p">{</code>
  <code class="kd">static</code> <code class="nx">getName</code><code class="p">()</code> <code class="p">{}</code>
  <code class="nx">componentDidMount</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">getName</code><code class="p">()</code> <code class="o">+</code> <code class="s1">'::componentDidMount'</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">componentWillUnmount</code><code class="p">()</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">getName</code><code class="p">()</code> <code class="o">+</code> <code class="s1">'::componentWillUnmount'</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="nx">componentDidUpdate</code><code class="p">(</code><code class="nx">prevProps</code><code class="o">,</code> <code class="nx">prevState</code><code class="o">,</code> <code class="nx">snapshot</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">getName</code><code class="p">()</code> <code class="o">+</code> <code class="s1">'::componentDidUpdate'</code><code class="p">);</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="pagebreak-before">The new <code>Counter</code> component simply shows the count. It doesn’t maintain state but displays the <code>count</code> property given by the parent:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">Counter</code> <code class="kd">extends</code> <code class="nx">LifecycleLoggerComponent</code> <code class="p">{</code>
  <code class="kd">static</code> <code class="nx">getName</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s1">'Counter'</code><code class="o">;</code>
  <code class="p">}</code>
  <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="o">&lt;</code><code class="nx">h3</code><code class="o">&gt;</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">count</code><code class="p">}</code><code class="o">&lt;/</code><code class="nx">h3</code><code class="o">&gt;;</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nx">Counter</code><code class="p">.</code><code class="nx">defaultProps</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">count</code><code class="o">:</code> <code class="mi">0</code><code class="o">,</code>
<code class="p">};</code></pre>

<p>The <code>textarea</code> <a data-type="indexterm" data-primary="static getName() method" id="idm45779451390720"/>component sets up a static <code>getName()</code> method:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">TextAreaCounter</code> <code class="kd">extends</code> <code class="nx">LifecycleLoggerComponent</code> <code class="p">{</code>
  <code class="kd">static</code> <code class="nx">getName</code><code class="p">()</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s1">'TextAreaCounter'</code><code class="o">;</code>
  <code class="p">}</code>
  <code class="c1">// ....</code>
<code class="p">}</code></pre>

<p>And finally, the <a data-type="indexterm" data-primary="render() method/function" id="ch2_term48"/><code>textarea</code>’s <code>render()</code> gets to use <code>&lt;Counter/&gt;</code> and use it conditionally; if the count is 0, nothing is displayed:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="s1">'text'</code> <code class="k">in</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code> <code class="o">?</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">.</code><code class="nx">text</code> <code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">text</code><code class="o">;</code>
  <code class="k">return</code> <code class="p">(</code>
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>
      <code class="o">&lt;</code><code class="nx">textarea</code>
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">text</code><code class="p">}</code>
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">}</code>
      <code class="o">/&gt;</code>
      <code class="p">{</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code>
        <code class="o">?</code> <code class="o">&lt;</code><code class="nx">Counter</code> <code class="nx">count</code><code class="o">=</code><code class="p">{</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">}</code> <code class="o">/&gt;</code>
        <code class="o">:</code> <code class="kc">null</code>
      <code class="p">}</code>
    <code class="o">&lt;/</code><code class="nx">div</code><code class="o">&gt;</code>
  <code class="p">);</code>
<code class="p">}</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Notice the <a data-type="indexterm" data-primary="JSX (JavaScript XML)" data-secondary="conditional statements in" id="idm45779451369552"/><a data-type="indexterm" data-primary="JSX (JavaScript XML)" data-secondary="curly braces, use of" id="idm45779451237440"/><a data-type="indexterm" data-primary="curly braces ({})" id="idm45779451236528"/><a data-type="indexterm" data-primary="{} (curly braces)" id="idm45779451235856"/>conditional statement in JSX. You wrap the expression in <code>{}</code> and conditionally render either <code>&lt;Counter/&gt;</code> or nothing (<code>null</code>). And just for demonstration: another option is to move the condition outside the <code>return</code>. Assigning the result of a JSX expression to a variable is perfectly fine.</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">text</code> <code class="o">=</code> <code class="s1">'text'</code> <code class="k">in</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code>
    <code class="o">?</code> <code class="k">this</code><code class="p">.</code><code class="nx">state</code><code class="p">.</code><code class="nx">text</code>
    <code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">props</code><code class="p">.</code><code class="nx">text</code><code class="o">;</code>
  <code class="nx">let</code> <code class="nx">counter</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">counter</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">Counter</code> <code class="nx">count</code><code class="o">=</code><code class="p">{</code><code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">}</code> <code class="o">/&gt;;</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="p">(</code>
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>
      <code class="o">&lt;</code><code class="nx">textarea</code>
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">text</code><code class="p">}</code>
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">onTextChange</code><code class="p">}</code>
      <code class="o">/&gt;</code>
      <code class="p">{</code><code class="nx">counter</code><code class="p">}</code>
    <code class="o">&lt;/</code><code class="nx">div</code><code class="o">&gt;</code>
  <code class="p">);</code>
<code class="p">}</code></pre>
</div>

<p>Now you can observe the lifecycle methods being logged for both components. Open <em>02.16.child.html</em> from the book’s repo in your browser to see what happens when you load the page and then change the contents of the <code>textarea</code>.</p>

<p>During initial load, the <a data-type="indexterm" data-primary="child-parent data communication" id="idm45779451109824"/><a data-type="indexterm" data-primary="parent-child data communication" id="idm45779451109200"/>child component is mounted and updated before the parent. You see in the console log:</p>

<pre data-type="programlisting">Counter::componentDidMount
TextAreaCounter::componentDidMount</pre>

<p>After deleting two characters you see how the child is updated, then the parent:</p>

<pre data-type="programlisting">Counter::componentDidUpdate
TextAreaCounter::componentDidUpdate
Counter::componentDidUpdate
TextAreaCounter::componentDidUpdate</pre>

<p>After deleting the last character, the child component is completely removed from the DOM:</p>

<pre data-type="programlisting">Counter::componentWillUnmount
TextAreaCounter::componentDidUpdate</pre>

<p>Finally, typing a character brings back the counter component <a data-type="indexterm" data-startref="ch2_term38" id="idm45779451104848"/><a data-type="indexterm" data-startref="ch2_term39" id="idm45779451104144"/><a data-type="indexterm" data-startref="ch2_term41" id="idm45779451103472"/><a data-type="indexterm" data-startref="ch2_term45" id="idm45779451102800"/><a data-type="indexterm" data-startref="ch2_term46" id="idm45779451102128"/><a data-type="indexterm" data-startref="ch2_term47" id="idm45779451101456"/>to the DOM:</p>

<pre data-type="programlisting">Counter::componentDidMount
TextAreaCounter::componentDidUpdate</pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Performance Win: Prevent Component Updates"><div class="sect1" id="idm45779451611040">
<h1>Performance Win: Prevent Component Updates</h1>

<p>You already <a data-type="indexterm" data-primary="shouldComponentUpdate() method" id="idm45779451098672"/>know about <code>shouldComponentUpdate()</code> and saw it in action. It’s especially important when building performance-critical parts of your app. It’s invoked before <code>componentWillUpdate()</code> and gives you a chance to cancel the update if you decide it’s not necessary.</p>

<p>There is a <a data-type="indexterm" data-primary="this.props object" id="idm45779451096176"/><a data-type="indexterm" data-primary="this.state object" id="idm45779451095472"/><a data-type="indexterm" data-primary="pure components" id="idm45779451094768"/><a data-type="indexterm" data-primary="components, custom" data-secondary="pure" id="idm45779451094096"/><a data-type="indexterm" data-primary="optimization of performance" id="idm45779451093152"/><a data-type="indexterm" data-primary="components, custom" data-secondary="updating, optimization of" id="idm45779451092512"/>class of components that use only <code>this.props</code> and <code>this.state</code> in their <code>render()</code> methods and no additional function calls. These components are called “pure” components. They can implement <code>shouldComponentUpdate()</code> and compare the state and the properties before and after an update and if there aren’t any changes, return <code>false</code> and save some processing power. Additionally, there can be pure static components that use neither props nor state. These can straight out return <code>false</code>.</p>

<p>React can <a data-type="indexterm" data-primary="React.Component" id="idm45779451087968"/><a data-type="indexterm" data-primary="React.PureComponent" id="idm45779451087264"/>make it easier to use the common (and generic) case of checking all props and state in <code>shouldComponentUpdate()</code>: instead of repeating this work, you can have your components inherit <code>React.PureComponent</code> instead of <code>React.Component</code>. This way you don’t need to implement <code>shouldComponentUpdate()</code>—it’s done for you. Let’s take advantage and tweak the previous example.</p>

<p>Since both components inherit the logger, all you need is:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="kd">class</code> <code class="nx">LifecycleLoggerComponent</code> <code class="kd">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">PureComponent</code> <code class="p">{</code>
  <code class="c1">// ... no other changes</code>
<code class="p">}</code></pre>

<p>Now both components are <em>pure</em>. Let’s also add a log message in the <code>render()</code> <span class="keep-together">methods</span>:</p>

<pre data-type="programlisting" data-code-language="actionscript"><code class="nx">render</code><code class="p">()</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">.</code><code class="nx">getName</code><code class="p">()</code> <code class="o">+</code> <code class="s1">'::render'</code><code class="p">);</code>
  <code class="c1">// ... no other changes</code>
<code class="p">}</code></pre>

<p>Now loading the page (<em>02.17.pure.html</em> from the repo) prints out:</p>

<pre data-type="programlisting">TextAreaCounter::render
Counter::render
Counter::componentDidMount
TextAreaCounter::componentDidMount</pre>

<p>Changing “Bob” to “Bobb” gives us the expected result of rendering and updating:</p>

<pre data-type="programlisting">TextAreaCounter::render
Counter::render
Counter::componentDidUpdate
TextAreaCounter::componentDidUpdate</pre>

<p class="pagebreak-before">Now if you <em>paste</em> the string “LOLz” replacing “Bobb” (or any string with 4 characters),  you see:</p>

<pre data-type="programlisting">TextAreaCounter::render
TextAreaCounter::componentDidUpdate</pre>

<p>As you see there’s no reason to re-render <code>&lt;Counter&gt;</code>, because its props have not changed. The new string has the same number of <a data-type="indexterm" data-startref="ch2_term42" id="idm45779451026816"/><a data-type="indexterm" data-startref="ch2_term43" id="idm45779451026112"/><a data-type="indexterm" data-startref="ch2_term44" id="idm45779451025440"/><a data-type="indexterm" data-startref="ch2_term48" id="idm45779451024768"/>characters.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Whatever Happened to Function Components?"><div class="sect1" id="idm45779451099712">
<h1>Whatever Happened to Function Components?</h1>

<p>You may have noticed that <a data-type="indexterm" data-primary="components, custom" data-secondary="function" id="idm45779451022416"/><a data-type="indexterm" data-primary="function components" data-secondary="hooks as necessary for" id="idm45779451021440"/>function components dropped out of this chapter by the time <code>this.state</code> got involved. They come back later in the book, when you’ll also learn the concept of <em>hooks</em>. Since there’s no <code>this</code> in functions, there needs to be another way to approach the management of state in a component. The good news is that once you understand the concepts of state and props, the function component differences are just <a data-type="indexterm" data-startref="ch2_term6" id="idm45779450996080"/>syntax.</p>

<p>As much “fun” as it was to spend all this time on a <code>textarea</code>, let’s move on to something more challenging. In the next chapter, you’ll see where React’s benefits come into play—namely, focusing on your <em>data</em> and having React take care of any and all UI updates.</p>
</div></section>







</div></section></div></body>
</html>