- en: Chapter 8\. Multi-Container Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 5](ch05.xhtml#pods_namespaces) explained how to manage single-container
    Pods. That’s the norm, as you’ll want to run a microservice inside of a single
    Pod to reinforce separation of concerns and increase cohesion. Technically, a
    Pod allows you to configure and run multiple containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll discuss the need for multi-container Pods, their relevant
    use cases, and the design patterns that have emerged in the Kubernetes community.
    The exam outline specifically mentions prominent design patterns: the init container,
    the sidecar container, and others. We’ll get a good grasp of their application
    with the help of representative examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Multiple Containers in a Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Especially for Kubernetes beginners, how to appropriately design a Pod isn’t
    necessarily apparent. If you read the Kubernetes user documentation and tutorials
    on the internet, you’ll quickly discover that you can create a Pod that runs multiple
    containers at the same time. The question then arises: “Should I deploy my microservices
    stack to a single Pod with multiple containers, or should I create multiple Pods,
    each running a single microservice?” The short answer is to operate a single microservice
    per Pod. This modus operandi promotes a decentralized, decoupled, and distributed
    architecture. Furthermore, it helps with rolling out new versions of a microservice
    without necessarily interrupting other parts of the system.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what’s the point of running multiple containers in a Pod? There are two
    common use cases. Sometimes, you’ll want to initialize your Pod by executing setup
    scripts, commands, or any other kind of preconfiguration procedure before the
    application container should start. This logic runs in an init container. Other
    times, you’ll want to provide helper functionality that runs alongside the application
    container to avoid the need to bake the logic into application code. For example,
    you may want to massage the log output produced by the application. Containers
    running helper logic are called *sidecars*.
  prefs: []
  type: TYPE_NORMAL
- en: Init Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Init containers* provide initialization logic concerns to be run before the
    main application starts. To draw an analogy, let’s look at a similar concept in
    programming languages. Many programming languages, especially object-oriented
    ones like Java or C++, come with a constructor or a static method block. Those
    language constructs initialize fields, validate data, and set the stage before
    a class can be created. Not all classes need a constructor, but they are equipped
    with the capability.'
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, this functionality can be achieved with the help of init containers.
    Init containers are always started before the main application containers, which
    means they have their own life cycle. To split up the initialization logic, you
    can even distribute the work into multiple init containers that are run in the
    order of definition in the manifest. Of course, initialization logic can fail.
    If an init container produces an error, the whole Pod is restarted, causing all
    init containers to run again in sequential order. Thus, to prevent any side effects,
    making init container logic idempotent is a good practice. [Figure 8-1](#init_containers)
    shows a Pod with two init containers and the main application.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0801](Images/ckd2_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Sequential and atomic life cycle of init containers in a Pod
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the past couple of chapters, we’ve explored how to define a container within
    a Pod: you simply specify its configuration under `spec.containers`. For init
    containers, Kubernetes provides a separate section: `spec.initContainers`. Init
    containers are always executed before the main application containers, regardless
    of the definition order in the manifest.'
  prefs: []
  type: TYPE_NORMAL
- en: The manifest shown in [Example 8-1](#init_container_pod) defines an init container
    and a main application container. For the most part, init containers use the same
    attributes as regular containers. There’s one big difference, however. They cannot
    define probes, discussed in [Chapter 14](ch14.xhtml#container_probes). The init
    container sets up a configuration file in the directory */usr/shared/app*. This
    directory has been shared through a Volume so that it can be referenced by a Node.js-based
    application running in the main container.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. A Pod defining an init container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When starting the Pod, you’ll see that the status column of the `get` command
    provides information on init containers as well. The prefix `Init:` signifies
    that an init container is in the process of being executed. The status portion
    after the colon character shows the number of init containers completed versus
    the overall number of init containers configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Errors can occur during the execution of init containers. If any container fails
    in the sequential initialization chain, then the whole Pod will fail to start.
    You can always retrieve the logs of an init container by using the `--container`
    command-line option (or `-c` in its short form), as shown in [Figure 8-2](#target_container).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0802](Images/ckd2_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Targeting a specific container
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following command renders the logs of the `configurer` init container,
    which equates to the `echo` command we configured in the YAML manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The Sidecar Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The life cycle of an init container looks like this: it starts up, runs its
    logic, then terminates once the work has been done. Init containers are not meant
    to keep running over a longer period of time. But some scenarios call for a different
    usage pattern. For example, you may want to create a Pod that runs multiple containers
    continuously alongside one another.'
  prefs: []
  type: TYPE_NORMAL
- en: Sidecar containers introduced in Kubernetes 1.29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Future exams using Kubernetes 1.29 or higher may cover the formalized [sidecar
    container](https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/).
    Sidecar containers are secondary containers that will start with the Pod and remain
    running during the entire life of the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, there are two different categories of containers: the container
    that runs the application and another container that provides helper functionality
    to the primary application. In the Kubernetes space, the container providing helper
    functionality is called a sidecar. The most commonly used capabilities of a sidecar
    container include file synchronization, logging, and watcher capabilities. The
    sidecars are not part of the main traffic or API of the primary application. They
    usually operate asynchronously and are not involved in the public API.'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the behavior of a sidecar, consider the following use case. The
    main application container runs a web server—in this case, NGINX. Once started,
    the web server produces two standard logfiles. The file */var/log/nginx/access.log*
    captures requests to the web server’s endpoint. The other file, */var/log/nginx/error.log*,
    records failures while processing incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the Pod’s functionality, we want to implement a monitoring service.
    The sidecar container polls the file’s *error.log* periodically and checks if
    any failures have been discovered. More specifically, the service tries to find
    failures assigned to the error log level, indicated by `[error]` in the log file.
    If an error is found, the monitoring service will react to it. For example, it
    could send a notification to the system administrators. We want to keep the functionality
    as simple as possible. The monitoring service will simply render an error message
    to standard output. The file exchange between the main application container and
    the sidecar container happens through a Volume, as shown in [Figure 8-3](#sidecar_pattern).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0803](Images/ckd2_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. The sidecar pattern in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The YAML manifest shown in [Example 8-2](#sidecar_pattern_pod) sets up the described
    scenario. The trickiest portion of the code is the lengthy bash command. This
    command runs an infinite loop. As part of each iteration, we inspect the contents
    of the file *error.log*, *grep* for an error and potentially act on it. The loop
    executes every 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2\. An exemplary sidecar pattern implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When starting up the Pod, you’ll notice that the overall number of containers
    will show 2\. After all containers can be started, the Pod signals a `Running`
    status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find that *error.log* does not contain any failure to begin with.
    It starts out as an empty file. With the following commands, you’ll provoke an
    error on purpose. After waiting for at least 10 seconds, you’ll find the expected
    message on the terminal, which you can query for with the `logs` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Adapter Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As application developers, we want to focus on implementing business logic.
    For example, as part of a two-week sprint, we’re tasked with adding a shopping
    cart feature. In addition to the functional requirements, we also have to think
    about operational aspects such as exposing administrative endpoints or crafting
    meaningful and properly formatted log output. It’s easy to fall into the habit
    of rolling all aspects into the application code, which makes it more complex
    and harder to maintain. Cross-cutting concerns in particular need to be replicated
    across multiple applications and are often copied and pasted from one code base
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, we can avoid bundling cross-cutting concerns into the application
    code by running them in another container apart from the main application container.
    The adapter pattern transforms the output produced by the application to make
    it consumable in the format needed by another part of the system. [Figure 8-4](#adapter_pattern)
    illustrates a concrete example of the adapter pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0804](Images/ckd2_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. The adapter pattern in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The business application running the main container produces timestamped information—in
    this case, the available disk space—and writes it to the file *diskspace.txt*.
    As part of the architecture, we want to consume the file from a third-party monitoring
    application. The problem is that the external application requires the information
    to exclude the timestamp. Of course, we could change the logging format to avoid
    writing the timestamp, but what if we actually want to know when the log entry
    has been written? This is where the adapter pattern can help. A sidecar container
    executes transformation logic that turns the log entries into the format needed
    by the external system without having to change application logic.
  prefs: []
  type: TYPE_NORMAL
- en: The YAML manifest in [Example 8-3](#adapter_pattern_pod) illustrates what this
    implementation of the adapter pattern could look like. The `app` container produces
    a new log entry every five seconds. The `transformer` container consumes the contents
    of the file, removes the timestamp, and writes it to a new file. Both containers
    have access to the same mount path through a Volume.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. An exemplary adapter pattern implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After creating the Pod, we’ll find two running containers. We should be able
    to locate the original file, */var/logs/diskspace.txt*, after shelling into the
    `transformer` container. The transformed data exists in a separate file in the
    user home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Ambassador Pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another important design pattern covered by the CKAD is the ambassador pattern.
    The ambassador pattern provides a proxy for communicating with external services.
  prefs: []
  type: TYPE_NORMAL
- en: Many use cases can justify the introduction of the ambassador pattern. The overarching
    goal is to hide and/or abstract the complexity of interacting with other parts
    of the system. Typical responsibilities include retry logic upon a request failure,
    security concerns such as providing authentication or authorization, and monitoring
    latency or resource usage. [Figure 8-5](#ambassador_pattern) illustrates this
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 0805](Images/ckd2_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. The ambassador pattern in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, we’ll want to implement rate-limiting functionality for HTTP(S)
    calls to an external service. For example, the requirements for the rate limiter
    could say that an application can make a maximum of 5 calls every 15 minutes.
    Instead of strongly coupling the rate-limiting logic to the application code,
    it will be provided by an ambassador container. Any calls made from the business
    application need to be funneled through the ambassador container. [Example 8-4](#rate_limiter_implementation)
    shows a Node.js-based rate limiter implementation that makes calls to the external
    service [Postman](https://www.postman.com).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4\. Node.js HTTP rate limiter implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding Pod shown in [Example 8-5](#ambassador_pattern_pod) runs the
    main application container on a different port than the ambassador container.
    Every call to the HTTP endpoint of the container named `business-app` would delegate
    to the HTTP endpoint of the container named `ambassador`. It’s important to mention
    that containers running inside of the same Pod can communicate via `localhost`.
    No additional networking configuration is required.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5\. An exemplary ambassador pattern implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test the functionality. First, we’ll create the Pod, shell into the container
    that runs the business application, and execute a series of `curl` commands. The
    first five calls will be allowed to the external service. On the sixth call, we’ll
    receive an error message, as the rate limit has been reached within the given
    time frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Real-world scenarios call for running multiple containers inside of a Pod. An
    init container helps with setting the stage for the main application container
    by executing initializing logic. Once the initialized logic has been processed,
    the container will be terminated. The main application container starts only if
    the init container ran through its functionality successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Other design patterns that involve multiple containers per Pod are the adapter
    pattern and the ambassador pattern. The adapter pattern helps with “translating”
    data produced by the application so that it becomes consumable by third-party
    services. The ambassador pattern acts as a proxy for the application container
    when communicating with external services by abstracting the “how.”
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand the need for running multiple containers in a Pod
  prefs: []
  type: TYPE_NORMAL
- en: Pods can run multiple containers. You will need to understand the difference
    between init containers and sidecar containers and their respective life cycles.
    Practice accessing a specific container in a multi-container Pod with the help
    of the command-line option `--container` or `-c`.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to create an init container
  prefs: []
  type: TYPE_NORMAL
- en: Init containers see a lot of use in enterprise Kubernetes cluster environments.
    Understand the need for using them in their respective scenarios. Practice defining
    a Pod with one or even more init containers and observe their linear execution
    when creating the Pod. It’s important to experience the behavior of a Pod in failure
    situations that occur in an init container.
  prefs: []
  type: TYPE_NORMAL
- en: Understand multi-container design patterns and how to implement them
  prefs: []
  type: TYPE_NORMAL
- en: Multi-container Pods are best understood by implementing a scenario for one
    of the established patterns. Based on what you’ve learned, come up with your own
    applicable use case and create a multi-container Pod to solve it. It’s helpful
    to be able to identify sidecar patterns and understand why they are important
    in practice and how to stand them up yourself. As you implement your own sidecars,
    you may notice that you have to brush up on your knowledge of bash.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_004.xhtml#appendix_a_multicontainer_pods).
  prefs: []
  type: TYPE_NORMAL
- en: Create a YAML manifest for a Pod named `complex-pod`. The main application container
    named `app` should use the image `nginx:1.25.1` and expose the container port
    80\. Modify the YAML manifest so that the Pod defines an init container named
    `setup` that uses the image `busybox:1.36.1`. The init container runs the command
    `wget -O- google.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the Pod from the YAML manifest.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Download the logs of the init container. You should see the output of the `wget`
    command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open an interactive shell to the main application container and run the `ls`
    command. Exit out of the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Force-delete the Pod.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a YAML manifest for a Pod named `data-exchange`. The main application
    container named `main-app` should use the image `busybox:1.36.1`. The container
    runs a command that writes a new file every 30 seconds in an infinite loop in
    the directory */var/app/data*. The filename follows the pattern *{counter++}-data.txt*.
    The variable counter is incremented every interval and starts with the value 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the YAML manifest by adding a sidecar container named `sidecar`. The
    sidecar container uses the image `busybox:1.36.1` and runs a command that counts
    the number of files produced by the `main-app` container every 60 seconds in an
    infinite loop. The command writes the number of files to standard output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Define a Volume of type `emptyDir`. Mount the path */var/app/data* for both
    containers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the Pod. Tail the logs of the sidecar container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delete the Pod.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
