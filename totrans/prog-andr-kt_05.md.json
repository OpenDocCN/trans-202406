["```\nclass A {\n    var aList: MutableList<Int> = ArrayList()\n    private set\n\n    fun add() {\n        val last = aList.last()  // equivalent of aList[aList.size - 1]\n        aList.add(last + 1)\n    }\n\n    init {\n        aList.add(1)\n    }\n}\n```", "```\nclass A {\n    var list =\n        Collections.synchronizedList<Int>(object : ArrayList<Int?>() {\n            init {\n                add(1)\n            }\n        })\n\n    fun add() {\n        val last = list.last()\n        list.add(last + 1)\n    }\n}\n```", "```\nclass A {\n    List<Integer> list = Collections.synchronizedList(\n        new ArrayList<Integer>() {{\n           add(1);\n        }}\n    );\n\n    void add() {\n        Integer last = list.get(list.size() - 1);\n        list.add(last + 1);\n    }\n}\n```", "```\nvar list: List<Int> = CopyOnWriteArrayList(listOf(1))\n```", "```\nList<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(1));\n```", "```\nclass A {\n    val list: MutableList<Int> = mutableListOf(1)\n\n    @Synchronized\n    fun add() {\n        val last = list.last()\n        list.add(last + 1)\n    }\n}\n```", "```\npublic class A {\n    private List<Integer> list = new ArrayList<Integer>() {{\n        add(1);\n    }};\n\n    synchronized void add() {\n        Integer last = list.get(list.size() - 1);\n        list.add(last + 1);\n    }\n}\n```", "```\nvoid add() {\n    synchronized(this) {\n        val last = list.last()\n        list.add(last + 1)\n    }\n}\n```", "```\nprivate val myConnection =\n        object : ThreadLocal<Connection>() {\n            override fun initialValue(): Connection? {\n                return DriverManager.getConnection(connectionStr)\n            }\n        }\n```", "```\nclass WorkerPool {\n    private val workLock = Any() // In Java, we would have used `new Object()`\n\n    fun work() {\n        synchronized(workLock) {\n            try {\n                Thread.sleep(1000) // simulate CPU-intensive task\n            } catch (e: Exception) {\n                e.printStackTrace()\n            }\n        }\n    }\n\n    // other methods which may use the intrinsic lock\n}\n```", "```\nfun main() {\n    val workQueue = LinkedBlockingQueue<Int>(5)  // queue of size 5\n\n    val producer = thread {\n        while (true) {\n            /* Inserts one element at the tail of the queue,\n * waiting if necessary for space to become available. */\n            workQueue.put(1)\n            println(\"Producer added a new element to the queue\")\n        }\n    }\n\n    val consumer = thread {\n        while (true) {\n            // We have a slow consumer - it sleeps at each iteration\n            Thread.sleep(1000)\n            workQueue.take()\n            println(\"Consumer took an element out of the queue\")\n        }\n    }\n}\n```", "```\nProducer added a new element to the queue\nProducer added a new element to the queue\nProducer added a new element to the queue\nProducer added a new element to the queue\nProducer added a new element to the queue\nConsumer took an element out of the queue\nProducer added a new element to the queue\nConsumer took an element out of the queue\nProducer added a new element to the queue\n...\n```"]