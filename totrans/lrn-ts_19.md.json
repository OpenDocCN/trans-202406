["```\ntype NewType = {\n    [K in OriginalType]: NewProperty;\n};\n```", "```\ntype Animals = \"alligator\" | \"baboon\" | \"cat\";\n\ntype AnimalCounts = {\n    [K in Animals]: number;\n};\n// Equivalent to:\n// {\n//   alligator: number;\n//   baboon: number;\n//   cat: number;\n// }\n```", "```\ninterface AnimalVariants {\n    alligator: boolean;\n    baboon: number;\n    cat: string;\n}\n\ntype AnimalCounts = {\n    [K in keyof AnimalVariants]: number;\n};\n// Equivalent to:\n// {\n//   alligator: number;\n//   baboon: number;\n//   cat: number;\n// }\n```", "```\ninterface BirdVariants {\n    dove: string;\n    eagle: boolean;\n}\n\ntype NullableBirdVariants = {\n    [K in keyof BirdVariants]: BirdVariants[K] | null,\n};\n// Equivalent to:\n// {\n//   dove: string | null;\n//   eagle: boolean | null;\n// }\n```", "```\ninterface Researcher {\n    researchMethod(): void;\n    researchProperty: () => string;\n}\n\ntype JustProperties<T> = {\n    [K in keyof T]: T[K];\n};\n\ntype ResearcherProperties = JustProperties<Researcher>;\n// Equivalent to:\n// {\n//   researchMethod: () => void;\n//   researchProperty: () => string;\n// }\n```", "```\ninterface Environmentalist {\n    area: string;\n    name: string;\n}\n\ntype ReadonlyEnvironmentalist = {\n    readonly [K in keyof Environmentalist]: Environmentalist[K];\n};\n// Equivalent to:\n// {\n//   readonly area: string;\n//   readonly name: string;\n// }\n\ntype OptionalReadonlyEnvironmentalist = {\n    [K in keyof ReadonlyEnvironmentalist]?: ReadonlyEnvironmentalist[K];\n};\n// Equivalent to:\n// {\n//   readonly area?: string;\n//   readonly name?: string;\n// }\n```", "```\ninterface Conservationist {\n    name: string;\n    catchphrase?: string;\n    readonly born: number;\n    readonly died?: number;\n}\n\ntype WritableConservationist = {\n    -readonly [K in keyof Conservationist]: Conservationist[K];\n};\n// Equivalent to:\n// {\n//   name: string;\n//   catchphrase?: string;\n//   born: number;\n//   died?: number;\n// }\n\ntype RequiredWritableConservationist = {\n    [K in keyof WritableConservationist]-?: WritableConservationist[K];\n};\n// Equivalent to:\n// {\n//   name: string;\n//   catchphrase: string;\n//   born: number;\n//   died: number;\n// }\n```", "```\ntype MakeReadonly<T> = {\n    readonly [K in keyof T]: T[K];\n}\n\ninterface Species {\n    genus: string;\n    name: string;\n}\n\ntype ReadonlySpecies = MakeReadonly<Species>;\n// Equivalent to:\n// {\n//   readonly genus: string;\n//   readonly name: string;\n// }\n```", "```\ninterface GenusData {\n    family: string;\n    name: string;\n}\n\ntype MakeOptional<T> = {\n    [K in keyof T]?: T[K];\n}\n// Equivalent to:\n// {\n//   family?: string;\n//   name?: string;\n// }\n\n/**\n * Spreads any {overrides} on top of default values for GenusData.\n */\nfunction createGenusData(overrides?: MakeOptional<GenusData>): GenusData {\n    return {\n        family: 'unknown',\n        name: 'unknown',\n        ...overrides,\n    }\n}\n```", "```\nLeftType extends RightType ? IfTrue : IfFalse\n```", "```\n// Type: false\ntype CheckStringAgainstNumber = string extends number ? true : false;\n```", "```\ntype CheckAgainstNumber<T> = T extends number ? true : false;\n\n// Type: false\ntype CheckString = CheckAgainstNumber<'parakeet'>;\n\n// Type: true\ntype CheckString = CheckAgainstNumber<1891>;\n\n// Type: true\ntype CheckString = CheckAgainstNumber<number>;\n```", "```\ntype CallableSetting<T> =\n    T extends () => any\n        ? T\n        : () => T\n\n// Type: () => number[]\ntype GetNumbersSetting = CallableSetting<() => number[]>;\n\n// Type: () => string\ntype StringSetting = CallableSetting<string>;\n```", "```\ninterface QueryOptions {\n  throwIfNotFound: boolean;\n}\n\ntype QueryResult<Options extends QueryOptions> =\n  Options[\"throwIfNotFound\"] extends true ? string : string | undefined;\n\ndeclare function retrieve<Options extends QueryOptions>(\n    key: string,\n    options?: Options,\n): Promise<QueryResult<Options>>;\n\n// Returned type: string | undefined\nawait retrieve(\"BirutÃ© Galdikas\");\n\n// Returned type: string | undefined\nawait retrieve(\"Jane Goodall\", { throwIfNotFound: Math.random() > 0.5 });\n\n// Returned type: string\nawait retrieve(\"Dian Fossey\", { throwIfNotFound: true });\n```", "```\ntype ArrayifyUnlessString<T> = T extends string ? T : T[];\n\n// Type: string | number[]\ntype HalfArrayified = ArrayifyUnlessString<string | number>;\n```", "```\ntype ArrayItems<T> =\n    T extends (infer Item)[]\n        ? Item\n        : T;\n\n// Type: string\ntype StringItem = ArrayItems<string>;\n\n// Type: string\ntype StringArrayItem = ArrayItems<string[]>;\n\n// Type: string[]\ntype String2DItem = ArrayItems<string[][]>;\n```", "```\ntype ArrayItemsRecursive<T> =\n    T extends (infer Item)[]\n        ? ArrayItemsRecursive<Item>\n        : T;\n\n// Type: string\ntype StringItem = ArrayItemsRecursive<string>;\n\n// Type: string\ntype StringArrayItem = ArrayItemsRecursive<string[]>;\n\n// Type: string\ntype String2DItem = ArrayItemsRecursive<string[][]>;\n```", "```\ntype MakeAllMembersFunctions<T> = {\n    [K in keyof T]: T[K] extends (...args: any[]) => any\n        ? T[K]\n        : () => T[K]\n};\n\ntype MemberFunctions = MakeAllMembersFunctions<{\n    alreadyFunction: () => string,\n    notYetFunction: number,\n}>;\n// Type:\n// {\n//   alreadyFunction: () => string,\n//   notYetFunction: () => number,\n// }\n```", "```\ntype NeverIntersection = never & string; // Type: never\ntype NeverUnion = never | string; // Type: string\n```", "```\ntype OnlyStrings<T> = T extends string ? T : never;\n\ntype RedOrBlue = OnlyStrings<\"red\" | \"blue\" | 0 | false>;\n// Equivalent to: \"red\" | \"blue\"\n```", "```\ntype FirstParameter<T extends (...args: any[]) => any> =\n    T extends (arg: infer Arg) => any\n        ? Arg\n        : never;\n\ntype GetsString = FirstParameter<\n    (arg0: string) => void\n>; // Type: string\n```", "```\ntype OnlyStringProperties<T> = {\n  [K in keyof T]: T[K] extends string ? K : never;\n}[keyof T];\n\ninterface AllEventData {\n    participants: string[];\n    location: string;\n    name: string;\n    year: number;\n}\n\ntype OnlyStringEventData = OnlyStringProperties<AllEventData>;\n// Equivalent to: \"location\" | \"name\"\n```", "```\ntype Greeting = `Hello${string}`;\n\nlet matches: Greeting = \"Hello, world!\"; // Ok\n\nlet outOfOrder: Greeting = \"World! Hello!\";\n//  ~~~~~~~~~~\n// Error: Type '\"World! Hello!\"' is not assignable to type '`Hello ${string}`'.\n\nlet missingAltogether: Greeting = \"hi\";\n//  ~~~~~~~~~~~~~~~~~\n// Error: Type '\"hi\"' is not assignable to type '`Hello ${string}`'.\n```", "```\ntype Brightness = \"dark\" | \"light\";\ntype Color =  \"blue\" | \"red\";\n\ntype BrightnessAndColor = `${Brightness}-${Color}`;\n// Equivalent to: \"dark-red\" | \"light-red\" | \"dark-blue\" | \"light-blue\"\n\nlet colorOk: BrightnessAndColor = \"dark-blue\"; // Ok\n\nlet colorWrongStart: BrightnessAndColor = \"medium-blue\";\n//  ~~~~~~~~~~~~~~~\n// Error: Type '\"medium-blue\"' is not assignable to type\n// '\"dark-blue\" | \"dark-red\" | \"light-blue\" | \"light-red\"'.\n\nlet colorWrongEnd: BrightnessAndColor = \"light-green\";\n//  ~~~~~~~~~~~~~\n// Error: Type '\"light-green\"' is not assignable to type\n// '\"dark-blue\" | \"dark-red\" | \"light-blue\" | \"light-red\"'.\n```", "```\ntype ExtolNumber = `much ${number} wow`;\n\nfunction extol(extolee: ExtolNumber) { /* ... */ }\n\nextol('much 0 wow'); // Ok\nextol('much -7 wow'); // Ok\nextol('much 9.001 wow'); // Ok\n\nextol('much false wow');\n//    ~~~~~~~~~~~~~~~~\n// Error: Argument of type '\"much false wow\"' is not\n// assignable to parameter of type '`much ${number} wow`'.\n```", "```\ntype FormalGreeting = Capitalize<\"hello.\">; // Type: \"Hello.\"\n```", "```\ntype DataKey = \"location\" | \"name\" | \"year\";\n\ntype ExistenceChecks = {\n    [K in `check${Capitalize<DataKey>}`]: () => boolean;\n};\n// Equivalent to:\n// {\n//   checkLocation: () => boolean;\n//   checkName: () => boolean;\n//   checkYear: () => boolean;\n// }\n\nfunction checkExistence(checks: ExistenceChecks) {\n    checks.checkLocation(); // Type: boolean\n    checks.checkName(); // Type: boolean\n\n    checks.checkWrong();\n    //     ~~~~~~~~~~\n    // Error: Property 'checkWrong' does not exist on type 'ExistenceChecks'.\n}\n```", "```\ninterface DataEntry<T> {\n    key: T;\n    value: string;\n}\n\ntype DataKey = \"location\" | \"name\" | \"year\";\n\ntype DataEntryGetters = {\n    [K in DataKey as `get${Capitalize<K>}`]: () => DataEntry<K>;\n};\n// Equivalent to:\n// {\n//   getLocation: () => DataEntry<\"location\">;\n//   getName: () => DataEntry<\"name\">;\n//   getYear: () => DataEntry<\"year\">;\n// }\n```", "```\nconst config = {\n    location: \"unknown\",\n    name: \"anonymous\",\n    year: 0,\n};\n\ntype LazyValues = {\n    [K in keyof typeof config as `${K}Lazy`]: () => Promise<typeof config[K]>;\n};\n// Equivalent to:\n// {\n//   location: Promise<string>;\n//   name: Promise<string>;\n//   year: Promise<number>;\n// }\n\nasync function withLazyValues(configGetter: LazyValues) {\n    await configGetter.locationLazy; // Resultant type: string\n\n    await configGetter.missingLazy();\n    //                 ~~~~~~~~~~~\n    // Error: Property 'missingLazy' does not exist on type 'LazyValues'.\n};\n```", "```\ntype TurnIntoGettersDirect<T> = {\n    [K in keyof T as `get${K}`]: () => T[K]\n    //                     ~\n    // Error: Type 'keyof T' is not assignable to type\n    // 'string | number | bigint | boolean | null | undefined'.\n    //   Type 'string | number | symbol' is not assignable to type\n    //   'string | number | bigint | boolean | null | undefined'.\n    //     Type 'symbol' is not assignable to type\n    //     'string | number | bigint | boolean | null | undefined'.\n};\n```", "```\nconst someSymbol = Symbol(\"\");\n\ninterface HasStringAndSymbol {\n    StringKey: string;\n    [someSymbol]: number;\n}\n\ntype TurnIntoGetters<T> = {\n    [K in keyof T as `get${string & K}`]: () => T[K]\n};\n\ntype GettersJustString = TurnIntoGetters<HasStringAndSymbol>;\n// Equivalent to:\n// {\n//     getStringKey: () => string;\n// }\n```"]