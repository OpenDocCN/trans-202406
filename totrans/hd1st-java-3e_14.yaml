- en: 'Chapter 12\. Lambdas and Streams: What, Not How: Lambdas and Streams'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0369-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**What if...you didn’t need to tell the computer HOW to do something?** Programming
    involves a lot of telling the computer how to do something: **while** this is
    true **do** this thing; **for** all these items **if** it looks like this **then**
    do this; and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also seen that we don’t have to do everything ourselves. The JDK contains
    library code, like the Collections API we saw in the previous chapter, that we
    can use instead of writing everything from scratch. This library code isn’t just
    limited to collections to put data into; there are methods that will do common
    tasks for us, so we just need to tell them **what** we want and not **how** to
    do it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we’ll look at the Streams API. You’ll see how helpful lambda
    expressions can be when you’re using streams, and you’ll learn how to use the
    Streams API to query and transform the data in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Tell the computer WHAT you want
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you have a list of colors, and you wanted to print out all the colors.
    You could use a for loop to do this.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0370-01.png)'
  prefs: []
  type: TYPE_IMG
- en: But doing something to every item in a list is a really common thing to want
    to do. So instead of creating a for loop every time we want to do something “for
    each” item in the list, we can call the **`forEach`** method from the Iterable
    interface—remember, List implements Iterable so it has all the methods from the
    Iterable interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0370-02.png)![image](Images/f0370-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The forEach method of a list takes a lambda expression, which we saw for
    the first time in the previous chapter. This is a way for you to pass behavior
    (“follow these instructions”) into a method, instead of passing an object containing
    data (“here is an object for you to use”).**'
  prefs: []
  type: TYPE_NORMAL
- en: Fireside Chats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0304-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tonight’s Talk: **The for loop and forEach method battle over the question,
    “Which is better?”**'
  prefs: []
  type: TYPE_NORMAL
- en: '| forEach() | for loop |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| I am the default! The for loop is so important that loads of programming
    languages have me. It’s one of the first things a programmer learns! If someone
    needs to loop a set number of times to do something, they’re going to reach for
    their trusty for loop. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Pff. Please. You are *so old*; that’s why you’re in all the programming
    languages. But things change, languages evolve. There’s a better way. A more modern
    way. Me. |'
  prefs: []
  type: TYPE_TB
- en: '| Sure, fashions change. But sometimes it’s just a fad; things fall out of
    fashion too. A classic like me will be easy to read and write forever, even for
    non-Java programmers. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | But look how much work developers need to do to write you! They have to
    control when to start, increment, and stop the loop, as well as writing the code
    that needs to be run inside the loop. All sorts of things could go wrong! If they
    use me, they just have to think about what needs to happen to each item, they
    don’t have to worry about how to loop to find each item. |'
  prefs: []
  type: TYPE_TB
- en: '| So much work?! Ha! A developer isn’t scared of a little syntax to clearly
    specify what to do and how to do it. At least with me, someone reading my code
    can clearly see what’s going on. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Dude, they shouldn’t *have* to see what’s going on. It says very clearly
    in my method name exactly what I do—“for each” element I will apply the logic
    they specify. Job done. |'
  prefs: []
  type: TYPE_TB
- en: '| Well I’m faster. Everyone knows that. |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | Well actually, under the covers I’m using a for loop myself, but if something
    is invented later that’s even faster, I can use that, and developers don’t have
    to change a single thing to get faster code. In fact we’re out of time now so....
    |'
  prefs: []
  type: TYPE_TB
- en: '| I said you would disappear soon. |  |'
  prefs: []
  type: TYPE_TB
- en: When for loops go wrong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using **`forEach`** instead of a for loop means a bit less typing, and it’s
    also nice to focus on telling the compiler *what* you want to do and not *how*
    to do it. There’s another advantage to letting the libraries take care of routine
    code like this—it can mean fewer accidental errors.
  prefs: []
  type: TYPE_NORMAL
- en: Mixed Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0372-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A short Java program is listed below. One block of the program is missing. We
    expect the output of the program should be “1 2 3 4 5” but sometimes it’s difficult
    to get a for loop just right.
  prefs: []
  type: TYPE_NORMAL
- en: Your challenge is to **match the candidate block of code** (on the left) **with
    the output** that you’d see if the block were inserted. Not all the lines of output
    will be used, and some of the lines of output might be used more than once.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0372-02.png)![image](Images/f0372-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr1.png) **Answers in [“Mixed Messages”](#mixed_messages_left_parenthesisf-id00001).**'
  prefs: []
  type: TYPE_NORMAL
- en: Small errors in common code can be hard to spot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The for loops from the previous exercise all look quite similar, and at first
    glance they all look like they would print out all the values in the List in order.
    Compiler errors can be easiest to spot, because your IDE or compiler will tell
    you the code is wrong, and Exceptions (which we’ll see in [Chapter 13](ch13.xhtml#risky_behavior_exception_handling),
    *Risky Behavior*) can also point to a problem in the code. But it can be trickier
    to spot code that produces incorrect output just by looking at the code.
  prefs: []
  type: TYPE_NORMAL
- en: Using a method like **`forEach`** takes care of the “boilerplate,” the repetitive
    and common code like the for loop. Using forEach, passing in only the thing we
    want to do, can reduce accidental errors in our code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0373-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Yes absolutely, in fact Java 8 introduced a whole API just for this.**'
  prefs: []
  type: TYPE_NORMAL
- en: Java 8 introduced the *Streams API*, a new set of methods that can be used on
    many classes, including the Collections classes we looked at in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Streams API isn’t just a bunch of helpful methods, but also a slightly different
    way of working. It lets us build up a whole set of requirements, a recipe if you
    like, of what we want to know about our data.
  prefs: []
  type: TYPE_NORMAL
- en: Building blocks of common operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ways we search our collections, and the types of information we want to
    output from those collections, can be quite similar even on different types of
    collections containing different types of Objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine what you might want do to with a Collection: “give me just the items
    that meet some criteria,” “change all the items using these steps,” “remove all
    duplicates,” and the example we worked through in the previous chapter: “sort
    the elements in this way.”'
  prefs: []
  type: TYPE_NORMAL
- en: It’s not too hard to go one step further and assume each of these collection
    operations could be given a name that tells us what will happen to our collection.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Streams API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Streams API is a set of operations we can perform on a collection, so when
    we read these operations in our code, we can understand what we’re trying to do
    with the collection data. If you were successful in the “Who Does What?” exercise
    on the previous page (the complete answers are at the end of this chapter), you
    should have seen that the names of the operations describe what they do.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0375-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Streams, and lambda expressions, were introduced in Java 8.**'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start going into detail about what the Streams API is, what it does,
    and how to use it, we’re going to give you some very basic tools to start experimenting.
  prefs: []
  type: TYPE_NORMAL
- en: To use the Streams methods, we need a Stream object (obviously). If we have
    a collection like a List, this doesn’t implement Stream. However, the Collection
    interface has a method, **`stream`**, which returns a Stream object for the Collection.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0376-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we can call the methods of the Streams API. For example, we could use **limit**
    to say we want a maximum of four elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0376-02.png)'
  prefs: []
  type: TYPE_IMG
- en: What happens if we try to print out the result of calling limit()?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0376-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Like everything in Java, the stream variables in the example are Objects. But
    a stream does ***not*** contain the elements in the collection. It’s more like
    the set of instructions for the operations to perform on the Collection data.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Stream methods that return another Stream are called Intermediate Operations.
    These are instructions of things to do, but they don’t actually perform the operation
    on their own.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0377-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Streams are like recipes: nothing’s going to happen until someone actually
    cooks them'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recipe in a book only tells someone *how* to cook or bake something. Opening
    the recipe doesn’t automatically present you with a freshly baked chocolate cake.
    You need to gather the ingredients according to the recipe and follow the instructions
    exactly to come up with the result you want.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0377-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Collections are not ingredients, and a list limited to four entries is not a
    chocolate cake (sadly). But you do need to call one of the Stream’s “do it” methods
    in order to get the result you want. These “do it” methods are called **Terminal
    Operations**, and these are the methods that will actually return something to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0377-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting a result from a Stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yes, we’ve thrown a **lot** of new words at you: *streams*; *intermediate operations*;
    *terminal operations*... And we still haven’t told you what streams can do!'
  prefs: []
  type: TYPE_NORMAL
- en: To start to get a feel for what we can do with streams, we going to show code
    for a simple use of the Streams API. After that, we’ll step back and learn more
    about what we’re seeing here.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0378-01.png)![image](Images/f0378-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This works, but it’s not very useful. One of the most common things to do with
    Streams is put the results into another type of collection. The API documentation
    for this method might seem intimidating with all the generic types, but the simplest
    case is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0378-03.png)![image](Images/f0378-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we have a result that looks like something we would have expected:
    we had a List of Strings, and we asked to **limit** that list to the first four
    items and then **collect** those four items into a new List.'
  prefs: []
  type: TYPE_NORMAL
- en: Stream operations are building blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We wrote a lot of code just to output the first four elements in the list.
    We also introduced a lot of new terminology: streams, intermediate operations,
    and terminal operations. Let’s put all this together: you create a **stream p****i****peline**
    from three different types of building blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Get the Stream from a **source** collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0379-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) Call zero or more **intermediate operations** on the
    Stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0379-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) Output the results with a **terminal operation**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0379-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: You need at least the ***first*** and ***last*** pieces of the puzzle to use
    the Streams API. However, you don’t need to assign each step to its own variable
    (which we were doing on the last page). In fact, the operations are designed to
    be **chained**, so you can call one stage straight after the previous one, without
    putting each stage in its own variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the last page, all the building blocks for the stream were highlighted (stream,
    limit, count, collect). We can take these building blocks and rewrite the limit-and-collect
    operation in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0379-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Building blocks can be stacked and combined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every intermediate operation acts on a Stream and returns a Stream. That means
    you can stack together as many of these operations as you want, before calling
    a terminal operation to output the results.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0380-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The source, the intermediate operation(s), and the terminal operation all
    combine to form a Stream Pipeline. This pipeline represents a query on the original
    collection.**'
  prefs: []
  type: TYPE_NORMAL
- en: This is where the Streams API becomes really useful. In the earlier example,
    we needed three building blocks (stream, limit, collect) to create a shorter version
    of the original List, which may seem like a lot of work for a simple operation.
  prefs: []
  type: TYPE_NORMAL
- en: But to do something more complicated, we can stack together multiple operations
    in a single **stream pipeline**.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can sort the elements in the stream before we apply the limit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0380-02.png)![image](Images/f0380-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Customizing the building blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can stack together operations to create a more advanced query on our collection.
    We can also customize what the blocks do too. For example, we customized the **`limit`**
    method by passing in the maximum number of items to return (four).
  prefs: []
  type: TYPE_NORMAL
- en: If we didn’t want to use the natural ordering to sort our Strings, we could
    define a specific way to sort them. It’s possible to set the sort criteria for
    the **`sorted`** method (remember, we did something similar in the previous chapter
    when we sorted Lou’s song list).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0381-01.png)![image](Images/f0381-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Create complex pipelines block by block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each new operation you add to the pipeline changes the output from the pipeline.
    Each operations tell the Streams API *what* it is you want to do.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0381-04.png)![image](Images/f0382-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, because Streams are lazy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That doesn’t mean they’re slow or useless! It means that each intermediate operation
    is just the instruction about what to do; it doesn’t perform the instruction itself.
    Intermediate operations are *lazily evaluated*.
  prefs: []
  type: TYPE_NORMAL
- en: The terminal operation is responsible for looking at the whole list of instructions,
    all those intermediate operations in the pipeline, and then running the whole
    set together in one go. Terminal operations are *eager*; they are run as soon
    as they’re called.
  prefs: []
  type: TYPE_NORMAL
- en: This means that in theory it’s possible to run the combination of instructions
    in the most efficient way. Instead of having to iterate over the original collection
    for each and every intermediate operation, it may be possible to do all the operations
    while only going through the data once.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0382-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Terminal operations do all the work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since intermediate operations are *lazy*, it’s up to the terminal operation
    to do everything.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circlea.png) Perform all the intermediate operations as efficiently
    as possible. Ideally, just going through the original data once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/1circleb.png) Work out the result of the operation, which
    is defined by the terminal operation itself. For example, this could be a list
    of values, a single value, or a boolean (true/false).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/1circlec.png) Return the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting to a List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know more about what’s going on in a terminal operation, let’s take
    a closer look at the “magic incantation” that returns a list of results.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0383-01.png)![image](Images/f0383-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Guidelines for working with streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like any puzzle or game, there are rules for getting the stream building blocks
    to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **You need at least the first and last pieces to create
    a stream pipeline.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without the **`stream`****`()`** piece, you don’t get a Stream at all, and without
    the terminal operation, you’re not going to get any results.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0384-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) **You can’t reuse Streams.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It might seem useful to store a Stream representing a query, and reuse it in
    multiple places, either because the query itself is useful or because you want
    to build on it and add to it. But once a terminal operation has been called on
    a stream, you can’t reuse any parts of that stream; you have to create a new one.
    Once a pipeline has executed, that stream is closed and can’t be used in another
    pipeline, even if you stored part of it in a variable for reusing elsewhere. If
    you try to reuse a stream in any way, you’ll get an Exception.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![image](Images/f0384-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) **You can’t change the underlying collection while
    the stream is operating.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do this, you’ll see strange results, or exceptions. Think about it—if
    someone asked you a question about what was in a shopping list and then someone
    else was scribbling on that shopping list at the same time, you’d give confusing
    answers too.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0384-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![image](Images/f0385-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Correct! Stream operations don’t change the original collection.
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Streams API is a way to query a collection, but it **doesn’t make changes**
    to the collection itself. You can use the Streams API to look through that collection
    and return results based on the contents of the collection, but your original
    collection will remain the same as it was.
  prefs: []
  type: TYPE_NORMAL
- en: This is actually very helpful. It means you can query collections and output
    the results from anywhere in your program and know that the data in your original
    collection is safe; it will not be changed (“mutated”) by any of these queries.
  prefs: []
  type: TYPE_NORMAL
- en: You can see this in action by printing out the contents of the original collection
    after using the Streams API to query it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0385-02.png)![image](Images/f0385-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: Code Magnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0386-02.png)'
  prefs: []
  type: TYPE_IMG
- en: A Java program is all scrambled up on the fridge. Can you reconstruct the code
    snippets to make a working Java program that produces the output listed below?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0386-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr1.png) **Answers in [“Code Magnets”](#code_magnets_left_parenthesisfrom_page_3).**'
  prefs: []
  type: TYPE_NORMAL
- en: Hello Lambda, my (not so) old friend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lambda expressions have cropped up in the streams examples so far, and you can
    bet your bottom dollar (or euro, or currency of your choice) that you’re going
    to see more of them before this chapter is done.
  prefs: []
  type: TYPE_NORMAL
- en: Having a better understanding of what lambda expressions are will make it easier
    to work with the Streams API, so let’s take a closer look at lambdas.
  prefs: []
  type: TYPE_NORMAL
- en: Passing behavior around
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wrote a **`forEach`** method, it might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0388-01.png)'
  prefs: []
  type: TYPE_IMG
- en: What would you put in the place where “?????” is? It would need to somehow **be**
    the block of code that’s going to go into that nice, blank square.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you want someone calling the method to be able to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0388-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we need to replace the *do this* with some sort of symbol to represent
    that this code isn’t to be run straightaway, but instead needs to be passed into
    the method. We could use, oh, let’s see... “**`->`**” as this symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Then we need a way to say “look, this code is going to need to work on values
    from elsewhere.” We could put the things the code needs on the left side of the
    “do this” symbol....
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0388-03.png)![image](Images/f0388-04.png)![image](Images/f0389-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Lambda expressions are objects, and you run them by calling their Single Abstract
    Method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, everything in Java is an Object (well, except for the primitive types),
    and lambdas are no exception.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**A lambda expression implements a Functional Interface.**'
  prefs: []
  type: TYPE_NORMAL
- en: This means the reference to the lambda expression is going to be a Functional
    Interface. So, if you want your method to accept a lambda expression, you need
    to have a parameter whose type is a functional interface. That functional interface
    needs to be the right “shape” for your lambda.
  prefs: []
  type: TYPE_NORMAL
- en: Back to our imaginary **`forEach`** example; our parameter needs to implement
    a Functional Interface. We also need to call that lambda expression somehow, passing
    in the list element.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, Functional Interfaces have a Single Abstract Method (SAM). It’s this
    method, whatever its name is, that gets called when we want to run the lambda
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0389-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Lambdas aren’t magic; they’re just classes like everything else.**'
  prefs: []
  type: TYPE_NORMAL
- en: The shape of lambda expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve seen two lambda expressions that implement the Comparator interface:
    the example for sorting Lou’s songs in the previous chapter, and the lambda expression
    we passed into the **`sorted`****`()`** stream operation in [“Customizing the
    building blocks”](#customizing_the_building_blocks). Look at this last example
    side by side with the Comparator Functional Interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0390-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You might be wondering where the **return** keyword is in the lambda expression.
    The short version is: you don’t need it. The longer version is, if the lambda
    expression is a single line, and if the functional interface’s method signature
    requires a returned value, the compiler just assumes that your one line of code
    will generate the value that is to be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The lambda expression can also be written like this, if you want to add all
    the parts a lambda expression can have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Anatomy of a lambda expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you take a closer look at this expanded version of the lambda expression
    that implements `Comparator<String>`, you’ll see it’s not so different from a
    standard Java method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0391-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The shape of the lambda (its parameters, return type, and what it can reasonably
    be expected to do) is dictated by the Functional Interface it implements.
  prefs: []
  type: TYPE_NORMAL
- en: Variety is the spice of life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0392-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Lambda expressions can come in all shapes and sizes, and still conform to the
    same basic rules that we’ve seen.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda might have more than one line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lambda expression is effectively a method, and can have as many lines as any
    other method. Multiline lambda expressions ***must*** be inside curly braces.
    Then, like any other method code, every line ***must*** end in a semicolon, and
    if the method is supposed to return something, the lambda body ***must*** include
    the word “return” like any normal method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0392-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Single-line lambdas don’t need ceremony
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your lambda expression is a single line, it makes it much easier for the
    compiler to guess what’s going on. Therefore, we can leave out a lot of the “boilerplate”
    syntax. If we shrink the lambda expression from the last example into a single
    line, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0392-03.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the same Functional Interface (Comparator) and performs the same operation.
    Whether you use multiline lambdas or single-line lambdas is completely up to you.
    It will probably depend upon how complicated the logic in the lambda expression
    is, and how easy you think it is to read—sometimes longer code can be more descriptive.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we’ll see another approach for handling long lambda expressions.
  prefs: []
  type: TYPE_NORMAL
- en: A lambda might not return anything
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Functional Interface’s method might be declared void; i.e., it doesn’t return
    anything. In these cases, the code inside the lambda is simply run, and you don’t
    need to return any values from the lambda body.
  prefs: []
  type: TYPE_NORMAL
- en: This is the case for lambda expressions in a **`forEach`** method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0393-01.png)'
  prefs: []
  type: TYPE_IMG
- en: A lambda might have zero, one, or many parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The number of parameters the lambda expression needs is dependent upon the number
    of parameters the Functional Interface’s method takes. The parameter types (e.g.,
    the name “String”) are not usually required, but you can add them if you think
    it makes it easier to understand the code. You may need to add the types if the
    compiler can’t automatically work out which Functional Interface your lambda implements.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0393-02.png)'
  prefs: []
  type: TYPE_IMG
- en: How can I tell if a method takes a lambda?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now you’ve seen that lambda expressions are implementations of a functional
    interface—that is, an Interface with a Single Abstract Method. That means the
    **type** of a lambda expression is this interface.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and create a lambda expression. Instead of passing this into some method,
    as we have been doing so far, assign it to a variable. You’ll see it can be treated
    just like any other Object in Java, because everything in Java is an Object. The
    variable’s type is the Functional Interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'How does this help us see if a method takes a lambda expression? Well, the
    method’s parameter type will be a Functional Interface. Take a look at some examples
    from the Streams API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0394-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the Compiler, advanced
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0395-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Your job is to play compiler and determine which of these statements would
    compile. But some of this code wasn’t covered in the chapter, so you need to work
    out the answers based on what you DID learn, applying the “rules” to these new
    situations.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The signatures of the functional interfaces are on the right, for your convenience.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0395-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Check the box if the statement would compile.**'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Images](Images/box.png) | `**Runnable r = () -> System.out.println("Hi!");**`
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Consumer<String> c = s -> System.out.println(s);**`
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Supplier<String> s = () -> System.out.println("Some
    string");**` |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Consumer<String> c = (s1, s2) -> System.out.println(s1
    + s2);**` |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Runnable r = (String str) -> System.out.println(str);**`
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Function<String, Integer> f = s -> s.length();**`
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Supplier<String> s = () -> "Some string";**`
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Consumer<String> c = s -> "String" + s;**`
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Function<String, Integer> f = (int i) -> "i
    = " + i;**` |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Supplier<String> s = s -> "Some string: "
    + s;**` |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | `**Function<String, Integer> f = (String s) ->
    s.length();**` |'
  prefs: []
  type: TYPE_TB
- en: '![Images](Images/arr1.png) **Answers in [“BE the Compiler”](#be_the_compiler_left_parenthesis-id00001).**'
  prefs: []
  type: TYPE_NORMAL
- en: Spotting Functional Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we’ve seen Functional Interfaces that are marked with a **`@FunctionalInterface`**
    *annotation* (we’ll cover annotations in [Appendix B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d)),
    which conveniently tells us this interface has a Single Abstract Method and can
    be implemented with a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: Not all functional interfaces are tagged this way, particularly in older code,
    so it’s useful to understand how to spot a functional interface for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0396-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Not so fast!**'
  prefs: []
  type: TYPE_NORMAL
- en: Originally, the only kind of methods allowed in interfaces were **abstract**
    methods, methods that need to be *overridden* by any class that *implements* this
    interface. But as of Java 8, interfaces can also contain **`default`** and **`static`**
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: You saw static methods in [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics),
    *Numbers Matter*, and you’ll see them later in this chapter too. These are methods
    that don’t need to belong to an instance, and are often used as helper methods.
  prefs: []
  type: TYPE_NORMAL
- en: Default methods are slightly different. Remember abstract classes from [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst),
    *Serious Polymorphism*? They had abstract methods that need to be overridden,
    and standard methods with a body. On an interface, a default method works a bit
    like a standard method in an abstract class—they have a body, and will be inherited
    by subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Both default and static methods have a method body, with defined behavior. With
    interfaces, any method that is not defined as **`default`** or **`static`** is
    an abstract method that *must* be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: Functional interfaces in the wild
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know interfaces can have **non**-abstract methods, we can see there’s
    a bit more of a trick to identifying interfaces with just one abstract method.
    Take a look at our old friend, Comparator. It has a **lot** of methods! And yet
    it’s still a SAM-type; it has only one Single Abstract Method. It’s a Functional
    Interface we can implement as a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0397-01.png)![image](Images/f0398-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Lou’s back!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lou’s been running his new jukebox management software from the last chapter
    for some time now, and he wants to learn so much more about the songs played on
    the diner’s jukebox. Now that he has the data, he wants to slice-and-dice it and
    put it together in a new shape, just as he does with the ingredients of his famous
    Special Omelette!
  prefs: []
  type: TYPE_NORMAL
- en: 'He’s thinking there are all kinds of information he could learn about the songs
    that are played, like:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the top five most-played songs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What sort of genres are played?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there any songs with the same name by different artists?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We *could* find these things out writing a for loop to look at our song data,
    performing checks using if statements, and perhaps putting songs, titles, or artists
    into different collections to find the answers to these questions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**But now that we know about the Streams API, we know there’s an easier way....**'
  prefs: []
  type: TYPE_NORMAL
- en: The code on the next page is your **mock** code; calling **`Songs.getSongs()`**
    will give you a List of Song objects that you can assume looks just like the real
    data from Lou’s jukebox.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: Type in the Ready-Bake Code on the next page, including filling out the rest
    of the Song class. When you’ve done that, create a main method that prints out
    all the songs.
  prefs: []
  type: TYPE_NORMAL
- en: What do you expect the output to look like?
  prefs: []
  type: TYPE_NORMAL
- en: Ready-Bake Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0399-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Here’s an updated “mock” method. It will return some test data that we can use
    on to try out some of the reports Lou wants to create for the jukebox system.
    There’s also an updated Song class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Lou’s Challenge #1: Find all the “rock” songs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data in the updated song list contains the *genre* of the song. Lou’s noticed
    that the diner’s clientele seem to prefer variations on rock music, and he wants
    to see a list of all the songs that fall under some genre of “rock.”
  prefs: []
  type: TYPE_NORMAL
- en: This is the Streams chapter, so clearly the solution is going to involve the
    Streams API. Remember, there are three types of pieces we can put together to
    form a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0400-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Fortunately, there are hints about how to create a Streams API call based on
    the requirements Lou gave us: he wants to **`filter`** for just the Songs with
    a particular genre, and he wants to **`collect`** them into a new List`.`'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0400-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Filter a stream to keep certain elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s see how a filter operation might work on the list of songs.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0401-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s Rock!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So adding a **`filter`** operation filters out elements that we don’t want,
    and the stream continues with just the elements that meet our criteria. It should
    come as no surprise to find that you can use a lambda expression to state which
    elements we want to keep in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: The filter method takes a **`Predicate`**.
  prefs: []
  type: TYPE_NORMAL
- en: Given what we know about the shapes of lambda expressions, we should be able
    to work out how to write a lambda expression that implements Predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0402-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll know what the type of the single parameter is when we plug it into the
    Stream operation, since the input type to the lambda will be determined by the
    types in the stream.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0402-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting clever with filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **`filter`** method, with its “simple” true or false return value, can
    contain sophisticated logic to filter elements in, or out, of the stream. Let’s
    take our filter one step further and actually do what Lou asked:'
  prefs: []
  type: TYPE_NORMAL
- en: '*He wants to see a list of all the songs that fall under* ***some genre***
    *of “rock.**”*'
  prefs: []
  type: TYPE_NORMAL
- en: He doesn’t want to see just the songs that are classed as “Rock,” but any genre
    that is kinda Rock-like. We should search for any genre that has the word “Rock”
    in it somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a method in String that can help us with this, it’s called **`contains`**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0403-01.png)![image](Images/f0403-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Lou’s Challenge #2: List all the genres'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lou now senses that the genres of music that the diners are listening to are
    more complicated than he thought. He wants a list of all the genres of the songs
    that have been played.
  prefs: []
  type: TYPE_NORMAL
- en: So far, all of our streams have returned the same types that they started with.
    The earlier examples were Streams of Strings, and returned Lists of Strings. Lou’s
    previous challenge started with a List of Songs and ended up with a (smaller)
    List of Songs.
  prefs: []
  type: TYPE_NORMAL
- en: Lou now wants a list of genres, which means we need to somehow turn the song
    elements in the stream into genre (String) elements. This is what **`map`** is
    for. The map operation states how to map *from* one type *to* another type.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0404-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Mapping from one type to another
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The map method takes a **`Function`**. The generics by definition are a bit
    vague, which makes it a little tricky to understand, but Functions do one thing:
    they take something of one type and return something of a different type. Exactly
    what’s needed for mapping varies from one type to another.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0405-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s see what it looks like when we use **`map`** in a stream pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0405-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The map’s lambda expression is similar to the one for filter; it takes a song
    and turns it into something else. Instead of returning a boolean, it returns some
    other object, in this case a String containing the song’s genre.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0405-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing duplicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve got a list of all the genres in our test data, but Lou probably doesn’t
    want to wade through all these duplicate genres. The **`map`** operation on its
    own will result in an output List that’s the same size as the input List. Since
    stream operations are designed to be stacked together, perhaps there’s another
    operation we can use to get just one of every element in the stream?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0406-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Only one of every genre
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All we need to do is to add a distinct operation to the stream pipeline, and
    we’ll get just one of each genre.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0407-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Just keep building!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stream pipeline can have any number of intermediate operations. The power
    of the Streams API is that we can build up complex queries with understandable
    building blocks. The library will take care of running this in a way that is as
    efficient as possible. For example, we could create a query that returns a list
    of all the artists that have covered a specific song, excluding the original artists,
    by using a map operation and multiple filters.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes you don’t even need a lambda expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some lambda expressions do something simple and predictable, given the type
    of the parameter or the shape of the functional interface. Look again at the lambda
    expression for the **`map`** operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Method references can replace lambda expressions, but you don’t have to use
    them.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sometimes method references make the code easier to understand.**'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of spelling this whole thing out, you can point the compiler to a method
    that does the operation we want, using a **method reference**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0408-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Method references can replace lambda expressions in a number of different cases.
    Generally, we might use a method reference if it makes the code easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take our old friend the Comparator, for example. There are a lot of helper
    methods on the Comparator interface that, when combined with a method reference,
    let you see which value is being used for sorting and in which direction. Instead
    of doing this, to order the songs from oldest to newest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use a method reference combined with a **`static`** helper method from Comparator
    to state what the comparison should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Collecting results in different ways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While **`Collectors.toList`** is the most commonly used Collector, there are
    other useful Collectors. For example, instead of using **`distinct`** to solve
    the last challenge, we could collect the results into a Set, which does not allow
    duplicates. The advantage of using this approach is that anything else that uses
    the results knows that because it’s a Set, *by definition* there will be no duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0409-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Collectors.toList and Collectors.toUnmodifiableList**'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen **`toList`**. Alternatively, you can get a List that can’t
    be changed (no elements can be added, replaced or removed) by using **`Collectors.toUnmodifableList`**
    instead. This is only available from Java 10 onward.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0409-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Collectors.toSet and Collectors.toUnmodifiableSet**'
  prefs: []
  type: TYPE_NORMAL
- en: Use these to put the results into a Set, rather than a List. Remember that a
    Set cannot contain duplicates, and is not usually ordered. If you’re using Java
    10 or higher, you can use **`Collectors.toUnmodifiableSet`** if you want to make
    sure your results aren’t changed by anything.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0409-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Collectors.toMap and Collectors.toUnmodifiableMap**'
  prefs: []
  type: TYPE_NORMAL
- en: You can collect your stream into a Map of key/value pairs. You will need to
    provide some functions to tell the collector what will be the key and what will
    be the value. You can use **`Collectors.toUnmodifiableMap`** to create a map that
    can’t be changed, from Java 10 onward.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0409-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Collectors.joining**'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a String result from the stream. It will join together all the
    stream elements into a single String. You can optionally define the *delimiter*,
    the character to use to separate each element. This can be very useful if you
    want to turn your stream into a String of Comma Separated Values (CSV).
  prefs: []
  type: TYPE_NORMAL
- en: But wait, there’s more!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collecting the results is not the only game in town; **`collect`** is just one
    of many terminal operations.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if something exists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use terminal operations that return a boolean value to look for certain
    things in the stream. For example, we can see if any R&B songs have been played
    in the diner.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0410-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Find a specific thing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Terminal operations that return an **`Optional`** value look for certain things
    in the stream. For example, we can find the first song played that was released
    in 1995.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0410-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Count the items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s a count operation that you can use to find out the number of elements
    in your stream. We could find the number of unique artists, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**There are even more terminal operations, and some of them depend upon the
    type of Stream you’re working with.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Remember, the API documentation can help you figure out if there’s a built-in
    operation that does what you want.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0411-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, some operations may return something, or may not return anything at all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It might seem weird that a method *may* or *may not* return a value, but it
    happens all the time in real life.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you’re at an ice-cream stand, and you ask for strawberry ice cream.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0411-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Easy, right? But what if they don’t have any strawberry? The ice-cream person
    is likely to tell you “we don’t have that flavor.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0411-03.png)'
  prefs: []
  type: TYPE_IMG
- en: It’s then up to you what you do next—perhaps order chocolate instead, find another
    ice-cream place, or maybe just go home and sulk about your lack of ice cream.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine trying to do this in the Java world. In the first example, you get an
    ice-cream instance. In the second, you get...a String message? But a message doesn’t
    fit into an ice-cream-shaped variable. A null? But what does null really mean?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0411-04.png)![image](Images/f0411-05.png)'
  prefs: []
  type: TYPE_IMG
- en: Optional is a wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Java 8, the normal way for a method to declare that *sometimes it might
    not return a resu**lt* is to return an **Optional**. This is an object that *wraps*
    the result, so you can ask “Did I get a result? Or is it empty?” Then you can
    make a decision about what to do next.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0412-01.png)![image](Images/f0412-02.png)![image](Images/f0412-03.png)![image](Images/f0413-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Yes, but now we have a way to ask if we have a result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optional gives us a way to find out about, and deal with, the times when you
    don’t get an ice cream.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0413-02.png)![image](Images/f0413-03.png)'
  prefs: []
  type: TYPE_IMG
- en: In the past, methods might have thrown Exceptions for this case, or return “null”,
    or a special type of “Not Found” ice-cream instance. Returning an *Optional* from
    a method makes it really clear that anything calling the method ***needs*** to
    check if there’s a result first, and ***then*** make their own decision about
    what to do if there isn’t one.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to talk to the Optional wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The important thing about Optional results is that **they can be empty**. If
    you don’t check first to see if there’s a value present and the result is empty,
    you will get an exception.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0414-01.png)![image](Images/f0414-02.png)![image](Images/f0414-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The Unexpected Coffee
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0415-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Alex was programming her mega-ultra-clever (Java-powered) coffee machine to
    give her the types of coffee that suited her best at different times of day.
  prefs: []
  type: TYPE_NORMAL
- en: Five-Minute Mystery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0415-02.png)'
  prefs: []
  type: TYPE_IMG
- en: In the afternoons, Alex wanted the machine to give her the weakest coffee it
    had available (she had enough to keep her up at night; she didn’t need caffeine
    adding to her problems!). As an experienced software developer, she knew the Streams
    API would give her the best stream of coffee at the right time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coffees would automatically be sorted from the weakest to the strongest
    using natural ordering, so she gave the coffee machine these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The very next day, she asked for an afternoon coffee. To her horror, the machine
    presented her with an Americano, not the Decaf Cappuccino she was expecting.
  prefs: []
  type: TYPE_NORMAL
- en: “I can’t drink that!! I’ll be up all night worrying about my latest software
    project!”
  prefs: []
  type: TYPE_NORMAL
- en: '***What happened? Why did the coffee machine give Alex an Americano?***'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arr1.png) **Answers in [“Five-Minute Mystery”](#five-minute_mystery_left_parent-id0001).**'
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0416-01.png)![image](Images/f0416-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Your ***job*** is to take code snippets from the pool and place them into the
    blank lines in the code. You may ***not*** use the same snippet more than once,
    and you won’t need to use all the snippets. Your ***goal*** is to make a class
    that will compile and run and produce the output listed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0416-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Note: each thing from the pool can be used only once!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0416-05.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](Images/arr1.png) **Answers in [“Pool Puzzle”](#pool_puzzle_left_parenthesisfrom_page_41).**'
  prefs: []
  type: TYPE_NORMAL
- en: Mixed Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“When for loops go wrong”](#when_for_loops_go_wrong))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0415-01.png)![image](Images/f0417-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Who Does What?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“WHO DOES WHAT?”](#brain_barbell-id00200))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0417-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code Magnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Code Magnets”](#code_magnets-id000004))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0418-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0418-02-01.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the Compiler, advanced”](#be_the_compilercomma_advanced-id0001))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0418-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Sharpen your pencil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00030))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/pencil.png)![image](Images/f0419-01.png)![image](Images/f0419-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Five-Minute Mystery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Five-Minute Mystery”](#five-minute_mystery_left_parent-id0001))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0419-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Alex didn’t pay attention to the order of the stream operations. She first mapped
    the coffee objects to a stream of Strings, and then ordered that. Strings are
    naturally ordered alphabetically, so when the coffee machine got the “first” of
    these results for Alex’s afternoon coffee, it was brewing a fresh “Americano.”
  prefs: []
  type: TYPE_NORMAL
- en: If Alex wanted to order the coffees by strength, with the weakest (1 out of
    5) first, she needed to order the stream of coffees first, before mapping it to
    a String name,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Then the coffee machine will brew her a decaf instead of an Americano.
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Pool Puzzle”](#pool_puzzle-id00005))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0415-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
