["```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:orientation=\"vertical\">\n\n  <SearchView\n      android:id=\"@+id/search_locations\"\n      android:layout_width=\"match_parent\"\n      android:layout_height=\"wrap_content\"\n      android:background=\"#FFFFFFFF\" />\n\n  <androidx.recyclerview.widget.RecyclerView\n      android:id=\"@+id/browse_content_recyclerview\"\n      android:layout_width=\"match_parent\"\n      android:layout_height=\"match_parent\"\n      android:background=\"#FFFFFFFF\" />\n\n</LinearLayout>\n```", "```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<FrameLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:background=\"#FFFFFFFF\">\n\n  <androidx.recyclerview.widget.RecyclerView\n      android:id=\"@+id/search_results_recyclerview\"\n      android:layout_width=\"match_parent\"\n      android:layout_height=\"match_parent\"\n      android:visibility=\"gone\"\n      android:background=\"#FFFFFFFF\" />\n\n  <ProgressBar\n      android:id=\"@+id/search_progress\"\n      android:indeterminate=\"true\"\n      android:layout_width=\"wrap_content\"\n      android:layout_height=\"wrap_content\"\n      android:layout_gravity=\"center\" />\n\n</FrameLayout>\n```", "```\n[\n    {\n        \"street_address\": \"123 Eiffel Tower Street\",\n        \"city\": \"Paris\",\n        \"country\": \"France\",\n        \"emoji\": \"\",\n        \"hours\": \"8am–7pm\"\n    },\n    {\n        \"street_address\": \"86 Libery Boulevard\",\n        \"city\": \"New York\",\n        \"country\": \"America\",\n        \"emoji\": \"\",\n        \"hours\": \"6am–10pm\"\n    }\n]\n\n```", "```\nimport UIKit\n\nclass LocationsTableViewController: UITableViewController {\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n    }\n\n    // MARK: - Table view data source\n\n    override func numberOfSections(in tableView: UITableView) ->\n    Int {\n        // #warning Incomplete implementation, return the number of sections\n        return 0\n    }\n\n    override func tableView(_ tableView: UITableView, numberOfRowsInSection section:\n    Int) -> Int {\n        // #warning Incomplete implementation, return the number of rows\n        return 0\n    }\n}\n```", "```\noverride func viewDidLoad() {\n\tsuper.viewDidLoad()\n\n\tlet searchController = UISearchController(searchResultsController: nil)\n\tsearchController.searchBar.delegate = self\n\tsearchController.searchBar.placeholder = \"Search Locations by Country\"\n\tsearchController.obscuresBackgroundDuringPresentation = false\n\tdefinesPresentationContext = true\n\n\tnavigationItem.searchController = searchController\n\tnavigationItem.hidesSearchBarWhenScrolling = false\n}\n```", "```\nextension LocationsTableViewController: UISearchBarDelegate {\n    func searchBarTextDidEndEditing(_ searchBar: UISearchBar) {\n        // TODO: Update the table view from the search results\n    }\n}\n```", "```\n    $ mkdir library-node-service\n    $ cd library-node-service\n    ```", "```\n    const express = require('express')\n    const PORT = process.env.PORT || 3000\n\n    express()\n      .get('/catalog', (req, res) => res.json(catalog(req)))\n      .get('/locations', (req, res) => res.json(locations(req)))\n      .listen(PORT, () => console.log(`Listening on ${ PORT }`))\n\n    catalog = (req) => {\n    \tvar fs = require('fs');\n    \tvar json = JSON.parse(fs.readFileSync('catalog.json', 'utf8'));\n    \tconst query = (req.query.q || \"\").toLowerCase()\n    \treturn json.filter(book => book.title.toLowerCase().startsWith(query))\n    }\n\n    locations = (req) => {\n    \tvar fs = require('fs');\n    \tvar json = JSON.parse(fs.readFileSync('locations.json', 'utf8'));\n    \tconst query = (req.query.country || \"\").toLowerCase()\n    \treturn json.filter(loc => loc.country.toLowerCase().startsWith(query))\n    }\n    ```", "```\n[\n    {\n        \"street_address\": \"123 Eiffel Tower Street\",\n        \"city\": \"Paris\",\n        \"country\": \"France\",\n        \"emoji\": \"\",\n        \"hours\": \"8am–7pm\"\n    },\n    {\n        \"street_address\": \"86 Libery Boulevard\",\n        \"city\": \"New York\",\n        \"country\": \"America\",\n        \"emoji\": \"\",\n        \"hours\": \"6am–10pm\"\n    },\n    {\n        \"street_address\": \"49 Lombard Street\",\n        \"city\": \"San Francisco\",\n        \"country\": \"America\",\n        \"emoji\": \"\",\n        \"hours\": \"8am–8pm\"\n    },\n    {\n        \"street_address\": \"1901 Aussie Way\",\n        \"city\": \"Melbourne\",\n        \"country\": \"Australia\",\n        \"emoji\": \"\",\n        \"hours\": \"7am–8pm\"\n    },\n    {\n        \"street_address\": \"302 Deutsch Avenue\",\n        \"city\": \"Berlin\",\n        \"country\": \"Germany\",\n        \"emoji\": \"\",\n        \"hours\": \"9am–6pm\"\n    }\n]\n\n```", "```\nfunc fetchLocations(for country: String) -> [Location] {\n\n}\n```", "```\nstruct Location: Codable {\n    let streetAddress: String\n    let city: String\n    let country: String\n    let emoji: String\n    let hours: String\n\n    private enum CodingKeys: String, CodingKey {\n        case streetAddress = \"the_address\"\n        case city\n        case country\n        case emoji\n        case hours\n    }\n}\n```", "```\nlet decoder = JSONDecoder()\ndecoder.keyDecodingStrategy = .convertFromSnakeCase\n...\n```", "```\nfunc fetchLocations(for country: String,\n  completionHandler: @escaping ([Location]) -> (), errorHandler: @escaping (Error?) -> ()) {\n\n}\n```", "```\nimport Foundation\n\nclass LocationsController {\n    func fetchLocations(for country: String,\n      completionHandler: @escaping ([Location]) -> (), errorHandler: @escaping (Error?) ->\n      ()) {\n\n    }\n}\n\nstruct Location: Codable {\n    let streetAddress: String\n    let city: String\n    let country: String\n    let emoji: String\n    let hours: String\n\n    private enum CodingKeys: String, CodingKey {\n        case streetAddress = \"street_address\"\n        case city\n        case country\n        case emoji\n        case hours\n    }\n}\n```", "```\nlet url = URL(string: \"http://localhost:3000/locations?country=\\(country)\")!\nlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n\n}\ntask.resume()\n```", "```\nfunc fetchLocations(for country: String, completionHandler: @escaping ([Location]) -> (),\n  errorHandler: @escaping (Error?) -> ()) {\n\tlet url = URL(string: \"http://localhost:3000/locations?country=\\(country)\")!\n\tlet task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n\t\tif let error = error {\n\t\t\t// Server error encountered\n\t\t\terrorHandler(error)\n\t\t\treturn\n\t\t}\n\n\t\tguard let response = response as? HTTPURLResponse,\n      response.statusCode < 300 else {\n\t\t\t// Client error encountered\n\t\t\terrorHandler(nil)\n\t\t\treturn\n\t\t}\n\n\t\tguard let data = data else {\n\t\t\t// No valid data\n\t\t\terrorHandler(nil)\n\t\t\treturn\n\t\t}\n\n\t\t// Take our data and convert it to a [Location] object\n\t}\n\ttask.resume()\n}\n```", "```\nimport Foundation\n\nclass LocationsController {\n    func fetchLocations(for country: String, completionHandler: @escaping ([Location]) ->\n    (),\n      errorHandler: @escaping (Error?) -> ()) {\n        let url = URL(string: \"http://localhost:3000/locations?country=\\(country)\")!\n        let task = URLSession.shared.dataTask(with: url) { (data, response, error) in\n            if let error = error {\n                errorHandler(error)\n                return\n            }\n\n            guard let response = response as? HTTPURLResponse, response.statusCode <\n            300 else {\n                errorHandler(nil)\n                return\n            }\n\n            guard let data = data, let locations =\n            try? JSONDecoder().decode([Location].self,\n              from: data) else {\n                errorHandler(nil)\n                return\n            }\n\n            // Call our completion handler with our locations\n            completionHandler(locations)\n        }\n        task.resume()\n    }\n}\n\nstruct Location: Codable {\n    let streetAddress: String\n    let city: String\n    let country: String\n    let emoji: String\n    let hours: String\n}\n```", "```\nfunc searchBarTextDidEndEditing(_ searchBar: UISearchBar) {\n\tlet country = searchBar.text ?? \"\"\n\tlocationsController.fetchLocations(for: country, completionHandler:\n\t{ (locations) in\n\t\tDispatchQueue.main.async {\n\t\t\tself.locations = locations\n\t\t\tself.tableView.reloadData()\n\t\t}\n\t}) { (error) in\n\t\tDispatchQueue.main.async {\n\t\t\tself.locations = []\n\t\t\tself.tableView.reloadData()\n\t\t}\n\t}\n}\n```", "```\noverride func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) ->\nInt {\n\treturn locations.count\n}\n\noverride func tableView(_ tableView: UITableView,\n    cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n\t// Dequeue a table view cell\n\tlet cell = tableView.dequeueReusableCell(withIdentifier: \"LocationCell\", for:\n\tindexPath)\n\n\t// Find the correct location based on the row being populated\n\tlet location = locations[indexPath.row]\n\n\t// Style the cell\n\tcell.textLabel?.text = location.emoji\n\tcell.detailTextLabel?.text =\n    \"\\(location.streetAddress)\\n\\(location.city),\n    \\(location.country)\\nHours: \\(location.hours)\"\n\n\treturn cell\n}\n```", "```\nimport UIKit\n\nclass LocationsTableViewController: UITableViewController {\n\n    let locationsController = LocationsController()\n    var locations: [Location] = []\n\n    override func viewDidLoad() {\n        super.viewDidLoad()\n\n        let searchController = UISearchController(searchResultsController: nil)\n        searchController.searchBar.delegate = self\n        searchController.searchBar.placeholder = \"Search Locations by Country\"\n        searchController.obscuresBackgroundDuringPresentation = false\n        definesPresentationContext = true\n\n        navigationItem.searchController = searchController\n        navigationItem.hidesSearchBarWhenScrolling = false\n    }\n\n    // MARK: - Table view data source\n    override func tableView(_ tableView: UITableView,\n        numberOfRowsInSection section: Int) -> Int {\n        return locations.count\n    }\n\n    override func tableView(_ tableView: UITableView,\n        cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n        // Dequeue a table view cell\n        let cell = tableView.dequeueReusableCell(withIdentifier: \"LocationCell\", for:\n        indexPath)\n\n        // Find the correct location based on the row being populated\n        let location = locations[indexPath.row]\n\n        // Style the cell\n        cell.textLabel?.text =\n          \"\\(location.streetAddress)\\n\\(location.city), \\(location.country)\\nHours:\n          \\(location.hours)\"\n        cell.detailTextLabel?.text = location.emoji\n\n        return cell\n    }\n}\n\nextension LocationsTableViewController: UISearchBarDelegate {\n    func searchBarTextDidEndEditing(_ searchBar: UISearchBar) {\n        let country = searchBar.text ?? \"\"\n        guard country != \"\" else {\n            self.locations = []\n            self.tableView.reloadData()\n            return\n        }\n        locationsController.fetchLocations(for: country, completionHandler:\n        { (locations) in\n            DispatchQueue.main.async {\n                self.locations = locations\n                self.tableView.reloadData()\n            }\n        }) { (error) in\n            DispatchQueue.main.async {\n                self.locations = []\n                self.tableView.reloadData()\n            }\n        }\n    }\n\n    func searchBarCancelButtonClicked(_ searchBar: UISearchBar) {\n        self.locations = []\n        self.tableView.reloadData()\n    }\n}\n```", "```\nApp Transport Security(((\"App Transport Security\"))) has blocked a cleartext HTTP (http://)\n    resource load since it is insecure. Temporary exceptions can be configured via your\n    app's(((\"Info.plist file\"))) Info.plist file.\n```", "```\nfunc fetchLocations(for country: String, completionHandler: @escaping ([Location]) -> (),\n  errorHandler: @escaping (Error?) -> ()) {\n\n\t...\n\n\tDispatchQueue.main.async {\n\t\tUIApplication.shared.isNetworkActivityIndicatorVisible = true\n\t}\n\ttask.resume()\n}\n```"]