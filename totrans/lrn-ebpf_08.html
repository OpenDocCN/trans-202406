<html><head></head><body><section data-pdf-bookmark="Chapter 8. eBPF for Networking" data-type="chapter" epub:type="chapter"><div class="chapter" id="ebpf_for_networking">&#13;
<h1><span class="label">Chapter 8. </span>eBPF for Networking</h1>&#13;
<p><a contenteditable="false" data-primary="networking" data-secondary="eBPF for" data-type="indexterm" id="ch08.html0"/>As you saw in <a data-type="xref" href="ch01.html#what_is_ebpf_and_why_is_it_importantque">Chapter 1</a>, the dynamic nature of eBPF allows us to customize the behavior of the kernel. In the world of networking, there is a huge range of desirable behavior that depends on the application. For example, a telecommunications operator might have to interface with telco-specific protocols like SRv6; a Kubernetes environment might need to be integrated with legacy applications; dedicated hardware load balancers can be replaced with XDP programs running on commodity hardware. eBPF allows programmers to build networking features to meet specific needs, without having to force them on all upstream kernel users.</p>&#13;
<p>Network tools based on eBPF are now widely used and have proven to be effective at prolific scale. The CNCF’s <a href="http://cilium.io">Cilium project</a>, for example, uses eBPF as a platform for Kubernetes networking, standalone load balancing, and much more, and it’s used by cloud native adopters in every conceivable industry vertical.<sup><a data-type="noteref" href="ch08.html#ch08fn1" id="ch08fn1-marker">1</a></sup> Meta has been using eBPF at a vast scale—every packet to and from Facebook since 2017 has been through an XDP program. Another public and hyper-scaled example is Cloudflare’s use of eBPF for DDoS (distributed denial-of-service) protection.</p>&#13;
<p>These are complex, production-ready solutions, and their details are far beyond the scope of this book, but by reading the examples in this chapter you can get a feel for how eBPF networking solutions like these are built.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The code examples for this chapter are in the <em>chapter8</em> directory of the repository at <a class="orm:hideurl" href="https://github.com/lizrice/learning-ebpf"><em>github.com/lizrice/learning-ebpf</em></a>.</p>&#13;
</div>&#13;
<section data-pdf-bookmark="Packet Drops" data-type="sect1"><div class="sect1" id="packet_drops">&#13;
<h1>Packet Drops</h1>&#13;
<p><a contenteditable="false" data-primary="networking" data-secondary="packet drops" data-type="indexterm" id="ch08.html1"/><a contenteditable="false" data-primary="networking" data-secondary="network security" data-type="indexterm" id="ch08.html1a"/><a contenteditable="false" data-primary="packet drops" data-type="indexterm" id="ch08.html2"/><a contenteditable="false" data-primary="security" data-secondary="packet drops" data-type="indexterm" id="ch08.html3"/><a contenteditable="false" data-primary="network security" data-secondary="packet drops" data-type="indexterm" id="ch08.html3a"/>There are several network security features that involve dropping certain incoming packets and allowing others. These features include firewalling, DDoS protection, and mitigating packet-of-death vulnerabilities:</p>&#13;
<ul class="list_style_type_none">&#13;
<li><p><a contenteditable="false" data-primary="firewalling" data-secondary="defined" data-type="indexterm" id="idm46123194408080"/>Firewalling involves deciding on a per-packet basis whether to allow a packet, based on the source and destination IP addresses and/or port numbers.</p></li>&#13;
<li><p><a contenteditable="false" data-primary="DDoS protection" data-type="indexterm" id="idm46123194406000"/>DDoS protection adds some complexity, perhaps keeping track of the rate at which packets are arriving from a particular source and/or detecting certain characteristics of the packet contents to determine that an attacker or set of attackers is trying to flood the interface with traffic.</p></li>&#13;
<li><p><a contenteditable="false" data-primary="packet-of-death vulnerability" data-type="indexterm" id="idm46123194404352"/>A packet-of-death vulnerability is a class of kernel vulnerability in which the kernel fails to safely process a packet crafted in a particular way. An attacker who sends packets with this particular format can exploit the vulnerability, which could potentially cause the kernel to crash. Traditionally, when a kernel vulnerability like this is found, it requires installing a new kernel with the fix, which in turn requires machine downtime. But an eBPF program that detects and drops these malicious packets can be installed dynamically, instantly protecting that host without affecting any applications running on the machine.</p></li>&#13;
</ul>&#13;
<p>The decision-making algorithms for features like these are beyond the scope of this book, but let’s explore how eBPF programs attached to the XDP hook on a network interface drop certain packets, which is the basis for implementing these use cases.</p>&#13;
<section data-pdf-bookmark="XDP Program Return Codes" data-type="sect2"><div class="sect2" id="xdp_program_return_codes">&#13;
<h2>XDP Program Return Codes</h2>&#13;
<p><a contenteditable="false" data-primary="packet drops" data-secondary="XDP program return codes" data-type="indexterm" id="idm46123194400880"/><a contenteditable="false" data-primary="return code" data-secondary="XDP program return codes" data-type="indexterm" id="idm46123194399440"/><a contenteditable="false" data-primary="XDP (eXpress Data Path)" data-secondary="return codes" data-type="indexterm" id="idm46123194398048"/>An XDP program is triggered by the arrival of a network packet. The program examines the packet, and when it’s done, the return code gives a <em>verdict</em> that indicates what to do next with that packet:</p>&#13;
<ul class="list_style_type_none">&#13;
<li><p><code>XDP_PASS</code> indicates that the packet should be sent to the network stack in the normal way (as it would have done if there were no XDP program).</p></li>&#13;
<li><p><code>XDP_DROP</code> causes the packet to be discarded immediately.</p></li>&#13;
<li><p><code>XDP_TX</code> sends the packet back out of the same interface it arrived on.</p></li>&#13;
<li><p><code>XDP_REDIRECT</code> is used to send it to a different network interface.</p></li>&#13;
<li><p><code>XDP_ABORTED</code> results in the packet being dropped, but its use implies an error case or something unexpected, rather than a “normal” decision to discard a packet.</p></li>&#13;
</ul>&#13;
<p>For some use cases (like firewalling), the XDP program simply has to decide between passing the packet on or dropping it. An outline for an XDP program that decides whether to drop packets looks something like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"xdp"</code><code class="p">)</code><code class="w">   </code>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">hello</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">xdp_md</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">   </code>&#13;
<code class="w">    </code><code class="kt">bool</code><code class="w"> </code><code class="n">drop</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="n">drop</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="o">&lt;</code><code class="n">examine</code><code class="w"> </code><code class="n">packet</code><code class="w"> </code><code class="n">and</code><code class="w"> </code><code class="n">decide</code><code class="w"> </code><code class="n">whether</code><code class="w"> </code><code class="n">to</code><code class="w"> </code><code class="n">drop</code><code class="w"> </code><code class="n">it</code><code class="o">&gt;</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">drop</code><code class="p">)</code><code class="w"> </code>&#13;
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_DROP</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">else</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_PASS</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>An XDP program can also manipulate the packet contents, but I’ll come to that later in this chapter.</p>&#13;
<p>XDP programs get triggered whenever an inbound network packet arrives on the interface to which it is attached. The <code>ctx</code> parameter is a pointer to an <code>xdp_md</code> structure, which holds metadata about the incoming packet. Let’s see how you can use this structure to examine the packet’s contents in order to reach a verdict.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="XDP Packet Parsing" data-type="sect2"><div class="sect2" id="xdp_packet_parsing">&#13;
<h2>XDP Packet Parsing</h2>&#13;
<p><a contenteditable="false" data-primary="packet drops" data-secondary="XDP packet parsing" data-type="indexterm" id="ch08.html4"/><a contenteditable="false" data-primary="XDP (eXpress Data Path)" data-secondary="packet parsing" data-type="indexterm" id="ch08.html5"/>Here’s the definition of the <code>xdp_md</code> structure:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/xdp_md"><code class="nc">xdp_md</code></a><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><code class="n">data</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/data_end"><code class="n">data_end</code></a><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/data_meta"><code class="n">data_meta</code></a><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="cm">/* Below access go through struct xdp_rxq_info */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/ingress_ifindex"><code class="n">ingress_ifindex</code></a><code class="p">;</code><code class="w"> </code><code class="cm">/* rxq-&gt;dev-&gt;ifindex */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/rx_queue_index"><code class="n">rx_queue_index</code></a><code class="p">;</code><code class="w">  </code><code class="cm">/* rxq-&gt;queue_index  */</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u32"><code class="n">__u32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/egress_ifindex"><code class="n">egress_ifindex</code></a><code class="p">;</code><code class="w">  </code><code class="cm">/* txq-&gt;dev-&gt;ifindex */</code><code class="w">&#13;
</code><code class="p">}</code><code class="p">;</code></pre>&#13;
<p>Don’t be fooled by the <code>__u32</code> type for the first three fields, as they are really pointers. The <code>data</code> field indicates the location in memory where the packet starts, and <code>data_end</code> shows where it ends. As you saw in <a data-type="xref" href="ch06.html#the_ebpf_verifier">Chapter 6</a>, to pass the eBPF verifier you will have to explicitly check that any reads or writes to the packet’s contents are within the range <code>data</code> to <code>data_end</code>.</p>&#13;
<p>There is also an area in memory ahead of the packet, between <code>data_meta</code> and <code>data</code>, for storing metadata about this packet. This can be used for coordination between multiple eBPF programs that might process the same packet at various places on its journey through the stack.</p>&#13;
<p>To illustrate the basics of parsing a network packet, there is an XDP program called <code>ping()</code> in the example code, which will simply generate a line of trace whenever it detects a ping (ICMP) packet. Here’s the code for that program:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"xdp"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">ping</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">xdp_md</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">long</code><code class="w"> </code><code class="n">protocol</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">lookup_protocol</code><code class="p">(</code><code class="n">ctx</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">protocol</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="c1">// ICMP</code>&#13;
<code class="w">   </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">       </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"Hello ping"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_PASS</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>You can see this program in action by following these steps:</p>&#13;
<ol>&#13;
<li><p>Run <code>make</code> in the <em>chapter8</em> directory. This doesn’t just build the code; it also attaches the XDP program to the loopback interface (called <code>lo</code>).</p></li>&#13;
<li><p>Run <code>ping localhost</code> in one terminal window.</p></li>&#13;
<li><p>In another terminal window, watch the output generated in the trace pipe by running <code>cat /sys/kernel/tracing/trace_pipe</code>.</p></li>&#13;
</ol>&#13;
<p>You should see two lines of trace being generated approximately every second, and they should look like this:</p>&#13;
<pre data-type="programlisting">ping-26622   [000] d.s11 276880.862408: bpf_trace_printk: Hello ping&#13;
ping-26622   [000] d.s11 276880.862459: bpf_trace_printk: Hello ping&#13;
ping-26622   [000] d.s11 276881.889575: bpf_trace_printk: Hello ping&#13;
ping-26622   [000] d.s11 276881.889676: bpf_trace_printk: Hello ping&#13;
ping-26622   [000] d.s11 276882.910777: bpf_trace_printk: Hello ping&#13;
ping-26622   [000] d.s11 276882.910930: bpf_trace_printk: Hello ping</pre>&#13;
<p>There are two lines of trace per second because the loopback interface is receiving both the ping requests and the ping responses.</p>&#13;
<p>You can easily modify this code to drop ping packets by adding a line of code to return <code>XDP_DROP</code> when the protocol matches, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">protocol</code><code class="w"> </code><code class="o">==</code><code class="w"> </code><code class="mi">1</code><code class="p">)</code><code class="w"> </code><code class="c1">// ICMP</code>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"Hello ping"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_DROP</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
<code class="k">return</code><code class="w"> </code><code class="n">XDP_PASS</code><code class="p">;</code><code class="w"/></pre>&#13;
<p>If you try this, you’ll see that output resembling the following is only generated in the trace output once per second:</p>&#13;
<pre data-type="programlisting">ping-26639   [002] d.s11 277050.589356: bpf_trace_printk: Hello ping&#13;
ping-26639   [002] d.s11 277051.615329: bpf_trace_printk: Hello ping&#13;
ping-26639   [002] d.s11 277052.637708: bpf_trace_printk: Hello ping</pre>&#13;
<p>The loopback interface receives a ping request, and the XDP program drops it, so the request never gets far enough through the network stack to elicit a response.</p>&#13;
<p>Most of the work in this XDP program is being done in a function called <code>lookup_protocol()</code> that determines the Layer 4 protocol type. It’s just an example, not a production-quality implementation of parsing a network packet! But it’s sufficient to give you an idea of how parsing in eBPF works.</p>&#13;
<p>The network packet that has been received consists of a string of bytes that are laid out as shown in <a data-type="xref" href="#layout_of_an_ip_network_packetcomma_sta">Figure 8-1</a>.</p>&#13;
<figure><div class="figure" id="layout_of_an_ip_network_packetcomma_sta">&#13;
<img alt="Layout of an IP network packet, starting with an Ethernet header, followed by an IP header, and then the Layer 4 data" src="assets/lebp_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>Layout of an IP network packet, starting with an Ethernet header, followed by an IP header, and then the Layer 4 data</h6>&#13;
</div></figure>&#13;
<p>The <code>lookup_protocol()</code> function takes the <code>ctx</code> structure that holds information about where this network packet is in memory and returns the protocol type that it finds in the IP header. The code is as follows:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">unsigned</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="nf">lookup_protocol</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">xdp_md</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">{</code><code class="w">&#13;
</code><code class="w">   </code><code class="kt">unsigned</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">protocol</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)</code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-</code><code class="o">&gt;</code><code class="n">data</code><code class="p">;</code><code class="w">                                    </code><a class="co" href="#list_id_8_1" id="code_id_8_1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data_end</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)</code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-</code><code class="o">&gt;</code><code class="n">data_end</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="w"> </code><code class="o">*</code><code class="n">eth</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="p">;</code><code class="w">                                               </code><a class="co" href="#list_id_8_2" id="code_id_8_2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">data_end</code><code class="p">)</code><code class="w">                             </code><a class="co" href="#list_id_8_3" id="code_id_8_3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">       </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">   </code><code class="c1">// Check that it's an IP packet&#13;
</code><code class="w">   </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">bpf_ntohs</code><code class="p">(</code><code class="n">eth</code><code class="o">-</code><code class="o">&gt;</code><code class="n">h_proto</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="n">ETH_P_IP</code><code class="p">)</code><code class="w">                                 </code><a class="co" href="#list_id_8_4" id="code_id_8_4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">       </code><code class="c1">// Return the protocol of this packet&#13;
</code><code class="w">       </code><code class="c1">// 1 = ICMP&#13;
</code><code class="w">       </code><code class="c1">// 6 = TCP&#13;
</code><code class="w">       </code><code class="c1">// 17 = UDP       &#13;
</code><code class="w">       </code><code class="k">struct</code><code class="w"> </code><code class="nc">iphdr</code><code class="w"> </code><code class="o">*</code><code class="n">iph</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="p">;</code><code class="w">                    </code><a class="co" href="#list_id_8_5" id="code_id_8_5"><img alt="5" src="assets/5.png"/></a><code class="w"> </code><code class="w">&#13;
</code><code class="w">       </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">iphdr</code><code class="p">)</code><code class="w"> </code><code class="o">&lt;</code><code class="o">=</code><code class="w"> </code><code class="n">data_end</code><code class="p">)</code><code class="w"> </code><a class="co" href="#list_id_8_6" id="code_id_8_6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">           </code><code class="n">protocol</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">iph</code><code class="o">-</code><code class="o">&gt;</code><code class="n">protocol</code><code class="p">;</code><code class="w">                                        </code><a class="co" href="#list_id_8_7" id="code_id_8_7"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
</code><code class="w">   </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">protocol</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_8_1" id="list_id_8_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>The local variables <code>data</code> and <code>data_end</code> point to the start and end of the network packet.</dd>&#13;
<dt><a class="co" href="#code_id_8_2" id="list_id_8_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>The network packet should start with an Ethernet header.</dd>&#13;
<dt><a class="co" href="#code_id_8_3" id="list_id_8_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>But you can’t simply assume this network packet is big enough to hold that Ethernet header! The verifier requires that you check this explicitly.</dd>&#13;
<dt><a class="co" href="#code_id_8_4" id="list_id_8_4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>The Ethernet header contains a 2-byte field that tells us the Layer 3 protocol.</dd>&#13;
<dt><a class="co" href="#code_id_8_5" id="list_id_8_5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd>If the protocol type indicates that it’s an IP packet, the IP header immediately follows the Ethernet header.</dd>&#13;
<dt><a class="co" href="#code_id_8_6" id="list_id_8_6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd>You can’t just assume there’s enough room for that IP header in the network packet. Again the verifier requires that you check explicitly.</dd>&#13;
<dt><a class="co" href="#code_id_8_7" id="list_id_8_7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd>The IP header contains the protocol byte the function will return to its caller.</dd>&#13;
</dl>&#13;
<p>The <code>bpf_ntohs()</code> function used by this program ensures that the two bytes are in the order expected on this host. Network protocols are big-endian, but most processors are little-endian, meaning they hold multibyte values in a different order. This function converts (if necessary) from network ordering to host ordering. You should use this function whenever you extract a value from a field in a network packet that’s more than one byte long.</p>&#13;
<p>The simple example here shows how just a few lines of eBPF code can have a dramatic impact on networking functionality. It’s not hard to imagine how more complex rules about which packets to pass and which packets to drop could result in the features I described at the start of this section: firewalling, DDoS protection, and packet-of-death vulnerability mitigation. Now let’s consider how even more functionality can be provided given the power to modify network packets within eBPF <span class="keep-together">programs</span><a contenteditable="false" data-primary="" data-startref="ch08.html5" data-type="indexterm" id="idm46123193703184"/><a contenteditable="false" data-primary="" data-startref="ch08.html4" data-type="indexterm" id="idm46123193701968"/>.<a contenteditable="false" data-primary="" data-startref="ch08.html3" data-type="indexterm" id="idm46123193700624"/><a contenteditable="false" data-primary="" data-startref="ch08.html3a" data-type="indexterm" id="idm46123193699408"/><a contenteditable="false" data-primary="" data-startref="ch08.html2" data-type="indexterm" id="idm46123193698192"/><a contenteditable="false" data-primary="" data-startref="ch08.html1a" data-type="indexterm" id="idm46123193696976"/><a contenteditable="false" data-primary="" data-startref="ch08.html1" data-type="indexterm" id="idm46123193695760"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Load Balancing and Forwarding" data-type="sect1"><div class="sect1" id="load_balancing_and_forwarding">&#13;
<h1>Load Balancing and Forwarding</h1>&#13;
<p><a contenteditable="false" data-primary="load balancing" data-type="indexterm" id="ch08.html6"/><a contenteditable="false" data-primary="networking" data-secondary="load balancing and forwarding" data-type="indexterm" id="ch08.html7"/><a contenteditable="false" data-primary="XDP (eXpress Data Path)" data-secondary="load balancing and forwarding" data-type="indexterm" id="ch08.html8"/>XDP programs aren’t limited to inspecting the contents of a packet. They can also modify the packet’s contents. Let’s consider what’s involved if you want to build a simple load balancer that takes packets sent to a given IP address and fans those requests to a number of backends that can fulfill the request.</p>&#13;
<p>There’s an example of this in the GitHub repo.<sup><a data-type="noteref" href="ch08.html#ch08fn2" id="ch08fn2-marker">2</a></sup> The setup here is a set of containers that run on the same host. There’s a client, a load balancer, and two backends, each running in their own container. As illustrated in <a data-type="xref" href="#example_load_balancer_setup">Figure 8-2</a>, the load balancer receives traffic from the client and forwards it to one of the two backend containers.</p>&#13;
<figure><div class="figure" id="example_load_balancer_setup">&#13;
<img alt="Example load balancer setup" src="assets/lebp_0802.png"/>&#13;
<h6><span class="label">Figure 8-2. </span>Example load balancer setup</h6>&#13;
</div></figure>&#13;
<p>The load balancing function is implemented as an XDP program attached to the load balancer’s eth0 network interface. The return code from this program is <code>XDP_TX</code>, indicating that the packet should be sent back out of the interface it came in on. But before that happens, the program has to update the address information in the packet headers.</p>&#13;
<p>Although I think it’s useful as a learning exercise, this example code is very, very far from being production ready; for example, it uses hard-coded addresses that assume the exact setup of IP addresses shown in <a data-type="xref" href="#example_load_balancer_setup">Figure 8-2</a>. It assumes that the only TCP traffic it will ever receive is requests from the client or responses to the client. It also cheats by taking advantage of the way Docker sets up virtual MAC addresses, using each container’s IP address as the last four bytes of the MAC address for the virtual Ethernet interface for each container. That virtual Ethernet interface is called eth0 from the perspective of the container.</p>&#13;
<p>Here’s the XDP program from the example load balancer code:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"</code><code class="s">xdp_lb</code><code class="s">"</code><code class="p">)</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="n">xdp_load_balancer</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">xdp_md</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)</code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-</code><code class="o">&gt;</code><code class="n">data</code><code class="p">;</code><code class="w">           </code><a class="co" href="#list_id_8_8" id="code_id_8_8"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data_end</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)</code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-</code><code class="o">&gt;</code><code class="n">data_end</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="w"> </code><code class="o">*</code><code class="n">eth</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">data_end</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_ABORTED</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">bpf_ntohs</code><code class="p">(</code><code class="n">eth</code><code class="o">-</code><code class="o">&gt;</code><code class="n">h_proto</code><code class="p">)</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="n">ETH_P_IP</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_PASS</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">struct</code><code class="w"> </code><code class="nc">iphdr</code><code class="w"> </code><code class="o">*</code><code class="n">iph</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">iphdr</code><code class="p">)</code><code class="w"> </code><code class="o">&gt;</code><code class="w"> </code><code class="n">data_end</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_ABORTED</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">iph</code><code class="o">-</code><code class="o">&gt;</code><code class="n">protocol</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="n">IPPROTO_TCP</code><code class="p">)</code><code class="w">               </code><a class="co" href="#list_id_8_9" id="code_id_8_9"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_PASS</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">iph</code><code class="o">-</code><code class="o">&gt;</code><code class="n">saddr</code><code class="w"> </code><code class="o">=</code><code class="o">=</code><code class="w"> </code><code class="n">IP_ADDRESS</code><code class="p">(</code><code class="n">CLIENT</code><code class="p">)</code><code class="p">)</code><code class="w">           </code><a class="co" href="#list_id_8_10" id="code_id_8_10"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="kt">char</code><code class="w"> </code><code class="n">be</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BACKEND_A</code><code class="p">;</code><code class="w">                        </code><a class="co" href="#list_id_8_11" id="code_id_8_11"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">bpf_get_prandom_u32</code><code class="p">(</code><code class="p">)</code><code class="w"> </code><code class="o">%</code><code class="w"> </code><code class="mi">2</code><code class="p">)</code><code class="w">                </code><code class="w">&#13;
</code><code class="w">            </code><code class="n">be</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">BACKEND_B</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">        </code><code class="n">iph</code><code class="o">-</code><code class="o">&gt;</code><code class="n">daddr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">IP_ADDRESS</code><code class="p">(</code><code class="n">be</code><code class="p">)</code><code class="p">;</code><code class="w">                </code><a class="co" href="#list_id_8_12" id="code_id_8_12"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="n">eth</code><code class="o">-</code><code class="o">&gt;</code><code class="n">h_dest</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">be</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">else</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">        </code><code class="n">iph</code><code class="o">-</code><code class="o">&gt;</code><code class="n">daddr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">IP_ADDRESS</code><code class="p">(</code><code class="n">CLIENT</code><code class="p">)</code><code class="p">;</code><code class="w">            </code><a class="co" href="#list_id_8_13" id="code_id_8_13"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="n">eth</code><code class="o">-</code><code class="o">&gt;</code><code class="n">h_dest</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">CLIENT</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="n">iph</code><code class="o">-</code><code class="o">&gt;</code><code class="n">saddr</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">IP_ADDRESS</code><code class="p">(</code><code class="n">LB</code><code class="p">)</code><code class="p">;</code><code class="w">                    </code><a class="co" href="#list_id_8_14" id="code_id_8_14"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="n">eth</code><code class="o">-</code><code class="o">&gt;</code><code class="n">h_source</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">LB</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="n">iph</code><code class="o">-</code><code class="o">&gt;</code><code class="n">check</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">iph_csum</code><code class="p">(</code><code class="n">iph</code><code class="p">)</code><code class="p">;</code><code class="w">                     </code><a class="co" href="#list_id_8_15" id="code_id_8_15"><img alt="8" src="assets/8.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_TX</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_8_8" id="list_id_8_8"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>The first part of this function is practically the same as in the previous example: it locates the Ethernet header and then the IP header in the packet.</dd>&#13;
<dt><a class="co" href="#code_id_8_9" id="list_id_8_9"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>This time it will process only TCP packets, passing anything else it receives on up the stack as if nothing had happened.</dd>&#13;
<dt><a class="co" href="#code_id_8_10" id="list_id_8_10"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>Here the source IP address is checked. If this packet didn’t come from the client, I will assume it is a response going to the client.</dd>&#13;
<dt><a class="co" href="#code_id_8_11" id="list_id_8_11"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>This code generates a pseudorandom choice between backends A and B.</dd>&#13;
<dt><a class="co" href="#code_id_8_12" id="list_id_8_12"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd>The destination IP and MAC addresses are updated to match whichever backend was chosen…</dd>&#13;
<dt><a class="co" href="#code_id_8_13" id="list_id_8_13"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd>…or if this is a response from a backend (which is the assumption here if it didn’t come from a client), the destination IP and MAC addresses are updated to match the client.</dd>&#13;
<dt><a class="co" href="#code_id_8_14" id="list_id_8_14"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd>Wherever this packet is going, the source addresses need to be updated so that it looks as though the packet originated from the load balancer.</dd>&#13;
<dt><a class="co" href="#code_id_8_15" id="list_id_8_15"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd>The IP header includes a checksum calculated over its contents, and since the source and destination IP addresses have both been updated, the checksum also needs to be recalculated and replaced in this packet.</dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Since this is a book on eBPF and not networking, I haven’t delved into details such as why the IP and MAC addresses need to be updated or what happens if they aren’t. If you’re interested, I cover this some more in my <a href="https://oreil.ly/mQxtT">YouTube video of the eBPF Summit talk</a> where I originally wrote this example code.</p>&#13;
</div>&#13;
<p><a contenteditable="false" data-primary="bpftool" data-secondary="XDP and" data-type="indexterm" id="idm46123193525392"/>Much like the previous example, the Makefile includes instructions to not only build the code but also use <code>bpftool</code> to load and attach the XDP program to the interface, like this:</p>&#13;
<pre data-type="programlisting">xdp: $(BPF_OBJ)&#13;
   bpftool net detach xdpgeneric dev eth0&#13;
   rm -f /sys/fs/bpf/$(TARGET)&#13;
   bpftool prog load $(BPF_OBJ) /sys/fs/bpf/$(TARGET)&#13;
   bpftool net attach xdpgeneric pinned /sys/fs/bpf/$(TARGET) dev eth0</pre>&#13;
<p>This <code>make</code> instruction needs to be run <em>inside</em> the load balancer container so that eth0 corresponds to its virtual Ethernet interface. This leads to an interesting point: an eBPF program is loaded into the kernel, of which there is only one; yet the attachment point may be within a particular network namespace and visible only within that network namespace.<sup><a data-type="noteref" href="ch08.html#ch08fn3" id="ch08fn3-marker">3</a></sup><a contenteditable="false" data-primary="" data-startref="ch08.html8" data-type="indexterm" id="idm46123193516112"/><a contenteditable="false" data-primary="" data-startref="ch08.html7" data-type="indexterm" id="idm46123193514768"/><a contenteditable="false" data-primary="" data-startref="ch08.html6" data-type="indexterm" id="idm46123193220208"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="XDP Offloading" data-type="sect1"><div class="sect1" id="xdp_offloading">&#13;
<h1>XDP Offloading</h1>&#13;
<p><a contenteditable="false" data-primary="networking" data-secondary="XDP offloading" data-type="indexterm" id="idm46123193216752"/><a contenteditable="false" data-primary="XDP (eXpress Data Path)" data-secondary="offloading" data-type="indexterm" id="idm46123193171600"/>The idea for XDP originated from a conversation speculating how useful it would be if you could run eBPF programs on a network card to make decisions about individual packets before they even reach the kernel’s networking stack.<sup><a data-type="noteref" href="ch08.html#ch08fn4" id="ch08fn4-marker">4</a></sup> There are some network interface cards that support this full <em>XDP offload</em> capability where they can indeed run eBPF programs on inbound packets on their own processor. This is illustrated in <a data-type="xref" href="#network_interface_cards_that_support_xd">Figure 8-3</a>.</p>&#13;
<figure><div class="figure" id="network_interface_cards_that_support_xd">&#13;
<img alt="Network interface cards that support XDP offload can process, drop, and retransmit packets without any work required from the host CPU" src="assets/lebp_0803.png"/>&#13;
<h6><span class="label">Figure 8-3. </span>Network interface cards that support XDP offload can process, drop, and retransmit packets without any work required from the host CPU</h6>&#13;
</div></figure>&#13;
<p>This means a packet that gets dropped or redirected back out of the same physical interface—like the packet drop and load balancing examples earlier in this chapter—is never seen by the host’s kernel, and no CPU cycles on the host machine are ever spent processing them, as all the work is done on the network card.</p>&#13;
<p>Even if the physical network interface card doesn’t support full XDP offload, many NIC drivers support XDP hooks, which minimizes the memory copying required for an eBPF program to process a packet.<sup><a data-type="noteref" href="ch08.html#ch08fn5" id="ch08fn5-marker">5</a></sup></p>&#13;
<p>This can result in significant performance benefits and allows functionality like load balancing to run very efficiently on commodity hardware.<sup><a data-type="noteref" href="ch08.html#ch08fn6" id="ch08fn6-marker">6</a></sup></p>&#13;
<p>You’ve seen how XDP can be used to process inbound network packets, accessing them as soon as possible as they arrive on a machine. eBPF can also be used to process traffic at other points in the network stack, in whatever direction it is flowing. Let’s move on and think about eBPF programs attached within the TC subsystem.</p>&#13;
</div></section>&#13;
<section class="pagebreak-before" data-pdf-bookmark="Traffic Control (TC)" data-type="sect1"><div class="sect1" id="traffic_control_left_parenthesistcright">&#13;
<h1 class="less_space">Traffic Control (TC)</h1>&#13;
<p><a contenteditable="false" data-primary="networking" data-secondary="traffic control" data-type="indexterm" id="ch08.html9"/><a contenteditable="false" data-primary="traffic control (TC)" data-type="indexterm" id="ch08.html10"/>I mentioned traffic control in the previous chapter. By the time a network packet reaches this point it will be in kernel memory in the form of an <a href="https://oreil.ly/TKDCF"><code>sk_buff</code></a>. This is a data structure that’s used throughout the kernel’s network stack. eBPF programs attached within the TC subsystem receive a pointer to the <code>sk_buff</code> structure as the context parameter.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You might be wondering why XDP programs don’t also use this same structure for their context. The answer is that the XDP hook happens before the network data reaches the network stack and before the <code>sk_buff</code> structure has been set up.</p>&#13;
</div>&#13;
<p>The TC subsystem is intended to regulate how network traffic is scheduled. For example, you might want to limit the bandwidth available to each application so that they all get a fair chance. But when you’re looking at scheduling individual packets, <em>bandwidth</em> isn’t a terribly meaningful term, as it’s used for the average amount of data being sent or received. A given application might be very bursty, or another application might be very sensitive to network latency, so TC gives much finer control over the way packets are handled and prioritized.<sup><a data-type="noteref" href="ch08.html#ch08fn7" id="ch08fn7-marker">7</a></sup></p>&#13;
<p>eBPF programs were introduced here to give custom control over the algorithms used within TC. But with the power to manipulate, drop, or redirect packets, eBPF programs attached within TC can also be used as the building blocks for complex network behaviors.</p>&#13;
<p>A given piece of network data in the stack flows in one of two directions: <em>ingress</em> (inbound from the network interface) or <em>egress</em> (outbound toward the network interface). eBPF programs can be attached in either direction and will affect traffic only in that direction. Unlike XDP, it’s possible to attach multiple eBPF programs that will be processed in sequence.</p>&#13;
<p>Traditional traffic control is split into <em>classifiers</em>, which classify packets based on some rule, and separate <em>actions</em>, which are taken based on the output from a classifier and determine what to do with a packet. There can be a series of classifiers, all defined as part of a <em>qdisc</em> or queuing discipline.</p>&#13;
<p class="pagebreak-before">eBPF programs are attached as a classifier, but they can also determine what action to take within the same program. The action is indicated by the program’s return code (whose values are defined in <em>linux/pkt_cls.h</em>):</p>&#13;
<ul class="list_style_type_none">&#13;
<li><p><code>TC_ACT_SHOT</code> tells the kernel to drop the packet.</p></li>&#13;
<li><p><code>TC_ACT_UNSPEC</code> behaves as if the eBPF program hadn’t been run on this packet (so it would be passed to the next classifier in the sequence, if there is one).</p></li>&#13;
<li><p><code>TC_ACT_OK</code> tells the kernel to pass the packet to the next layer in the stack.</p></li>&#13;
<li><p><code>TC_ACT_REDIRECT</code> sends the packet to the ingress or egress path of a different network device.</p></li>&#13;
</ul>&#13;
<p>Let’s take a look at a few simple examples of programs that can be attached within TC. The first simply generates a line of trace and then tells the kernel to drop the packet:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">tc_drop</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">__sk_buff</code><code class="w"> </code><code class="o">*</code><code class="n">skb</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">bpf_trace_printk</code><code class="p">(</code><code class="s">"[tc] dropping packet</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">TC_ACT_SHOT</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>Now let’s consider how to drop only a subset of packets. This example drops ICMP (ping) request packets and is very similar to the XDP example you saw earlier in this chapter:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">tc</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">__sk_buff</code><code class="w"> </code><code class="o">*</code><code class="n">skb</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">skb</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data_end</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">skb</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">is_icmp_ping_request</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="n">data_end</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">struct</code><code class="w"> </code><code class="nc">iphdr</code><code class="w"> </code><code class="o">*</code><code class="n">iph</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">struct</code><code class="w"> </code><code class="nc">icmphdr</code><code class="w"> </code><code class="o">*</code><code class="n">icmp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">iphdr</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="n">bpf_trace_printk</code><code class="p">(</code><code class="s">"[tc] ICMP request for %x type %x</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">iph</code><code class="o">-&gt;</code><code class="n">daddr</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                     </code><code class="n">icmp</code><code class="o">-&gt;</code><code class="n">type</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">TC_ACT_SHOT</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">TC_ACT_OK</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>The <code>sk_buff</code> structure has pointers to the start and end of the packet data, very much like the <code>xdp_md</code> structure, and packet parsing proceeds in very much the same way. Again, to pass verification you have to explicitly check that any access to data is within the range between <code>data</code> and <code>data_end</code>.</p>&#13;
<p class="pagebreak-before">You might be wondering why you would want to implement something like this at the TC layer when you have already seen the same kind of functionality implemented with XDP. One good reason is that you can use TC programs for egress traffic, where XDP can only process ingress traffic. Another is that because XDP is triggered as soon as the packet arrives, there is no <code>sk_buff</code> kernel data structure related to the packet at that point. If the eBPF program is interested in or wants to manipulate the <code>sk_buff</code> the kernel creates for this packet, the TC attachment point is suitable.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To better understand the differences between XDP and TC eBPF programs, read the “Program Types” section in the <a href="https://oreil.ly/MWAJL">BPF and XDP Reference Guide</a> from the Cilium project.</p>&#13;
</div>&#13;
<p>Now let’s consider an example that doesn’t just drop certain packets. This example identifies a ping request being received and responds with a ping response:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">tc_pingpong</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">__sk_buff</code><code class="w"> </code><code class="o">*</code><code class="n">skb</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)</code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="n">skb</code><code class="o">-</code><code class="o">&gt;</code><code class="n">data</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data_end</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)</code><code class="p">(</code><code class="kt">long</code><code class="p">)</code><code class="n">skb</code><code class="o">-</code><code class="o">&gt;</code><code class="n">data_end</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="n">is_icmp_ping_request</code><code class="p">(</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="n">data_end</code><code class="p">)</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">      </code><a class="co" href="#list_id_8_16" id="code_id_8_16"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">TC_ACT_OK</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">iphdr</code><code class="w"> </code><code class="o">*</code><code class="n">iph</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">struct</code><code class="w"> </code><code class="nc">icmphdr</code><code class="w"> </code><code class="o">*</code><code class="n">icmp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ethhdr</code><code class="p">)</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">iphdr</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">swap_mac_addresses</code><code class="p">(</code><code class="n">skb</code><code class="p">)</code><code class="p">;</code><code class="w">                          </code><a class="co" href="#list_id_8_17" id="code_id_8_17"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="n">swap_ip_addresses</code><code class="p">(</code><code class="n">skb</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="c1">// Change the type of the ICMP packet to 0 (ICMP Echo Reply) &#13;
</code><code class="w">  </code><code class="c1">// (was 8 for ICMP Echo request)&#13;
</code><code class="w">  </code><code class="n">update_icmp_type</code><code class="p">(</code><code class="n">skb</code><code class="p">,</code><code class="w"> </code><code class="mi">8</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="p">;</code><code class="w">                      </code><a class="co" href="#list_id_8_18" id="code_id_8_18"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="c1">// Redirecting a clone of the modified skb back to the interface &#13;
</code><code class="w">  </code><code class="c1">// it arrived on&#13;
</code><code class="w">  </code><code class="n">bpf_clone_redirect</code><code class="p">(</code><code class="n">skb</code><code class="p">,</code><code class="w"> </code><code class="n">skb</code><code class="o">-</code><code class="o">&gt;</code><code class="n">ifindex</code><code class="p">,</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="p">;</code><code class="w">         </code><a class="co" href="#list_id_8_19" id="code_id_8_19"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">TC_ACT_SHOT</code><code class="p">;</code><code class="w">                               </code><a class="co" href="#list_id_8_20" id="code_id_8_20"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_8_16" id="list_id_8_16"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>The <code>is_icmp_ping_request()</code> function parses the packet and checks not only that it’s an ICMP message, but also that it’s an echo (ping) request.</dd>&#13;
<dt><a class="co" href="#code_id_8_17" id="list_id_8_17"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>Since this function is going to send a response to the sender, the source and destination addresses need to be swapped. (You can read the example code if you want to see the nitty-gritty details of this, which also includes updating the IP header checksum.)</dd>&#13;
<dt><a class="co" href="#code_id_8_18" id="list_id_8_18"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>This is converted to an echo response by changing the type field in the ICMP header.</dd>&#13;
<dt><a class="co" href="#code_id_8_19" id="list_id_8_19"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>This helper function sends a clone of the packet back through the interface (<code>skb-&gt;ifindex</code>) on which it was received.</dd>&#13;
<dt><a class="co" href="#code_id_8_20" id="list_id_8_20"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd>Since the helper function cloned the packet before sending out the response, the original packet should be dropped.</dd>&#13;
</dl>&#13;
<p>In normal circumstances, a ping request would be handled later by the kernel’s network stack, but this small example demonstrates how network functionality more generally can be replaced by an eBPF implementation.</p>&#13;
<p>Lots of networking capabilities today are handled by user space services, but where they can be replaced by eBPF programs, it’s likely to be great for performance. A packet that’s processed within the kernel doesn’t have to complete its journey through the rest of the stack; there is no need for it to transition to user space for processing, and the response doesn’t require a transition back into the kernel. What’s more, the two could run in parallel—an eBPF program can return <code>TC_ACT_OK</code> for any packet that requires complex processing that it can’t handle so that it gets passed up to the user space service as normal.</p>&#13;
<p>For me, this is an important aspect of implementing network functionality in eBPF. As the eBPF platform develops (e.g., more recent kernels allowing programs of one million instructions), it’s possible to implement increasingly complex aspects of networking in the kernel. The parts that are not yet implemented in eBPF can still be handled either by the traditional stack within the kernel or in user space. Over time, more and more features can be moved from user space into the kernel, with the flexibility and dynamic nature of eBPF meaning you won’t have to wait for them to be part of the kernel distribution itself. You can load eBPF implementations immediately, just as I discussed in <a data-type="xref" href="ch01.html#what_is_ebpf_and_why_is_it_importantque">Chapter 1</a>.</p>&#13;
<p>I’ll return to the implementation of networking features in <a data-type="xref" href="#ebpf_and_kubernetes_networking">“eBPF and Kubernetes Networking”</a>. But first, let’s consider another use case that eBPF enables: inspecting the decrypted contents of encrypted traffic.<a contenteditable="false" data-primary="" data-startref="ch08.html10" data-type="indexterm" id="idm46123192611376"/><a contenteditable="false" data-primary="" data-startref="ch08.html9" data-type="indexterm" id="idm46123192610160"/></p>&#13;
</div></section>&#13;
<section class="pagebreak-before" data-pdf-bookmark="Packet Encryption and Decryption" data-type="sect1"><div class="sect1" id="packet_encryption_and_decryption">&#13;
<h1 class="less_space">Packet Encryption and Decryption</h1>&#13;
<p><a contenteditable="false" data-primary="encryption" data-secondary="packet encryption/decryption" data-type="indexterm" id="ch08.html12"/><a contenteditable="false" data-primary="networking" data-secondary="packet encryption/decryption" data-type="indexterm" id="ch08.html13"/><a contenteditable="false" data-primary="packet encryption/decryption" data-type="indexterm" id="ch08.html14"/><a contenteditable="false" data-primary="security" data-secondary="packet encryption/decryption" data-type="indexterm" id="ch08.html15"/><a contenteditable="false" data-primary="network security" data-secondary="packet encryption/decryption" data-type="indexterm" id="ch08.html15a"/><a contenteditable="false" data-primary="network security" data-secondary="network security" data-type="indexterm" id="ch08.html15b"/>If an application uses encryption to secure data it sends or receives, there will be a point before it’s encrypted or after it’s decrypted where the data is in the clear. Recall that eBPF can attach programs pretty much anywhere on a machine, so if you can hook into a point where data is being passed and isn’t yet encrypted, or just after it has been decrypted, that would allow your eBPF program to observe that data in the clear. There’s no need to supply any certificates to decrypt the traffic, as you would in a traditional SSL inspection tool.</p>&#13;
<p>In many cases an application will encrypt data using a library like OpenSSL or BoringSSL that lives in user space. In this case the traffic will already be encrypted by the time it reaches the socket, which is the user space/kernel boundary for network traffic. If you want to trace out this data in its unencrypted form, you can use an eBPF program attached to the right place in the user space code.</p>&#13;
<section data-pdf-bookmark="User Space SSL Libraries" data-type="sect2"><div class="sect2" id="user_space_ssl_libraries">&#13;
<h2>User Space SSL Libraries</h2>&#13;
<p><a contenteditable="false" data-primary="SSL libraries" data-type="indexterm" id="ch08.html17"/><a contenteditable="false" data-primary="user space" data-secondary="SSL libraries" data-type="indexterm" id="ch08.html18"/>One common way to trace out the decrypted content of encrypted packets is to hook into calls made to user space libraries like OpenSSL or BoringSSL. An application using OpenSSL sends data to be encrypted by making a call to a function called <code>SSL_write()</code> and retrieves cleartext data that was received over the network in encrypted form using <code>SSL_read()</code>. Hooking eBPF programs into these functions with uprobes allows an application to observe the data <em>from any application that uses this shared library</em> in the clear, before it is encrypted or after it has been decrypted. And there is no need for any keys, because those are already being provided by the <span class="keep-together">application</span>.</p>&#13;
<p>There is a fairly straightforward example called <a href="https://oreil.ly/puDp9">openssl-tracer in the Pixie project</a>,<sup><a data-type="noteref" href="ch08.html#ch08fn8" id="ch08fn8-marker">8</a></sup> within which the eBPF programs are in a file called <em>openssl_tracer_bpf_funcs.c</em>. Here’s the part of that code that sends data to user space, using a perf buffer (similar to examples you have seen earlier in this book):</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">static</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="nf">process_SSL_data</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">pt_regs</code><code class="o">*</code><code class="w"> </code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="kt">uint64_t</code><code class="w"> </code><code class="n">id</code><code class="p">,</code><code class="w"> </code><code class="k">enum</code><code class="w">  </code>&#13;
<code class="n">ssl_data_event_type</code><code class="w"> </code><code class="n">type</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buf</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w"> </code><code class="p">...</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">bpf_probe_read</code><code class="p">(</code><code class="n">event</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="n">event</code><code class="o">-&gt;</code><code class="n">data_len</code><code class="p">,</code><code class="w"> </code><code class="n">buf</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">tls_events</code><code class="p">.</code><code class="n">perf_submit</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="n">event</code><code class="p">,</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">ssl_data_event_t</code><code class="p">));</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>You can see that data from <code>buf</code> gets read into an <code>event</code> structure using the helper function <code>bpf_probe_read()</code>, and then that <code>event</code> structure is submitted to a perf buffer.</p>&#13;
<p>If this data is being sent to user space, it’s reasonable to assume this must be the data in unencrypted format. So where is this buffer of data obtained? You can work that out by seeing where the <code>process_SSL_data()</code> function is called. It’s called in two places: one for data being read and one for data being written. <a data-type="xref" href="#ebpf_programs_are_hooked_to_uprobes_at_">Figure 8-4</a> illustrates what is happening in the case of reading data that arrives on this machine in encrypted form.</p>&#13;
<p>When you’re reading data, you supply a pointer to a buffer to <code>SSL_read()</code>, and when the function returns, that buffer will contain the unencrypted data. Much like kprobes, the input parameters to a function—including that buffer pointer—are only available to a uprobe attached to the entry point, as the registers they’re held in might well get overwritten during the function’s execution. But the data won’t be available in the buffer until the function exits, when you can read it using a uretprobe.</p>&#13;
<figure><div class="figure" id="ebpf_programs_are_hooked_to_uprobes_at_">&#13;
<img alt="eBPF programs are hooked to uprobes at the entry to and exit from SSL_read() so that the unencrypted data can be read from the buffer pointer" src="assets/lebp_0804.png"/>&#13;
<h6><span class="label">Figure 8-4. </span>eBPF programs are hooked to uprobes at the entry to and exit from <code>SSL_read()</code> so that the unencrypted data can be read from the buffer pointer</h6>&#13;
</div></figure>&#13;
<p class="pagebreak-before">So this example follows a common pattern for kprobes and uprobes, illustrated in <a data-type="xref" href="#ebpf_programs_are_hooked_to_uprobes_at_">Figure 8-4</a>, where the entry probe temporarily stores input parameters using a map, from which the exit probe can retrieve them. Let’s look at the code that does this, starting with the eBPF program attached to the start of <code>SSL_read()</code>:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="c1">// Function signature being probed:&#13;
</code><code class="c1">// int SSL_read(SSL *s, void *buf, int num)&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="nf">probe_entry_SSL_read</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">pt_regs</code><code class="o">*</code><code class="w"> </code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">  </code><code class="kt">uint64_t</code><code class="w"> </code><code class="n">current_pid_tgid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_pid_tgid</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="w">&#13;
</code><code class="w">  </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="w"> </code><code class="n">buf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="p">)</code><code class="n">PT_REGS_PARM2</code><code class="p">(</code><code class="n">ctx</code><code class="p">)</code><code class="p">;</code><code class="w">         </code><a class="co" href="#list_id_8_21" id="code_id_8_21"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">active_ssl_read_args_map</code><code class="p">.</code><code class="n">update</code><code class="p">(</code><code class="o">&amp;</code><code class="n">current_pid_tgid</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">buf</code><code class="p">)</code><code class="p">;</code><code class="w">  </code><a class="co" href="#list_id_8_22" id="code_id_8_22"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_8_21" id="list_id_8_21"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>As described in the comment for this function, the buffer pointer is the second parameter passed into the <code>SSL_read()</code> function to which this probe will be attached. The <code>PT_REGS_PARM2</code> macro gets this parameter from the context.</dd>&#13;
<dt><a class="co" href="#code_id_8_22" id="list_id_8_22"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>The buffer pointer is stored in a hash map, for which the key is the current process and thread ID, obtained at the start of the function using the helper <code>bpf_get_current_pid_tgif()</code>.</dd>&#13;
</dl>&#13;
<p>Here’s the corresponding program for the exit probe:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">int</code><code class="w"> </code><code class="nf">probe_ret_SSL_read</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">pt_regs</code><code class="o">*</code><code class="w"> </code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">  </code><code class="kt">uint64_t</code><code class="w"> </code><code class="n">current_pid_tgid</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_get_current_pid_tgid</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="w">&#13;
</code><code class="w">  </code><code class="k">const</code><code class="w"> </code><code class="kt">char</code><code class="o">*</code><code class="o">*</code><code class="w"> </code><code class="n">buf</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">active_ssl_read_args_map</code><code class="p">.</code><code class="n">lookup</code><code class="p">(</code><code class="o">&amp;</code><code class="n">current_pid_tgid</code><code class="p">)</code><code class="p">;</code><code class="w">   </code><a class="co" href="#list_id_8_23" id="code_id_8_23"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">buf</code><code class="w"> </code><code class="o">!</code><code class="o">=</code><code class="w"> </code><code class="nb">NULL</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="n">process_SSL_data</code><code class="p">(</code><code class="n">ctx</code><code class="p">,</code><code class="w"> </code><code class="n">current_pid_tgid</code><code class="p">,</code><code class="w"> </code><code class="n">kSSLRead</code><code class="p">,</code><code class="w"> </code><code class="o">*</code><code class="n">buf</code><code class="p">)</code><code class="p">;</code><code class="w">               </code><a class="co" href="#list_id_8_24" id="code_id_8_24"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="w">  </code><code class="n">active_ssl_read_args_map</code><code class="p">.</code><code class="n">delete</code><code class="p">(</code><code class="o">&amp;</code><code class="n">current_pid_tgid</code><code class="p">)</code><code class="p">;</code><code class="w">                      </code><a class="co" href="#list_id_8_25" id="code_id_8_25"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_8_23" id="list_id_8_23"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>Having looked up the current process and thread ID, use this as the key to retrieve the buffer pointer from the hash map.</dd>&#13;
<dt><a class="co" href="#code_id_8_24" id="list_id_8_24"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>If this isn’t a null pointer, call <code>process_SSL_data()</code>, which is the function you saw earlier that sends the data from that buffer to user space using the perf buffer.</dd>&#13;
<dt><a class="co" href="#code_id_8_25" id="list_id_8_25"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>Clean up the entry in the hash map, since every entry call should be paired with an exit.</dd>&#13;
</dl>&#13;
<p>This example shows how to trace out the cleartext version of encrypted data that gets sent and received by a user space application. The tracing itself is attached to a user space library, and there’s no guarantee that every application will use a given SSL library. The BCC project includes a utility called <a href="https://oreil.ly/tFT9p"><em>sslsniff</em></a> that also supports GnuTLS and NSS. But if someone’s application uses some other encryption library (or even, heaven forbid, they chose to “roll their own crypto”), the uprobes simply won’t have the right places to hook to and these tracing tools won’t work.</p>&#13;
<p>There are even more common reasons why this uprobe-based approach might not be successful. Unlike the kernel (of which there is only one per [virtual] machine), there can be multiple copies of user space library code. If you’re using containers, each one is likely to have its own set of all library dependencies. You can hook into uprobes in these libraries, but you’d have to identify the right copy for the particular container you want to trace. Another possibility is that rather than using a shared, dynamically linked library, an application might be statically linked so that it’s a single standalone executable<a contenteditable="false" data-primary="" data-startref="ch08.html18" data-type="indexterm" id="idm46123192241984"/><a contenteditable="false" data-primary="" data-startref="ch08.html17" data-type="indexterm" id="idm46123192188864"/>.<a contenteditable="false" data-primary="" data-startref="ch08.html15" data-type="indexterm" id="idm46123192187456"/><a contenteditable="false" data-primary="" data-startref="ch08.html15b" data-type="indexterm" id="idm46123192186048"/><a contenteditable="false" data-primary="" data-startref="ch08.html15a" data-type="indexterm" id="idm46123192184672"/><a contenteditable="false" data-primary="" data-startref="ch08.html14" data-type="indexterm" id="idm46123192183296"/><a contenteditable="false" data-primary="" data-startref="ch08.html13" data-type="indexterm" id="idm46123192181920"/><a contenteditable="false" data-primary="" data-startref="ch08.html12" data-type="indexterm" id="idm46123192180544"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="eBPF and Kubernetes Networking" data-type="sect1"><div class="sect1" id="ebpf_and_kubernetes_networking">&#13;
<h1>eBPF and Kubernetes Networking</h1>&#13;
<p><a contenteditable="false" data-primary="Kubernetes" data-secondary="eBPF and Kubernetes networking" data-type="indexterm" id="ch08.html19"/><a contenteditable="false" data-primary="networking" data-secondary="Kubernetes and eBPF" data-type="indexterm" id="ch08.html20"/>Although this book isn’t about Kubernetes, eBPF is so widely used for Kubernetes networking that it’s a great illustration of using the platform to customize the networking stack.</p>&#13;
<p><a contenteditable="false" data-primary="pods, defined" data-type="indexterm" id="idm46123192173776"/>In Kubernetes environments, applications are deployed in <em>pods</em>. Each pod is a group of one or more containers that share kernel namespaces and cgroups, isolating pods from each other and from the host machine they are running on.</p>&#13;
<p>In particular (for the purposes of this chapter), a pod typically has its own network namespace and its own IP address.<sup><a data-type="noteref" href="ch08.html#ch08fn9" id="ch08fn9-marker">9</a></sup> This means the kernel has a set of network stack structures for that namespace, separated from the host’s and from other pods. As shown in <a data-type="xref" href="#network_path_in_kubernetes">Figure 8-5</a>, the pod is connected to the host by a virtual Ethernet connection, and it is allocated its own IP address.</p>&#13;
<figure><div class="figure" id="network_path_in_kubernetes">&#13;
<img alt="Network path in Kubernetes" src="assets/lebp_0805.png"/>&#13;
<h6><span class="label">Figure 8-5. </span>Network path in Kubernetes</h6>&#13;
</div></figure>&#13;
<p>You can see from <a data-type="xref" href="#network_path_in_kubernetes">Figure 8-5</a> that a packet coming from outside the machine destined for an application pod has to travel through the network stack on the host, across the virtual Ethernet connection, and into the pod’s network namespace, and then it has to traverse the network stack again to reach the application.</p>&#13;
<p>Those two network stacks are running in the same kernel, so the packet is really running through the same processing twice. The more code a network packet has to pass through, the higher the latency, so if it’s possible to shorten the network path, that will likely bring about performance improvements.</p>&#13;
<p class="pagebreak-before">An eBPF-based networking solution like Cilium can hook into the network stack to override the kernel’s native networking behavior, as shown in <a data-type="xref" href="#bypassing_iptables_and_conntrack_proces">Figure 8-6</a>.</p>&#13;
<figure><div class="figure" id="bypassing_iptables_and_conntrack_proces">&#13;
<img alt="Bypassing iptables and conntrack processing with eBPF" src="assets/lebp_0806.png"/>&#13;
<h6><span class="label">Figure 8-6. </span>Bypassing iptables and conntrack processing with eBPF</h6>&#13;
</div></figure>&#13;
<p>In particular, eBPF enables replacing iptables and conntrack with a more efficient solution for managing network rules and connection tracking. Let’s discuss why this results in a significant performance improvement in Kubernetes.</p>&#13;
<section class="pagebreak-before" data-pdf-bookmark="Avoiding iptables" data-type="sect2"><div class="sect2" id="avoiding_iptables">&#13;
<h2 class="less_space">Avoiding iptables</h2>&#13;
<p><a contenteditable="false" data-primary="load balancing" data-secondary="kube-proxy" data-type="indexterm" id="idm46123192158800"/><a contenteditable="false" data-primary="iptables, avoiding" data-type="indexterm" id="idm46123192157424"/><a contenteditable="false" data-primary="kube-proxy" data-type="indexterm" id="idm46123192156320"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="avoiding iptables" data-type="indexterm" id="idm46123192155216"/>Kubernetes has a component called kube-proxy that implements load balancing behavior, allowing multiple pods to fulfill requests to a service. This has been implemented using iptables rules.</p>&#13;
<p><a contenteditable="false" data-primary="CNI (Container Network Interface)" data-type="indexterm" id="idm46123192153424"/><a contenteditable="false" data-primary="Container Network Interface (CNI)" data-type="indexterm" id="idm46123192152304"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="CNI" data-type="indexterm" id="idm46123192151184"/>Kubernetes offers users the choice of which networking solution to use through the use of the Container Network Interface (CNI). Some CNI plug-ins use iptables rules to implement L3/L4 network policy in Kubernetes; that is, the iptables rules indicate whether to drop a packet because it doesn’t meet the network policy.</p>&#13;
<p>Although iptables was effective for traditional (precontainer) networking, it has some weaknesses when it’s used in Kubernetes. In this environment, pods—and their IP addresses—come and go dynamically, and each time a pod is added or removed, the iptables rules have to be rewritten in their entirety, and this impacts performance at scale. (A <a href="https://oreil.ly/BO0-8">talk</a> by Haibin Xie and Quinton Hoole at KubeCon in 2017 described how making a single rule update to iptables rules for 20,000 services could take five hours.)</p>&#13;
<p>Updates to iptables aren’t the only performance issues: looking up a rule requires a linear search through the table, which is an O(n) operation, growing linearly with the number of rules.</p>&#13;
<p>Cilium uses eBPF hash table maps to store network policy rules, connection tracking, and load balancer lookup tables, which can replace iptables for kube-proxy. Both looking up an entry in a hash table and inserting a new one are approximately O(1) operations, which means they scale much, much better.</p>&#13;
<p>You can read about the benchmarked performance improvements this achieves on the Cilium <a href="https://oreil.ly/9NV99">blog</a>. In the same post you’ll see that Calico, another CNI that has an eBPF option, also achieves better performance when you pick its eBPF implementation over iptables. eBPF offers the most performant mechanisms for scalable, dynamic Kubernetes deployments.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Coordinated Network Programs" data-type="sect2"><div class="sect2" id="coordinated_network_programs">&#13;
<h2>Coordinated Network Programs</h2>&#13;
<p>A <a contenteditable="false" data-primary="Cilium" data-secondary="coordinated network programs" data-type="indexterm" id="ch08.html22"/>complex networking implementation like Cilium can’t be written as a single eBPF program. As shown in <a data-type="xref" href="#cilium_consists_of_multiple_coordinated">Figure 8-7</a>, it provides several different eBPF programs that are hooked into different parts of the kernel and its network stack.</p>&#13;
<figure><div class="figure" id="cilium_consists_of_multiple_coordinated">&#13;
<img alt="Cilium consists of multiple coordinated eBPF programs that hook into different points in the kernel" src="assets/lebp_0807.png"/>&#13;
<h6><span class="label">Figure 8-7. </span>Cilium consists of multiple coordinated eBPF programs that hook into different points in the kernel</h6>&#13;
</div></figure>&#13;
<p>As a general principle, Cilium intercepts traffic as soon as it can in order to shorten the processing path for each packet. Messages flowing out from an application pod are intercepted at the socket layer, as close to the application as possible. Inbound packets from the external network are intercepted using XDP. But what about the additional attachment points?</p>&#13;
<p>Cilium supports different networking modes that suit different environments. A full description of this is beyond the scope of this book (you can find more information at <a class="orm:hideurl" href="https://cilium.io">Cilium.io</a>), but I’ll give a brief overview here so that you can see why there are so many different eBPF programs!</p>&#13;
<p>There is a simple, flat networking mode, in which Cilium allocates IP addresses for all the pods in a cluster from the same CIDR and directly routes traffic between them. There are also a couple of different tunneling modes, in which traffic intended for a pod on a different node gets encapsulated in a message addressed to that destination node’s IP address and decapsulated on that destination node for the final hop into the pod. Different eBPF programs get invoked to handle traffic depending on whether a packet is destined for a local container, the local host, another host on this network, or a tunnel.</p>&#13;
<p><a contenteditable="false" data-primary="traffic control (TC)" data-type="indexterm" id="idm46123192136080"/>In <a data-type="xref" href="#cilium_consists_of_multiple_coordinated">Figure 8-7</a> you can see multiple TC programs that handle traffic to and from different devices. These devices represent the possible different real and virtual network interfaces where a packet might be flowing:</p>&#13;
<ul class="list_style_type_none">&#13;
<li><p>The interface to a pod’s network (one end of the virtual Ethernet connection between the pod and the host)</p></li>&#13;
<li><p>The interface to a network tunnel</p></li>&#13;
<li><p>The interface to a physical network device on the host</p></li>&#13;
<li><p>The host’s own network interface</p></li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’re interested in learning more about how packets flow through Cilium, Arthur Chiao wrote this detailed and interesting blog post: <a href="https://oreil.ly/toxsM">“Life of a Packet in Cilium: Discovering the Pod-to-Service Traffic Path and BPF Processing Logics”</a>.<a contenteditable="false" data-primary="" data-startref="ch08.html22" data-type="indexterm" id="idm46123192128688"/></p>&#13;
</div>&#13;
<p>The different eBPF programs attached at these various points in the kernel communicate using eBFP maps and using the metadata that can be attached to network packets as they flow through the stack (which I mentioned when I discussed accessing network packets in the XDP example). These programs don’t just route packets to their destination; they’re also used to drop packets—just like you saw in earlier examples—based on network policies.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Network Policy Enforcement" data-type="sect2"><div class="sect2" id="network_policy_enforcement">&#13;
<h2>Network Policy Enforcement</h2>&#13;
<p><a contenteditable="false" data-primary="Kubernetes" data-secondary="policy enforcement" data-type="indexterm" id="idm46123192125088"/><a contenteditable="false" data-primary="networking" data-secondary="policy enforcement" data-type="indexterm" id="idm46123192123712"/>You saw at the start of this chapter how eBPF programs can drop packets, and that means they simply won’t reach their destination. This is the basis of network policy enforcement, and conceptually it’s essentially the same whether we are thinking about “traditional” or cloud native firewalling. A policy determines whether a packet should be dropped or not, based on information about its source and/or destination.</p>&#13;
<p><a contenteditable="false" data-primary="IP addresses, Kubernetes and" data-type="indexterm" id="idm46123192121920"/>In traditional environments, IP addresses are assigned to a particular server for a long period of time, but in Kubernetes, IP addresses come and go dynamically, and the address assigned today for a particular application pod might very well be reused for a completely different application tomorrow. <a contenteditable="false" data-primary="firewalling" data-secondary="network policy enforcement and" data-type="indexterm" id="idm46123192120624"/>This is why traditional firewalling isn’t terribly effective in cloud native environments. It would be impractical to redefine firewall rules manually every time IP addresses change.</p>&#13;
<p>Instead, Kubernetes supports the concept of a NetworkPolicy resource, which defines firewalling rules based on the labels applied to particular pods rather than based on their IP address. Although the resource type is native to Kubernetes, it’s not implemented by Kubernetes itself. <a contenteditable="false" data-primary="Container Network Interface (CNI)" data-type="indexterm" id="idm46123192118384"/><a contenteditable="false" data-primary="CNI (Container Network Interface)" data-type="indexterm" id="idm46123192117264"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="CNI" data-type="indexterm" id="idm46123192116144"/>Instead, this functionality is delegated to whatever CNI plug-in you’re using. If you choose a CNI that doesn’t support NetworkPolicy resources, any rules you might configure are simply ignored. On the flip side, CNIs are free to configure custom resources that allow for more sophisticated network policy configurations than the native Kubernetes definition allows. For example, Cilium supports features like DNS-based network policy rules, so you can define whether traffic is or isn’t allowed not based on an IP address but based on the DNS name (e.g., “<em>example.com</em>”). You can also define policies for various Layer 7 protocols, for example, allowing or denying traffic for HTTP GET calls but not for POST calls to a particular URL.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Isovalent’s free hands-on lab <a href="https://oreil.ly/afdeh">“Getting Started with Cilium”</a> walks you through defining network policies at Layers 3/4 and Layer 7. Another very useful resource is the Network Policy Editor at <a href="http://networkpolicy.io"><em>networkpolicy.io</em></a>, which visually presents the effects of a network policy.</p>&#13;
</div>&#13;
<p>As I discussed earlier in this chapter, it’s possible to use iptables rules to drop traffic, and that’s an approach some CNIs have taken to implement Kubernetes NetworkPolicy rules. Cilium uses eBPF programs to drop traffic that doesn’t match the set of rules currently in place. Having seen examples of dropping packets earlier in this chapter, I hope you have a rough mental model for how this would work.</p>&#13;
<p>Cilium uses Kubernetes identities to determine whether a given network policy rule applies. In the same way labels define which pods are part of a service in Kubernetes, labels also define Cilium’s security identity for the pod. eBPF hash tables, indexed by these service identities, make for very efficient rule lookups.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Encrypted Connections" data-type="sect2"><div class="sect2" id="encrypted_connections">&#13;
<h2>Encrypted Connections</h2>&#13;
<p><a contenteditable="false" data-primary="encryption" data-secondary="encrypted connections in Kubernetes" data-type="indexterm" id="ch08.html23"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="encrypted connections" data-type="indexterm" id="ch08.html24"/><a contenteditable="false" data-primary="security" data-secondary="encrypted connections in Kubernetes" data-type="indexterm" id="ch08.html25"/>Many organizations have requirements to protect their deployments and their users’ data by encrypting traffic between applications. This can be achieved by writing code in each application to ensure that it sets up secure connections, typically using mutual Traffic Layer Security (mTLS) underpinning an HTTP or gRPC connection. Setting up these connections requires first establishing the identities of the apps at either end of the connection (which is usually achieved by exchanging certificates) and then encrypting the data that flows between them.</p>&#13;
<p>In Kubernetes, it’s possible to offload the requirement from the application, either to a service mesh layer or to the underlying network itself. A full discussion of service mesh is beyond the scope of this book, but you might be interested in a piece I wrote on the new stack: <a href="https://oreil.ly/5ayvF">“How eBPF Streamlines the Service Mesh”</a>. Let’s concentrate here on the network layer and how eBPF makes it possible to push the encryption requirement into the kernel.</p>&#13;
<p><a contenteditable="false" data-primary="encryption" data-secondary="transparent" data-type="indexterm" id="idm46123192101696"/><a contenteditable="false" data-primary="transparent encryption" data-type="indexterm" id="idm46123192100320"/>The simplest option to ensure that traffic is encrypted within a Kubernetes cluster is to use <em>transparent encryption</em>. It’s called “transparent” because it takes place entirely at the network layer and it’s extremely lightweight from an operational point of view. The applications themselves don’t need to be aware of the encryption at all, and they don’t need to set up HTTPS connections; nor does this approach require any additional infrastructure components running under Kubernetes.</p>&#13;
<p><a contenteditable="false" data-primary="IPsec encryption protocol" data-type="indexterm" id="idm46123192098272"/><a contenteditable="false" data-primary="WireGuard encryption protocol" data-type="indexterm" id="idm46123192097152"/>There are two in-kernel encryption protocols in common usage, IPsec and WireGuard<sup>(R)</sup>, and they’re both supported in Kubernetes networking by Cilium and Calico CNIs. It’s beyond the scope of this book to discuss the differences between these two protocols, but the key point is that they set up a secure tunnel between two machines. The CNI can choose to connect the eBPF endpoint for a pod via this secure tunnel.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There is a nice write-up on the <a href="https://oreil.ly/xjpGP">Cilium blog</a> of how Cilium uses WireGuard<sup>(R)</sup> as well as IPsec to provide encrypted traffic between nodes. The post also gives a brief overview of the performance characteristics of both.</p>&#13;
</div>&#13;
<p>The secure tunnel is set up using the identities of the nodes at either end. These identities are managed by Kubernetes anyway, so the administrative burden for an operator is minimal. For many purposes this is sufficient as it ensures that all network traffic in a cluster is encrypted. Transparent encryption can also be used unmodified with NetworkPolicy that uses Kubernetes identities to manage whether traffic can flow between different endpoints in the cluster.</p>&#13;
<p>Some organizations operate a multitenant environment where there’s a need for strong multitenant boundaries and where it’s essential to use certificates to identify every application endpoint. Handling this within every application is a significant burden, so it’s something that more recently has been offloaded to a service mesh layer, but this requires a whole extra set of components to be deployed, causing additional resource consumption, latency, and operational complexity.</p>&#13;
<p>eBPF is now enabling a <a href="https://oreil.ly/DSnLZ">new approach</a> that builds on transparent encryption but uses TLS for the initial certificate exchange and endpoint authentication so that the identities can represent individual applications rather than the nodes they are running on, as depicted in <a data-type="xref" href="#transparent_encryption_between_authenti">Figure 8-8</a>.</p>&#13;
<figure><div class="figure" id="transparent_encryption_between_authenti">&#13;
<img alt="Transparent encryption between authenticated application identities" src="assets/lebp_0808.png"/>&#13;
<h6><span class="label">Figure 8-8. </span>Transparent encryption between authenticated application identities</h6>&#13;
</div></figure>&#13;
<p>Once the authentication step has taken place, IPsec or WireGuard<sup>(R)</sup> within the kernel is used to encrypt the traffic that flows between those applications. This has a number of advantages. It allows third-party certificate and identity management tools like cert-manager or SPIFFE/SPIRE to handle the identity part, and the network takes care of encryption so that it’s all entirely transparent to the application. Cilium supports NetworkPolicy definitions that specify endpoints by their SPIFFE ID rather than just by their Kubernetes labels. And perhaps most importantly, this approach can be used with any protocol that travels in IP packets. That’s a big step up from mTLS, which works only for TCP-based connections.</p>&#13;
<p>There’s not enough room in this book to dive deep into all the internals of Cilium, but I hope this section helped you understand how eBPF is a powerful platform for building complex networking functionality like a fully featured Kubernetes CNI<a contenteditable="false" data-primary="" data-startref="ch08.html25" data-type="indexterm" id="idm46123192086688"/><a contenteditable="false" data-primary="" data-startref="ch08.html24" data-type="indexterm" id="idm46123192085312"/><a contenteditable="false" data-primary="" data-startref="ch08.html23" data-type="indexterm" id="idm46123192083936"/>.<a contenteditable="false" data-primary="" data-startref="ch08.html20" data-type="indexterm" id="idm46123192082432"/><a contenteditable="false" data-primary="" data-startref="ch08.html19" data-type="indexterm" id="idm46123192081024"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000017">&#13;
<h1>Summary</h1>&#13;
<p>In this chapter you saw eBPF programs attached at a variety of different points in the network stack. I showed examples of basic packet processing, and I hope these gave you an indication of how eBPF can create powerful networking features. You also saw some real-life examples of these networking features, including load balancing, firewalling, security mitigation, and Kubernetes networking.<a contenteditable="false" data-primary="" data-startref="ch08.html0" data-type="indexterm" id="idm46123192078288"/></p>&#13;
</div></section>&#13;
<section class="pagebreak-before" data-pdf-bookmark="Exercises and Further Reading" data-type="sect1"><div class="sect1" id="exercises_and_further_reading">&#13;
<h1 class="less_space">Exercises and Further Reading</h1>&#13;
<p>Here are some ways to learn more about the range of networking use cases for eBPF:</p>&#13;
<ol>&#13;
<li><p>Modify the example XDP program <code>ping()</code> so that it generates different trace messages for ping responses and ping requests. The ICMP header immediately follows the IP header in the network packet (just like the IP header follows the Ethernet header). You’ll likely want to use <code>struct icmphdr</code> from <em>linux/icmp.h</em> and look at whether the type field shows <code>ICMP_ECHO</code> or <code>ICMP_ECHOREPLY</code>.</p></li>&#13;
<li><p>If you want to dive further into XDP programming, I recommend the xdp-project’s <a href="https://oreil.ly/UmJMF">xdp-tutorial</a>.</p></li>&#13;
<li><p>Use <a href="https://oreil.ly/Zuww7">sslsniff</a> from the BCC project to view the contents of encrypted traffic.</p></li>&#13;
<li><p>Explore Cilium by using tutorials and labs linked to from the <a href="https://cilium.io/get-started">Cilium website</a>.</p></li>&#13;
<li><p>Use the editor at <a class="orm:hideurl" href="https://networkpolicy.io"><em>networkpolicy.io</em></a> to visualize the effect of network policies in a Kubernetes deployment.</p></li>&#13;
</ol>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch08fn1"><sup><a href="ch08.html#ch08fn1-marker">1</a></sup> At the time of this writing, around 100 organizations have publicly announced their use of Cilium in its <a href="https://oreil.ly/PC7-G"><em>USERS.md</em> file</a>, though this number is growing quickly. Cilium has also been adopted by AWS, Google, and Microsoft.</p><p data-type="footnote" id="ch08fn2"><sup><a href="ch08.html#ch08fn2-marker">2</a></sup> This example is based on a talk I gave at eBPF Summit 2021 called <a href="https://oreil.ly/mQxtT">“A Load Balancer from scratch”</a>. Build an eBPF load balancer in just over 15 minutes!</p><p data-type="footnote" id="ch08fn3"><sup><a href="ch08.html#ch08fn3-marker">3</a></sup> If you want to explore this, try <a href="https://oreil.ly/YIh_t">CTF Challenge 3 from eBPF Summit 2022</a>. I won’t give spoilers here in the book, but you can see the solution in <a href="https://oreil.ly/_51rC">a walkthrough given by Duffie Cooley and me here</a>.</p><p data-type="footnote" id="ch08fn4"><sup><a href="ch08.html#ch08fn4-marker">4</a></sup> See Daniel Borkmann’s presentation <a href="https://oreil.ly/_8ZuF">“Little Helper Minions for Scaling Microservices”</a> that includes a history of eBPF, where he tells this anecdote.</p><p data-type="footnote" id="ch08fn5"><sup><a href="ch08.html#ch08fn5-marker">5</a></sup> Cilium maintains a <a href="https://oreil.ly/wCMjB">list of drivers that support XDP</a> within the <a href="https://oreil.ly/eB7vL">BPF and XDP Reference Guide</a>.</p><p data-type="footnote" id="ch08fn6"><sup><a href="ch08.html#ch08fn6-marker">6</a></sup> Ceznam shared data about the performance boost its team saw when experimenting with an eBPF-based load balancer in <a href="https://oreil.ly/0cbCx">this blog post</a>.</p><p data-type="footnote" id="ch08fn7"><sup><a href="ch08.html#ch08fn7-marker">7</a></sup> For a more complete overview of TC and its concepts, I recommend Quentin Monnet’s post <a href="https://oreil.ly/7gU2A">“Understanding tc “direct action” mode for BPF”</a>.</p><p data-type="footnote" id="ch08fn8"><sup><a href="ch08.html#ch08fn8-marker">8</a></sup> There is also a blog post that accompanies this example at <a href="https://blog.px.dev/ebpf-openssl-tracing"><em>https://blog.px.dev/ebpf-openssl-tracing</em></a>.</p><p data-type="footnote" id="ch08fn9"><sup><a href="ch08.html#ch08fn9-marker">9</a></sup> It’s possible for pods to be run in the host’s network namespace so that they share the IP address of the host, but this isn’t usually done unless there’s a good reason for an application running in the pod to require it.</p></div></div></section></body></html>