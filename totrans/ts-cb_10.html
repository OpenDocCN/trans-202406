<html><head></head><body><section data-pdf-bookmark="Chapter 9. The Standard Library &#10;and External Type Definitions" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch09">&#13;
<h1><span class="label">Chapter 9. </span>The Standard Library &#13;
<span class="keep-together">and External Type Definitions</span></h1>&#13;
&#13;
&#13;
<p><a data-primary="standard library and external type definitions" data-type="indexterm" id="id810"/>TypeScript’s lead architect, Anders Hejlsberg, once said that he envisions “TypeScript to be the Switzerland of JavaScript,” meaning that it doesn’t prefer or work toward compatibility with a single framework but rather tries to cater to all JavaScript frameworks and flavors. In the past, TypeScript worked on a decorator implementation to convince Google not to pursue the JavaScript dialect <a href="https://oreil.ly/ZrcKR">AtScript</a> for Angular, which was TypeScript plus decorators. The TypeScript decorator implementation also serves as a template for a respective <a href="https://oreil.ly/76JuE">ECMAScript proposal on decorators</a>. TypeScript also understands the JSX syntax extension, allowing frameworks like React or Preact to use TypeScript without limitations.</p>&#13;
&#13;
<p>But even if TypeScript tries to cater to all JavaScript developers and makes a huge effort to integrate new and useful features for a plethora of frameworks, there are still things it can’t or won’t do. Maybe because a certain feature is too niche, or maybe because a decision would have huge implications for too many developers.</p>&#13;
&#13;
<p>This is why TypeScript has been designed to be extensible by default. A lot of TypeScript’s features like namespaces, modules, and interfaces allow for declaration merging, which gives you the possibility to add type definitions to your liking.</p>&#13;
&#13;
<p>In this chapter, we look at how TypeScript deals with standard JavaScript functionality like modules, arrays, and objects. We will see some of their limitations, analyze the reasoning behind their limitations, and provide reasonable workarounds. You will see that TypeScript has been designed to be very flexible for various flavors of JavaScript, starting with sensible defaults, and giving you the opportunity to extend when you see fit.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="9.1 Iterating over Objects with Object.keys" data-type="sect1"><div class="sect1" id="ch09_working_with_object_keys">&#13;
<h1>9.1 Iterating over Objects with Object.keys</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id135">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="for-in loop" data-type="indexterm" id="ix_09-01-asciidoc0"/><a data-primary="iterating over objects with Object.keys" data-type="indexterm" id="ix_09-01-asciidoc1"/><a data-primary="Object.keys" data-type="indexterm" id="ix_09-01-asciidoc2"/><a data-primary="standard library and external type definitions" data-secondary="iterating over objects with Object.keys" data-type="indexterm" id="ix_09-01-asciidoc3"/>When you try to access object properties via iterating over its keys, TypeScript throws red squiggly lines at you, telling you that "<code>‘string’</code> can’t be used to index type.”</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id811">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a <code>for-in</code> loop instead of <code>Object.keys</code> and lock your type using generic type parameters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id136">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>A prominent head-scratcher in TypeScript is trying to access an object property via iterating through its keys. This pattern is so common in JavaScript, yet TypeScript seems to keep you from using it at all costs. We use this simple line to iterate over an object’s properties:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">person</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">k</code> <code class="o">=&gt;</code> <code class="nx">person</code><code class="p">[</code><code class="nx">k</code><code class="p">])</code></pre>&#13;
&#13;
<p>It leads to TypeScript throwing red squigglies at you and developers flipping tables: “Element implicitly has an <code>'any'</code> type because expression of type <code>'string'</code> can’t be used to index type <code>'Person'</code>.” In this situation, experienced JavaScript developers feel like TypeScript is working against them. But as with all decisions in TypeScript, there is a good reason why TypeScript behaves like this.</p>&#13;
&#13;
<p>Let’s find out why. Take a look at this function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">p</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">p</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">k</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code> <code class="nx">p</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>&#13;
<code class="c1">//                ^</code>&#13;
<code class="c1">// Element implicitly has an 'any' type because expression</code>&#13;
<code class="c1">// of type 'string' can't be used to index type 'Person'.</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>All we want is to print a <code>Person</code>’s fields by accessing them through its keys. TypeScript won’t allow this. <code>Object.keys(p)</code> returns a <code>string[]</code>, which is too wide to allow accessing a very defined object shape <code>Person</code>.</p>&#13;
&#13;
<p>But why is that? Isn’t it obvious that we only access keys that are available? That’s the whole point of using <code>Object.keys</code>! It is, but we are also able to pass objects that are subtypes of <code>Person</code>, which can have more properties than defined in <code>Person</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">me</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="nx">website</code><code class="o">:</code> <code class="s2">"https://fettblog.eu"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="nx">me</code><code class="p">);</code> <code class="c1">// All good!</code></pre>&#13;
&#13;
<p><code>printPerson</code> still should work correctly. It prints more properties, but it doesn’t break. It’s still the keys of <code>p</code>, so every property should be accessible. But what if you don’t access only <code>p</code>?</p>&#13;
&#13;
<p>Let’s assume <code>Object.keys</code> gives you <code>(keyof Person)[]</code>. You can easily write something like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">p</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">you</code><code class="o">: </code><code class="kr">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Reader"</code><code class="p">,</code>&#13;
    <code class="nx">age</code><code class="o">:</code> <code class="kc">NaN</code><code class="p">,</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">p</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">k</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code> <code class="nx">you</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">me</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="nx">website</code><code class="o">:</code> <code class="s2">"https://fettblog.eu"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="nx">me</code><code class="p">);</code></pre>&#13;
&#13;
<p>If <code>Object.keys(p)</code> returns an array of type <code>keyof Person[]</code>, you will be able to access other objects of <code>Person</code>, too. This might not add up. In our example, we just print undefined. But what if you try to do something with those values? This will break at runtime.</p>&#13;
&#13;
<p>TypeScript prevents you from scenarios like this. While we might think <code>Object.keys</code> is <code>keyof Person</code>, in reality, it can be so much more.</p>&#13;
&#13;
<p>One way to mitigate this problem is to use type guards:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">isKey</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">x</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">k</code><code class="o">:</code> <code class="nx">PropertyKey</code><code class="p">)</code><code class="o">:</code> <code class="nx">k</code> <code class="nx">is</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">x</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">p</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">p</code><code class="p">).</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">k</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">isKey</code><code class="p">(</code><code class="nx">p</code><code class="p">,</code> <code class="nx">k</code><code class="p">))</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code> <code class="nx">p</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code> <code class="c1">// All fine!</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But this adds an extra step that frankly shouldn’t be there.</p>&#13;
&#13;
<p>There’s another way to iterate over objects, using <code>for-in</code> loops:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">p</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">p</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code> <code class="nx">p</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>&#13;
<code class="c1">//                 ^</code>&#13;
<code class="c1">// Element implicitly has an 'any' type because expression</code>&#13;
<code class="c1">// of type 'string' can't be used to index type 'Person'.</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>TypeScript will throw the same error for the same reason because you still can do things like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="p">(</code><code class="nx">p</code><code class="o">: </code><code class="kr">Person</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">you</code><code class="o">: </code><code class="kr">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Reader"</code><code class="p">,</code>&#13;
    <code class="nx">age</code><code class="o">:</code> <code class="kc">NaN</code><code class="p">,</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">p</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code> <code class="nx">you</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">me</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="nx">website</code><code class="o">:</code> <code class="s2">"https://fettblog.eu"</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">printPerson</code><code class="p">(</code><code class="nx">me</code><code class="p">);</code></pre>&#13;
&#13;
<p>And it will break at runtime. However, writing it like this gives you a little edge over the <code>Object.keys</code> version. TypeScript can be much more exact in this scenario if you add a generic:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Person</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">p</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">p</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code> <code class="nx">p</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code> <code class="c1">// This works</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Instead of requiring <code>p</code> to be <code>Person</code> (and thus be compatible with all subtypes of &#13;
<span class="keep-together"><code>Person</code></span>), we add a new generic type parameter <code>T</code> that is a subtype of <code>Person</code>. This means all types that have been compatible with this function signature are still compatible, but the moment we use <code>p</code>, we are dealing with an explicit subtype, not the broader supertype <code>Person</code>.</p>&#13;
&#13;
<p>We substitute <code>T</code> for something that is compatible with <code>Person</code> but where TypeScript knows that it’s concrete enough to prevent errors.</p>&#13;
&#13;
<p>The preceding code works. <code>k</code> is of type <code>keyof T</code>. That’s why we can access <code>p</code>, which is of type <code>T</code>. And this technique still prevents us from accessing types that lack specific properties:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">printPerson</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Person</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">p</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">you</code><code class="o">: </code><code class="kr">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Reader"</code><code class="p">,</code>&#13;
    <code class="nx">age</code><code class="o">:</code> <code class="kc">NaN</code><code class="p">,</code>&#13;
  <code class="p">};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">p</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">k</code><code class="p">,</code> <code class="nx">you</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>&#13;
<code class="c1">//                 ^</code>&#13;
<code class="c1">//  Type 'Extract&lt;keyof T, string&gt;' cannot be used to index type 'Person'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can’t access a <code>Person</code> with <code>keyof T</code>. They might be different. But since <code>T</code> is a subtype of <code>Person</code>, we still can assign properties, if we know the exact property names:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">p</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="nx">you</code><code class="p">.</code><code class="nx">age</code></pre>&#13;
&#13;
<p>And that’s exactly what we want.</p>&#13;
&#13;
<p>TypeScript being very conservative about its types here is something that might seem odd at first, but it helps you in scenarios you wouldn’t think of. I guess this is the part where JavaScript developers usually scream at the compiler and think they’re “fighting” it, but maybe TypeScript saved you without you knowing it. For situations where this gets annoying, TypeScript at least gives you ways to work around it.<a data-startref="ix_09-01-asciidoc3" data-type="indexterm" id="id812"/><a data-startref="ix_09-01-asciidoc2" data-type="indexterm" id="id813"/><a data-startref="ix_09-01-asciidoc1" data-type="indexterm" id="id814"/><a data-startref="ix_09-01-asciidoc0" data-type="indexterm" id="id815"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="9.2 Explicitly Highlighting Unsafe Operations with &#10;Type Assertions and unknown" data-type="sect1"><div class="sect1" id="ch09_unsafe_operations">&#13;
<h1>9.2 Explicitly Highlighting Unsafe Operations with &#13;
<span class="keep-together">Type Assertions and unknown</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id137">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="standard library and external type definitions" data-secondary="explicitly highlighting unsafe operations with type assertions and unknown" data-type="indexterm" id="ix_09-02-asciidoc0"/><a data-primary="type assertions" data-secondary="explicit highlighting unsafe operations with type assertions and unknown" data-type="indexterm" id="ix_09-02-asciidoc1"/><a data-primary="unknown type" data-secondary="explicit highlighting unsafe operations with type assertions and unknown" data-type="indexterm" id="ix_09-02-asciidoc2"/><a data-primary="unsafe operations, highlighting with type assertions and unknown" data-type="indexterm" id="ix_09-02-asciidoc3"/>Parsing arbitrary data via JSON operations can go wrong if the data is not correct. TypeScript’s defaults don’t provide any safeguards for these unsafe operations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id227">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="type annotations" data-secondary="type assertions as substitute for" data-type="indexterm" id="ix_09-02-asciidoc4"/>Explicitly highlight unsafe operations by using type assertions instead of type annotations, and make sure they are enforced by patching the original types with <code>unknown</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id138">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#ch03_item_assertions">Recipe 3.9</a> we spoke about how to effectively use type assertions. Type assertions are an explicit call to the type system to say that some type should be a different one, and based on some set of guardrails—for example, not saying <code>number</code> is actually <code>string</code>—TypeScript will treat this particular value as the new type.</p>&#13;
&#13;
<p>With TypeScript’s rich and extensive type system, sometimes type assertions are inevitable. Sometimes you even want them, as shown in <a data-type="xref" href="ch03.html#ch03_item_assertions">Recipe 3.9</a> where we use the <code>fetch</code> API to get JSON data from a backend. One way is to call <code>fetch</code> and assign the results to an annotated type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">ppl</code><code class="o">: </code><code class="kr">Person</code><code class="p">[]</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/people"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code></pre>&#13;
&#13;
<p><code>res.json()</code> results in <code>any</code>,<sup><a data-type="noteref" href="ch09.html#id816" id="id816-marker">1</a></sup> and everything that is <code>any</code> can be changed to any other type through a type annotation. There is no guarantee that the result is actually &#13;
<span class="keep-together"><code>Person[]</code>.</span></p>&#13;
&#13;
<p>The other way is to use a type assertion instead of a type annotation:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">ppl</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/people"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code> <code class="kr">as</code> <code class="nx">Person</code><code class="p">[];</code></pre>&#13;
&#13;
<p>For the type system, this is the same thing, but we can easily scan situations where there might be problems. If we don’t validate our incoming values against types (with, for example, Zod; see <a data-type="xref" href="ch12.html#ch12_zod">Recipe 12.5</a>), then having a type assertion here is an effective way of highlighting unsafe operations.</p>&#13;
&#13;
<p><em>Unsafe</em> operations in a type system are situations where we tell the type system that we expect values to be of a certain type, but we don’t have any guarantee from the type system itself that this will actually be true. This happens mostly at the borders of our application, where we load data from someplace, deal with user input, or parse data with built-in methods.</p>&#13;
&#13;
<p>Unsafe operations can be highlighted by using certain keywords that indicate an explicit change in the type system. Type assertions (<code>as</code>), type predicates (<code>is</code>), or assertion signatures (<code>asserts</code>) help us find those situations. In some cases, TypeScript even forces us either to comply with its view of types or to explicitly change the rules based on our situations. But not always.</p>&#13;
&#13;
<p>When we fetch data from some backend, it is just as easy to annotate as it is to write a type assertion. Things like that can be overlooked if we don’t force ourselves to use the correct technique.</p>&#13;
&#13;
<p>But we can help TypeScript help us do the right thing. The problem is the call to <code>res.json()</code>, which comes from the <code>Body</code> interface in <em>lib.dom.d.ts</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nx">Body</code> <code class="p">{</code>&#13;
  <code class="kr">readonly</code> <code class="nx">body</code><code class="o">:</code> <code class="nx">ReadableStream</code><code class="o">&lt;</code><code class="nx">Uint8Array</code><code class="o">&gt;</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code>&#13;
  <code class="kr">readonly</code> <code class="nx">bodyUsed</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
  <code class="nx">arrayBuffer</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">ArrayBuffer</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="nx">blob</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">Blob</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="nx">formData</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">FormData</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="nx">json</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kr">any</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="nx">text</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>json()</code> call returns a <code>Promise&lt;any&gt;</code>, and <code>any</code> is the loosey-goosey type where TypeScript just ignores any type-check at all. We would need <code>any</code>’s cautious brother, <code>unknown</code>. Thanks to declaration merging, we can override the <code>Body</code> type definition and define <code>json()</code> to be a bit more restrictive:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nx">Body</code> <code class="p">{</code>&#13;
  <code class="nx">json</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kr">unknown</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The moment we do a type annotation, TypeScript yells at us that we can’t assign <code>unknown</code> to <code>Person[]</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">ppl</code><code class="o">: </code><code class="kr">Person</code><code class="p">[]</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/people"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>&#13;
<code class="c1">//    ^</code>&#13;
<code class="c1">// Type 'unknown' is not assignable to type 'Person[]'.ts(2322)</code></pre>&#13;
&#13;
<p>But TypeScript is still happy if we do a type assertion:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">ppl</code> <code class="o">=</code> <code class="kr">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/people"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code> <code class="kr">as</code> <code class="nx">Person</code><code class="p">[];</code></pre>&#13;
&#13;
<p>And with that, we can force TypeScript to highlight <a data-startref="ix_09-02-asciidoc4" data-type="indexterm" id="id817"/>unsafe operations<a data-startref="ix_09-02-asciidoc3" data-type="indexterm" id="id818"/><a data-startref="ix_09-02-asciidoc2" data-type="indexterm" id="id819"/><a data-startref="ix_09-02-asciidoc1" data-type="indexterm" id="id820"/><a data-startref="ix_09-02-asciidoc0" data-type="indexterm" id="id821"/>.<sup><a data-type="noteref" href="ch09.html#id822" id="id822-marker">2</a></sup></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="9.3 Working with defineProperty" data-type="sect1"><div class="sect1" id="ch09_define_property">&#13;
<h1>9.3 Working with defineProperty</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id139">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="defineProperty" data-type="indexterm" id="ix_09-03-asciidoc0"/><a data-primary="object properties" data-type="indexterm" id="ix_09-03-asciidoc1"/><a data-primary="Object.defineProperty" data-type="indexterm" id="ix_09-03-asciidoc2"/><a data-primary="standard library and external type definitions" data-secondary="working with defineProperty" data-type="indexterm" id="ix_09-03-asciidoc3"/><a data-primary="wrapper function" data-type="indexterm" id="ix_09-03-asciidoc4"/>You define properties on the fly using <code>Object.defineProperty</code>, but TypeScript doesn’t pick up changes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id823">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a wrapper function and use assertion signatures to change the object’s type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id140">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>In JavaScript, you can define object properties on the fly with <code>Ob⁠je⁠ct.de⁠fi⁠ne​Pr⁠op⁠er⁠ty</code>. This is useful if you want your properties to be read-only. Think of a storage object that has a maximum value that shouldn’t be overwritten:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">storage</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">currentValue</code><code class="o">:</code> <code class="mi">0</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">storage</code><code class="p">,</code> <code class="s1">'maxValue'</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="mi">9001</code><code class="p">,</code>&#13;
  <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">storage</code><code class="p">.</code><code class="nx">maxValue</code><code class="p">);</code> <code class="c1">// 9001</code>&#13;
&#13;
<code class="nx">storage</code><code class="p">.</code><code class="nx">maxValue</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">storage</code><code class="p">.</code><code class="nx">maxValue</code><code class="p">);</code> <code class="c1">// still 9001</code></pre>&#13;
&#13;
<p><code>defineProperty</code> and property descriptors are very complex. They allow you to do everything with properties that usually is reserved for built-in objects. So they’re common in larger codebases. TypeScript has a problem with <code>defineProperty</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">storage</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">currentValue</code><code class="o">:</code> <code class="mi">0</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">storage</code><code class="p">,</code> <code class="s1">'maxValue'</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="mi">9001</code><code class="p">,</code>&#13;
  <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">storage</code><code class="p">.</code><code class="nx">maxValue</code><code class="p">);</code>&#13;
<code class="c1">//                  ^</code>&#13;
<code class="c1">// Property 'maxValue' does not exist on type '{ currentValue: number; }'.</code></pre>&#13;
&#13;
<p>If we don’t explicitly assert to a new type, we don’t get <code>maxValue</code> attached to the type of <code>storage</code>. However, for simple use cases, we can help ourselves using &#13;
<span class="keep-together">assertion signatures.</span></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>While TypeScript might not feature object changes when using <code>Object.defineProperty</code>, there is a chance that the team will add typings or special behavior for cases like this in the future. For example, checking if an object has a certain property using the <code>in</code> keyword didn’t affect types for years. This changed in 2022 with <a href="https://oreil.ly/YpyGG">TypeScript 4.9</a>.</p>&#13;
</div>&#13;
&#13;
<p>Think of an <code>assertIsNumber</code> function where you can make sure some value is of type <code>number</code>. Otherwise, it throws an error. This is similar to the <code>assert</code> function in Node.js:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">assertIsNumber</code><code class="p">(</code><code class="nx">val</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">val</code> <code class="o">!==</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="k">new</code> <code class="nx">AssertionError</code><code class="p">(</code><code class="s2">"Not a number!"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">multiply</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">assertIsNumber</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>&#13;
  <code class="nx">assertIsNumber</code><code class="p">(</code><code class="nx">y</code><code class="p">);</code>&#13;
  <code class="c1">// at this point I'm sure x and y are numbers</code>&#13;
  <code class="c1">// if one assert condition is not true, this position</code>&#13;
  <code class="c1">// is never reached</code>&#13;
  <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To comply with behavior like this, we can add an assertion signature that tells TypeScript that we know more about the type after this function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">assertIsNumber</code><code class="p">(</code><code class="nx">val</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="o">:</code> <code class="nx">asserts</code> <code class="nx">val</code> <code class="nx">is</code> <code class="kt">number</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">val</code> <code class="o">!==</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">throw</code> <code class="k">new</code> <code class="nx">AssertionError</code><code class="p">(</code><code class="s2">"Not a number!"</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This works a lot like type predicates (see <a data-type="xref" href="ch03.html#ch03_item_type_predicates">Recipe 3.5</a>) but without the control flow of a condition-based structure like <code>if</code> or <code>switch</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">multiply</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">assertIsNumber</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>&#13;
  <code class="nx">assertIsNumber</code><code class="p">(</code><code class="nx">y</code><code class="p">);</code>&#13;
  <code class="c1">// Now also TypeScript knows that both x and y are numbers</code>&#13;
  <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you look at it closely, you can see those assertion signatures can <em>change the type of a parameter or variable on the fly</em>. This is what <code>Object.defineProperty</code> does as well.</p>&#13;
&#13;
<p>The following helper does not aim to be 100% accurate or complete. It might have errors, and it might not tackle every edge case of the <code>defineProperty</code> specification. But it will give us the basic functionality. First, we define a new function called <code>de⁠fin⁠e​Pr⁠ope⁠rty</code> that we use as a wrapper function for <code>Object.defineProperty</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">defineProperty</code><code class="o">&lt;</code>&#13;
  <code class="nx">Obj</code> <code class="kr">extends</code> <code class="nx">object</code><code class="p">,</code>&#13;
  <code class="nx">Key</code> <code class="kr">extends</code> <code class="nx">PropertyKey</code><code class="p">,</code>&#13;
  <code class="nx">PDesc</code> <code class="kr">extends</code> <code class="nx">PropertyDescriptor</code><code class="o">&gt;</code>&#13;
  <code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="nx">Obj</code><code class="p">,</code> <code class="nx">prop</code><code class="o">:</code> <code class="nx">Key</code><code class="p">,</code> <code class="nx">val</code><code class="o">:</code> <code class="nx">PDesc</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">prop</code><code class="p">,</code> <code class="nx">val</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We work with three generics:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The object we want to modify, of type <code>Obj</code>, which is a subtype of <code>object</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Type <code>Key</code>, which is a subtype of <code>PropertyKey</code> (built-in): <code>string | number | ​sy⁠mb⁠ol</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>PDesc</code>, a subtype of <code>PropertyDescriptor</code> (built-in). This allows us to define the property with all its features (writability, enumerability, reconfigurability).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We use generics because TypeScript can narrow them to a very specific unit type. <code>PropertyKey</code>, for example, is all numbers, strings, and symbols. But if we use <code>Key extends PropertyKey</code>, we can pinpoint <code>prop</code> to be, for example, type <code>"maxValue"</code>. This is helpful if we want to change the original type by adding more properties.</p>&#13;
&#13;
<p>The <code>Object.defineProperty</code> function either changes the object or throws an error should something go wrong. That’s exactly what an assertion function does. Our custom helper <code>defineProperty</code> thus does the same.</p>&#13;
&#13;
<p>Let’s add an assertion signature. Once <code>defineProperty</code> successfully executes, our object has another property. We are creating some helper types for that. The signature first:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">defineProperty</code><code class="o">&lt;</code>&#13;
  <code class="nx">Obj</code> <code class="kr">extends</code> <code class="nx">object</code><code class="p">,</code>&#13;
  <code class="nx">Key</code> <code class="kr">extends</code> <code class="nx">PropertyKey</code><code class="p">,</code>&#13;
  <code class="nx">PDesc</code> <code class="kr">extends</code> <code class="nx">PropertyDescriptor</code><code class="o">&gt;</code>&#13;
   <code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="nx">Obj</code><code class="p">,</code> <code class="nx">prop</code><code class="o">:</code> <code class="nx">Key</code><code class="p">,</code> <code class="nx">val</code><code class="o">:</code> <code class="nx">PDesc</code><code class="p">)</code><code class="o">:</code>&#13;
     <code class="nx">asserts</code> <code class="nx">obj</code> <code class="nx">is</code> <code class="nx">Obj</code> <code class="o">&amp;</code> <code class="nx">DefineProperty</code><code class="o">&lt;</code><code class="nx">Key</code><code class="p">,</code> <code class="nx">PDesc</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">prop</code><code class="p">,</code> <code class="nx">val</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><code>obj</code> then is of type <code>Obj</code> (narrowed through a generic) and our newly defined property.</p>&#13;
&#13;
<p>This is the <code>DefineProperty</code> helper type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">DefineProperty</code><code class="o">&lt;</code>&#13;
  <code class="nx">Prop</code> <code class="kr">extends</code> <code class="nx">PropertyKey</code><code class="p">,</code>&#13;
  <code class="nx">Desc</code> <code class="kr">extends</code> <code class="nx">PropertyDescriptor</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
    <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">set</code><code class="p">(</code><code class="nx">val</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="kr">any</code> <code class="p">}</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code>&#13;
    <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">get</code><code class="p">()</code><code class="o">:</code> <code class="kr">any</code> <code class="p">}</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code>&#13;
    <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">Readonly</code><code class="o">&lt;</code><code class="nx">InferValue</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">Desc</code><code class="o">&gt;&gt;</code> <code class="o">:</code>&#13;
    <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">InferValue</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">Desc</code><code class="o">&gt;</code> <code class="o">:</code>&#13;
    <code class="nx">Readonly</code><code class="o">&lt;</code><code class="nx">InferValue</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">Desc</code><code class="o">&gt;&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>First, we deal with the <code>writable</code> property of a <code>PropertyDescriptor</code>. It’s a set of conditions to define some edge cases and conditions of how the original property descriptors work:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If we set <code>writable</code> and any property accessor (<code>get</code>, <code>set</code>), we fail. <code>never</code> tells us that an error was thrown.</p>&#13;
</li>&#13;
<li>&#13;
<p>If we set <code>writable</code> to <code>false</code>, the property is read-only. We defer to the <code>InferValue</code> helper type.</p>&#13;
</li>&#13;
<li>&#13;
<p>If we set <code>writable</code> to <code>true</code>, the property is not read-only. We defer as well.</p>&#13;
</li>&#13;
<li>&#13;
<p>The last default case is the same as <code>writable: false</code>, so <code>Readonly&lt;InferValue&lt;Prop, Desc&gt;&gt;</code>. (<code>Readonly&lt;T&gt;</code> is built-in.)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This is the <code>InferValue</code> helper type, dealing with the set <code>value</code> property:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">InferValue</code><code class="o">&lt;</code><code class="nx">Prop</code> <code class="kr">extends</code> <code class="nx">PropertyKey</code><code class="p">,</code> <code class="nx">Desc</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">get</code><code class="p">()</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code> <code class="p">}</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code>&#13;
  <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">T</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">:</code>&#13;
  <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">get</code><code class="p">()</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">T</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Again a set of conditions:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Do we have a getter and a value set? <code>Object.defineProperty</code> throws an error, so <code>never</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If we have set a value, let’s infer the type of this value and create an object with our defined property key and the value type.</p>&#13;
</li>&#13;
<li>&#13;
<p>Or we infer the type from the return type of a getter.</p>&#13;
</li>&#13;
<li>&#13;
<p>Anything else we forget. TypeScript won’t let us work with the object as it’s becoming <code>never</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Lots of helper types, but roughly 20 lines of code to get it right:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">InferValue</code><code class="o">&lt;</code><code class="nx">Prop</code> <code class="kr">extends</code> <code class="nx">PropertyKey</code><code class="p">,</code> <code class="nx">Desc</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">get</code><code class="p">()</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code> <code class="p">}</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code>&#13;
  <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">T</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">:</code>&#13;
  <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">get</code><code class="p">()</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">T</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">DefineProperty</code><code class="o">&lt;</code>&#13;
  <code class="nx">Prop</code> <code class="kr">extends</code> <code class="nx">PropertyKey</code><code class="p">,</code>&#13;
  <code class="nx">Desc</code> <code class="kr">extends</code> <code class="nx">PropertyDescriptor</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
    <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">set</code><code class="p">(</code><code class="nx">val</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code><code class="o">:</code> <code class="kr">any</code> <code class="p">}</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code>&#13;
    <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">get</code><code class="p">()</code><code class="o">:</code> <code class="kr">any</code> <code class="p">}</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code>&#13;
    <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">Readonly</code><code class="o">&lt;</code><code class="nx">InferValue</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">Desc</code><code class="o">&gt;&gt;</code> <code class="o">:</code>&#13;
    <code class="nx">Desc</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">InferValue</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">Desc</code><code class="o">&gt;</code> <code class="o">:</code>&#13;
    <code class="nx">Readonly</code><code class="o">&lt;</code><code class="nx">InferValue</code><code class="o">&lt;</code><code class="nx">Prop</code><code class="p">,</code> <code class="nx">Desc</code><code class="o">&gt;&gt;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">defineProperty</code><code class="o">&lt;</code>&#13;
  <code class="nx">Obj</code> <code class="kr">extends</code> <code class="nx">object</code><code class="p">,</code>&#13;
  <code class="nx">Key</code> <code class="kr">extends</code> <code class="nx">PropertyKey</code><code class="p">,</code>&#13;
  <code class="nx">PDesc</code> <code class="kr">extends</code> <code class="nx">PropertyDescriptor</code><code class="o">&gt;</code>&#13;
  <code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="nx">Obj</code><code class="p">,</code> <code class="nx">prop</code><code class="o">:</code> <code class="nx">Key</code><code class="p">,</code> <code class="nx">val</code><code class="o">:</code> <code class="nx">PDesc</code><code class="p">)</code><code class="o">:</code>&#13;
    <code class="nx">asserts</code>  <code class="nx">obj</code> <code class="nx">is</code> <code class="nx">Obj</code> <code class="o">&amp;</code> <code class="nx">DefineProperty</code><code class="o">&lt;</code><code class="nx">Key</code><code class="p">,</code> <code class="nx">PDesc</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">prop</code><code class="p">,</code> <code class="nx">val</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s see what TypeScript does with our changes:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">storage</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">currentValue</code><code class="o">:</code> <code class="mi">0</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">defineProperty</code><code class="p">(</code><code class="nx">storage</code><code class="p">,</code> <code class="s1">'maxValue'</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">9001</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">storage</code><code class="p">.</code><code class="nx">maxValue</code><code class="p">;</code> <code class="c1">// it's a number</code>&#13;
<code class="nx">storage</code><code class="p">.</code><code class="nx">maxValue</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code> <code class="c1">// Error! It's read-only</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">storageName</code> <code class="o">=</code> <code class="s1">'My Storage'</code><code class="p">;</code>&#13;
<code class="nx">defineProperty</code><code class="p">(</code><code class="nx">storage</code><code class="p">,</code> <code class="s1">'name'</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">get</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">storageName</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">storage</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code> <code class="c1">// it's a string!</code>&#13;
&#13;
<code class="c1">// it's not possible to assign a value and a getter</code>&#13;
<code class="nx">defineProperty</code><code class="p">(</code><code class="nx">storage</code><code class="p">,</code> <code class="s1">'broken'</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">get</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">storageName</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="mi">4000</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// storage is never because we have a malicious</code>&#13;
<code class="c1">// property descriptor</code>&#13;
<code class="nx">storage</code><code class="p">;</code></pre>&#13;
&#13;
<p>While this might not cover everything, there is already a lot done for simple &#13;
<span class="keep-together">property definitions</span>.<a data-startref="ix_09-03-asciidoc4" data-type="indexterm" id="id824"/><a data-startref="ix_09-03-asciidoc3" data-type="indexterm" id="id825"/><a data-startref="ix_09-03-asciidoc2" data-type="indexterm" id="id826"/><a data-startref="ix_09-03-asciidoc1" data-type="indexterm" id="id827"/><a data-startref="ix_09-03-asciidoc0" data-type="indexterm" id="id828"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="9.4 Expanding Types for Array.prototype.includes" data-type="sect1"><div class="sect1" id="ch09_array_includes">&#13;
<h1>9.4 Expanding Types for Array.prototype.includes</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id141">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="Array.prototype.includes" data-type="indexterm" id="ix_09-04-asciidoc0"/><a data-primary="generic helper functions" data-type="indexterm" id="ix_09-04-asciidoc1"/><a data-primary="standard library and external type definitions" data-secondary="expanding types for Array.prototype.includes" data-type="indexterm" id="ix_09-04-asciidoc2"/>TypeScript won’t be able to look for an element of a broad type like <code>string</code> or <code>number</code> within a very narrow tuple or array.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id829">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create generic helper functions with type predicates, where you change the &#13;
<span class="keep-together">relationship</span> between type parameters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id830">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>We create an array called <code>actions</code>, which contains a set of actions in string format that we want to execute. The resulting type of this <code>actions</code> array is <code>string[]</code>.</p>&#13;
&#13;
<p>The <code>execute</code> function takes any string as an argument. We check if this is a valid action, and if so, do something:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// actions: string[]</code>&#13;
<code class="kr">const</code> <code class="nx">actions</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"CREATE"</code><code class="p">,</code> <code class="s2">"READ"</code><code class="p">,</code> <code class="s2">"UPDATE"</code><code class="p">,</code> <code class="s2">"DELETE"</code><code class="p">];</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">execute</code><code class="p">(</code><code class="nx">action</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">actions</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">action</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="c1">// do something with action</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It gets a little trickier if we want to narrow the <code>string[]</code> to something more concrete, a subset of all possible strings. By adding <em>const context</em> via <code>as const</code>, we can narrow <code>actions</code> to be of type <code>readonly ["CREATE", "READ", "UPDATE", "DELETE"]</code>.</p>&#13;
&#13;
<p>This is handy if we want to do exhaustiveness checking to make sure we have cases for all available actions. However, <code>actions.includes</code> does not agree with us:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Adding const context</code>&#13;
<code class="c1">// actions: readonly ["CREATE", "READ", "UPDATE", "DELETE"]</code>&#13;
<code class="kr">const</code> <code class="nx">actions</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"CREATE"</code><code class="p">,</code> <code class="s2">"READ"</code><code class="p">,</code> <code class="s2">"UPDATE"</code><code class="p">,</code> <code class="s2">"DELETE"</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">execute</code><code class="p">(</code><code class="nx">action</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">actions</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">action</code><code class="p">))</code> <code class="p">{</code>&#13;
<code class="c1">//                     ^</code>&#13;
<code class="c1">// Argument of type 'string' is not assignable to parameter of type</code>&#13;
<code class="c1">// '"CREATE" | "READ" | "UPDATE" | "DELETE"'.(2345)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Why is that? Let’s look at the typings of <code>Array&lt;T&gt;</code> and <code>ReadonlyArray&lt;T&gt;</code> (we work with the latter due to <em>const context</em>):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="cm">/**</code>&#13;
<code class="cm">   * Determines whether an array includes a certain element,</code>&#13;
<code class="cm">   * returning true or false as appropriate.</code>&#13;
<code class="cm">   * @param searchElement The element to search for.</code>&#13;
<code class="cm">   * @param fromIndex The position in this array at which</code>&#13;
<code class="cm">   *   to begin searching for searchElement.</code>&#13;
<code class="cm">   */</code>&#13;
  <code class="nx">includes</code><code class="p">(</code><code class="nx">searchElement</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">fromIndex</code><code class="o">?:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="cm">/**</code>&#13;
<code class="cm">   * Determines whether an array includes a certain element,</code>&#13;
<code class="cm">   * returning true or false as appropriate.</code>&#13;
<code class="cm">   * @param searchElement The element to search for.</code>&#13;
<code class="cm">   * @param fromIndex The position in this array at which</code>&#13;
<code class="cm">   *   to begin searching for searchElement.</code>&#13;
<code class="cm">   */</code>&#13;
  <code class="nx">includes</code><code class="p">(</code><code class="nx">searchElement</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">fromIndex</code><code class="o">?:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The element we want to search for (<code>searchElement</code>) needs to be of the same type as the array itself! So if we have <code>Array&lt;string&gt;</code> (or <code>string[]</code> or <code>Re⁠ad⁠on⁠ly​Ar⁠ra⁠y&lt;s⁠tr⁠in⁠g&gt;</code>), we can search only for strings. In our case, this would mean that <code>action</code> needs to be of type <code>"CREATE" | "READ" | "UPDATE" | "DELETE"</code>.</p>&#13;
&#13;
<p>Suddenly, our program doesn’t make a lot of sense anymore. Why do we search for something if the type already tells us that it can be just one of four strings? If we change the type for <code>action</code> to <code>"CREATE" | "READ" | "UPDATE" | "DELETE"</code>, <code>actions.includes</code> becomes obsolete. If we don’t change it, TypeScript throws an error at us, and rightfully so!</p>&#13;
&#13;
<p>One of the problems is that TypeScript lacks the possibility to check for contravariant types with, for example, upper-bound generics. We can tell if a type should be a <em>subset</em> of type <code>T</code> with constructs like <code>extends</code>; we can’t check if a type is a <em>superset</em> of <code>T</code>. At least not yet!</p>&#13;
&#13;
<p>So what can we do?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Option 1: Redeclare ReadonlyArray" data-type="sect3"><div class="sect3" id="id831">&#13;
<h3>Option 1: Redeclare ReadonlyArray</h3>&#13;
&#13;
<p>One option that comes to mind is changing how <code>includes</code> in <code>ReadonlyArray</code> should behave. Thanks to declaration merging, we can add our own definitions for <code>Re⁠ad⁠on⁠ly​Ar⁠ray</code> that are a bit looser in the arguments and more specific in the result, like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">includes</code><code class="p">(</code><code class="nx">searchElement</code><code class="o">:</code> <code class="kr">any</code><code class="p">,</code> <code class="nx">fromIndex</code><code class="o">?:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">searchElement</code> <code class="nx">is</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This allows for a broader set of <code>searchElement</code> values to be passed (literally any!), and if the condition is true, we tell TypeScript through a <em>type predicate</em> that <code>se⁠ar⁠ch​Ele⁠men⁠t is⁠ T</code> (the subset we are looking for).</p>&#13;
&#13;
<p>Turns out, this works pretty well:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">actions</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"CREATE"</code><code class="p">,</code> <code class="s2">"READ"</code><code class="p">,</code> <code class="s2">"UPDATE"</code><code class="p">,</code> <code class="s2">"DELETE"</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">execute</code><code class="p">(</code><code class="nx">action</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="nx">actions</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">action</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="c1">// action: "CREATE" | "READ" | "UPDATE" | "DELETE"</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There’s a problem, though. The solution works but takes the assumption of what’s correct and what needs to be checked. If you change <code>action</code> to <code>number</code>, TypeScript usually throws an error that you can’t search for that kind of type. <code>actions</code> only consists of <code>string</code>, so why even look at <code>number</code>? This is an error you want to catch:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// type number has no relation to actions at all</code>&#13;
<code class="kd">function</code> <code class="nx">execute</code><code class="p">(</code><code class="nx">action</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="nx">actions</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">action</code><code class="p">))</code> <code class="p">{</code>&#13;
    <code class="c1">// do something</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With our change to <code>ReadonlyArray</code>, we lose this check as <code>searchElement</code> is <code>any</code>. While the functionality of <code>action.includes</code> still works as intended, we might not see the right <em>problem</em> once we change function signatures along the way.</p>&#13;
&#13;
<p>Also, and more important, we change the behavior of built-in types. This might change your type-checks somewhere else and might cause problems in the long run!</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you do a <em>type patch</em> by changing behavior from the standard library, be sure to do this module scoped, and not globally.</p>&#13;
</div>&#13;
&#13;
<p>There is another way.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Option 2: A helper with type assertions" data-type="sect3"><div class="sect3" id="id142">&#13;
<h3>Option 2: A helper with type assertions</h3>&#13;
&#13;
<p>As originally stated, one of the problems is that TypeScript lacks the possibility to check if a value belongs to a <em>superset</em> of a generic parameter. With a helper function, we can turn this relationship around:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">includes</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">U</code><code class="p">,</code> <code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">coll</code><code class="o">:</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">el</code><code class="o">:</code> <code class="nx">U</code><code class="p">)</code><code class="o">:</code> <code class="nx">el</code> <code class="nx">is</code> <code class="nx">T</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">coll</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">el</code> <code class="kr">as</code> <code class="nx">T</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>includes</code> function takes the <code>ReadonlyArray&lt;T&gt;</code> as an argument and searches for an element that is of type <code>U</code>. We check through our generic bounds that <code>T extends U</code>, which means that <code>U</code> is a <em>superset</em> of <code>T</code> (or <code>T</code> is a <em>subset</em> of <code>U</code>). If the method returns <code>true</code>, we can say for sure that <code>el</code> is of the <em>narrower</em> type <code>U</code>.</p>&#13;
&#13;
<p>The only thing that we need to make the implementation work is to do a little type assertion the moment we pass <code>el</code> to <code>Array.prototype.includes</code>. The original problem is still there! The type assertion <code>el as T</code> is OK, though, as we check possible problems already in the function signature.</p>&#13;
&#13;
<p>This means the moment we change, for example, <code>action</code> to <code>number</code>, we get the right errors throughout our code:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">execute</code><code class="p">(</code><code class="nx">action</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code><code class="p">(</code><code class="nx">includes</code><code class="p">(</code><code class="nx">actions</code><code class="p">,</code> <code class="nx">action</code><code class="p">))</code> <code class="p">{</code>&#13;
<code class="c1">//            ^</code>&#13;
<code class="c1">// Argument of type 'readonly ["CREATE", "READ", "UPDATE", "DELETE"]'</code>&#13;
<code class="c1">// is not assignable to parameter of type 'readonly number[]'.</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And this is the behavior we want. A nice touch is that TypeScript wants us to change the array, not the element we are looking for. This is due to the relationship between the generic type parameters.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The same solutions also work if you run into similar troubles with <code>Array.prototype.indexOf</code>.</p>&#13;
</div>&#13;
&#13;
<p>TypeScript aims to get all standard JavaScript functionality correct, but sometimes you have to make trade-offs. This case calls for trade-offs: do you allow for an argument list that’s looser than you would expect, or do you throw errors for types where you already should know more?</p>&#13;
&#13;
<p>Type assertions, declaration merging, and other tools help us get around that in situations where the type system can’t help us. Not until it becomes better than before, by allowing us to move even further in the type space.<a data-startref="ix_09-04-asciidoc2" data-type="indexterm" id="id832"/><a data-startref="ix_09-04-asciidoc1" data-type="indexterm" id="id833"/><a data-startref="ix_09-04-asciidoc0" data-type="indexterm" id="id834"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="9.5 Filtering Nullish Values" data-type="sect1"><div class="sect1" id="ch08_nullish_values">&#13;
<h1>9.5 Filtering Nullish Values</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id143">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="Boolean constructor, filtering nullish values with" data-type="indexterm" id="ix_09-08-asciidoc0"/><a data-primary="declaration merging" data-secondary="filtering nullish values" data-type="indexterm" id="ix_09-08-asciidoc1"/><a data-primary="filter method" data-type="indexterm" id="ix_09-08-asciidoc2"/><a data-primary="nullish values, filtering" data-type="indexterm" id="ix_09-08-asciidoc3"/><a data-primary="standard library and external type definitions" data-secondary="filtering nullish values" data-type="indexterm" id="ix_09-08-asciidoc4"/>You want to use the Boolean constructor to filter nullish values from an array, but TypeScript still yields the same types, including <code>null</code> and <code>undefined</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id835">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Overload the <code>filter</code> method from <code>Array</code> using declaration merging.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id144">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Sometimes you have collections that could include <em>nullish</em> values (<code>undefined</code> or <code>null</code>):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// const array: (number | null | undefined)[]</code>&#13;
<code class="kr">const</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="kc">null</code><code class="p">];</code></pre>&#13;
&#13;
<p>To continue working, you want to remove those nullish values from your collection. <a data-primary="falsy values" data-type="indexterm" id="id836"/><a data-primary="truthiness of a value" data-type="indexterm" id="id837"/>This is typically done using the <code>filter</code> method of <code>Array</code>, maybe by checking the <em>truthiness</em> of a value. <code>null</code> and <code>undefined</code> are <em>falsy</em>, so they get filtered out:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">filtered</code> <code class="o">=</code> <code class="nx">array</code><code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">val</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="o">!!</code><code class="nx">val</code><code class="p">);</code></pre>&#13;
&#13;
<p>A convenient way of checking the truthiness of a value is by passing it to the Boolean constructor. This is short, on point, and very elegant to read:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// const array: (number | null | undefined)[]</code>&#13;
<code class="kr">const</code> <code class="nx">filtered</code> <code class="o">=</code> <code class="nx">array</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nb">Boolean</code><code class="p">);</code></pre>&#13;
&#13;
<p>But sadly, it doesn’t change our type. We still have <code>null</code> and <code>undefined</code> as possible types for the filtered array.</p>&#13;
&#13;
<p>By opening up the <code>Array</code> interface and adding another declaration for <code>filter</code>, we can add this special case as an overload:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">interface</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">filter</code><code class="p">(</code><code class="nx">predicate</code><code class="o">:</code> <code class="nx">BooleanConstructor</code><code class="p">)</code><code class="o">:</code> <code class="nx">NonNullable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">[]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">filter</code><code class="p">(</code><code class="nx">predicate</code><code class="o">:</code> <code class="nx">BooleanConstructor</code><code class="p">)</code><code class="o">:</code> <code class="nx">NonNullable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">[]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And with that, we get rid of nullish types and have more clarity on the type of our array’s contents:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// const array: number[]</code>&#13;
<code class="kr">const</code> <code class="nx">filtered</code> <code class="o">=</code> <code class="nx">array</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nb">Boolean</code><code class="p">);</code></pre>&#13;
&#13;
<p>Neat! What’s the caveat? Literal tuples and arrays. <code>BooleanConstructor</code> filters not only nullish values but also falsy values. To get the right elements, we not only have to return <code>NonNullable&lt;T&gt;</code> but also introduce a type that checks for truthy values:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Truthy</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="s2">""</code> <code class="o">|</code> <code class="kc">false</code> <code class="o">|</code> <code class="mi">0</code> <code class="o">|</code> <code class="mi">0</code><code class="nx">n</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code> <code class="nx">T</code><code class="p">;</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">filter</code><code class="p">(</code><code class="nx">predicate</code><code class="o">:</code> <code class="nx">BooleanConstructor</code><code class="p">)</code><code class="o">:</code> <code class="nx">Truthy</code><code class="o">&lt;</code><code class="nx">NonNullable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;&gt;</code><code class="p">[];</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">filter</code><code class="p">(</code><code class="nx">predicate</code><code class="o">:</code> <code class="nx">BooleanConstructor</code><code class="p">)</code><code class="o">:</code> <code class="nx">Truthy</code><code class="o">&lt;</code><code class="nx">NonNullable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;&gt;</code><code class="p">[];</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// as const creates a readonly tuple</code>&#13;
<code class="kr">const</code> <code class="nx">array</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="sb">``</code><code class="p">,</code> <code class="o">-</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="nx">n</code><code class="p">,</code> <code class="kc">false</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="kc">null</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// const filtered: (1 | 2 | 3)[]</code>&#13;
<code class="kr">const</code> <code class="nx">filtered</code> <code class="o">=</code> <code class="nx">array</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nb">Boolean</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">nullOrOne</code><code class="o">:</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="mi">0</code> <code class="o">|</code> <code class="mi">1</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">];</code>&#13;
&#13;
<code class="c1">// const onlyOnes: 1[]</code>&#13;
<code class="kr">const</code> <code class="nx">onlyOnes</code> <code class="o">=</code> <code class="nx">nullOrOne</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nb">Boolean</code><code class="p">);</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The example includes <code>0n</code> which is 0 in the <code>BigInt</code> type. This type is available only from ECMAScript 2020 on.</p>&#13;
</div>&#13;
&#13;
<p>This gives us the right idea of which types to expect, but since <code>ReadonlyArray&lt;T&gt;</code> takes the tuple’s elements types and not the tuple type itself, we lose information on the order of types within the tuple.</p>&#13;
&#13;
<p>As with all extensions to existing TypeScript types, be aware that this might cause side effects. Scope them locally and use them carefully.<a data-startref="ix_09-08-asciidoc4" data-type="indexterm" id="id838"/><a data-startref="ix_09-08-asciidoc3" data-type="indexterm" id="id839"/><a data-startref="ix_09-08-asciidoc2" data-type="indexterm" id="id840"/><a data-startref="ix_09-08-asciidoc1" data-type="indexterm" id="id841"/><a data-startref="ix_09-08-asciidoc0" data-type="indexterm" id="id842"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="9.6 Extending Modules" data-type="sect1"><div class="sect1" id="ch09_modules">&#13;
<h1>9.6 Extending Modules</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id228">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="declaration merging" data-secondary="extending modules" data-type="indexterm" id="ix_09-05-asciidoc0"/><a data-primary="modules" data-secondary="extending" data-type="indexterm" id="ix_09-05-asciidoc1"/><a data-primary="standard library and external type definitions" data-secondary="extending modules" data-type="indexterm" id="ix_09-05-asciidoc2"/>You work with libraries that provide their own view of HTML elements, like Preact or React. But sometimes their type definitions don’t include the latest features. You want to patch them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id843">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use declaration merging on the module and interface level.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id145">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="JSX" data-type="indexterm" id="id844"/><em>JSX</em> is a syntax extension to JavaScript, introducing an XML-like way of describing and nesting components. Basically, everything that can be described as a tree of elements can be expressed in JSX. JSX was introduced by the creators of the popular React framework to make it possible to write and nest components in an HTML-like way within JavaScript, where it is actually transpiled to a series of function calls:</p>&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="na">alert</code><code class="p">(</code><code class="s1">'YES'</code><code class="p">)}&gt;</code><code class="nx">Click</code><code class="w"> </code><code class="nx">me</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
&#13;
<code class="c1">// Transpiles to:</code><code class="w"/>&#13;
&#13;
<code class="nx">React</code><code class="p">.</code><code class="na">createElement</code><code class="p">(</code><code class="s2">"button"</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="na">onClick</code><code class="o">:</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="na">alert</code><code class="p">(</code><code class="s1">'YES'</code><code class="p">)</code><code class="w"> </code><code class="p">},</code><code class="w"> </code><code class="s1">'Click me'</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>JSX has since been adopted by many frameworks, even if there is little or no connection to React. There’s a lot more on JSX in <a data-type="xref" href="ch10.html#ch10">Chapter 10</a>.</p>&#13;
&#13;
<p>React typings for TypeScript come with lots of interfaces for all possible HTML elements. But sometimes your browsers, your frameworks, or your code are a little bit ahead of what’s possible.</p>&#13;
&#13;
<p>Let’s say you want to use the latest image features in Chrome and load your images lazily. This is a progressive enhancement, so only browsers that understand what’s going on know how to interpret this. Other browsers are robust enough not to care:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">img</code> <code class="na">src</code><code class="o">=</code><code class="s">"/awesome.jpg"</code> <code class="na">loading</code><code class="o">=</code><code class="s">"lazy"</code> <code class="na">alt</code><code class="o">=</code><code class="s">"What an awesome image"</code> <code class="p">/&gt;</code></pre>&#13;
&#13;
<p>But your TypeScript JSX code? Errors:</p>&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="na">Image</code><code class="p">({</code><code class="w"> </code><code class="nx">src</code><code class="p">,</code><code class="w"> </code><code class="nx">alt</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// Property 'loading' does not exist.</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nt">&lt;</code><code class="nt">img</code> <code class="na">src</code><code class="o">=</code><code class="p">{</code><code class="nx">src</code><code class="p">}</code> <code class="na">alt</code><code class="o">=</code><code class="p">{</code><code class="nx">alt</code><code class="p">}</code> <code class="na">loading</code><code class="o">=</code><code class="s">"lazy"</code> <code class="p">/&gt;;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>To prevent this, we can extend the available interfaces with our own properties. This TypeScript feature is called <em>declaration merging</em>.</p>&#13;
&#13;
<p>Create an <em>@types</em> folder and put a <em>jsx.d.ts</em> file in it. Change your TypeScript config so your compiler options allow for extra types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"compilerOptions"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
    <code class="cm">/* Type declaration files to be included in compilation. */</code>&#13;
    <code class="s2">"types"</code><code class="o">:</code> <code class="p">[</code><code class="s2">"@types/**"</code><code class="p">],</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We re-create the exact module and interface structure:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The module is called <code>'react'</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The interface is <code>ImgHTMLAttributes&lt;T&gt; extends HTMLAttributes&lt;T&gt;</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We know that from the original typings. Here, we add the properties we want:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"react"</code> <code class="p">{</code>&#13;
  <code class="kr">interface</code> <code class="nx">ImgHTMLAttributes</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">extends</code> <code class="nx">HTMLAttributes</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">loading</code><code class="o">?:</code> <code class="s2">"lazy"</code> <code class="o">|</code> <code class="s2">"eager"</code> <code class="o">|</code> <code class="s2">"auto"</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And while we are at it, let’s make sure we don’t forget alt texts:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"react"</code> <code class="p">{</code>&#13;
  <code class="kr">interface</code> <code class="nx">ImgHTMLAttributes</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">extends</code> <code class="nx">HTMLAttributes</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">loading</code><code class="o">?:</code> <code class="s2">"lazy"</code> <code class="o">|</code> <code class="s2">"eager"</code> <code class="o">|</code> <code class="s2">"auto"</code><code class="p">;</code>&#13;
    <code class="nx">alt</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That’s much better! TypeScript will take the original definition and merge your declarations. Your autocomplete can give you all available options <em>and</em> will error when you forget an alt text.</p>&#13;
&#13;
<p><a data-primary="Preact" data-type="indexterm" id="id845"/>When working with <a href="https://preactjs.com">Preact</a>, things are a bit more complicated. The original HTML typings are very generous and not as specific as React’s typings. That’s why we have to be a bit more explicit when defining images:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">namespace</code> <code class="nx">JSX</code> <code class="p">{</code>&#13;
  <code class="kr">interface</code> <code class="nx">IntrinsicElements</code> <code class="p">{</code>&#13;
    <code class="nx">img</code><code class="o">:</code> <code class="nx">HTMLAttributes</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
      <code class="nx">alt</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
      <code class="nx">src</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
      <code class="nx">loading</code><code class="o">?:</code> <code class="s2">"lazy"</code> <code class="o">|</code> <code class="s2">"eager"</code> <code class="o">|</code> <code class="s2">"auto"</code><code class="p">;</code>&#13;
    <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This makes sure that both <code>alt</code> and <code>src</code> are available and adds a new attribute called <code>loading</code>. The technique is the same, though: declaration merging, which works on the level of namespaces, interfaces, and modules.<a data-startref="ix_09-05-asciidoc2" data-type="indexterm" id="id846"/><a data-startref="ix_09-05-asciidoc1" data-type="indexterm" id="id847"/><a data-startref="ix_09-05-asciidoc0" data-type="indexterm" id="id848"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="9.7 Augmenting Globals" data-type="sect1"><div class="sect1" id="ch09_augmenting_globals">&#13;
<h1>9.7 Augmenting Globals</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id146">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="custom type definitions, augmenting global namespace with" data-type="indexterm" id="ix_09-06-asciidoc0"/><a data-primary="global namespace, augmenting with custom type definitions" data-type="indexterm" id="ix_09-06-asciidoc1"/><a data-primary="namespaces" data-secondary="augmenting globals with custom type definitions" data-type="indexterm" id="ix_09-06-asciidoc2"/><a data-primary="Resize Observer" data-type="indexterm" id="ix_09-06-asciidoc3"/><a data-primary="standard library and external type definitions" data-secondary="augmenting globals" data-type="indexterm" id="ix_09-06-asciidoc4"/>You use a browser feature like <code>ResizeObserver</code> and see that it isn’t available in your current TypeScript configuration.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id849">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Augment the global namespace with custom type definitions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id147">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript stores types to all DOM APIs in <em>lib.dom.d.ts</em>. This file is autogenerated from Web IDL files. <em>Web IDL</em> stands for <em>Web Interface Definition Language</em> and is a format the W3C and WHATWG use to define interfaces to web APIs. It came out around 2012 and has been a standard since 2016.</p>&#13;
&#13;
<p>When you read standards at <a href="https://www.w3.org">W3C</a>—like on <a href="https://oreil.ly/XeSUG">Resize Observer</a>—you can see parts of a definition or the full definition somewhere within the specification. Like this one:</p>&#13;
&#13;
<pre data-type="programlisting">enum ResizeObserverBoxOptions {&#13;
  "border-box", "content-box", "device-pixel-content-box"&#13;
};&#13;
&#13;
dictionary ResizeObserverOptions {&#13;
  ResizeObserverBoxOptions box = "content-box";&#13;
};&#13;
&#13;
[Exposed=(Window)]&#13;
interface ResizeObserver {&#13;
  constructor(ResizeObserverCallback callback);&#13;
  void observe(Element target, optional ResizeObserverOptions options);&#13;
  void unobserve(Element target);&#13;
  void disconnect();&#13;
};&#13;
&#13;
callback ResizeObserverCallback = void (&#13;
  sequence&lt;ResizeObserverEntry&gt; entries,&#13;
  ResizeObserver observer&#13;
);&#13;
&#13;
[Exposed=Window]&#13;
interface ResizeObserverEntry {&#13;
  readonly attribute Element target;&#13;
  readonly attribute DOMRectReadOnly contentRect;&#13;
  readonly attribute FrozenArray&lt;ResizeObserverSize&gt; borderBoxSize;&#13;
  readonly attribute FrozenArray&lt;ResizeObserverSize&gt; contentBoxSize;&#13;
  readonly attribute FrozenArray&lt;ResizeObserverSize&gt; devicePixelContentBoxSize;&#13;
};&#13;
&#13;
interface ResizeObserverSize {&#13;
  readonly attribute unrestricted double inlineSize;&#13;
  readonly attribute unrestricted double blockSize;&#13;
};&#13;
&#13;
interface ResizeObservation {&#13;
  constructor(Element target);&#13;
  readonly attribute Element target;&#13;
  readonly attribute ResizeObserverBoxOptions observedBox;&#13;
  readonly attribute FrozenArray&lt;ResizeObserverSize&gt; lastReportedSizes;&#13;
};</pre>&#13;
&#13;
<p>Browsers use this as a guideline to implement respective APIs. TypeScript uses these IDL files to generate <em>lib.dom.d.ts</em>. The <a href="https://oreil.ly/WLcLB">TypeScript and JavaScript lib generator</a> project scrapes web standards and extracts IDL information. Then an <em>IDL to TypeScript</em> generator parses the IDL file and generates the correct typings.</p>&#13;
&#13;
<p>Pages to scrape are maintained manually. The moment a specification is far enough and supported by all major browsers, people add a new resource and see their change released with an upcoming TypeScript version. So it’s just a matter of time until we get <code>ResizeObserver</code> in <em>lib.dom.d.ts</em>.</p>&#13;
&#13;
<p>If we can’t wait, we can add the typings ourselves but only for the project we currently are working with.</p>&#13;
&#13;
<p>Let’s assume we generated the types for <code>ResizeObserver</code>. We would store the output in a file called <em>resize-observer.d.ts</em>. Here are the contents:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ResizeObserverBoxOptions</code> <code class="o">=</code>&#13;
  <code class="s2">"border-box"</code> <code class="o">|</code>&#13;
  <code class="s2">"content-box"</code> <code class="o">|</code>&#13;
  <code class="s2">"device-pixel-content-box"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ResizeObserverOptions</code> <code class="p">{</code>&#13;
  <code class="nx">box</code><code class="o">?:</code> <code class="nx">ResizeObserverBoxOptions</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ResizeObservation</code> <code class="p">{</code>&#13;
  <code class="kr">readonly</code> <code class="nx">lastReportedSizes</code><code class="o">:</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">ResizeObserverSize</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="kr">readonly</code> <code class="nx">observedBox</code><code class="o">:</code> <code class="nx">ResizeObserverBoxOptions</code><code class="p">;</code>&#13;
  <code class="kr">readonly</code> <code class="nx">target</code><code class="o">:</code> <code class="nx">Element</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">declare</code> <code class="kd">var</code> <code class="nx">ResizeObservation</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">prototype</code><code class="o">:</code> <code class="nx">ResizeObservation</code><code class="p">;</code>&#13;
  <code class="k">new</code><code class="p">(</code><code class="nx">target</code><code class="o">:</code> <code class="nx">Element</code><code class="p">)</code><code class="o">:</code> <code class="nx">ResizeObservation</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ResizeObserver</code> <code class="p">{</code>&#13;
  <code class="nx">disconnect</code><code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="nx">observe</code><code class="p">(</code><code class="nx">target</code><code class="o">:</code> <code class="nx">Element</code><code class="p">,</code> <code class="nx">options</code><code class="o">?:</code> <code class="nx">ResizeObserverOptions</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="nx">unobserve</code><code class="p">(</code><code class="nx">target</code><code class="o">:</code> <code class="nx">Element</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">declare</code> <code class="kd">var</code> <code class="nx">ResizeObserver</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">prototype</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">;</code>&#13;
  <code class="k">new</code><code class="p">(</code><code class="nx">callback</code><code class="o">:</code> <code class="nx">ResizeObserverCallback</code><code class="p">)</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ResizeObserverEntry</code> <code class="p">{</code>&#13;
  <code class="kr">readonly</code> <code class="nx">borderBoxSize</code><code class="o">:</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">ResizeObserverSize</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="kr">readonly</code> <code class="nx">contentBoxSize</code><code class="o">:</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">ResizeObserverSize</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="kr">readonly</code> <code class="nx">contentRect</code><code class="o">:</code> <code class="nx">DOMRectReadOnly</code><code class="p">;</code>&#13;
  <code class="kr">readonly</code> <code class="nx">devicePixelContentBoxSize</code><code class="o">:</code> <code class="nx">ReadonlyArray</code><code class="o">&lt;</code><code class="nx">ResizeObserverSize</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="kr">readonly</code> <code class="nx">target</code><code class="o">:</code> <code class="nx">Element</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">declare</code> <code class="kd">var</code> <code class="nx">ResizeObserverEntry</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">prototype</code><code class="o">:</code> <code class="nx">ResizeObserverEntry</code><code class="p">;</code>&#13;
  <code class="k">new</code><code class="p">()</code><code class="o">:</code> <code class="nx">ResizeObserverEntry</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ResizeObserverSize</code> <code class="p">{</code>&#13;
  <code class="kr">readonly</code> <code class="nx">blockSize</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="kr">readonly</code> <code class="nx">inlineSize</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">declare</code> <code class="kd">var</code> <code class="nx">ResizeObserverSize</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">prototype</code><code class="o">:</code> <code class="nx">ResizeObserverSize</code><code class="p">;</code>&#13;
  <code class="k">new</code><code class="p">()</code><code class="o">:</code> <code class="nx">ResizeObserverSize</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">ResizeObserverCallback</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">entries</code><code class="o">:</code> <code class="nx">ResizeObserverEntry</code><code class="p">[],</code> <code class="nx">observer</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We declare a ton of interfaces and some variables that implement our interfaces, like <code>declare var ResizeObserver</code>, which is the object that defines the prototype and constructor function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kd">var</code> <code class="nx">ResizeObserver</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">prototype</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">;</code>&#13;
  <code class="k">new</code><code class="p">(</code><code class="nx">callback</code><code class="o">:</code> <code class="nx">ResizeObserverCallback</code><code class="p">)</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This already helps a lot. We can use the (arguably) long type declarations and put them directly in the file where we need them. <code>ResizeObserver</code> is found! We want to have it available everywhere, though.</p>&#13;
&#13;
<p>Thanks to TypeScript’s declaration-merging feature, we can extend <em>namespaces</em> and <em>interfaces</em> as needed. This time, we’re extending the <em>global namespace</em>.</p>&#13;
&#13;
<p>The global namespace contains all objects and interfaces that are, well, globally available. Like the <code>window</code> object (and <code>Window</code> interface), as well as everything else that should be part of our JavaScript execution context. We augment the global namespace and add the <code>ResizeObserver</code> object to it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">global</code> <code class="p">{</code> <code class="c1">// opening up the namespace</code>&#13;
  <code class="kd">var</code> <code class="nx">ResizeObserver</code><code class="o">:</code> <code class="p">{</code> <code class="c1">// merging ResizeObserver with it</code>&#13;
    <code class="nx">prototype</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">;</code>&#13;
    <code class="k">new</code><code class="p">(</code><code class="nx">callback</code><code class="o">:</code> <code class="nx">ResizeObserverCallback</code><code class="p">)</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s put <em>resize-observer.d.ts</em> in a folder called <em>@types</em>. Don’t forget to add the folder to the sources that TypeScript will parse as well as the list of type declaration folders in <em>tsconfig.json</em>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"compilerOptions"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="c1">//...</code>&#13;
    <code class="s2">"typeRoots"</code><code class="o">:</code> <code class="p">[</code><code class="s2">"@types"</code><code class="p">,</code> <code class="s2">"./node_modules/@types"</code><code class="p">],</code>&#13;
    <code class="c1">//...</code>&#13;
  <code class="p">},</code>&#13;
  <code class="s2">"include"</code><code class="o">:</code> <code class="p">[</code><code class="s2">"src"</code><code class="p">,</code> <code class="s2">"@types"</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Since there’s a significant possibility that <code>ResizeObserver</code> is not yet available in your target browser, make sure that you make the <code>ResizeObserver</code> object <code>undefined</code>. This urges you to check if the object is available:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">global</code> <code class="p">{</code>&#13;
  <code class="kd">var</code> <code class="nx">ResizeObserver</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">prototype</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">;</code>&#13;
    <code class="k">new</code><code class="p">(</code><code class="nx">callback</code><code class="o">:</code> <code class="nx">ResizeObserverCallback</code><code class="p">)</code><code class="o">:</code> <code class="nx">ResizeObserver</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="o">|</code> <code class="kc">undefined</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In your application:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">ResizeObserver</code> <code class="o">!==</code> <code class="s1">'undefined'</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ResizeObserver</code><code class="p">((</code><code class="nx">entries</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{});</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This makes working with <code>ResizeObserver</code> as safe as possible!</p>&#13;
&#13;
<p class="pagebreak-before">It might be that TypeScript doesn’t pick up your ambient declaration files and the global augmentation. If this happens, make sure that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You parse the <em>@types</em> folder via the <code>include</code> property in <em>tsconfig.json</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Your ambient type declaration files are recognized as such by adding them to <code>types</code> or <code>typeRoots</code> in the <em>tsconfig.json</em> compiler options.</p>&#13;
</li>&#13;
<li>&#13;
<p>You add <code>export {}</code> at the end of your ambient declaration file so TypeScript recognizes this file as a module.<a data-startref="ix_09-06-asciidoc4" data-type="indexterm" id="id850"/><a data-startref="ix_09-06-asciidoc3" data-type="indexterm" id="id851"/><a data-startref="ix_09-06-asciidoc2" data-type="indexterm" id="id852"/><a data-startref="ix_09-06-asciidoc1" data-type="indexterm" id="id853"/><a data-startref="ix_09-06-asciidoc0" data-type="indexterm" id="id854"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="9.8 Adding Non-JS Modules to the Module Graph" data-type="sect1"><div class="sect1" id="id357">&#13;
<h1>9.8 Adding Non-JS Modules to the Module Graph</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id148">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="module graph, adding non-JS modules to" data-type="indexterm" id="ix_09-07-asciidoc0"/><a data-primary="modules" data-secondary="adding non-JS modules to the module graph" data-type="indexterm" id="ix_09-07-asciidoc1"/><a data-primary="standard library and external type definitions" data-secondary="adding non-JS modules to the module graph" data-type="indexterm" id="ix_09-07-asciidoc2"/><a data-primary="Webpack" data-type="indexterm" id="ix_09-07-asciidoc3"/>You use a bundler like Webpack to load files like <em>.css</em> or images from JavaScript, but TypeScript does not recognize those files.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id855">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Globally declare modules based on filename extensions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id149">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>There is a movement in web development to make JavaScript the default entry point of everything and let it handle all relevant assets via <code>import</code> statements. What you need for this is a build tool, a bundler, that analyzes your code and creates the right artifacts. A popular tool for this is <a href="https://webpack.js.org">Webpack</a>, a JavaScript bundler that allows you to bundle <em>everything</em>—CSS, Markdown, SVGs, JPEGs, you name it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// like this</code>&#13;
<code class="kr">import</code> <code class="s2">"./Button.css"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// or this</code>&#13;
<code class="kr">import</code> <code class="nx">styles</code> <code class="nx">from</code> <code class="s2">"./Button.css"</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-primary="loaders (Webpack)" data-type="indexterm" id="id856"/>Webpack uses a concept called <em>loaders</em>, which looks at file endings and activates certain bundling concepts. Importing <em>.css</em> files in JavaScript is not native. It’s part of Webpack (or whatever bundler you are using). However, we can teach TypeScript to understand files like this.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There is a proposal in the ECMAScript standards committee to allow imports of files other than JavaScript and assert certain built-in formats for this. This will have an effect on TypeScript eventually. You can read all about it <a href="https://oreil.ly/stAm5">here</a>.</p>&#13;
</div>&#13;
&#13;
<p><a data-primary="ambient module declarations" data-type="indexterm" id="id857"/>TypeScript supports <em>ambient module declarations</em>, even for a module that is not “physically” there but in the environment or reachable via tooling. One example is Node’s main built-in modules, like <code>url</code>, <code>http</code> or <code>path</code>, as described in TypeScript’s documentation:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"path"</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">normalize</code><code class="p">(</code><code class="nx">p</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">join</code><code class="p">(...</code><code class="nx">paths</code><code class="o">:</code> <code class="kr">any</code><code class="p">[])</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="kr">export</code> <code class="kd">var</code> <code class="nx">sep</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This is great for modules where we know the exact name. We can also use the same technique for wildcard patterns. Let’s declare a generic ambient module for all our <em>.css</em> files:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'*.css'</code> <code class="p">{</code>&#13;
  <code class="c1">// to be done.</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The pattern is ready. This listens to all <em>.css</em> files we want to import. What we expect is a list of class names that we can add to our components. Since we don’t know which classes are defined in the <em>.css</em> files, let’s go with an object that accepts every string key and returns a string:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'*.css'</code> <code class="p">{</code>&#13;
  <code class="kr">interface</code> <code class="nx">IClassNames</code> <code class="p">{</code>&#13;
    <code class="p">[</code><code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code>&#13;
  <code class="p">}</code>&#13;
  <code class="kr">const</code> <code class="nx">classNames</code><code class="o">:</code> <code class="nx">IClassNames</code><code class="p">;</code>&#13;
  <code class="kr">export</code> <code class="k">default</code> <code class="nx">classNames</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That’s all we need to make our files compile again. The only downside is that we can’t use the exact class names to get autocompletion and similar benefits. A way to solve this is to generate type files automatically. There are packages on <a href="https://oreil.ly/sDBv0">NPM</a> that deal with that problem. Feel free to choose one of your liking.</p>&#13;
&#13;
<p><a data-primary="Markdown" data-type="indexterm" id="id858"/><a data-primary="MDX" data-type="indexterm" id="id859"/>It’s a bit easier if we want to import something like MDX into our modules. MDX lets us write Markdown, which parses to regular React (or JSX) components (more on React in <a data-type="xref" href="ch10.html#ch10">Chapter 10</a>).</p>&#13;
&#13;
<p><a data-primary="JSX" data-type="indexterm" id="id860"/>We expect a functional component (that we can pass props to) that returns a JSX &#13;
<span class="keep-together">element:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'*.mdx'</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">MDXComponent</code><code class="o">:</code> <code class="p">(</code><code class="nx">props</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">JSX</code><code class="p">.</code><code class="nx">Element</code><code class="p">;</code>&#13;
  <code class="kr">export</code> <code class="k">default</code> <code class="nx">MDXComponent</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">And voilà! We can load <em>.mdx</em> files in JavaScript and use them as components:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="nx">About</code> <code class="nx">from</code> <code class="s1">'../articles/about.mdx'</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">About</code><code class="o">/&gt;</code>&#13;
  <code class="o">&lt;</code><code class="o">/&gt;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you don’t know what to expect, make your life easy. All you need to do is declare the module. Don’t provide any types. TypeScript will allow loading but won’t give you any type safety:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'*.svg'</code><code class="p">;</code></pre>&#13;
&#13;
<p>To make ambient modules available to your app, it is recommended to create an <em>@types</em> folder somewhere in your project (probably root level). There you can put any amount of <em>.d.ts</em> files with your module definitions. Add a referral to your <em>tsconfig.json</em>, and TypeScript knows what to do:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="p">...</code>&#13;
  <code class="s2">"compilerOptions"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="p">...</code>&#13;
    <code class="s2">"typeRoots"</code><code class="o">:</code> <code class="p">[</code>&#13;
      <code class="s2">"./node_modules/@types"</code><code class="p">,</code>&#13;
      <code class="s2">"./@types"</code>&#13;
    <code class="p">],</code>&#13;
    <code class="p">...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>One of TypeScript’s main features is to be adaptable to all JavaScript flavors. Some things are built-in, and others need some extra patching from you.<a data-startref="ix_09-07-asciidoc3" data-type="indexterm" id="id861"/><a data-startref="ix_09-07-asciidoc2" data-type="indexterm" id="id862"/><a data-startref="ix_09-07-asciidoc1" data-type="indexterm" id="id863"/><a data-startref="ix_09-07-asciidoc0" data-type="indexterm" id="id864"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id816"><sup><a href="ch09.html#id816-marker">1</a></sup> Back when the API defintiion was created, <code>unknown</code> didn’t exist. Also, TypeScript has a strong  <span class="keep-together">focus on developer</span> productivity, and with <code>res.json()</code> being a widely used method, this would’ve  <span class="keep-together">broken countless applications.</span></p><p data-type="footnote" id="id822"><sup><a href="ch09.html#id822-marker">2</a></sup> Credit to Dan Vanderkam’s <a href="https://effectivetypescript.com"><em>Effective TypeScript</em> blog</a> for inspiration on  <span class="keep-together">this subject.</span></p></div></div></section></body></html>