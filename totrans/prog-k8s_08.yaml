- en: Chapter 8\. Custom API Servers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章 自定义 API 服务器
- en: As an alternative to CustomResourceDefinitions, you can use a custom API server.
    Custom API servers can serve API groups with resources the same way the main Kubernetes
    API server does. In contrast to CRDs, there are hardly any limits to what you
    can do with a custom API server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 CustomResourceDefinitions 的替代方案，可以使用自定义 API 服务器。自定义 API 服务器可以像主 Kubernetes
    API 服务器一样为 API 组提供资源服务。与 CRD 不同，自定义 API 服务器几乎没有限制，可以做任何事情。
- en: This chapter begins by listing a number of reasons why CRDs might not be the
    right solution for your use case. It describes the aggregation pattern that makes
    it possible to extend the Kubernetes API surface with a custom API server. Finally,
    you’ll learn to actually implement a custom API server using Golang.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章首先列出了为什么 CRD 可能不适合您的用例的一些原因。它描述了聚合模式，该模式使得通过自定义 API 服务器扩展 Kubernetes API 表面成为可能。最后，您将学习如何使用
    Golang 实际实现自定义 API 服务器。
- en: Use Cases for Custom API Servers
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 API 服务器的用例
- en: 'A custom API server can be used in place of CRDs. It can do everything that
    CRDs can do and offers nearly infinite flexibility. Of course, this comes at a
    cost: complexity of both development and operation.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用自定义 API 服务器替代 CRD。它可以做任何 CRD 能做的事情，并提供几乎无限的灵活性。当然，这也带来了成本：开发和运维的复杂性。
- en: 'Let’s look at some limits of CRDs as of the time of this writing (when Kubernetes
    1.14 was the stable release). CRDs:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下在本文撰写时（Kubernetes 1.14 为稳定版本），CRD 的一些限制：
- en: Use `etcd` as their storage medium (or whatever the Kubernetes API server uses).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `etcd` 作为它们的存储介质（或者 Kubernetes API 服务器使用的任何东西）。
- en: Do not support protobuf, only JSON.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持 protobuf，只支持 JSON。
- en: 'Support only two kinds of subresources: */status* and */scale* (see [“Subresources”](ch04.html#crd-subresources)).'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅支持两种子资源：*/status* 和 */scale*（参见[“子资源”](ch04.html#crd-subresources)）。
- en: Do not support graceful deletion.^([1](ch08.html#idm46336853170760)) Finalizers
    can simulate this but do not allow a custom graceful deletion time.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持优雅的删除。^([1](ch08.html#idm46336853170760)) 尽管 Finalizers 可以模拟这一过程，但不允许自定义优雅删除时间。
- en: Add significantly to the Kubernetes API server’s CPU load, because all algorithms
    are implemented in a generic way (for example, validation).
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会显著增加 Kubernetes API 服务器的 CPU 负载，因为所有算法都是通用实现的（例如验证）。
- en: Implement only standard CRUD semantics for the API endpoints.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅为 API 端点实现标准的 CRUD 语义。
- en: Do not support cohabitation of resources (i.e., resources in different API groups
    or resources of different names that share storage).^([2](ch08.html#idm46336853165528))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持资源共存（即不同 API 组中的资源或不同名称的资源共享存储）。^([2](ch08.html#idm46336853165528))
- en: 'A custom API server, in contrast, does not have these restrictions. A custom
    API server:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，自定义 API 服务器没有这些限制：
- en: 'Can use any storage medium. There are custom API servers, such as:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用任何存储介质。例如，有以下自定义 API 服务器：
- en: The [metrics API server](http://bit.ly/2FvgfAV), which stores data in memory
    for maximum performance
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[指标 API 服务器](http://bit.ly/2FvgfAV)，它将数据存储在内存中以实现最大的性能。'
- en: API servers mirroring a Docker registry in [OpenShift](http://redhat.com/openshift)
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 服务器可以镜像 [OpenShift](http://redhat.com/openshift) 中 Docker 注册表的自定义 API 对象。
- en: API servers writing to a time series database
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 服务器将数据写入时间序列数据库。
- en: API servers mirroring cloud APIs
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 服务器可以镜像云 API。
- en: API servers mirroring other API objects, like projects in [OpenShift](http://redhat.com/openshift)
    that mirror Kubernetes namespaces
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 服务器可以镜像其他 API 对象，例如 [OpenShift](http://redhat.com/openshift) 中镜像 Kubernetes
    命名空间的项目。
- en: Can provide protobuf support like all native Kubernetes resources do. For this
    you must create a *.proto* file by using [go-to-protobuf](http://bit.ly/31OLSie)
    and then using the protobuf compiler `protoc` to generate serializers, which are
    then compiled into the binary.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以像所有本机 Kubernetes 资源一样提供 protobuf 支持。为此，您必须使用 [go-to-protobuf](http://bit.ly/31OLSie)
    创建一个 *.proto* 文件，然后使用 protobuf 编译器 `protoc` 生成序列化器，最后将其编译成二进制文件。
- en: Can provide any custom subresource; for example, the Kubernetes API server provides
    */exec*, */logs*, */port-forward*, and more, most of which use very custom protocols
    like WebSockets or HTTP/2 streaming.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以提供任何自定义子资源；例如，Kubernetes API 服务器提供 */exec*、*/logs*、*/port-forward* 等，大多数使用非常自定义的协议，如
    WebSockets 或 HTTP/2 流式传输。
- en: Can implement graceful deletion as Kubernetes does for pods. `kubectl` waits
    for the deletion, and the user can even provide a custom graceful termination
    period.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以实现优雅的删除，就像 Kubernetes 对于 Pod 所做的那样。`kubectl` 等待删除操作，用户甚至可以提供自定义的优雅终止期。
- en: Can implement all operations like validation, admission, and conversion in the
    most efficient way using Golang, without a roundtrip through webhooks, which add
    further latency. This can matter for high performance use cases or if there is
    a large number of objects. Think about pod objects in a huge cluster with thousands
    of nodes, and two magnitudes more pods.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用Golang以最高效的方式实现所有操作，如验证、准入和转换，而无需通过webhook回程，这可以减少进一步的延迟。这对于高性能用例或对象数量众多的情况至关重要。想象一下在拥有数千个节点和两个数量级更多的Pod的大集群中，Pod对象的情况。
- en: 'Can implement custom semantics, like the atomic reservation of a service IP
    in the core v1 `Service` kind. At the moment the service is created, a unique
    service IP is assigned and directly returned. To a limited degree, special semantics
    like this can of course be implemented with admission webhooks (see [“Admission
    Webhooks”](ch09.html#admission-webhooks)), though those webhooks can never reliably
    know whether the passed object was actually created or updated: they are called
    optimistically, but a later step in the request pipeline might cancel the request.
    In other words: side effects in webhooks are tricky because there is no undo trigger
    if a request fails.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以实现自定义语义，例如在核心v1 `Service`类型中对服务IP进行原子预留。在创建服务时，会分配一个唯一的服务IP并直接返回。在请求管道中，虽然可以使用准入webhook实现特殊语义，但这些webhook无法可靠地知道传递的对象实际上是创建还是更新的：它们乐观地调用，但如果请求失败，后续步骤可能会取消请求。换句话说：webhook中的副作用很棘手，因为如果请求失败，则没有撤销触发器。
- en: Can serve resources that have a common storage mechanism (i.e., a common `etcd`
    key path prefix) but live in different API groups or are named differently. For
    example, Kubernetes stores deployments and other resources in the API group `extensions/v1`
    and then moves them to more specific API groups like `apps/v1`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以为具有共同存储机制（即公共`etcd`键路径前缀）但存在于不同API组或命名不同的资源提供服务。例如，Kubernetes将部署和其他资源存储在API组`extensions/v1`中，然后将它们移动到更具体的API组，如`apps/v1`。
- en: In other words, custom API servers are a solution for situations where CRDs
    are still limited. In transitional scenarios where it is important to not break
    resource compatibility when moving to new semantics, custom API servers are often
    much more flexible.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，自定义API服务器是在CRD仍然有限的情况下解决方案的情况。在过渡场景中，当转移到新的语义时重要的是不破坏资源兼容性时，自定义API服务器通常更加灵活。
- en: 'Example: A Pizza Restaurant'
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例：披萨餐厅
- en: 'To learn how custom API servers are implemented, in this section we will look
    at an example project: a custom API server implementing a pizza restaurant API.
    Let’s take a look at the requirements.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习如何实现自定义API服务器，在本节中，我们将看一个示例项目：一个实现披萨餐厅API的自定义API服务器。让我们看看需求。
- en: 'We want to create two kinds in the `restaurant.programming-kubernetes.info`
    API group:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在`restaurant.programming-kubernetes.info` API组中创建两种类型：
- en: '`Topping`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`Topping`'
- en: Pizza toppings (e.g., salami, mozzarella, or tomato)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 披萨配料（例如：萨拉米、马苏里拉奶酪或番茄）
- en: '`Pizza`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pizza`'
- en: The type of pizza offered in the restaurant
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 餐厅提供的披萨类型
- en: 'The toppings are cluster-wide resources and hold only a floating-point value
    for the cost of one unit of the topping. An instance is as simple as:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 配料是集群范围的资源，仅包含一个浮点值，用于配料单位的成本。一个实例如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Each pizza can have an arbitrary number of toppings; for example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每个披萨可以有任意数量的配料；例如：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The list of toppings is ordered (like any list in YAML or JSON), but the order
    does not really matter for the semantics of the type. The customer will get the
    same pizza in any case. We want to allow duplicates in the list in order to allow,
    say, a pizza with extra cheese.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 配料列表是有序的（就像在YAML或JSON中的任何列表一样），但顺序对类型的语义并不真正重要。客户在任何情况下都会得到相同的披萨。我们希望允许列表中的重复项，以便允许例如额外加奶酪的披萨。
- en: All this can be implemented easily with CRDs. Now let’s add some requirements
    that go beyond the basic CRD capabilities:^([3](ch08.html#idm46336853099640))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过CRD轻松实现。现在让我们添加一些超出基本CRD功能的需求：^([3](ch08.html#idm46336853099640))
- en: We want to allow only toppings in a pizza specification that have a corresponding
    `Topping` object.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望在披萨规格中仅允许有相应的`Topping`对象的配料。
- en: We also want to assume that we first introduced this API as a `v1alpha1` version
    but eventually learned that we want another representation of the toppings in
    the `v1beta1` version of the same API.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还希望假设我们首先将此API引入为`v1alpha1`版本，但最终发现我们希望在同一API的`v1beta1`版本中有另一种配料表示。
- en: In other words, we want to have two versions and convert seamlessly between
    them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望拥有两个版本，并在它们之间实现无缝转换。
- en: 'The full implementation of this API as a custom API server can be found at
    [the book’s GitHub repository](http://bit.ly/2x9C3gR). In the rest of this chapter,
    we will go through all the major parts of that project and learn how it works.
    In the process, you’ll see a lot of the concepts presented in the previous chapter
    in a different light: namely, the Golang implementation that is also behind the
    Kubernetes API server. A number of design decisions highlighted in CRDs also will
    become clearer.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该API的完整实现作为自定义API服务器可以在[本书的GitHub存储库](http://bit.ly/2x9C3gR)中找到。在本章的其余部分，我们将深入探讨该项目的所有主要部分，并了解其工作原理。在此过程中，您将看到前一章节中呈现的许多概念以不同的方式：即，也是Kubernetes
    API服务器背后的Golang实现。还会更清晰地看到一些在CRDs中突出的设计决策。
- en: Hence, we highly recommend you read through this chapter even if you don’t plan
    to go the route of a custom API server. Maybe the concepts presented here will
    be made available for CRDs as well in the future, in which case having knowledge
    of custom API servers will be useful to you.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们强烈建议您阅读本章，即使您不打算使用自定义API服务器。也许未来这里呈现的概念也会适用于CRDs，那么了解自定义API服务器的知识对您也会有所帮助。
- en: 'The Architecture: Aggregation'
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构：聚合
- en: Before going into the technical implementation details, we want to take a higher-level
    view of the custom API server architecture in the context of a Kubernetes cluster.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入技术实现细节之前，我们希望在Kubernetes集群的背景下，从更高层次来看自定义API服务器架构。
- en: Custom API servers are processes serving API groups, usually built using the
    generic API server library [*k8s.io/apiserver*](http://bit.ly/2X3joNX). These
    processes can run inside or outside of the cluster. In the former case, they run
    inside pods, with a service in front.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义API服务器是服务API组的进程，通常使用通用API服务器库[*k8s.io/apiserver*](http://bit.ly/2X3joNX)构建。这些进程可以在集群内部或外部运行。在前一种情况下，它们在Pod内运行，并带有前端服务。
- en: The main Kubernetes API server, called `kube-apiserver`, is always the first
    point of contact for `kubectl` and other API clients. API groups served by a custom
    API server are proxied by the `kube-apiserver` process to the custom API server
    process. In other words, the `kube-apiserver` process knows about all of the custom
    API servers and the API groups they serve, in order to be able to proxy the right
    requests to them.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的Kubernetes API服务器称为`kube-apiserver`，始终是`kubectl`和其他API客户端的第一个接触点。由自定义API服务器提供的API组由`kube-apiserver`进程代理到自定义API服务器进程。换句话说，`kube-apiserver`进程了解所有自定义API服务器及其服务的API组，以便能够将正确的请求代理到它们。
- en: The component doing this proxying is inside the `kube-apiserver` process and
    is called [`kube-aggregator`](http://bit.ly/2X10C9W). The process of proxying
    API requests to the custom API server is called *API aggregation*.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代理的组件位于`kube-apiserver`进程内部，称为[`kube-aggregator`](http://bit.ly/2X10C9W)。代理API请求到自定义API服务器的过程称为*API聚合*。
- en: 'Let’s look a bit more into the path of requests targeted at a custom API server,
    but coming in at the Kubernetes API server TCP socket (see [Figure 8-1](#aggregation-kube-apiserver)):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解针对自定义API服务器的请求路径，但是进入Kubernetes API服务器的TCP套接字（参见[图 8-1](#aggregation-kube-apiserver)）：
- en: Requests are received by the Kubernetes API server.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求由Kubernetes API服务器接收。
- en: They pass the handler chain consisting of authentication, audit logging, impersonation,
    max-in-flight throttling, authorization, and more (the figure is just a sketch
    and is not complete).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们通过处理程序链传递，包括身份验证、审计日志记录、模拟、最大并发限制、授权等等（图仅为草图，不完整）。
- en: As the Kubernetes API server knows the aggregated APIs, it can intercept requests
    to the HTTP path */apis/`aggregated-API-group-name`*.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Kubernetes API服务器知道聚合的API，它可以拦截指向HTTP路径`/apis/`聚合API组名称`*`的请求。
- en: The Kubernetes API server forwards the request to the custom API server.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes API服务器将请求转发到自定义API服务器。
- en: '![Kubernetes main API server `kube-apiserver` with an integrated `kube-aggregator`](assets/prku_0801.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes主API服务器`kube-apiserver`与集成的`kube-aggregator`](assets/prku_0801.png)'
- en: Figure 8-1\. Kubernetes main API server kube-apiserver with an integrated kube-aggregator
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. Kubernetes主API服务器kube-apiserver与集成的kube-aggregator
- en: The `kube-aggregator` proxies requests under the HTTP path for an API group
    version (i.e., everything under */apis/`group-name`/`version`*). It does not have
    to know the actual served resources in the API group version.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`kube-aggregator`代理API组版本的HTTP路径下的请求（即 */apis/`group-name`/`version`*）。它不需要知道API组版本中实际提供的资源。'
- en: In contrast, the `kube-aggregator` serves the discovery endpoints */apis* and
    */apis/`group-name`* of all aggregated custom API servers itself (it uses the
    defined order explained in the following section) and returns the results without
    talking to the aggregated custom API servers. Instead it uses the information
    from the `APIService` resource. Let’s look at this process in detail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`kube-aggregator`本身为所有聚合的自定义API服务器服务发现端点 */apis* 和 */apis/`group-name`*（它使用下文解释的定义顺序），并在不与聚合的自定义API服务器通信的情况下返回结果。而是使用来自`APIService`资源的信息。让我们详细了解此过程。
- en: API Services
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API服务
- en: 'For the Kubernetes API server to know about the API groups a custom API server
    serves, one `APIService` object must be created in the `apiregistration.k8s.io/v1`
    API group. These objects list only the API groups and versions, not resources
    or any further details:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API服务器要了解自定义API服务器提供的API组，必须在`apiregistration.k8s.io/v1` API组中创建一个`APIService`对象。这些对象仅列出API组和版本，不包括资源或任何进一步的细节：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The name is arbitrary, but for clarity we suggest you use a name that identifies
    the API group name and version—e.g., *`group-name-version`*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 名称是任意的，但为了清晰起见，建议您使用标识API组名称和版本的名称，例如*`group-name-version`*。
- en: The service can be a normal [`ClusterIP` service](http://bit.ly/2X0zEEu) in
    the cluster, or it can be an `ExternalName` service with a given DNS name for
    out-of-cluster custom API servers. In both cases, the port must be 443\. No other
    service port is supported (at the time of this writing). Service target port mapping
    allows any chosen, preferably nonrestricted, higher port to be used for the custom
    API server pods, so this is not a major restriction.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以是集群中的普通[`ClusterIP`服务](http://bit.ly/2X0zEEu)，或者可以是带有给定DNS名称的`ExternalName`服务，用于集群外的自定义API服务器。在这两种情况下，端口必须是443。在撰写本文时不支持其他服务端口。服务目标端口映射允许为自定义API服务器pod选择任意选择的、最好是非限制性的更高端口，因此这不是一个主要限制。
- en: The certificate authority (CA) bundle is used for the Kubernetes API server
    to trust the contacted service. Note that API requests can contain confidential
    data. To avoid man-in-the-middle attacks, it is highly recommended that you set
    the `caBundle` field and not use the `insecureSkipTLSVerify` alternative. This
    is especially important for any production cluster, including a mechanism for
    certificate rotation.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 证书颁发机构（CA）捆绑包用于Kubernetes API服务器信任所联系的服务。请注意，API请求可能包含机密数据。为避免中间人攻击，强烈建议设置`caBundle`字段，而不使用`insecureSkipTLSVerify`替代方案。对于任何生产集群，包括证书轮换机制，这尤为重要。
- en: 'Finally, there are two priorities in the `APIService` object. These have some
    tricky semantics, described in the Golang code documentation for the `APIService`
    type:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`APIService`对象中有两个优先级。这些具有一些棘手的语义，详见`APIService`类型的Golang代码文档：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In other words, the `GroupPriorityMinimum` value determines where the group
    is prioritized. If multiple `APIService` objects for different versions differ,
    the highest value rules.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`GroupPriorityMinimum`值决定了组的优先级。如果不同版本的多个`APIService`对象不同，将选择最高值。
- en: The second priority just orders the versions among each other to define the
    preferred version to be used by dynamic clients.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个优先级仅用于定义动态客户端首选使用的首选版本之间的顺序。
- en: 'Here is a list of the `GroupPriorityMinimum` values for the native Kubernetes
    API groups:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是原生Kubernetes API组的`GroupPriorityMinimum`值列表：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So using `2000` for PaaS-like APIs means that they are placed at the end of
    this list.^([4](ch08.html#idm46336852602264))
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于类似PaaS的API，使用`2000`意味着它们被放置在此列表的末尾。^([4](ch08.html#idm46336852602264))
- en: The order of the API groups plays a role during the REST mapping process in
    `kubectl` (see [“REST Mapping”](ch03.html#RESTMapping)). This means it has actual
    influence on the user experience. If there are conflicting resource names or short
    names, the one with the highest `GroupPriorityMinimum` value wins.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: API组的顺序在`kubectl`中的REST映射过程中起到作用（参见[“REST映射”](ch03.html#RESTMapping)）。这意味着它实际上对用户体验产生影响。如果存在冲突的资源名称或简称，则具有最高`GroupPriorityMinimum`值的组将获胜。
- en: Also, in the special case of replacing of an API group version using a custom
    API server, this priority ordering might be of use. For example, you could replace
    a native Kubernetes API group with a modified one (for whatever reason) by placing
    the custom API service at a position with a lower `GroupPriorityMinimum` value
    than the one in the upper table.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在使用自定义 API 服务器替换 API 组版本的特殊情况下，此优先级排序可能有用。例如，您可以通过将自定义 API 服务放置在比上表中的值较低的位置来替换原生
    Kubernetes API 组为修改后的 API 组（出于任何原因）。
- en: Note again that the Kubernetes API server does not need to know the list of
    resources for either of the discovery endpoints */apis*, and */apis/`group-name`*,
    or for proxying. The list of resources is returned only via the third discovery
    endpoint, */apis/`group-name`/`version`*. But as we have seen in the previous
    section, this endpoint is served by the aggregated custom API server, not by `kube-aggregator`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，Kubernetes API 服务器不需要知道任何发现端点 */apis* 和 */apis/`group-name`* 的资源列表，也不需要代理。资源列表仅通过第三个发现端点
    */apis/`group-name`/`version`* 返回。但正如我们在前一节中看到的，此端点由聚合的自定义 API 服务器提供，而不是由`kube-aggregator`提供。
- en: Inner Structure of a Custom API Server
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 API 服务器的内部结构
- en: 'A custom API server resembles most of the parts that make up the Kubernetes
    API server, though of course with different API group implementations, and without
    an embedded `kube-aggregator` or an embedded `apiextension-apiserver` (which serves
    CRDs). This leads to nearly the same architectural picture (shown in [Figure 8-2](#aggregation-aggregated-apiserver))
    as the one in [Figure 8-1](#aggregation-kube-apiserver):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 API 服务器与组成 Kubernetes API 服务器的大部分部件相似，尽管当然具有不同的 API 组实现，并且没有嵌入式`kube-aggregator`或嵌入式`apiextension-apiserver`（用于服务
    CRD）。这导致几乎与 [图8-1](#aggregation-kube-apiserver) 中显示的架构图片相同：
- en: '![An aggregated custom API server based on k8s.io/apiserver](assets/prku_0802.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![基于 k8s.io/apiserver 的聚合自定义 API 服务器](assets/prku_0802.png)'
- en: Figure 8-2\. An aggregated custom API server based on k8s.io/apiserver
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-2。基于 k8s.io/apiserver 的聚合自定义 API 服务器。
- en: 'We observe a number of things. An aggregated API server:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察到一些事情。一个聚合的 API 服务器：
- en: Has the same basic internal structure as the Kubernetes API server.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有与 Kubernetes API 服务器相同的基本内部结构。
- en: Has its own handler chain, including authentication, audit, impersonation, max-in-flight
    throttling, and authorization (we will explain throughout this chapter why this
    is necessary; see, for example, [“Delegated Authorization”](#aggregated-authorization)).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有自己的处理程序链，包括身份验证、审计、冒充、最大并发限制和授权（我们将在本章中详细解释为什么这是必要的；例如，参见[“委托授权”](#aggregated-authorization)）。
- en: Has its own resource handler pipeline, including decoding, conversion, admission,
    REST mapping, and encoding.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有自己的资源处理程序管道，包括解码、转换、准入、REST 映射和编码。
- en: Calls admission webhooks.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用准入 Webhook。
- en: Might write to `etcd` (it can use a different storage backend, though). The
    `etcd` cluster does not have to be the same as the one used by the Kubernetes
    API server.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会写入`etcd`（尽管它可以使用不同的存储后端）。`etcd` 集群不必与 Kubernetes API 服务器使用的相同。
- en: Has its own scheme and registry implementation for custom API groups. The registry
    implementation might differ and be customized to any degree.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有自己的方案和注册表实现用于自定义 API 组。注册表实现可能有所不同，并且可以根据需要进行定制。
- en: Does authentication again. It usually does client certificate authentication
    and token-based authentication, calling back to the Kubernetes API server with
    a `TokenAccessReview` request. We will discuss the authentication and trust architecture
    in more detail shortly.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次进行认证。通常进行客户端证书认证和基于令牌的认证，并通过`TokenAccessReview`请求回调到 Kubernetes API 服务器。我们将在稍后更详细地讨论认证和信任架构。
- en: Does its own auditing. This means the Kubernetes API server audits certain fields,
    but only on the meta level. Object-level auditing is done in the aggregated custom
    API server.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自己进行审计。这意味着 Kubernetes API 服务器会审计某些字段，但仅限于元级别。对象级别的审计是在聚合的自定义 API 服务器中完成的。
- en: Does its own authentication using `SubjectAccessReview` requests to the Kubernetes
    API server. We will discuss authorization in more detail shortly.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SubjectAccessReview`请求对 Kubernetes API 服务器进行自身认证。我们将稍后更详细地讨论授权。
- en: Delegated Authentication and Trust
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托认证和信任
- en: An aggregated custom API server (based on [*k8s.io/apiserver*](http://bit.ly/2X3joNX))
    is built on the same authentication library as the Kubernetes API server. It can
    use client certificates or tokens to authenticate a user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 基于[*k8s.io/apiserver*](http://bit.ly/2X3joNX)构建的聚合自定义API服务器与Kubernetes API服务器使用相同的认证库。它可以使用客户端证书或令牌对用户进行身份验证。
- en: Because an aggregated custom API server is architecturally placed behind the
    Kubernetes API server (i.e., the Kubernetes API server receives requests and proxies
    them to the aggregated custom API server), requests are already authenticated
    by the Kubernetes API server. The Kubernetes API server stores the result of the
    authentication—that is, the username and group membership—in HTTP request headers,
    usually `X-Remote-User` and `X-Remote-Group` (these can be configured with the
    `--requestheader-username-headers` and `--requestheader-group-headers` flags).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为聚合自定义API服务器在Kubernetes API服务器之后架构上（即Kubernetes API服务器接收请求并将其代理到聚合自定义API服务器），请求已经由Kubernetes
    API服务器进行了身份验证。 Kubernetes API服务器将身份验证结果（即用户名和组成员资格）存储在HTTP请求头中，通常为`X-Remote-User`和`X-Remote-Group`（可以使用`--requestheader-username-headers`和`--requestheader-group-headers`标志进行配置）。
- en: 'The aggregated custom API server has to know when to trust these headers; otherwise,
    any other caller could claim to have done authentication and could set these headers.
    This is handled by a special request header client CA. It is stored in the config
    map *kube-system/extension-apiserver-authentication* (filename *requestheader-client-ca-file*).
    Here is an example:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合自定义API服务器必须知道何时信任这些头部；否则，任何其他调用者都可以声称已进行了身份验证并且可以设置这些头部。这由特殊的请求头客户端CA处理。它存储在配置映射*kube-system/extension-apiserver-authentication*（文件名*requestheader-client-ca-file*）中。这里是一个示例：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this information, an aggregated custom API server with default settings
    will authenticate:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，使用默认设置的聚合自定义API服务器将进行身份验证：
- en: Clients using client certificates matching the given *client-ca-file*
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用与给定*client-ca-file*匹配的客户端证书的客户端
- en: Clients preauthenticated by the Kubernetes API server whose requests are forwarded
    using the given *requestheader-client-ca-file* and whose username and group memberships
    are stored in the given HTTP headers `X-Remote-Group` and `X-Remote-User`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端由Kubernetes API服务器预认证，其请求使用给定的*requestheader-client-ca-file*进行转发，并且其用户名和组成员资格存储在给定的HTTP头`X-Remote-Group`和`X-Remote-User`中。
- en: 'Last but not least, there is a mechanism called `TokenAccessReview` that forwards
    bearer tokens (received via the HTTP header `Authorization: bearer *token*`) back
    to the Kubernetes API server in order to verify whether they are valid. The token
    access review mechanism is disabled by default but can optionally be enabled;
    see [“Options and Config Pattern and Startup Plumbing”](#aggregated-apiserver-development-options-config).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '最后但同样重要的是，有一个名为`TokenAccessReview`的机制，它将承载令牌（通过HTTP头部`Authorization: bearer
    *token*`接收）发送回Kubernetes API服务器，以验证它们是否有效。令牌访问审查机制默认情况下是禁用的，但可以选择启用；请参阅[“选项和配置模式及启动管道”](#aggregated-apiserver-development-options-config)。'
- en: We will see in the following sections how delegated authentication is actually
    set up. While we’ve gone into detail about this mechanism here, inside an aggregated
    custom API server this is mostly done automatically by the *k8s.io/apiserver*
    library. But knowing what is going on behind the curtain is certainly valuable,
    especially where security is involved.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分看到委派身份验证是如何实际设置的。虽然我们在这里详细介绍了这个机制，在聚合自定义API服务器内部，这大部分都是由*k8s.io/apiserver*库自动完成的。但了解幕后发生的事情在涉及安全性时确实很有价值。
- en: Delegated Authorization
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委派授权
- en: After authentication has been done, each request must be authorized. Authorization
    is based on the username and group list. The default authorization mechanism in
    Kubernetes is role-based access control (RBAC).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证完成后，必须对每个请求进行授权。授权基于用户名和组列表。Kubernetes中的默认授权机制是基于角色的访问控制（RBAC）。
- en: RBAC maps identities to roles, and roles to authorization rules, which finally
    accept or reject requests. We won’t go into all the details here about RBAC authorization
    objects like roles and cluster roles, or role bindings and cluster role bindings
    (see [“Getting the Permissions Right”](ch07.html#crds-rbac) for more). From an
    architectural point of view it is enough to know that an aggregated custom API
    server authorizes requests using delegated authorization via `SubjectAccessReview`s.
    It does not evaluate RBAC rules itself but instead delegates evaluation to the
    Kubernetes API server.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC 将身份映射到角色，并将角色映射到授权规则，最终接受或拒绝请求。我们这里不会详细讨论 RBAC 授权对象，如角色和集群角色，或角色绑定和集群角色绑定的所有细节（请参阅[“正确设置权限”](ch07.html#crds-rbac)了解更多）。从架构的角度来看，了解聚合的自定义
    API 服务器通过 `SubjectAccessReview` 委托授权来授权请求就足够了。它不会自己评估 RBAC 规则，而是将评估委托给 Kubernetes
    API 服务器。
- en: Let’s look at delegated authorization in more detail now.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地查看委托授权。
- en: 'A subject access review is sent from the aggregated custom API server to the
    Kubernetes API server on a request (if it does not find an answer in its authorization
    cache). Here is an example of such a review object:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 主题访问审查请求是从聚合的自定义 API 服务器发送到 Kubernetes API 服务器（如果在其授权缓存中找不到答案时）。以下是这样一个审查对象的示例：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Kubernetes API server receives this from the aggregated custom API server,
    evaluates the RBAC rules in the cluster, and makes a decision, returning a `SubjectAccessReview`
    object with a status field set; for example:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器接收到这些信息后，评估集群中的 RBAC 规则并做出决策，返回一个带有状态字段设置的 `SubjectAccessReview`
    对象；例如：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note here that it is possible that both `allowed` and `denied` are `false`.
    This means that the Kubernetes API server could not make a decision, in which
    case another authorizer inside an aggregated custom API server can make a decision
    (API servers implement an authorization chain that is queried one by one, with
    delegated authorization being one of the authorizers in that chain). This can
    be used to model nonstandard authorization logic—that is, if in certain cases
    there are no RBAC rules but an external authorization system is used instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`allowed` 和 `denied` 可能都是 `false`。这意味着 Kubernetes API 服务器无法做出决策，此时聚合的自定义
    API 服务器中的另一个授权器可以做出决策（API 服务器实现一个授权链，逐个查询，委托授权是该链中的一个授权器）。这可以用于建模非标准授权逻辑，即在某些情况下没有
    RBAC 规则，而是使用外部授权系统。
- en: 'Note that for performance reasons, the delegated authorization mechanism maintains
    a local cache in each aggregated custom API server. By default, it caches 1,024
    authorization entries with:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了性能原因，委托授权机制在每个聚合的自定义 API 服务器中维护一个本地缓存。默认情况下，它使用以下方式缓存 1,024 个授权条目：
- en: '`5` minutes expiry for allowed authorization requests'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许授权请求的有效期为 `5` 分钟
- en: '`30` seconds expiry for denied authorization requests'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝授权请求的有效期为 `30` 秒
- en: These values can be customized via `--authorization-webhook-cache-authorized-ttl`
    and `--authorization-webhook-cache-unauthorized-ttl`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `--authorization-webhook-cache-authorized-ttl` 和 `--authorization-webhook-cache-unauthorized-ttl`
    进行这些值的自定义。
- en: We’ll see in the following sections how delegated authorization is set up in
    code. Again, as with authentication, inside an aggregated custom API server delegated
    authorization is mostly done automatically by the *k8s.io/apiserver* library.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分中看到如何在代码中设置委托授权。同样，与认证一样，在聚合的自定义 API 服务器中，委托授权大多是由 *k8s.io/apiserver*
    库自动完成的。
- en: Writing Custom API Servers
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义 API 服务器
- en: In the previous sections we looked at the architecture of aggregated API servers.
    In this section we want to look at the implementation of an aggregated custom
    API server in Golang.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看了聚合 API 服务器的架构。在本节中，我们想要查看在 Golang 中实现聚合自定义 API 服务器的具体实现。
- en: The main Kubernetes API server is implemented via the *k8s.io/apiserver* library.
    A custom API server will use the very same code. The main difference is that our
    custom API server will run in-cluster. This means that it can assume that a `kube-apiserver`
    is available in the cluster and use it to do delegated authorization and to retrieve
    other kube-native resources.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的 Kubernetes API 服务器是通过 *k8s.io/apiserver* 库实现的。自定义 API 服务器将使用完全相同的代码。主要区别在于我们的自定义
    API 服务器将在集群中运行。这意味着它可以假定集群中有一个 `kube-apiserver` 可用，并使用它进行委托授权和检索其他 kube 本地资源。
- en: We also assume that an `etcd` cluster is available and ready to be used by the
    aggregated custom API server. It is not important whether this `etcd` is dedicated
    or shared with the Kubernetes API server. Our custom API server will use a different
    `etcd` key space to avoid conflicts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还假设`etcd`集群已经准备好，并且可以被聚合的自定义API服务器使用。重要的是这个`etcd`是专用的还是与Kubernetes API服务器共享的并不重要。我们的自定义API服务器将使用不同的`etcd`键空间以避免冲突。
- en: The code examples in this chapter refer to [the example code on GitHub](http://bit.ly/2x9C3gR),
    so look there for the complete source code. We will show only the most interesting
    excerpt here, but you can always go to the complete example project, experiment
    with it, and—very important for learning—run it in a real cluster.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例引用了[Github上的示例代码](http://bit.ly/2x9C3gR)，所以请参考完整的源代码。我们这里只展示了最有趣的摘录，但您可以随时查看完整的示例项目，进行实验，并且非常重要的是在真实集群中运行它以进行学习。
- en: 'This `pizza-apiserver` project implements the example API shown in [“Example:
    A Pizza Restaurant”](#aggregation-example).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`pizza-apiserver`项目实现了在[“示例：Pizza餐厅”](#aggregation-example)中显示的示例API。
- en: Options and Config Pattern and Startup Plumbing
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选项和配置模式以及启动管道
- en: The *k8s.io/apiserver* library uses an *options and config pattern* to create
    a running API server.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*k8s.io/apiserver*库使用选项和配置模式来创建运行中的API服务器。'
- en: We’ll start with a couple of option structs that are bound to flags. Take them
    from *k8s.io/apiserver* and add our custom options. Option structs from *k8s.io/apiserver*
    can be tweaked in-code for special use cases, and the provided flags can be applied
    to a flag set in order to be accessible to the user.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一些绑定到标志的选项结构开始。从*k8s.io/apiserver*获取它们，并添加我们的自定义选项。从*k8s.io/apiserver*获取的选项结构可以根据特殊用例在代码中进行调整，并且提供的标志可以应用到一个标志集中，以便用户访问。
- en: 'In the [example](http://bit.ly/2x9C3gR) we start very simply by basing everything
    on the `RecommendedOptions`. These recommended options set up everything as needed
    for a “normal” aggregated custom API server for simple APIs, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例](http://bit.ly/2x9C3gR)中，我们从`RecommendedOptions`开始，非常简单地基于这一切。这些推荐的选项设置了一切需要的内容，以便为简单API的“正常”聚合自定义API服务器使用：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `CustomServerOptions` embed `RecommendedOptions` and add one field on top.
    `NewCustomServerOptions` is the constructor that fills the `CustomServerOptions`
    struct with default values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomServerOptions`嵌入了`RecommendedOptions`并在顶部添加了一个字段。`NewCustomServerOptions`是填充`CustomServerOptions`结构体默认值的构造函数。'
- en: 'Let’s look into some of the more interesting details:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一些更有趣的细节：
- en: '`defaultEtcdPathPrefix` is the `etcd` prefix for all of our keys. As a key
    space, we use */registry/pizza-apiserver.programming-kubernetes.info*, clearly
    distinct from Kubernetes keys.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultEtcdPathPrefix`是我们所有键的`etcd`前缀。作为键空间，我们使用*/registry/pizza-apiserver.programming-kubernetes.info*，明显区别于Kubernetes的键。'
- en: '`SharedInformerFactory` is the process-wide shared informer factory for our
    own CRs to avoid unnecessary informers for the same resources (see [Figure 3-5](ch03.html#informers-figure)).
    Note that it is imported from the generated informer code in our project and not
    from `client-go`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SharedInformerFactory`是全局共享的通知器工厂，用于我们自己的CR，以避免相同资源的不必要的通知器（参见[图 3-5](ch03.html#informers-figure)）。请注意，它是从我们项目中生成的通知器代码导入的，而不是从`client-go`导入的。'
- en: '`NewRecommendedOptions` sets everything up for an aggregated custom API server
    with default values.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewRecommendedOptions`为聚合的自定义API服务器设置了一切，使用了默认值。'
- en: 'Let’s take a quick look at `NewRecommendedOptions`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速看一下`NewRecommendedOptions`：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All of these can be tweaked if necessary. For example, if a custom default serving
    port is desired, `RecommendedOptions.SecureServing.SecureServingOptions.BindPort`
    can be set.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以根据需要进行调整。例如，如果需要自定义默认的服务端口，可以设置`RecommendedOptions.SecureServing.SecureServingOptions.BindPort`。
- en: 'Let’s briefly go through the existing option structs:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地浏览现有的选项结构：
- en: '`Etcd` configures the storage stack that reads and write to `etcd`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Etcd`配置存储栈，用于读取和写入`etcd`。'
- en: '`SecureServing` configures everything around HTTPS (i.e., ports, certificates,
    etc.)'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SecureServing`配置了所有关于HTTPS的内容（即端口、证书等）。'
- en: '`Authentication` sets up delegated authentication as described in [“Delegated
    Authentication and Trust”](#aggregated-authentication).'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authentication`设置了委托身份验证，如[“委托身份验证和信任”](#aggregated-authentication)中描述的。'
- en: '`Authorization` sets up delegated authorization as described in [“Delegated
    Authorization”](#aggregated-authorization).'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authorization`设置了委托授权，如[“委托授权”](#aggregated-authorization)中描述的。'
- en: '`Audit` sets up the auditing output stack. This is disabled by default, but
    can be set to output an audit log file or to send audit events to an external
    backend.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Audit` 设置审计输出堆栈。默认情况下已禁用，但可以设置为输出审计日志文件或将审计事件发送到外部后端。'
- en: '`Features` configures feature gates of alpha and beta features.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Features` 配置 alpha 和 beta 特性的功能开关。'
- en: '`CoreAPI` holds a path to a kubeconfig file to access the main API server.
    This defaults to using the in-cluster configuration.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoreAPI` 包含访问主 API 服务器的 kubeconfig 文件的路径。默认情况下，这使用集群内配置。'
- en: '`Admission` is a stack of mutating and validating admission plug-ins that execute
    for every incoming API request. This can be extended with custom in-code admission
    plug-ins, or the default admission chain can be tweaked for the custom API server.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Admission` 是一堆变更和验证准入插件的堆栈，用于处理每个传入的 API 请求。可以通过自定义代码中的自定义准入插件来扩展它，或者可以调整自定义
    API 服务器的默认准入链。'
- en: '`ExtraAdmissionInitializers` allows us to add more initializers for admission.
    Initializers implement the plumbing of, for example, informers or clients through
    the custom API server. See [“Admission”](#aggregated-apiserver-development-admission)
    for more about custom admission.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExtraAdmissionInitializers` 允许我们添加更多的准入初始化器。初始化器通过自定义 API 服务器的管道实现，例如，通过控制器或客户端。查看[“准入”](#aggregated-apiserver-development-admission)以了解更多关于自定义准入的信息。'
- en: '`ProcessInfo` holds information for event object creation (i.e., a process
    name and a namespace). We have set it to `pizza-apiserver` for both values.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessInfo` 包含事件对象创建的信息（即，进程名称和命名空间）。我们已将其设置为 `pizza-apiserver` 的值。'
- en: '`Webhook` configures how webhooks operate (e.g., general setting for authentication
    and admission webhook). It is set up with good defaults for a custom API server
    that runs inside of a cluster. For API servers outside of the cluster, this would
    be the place to configure how it can reach the webhook.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Webhook` 配置 webhooks 的操作方式（例如，用于认证和准入 webhook 的通用设置）。对于在集群内运行的自定义 API 服务器，它设置了良好的默认值。对于集群外的
    API 服务器，这是配置它如何访问 webhook 的地方。'
- en: Options are coupled with flags; that is, they are conventionally on the same
    abstraction level as flags. As a rule of thumb, options do not hold “running”
    data structures. They are used during startup and then converted to configuration
    or server objects, which are then run.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 选项与标志耦合；换句话说，它们通常处于与标志相同的抽象级别。作为一个经验法则，选项不保存“运行中”数据结构。它们在启动期间使用，然后转换为配置或服务器对象，然后运行。
- en: Options can be validated via the `Validate() error` method. This method will
    also check that the user-provided flag values make logical sense.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `Validate() error` 方法验证选项。此方法还将检查用户提供的标志值是否合乎逻辑。
- en: Options can be completed in order to set default values, which should not show
    up in the flags’ help text but which are necessary to get a complete set of options.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置默认值来完成选项，这些值不应出现在标志的帮助文本中，但是对于获得完整的选项集是必要的。
- en: 'Options are converted to a server configuration (“config”) by the `Config()
    (*apiserver.Config, error)` method. This is done by starting with a recommended
    default configuration and then applying the options to it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 选项通过 `Config() (*apiserver.Config, error)` 方法转换为服务器配置（“config”）。这是通过从推荐的默认配置开始，然后将选项应用于其上来完成的：
- en: '[PRE10]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The config created here contains runnable data structures; in other words, configs
    are runtime objects, in contrast to the options, which correspond to flags. The
    line `o.RecommendedOptions.SecureServing.MaybeDefaultWithSelfSignedCerts` creates
    self-signed certificates in case the user has not passed flags for pregenerated
    certificates.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在此创建的配置包含可运行的数据结构；换句话说，配置是运行时对象，与选项形成对比，后者对应标志。`o.RecommendedOptions.SecureServing.MaybeDefaultWithSelfSignedCerts`
    这一行在用户未传递用于预生成证书的标志时创建自签名证书。
- en: As we’ve described, `genericapiserver.NewRecommendedConfig` returns a default
    recommended configuration, and `RecommendedOptions.ApplyTo` changes it according
    to flags (and other customized options).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所描述的，`genericapiserver.NewRecommendedConfig` 返回一个默认的推荐配置，而 `RecommendedOptions.ApplyTo`
    则根据标志（和其他定制选项）对其进行更改。
- en: 'The config struct of the `pizza-apiserver` project itself is just a wrapper
    around the `RecommendedConfig` for our example custom API server:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`pizza-apiserver` 项目本身的配置结构只是我们示例自定义 API 服务器的 `RecommendedConfig` 的一个包装：'
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If more state for a running custom API server is necessary, `ExtraConfig` is
    the place to put it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要运行中自定义 API 服务器的更多状态，`ExtraConfig` 就是放置它的地方。
- en: 'Similarly to option structs, the config has a `Complete() CompletedConfig`
    method that sets default values. Because it is necessary to actually call `Complete()`
    for the underlying configuration, it is common to enforce that via the type system
    by introducing the unexported `completedConfig` data type. The idea here is that
    only a call to `Complete()` can turn a `Config` into a `completeConfig`. The compiler
    will complain if this call is not done:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于选项结构体，配置有一个`Complete() CompletedConfig`方法，用于设置默认值。因为必须实际调用`Complete()`来完成底层配置，通常通过引入未导出的`completedConfig`数据类型来通过类型系统强制执行。这里的想法是只有调用`Complete()`才能将`Config`转换为`completeConfig`。如果未执行此调用，编译器将报错：
- en: '[PRE12]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the completed config can be turned into a `CustomServer` runtime struct
    via the `New()` constructor:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过`New()`构造函数可以将完成的配置转换为`CustomServer`运行时结构体：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we have intentionally omitted the API installation part here. We’ll
    come back to this in [“API Installation”](#aggregated-apiserver-development-api-install)
    (i.e., how you wire the *registries* into the custom API server during startup).
    A registry implements the API and storage semantics of an API group. We will see
    this for the restaurant API group in [“Registry and Strategy”](#aggregated-apiserver-development-registry).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在这里有意省略了API安装部分。我们将在[“API安装”](#aggregated-apiserver-development-api-install)中回到这一点（即在启动期间如何将*注册表*连接到自定义API服务器中）。注册表实现API组的API和存储语义。我们将在[“注册表和策略”](#aggregated-apiserver-development-registry)中看到这一点，用于餐厅API组。
- en: 'The `CustomServer` object can finally be started with the `Run(stopCh <-chan
    struct{}) error` method. This is called by the `Run` method of the options in
    our example. That is, `CustomServerOptions.Run`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomServer`对象最终可以通过`Run(stopCh <-chan struct{}) error`方法启动。这由我们示例中选项的`Run`方法调用。也就是说，`CustomServerOptions.Run`：'
- en: Creates the config
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建配置
- en: Completes the config
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成配置
- en: Creates the `CustomServer`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`CustomServer`
- en: Calls `CustomServer.Run`
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`CustomServer.Run`
- en: 'This is the code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `PrepareRun()` call wires up the OpenAPI specification and might do other
    post-API-installation operations. After calling it, the `Run` method starts the
    actual server. It blocks until `stopCh` is closed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrepareRun()`调用连接了OpenAPI规范，并可能执行其他API安装后操作。调用它后，`Run`方法启动实际服务器，它会阻塞直到`stopCh`关闭。'
- en: This example also wires a *post-start hook* named `start-pizza-apiserver-informers`.
    As the name suggests, a post-start hook is called after the HTTPS server is up
    and listening. Here, it starts the shared informer factories.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还连接了一个名为`start-pizza-apiserver-informers`的*后启动钩子*。顾名思义，后启动钩子在HTTPS服务器启动并侦听之后调用。在这里，它启动了共享的通知器工厂。
- en: Note that even local in-process informers of resources provided by the custom
    API server itself speak via HTTPS to the localhost interface. So it makes sense
    to start them after the server is up and the HTTPS port is listening.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使是由自定义API服务器本身提供的本地进程内通知器也会通过HTTPS与本地主机接口通信。因此，在服务器启动并且HTTPS端口正在侦听之后启动它们是有意义的。
- en: Also note that the */healthz* endpoint returns success only after all post-start
    hooks have finished successfully.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意*/healthz*端点仅在所有后启动钩子成功完成后才返回成功。
- en: 'With all the little plumbing pieces in place, the `pizza-apiserver` project
    wraps everything up into a `cobra` command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有小的管道组件就位，`pizza-apiserver`项目将所有内容封装到`cobra`命令中：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With `NewCommandStartCustomServer` the `main()` method of the process is pretty
    simple:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NewCommandStartCustomServer`，进程的`main()`方法非常简单：
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note especially the call to `SetupSignalHandler`: it wires Unix signal handling.
    On `SIGINT` (triggered when you press Ctrl-C in a terminal) and `SIGKILL`, the
    stop channel is closed. The stop channel is passed to the running custom API server,
    and it shuts down when the stop channel is closed. Hence, the main loop will initiate
    a shutdown when one of the signals is received. This shutdown is graceful in the
    sense that running requests are finished (for up to 60 seconds by default) before
    termination. It also makes sure that all requests are sent to the audit backend
    and no audit data is dropped. After all that, `cmd.Execute()` will return and
    the process will terminate.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意调用`SetupSignalHandler`：它连接Unix信号处理。在收到`SIGINT`（在终端按下Ctrl-C触发）和`SIGKILL`时，关闭停止通道。停止通道传递给运行中的自定义API服务器，当停止通道关闭时，它将关闭。因此，主循环将在收到信号时启动关闭过程。这种关闭是优雅的，因为会在终止之前完成正在运行的请求（默认情况下最多60秒），还确保所有请求都发送到审计后端，不会丢失审计数据。在所有这些操作完成后，`cmd.Execute()`将返回，进程将终止。
- en: The First Start
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一次启动
- en: 'Now we have everything in place to start the custom API server for the first
    time. Assuming you have a cluster configured in *~/.kube/config*, you can use
    it for delegated authentication and authorization:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好首次启动自定义 API 服务器了。假设你已经配置了一个集群在 *~/.kube/config*，你可以用它进行委托的认证和授权：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It will start up and start serving the generic API endpoints:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它将启动并开始提供通用 API 端点的服务：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can also list the discovery endpoint, but the result is not very satisfying
    yet—we have not created an API, so the discovery is empty:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以列出发现端点，但结果还不是很令人满意——因为我们还没有创建 API，所以发现结果为空：
- en: '[PRE19]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let’s take a look from a higher level:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从更高层次来看：
- en: We have started a custom API server with the recommended options and config.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经使用推荐的选项和配置启动了自定义 API 服务器。
- en: We have a standard handler chain that includes delegated authentication, delegated
    authorization, and auditing.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个包括委托认证、委托授权和审计的标准处理器链。
- en: 'We have an HTTPS server running and serving requests for the generic endpoints:
    */logs*, */metrics*, */version*, */healthz*, and */apis*.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个运行的 HTTPS 服务器，并为通用端点 */logs*、*/metrics*、*/version*、*/healthz* 和 */apis*
    提供服务。
- en: '[Figure 8-3](#aggregation-kube-apiserver_without) shows this from 10,000 feet.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-3](#aggregation-kube-apiserver_without) 以一万英尺的高度展示了这一情况。'
- en: '![The custom API server without APIs](assets/prku_0803.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![没有 API 的自定义 API 服务器](assets/prku_0803.png)'
- en: Figure 8-3\. The custom API server without APIs
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. 没有 API 的自定义 API 服务器
- en: Internal Types and Conversion
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部类型和转换
- en: Now that we’ve set up a running custom API server, it’s time to actually implement
    APIs. Before doing so, we have to understand API versions and how they are handled
    inside of an API server.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个运行中的自定义 API 服务器，现在是时候实际实现 API 了。在这之前，我们必须理解 API 版本及其在 API 服务器内部处理方式。
- en: Every API server serves a number of resources and versions (see [Figure 2-3](ch02.html#gvr)).
    Some resources have multiple versions. To make multiple versions of a resource
    possible, the API server converts between versions.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 API 服务器为多个资源和版本提供服务（见 [图 2-3](ch02.html#gvr)）。某些资源有多个版本。为了支持多个版本的资源，API 服务器在各版本之间进行转换。
- en: To avoid quadratic growth of necessary conversions between versions, API servers
    use an *internal version* when implementing the actual API logic. The internal
    version is also often called *hub version* because it is a kind of hub that every
    other version is converted to and from (see [Figure 8-4](#aggregation-version-star)).
    The internal API logic is implemented just once for that hub version.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免版本之间必要转换的二次增长，API 服务器在实现实际 API 逻辑时使用 *内部版本*。内部版本也经常被称为 *hub 版本*，因为它是每个其他版本都转换到和从中的中心（见
    [图 8-4](#aggregation-version-star)）。内部 API 逻辑仅为该 hub 版本实现一次。
- en: '![Conversion from and to the hub version](assets/prku_0804.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![从 hub 版本到其他版本的转换](assets/prku_0804.png)'
- en: Figure 8-4\. Conversion from and to the hub version
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. 从 hub 版本到其他版本的转换
- en: '[Figure 8-5](#aggregation-conversions-figure) shows how the API servers make
    use of the internal version in the life-cycle of an API request:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 8-5](#aggregation-conversions-figure) 展示了 API 服务器在 API 请求生命周期中如何利用内部版本：'
- en: The user sends a request using a specific version (e.g., `v1`).
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户使用特定版本（例如，`v1`）发送请求。
- en: The API server decodes the payload and converts it to the internal version.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 服务器解码有效负载并将其转换为内部版本。
- en: The API server passes the internal version through admission and validation.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 服务器通过审核和验证传递内部版本。
- en: The API logic is implemented for internal versions in the registry.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 逻辑在注册表中为内部版本实现。
- en: '`etcd` reads and writes the versioned object (e.g., `v2`—the storage version);
    that is, it converts from and to the internal version.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etcd` 读取和写入版本化对象（例如，`v2`—存储版本）；也就是说，它从内部版本转换到目标版本。'
- en: Finally, the result is converted to the request version, in this case, `v1`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，结果被转换为请求的版本，本例中为 `v1`。
- en: '![Conversion of API objects during the life-cycle of a request](assets/prku_0805.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![API 对象在请求生命周期中的转换](assets/prku_0805.png)'
- en: Figure 8-5\. Conversion of API objects during the lifecycle of a request
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-5\. API 对象在请求生命周期中的转换
- en: On each edge between the internal hub version and the external version, a conversion
    takes place. In [Figure 8-6](#aggregation-conversions-points), you can count the
    number of conversions per request handler. In a writing operation (like creation
    and update), at least four conversions are done, and even more if admission webhooks
    are deployed in the cluster. As you can see, conversion is a crucial operation
    in every API implementation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部中心版本与外部版本之间的每条边缘上，都会进行一次转换。在 [图 8-6](#aggregation-conversions-points) 中，您可以计算每个请求处理程序的转换次数。在写操作（如创建和更新）中，至少会执行四次转换，如果集群中部署了准入
    Webhook，则可能会执行更多转换。正如您所见，转换是每个 API 实现中至关重要的操作。
- en: '![Conversions and Defaulting during the life-cycle of a request](assets/prku_0806.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![请求生命周期中的转换和默认值](assets/prku_0806.png)'
- en: Figure 8-6\. Conversions and defaulting during the lifecycle of a request
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-6\. 请求生命周期中的转换和默认值
- en: In addition to conversion, [Figure 8-6](#aggregation-conversions-points) also
    shows when *defaulting* takes place. Defaulting is the process of filling in unspecified
    field values. Defaulting is highly coupled with conversion, and is always done
    on the external version when it comes in from the user’s request, from `etcd`
    or from an admission webhook, but never when converted from the hub to the external
    version.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 除了转换外，[图 8-6](#aggregation-conversions-points) 还显示了*默认值*的设置时机。默认值是填充未指定字段值的过程。默认值与转换高度耦合，并且始终在外部版本从用户请求、从`etcd`或从准入
    Webhook 接收时进行，但从中心转换到外部版本时则不会进行。
- en: Warning
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Conversion is crucial for the API server mechanics. It is also crucial that
    all conversions (back and forth) must be correct in the sense of being *roundtrippable*.
    Roundtrippable means that we can convert back and forth in the version graph ([Figure 8-4](#aggregation-version-star))
    starting with random values, and we never lose any information; that is, conversions
    are bijective, or one-to-one. For example, we must be able to go from a random
    (but valid) `v1` object to the internal hub type, then to `v1alpha1`, back to
    the internal hub type, and then back to `v1`. The resulting object must be equivalent
    to the original.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 API 服务器机制而言，转换至关重要。同样重要的是，所有转换（前后）必须正确，即符合*双向可逆*的概念。双向可逆意味着我们可以在版本图中（从 [图 8-4](#aggregation-version-star)
    开始）的随机值之间前后转换，而且不会丢失任何信息；换句话说，转换是双射的或一对一的。例如，我们必须能够从一个随机（但有效的）`v1`对象转换到内部中心类型，然后转换到`v1alpha1`，再次转换到内部中心类型，然后再次转换回`v1`。得到的对象必须等同于原始对象。
- en: Making types roundtrippable often requires a lot of thought; it nearly always
    drives the API design of new versions and also influences the extension of old
    types in order to store the information that new versions carry.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类型的双向转换通常需要深思熟虑；它几乎总是驱动新版本的 API 设计，并影响旧类型的扩展，以存储新版本所携带的信息。
- en: 'In short: getting roundtripping right is hard—very hard at times. See [“Roundtrip
    Testing”](#aggregated-apiserver-roundtrip) to learn how roundtripping can be tested
    effectively.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之：正确实现双向转换是困难的——有时非常困难。请参阅 [“双向转换测试”](#aggregated-apiserver-roundtrip) 以了解如何有效地测试双向转换。
- en: Defaulting logic can changed during the lifecycle of an API server. Imagine
    you add a new field to a type. The user might have old objects stored on disk,
    or the `etcd` may have old objects. If that new field has a default, this field
    value is set when the old, stored objects are sent to the API server, or when
    the user retrieves one of the old objects from `etcd`. It looks like the new field
    has existed forever, while in reality the defaulting process in the API server
    sets the field values during the processing of the request.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 默认逻辑可能会在 API 服务器的生命周期内发生变化。想象一下，您向类型添加了一个新字段。用户可能在磁盘上存储了旧对象，或者`etcd`可能存储了旧对象。如果该新字段具有默认值，当将旧存储对象发送到
    API 服务器时，或者当用户从`etcd`检索到其中一个旧对象时，该字段值会被设置。在请求处理过程中，API 服务器的默认过程设置字段值，看起来就像新字段一直存在一样。
- en: Writing the API Types
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 API 类型
- en: As we have seen, to add an API to the custom API server, we have to write the
    internal hub version types and the external version types and convert between
    them. This is what we’ll look at now for the [pizza example project](http://bit.ly/2x9C3gR).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，要向自定义 API 服务器添加 API，我们必须编写内部中心版本类型和外部版本类型，并在它们之间进行转换。现在我们将为 [比萨示例项目](http://bit.ly/2x9C3gR)
    进行详细讨论。
- en: API types are traditionally placed into the *pkg/apis/`group-name`* package
    of the project with *pkg/apis/`group-name`/types.go* for internal types and *pkg/apis/`group-name`/`version`/types.go*
    for the external versions). So, for our example, *pkg/apis/restaurant*, *pkg/apis/restaurant/v1alpha1/types.go*,
    and *pkg/apis/restaurant/v1beta1/types.go*.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: API 类型传统上放置在项目的 *pkg/apis/`group-name`* 包中，内部类型为 *pkg/apis/`group-name`/types.go*，外部版本为
    *pkg/apis/`group-name`/`version`/types.go*)。因此，对于我们的示例，*pkg/apis/restaurant*，*pkg/apis/restaurant/v1alpha1/types.go*
    和 *pkg/apis/restaurant/v1beta1/types.go*。
- en: Conversions will be created at *pkg/apis/`group-name`/`version`/zz_generated.conversion.go*
    (for `conversion-gen` output) and *pkg/apis/`group-name`/`version`/conversion.go*
    for custom conversions written by the developer.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 转换将在 *pkg/apis/`group-name`/`version`/zz_generated.conversion.go*（用于 `conversion-gen`
    输出）和开发者编写的自定义转换的 *pkg/apis/`group-name`/`version`/conversion.go* 中创建。
- en: In a similar way, defaulting code will be created for `defaulter-gen` output
    at *pkg/apis/`group-name`/`version`/zz_generated.defaults.go* and at *pkg/apis/`group-name`/`version`/defaults.go*
    for custom defaulting code written by the developer. We have both *pkg/apis/restaurant/v1alpha1/defaults.go*
    and *pkg/apis/restaurant/v1beta1/defaults.go* in our example.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`defaulter-gen` 输出的默认代码将被创建在 *pkg/apis/`group-name`/`version`/zz_generated.defaults.go*
    和开发者编写的自定义默认代码中的 *pkg/apis/`group-name`/`version`/defaults.go*。在我们的示例中，*pkg/apis/restaurant/v1alpha1/defaults.go*
    和 *pkg/apis/restaurant/v1beta1/defaults.go* 都有。
- en: We go into more detail about conversion and defaulting in [“Conversions”](#aggregated-apiserver-conversion)
    and [“Defaulting”](#aggregated-apiserver-defaulting).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“转换”](#aggregated-apiserver-conversion)和[“默认情况”](#aggregated-apiserver-defaulting)中详细讨论转换和默认情况。
- en: With the exception of conversion and defaulting, we’ve seen most of this process
    already for CustomResourceDefinitions in [“Anatomy of a type”](ch04.html#anatomy-of-CRD-types).
    Native types for the external versions in our custom API server are defined exactly
    the same way.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 除了转换和默认情况外，我们已经在[“类型解剖”](ch04.html#anatomy-of-CRD-types)中为自定义资源定义的大部分过程已经见过了。在我们自定义的
    API 服务器中，外部版本的原生类型完全以相同的方式定义。
- en: In addition, we have *pkg/apis/`group-name`/types.go* for the internal types,
    the hub types. The main difference is that in the latter the `SchemeGroupVersion`
    in the *register.go* file references `runtime.APIVersionInternal` (which is a
    shortcut for `"__internal"`).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们有 *pkg/apis/`group-name`/types.go* 用于内部类型，即中心类型。两者的主要区别在于后者的 *register.go*
    文件中的 `SchemeGroupVersion` 引用了 `runtime.APIVersionInternal`（这是 `"__internal"` 的快捷方式）。
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another difference between `pkg/apis/*group-name*/types.go` and the external
    type files is the lack of JSON and protobuf tags.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*pkg/apis/*group-name*/types.go* 和外部类型文件之间的另一个区别是缺乏 JSON 和 protobuf 标签。'
- en: Tip
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: JSON tags are used by some generators to detect whether a *types.go* file is
    for an external version or the internal version. So always drop those tags when
    copying and pasting external types in order to create or update the internal types.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一些生成器使用 JSON 标签来检测 *types.go* 文件是否为外部版本或内部版本。因此，在复制和粘贴外部类型以创建或更新内部类型时，务必删除这些标签。
- en: 'Last but not least, there is a helper to install all versions of an API group
    into a scheme. This helper is traditionally placed in *pkg/apis/`group-name`/install/install.go*.
    For our custom API server *pkg/apis/restaurant/install/install.go*, it looks as
    simple as this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，有一个助手将 API 组的所有版本安装到一个方案中。这个助手通常放置在 *pkg/apis/`group-name`/install/install.go*
    中。对于我们的自定义 API 服务器 *pkg/apis/restaurant/install/install.go*，看起来就像这样简单：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Because we have multiple versions, the priority has to be defined. This order
    will be used to determine the default storage version of the resource. It used
    to also play a role in version selection in internal clients (clients that return
    internal version objects; refer back to the note [“Versioned Clients and Internal
    Clients in the Past”](ch03.html#internal-clients)). But internal clients are deprecated
    and are going away. Even code inside an API server will use an external version
    client in the future.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有多个版本，必须定义优先级。此顺序将用于确定资源的默认存储版本。它曾经在内部客户端（返回内部版本对象的客户端；参见注释[“过去的版本化客户端和内部客户端”](ch03.html#internal-clients)）中也起过版本选择的作用。但是内部客户端已被弃用，即将消失。甚至
    API 服务器内部的代码将来也将使用外部版本客户端。
- en: Conversions
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换
- en: Conversion takes an object in one version and converts it into an object in
    another version. Conversion is implemented through conversion functions, some
    of them manually written (placed into *pkg/apis/`group-name`/`version`/conversion.go*
    by convention), and others autogenerated by [`conversion-gen`](http://bit.ly/31RewiP)
    (placed by convention into *pkg/apis/`group-name`/`version`/zz_generated.conversion.go*).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 转换将一个版本中的对象转换为另一个版本中的对象。转换通过转换函数实现，其中一些是手动编写的（按照惯例放置在*pkg/apis/`group-name`/`version`/conversion.go*中），其他则由[`conversion-gen`](http://bit.ly/31RewiP)自动生成（按照惯例放置在*pkg/apis/`group-name`/`version`/zz_generated.conversion.go*中）。
- en: 'Conversion is initiated via a scheme (see [“Scheme”](ch03.html#scheme)) using
    the `Convert()` method, passing the source object `in` and the target object `out`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过方案（见[“Scheme”](ch03.html#scheme)）使用`Convert()`方法启动转换，传递源对象`in`和目标对象`out`：
- en: '[PRE22]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `context` is described as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`context`描述如下：'
- en: '[PRE23]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: It is used only in very special cases and is usually `nil`. Later in the chapter
    we will look at the conversion function scope, which allows us to access this
    context from within conversion functions.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它仅在非常特殊的情况下使用，并且通常为`nil`。稍后在本章中，我们将查看转换函数作用域，这使我们能够从转换函数内部访问此上下文。
- en: 'To do the actual conversion, the scheme knows about all the Golang API types,
    their GroupVersionKinds, and the conversion functions between GroupVersionKinds.
    For this, `conversion-gen` registers generated conversion functions via the local
    scheme builder. In our example custom API server, the *zz_generated.conversion.go*
    file starts like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行实际的转换，方案了解所有Golang API类型、它们的GroupVersionKinds以及在GroupVersionKinds之间的转换函数。为此，`conversion-gen`通过本地方案构建器注册生成的转换函数。在我们的示例自定义API服务器中，*zz_generated.conversion.go*文件以如下方式开始：
- en: '[PRE24]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The function `Convert_v1alpha1_Topping_To_restaurant_Topping()` is generated.
    It takes a `v1alpha1` object and converts it to the internal type.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`Convert_v1alpha1_Topping_To_restaurant_Topping()`是由生成的。它接收一个`v1alpha1`对象并将其转换为内部类型。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding complicated type conversion turns the typed conversion function
    into a uniformly typed `func(a, b interface{}, scope conversion.Scope) error`.
    The scheme uses the latter types because it can call them without the use of reflection.
    Reflection is slow due to the many necessary allocations.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 前面复杂的类型转换将有类型的转换函数变成一个统一类型的`func(a, b interface{}, scope conversion.Scope) error`。该方案使用后者的类型，因为它可以在不使用反射的情况下调用它们。由于反射需要许多必要的分配，因此反射速度较慢。
- en: 'The manually written conversions in *conversion.go* take precedence during
    generation in the sense that `conversion-gen` skips generation for types if it
    finds a manually written function in the packages with the *Convert_`source-package-basename_Kind`To_`target-package-basename`_Kind*
    conversion function naming pattern. For example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在*conversion.go*中手动编写的转换在生成过程中优先，这意味着如果在包中找到符合*Convert_`source-package-basename_Kind`To_`target-package-basename`_Kind*命名模式的手动编写函数，`conversion-gen`将跳过类型的生成。例如：
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the simplest case, conversion functions just copy over values from the source
    to the target object. But for the previous example, which converts a `v1alpha1`
    pizza specification to the internal type, simple copying is not enough. We have
    to adapt the different structure, which actually looks like the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，转换函数只是从源对象复制值到目标对象。但对于前面的例子，将`v1alpha1`披萨规范转换为内部类型，简单的复制是不够的。我们必须适应不同的结构，实际上看起来像下面这样：
- en: '[PRE26]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Clearly, no code generation can be so clever as to foresee what the user intended
    when defining these different types.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，没有代码生成可以如此聪明地预见用户在定义这些不同类型时的意图。
- en: Note that during conversion the source object must never be mutated. But it
    is completely normal and, often for performance reasons, highly recommended to
    reuse data structures of the source in the target object if the types match.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换过程中，请注意源对象绝不能被改变。但是，如果类型匹配，将源数据结构在目标对象中完全正常并且通常出于性能原因是强烈建议的。
- en: This is so important that we reiterate it in a warning, because it has implications
    not only for the implementation of conversion but also for callers of conversions
    and consumers of conversion output.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如此重要，以至于我们在警告中再次强调它，因为它不仅对转换的实现有影响，还对调用者和转换输出的消费者有影响。
- en: Warning
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Conversion functions must not mutate the source object, but the output is allowed
    to share data structures with the source. This means that consumers of conversion
    output have to make sure not to mutate an object if the original object must not
    be mutated.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 转换函数不能改变源对象，但允许输出与源对象共享数据结构。这意味着转换输出的消费者必须确保不要改变对象，如果不希望改变原始对象，则需要进行深度拷贝。
- en: For example, assume you have a `pod *core.Pod` in the internal version, and
    you convert it to `v1` as `podv1 *corev1.Pod`, and mutate the resulting `podv1`.
    This might also mutate the original `pod`. If the `pod` came from an informer,
    this is highly dangerous because informers have a shared cache and mutating `pod`
    makes the cache inconsistent.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您在内部版本中有一个`pod *core.Pod`，并将其转换为`v1`版本的`podv1 *corev1.Pod`，并且改变了结果的`podv1`。这可能也会改变原始的`pod`。如果`pod`来自于一个informer，这是非常危险的，因为
    informer 具有共享缓存，而改变`pod`会使缓存不一致。
- en: So, be aware of this property of conversion and do deep copies if necessary
    to avoid undesired and potentially dangerous mutations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要注意这种转换特性，如有必要请进行深度拷贝，以避免不必要和潜在的危险变异。
- en: 'While this sharing of data structures leads to some risk, it also can avoid
    unnecessary allocations in many situations. Generated code goes so far that the
    generator compares source and target structs and uses Golang’s `unsafe` packages
    to convert pointers to structs of the same memory layout via a simple type conversion.
    Because the internal type and the `v1beta1` types for a pizza in our example have
    the same memory layout, we get this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数据结构的共享会带来一些风险，但在许多情况下也可以避免不必要的分配。生成的代码会比较源结构和目标结构，并使用 Golang 的`unsafe`包通过简单的类型转换将指向具有相同内存布局的结构体的指针进行转换。因为在我们的示例中，内部类型和`v1beta1`类型的
    pizza 具有相同的内存布局，所以我们得到了这个：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On the machine language level, this is a NOOP and therefore as fast as it can
    get. It avoids allocating a slice in this case and copying item by item from `in`
    to `out`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器语言级别上，这是一个 NOOP 操作，因此速度非常快。在这种情况下，它避免了分配一个切片并从`in`复制项目到`out`。
- en: 'Last but not least, some words about the third argument of conversion functions:
    the conversion scope `conversion.Scope`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要，关于转换函数的第三个参数的一些说明：转换范围`conversion.Scope`。
- en: 'The conversion scope provides access to a number of conversion metalevel values.
    For example, it allows us to access the `context` value that is passed to the
    scheme’s `Convert(in, out interface{}, context interface{}) error` method via:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 转换范围提供对多个转换元值的访问。例如，它允许我们通过以下方式访问传递给方案的`Convert(in, out interface{}, context
    interface{}) error`方法的`context`值：
- en: '[PRE28]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It also allows us to call the scheme conversion for subtypes via `s.Convert`,
    or without considering the registered conversion functions at all via `s.DefaultConvert`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 它还允许我们通过`s.Convert`来调用子类型的方案转换，或者在完全不考虑注册的转换函数的情况下通过`s.DefaultConvert`。
- en: In most conversion cases, though, there is no need to use the scope at all.
    You can just ignore its existence for the sake of simplicity until you hit a tricky
    situation where more context than the source and target object is necessary.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数转换情况下，实际上根本不需要使用范围。为了简单起见，可以忽略其存在，直到遇到需要比源对象和目标对象更多上下文的棘手情况为止。
- en: Defaulting
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认值
- en: Defaulting is the step in an API request’s lifecycle that sets default values
    for omitted fields in incoming objects (from the client or from `etcd`). For example,
    a pod has a `restartPolicy` field. If the user does not specify it, a value will
    default to `Always`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值是 API 请求生命周期中设置省略对象（来自客户端或`etcd`）中省略字段的默认值的步骤。例如，一个 pod 有一个`restartPolicy`字段。如果用户没有指定它，该值将默认为`Always`。
- en: Imagine we are using a very old Kubernetes version around the year 2014\. The
    field `restartPolicy` was just introduced to the system in the latest release
    at that time. After an upgrade of your cluster, there is a pod in `etcd` without
    the `restartPolicy` field. A `kubectl get pod` would read the old pod from `etcd`
    and the defaulting code would add the default value `Always`. From the user’s
    point of view, magically the old pod suddenly has the new `restartPolicy` field.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们正在使用一个非常旧的 Kubernetes 版本，大约在 2014 年左右。该字段`restartPolicy`刚刚在当时的最新版本中引入到系统中。在升级集群后，`etcd`中有一个没有`restartPolicy`字段的
    pod。一个`kubectl get pod`将从`etcd`中读取旧的 pod，并且默认值代码会添加默认值`Always`。从用户的角度来看，旧的 pod
    突然具有了新的`restartPolicy`字段，这看起来像是魔术般的变化。
- en: Refer back to [Figure 8-6](#aggregation-conversions-points) to see where defaulting
    takes place today in the Kubernetes request pipeline. Note that defaulting is
    done only for external types, not internal types.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 参考[图 8-6](#aggregation-conversions-points)以查看 Kubernetes 请求流水线中当前进行默认设置的位置。请注意，仅为外部类型执行默认操作，而不是内部类型。
- en: Now let’s look at the code that does defaulting. Defaulting is initiated by
    the *k8s.io/apiserver* code via the scheme, similarly to conversion. Hence, we
    have to register defaulting functions into the scheme for our custom types.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一下执行默认设置的代码。默认设置是由*k8s.io/apiserver*代码通过方案启动的，类似于转换。因此，我们必须为我们的自定义类型在方案中注册默认函数。
- en: Again, similarly to conversions, most defaulting code is just generated with
    the [`defaulter-gen`](http://bit.ly/2J108vK) binary. It traverses API types and
    creates defaulting functions in *pkg/apis/`group-name`/`version`/zz_generated.defaults.go*.
    The code doesn’t do anything by default other than calling defaulting functions
    for the substructures.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，大多数默认代码只是通过[`defaulter-gen`](http://bit.ly/2J108vK)二进制生成的。它遍历 API 类型，并在*pkg/apis/`group-name`/`version`/zz_generated.defaults.go*中创建默认函数。默认情况下，此代码除了调用子结构的默认函数外，不执行任何操作。
- en: 'You can define your own defaulting logic by following the defaulting function
    naming pattern `SetDefaults*Kind*`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过遵循默认函数命名模式`SetDefaults*Kind*`来定义自己的默认逻辑：
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In addition, and unlike with conversions, we have to call the registration
    of the generated function on the local scheme builder manually. This is unfortunately
    not done automatically:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与转换不同的是，我们必须手动在本地方案构建器上调用生成函数的注册。不幸的是，这不会自动完成：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, `RegisterDefaults` is generated inside package *pkg/apis/`group-name`/`version`/zz_generated.defaults.go*.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`RegisterDefaults`在包*pkg/apis/`group-name`/`version`/zz_generated.defaults.go*内生成。
- en: For defaulting code, it is crucial to know when a field was set by the user
    and when it wasn’t. This is not that clear in many cases.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于默认代码，了解用户何时设置了字段，何时未设置至关重要。在许多情况下，这一点并不明显。
- en: Golang has zero values for every type and sets them if a field is not found
    in the passed JSON or protobuf. Imagine a default of `true` for a boolean field
    `foo`. The zero value is `false`. Unfortunately, it is not clear whether `false`
    was set due to the user’s input or because `false` is just the zero value of booleans.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Golang 对于每种类型都有零值，并在传递的 JSON 或 protobuf 中找不到字段时设置它们。想象一个布尔字段`foo`的默认值为`true`。零值为`false`。不幸的是，不清楚`false`是由于用户的输入设置的，还是因为`false`只是布尔值的零值。
- en: 'To avoid this situation, often a pointer type must be used in the Golang API
    types (e.g., `*bool` in the preceding case). A user-provided `false` would lead
    to a non-`nil` boolean pointer to a `false` value, and a user-provided `true`
    would lead to the non-`nil` boolean pointer and a `true` value. A not-provided
    field leads to `nil`. This can be detected in the defaulting code:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，通常必须在 Golang API 类型中使用指针类型（例如，在前面的情况下使用`*bool`）。用户提供的`false`将导致非`nil`布尔指针指向`false`值，用户提供的`true`将导致非`nil`布尔指针指向`true`值。未提供字段将导致`nil`。这可以在默认代码中检测到：
- en: '[PRE31]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This gives the desired semantics: “foo defaults to true.”'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了期望的语义：“foo 默认为 true。”
- en: Tip
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: This trick of using a pointer works for primitive types like strings. For maps
    and arrays, it is often hard to reach roundtrippability without identifying `nil`
    maps/arrays and empty maps/arrays. Most defaulters for maps and arrays in Kubernetes
    therefore apply the default in both cases, working around encoding and decoding
    bugs.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用指针的技巧适用于诸如字符串之类的原始类型。对于映射和数组，要在不识别`nil`映射/数组和空映射/数组的情况下实现往返性通常很困难。因此，Kubernetes
    中大多数映射和数组的默认函数在这两种情况下都应用默认值，以解决编码和解码错误。
- en: Roundtrip Testing
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 往返测试
- en: Getting conversions right is hard. Roundtrip tests are an essential tool to
    check automatically in a randomized test that conversions behave as planned and
    do not lose data when converting from and to all known group versions.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 正确进行转换很困难。往返测试是检查在随机测试中转换是否按计划进行并且在从所有已知组版本转换时不丢失数据的重要工具。
- en: 'Roundtrip tests are usually placed with the *install.go* file (for example,
    into *pkg/apis/restaurant/install/roundtrip_test.go*) and just call the roundtrip
    test functions from API Machinery:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 往返测试通常与*install.go*文件一起放置（例如，*pkg/apis/restaurant/install/roundtrip_test.go*），并且只需从
    API Machinery 调用往返测试函数：
- en: '[PRE32]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Internally, the `RoundTripTestForAPIGroup` call installs the API group into
    a temporary scheme using the `Install` functions. Then it creates random objects
    in the internal version using the given fuzzer, and then converts them to some
    external version and back to internal. The resulting objects must be equivalent
    to the original. This test is done hundreds or thousand of times with all external
    versions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`RoundTripTestForAPIGroup` 调用使用 `Install` 函数将 API 组安装到临时方案中。然后，使用给定的 fuzzer
    在内部版本中创建随机对象，然后将它们转换为某些外部版本，再转换回内部版本。结果对象必须与原始对象相等。此测试将在所有外部版本中重复数百次或数千次。
- en: 'A *fuzzer* is a function that return a slice of randomizer functions for the
    internal types and their subtypes. In our example, the fuzzer is placed into the
    package *pkg/apis/restaurant/fuzzer/fuzzer.go* and contains a randomizer for the
    spec struct:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '*fuzzer* 是一个函数，返回内部类型及其子类型的随机函数切片。在我们的示例中，fuzzer 放置在包 *pkg/apis/restaurant/fuzzer/fuzzer.go*
    中，并为 spec 结构体提供了一个随机化器：'
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If no randomizer function is given, the underlying library [*github.com/google/gofuzz*](http://bit.ly/2KJrb27)
    will generically try to fuzz the object by setting random values for base types
    and diving recursively into pointers, structs, maps, and slices, eventually calling
    custom randomizer functions if they are given by the developer.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供随机化器函数，则底层库 [*github.com/google/gofuzz*](http://bit.ly/2KJrb27) 将尝试通用地对对象进行随机化，为基本类型设置随机值，并递归地深入指针、结构体、映射和切片，最终调用开发人员提供的自定义随机化器函数。
- en: When writing a randomizer function for one of the types, it is convenient to
    call `c.FuzzNoCustom(s)` first. It randomizes the given object `s` and also calls
    custom functions for substructures, but not for `s` itself. Then the developer
    can restrict and fix the random values to make the object valid.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当为某种类型编写随机化函数时，首先调用 `c.FuzzNoCustom(s)` 是很方便的。它会随机化给定的对象 `s`，并调用子结构的自定义函数，但不会对
    `s` 本身进行处理。然后开发人员可以限制和修复随机值，使对象有效。
- en: Warning
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It is important to make fuzzers as general as possible in order to cover as
    many valid objects as possible. If the fuzzer is too restrictive, the test coverage
    will be bad. In many cases during the development of Kubernetes, regressions were
    not caught because the fuzzers in place were not good.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能将 fuzzer 设计得尽可能通用，以覆盖尽可能多的有效对象。如果 fuzzer 过于限制，测试覆盖率将变差。在 Kubernetes 的开发过程中，许多情况下由于现有的
    fuzzer 不足以捕捉到回归问题。
- en: On the other hand, a fuzzer only has to consider objects that validate and are
    the projection of actual objects definable in the external versions. Often you
    have to restrict the random values set by `c.FuzzNoCustom(s)` in a way that the
    randomized object becomes valid. For example, a string holding a URL does not
    have to roundtrip for arbitrary values if validation will reject arbitrary strings
    anyway.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，fuzzer 只需考虑验证对象，它们是外部版本中可定义的实际对象的投影。通常需要限制 `c.FuzzNoCustom(s)` 设置的随机值，使随机对象有效。例如，如果一个字符串包含
    URL，则无需为任意值进行往返转换，如果验证将拒绝任意字符串的话。
- en: 'Our preceding `PizzaSpec` example first calls `c.FuzzNoCustom(s)` and then
    fixes up the object by:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的 `PizzaSpec` 示例首先调用 `c.FuzzNoCustom(s)`，然后通过以下方式修复对象：
- en: Defaulting the `nil` case for toppings
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于配料的 `nil` 情况进行默认设置
- en: Setting a reasonable quantity for each topping (without that, the conversion
    to `v1alpha1` will explode in complexity, introducing high quantities into a string
    list)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每种配料设置合理的数量（如果不这样做，在将其转换为 `v1alpha1` 时，将会增加复杂性，并且会在字符串列表中引入高数量）
- en: Normalizing the topping names, as we know that duplicated toppings in a pizza
    spec will never roundtrip (for the internal types, note that v1alpha1 types have
    duplication)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范化配料名称，因为我们知道在 pizza 规范中重复的配料永远不会往返（对于内部类型，注意 v1alpha1 类型存在重复）
- en: Validation
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证
- en: Incoming objects are validated shortly after they have been deserialized, defaulted,
    and converted to the internal version. [Figure 8-5](#aggregation-conversions-figure)
    showed earlier how validation is done between mutating admission plug-ins and
    validating admission plug-ins, long before the actual creation or update logic
    is executed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在反序列化、默认设置和转换为内部版本后不久，传入对象将被验证。[图 8-5](#aggregation-conversions-figure) 早些时候展示了在执行实际创建或更新逻辑之前，如何在变异准入插件和验证准入插件之间进行验证。
- en: This means validation has to be implemented only once for the internal version,
    not for all external versions. This has the advantage that it obviously saves
    implementation work and also ensures consistency between versions. On the other
    hand, it means that validation errors do not refer to the external version. This
    can actually be observed with Kubernetes resources, but in practice it is no big
    deal.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着只需为内部版本实现一次验证，而不是为所有外部版本实现。这具有明显的实施工作节省优势，并确保各版本之间的一致性。另一方面，这意味着验证错误不涉及外部版本。实际上，这在
    Kubernetes 资源中可以观察到，但实际上并不是什么大问题。
- en: In this section, we’ll look at the implementation of validation functions. The
    wiring into the custom API server—namely, calling validation from the strategy
    that configures the generic registry—will be covered in the next section. In other
    words, [Figure 8-5](#aggregation-conversions-figure) is slightly misleading in
    favor of visual simplicity.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下验证函数的实现。将自定义 API 服务器中的连接——也就是从配置通用注册表的策略中调用验证——将在下一节中讨论。换句话说，[图 8-5](#aggregation-conversions-figure)
    在视觉上略显简单化。
- en: 'For now it should be enough to look at the entry point into the validation
    inside the strategy:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，仅需看一下策略内部验证的入口点即可：
- en: '[PRE34]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This calls out to the `Validate*Kind*(obj` `**Kind*) field.ErrorList` validation
    function in the validation package of the API group `pkg/apis/*group*/*validation*`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这会调用验证包中 API 组 `pkg/apis/*group*/*validation*` 的 `Validate*Kind*(obj **Kind*)
    field.ErrorList` 验证函数。
- en: 'The validation functions return an error list. They are usually written in
    the same style, appending return values to an error list while recursively diving
    into the type, one validation function per struct:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 验证函数返回一个错误列表。它们通常以相同的风格编写，将返回值追加到错误列表中，同时递归地深入类型，每个结构体一个验证函数：
- en: '[PRE35]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note how the field path is maintained using `Child` and `Index` calls. The field
    path is the JSON path, which is printed in case of errors.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何使用 `Child` 和 `Index` 调用维护字段路径。字段路径是 JSON 路径，在错误发生时打印。
- en: 'Often there is an additional set of validation functions that differs slightly
    for updates (while the preceding set is used for creation). In our example API
    server, this could look like the following:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 常常存在一组额外的验证函数，这些函数与更新有所不同（而之前的函数用于创建）。在我们的示例 API 服务器中，可能如下所示：
- en: '[PRE36]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This can be used to verify that no read-only fields are changed. Often an update
    validation calls the normal validation functions as well and only adds checks
    relevant for the update.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这可用于验证不更改只读字段。通常，更新验证也会调用正常的验证函数，并且仅添加与更新相关的检查。
- en: Note
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Validation is the right place to restrict object names on creation—for example,
    to be single-word only, or to not include any non-alpha-numeric characters.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，验证是限制对象名称的正确位置——例如，只能是单词，或者不包含任何非字母数字字符。
- en: Actually, any `ObjectMeta` field can technically be restricted in a custom way,
    though that’s not desirable for many fields because it might break core API machinery
    behavior. A number of resources restrict the names because, for example, the name
    will show up in other systems or in other contexts that require a specially formatted
    name.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，任何 `ObjectMeta` 字段在技术上都可以以自定义方式限制，尽管对于许多字段来说并非理想，因为这可能会破坏核心 API 机制行为。一些资源限制名称，例如，因为名称会显示在其他系统或其他需要特殊格式名称的上下文中。
- en: But even if there are special `ObjectMeta` validations in place in a custom
    API server, the generic registry will validate against generic rules in any case,
    after the custom validation has passed. This allows us to return more specific
    error messages from the custom code first.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在自定义 API 服务器中有特定的 `ObjectMeta` 验证，通用注册表也会在自定义验证通过后对其进行通用规则验证。这使我们能够首先从自定义代码返回更具体的错误消息。
- en: Registry and Strategy
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册表和策略
- en: So far, we have seen how API types are defined and validate. The next step is
    the implementation of the REST logic for those API types. [Figure 8-7](#aggregated-registry-figure)
    shows the registry as a central part of the implementation of an API group. The
    generic REST request handler code in *k8s.io/apiserver* calls out to the registry.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何定义和验证 API 类型。下一步是为这些 API 类型的 REST 逻辑实现。[图 8-7](#aggregated-registry-figure)
    显示了注册表作为 API 组实现的核心部分。*k8s.io/apiserver* 中的通用 REST 请求处理程序代码会调用注册表。
- en: '![Resource storage and generic registry](assets/prku_0807.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![资源存储和通用注册表](assets/prku_0807.png)'
- en: Figure 8-7\. Resource storage and generic registry
  id: totrans-313
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-7\. 资源存储和通用注册表
- en: Generic registry
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用注册表
- en: The REST logic is usually implemented by what is called the *generic registry*.
    It is—as the name suggests—a generic implementation of the registry interfaces
    in the package *k8s.io/apiserver/pkg/registry/rest*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: REST 逻辑通常由所谓的*通用注册表*实现。正如其名称所示，它是 *k8s.io/apiserver/pkg/registry/rest* 包中注册表接口的通用实现。
- en: The generic registry implements the default REST behavior for “normal” resources.
    Nearly all Kubernetes resources use this implementation. Only a few, specifically
    those that do not persist objects (e.g., `SubjectAccessReview`; see [“Delegated
    Authorization”](#aggregated-authorization)), have custom implementations.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 通用注册表实现了“普通”资源的默认 REST 行为。几乎所有 Kubernetes 资源使用此实现。仅少数不持久化对象的资源（例如`SubjectAccessReview`；参见[“委托授权”](#aggregated-authorization)）具有自定义实现。
- en: 'In *k8s.io/apiserver/pkg/registry/rest/rest.go* you will find many interfaces,
    loosely corresponding to HTTP verbs and certain API functionalities. If an interface
    is implemented by a registry, the API endpoint code will offer certain REST features.
    Because the generic registry implements most of the *k8s.io/apiserver/pkg/registry/rest*
    interfaces, resources that use it will support all the default Kubernetes HTTP
    verbs (see [“The HTTP Interface of the API Server”](ch02.html#api-server-http-interface)).
    Here is a list of those interfaces that are implemented, with the GoDoc description
    from the Kubernetes source code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *k8s.io/apiserver/pkg/registry/rest/rest.go* 中，您将找到许多接口，它们大致对应于 HTTP 动词和某些
    API 功能。如果注册表实现了某个接口，则 API 端点代码将提供某些 REST 功能。因为通用注册表实现了大多数 *k8s.io/apiserver/pkg/registry/rest*
    接口，因此使用它的资源将支持所有默认的 Kubernetes HTTP 动词（参见[“API 服务器的 HTTP 接口”](ch02.html#api-server-http-interface)）。以下是已实现的接口列表，包括
    Kubernetes 源代码中的 GoDoc 描述：
- en: '`CollectionDeleter`'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`CollectionDeleter`'
- en: An object that can delete a collection of RESTful resources
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 可以删除一组 RESTful 资源的对象
- en: '`Creater`'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`Creater`'
- en: An object that can create an instance of a RESTful object
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建 RESTful 对象的实例的对象
- en: '`CreaterUpdater`'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreaterUpdater`'
- en: A storage object that must support both create and update operations
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 必须支持创建和更新操作的存储对象
- en: '`Exporter`'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exporter`'
- en: An object that knows how to strip a RESTful resource for export
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何为导出剥离 RESTful 资源的对象
- en: '`Getter`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`Getter`'
- en: An object that can retrieve a named RESTful resource
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检索命名的 RESTful 资源的对象
- en: '`GracefulDeleter`'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`GracefulDeleter`'
- en: An object that knows how to pass deletion options to allow delayed deletion
    of a RESTful object
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 知道如何传递删除选项以允许延迟删除 RESTful 对象的对象
- en: '`Lister`'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lister`'
- en: An object that can retrieve resources that match the provided field and label
    criteria
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 可以检索符合提供的字段和标签条件的资源的对象
- en: '`Patcher`'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`Patcher`'
- en: A storage object that supports both get and update
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 支持获取和更新的存储对象
- en: '`Scoper`'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scoper`'
- en: An object that must be specified and indicates what scope the resource
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 必须指定并指示资源所在范围的对象
- en: '`Updater`'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '`Updater`'
- en: An object that can update an instance of a RESTful object
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 可以更新 RESTful 对象实例的对象
- en: '`Watcher`'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`Watcher`'
- en: An object that should be implemented by all storage objects that want to offer
    the ability to watch for changes through the `Watch` API
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一个所有存储对象都应实现的对象，希望通过`Watch` API提供监视变更能力
- en: 'Let’s look at one of the interfaces, `Creater`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其中一个接口，`Creater`：
- en: '[PRE37]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A registry implementing this interface will be able to create objects. In contrast
    to `NamedCreater`, the name of the new object either comes from `ObjectMeta.Name`
    or is generated via `ObjectMeta.GenerateName`. If a registry implements `NamedCreater`,
    the name can also be passed through the HTTP path.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此接口的注册表将能够创建对象。与`NamedCreater`相反，新对象的名称要么来自`ObjectMeta.Name`，要么通过`ObjectMeta.GenerateName`生成。如果注册表实现了`NamedCreater`，则名称也可以通过
    HTTP 路径传递。
- en: It is important to understand that the implemented interfaces determine which
    verbs will be supported by the API endpoint that is created while installing the
    API into the custom API server. See [“API Installation”](#aggregated-apiserver-development-api-install)
    for how this is done in the code.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，实现的接口决定了在安装 API 到自定义 API 服务器时将支持哪些动词。请参见[“API 安装”](#aggregated-apiserver-development-api-install)以了解在代码中如何实现这一点。
- en: Strategy
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 策略
- en: The generic registry can be customized to a certain degree using an object called
    a *strategy*. The strategy provides callbacks to functionality like validation,
    as we saw in [“Validation”](#aggregated-apiserver-development-validation).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通用注册表可以使用称为*策略*的对象在一定程度上进行定制。 正如我们在[“验证”](#aggregated-apiserver-development-validation)中看到的，策略提供了到功能的回调，例如验证。
- en: 'The strategy implements the REST strategy interfaces listed here with their
    GoDoc description (see *k8s.io/apiserver/pkg/registry/rest* for their definitions):'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 策略实现了此处列出的 REST 策略接口及其 GoDoc 描述（请参阅*k8s.io/apiserver/pkg/registry/rest*获取定义）：
- en: '`RESTCreateStrategy`'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESTCreateStrategy`'
- en: Defines the minimum validation, accepted input, and name generation behavior
    to create an object that follows Kubernetes API conventions.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了最小验证、接受的输入和名称生成行为，以创建符合 Kubernetes API 约定的对象。
- en: '`RESTDeleteStrategy`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESTDeleteStrategy`'
- en: Defines deletion behavior on an object that follows Kubernetes API conventions.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了符合 Kubernetes API 约定的对象的删除行为。
- en: '`RESTGracefulDeleteStrategy`'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESTGracefulDeleteStrategy`'
- en: Must be implemented by the registry that supports graceful deletion.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 必须由支持优雅删除的注册表实现。
- en: '`GarbageCollectionDeleteStrategy`'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`GarbageCollectionDeleteStrategy`'
- en: Must be implemented by the registry that wants to orphan dependents by default.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 必须由默认要孤立依赖项的注册表实现。
- en: '`RESTExportStrategy`'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESTExportStrategy`'
- en: Defines how to export a Kubernetes object.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了如何导出 Kubernetes 对象。
- en: '`RESTUpdateStrategy`'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`RESTUpdateStrategy`'
- en: Defines the minimum validation, accepted input, and name generation behavior
    to update an object that follows Kubernetes API conventions.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了最小验证、接受的输入和名称生成行为，以更新符合 Kubernetes API 约定的对象。
- en: 'Let’s look again at the strategy for the creation case:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看创建情况的策略：
- en: '[PRE38]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The embedded `ObjectTyper` recognizes objects; that is, it checks whether an
    object in a request is supported by the registry. This is important to create
    the right kind of objects (e.g., via a “foo” resource, only “Foo” resources should
    be created).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入的`ObjectTyper`识别对象；也就是说，它检查请求中的对象是否受注册表支持。 这对于创建正确类型的对象非常重要（例如，通过“foo”资源，只应创建“Foo”资源）。
- en: The `NameGenerator` obviously generates names from the `ObjectMeta.GenerateName`
    field.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`NameGenerator`显然是从`ObjectMeta.GenerateName`字段生成名称。'
- en: Via `NamespaceScoped` the strategy can support cluster-wide or namespaced resources
    by returning either `false` or `true`.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`NamespaceScoped`，该策略可以通过返回`false`或`true`支持整个集群或命名空间资源。
- en: The `PrepareForCreate` method is called with the incoming object before validation.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证之前，使用传入的对象调用`PrepareForCreate`方法。
- en: 'The `Validate` method we’ve seen before in [“Validation”](#aggregated-apiserver-development-validation):
    it’s the entry point to the validation functions.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在[“验证”](#aggregated-apiserver-development-validation)中见过的`Validate`方法：这是验证函数的入口点。
- en: Finally, the `Canonicalize` method does normalization (e.g., sorting of slices).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Canonicalize`方法对切片进行规范化（例如，排序）。
- en: Wiring a strategy into the generic registry
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将策略连接到通用注册表中。
- en: 'The strategy object is plugged into a generic registry instance. Here is the
    REST storage constructor for our custom API server on [GitHub](http://bit.ly/2Y0Mtyn):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 策略对象被插入到通用注册表实例中。 这是我们在[GitHub](http://bit.ly/2Y0Mtyn)上自定义 API 服务器的 REST 存储构造函数：
- en: '[PRE39]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It instantiates the generic registry object `genericregistry.Store` and sets
    a few fields. Many of these fields are optional and `store.CompleteWithOptions`
    will default them if they are not set by the developer.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 它实例化了通用注册表对象`genericregistry.Store`并设置了几个字段。 这些字段中的许多是可选的，如果开发人员未设置它们，`store.CompleteWithOptions`将使用默认值。
- en: You can see how the custom strategy is first instantiated via the `NewStrategy`
    constructor and then plugged into the registry for `create`, `update`, and `delete`
    operators.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`NewStrategy`构造函数首次实例化自定义策略，然后将其插入到注册表中以进行`create`、`update`和`delete`操作。
- en: In addition, the `NewFunc` is set to create a new object instance, and the `NewListFunc`
    field is set to create a new object list. The `PredicateFunc` translates a selector
    (which could be passed to a list request) into a predicate function, filtering
    runtime objects.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`NewFunc`设置为创建新对象实例，并设置了`NewListFunc`字段以创建新对象列表。 `PredicateFunc`将选择器（可以传递到列表请求）转换为谓词函数，过滤运行时对象。
- en: 'The returned object is a REST registry, just a simple wrapper in [our example
    project](http://bit.ly/2Rxcv6G) around the generic registry object to make the
    type our own:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的对象是一个 REST 注册表，在[我们的示例项目](http://bit.ly/2Rxcv6G)中只是一个围绕通用注册表对象的简单包装：
- en: '[PRE40]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this we have everything to instantiate our API and wire it into the custom
    API server. In the following section we’ll see how to create an HTTP handler out
    of it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们已经准备好实例化我们的API并将其连接到自定义API服务器中。在接下来的部分中，我们将看到如何创建HTTP处理程序。
- en: API Installation
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API安装
- en: 'To activate an API in an API server, two steps are necessary:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要在API服务器中激活API，需要两个步骤：
- en: The API version must be installed into the API type’s (and conversion and defaulting
    functions’) server scheme.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须将API版本安装到API类型（以及转换和默认函数）的服务器方案中。
- en: The API version must be installed into the server HTTP multiplexer (mux).
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须将API版本安装到服务器HTTP多路复用器（mux）中。
- en: 'The first step is usually done using `init` functions somewhere centrally in
    the API server bootstrapping. This is done in *pkg/apiserver/apiserver.go* in
    our example custom API server, where the `serverConfig` and `CustomServer` objects
    are defined (see [“Options and Config Pattern and Startup Plumbing”](#aggregated-apiserver-development-options-config)):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步通常是在API服务器引导过程的某个中心位置使用`init`函数完成的。在我们示例的自定义API服务器中，这在*pkg/apiserver/apiserver.go*中完成，其中定义了`serverConfig`和`CustomServer`对象（参见[“选项和配置模式以及启动流程”](#aggregated-apiserver-development-options-config)）：
- en: '[PRE41]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then for each API group that should be served, we call the `Install()` function:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于每个应该提供服务的API组，我们调用`Install()`函数：
- en: '[PRE42]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'For technical reasons, we also have to add some discovery-related types to
    the scheme (this will probably go away in future versions of *k8s.io/apiserver*):'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 由于技术原因，我们还必须向方案中添加一些与发现相关的类型（这可能会在将来的*k8s.io/apiserver*版本中消失）：
- en: '[PRE43]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this we have registered our API types in the global scheme, including conversion
    and defaulting functions. In other words, the empty scheme of [Figure 8-3](#aggregation-kube-apiserver_without)
    now knows everything about our types.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们已在全局方案中注册了我们的API类型，包括转换和默认函数。换句话说，[图8-3](#aggregation-kube-apiserver_without)的空方案现在已了解关于我们类型的所有内容。
- en: The second step is to add the API group to the HTTP mux. The generic API server
    code embedded into our `CustomServer` struct provides the `InstallAPIGroup(apiGroupInfo
    *APIGroupInfo) error` method, which sets up the whole request pipeline for an
    API group.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将API组添加到HTTP mux中。嵌入到我们的`CustomServer`结构体中的通用API服务器代码提供了`InstallAPIGroup(apiGroupInfo
    *APIGroupInfo) error`方法，该方法为API组设置了整个请求流水线。
- en: 'The only thing we have to do is to provide a properly filled `APIGroupInfo`
    struct. We do this in the constructor `New()` `(*CustomServer, error)` of the
    `completedConfig` type:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要做的就是提供一个正确填充的`APIGroupInfo`结构体。我们在`completedConfig`类型的构造函数`New() (*CustomServer,
    error)`中完成了这一步：
- en: '[PRE44]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `APIGroupInfo` has references to the generic registry that we customized
    in [“Registry and Strategy”](#aggregated-apiserver-development-registry) via a
    strategy. For each group version and resource, we create an instance of the registry
    using the implemented constructors.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIGroupInfo`具有对我们在[“注册表和策略”](#aggregated-apiserver-development-registry)中定制的通用注册表的引用。对于每个组版本和资源，我们使用实现的构造函数创建注册表的实例。'
- en: 'The `customregistry.RESTInPeace` wrapper is just a helper that panics when
    the registry constructors return an error:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`customregistry.RESTInPeace`包装器只是一个辅助工具，当注册表构造函数返回错误时会引发恐慌：'
- en: '[PRE45]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The registry itself is version-independent, as it operates on internal objects;
    refer back to [Figure 8-5](#aggregation-conversions-figure). Hence, we call the
    same registry constructor for each version.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表本身是版本无关的，因为它操作内部对象；请参考[图8-5](#aggregation-conversions-figure)。因此，我们为每个版本调用相同的注册表构造函数。
- en: The call to `InstallAPIGroup` finally leads us to a complete custom API server
    ready to serve our custom API group, as shown earlier in [Figure 8-7](#aggregated-registry-figure).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`InstallAPIGroup`最终使我们的完整自定义API服务器准备好为我们的自定义API组提供服务，就像[图8-7](#aggregated-registry-figure)中早先展示的那样。
- en: 'After all this heavy plumbing, it is time to see our new API groups in action.
    For this we start up the server as shown in [“The First Start”](#aggregated-apiserver-development-first-start).
    But this time the discovery info is not empty but instead shows our newly registered
    resource:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有这些繁重的流程之后，现在是时候看到我们新API组的实际效果了。为此，我们启动服务器，如[“首次启动”](#aggregated-apiserver-development-first-start)所示。但这次发现信息不再是空的，而是显示我们新注册的资源：
- en: '[PRE46]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With this, we have nearly reached our goal to serve the restaurant API. We have
    wired the API group versions, conversions are in place, and validation is working.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们几乎已经达到了为服务餐厅API的目标。我们已经连接了API组版本，转换已完成，并且验证工作正常。
- en: What’s missing is a check that a topping mentioned in a pizza actually exists
    in the cluster. We could add this in the validation functions. But traditionally
    these are just format validation functions, which are static and do not need other
    resources to run.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的是检查披萨中提到的配料是否实际存在于集群中。我们可以将此添加到验证函数中。但传统上这些只是格式验证函数，是静态的，不需要其他资源来运行。
- en: In contrast, more complex checks are implemented in admission—the topic of the
    next section.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，更复杂的检查是在准入阶段实现的——这是下一节的主题。
- en: Admission
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准入
- en: 'Every request passes the chain of admission plug-ins after being unmarshaled,
    defaulted, and converted to internal types; refer back to [Figure 8-2](#aggregation-aggregated-apiserver).
    More precisely, requests pass admission twice:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求在解组、默认化和转换为内部类型后都会通过一系列准入插件链；请参考[图8-2](#aggregation-aggregated-apiserver)。更准确地说，请求会经过两次准入：
- en: The mutating plug-ins
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异插件
- en: The validating plug-ins
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证插件
- en: 'Admission plug-ins can be both mutating and validating and therefore can potentially
    get called twice by the admission mechanism:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 准入插件可以既变异又验证，因此可能会被准入机制调用两次：
- en: Once in the mutation phase, called for all mutating plug-ins sequentially
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦进入变异阶段，便按顺序调用所有变异插件。
- en: Once in the validation phase, called (potentially parallelized) for all validating
    plug-ins
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次在验证阶段，为所有验证插件（可能并行）调用
- en: More precisely, a plug-in can implement both the mutating and the validating
    admission interface, with two different methods for both cases.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，一个插件可以同时实现变异和验证准入接口，分别有两种不同的方法。
- en: Note
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Before the separation into mutating and validating, there was just one call
    to each plug-in. It was nearly impossible to keep an eye on which mutation each
    plug-in did and which admission plug-in order therefore made sense to lead to
    consistent behavior for the user.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在分为变异和验证之前，每个插件只调用一次。几乎不可能监视每个插件所做的每个变异，并且因此什么顺序准入插件使得对用户行为一致性具有意义。
- en: This two-step architecture at least ensures that a validation is done at the
    end for all plug-ins, which guarantees consistency.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这种两步架构至少确保所有插件在最后进行验证，从而保证一致性。
- en: In addition, the chain (i.e., the order of plug-ins for both admission phases)
    is the same. Plug-ins are always enabled or disabled for both phases at the same
    time.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，链（即两个准入阶段的插件顺序）是相同的。插件始终同时启用或禁用这两个阶段。
- en: Admission plug-ins, at least those implemented in Golang as described in this
    chapter, work with internal types. In contrast, webhook admission plug-ins (see
    [“Admission Webhooks”](ch09.html#admission-webhooks)) are based on external types
    and involve conversion on the way to the webhook and back (in case of mutating
    webhooks).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 准入插件，至少在Golang中如本章节所述的那样实现的，与内部类型一起工作。相比之下，webhook准入插件（参见[“准入Webhook”](ch09.html#admission-webhooks)）基于外部类型，并且在向webhook和回传（在变异webhook的情况下）的途中进行转换。
- en: But after all this theory, let’s get into the code.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 但是说了这么多理论，让我们进入代码。
- en: Implementation
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现
- en: 'An admission plug-in is a type implementing:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 准入插件是实现以下类型的类型：
- en: The admission plug-in interface `Interface`
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准入插件接口`Interface`
- en: Optionally the `MutatingInterface`
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的`MutatingInterface`
- en: Optionally the `ValidatingInterface`
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的`ValidatingInterface`
- en: 'All three can be found in the package *k8s.io/apiserver/pkg/admission*:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三者都可以在包*k8s.io/apiserver/pkg/admission*中找到：
- en: '[PRE47]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You see that the `Interface` method `Handles` is responsible for filtering on
    the operation. The mutating plug-ins are called via `Admit` and the validating
    plug-ins are called via `Validate`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到`Interface`方法`Handles`负责对操作进行过滤。通过`Admit`调用变异插件，通过`Validate`调用验证插件。
- en: 'The `ObjectInterfaces` gives access to helpers usually implemented by a scheme:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectInterfaces`提供对通常由方案实现的辅助工具的访问：'
- en: '[PRE48]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The attributes passed to the plug-in (via `Admit` or `Validate` or both) basically
    contain all the information extractable from a request that is important to implementing
    advanced checks:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Admit`或`Validate`（或两者）传递给插件的属性基本上包含从请求中提取的所有对实施高级检查重要的信息：
- en: '[PRE49]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the mutating case—that is, in the implementation of the `Admit(a Attributes)
    error` method—the attributes can be mutated, or more precisely, the object returned
    from `GetObject() runtime.Object` can.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在变异情况下——也就是在实现`Admit(a Attributes) error`方法时——属性可能会发生变异，或者更准确地说，从`GetObject()
    runtime.Object`返回的对象可能会发生变异。
- en: In the validating case, mutation is not allowed.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证情况下，不允许变异。
- en: Both cases permit the call to `AddAnnotation(key, value string) error`, which
    allows us to add annotations that end up in the audit output of the API server.
    This can be helpful in order to understand why an admission plug-in mutated or
    rejected a request.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，都允许调用 `AddAnnotation(key, value string) error`，这使我们能够添加注释，最终出现在 API
    服务器的审计输出中。这有助于理解为何准入插件会变异或拒绝请求。
- en: Rejection is signaled by returning a non-`nil` error from `Admit` or `Validate`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 `Admit` 或 `Validate` 返回非`nil`错误来发出拒绝信号。
- en: Tip
  id: totrans-430
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: It is good practice for mutating admission plug-ins to also validate the changes
    in the validating admission phase. The reason is that other plug-ins, including
    webhook admission plug-ins, might add further changes. If an admission plug-in
    guarantees that certain invariants are fulfilled, only the validation step can
    make sure this is really the case.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变异准入插件来说，验证变异的变化也是个好习惯。原因是其他插件，包括 Webhook 准入插件，可能会添加进一步的变化。如果一个准入插件保证某些不变量已被满足，只有验证步骤才能确保这一点。
- en: 'Admission plug-ins have to implement the `Handles(operation Operation) bool`
    method from the `admission.Interface` interfaces. There is a helper in the same
    package called `Handler`. It can be instantiated using `NewHandler(ops ...Operation)
    *Handler` and implements the `Handles` method by embedding `Handler` into the
    custom admission plug-in:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 准入插件必须从 `admission.Interface` 接口实现 `Handles(operation Operation) bool` 方法。同一包中有一个叫做
    `Handler` 的助手。可以使用 `NewHandler(ops ...Operation) *Handler` 来实例化它，并通过将 `Handler`
    嵌入到自定义准入插件中来实现 `Handles` 方法：
- en: '[PRE50]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Admission plug-ins should always check the GroupVersionKind of the passed object
    first:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 准入插件应始终首先检查传递对象的 GroupVersionKind：
- en: '[PRE51]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'and similarly for the validating case:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 对于验证案例也是类似的：
- en: '[PRE52]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The full example admission implementation looks like this:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例准入实现如下所示：
- en: '[PRE53]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It takes the following steps:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 它采取以下步骤：
- en: Checks that the passed object is of the right kind
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查传递的对象是否是正确的类型
- en: Forbids access before the informers are ready
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 informer 就绪之前禁止访问
- en: Verifies via the toppings informer lister that each topping mentioned in the
    pizza specification actually exists as a `Topping` object in the cluster
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过配料 informer 列表检查每个比萨说明中提到的配料是否实际上作为群集中的 `Topping` 对象存在
- en: Note here that the lister is just an interface to the informer in-memory store.
    So these `Get` calls will be fast.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，列表是 informer 内存存储的接口。因此，这些 `Get` 调用将非常快。
- en: Registering
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册
- en: 'Admission plug-ins must be registered. This is done through a `Register` function:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注册准入插件。这通过一个 `Register` 函数来完成：
- en: '[PRE54]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This function is added to the plug-in list in the `RecommendedOptions` (see
    [“Options and Config Pattern and Startup Plumbing”](#aggregated-apiserver-development-options-config)):'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数添加到 `RecommendedOptions` 的插件列表中（见 [“Options and Config Pattern and Startup
    Plumbing”](#aggregated-apiserver-development-options-config)）：
- en: '[PRE55]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, the `RecommendedPluginOrder` list is prepopulated with the generic admission
    plug-ins, which every API server should keep enabled to be a good API convention
    citizen in the cluster.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`RecommendedPluginOrder` 列表预先填充了通用的准入插件，每个 API 服务器都应该保持启用，以便成为集群中良好的 API
    约定公民。
- en: It is best practice not to touch the order. One reason is that getting the order
    right is far from trivial. Of course, adding a custom plug-in at a location other
    than the end of the list is fine, if it is strictly necessary for the plug-in
    behavior.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要触及顺序。一个原因是正确排序远非易事。当然，如果严格需要插件行为，可以在列表的位置添加自定义插件，而不是在列表末尾。
- en: The user of the custom API server will be able to disable a custom admission
    plug-in with the usual admission chain configuration flags (`--disable-admission-plugins`,
    for example). By default our own plug-in is enabled, because we don’t explicitly
    disable it.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 API 服务器的用户可以通过常规的准入链配置标志（例如 `--disable-admission-plugins`）来禁用自定义准入插件。我们默认启用自己的插件，因为我们没有明确禁用它。
- en: 'Admission plug-ins can be configured using a configuration file. To do so,
    we parse the output of the `io.Reader` in the `Register` function shown previously.
    The `--admission-control-config-file` allows us to pass a configuration file to
    the plug-in, like so:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用配置文件配置准入插件。为此，我们解析先前展示的 `Register` 函数中 `io.Reader` 的输出。`--admission-control-config-file`
    允许我们向插件传递配置文件，如下所示：
- en: '[PRE56]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Alternatively, we can do inline configuration to have all our admission configuration
    in one place:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以进行内联配置，将所有准入配置放在一个地方：
- en: '[PRE57]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We briefly mentioned that our admission plug-in uses the toppings informer to
    check for the existence of toppings mentioned in the pizza. We have not talked
    about how to wire that into the admission plug-in. Let’s do this now.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要提到我们的 Admission 插件使用配料 informer 来检查披萨中提到的配料是否存在。我们还没有讨论如何将其连接到 Admission
    插件中。现在让我们来做这个。
- en: Plumbing resources
  id: totrans-458
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源的连接
- en: Admission plug-ins often need clients and informers or other resources to implement
    their behavior. We can do this resource plumbing using plug-in initializers.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Admission 插件通常需要客户端、informer 或其他资源来实现它们的行为。我们可以使用插件初始化器来进行这些资源的连接。
- en: 'There are a number of standard plug-in initializers. If your plug-in wants
    to be called by them, it has to implement certain interfaces with callback methods
    (for more on this, see *k8s.io/apiserver/pkg/admission/initializer*):'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多标准的插件初始化器。如果您的插件希望被它们调用，它必须实现具有回调方法的特定接口（有关详细信息，请参阅 *k8s.io/apiserver/pkg/admission/initializer*）：
- en: '[PRE58]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Implement some of these and the plug-in gets called during launch, in order
    to get access to, say, Kubernetes resources or the API server global scheme.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 实现其中一些插件，插件在启动期间被调用，以获取访问 Kubernetes 资源或 API 服务器全局架构的权限。
- en: 'In addition, the `admission.InitializationValidator` interface is supposed
    to be implemented to do a final check that the plug-in is properly set up:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，预期要实现 `admission.InitializationValidator` 接口以进行最终检查，确保插件已正确设置：
- en: '[PRE59]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Standard initializers are great, but we need access to the toppings informer.
    So, let’s look at how to add our own initializers. An initializer consists of:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 标准初始化器很好用，但我们需要访问配料 informer。因此，让我们看看如何添加我们自己的初始化器。一个初始化器由以下组成：
- en: 'A `Wants*` interface (e.g., `WantsRestaurantInformerFactory`), which should
    be implemented by an admission plug-in:'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wants*` 接口（例如 `WantsRestaurantInformerFactory`），应由 Admission 插件实现：'
- en: '[PRE60]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The initializer struct, implementing `admission.PluginInitializer`:'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化器结构体，实现 `admission.PluginInitializer`：
- en: '[PRE61]'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In other words, the `Initialize()` method checks that the passed plug-in implements
    the corresponding custom initializer `Wants*` interface. If that is the case,
    the initializer will call the method on the plug-in.
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 换句话说，`Initialize()` 方法检查传递的插件是否实现了相应的自定义初始化器 `Wants*` 接口。如果是这样，初始化器将在插件上调用该方法。
- en: 'Plumbing of the initializer constructor into `RecommendedOptions.Extra\AdmissionInitializers`
    (see [“Options and Config Pattern and Startup Plumbing”](#aggregated-apiserver-development-options-config)):'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将初始化器构造函数连接到 `RecommendedOptions.Extra\AdmissionInitializers`（参见[“选项和配置模式以及启动配置”](#aggregated-apiserver-development-options-config)）的管道资源：
- en: '[PRE62]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This code creates a loopback client for the restaurant API group, creates a
    corresponding informer factory, stores it in the options `o`, and returns a plug-in
    initializer for it.
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码为餐厅 API 组创建了一个环回客户端，创建了相应的 informer 工厂，将其存储在选项 `o` 中，并返回了一个用于它的插件初始化器。
- en: As promised, admission is the last step in the implementation to complete our
    custom API server for the restaurant API group. Now we want to see it in action,
    but not artificially on the local machine, but rather in a real Kubernetes cluster.
    This means we have to take a look at the deployment of an aggregated custom API
    server.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如约，Admission 是实现完成餐厅 API 组自定义 API 服务器的最后一步。现在我们希望看到它在实际 Kubernetes 集群中的运行情况，而不是在本地机器上人为地模拟。这意味着我们必须看一下聚合的自定义
    API 服务器的部署。
- en: Deploying Custom API Servers
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署自定义 API 服务器
- en: 'In [“API Services”](#aggregation-apiservices), we saw the `APIService` object,
    which is used to register the custom API server API group versions with the aggregator
    inside the Kubernetes API server:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“API 服务”](#aggregation-apiservices)中，我们看到了 `APIService` 对象，用于将自定义 API 服务器的
    API 组版本注册到 Kubernetes API 服务器内部的聚合器中：
- en: '[PRE63]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The `APIService` object points to a service. Usually, this service will be
    a normal cluster IP service: that is, the custom API server is deployed into the
    cluster using pods. The service forwards the requests to the pods.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIService` 对象指向一个服务。通常，这个服务将是一个普通的集群 IP 服务：也就是说，自定义 API 服务器部署在集群中，使用 pods。该服务将请求转发到
    pods。'
- en: Let’s look at the Kubernetes manifest to implement this.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Kubernetes 清单以实现这一点。
- en: Deployment Manifests
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署清单
- en: 'We have the following manifests (found in [the example code on GitHub](http://bit.ly/2J6CVIz))
    that will be part of an in-cluster deployment of a custom API service:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下清单（在[GitHub 上的示例代码](http://bit.ly/2J6CVIz)找到），它们将成为自定义 API 服务的集群内部部署的一部分：
- en: 'An `APIService` for both versions `v1alpha1`:'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `APIService` 适用于版本 `v1alpha1`：
- en: '[PRE64]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '…and `v1beta1`:'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: …和 `v1beta1`：
- en: '[PRE65]'
  id: totrans-485
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note here that we set `insecureSkipTLSVerify`. This is OK for development but
    inadequate for any production deployment. We’ll see how to fix this in [“Certificates
    and Trust”](#aggregated-apiserver-certs).
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这里我们设置了 `insecureSkipTLSVerify`。这对开发来说是可以接受的，但对于任何生产部署来说都不够。我们将看到如何在 [“证书和信任”](#aggregated-apiserver-certs)
    中修复这个问题。
- en: 'A `Service` in front of the custom API server instances running in the cluster:'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在集群中运行的自定义 API 服务器实例前面的 `Service`：
- en: '[PRE66]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A `Deployment` (as shown here) or `DaemonSet` for the custom API server pods:'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `Deployment`（如此所示）或者 `DaemonSet` 用于自定义 API 服务器的 pod：
- en: '[PRE67]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A namespace for the service and the deployment to live in:'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于服务和部署的命名空间：
- en: '[PRE68]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Often, the aggregated API server is deployed to some nodes reserved for control
    plane pods, usually called *masters*. In that case, a `DaemonSet` is a good choice
    to run one custom API server instance per master node. This leads to a high availability
    setup. Note, that API servers are stateless, which means they can easily be deployed
    multiple times and no leader election is necessary.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，聚合 API 服务器部署在一些专门用于控制平面 pod 的节点上，通常称为 *masters*。在这种情况下，使用 `DaemonSet`
    在每个主节点上运行一个自定义 API 服务器实例是个不错的选择。这样可以实现高可用设置。请注意，API 服务器是无状态的，这意味着它们可以轻松地部署多次，而不需要领导选举。
- en: 'With these manifests, we are nearly done. As is so often the case, though,
    a secure deployment needs some more thought. You might have noticed that the pods
    (defined via the preceding deployment) use a custom service account, `apiserver`.
    This can be created via another manifest:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些清单，我们几乎完成了。但通常情况下，安全部署还需要更多的思考。您可能已经注意到，通过前面部署定义的 pod 使用了一个自定义服务账号 `apiserver`。这可以通过另一个清单创建：
- en: '[PRE69]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This service account needs a number of permissions, which we can add via RBAC
    objects.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务账号需要一些权限，我们可以通过 RBAC 对象添加。
- en: Setting Up RBAC
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 RBAC
- en: 'The service account of an API service first needs some generic permissions
    to participate in:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: API 服务的服务账号首先需要一些通用权限来参与：
- en: namespace lifecycle
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的生命周期
- en: Objects can be created only in an existing namespace, and are deleted when the
    namespace is deleted. For this the API server has to get, list, and watch namespaces.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 只能在现有的命名空间中创建对象，并且在删除命名空间时会删除这些对象。为此，API 服务器必须获取、列出和监视命名空间。
- en: admission webhooks
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 准入 webhook
- en: Admission webhooks configured via `MutatingWebhookConfigurations` and `ValidatedWebhookConfigurations`
    are called from each API server independently. For this the admission mechanism
    in our custom API server has to get, list, and watch these resources.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `MutatingWebhookConfigurations` 和 `ValidatedWebhookConfigurations` 配置的准入
    webhook 从每个 API 服务器独立调用。为此，我们的自定义 API 服务器的准入机制必须获取、列出和监视这些资源。
- en: 'We configure both by creating an RBAC cluster role:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建 RBAC 集群角色来配置两者：
- en: '[PRE70]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'and binding it to our service account `apiserver` via a `ClusterRoleBinding`:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 并通过 `ClusterRoleBinding` 将其绑定到我们的服务账号 `apiserver`：
- en: '[PRE71]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For delegated authentication and authorization, the service account has to
    be bound to the preexisting RBAC role `extension-apiserver-authentication-reader`:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 对于委托的身份验证和授权，服务账号必须绑定到预先存在的 RBAC 角色 `extension-apiserver-authentication-reader`：
- en: '[PRE72]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'and the preexisting RBAC cluster role `system:auth-delegator`:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 还有预先存在的 RBAC 集群角色 `system:auth-delegator`：
- en: '[PRE73]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Running the Custom API Server Insecurely
  id: totrans-511
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不安全地运行自定义 API 服务器
- en: Now with all manifests in place and RBAC set up, let’s deploy the API server
    to a real cluster.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有清单都已就绪并且 RBAC 已设置好，让我们将 API 服务器部署到真实的集群中。
- en: 'From a checkout of [the GitHub repository](http://bit.ly/2x9C3gR), and with
    configured `kubectl` with `cluster-admin` privileges (this is needed because RBAC
    rules can never escalate access):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [GitHub 仓库的检出](http://bit.ly/2x9C3gR)，并使用具有 `cluster-admin` 权限配置的 `kubectl`（因为
    RBAC 规则永远不会升级访问权限）：
- en: '[PRE74]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now the custom API server is launching:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在自定义 API 服务器正在启动：
- en: '[PRE75]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'When it is running, we double-check that the Kubernetes API server does aggregation
    (i.e., proxying of requests). First check via `APIService`s whether the Kubernetes
    API server thinks that our custom API server is available:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行时，我们会再次检查 Kubernetes API 服务器是否正在聚合（即请求代理）。首先通过 `APIService` 检查 Kubernetes
    API 服务器是否认为我们的自定义 API 服务器可用：
- en: '[PRE76]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This looks good. Let’s try to list pizzas, with logging enabled to see whether
    something goes wrong:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错。让我们尝试列出披萨，启用日志记录以查看是否有什么问题：
- en: '[PRE77]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This looks very good. We see that `kubectl` queries the discovery information
    to find out what a pizza is. It queries the *restaurant.programming-kubernetes.info/v1beta1*
    API to list the pizzas. Unsurprisingly, there aren’t any yet. But we can of course
    change that:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常不错。我们看到`kubectl`查询发现信息以找出披萨是什么。它查询*restaurant.programming-kubernetes.info/v1beta1*
    API来列出披萨。毫不奇怪，目前还没有。但我们当然可以改变这一点：
- en: '[PRE78]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This looks awesome. But the margherita pizza was easy. Let’s try defaulting
    in action by creating an empty pizza that does not list any toppings:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很棒。但玛格丽特披萨很简单。让我们通过创建一个不列出任何配料的空披萨来尝试默认值的效果：
- en: '[PRE79]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Our defaulting should turn this into a salami pizza with a salami topping.
    Let’s try:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的默认值应将其转换为一款意大利辣香肠披萨。让我们试试：
- en: '[PRE80]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This looks like a delicious salami pizza.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像是一款美味的意大利辣香肠披萨。
- en: 'Now let’s check whether our custom admission plug-in is working. We first delete
    all pizzas and toppings, and then try to re-create the pizzas:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查我们的自定义准入插件是否正常工作。我们首先删除所有披萨和配料，然后尝试重新创建披萨：
- en: '[PRE81]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: No margherita without mozzarella, like in any good Italian restaurant.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 没有马格丽塔披萨，没有马苏里拉奶酪，就像在任何一家好的意大利餐厅里一样。
- en: 'Looks like we are done implementing what we described in [“Example: A Pizza
    Restaurant”](#aggregation-example). But not quite. Security. Again. We have not
    taken care of the proper certificates. A malicious pizza seller could try to get
    between our users and the custom API server because the Kubernetes API server
    just accepts any serving certificates without checking them. Let’s fix this.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们已经完成了在[“示例：一家披萨餐厅”](#aggregation-example)中描述的实现。但还不完全。安全性。再次。我们还没有处理适当的证书。一个恶意的披萨销售商可能会试图在我们的用户和自定义API服务器之间插入。因为Kubernetes
    API服务器只接受任何服务证书而不进行检查。让我们解决这个问题。
- en: Certificates and Trust
  id: totrans-532
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 证书和信任
- en: The `APIService` object contains the `caBundle` field. This configures how the
    aggregator (inside the Kubernetes API server) trusts the custom API server. This
    CA bundle contains the certificate (and intermediate certificates) used to verify
    that the aggregated API server has the identity it claims to have. For any serious
    deployment, put the corresponding CA bundle into this field.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIService`对象包含`caBundle`字段。这配置了聚合器（在Kubernetes API服务器内部）信任自定义API服务器的方式。这个CA捆绑包含用于验证聚合API服务器是否具有其所声明的身份的证书（和中间证书）。对于任何严肃的部署，请将相应的CA捆绑包放入此字段中。'
- en: Warning
  id: totrans-534
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While `insecureSkipTLSVerify` is allowed in an `APIService` in order to disable
    certification verification, it is a bad idea to use this in a production setup.
    The Kubernetes API server sends requests to a trusted aggregated API server. Setting
    `insecureSkipTLSVerify` to `true` means that any other actor can claim to be the
    aggregated API server. This is obviously insecure and should not be used in production
    environments.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在`APIService`中允许`insecureSkipTLSVerify`以禁用证书验证，但在生产设置中使用这个方法是个坏主意。Kubernetes
    API服务器将请求发送到受信任的聚合API服务器。将`insecureSkipTLSVerify`设置为`true`意味着任何其他参与者都可以声称自己是聚合API服务器。这显然是不安全的，不应在生产环境中使用。
- en: The reverse trust from the custom API server to the Kubernetes API server, and
    its preauthentication of requests, is described in [“Delegated Authentication
    and Trust”](#aggregated-authentication). We don’t have to do anything extra.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 自定API服务器到Kubernetes API服务器的逆信任及其请求的预身份验证在[“委托认证和信任”](#aggregated-authentication)中有描述。我们不必做任何额外的事情。
- en: 'Back to the pizza example: to make it secure, we need a serving certificate
    and a key for the custom API server in the deployment. We put both into a `serving-cert`
    secret and mount it into the pod at */var/run/apiserver/serving-cert/tls.{crt,key}*.
    Then we use the *tls.crt* file as CA in the `APIService`. This can all be found
    in [the example code on GitHub](http://bit.ly/2XxtJWP).'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 回到披萨的例子：要使其安全，我们需要一个自定义API服务器部署中的服务证书和密钥。我们将两者放入`serving-cert`秘密，并将其挂载到*/var/run/apiserver/serving-cert/tls.{crt,key}*的容器中。然后我们使用*tls.crt*文件作为`APIService`中的CA。所有这些都可以在[GitHub上的示例代码](http://bit.ly/2XxtJWP)中找到。
- en: The certificate-generation logic is scripted in a [Makefile](http://bit.ly/2KGn0nw).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 证书生成逻辑在[Makefile](http://bit.ly/2KGn0nw)中编写。
- en: Note that in a real-world scenario we’d probably have some kind of cluster or
    company CA we can plug into the `APIService`.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在实际场景中，我们可能会有某种类型的集群或公司CA可以插入`APIService`中。
- en: 'To see it in action, either start with a new cluster or just reuse the previous
    one and apply the new, secure manifests:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看其运行情况，可以从新的集群开始，或者只需重用以前的集群并应用新的安全清单：
- en: '[PRE82]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note here the correct common name `CN=api.pizza-apiserver.svc` in the certificate.
    The Kubernetes API server proxies the request to the *api/pizza-apiserver* service
    and hence its DNS name must be put into the certificate.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意证书中正确的通用名称 `CN=api.pizza-apiserver.svc`。Kubernetes API 服务器将请求代理到 *api/pizza-apiserver*
    服务，因此其 DNS 名称必须放入证书中。
- en: 'We double-check that we really have disabled the `insecureSkipTLSVerify` flag
    in the `APIService`:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次检查，确实已禁用了 `APIService` 中的 `insecureSkipTLSVerify` 标志：
- en: '[PRE83]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This looks as expected: `insecureSkipTLSVerify` is gone and the `caBundle`
    field is filled with a base64 value of our certificate And: the service is still
    available.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来如预期：`insecureSkipTLSVerify` 已经消失，并且 `caBundle` 字段填写了我们证书的 base64 值。而且：服务仍然可用。
- en: 'Now let’s see whether `kubectl` can still query the API:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `kubectl` 是否仍然可以查询 API：
- en: '[PRE84]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The margherita pizza is back. This time it is perfectly secured. No chance for
    a malicious pizza seller to start a man-in-the-middle attack. Buon appetito!
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: margherita 披萨回来了。这次它完全安全了。恶意披萨销售者无法发动中间人攻击。享受您的美食！
- en: Sharing etcd
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享 `etcd`
- en: Aggregated API servers using the `RecommendOptions` (see [“Options and Config
    Pattern and Startup Plumbing”](#aggregated-apiserver-development-options-config))
    use `etcd` for storage. This means that any deployment of a custom API server
    requires an `etcd` cluster to be available.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `RecommendOptions`（参见 [“Options and Config Pattern and Startup Plumbing”](#aggregated-apiserver-development-options-config)）的聚合
    API 服务器使用 `etcd` 进行存储。这意味着任何自定义 API 服务器的部署都需要可用的 `etcd` 集群。
- en: This cluster can be in-cluster—for example, deployed using the [`etcd` operator](http://bit.ly/2JTz8SK).
    This operator allows us to launch and administrate an `etcd` cluster in a declarative
    way. The operator will do updates, up and down scaling, and backup. This reduces
    the operational overhead a lot.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 该集群可以是集群内部的——例如，使用 [`etcd` operator](http://bit.ly/2JTz8SK) 部署。此操作者允许我们以声明性方式启动和管理
    `etcd` 集群。操作者将进行更新、扩展和备份操作。这大大减少了运维开销。
- en: 'Alternatively, the `etcd` of the cluster control plane (i.e., that of `kube-apiserver`)
    can be used. Depending on the environment—self-deployed, on-premise, or hosted
    services like Google Container Engine (GKE)—this might be viable, or it might
    be impossible because the user has no access to the cluster at all (as is the
    case with GKE). In the viable cases, the custom API server has to use a key path
    that is distinct from the one used by the Kubernetes API server or other `etcd`
    consumers. In our example custom API server, it looks like this:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用集群控制平面的 `etcd`（即 `kube-apiserver` 的 `etcd`）。根据环境——自部署、本地部署或像 Google 容器引擎（GKE）这样的托管服务——这可能是可行的，或者可能完全不可能，因为用户根本无法访问集群（如
    GKE 的情况）。在可行的情况下，自定义 API 服务器必须使用与 Kubernetes API 服务器或其他 `etcd` 消费者不同的键路径。在我们的示例自定义
    API 服务器中，看起来是这样的：
- en: '[PRE85]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: This `etcd` path prefix is different from Kubernetes API server paths, which
    use different group API names.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 此 `etcd` 路径前缀与使用不同组 API 名称的 Kubernetes API 服务器路径不同。
- en: Last but not least, `etcd` can be proxied. The project [etcdproxy-controller](http://bit.ly/2Na2VrN)
    implements this mechanism using the operator pattern; that is, `etcd` proxies
    can be deployed automatically to the cluster and configured using `EtcdProxy`
    objects.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要，`etcd` 可以进行代理。项目 [etcdproxy-controller](http://bit.ly/2Na2VrN) 利用操作者模式实现了这一机制；也就是说，`etcd`
    代理可以自动部署到集群，并通过 `EtcdProxy` 对象进行配置。
- en: The `etcd` proxies will automatically do key mapping, so it is guaranteed that
    `etcd` key prefixes will not conflict. This allows us to share `etcd` clusters
    for multiple aggregated API servers without worrying that one aggregated API server
    reads or changes the data of another one. This will improve security in an environment
    where shared `etcd` clusters are required, for example, due to resource constraints
    or to avoid operational overhead.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '`etcd` 代理将自动执行键映射，因此保证 `etcd` 键前缀不会冲突。这使我们能够为多个聚合 API 服务器共享 `etcd` 集群，而无需担心一个聚合
    API 服务器读取或更改另一个的数据。在需要共享 `etcd` 集群的环境中（例如由于资源限制或为了避免运维开销），这将提高安全性。'
- en: Depending on the context, one of these options must be chosen. Finally, aggregated
    API servers can of course also use other storage backends, at least in theory,
    as it requires a lot of custom code to implement the *k8s.io/apiserver* storage
    interfaces.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 根据上下文，必须选择其中之一的选项。最后，聚合 API 服务器当然也可以使用其他存储后端，至少在理论上是可以的，因为需要大量自定义代码来实现 *k8s.io/apiserver*
    存储接口。
- en: Summary
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a pretty large chapter, and you made it to the end. You’ve gotten a
    lot of background about APIs in Kubernetes and how they are implemented.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章相当大的内容，你已经看到了结尾。你对 Kubernetes 中的 API 有了很多背景知识，以及它们是如何实现的。
- en: We saw how aggregation of custom API servers fits into the architecture of a
    Kubernetes cluster. We saw how a custom API server receives requests that are
    proxies from the Kubernetes API server. We have seen how the Kubernetes API server
    preauthenticates these requests, and how API groups are implemented, with external
    versions and internal versions. We learned how objects are decoded into the Golang
    structs, how they are defaulted, how they are converted to internal types, and
    how they go through admission and validation and finally reach the registry. We
    saw how a strategy is plugged into a generic registry to implement “normal” Kubernetes-like
    REST resources, how we can add custom admissions, and how to configure a custom
    admission plug-in with a custom initializer. We now know how to do all the plumbing
    to start up a custom API server with a multiversion API group, and how to deploy
    the API group in a cluster with `APIServices`. We saw how to configure RBAC rules
    to allow the custom API server to do its job. We discussed how `kubectl` queries
    API groups. Finally, we learned how to secure the connection to our custom API
    server with certificates.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到自定义 API 服务器如何适配到 Kubernetes 集群的架构中。我们看到自定义 API 服务器如何接收来自 Kubernetes API
    服务器的代理请求。我们看到 Kubernetes API 服务器如何预认证这些请求，以及如何实现 API 组，包括外部版本和内部版本。我们学习了如何将对象解码为
    Golang 结构体，如何设置默认值，如何转换为内部类型，以及如何经历准入和验证，最终到达注册表。我们看到了如何将策略插入到通用注册表中来实现类似 Kubernetes
    的“正常” REST 资源，以及如何添加自定义准入，并如何使用自定义初始化器配置自定义准入插件。现在我们知道如何进行所有的管道配置来启动一个带有多版本 API
    组的自定义 API 服务器，以及如何使用 `APIServices` 在集群中部署 API 组。我们看到了如何配置 RBAC 规则以允许自定义 API 服务器执行其工作。我们讨论了
    `kubectl` 如何查询 API 组。最后，我们学习了如何使用证书来保护与自定义 API 服务器的连接。
- en: 'This was a lot. Now you have a much better understanding of what APIs are in
    Kubernetes and how they are implemented, and hopefully you are motivated to do
    one or more of the following:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多内容。现在你对 Kubernetes 中的 API 以及它们是如何实现的有了更好的理解，希望你能够有动力去做以下一项或多项：
- en: Implement your own custom API server
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现您自己的自定义 API 服务器
- en: Learn about the inner workings of Kubernetes
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 Kubernetes 的内部工作原理
- en: Contribute to Kubernetes in the future
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来为 Kubernetes 做贡献
- en: We hope that you have found this a good starting point.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望你觉得这是一个很好的起点。
- en: ^([1](ch08.html#idm46336853170760-marker)) Graceful deletion means that the
    client can pass a graceful deletion period as part of the deletion call. The actual
    deletion is done by a controller asynchronously (the `kubelet` does that for pods)
    by doing a forced deletion. This way pods have time to cleanly shut down.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#idm46336853170760-marker)) 优雅删除意味着客户端可以在删除调用中传递一个优雅删除期间。实际的删除由控制器异步完成（例如
    `kubelet` 用于 Pod），通过强制删除。这样可以让 Pod 有时间干净地关闭。
- en: ^([2](ch08.html#idm46336853165528-marker)) Kubernetes uses cohabitation to migrate
    resources (e.g., deployments from the `extensions/v1beta1` API group) to subject-specific
    API groups (e.g., `apps/v1`). CRDs have no concept of shared storage.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#idm46336853165528-marker)) Kubernetes 使用共存来迁移资源（例如，从 `extensions/v1beta1`
    API 组迁移到特定主题的 API 组（例如 `apps/v1`）。CRD 没有共享存储的概念。
- en: ^([3](ch08.html#idm46336853099640-marker)) We’ll see in [Chapter 9](ch09.html#ch_advanced-topics)
    that CRD conversion and admission webhooks available in the latest Kubernetes
    versions also allow us to add these features to CRDs.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#idm46336853099640-marker)) 我们将在 [第9章](ch09.html#ch_advanced-topics)
    中看到，在最新的 Kubernetes 版本中可用的 CRD 转换和准入 Webhook 也允许我们向 CRD 添加这些功能。
- en: ^([4](ch08.html#idm46336852602264-marker)) PaaS stands for Platform as a Service.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.html#idm46336852602264-marker)) PaaS 指的是平台即服务。
