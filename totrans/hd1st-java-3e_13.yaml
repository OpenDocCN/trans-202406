- en: 'Chapter 10\. Numbers Matter: Numbers and Statics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0275-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: '**Do the Math.** But there’s more to working with numbers than just doing primitive
    arithmetic. You might want to get the absolute value of a number, or round a number,
    or find the larger of two numbers. You might want your numbers to print with exactly
    two decimal places, or you might want to put commas into your large numbers to
    make them easier to read. And what about parsing a String into a number? Or turning
    a number into a String? Someday you’re gonna want to put a bunch of numbers into
    a collection like ArrayList that takes only objects. You’re in luck. Java and
    the Java API are full of handy number-tweaking capabilities and methods, ready
    and easy to use. But most of them are **static**, so we’ll start by learning what
    it means for a variable or method to be static, including constants in Java, also
    known as static *final* variables.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'MATH methods: as close as you’ll ever get to a *global* method'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Except there’s no global *anything* in Java. But think about this: what if
    you have a method whose behavior doesn’t depend on an instance variable value.
    Take the round() method in the Math class, for example. It does the same thing
    every time—rounds a floating-point number (the argument to the method) to the
    nearest integer. Every time. If you had 10,000 instances of class Math, and ran
    the round(42.2) method, you’d get an integer value of 42\. Every time. In other
    words, the method acts on the argument but is never affected by an instance variable
    state. The only value that changes the way the round() method runs is the argument
    passed to the method!'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Doesn’t it seem like a waste of perfectly good heap space to make an instance
    of class Math simply to run the round() method? And what about *other* Math methods
    like min(), which takes two numerical primitives and returns the smaller of the
    two? Or max(). Or abs(), which returns the absolute value of a number.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '***These methods never use instance variable values***. In fact, the Math class
    doesn’t *have* any instance variables. So there’s nothing to be gained by making
    an instance of class Math. So guess what? You don’t have to. As a matter of fact,
    you can’t.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**If you try to make an instance of class Math:**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**You’ll get this error:**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0276-02.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Methods in the Math class don’t use any instance variable values. And because
    the methods are “static,” you don’t need to have an instance of Math. All you
    need is the Math class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0276-01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: The difference between regular (non-static) and static methods
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java is object-oriented, but once in a while you have a special case, typically
    a utility method (like the Math methods), where there is no need to have an instance
    of the class. The keyword **`static`** lets a method run ***without any instance
    of the class***. A static method means “behavior not dependent on an instance
    variable, so no instance/object is required. Just the class.”
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0277-01.png)![image](Images/f0278-01.png)![image](Images/f0278-02.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: What it means to have a class with static methods
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often (although not always), a class with static methods is not meant to be
    instantiated. In [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst),
    *Serious Polymorphism*, we talked about abstract classes, and how marking a class
    with the **`abstract`** modifier makes it impossible for anyone to say “new” on
    that class type. In other words, ***it’s impossible to instantiate an abstract
    class.***
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: But you can restrict other code from instantiating a *non*-abstract class by
    marking the constructor **`private`**. Remember, a *method* marked private means
    that only code from within the class can invoke the method. A *constructor* marked
    private means essentially the same thing—only code from within the class can invoke
    the constructor. Nobody can say “new” from *outside* the class. That’s how it
    works with the Math class, for example. The constructor is private; you cannot
    make a new instance of Math. The compiler knows that your code doesn’t have access
    to that private constructor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: This does *not* mean that a class with one or more static methods should never
    be instantiated. In fact, every class you put a main() method in is a class with
    a static method in it!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Typically, you make a main() method so that you can launch or test another class,
    nearly always by instantiating a class in main and then invoking a method on that
    new instance.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: So you’re free to combine static and non-static methods in a class, although
    even a single non-static method means there must be *some* way to make an instance
    of the class. The only ways to get a new object are through “new” or deserialization
    (or something called the Java Reflection API that we don’t go into). No other
    way. But exactly *who* says new can be an interesting question, and one we’ll
    look at a little later in this chapter.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Static methods can’t use non-static (instance) variables!
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static methods run without knowing about any particular instance of the static
    method’s class. And as you saw on the previous pages, there might not even *be*
    any instances of that class. Since a static method is called using the *class*
    (***Math***.random()) as opposed to an *instance reference* (***t2***.play()),
    a static method can’t refer to any instance variables of the class. The static
    method doesn’t know *which* instance’s variable value to use.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '**If you try to compile this code:**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0279-01.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: '**You’ll get this error:**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0279-02.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you try to use an instance variable from inside a static method, the compiler
    thinks, “I don’t know which object’s instance variable you’re talking about!”
    If you have ten Duck objects on the heap, a static method doesn’t know about any
    of them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0279-03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Static methods can’t use non-static methods, either!
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do non-static methods do? ***They usually use instance variable state to
    affect the behavior of the method.*** A getName() method returns the value of
    the name variable. Whose name? The object used to invoke the getName() method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**This won’t compile:**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0280-01.png)![image](Images/f0280-02.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Static variable: value is the same for ALL instances of the class'
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you wanted to count how many Duck instances are being created while
    your program is running. How would you do it? Maybe an instance variable that
    you increment in the constructor?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0281-01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: No, that wouldn’t work because duckCount is an instance variable, and starts
    at 0 for each Duck. You could try calling a method in some other class, but that’s
    kludgey. You need a class that’s got only a single copy of the variable, and all
    instances share that one copy.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s what a static variable gives you: a value shared by all instances of
    a class. In other words, one value per *class*, instead of one value per *instance*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0281-02.png)![image](Images/f0281-03.png)![image](Images/f0282-01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: '**Static variables are shared.**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '**All instances of the same class share a single copy of the static variables.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'instance variables: 1 per **instance**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'static variables: 1 per **class**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Initializing a static variable
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static variables are initialized when a *class is loaded*. A class is loaded
    because the JVM decides it’s time to load it. Typically, the JVM loads a class
    because somebody’s trying to make a new instance of the class, for the first time,
    or use a static method or variable of the class. As a programmer, you also have
    the option of telling the JVM to load a class, but you’re not likely to need to
    do that. In nearly all cases, you’re better off letting the JVM decide when to
    *load* the class.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'And there are two guarantees about static initialization:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Static variables in a class are initialized before any *object* of that class
    can be created.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static variables in a class are initialized before any *static method* of the
    class runs.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0283-01.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: If you don’t explicitly initialize a static variable (by assigning it a value
    at the time you declare it), it gets a default value, so int variables are initialized
    to zero, which means we didn’t need to explicitly say playerCount = 0\. Declaring,
    but not initializing, a static variable means the static variable will get the
    default value for that variable type, in exactly the same way that instance variables
    are given default values when declared.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0283-02.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: static final variables are constants
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable marked **`final`** means that—once initialized—it can never change.
    In other words, the value of the static final variable will stay the same as long
    as the class is loaded. Look up Math.PI in the API, and you’ll find:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The variable is marked **`public`** so that any code can access it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: The variable is marked **`static`** so that you don’t need an instance of class
    Math (which, remember, you’re not allowed to create).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: The variable is marked **`final`** because PI doesn’t change (as far as Java
    is concerned).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: There is no other way to designate a variable as a constant, but there is a
    naming convention that helps you to recognize one. ***Constant variable names
    are usually in all caps!***
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialize a *final* static variable:**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **At the time you declare it:**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0284-01.png)'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**OR**'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **In a static initializer:**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0284-02.png)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**If you don’t give a value to a final variable in one of those two places:**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0284-03.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: '**The compiler will catch it:**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0284-04.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: final isn’t just for static variables...
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the keyword **`final`** to modify non-static variables too, including
    instance variables, local variables, and even method parameters. In each case,
    it means the same thing: the value can’t be changed. But you can also use final
    to stop someone from overriding a method or making a subclass.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**non-static final variables**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0285-01.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: '**final method**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**final class**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**A final variable means you can’t change its value.**'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A final method means you can’t override the method.**'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**A final class means you can’ extend the class (i.e., you can’t make a subclass).**'
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![image](Images/f0285-03.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [“Sharpen your pencil”](#sharpen_your_pencil_left_parenthesisfrom).**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Math methods
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know how static methods work, let’s look at some static methods
    in class Math. This isn’t all of them, just the highlights. Check your API for
    the rest including cos(), sin(), tan(), ceil(), floor(), and asin().
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0288-01.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: '**Math.abs()**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Returns a double that is the absolute value of the argument. The method is overloaded,
    so if you pass it an int, it returns an int. Pass it a double, it returns a double.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Math.random()**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Returns a double between (and including) 0.0 through (but not including) 1.0.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ve been using this method so far, but there’s also java.util.Random, which
    is a bit nicer to use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Math.round()**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Returns an int or a long (depending on whether the argument is a float or a
    double) rounded to the nearest integer value.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0289-01.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: '**Math.min()**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Returns a value that is the minimum of the two arguments. The method is overloaded
    to take ints, longs, floats, or doubles.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Math.max()**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Returns a value that is the maximum of the two arguments. The method is overloaded
    to take ints, longs, floats, or doubles.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Math.sqrt()**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Returns the positive square root of the argument. The method takes a double,
    but of course you can pass in anything that fits in a double.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Wrapping a primitive
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you want to treat a primitive like an object. For example, collections
    like ArrayList only work with Objects:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0290-01.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
- en: There’s a wrapper class for every primitive type, and since the wrapper classes
    are in the java.lang package, you don’t need to import them. You can recognize
    wrapper classes because each one is named after the primitive type it wraps, but
    with the first letter capitalized to follow the class naming convention.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh yeah, for reasons absolutely nobody on the planet is certain of, the API
    designers decided not to map the names *exactly* from primitive type to class
    type. You’ll see what we mean:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0290-02.png)![image](Images/f0290-03.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you need to treat a primitive like an object, wrap it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0290-04.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: 'Note: the picture at the top is a chocolate in a foil wrapper. Get it? Wrapper?
    Some people think it looks like a baked potato, but that works too.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0291-01.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Java will Autobox primitives for you
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In The Olden Days (pre–Java 5), we did have to do all this ourselves, manually
    wrapping and unwrapping primitives. Fortunately, now it’s all done for us *automatically*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens when we want to make an ArrayList to hold ints.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**An ArrayList of primitive ints**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0291-02.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Autoboxing works almost everywhere
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Autoboxing lets you do more than just the obvious wrapping and unwrapping to
    use primitives in a collection...it also lets you use either a primitive or its
    wrapper type virtually anywhere one or the other is expected. Think about that!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**Fun with autoboxing**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method arguments** If a method takes a wrapper type, you can pass a reference
    to a wrapper or a primitive of the matching type. And of course the reverse is
    true—if a method takes a primitive, you can pass in either a compatible primitive
    or a reference to a wrapper of that primitive type. | ![image](Images/f0292-01.png)
    |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| **Return values** If a method declares a primitive return type, you can return
    either a compatible primitive or a reference to the wrapper of that primitive
    type. And if a method declares a wrapper return type, you can return either a
    reference to the wrapper type or a primitive of the matching type. | ![image](Images/f0292-02.png)
    |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| **Boolean expressions** Any place a boolean value is expected, you can use
    either an expression that evaluates to a boolean (4 > 2), a primitive boolean,
    or a reference to a Boolean wrapper. | ![image](Images/f0292-03.png) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| **Operations on numbers** This is probably the strangest one—yes, you can
    use a wrapper type as an operand in operations where the primitive type is expected.
    That means you can apply, say, the increment operator against a reference to an
    Integer object!'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: But don’t worry—this is just a compiler trick. The language wasn’t modified
    to make the operators work on objects; the compiler simply converts the object
    to its primitive type before the operation. It sure looks weird, though.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Integer i = new Integer(42); i++;
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'And that means you can also do things like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Integer j = new Integer(5); Integer k = j + 3; | ![image](Images/f0293-01.png)
    |
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '| **Assignments** You can assign either a wrapper or primitive to a variable
    declared as a matching wrapper or primitive. For example, a primitive int variable
    can be assigned to an Integer reference variable, and vice versa—a reference to
    an Integer object can be assigned to a variable declared as an int primitive.
    | ![image](Images/f0293-02.png) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '![Images](Images/arr.png) **Yours to solve.**'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: But wait! There’s more! Wrappers have static utility methods too!
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Besides acting like a normal class, the wrappers have a bunch of really useful
    static methods.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: For example, the *parse* methods take a String and give you back a primitive
    value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0294-01.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: '**Converting a String to a primitive value is easy:**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0294-02.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: '**But if you try to do this:**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0294-03.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: '**You’ll get a runtime exception:**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0294-04.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
- en: '**Every method or constructor that parses a String can throw a NumberFormatException****.
    It’s a runtime exception, so you don’t have to handle or declare it. But you might
    want to.**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: (We’ll talk about exceptions in [Chapter 13](ch13.xhtml#risky_behavior_exception_handling),
    *Risky Behavior*.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: And now in reverse...turning a primitive number into a String
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to turn a number into a String, for example when you want to show
    this number to a user or put it into a message. There are several ways to turn
    a number into a String. The easiest is to simply concatenate the number to an
    existing String.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0295-01.png)![image](Images/f0295-02.png)![image](Images/f0295-03.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: Number formatting
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, formatting numbers and dates doesn’t have to be coupled with I/O. Think
    about it. One of the most typical ways to display numbers to a user is through
    a GUI. You put Strings into a scrolling text area, or maybe a table. If formatting
    was built only into print statements, you’d never be able to format a number into
    a nice String to display in a GUI.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The Java API provides powerful and flexible formatting using the Formatter class
    in java.util. But often you don’t need to create and call methods on the Formatter
    class yourself, because the Java API has convenience methods in some of the I/O
    classes (including printf()) and the String class. So it can be a simple matter
    of calling a static String.format() method and passing it the thing you want formatted
    along with formatting instructions.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you do have to know how to supply the formatting instructions, and
    that takes a little effort unless you’re familiar with the ***printf()*** function
    in C/C++. Fortunately, even if you *don’t* know printf(), you can simply follow
    recipes for the most basic things (that we’re showing in this chapter). But you
    *will* want to learn how to format if you want to mix and match to get *anything*
    you want.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start here with a basic example and then look at how it works. (Note:
    we’ll revisit formatting again in [Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr),
    *Saving Objects*.)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '**Making big numbers more readable with underscores, a quick detour**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we get into formatting numbers, let’s take a small, useful detour. Sometimes
    you’ll want to declare variables with large initial values. Let’s look at three
    declarations that assign the same large value, a billion, to long primitives:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0296-01.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: '**Formatting a number to use commas**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0296-02.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: Formatting deconstructed...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the most basic level, formatting consists of two main parts (there is more,
    but we’ll start with this to keep it cleaner):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Formatting instructions**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use special format specifiers that describe how the argument should be formatted.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **The argument to be formatted.**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although there can be more than one argument, we’ll start with just one. The
    argument type can’t be just *anything*...it has to be something that can be formatted
    using the format specifiers in the formatting instructions. For example, if your
    formatting instructions specify a *floating-point number*, you can’t pass in a
    Dog or even a String that looks like a floating-point number.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0297-01.png)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**What do these instructions actually say?**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: “Take the second argument to this method, and format it as a **d**ecimal integer
    and insert **commas**.”
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**How do they say that?**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: On the next page we’ll look in more detail at what the syntax “%,d” actually
    means, but for starters, any time you see the percent sign (%) in a format String
    (which is always the first argument to a format() method), think of it as representing
    a variable, and the variable is the other argument to the method. The rest of
    the characters after the percent sign describe the formatting instructions for
    the argument.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note: if you already know printf() from c/C++, you can probably just skim the
    next few pages. Otherwise, read carefully!'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: The percent (%) says, “insert argument here” (and format it using these instructions)
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first argument to a format() method is called the format String, and it
    can actually include characters that you just want printed as-is, without extra
    formatting. When you see the % sign, though, think of the percent sign as a variable
    that represents the other argument to the method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0298-01.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: The “%” sign tells the formatter to insert the other method argument (the second
    argument to format(), the number) here, AND format it using the “.2f” characters
    after the percent sign. Then the rest of the format String, “bugs to fix,” is
    added to the final output.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**Adding a comma**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0298-02.png)![image](Images/f0299-01.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: The format String uses its own little language syntax
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You obviously can’t put just *anything* after the “%” sign. The syntax for what
    goes after the percent sign follows very specific rules, and describes how to
    format the argument that gets inserted at that point in the result (formatted)
    String.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve already seen some examples:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '**%,d** means “insert commas and format the number as a decimal integer.”'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: and
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '**%.2f** means “format the number as a floating point with a precision of two
    decimal places.”'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: and
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '**%,.2f** means “insert commas and format the number as a floating point with
    a precision of two decimal places.”'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Really the question is: “How do I know what to put after the percent sign to
    get it to do what I want?” And that includes knowing the symbols (like “d” for
    decimal and “f” for floating point) as well as the order in which the instructions
    must be placed following the percent sign. For example, if you put the comma after
    the “d” like “%d,” instead of “%,d” it won’t work!'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Or will it? What do you think this will do:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: (We’ll answer that on the next page.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The format specifier
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything after the percent sign up to and including the type indicator (like
    “d” or “f”) is part of the formatting instructions. After the type indicator,
    the formatter assumes the next set of characters is meant to be part of the output
    String, until or unless it hits another percent (%) sign. Hmmmm...is that even
    possible? Can you have more than one formatted argument variable? Put that thought
    on hold for right now; we’ll come back to it in a few minutes. For now, let’s
    look at the syntax for the format specifiers—the things that go after the percent
    (%) sign and describe how the argument should be formatted.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**A format specifier can have up to five different parts (not including the
    “%”). Everything in brackets [ ] below is optional, so only the percent (%) and
    the type are required. But the order is also mandatory, so any parts you DO use
    must go in this order.**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0300-01.png)![image](Images/f0300-02.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: The only required specifier is for TYPE
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although type is the only required specifier, remember that if you *do* put
    in anything else, type must always come last! There are more than a dozen different
    type modifiers (not including dates and times; they have their own set), but most
    of the time you’ll probably use %d (decimal) or %f (floating point). And typically
    you’ll combine %f with a precision indicator to set the number of decimal places
    you want in your output.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '**The TYPE is mandatory, everything else is optional.**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0301-01.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must include a type in your format instructions, and if you specify things
    besides type, the type must always come last. Most of the time, you’ll probably
    format numbers using either “d” for decimal or “f” for floating point.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: The argument must be a byte, short, char, or int (including both primitive and
    wrapper types).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: What happens if I have more than one argument?
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine you want a String that looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: “The rank is ***20,456,654*** out of ***100,567,890.24***.”
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: But the numbers are coming from variables. What do you do? You simply add *two*
    arguments after the format String (first argument), so that means your call to
    format() will have three arguments instead of two. And inside that first argument
    (the format String), you’ll have two different format specifiers (two things that
    start with “%”). The first format specifier will insert the second argument to
    the method, and the second format specifier will insert the third argument to
    the method. In other words, the variable insertions in the format String use the
    order in which the other arguments are passed into the format() method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0302-01.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: As you’ll see when we get to date formatting, you might actually want to apply
    different formatting specifiers to the same argument. That’s probably hard to
    imagine until you see how *date* formatting (as opposed to the *number* formatting
    we’ve been doing) works. Just know that in a minute, you’ll see how to be more
    specific about which format specifiers are applied to which arguments.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Just one more thing...static imports
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static imports are a real mixed blessing. Some people love this idea, some people
    hate it. Static imports exist to make your code a little shorter. If you hate
    to type or hate long lines of code, you might just like this feature. The downside
    to static imports is that—if you’re not careful—using them can make your code
    a lot harder to read.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that whenever you’re using a static class, a static variable,
    or an enum (more on those later), you can import them and save yourself some typing.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '**Without static imports:**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Same code, with static imports:**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0303-01.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Use carefully: Static imports can make your code confusing to read. Always
    re-read your code after using a static import and think: “Will I understand this
    in six months time?”'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Fireside Chats
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0304-01.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: 'Tonight’s Talk: **An instance variable takes cheap shots at a static variable**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '| Instance Variable | Static Variable |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
- en: '| I don’t even know why we’re doing this. Everyone knows static variables are
    just used for constants. And how many of those are there? I think the whole API
    must have, what, four? And it’s not like anybody ever uses them. |  |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
- en: '|  | You really should check your facts. When was the last time you looked
    at the API? It’s frickin’ loaded with statics! It even has entire classes dedicated
    to holding constant values. There’s a class called SwingConstants, for example,
    that’s just full of them. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
- en: '| Full of it. Yeah, you can say that again. OK, so there are a few in the Swing
    library, but everybody knows Swing is just a special case. |  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
- en: '|  | It might be a special case, but it’s a really important one! And what
    about the Color class? What a pain if you had to remember the RGB values to make
    the standard colors! But the color class already has constants defined for blue,
    purple, white, red, etc. Very handy. |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
- en: '| Ok, but besides a few GUI things, give me an example of just one static variable
    that anyone would actually use. In the real world. |  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
- en: '|  | How’s System.out for starters? The out in System.out is a static variable
    of the System class. You personally don’t make a new instance of the System; you
    just ask the System class for its out variable. |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
- en: '| Well, that’s another special case. And nobody uses that except for debugging
    anyway. |  |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '|  | Oh, like debugging isn’t important? And here’s something that probably
    never crossed your narrow mind—let’s face it, static variables are more efficient.
    One per class instead of one per instance. The memory savings might be huge! |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| Um, aren’t you forgetting something? |  |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '|  | What? |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| Static variables are about as un-OO as it gets!! Gee, why not just go take
    a giant backward step and do some procedural programming while we’re at it. |  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '|  | What do you mean *un-*OO? |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| You’re like a global variable, and any programmer worth their sticker-covered
    laptop knows that’s usually a Bad Thing. |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: '|  | I am NOT a global variable. There’s no such thing. I live in a class!
    That’s pretty OO you know, a CLASS. I’m not just sitting out there in space somewhere;
    I’m a natural part of the state of an object; the only difference is that I’m
    shared by all instances of a class. Very efficient. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
- en: '| Yeah, you live in a class, but they don’t call it *Class*-Oriented programming.
    That’s just stupid. You’re a relic. Something to help the old-timers make the
    leap to Java. |  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
- en: '|  | Alright just stop right there. THAT is definitely not true. Some static
    variables are absolutely crucial to a system. And even the ones that aren’t crucial
    sure are handy. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
- en: '| Well, OK, every once in a while sure, it makes sense to use a static, but
    let me tell you, abuse of static variables (and methods) is the mark of an immature
    OO programmer. A designer should be thinking about *object* state, not *class*
    state. |  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '|  | Why do you say that? And what’s wrong with static methods? |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| Static methods are the worst things of all, because it usually means the
    programmer is thinking procedurally instead of about objects doing things based
    on their unique object state. |  |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '|  | Sure, I know that objects should be the focus of an OO design, but just
    because there are some clueless programmers out there...don’t throw the baby out
    with the bytecode. There’s a time and place for statics, and when you need one,
    nothing else beats it. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| Riiiiiight. Whatever you need to tell yourself. |  |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: Exercise
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: BE the compiler
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0306-02.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: '**The Java file on this page represents a complete program. Your job is to
    play compiler and determine whether this file will compile. If it won’t compile,
    how would you fix it? When it runs, what would be its output?**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Which of these is the output?
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '**Possible Output**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0306-04.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: '**Possible Output**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0306-05.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [“BE the compiler”](#be_the_compiler_left_parenthesisfrom_pag).**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explored the wonderful, static world of Java. Your job is to decide
    whether each of the following statements is true or false.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: True or False
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/hand.png)![image](Images/hand1.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: To use the Math class, the first step is to make an instance of it.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can mark a constructor with the **`static`** keyword.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static methods don’t have access to instance variable state of the “this” object.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is good practice to call a static method using a reference variable.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Static variables could be used to count the instances of a class.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Constructors are called before static variables are initialized.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MAX_SIZE would be a good name for a static final variable.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A static initializer block runs before a class’s constructor runs.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a class is marked final, all of its methods must be marked final.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A final method can be overridden only if its class is extended.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There is no wrapper class for boolean primitives.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A wrapper is used when you want to treat a primitive like an object.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The parseXxx methods always return a String.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Formatting classes (which are decoupled from I/O) are in the java.format package.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](Images/arr.png) **Answers in [“True or False”](#true_or_false_left_parenthesisfr-id0002).**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solution
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sharpen your pencil
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00021))
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/pencil.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: 1, 4, 5, and 6 are legal.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 2 doesn’t compile because the static method references a non-static instance
    variable.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 3 doesn’t compile because the instance variable is final but hasn’t been initialized.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: BE the compiler
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the compiler”](#be_the_compiler-id00002))
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: StaticSuper is a constructor and must have ( ) in its signature. Notice that
    as the output below demonstrates, the static blocks for both classes run before
    either of the constructors run.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0308-02.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: True or False
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“True or False”](#true_or_false))
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: To use the Math class, the first step is to make an instance of it.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: You can mark a constructor with the keyword “static.”
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Static methods don’t have access to an object’s instance variables.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: It is good practice to call a static method using a reference variable.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Static variables could be used to count the instances of a class.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Constructors are called before static variables are initialized.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: MAX_SIZE would be a good name for a static final variable.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: A static initializer block runs before a class’s constructor runs.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: If a class is marked final, all of its methods must be marked final.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: A final method can be overridden only if its class is extended.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: There is no wrapper class for boolean primitives.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: A wrapper is used when you want to treat a primitive like an object.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **True** |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The parseXxx methods always return a String.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Formatting classes (which are decoupled from I/O) are in the java.format package.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **False** |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
