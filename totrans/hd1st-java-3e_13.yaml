- en: 'Chapter 11\. Data Structures: Collections and Generics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0309-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Sorting is a snap in Java.** You have all the tools for collecting and manipulating
    your data without having to write your own sort algorithms (unless you’re reading
    this right now sitting in your Computer Science 101 class, in which case, trust
    us—you are SO going to be writing sort code while the rest of us just call a method
    in the Java API). In this chapter, you’re going to get a peek at when Java can
    save you some typing and figure out the types that you need.'
  prefs: []
  type: TYPE_NORMAL
- en: The Java Collections Framework has a data structure that should work for virtually
    anything you’ll ever need to do. Want to keep a list that you can easily keep
    adding to? Want to find something by name? Want to create a list that automatically
    takes out all the duplicates? Sort your co-workers by the number of times they’ve
    tried to speak with their mic muted on a video call? Sort your pets by number
    of tricks learned? It’s all here...
  prefs: []
  type: TYPE_NORMAL
- en: Tracking song popularity on your jukebox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0310-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations on your new job—managing the automated jukebox system at Lou’s
    Diner. There’s no Java inside the jukebox itself, but each time someone plays
    a song, the song data is appended to a simple text file.
  prefs: []
  type: TYPE_NORMAL
- en: Your job is to manage the data to track song popularity, generate reports, and
    manipulate the playlists. You’re not writing the entire app—some of the other
    software developers are involved as well, but you’re responsible for managing
    and sorting the data inside the Java app. And since Lou has a thing against databases,
    this is strictly an in-memory data collection. Another programmer will be writing
    the code to read the song data from a file and put the songs into a List. (In
    a few chapters you’ll learn how to read data from files, and write data to files.)
    All you’re going to get is a List with the song data the jukebox keeps adding
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s not wait for that other programmer to give us the actual file of songs;
    let’s create a small test program to provide us with some sample data we can work
    with. We’ve agreed with the other programmer that she’ll ultimately provide a
    Songs class with a getSongs method we’ll use to get the data. Armed with that
    information, we can write a small class to temporarily “stand in” for the actual
    code. Code that stands in for other code is often called “**mock**” code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**You’ll often want to write some temporary code that stands in for the real
    code that will come later. This is called “mocking.”**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0310-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Your first job, sort the songs in alphabetical order
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll start by creating code that reads in data from the mock Songs class and
    prints out what it got. Since an ArrayList’s elements are placed in the order
    in which they were added, it’s no surprise that the song titles are not yet alphabetized.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0311-01.png)![image](Images/f0311-02.png)![image](Images/f0312-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Great question! You spotted the diamond operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve been declaring our ArrayLists by showing the element type twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Most of the time, we don’t need to say the same thing twice. The compiler can
    tell from what you wrote on the left-hand side what you probably want on the right-hand
    side. It uses *type inference* to infer (work out) the type you need.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0312-03.png)'
  prefs: []
  type: TYPE_IMG
- en: This syntax is called the diamond operator (because, well, it’s diamond-shaped!)
    and was introduced in Java 7, so it’s been around a while and is probably available
    in your version of Java.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Over time, Java has evolved to remove unnecessary code duplication from its
    syntax. If the compiler can figure out a type, you don’t always need to write
    it out in full.**'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the java.util API, List and Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know that with an ArrayList, or any List, the elements are kept in the order
    in which they were added. So we’re going to need to sort the elements in the song
    list. In this chapter, we’ll be looking at some of the most important and commonly
    used collection classes in the java.util package, but for now, let’s limit ourselves
    to two classes: java.util.List and java.util.Collections.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been using ArrayList for a while now. Because ArrayList IS-A List and
    because many of the methods we’re familiar with on ArrayList come from List, we
    can comfortably transfer most of what we know about working with ArrayLists to
    List.
  prefs: []
  type: TYPE_NORMAL
- en: The Collections class is known as a “utility” class. It’s a class that has a
    lot of handy methods for working with the various collection types.
  prefs: []
  type: TYPE_NORMAL
- en: In the “Real-World”™ there are lots of ways to sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We don’t always want our lists sorted alphabetically. We might want to sort
    clothes by size, or movies by how many five-star reviews they get. Java lets you
    sort the good old-fashioned way, alphabetically, and it also lets you create your
    own custom sorting approaches. Those references you see above to “Comparator”
    have to do with custom sorting, which we’ll get to later this chapter. So for
    now, let’s stick with “natural ordering” (alphabetical).
  prefs: []
  type: TYPE_NORMAL
- en: Since we know we have a List, it looks like we’ve found the perfect method,
    **Collections.sort()**.
  prefs: []
  type: TYPE_NORMAL
- en: “Natural Ordering,” what Java means by alphabetical
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lou wants you to sort songs “alphabetically,” but what exactly does that mean?
    The A–Z part is obvious, but how about lowercase versus uppercase letters? How
    about numbers and special characters? Well, this is another can-of-worms topic,
    but Java uses Unicode, and for many of us in “the West” that means that numbers
    sort before uppercase letters, uppercase letters sort before lowercase letters,
    and some special characters sort before numbers and some sort after numbers. That’s
    pretty clear, right? Ha! Well, the upshot is that, by default, sorting in Java
    happens in what’s called “natural order,” which is more or less alphabetical.
    Let’s take a look at what happens when we sort our list of songs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0315-01.png)![image](Images/f0315-02.png)'
  prefs: []
  type: TYPE_IMG
- en: But now you need Song objects, not just simple Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now your boss Lou wants actual Song class instances in the list, not just Strings,
    so that each Song can have more data. The new jukebox device outputs more information,
    so the actual song file will have *three* pieces of information for each song.
  prefs: []
  type: TYPE_NORMAL
- en: The Song class is really simple, with only one interesting feature—the overridden
    toString() method. Remember, the toString() method is defined in class Object,
    so every class in Java inherits the method. And since the toString() method is
    called on an object when it’s printed (System.out.println(anObject)), you should
    override it to print something more readable than the default unique identifier
    code. When you print a list, the toString() method will be called on each object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0316-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Changing the Jukebox code to use Songs instead of Strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your code changes only a little. The big change is that the List will be of
    type <SongV2> instead of <String>.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0317-01.png)![image](Images/f0317-02.png)'
  prefs: []
  type: TYPE_IMG
- en: It won’t compile!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: He’s right to be curious, something’s wrong...the Collections class clearly
    shows there’s a sort() method that takes a List. It *should* work.
  prefs: []
  type: TYPE_NORMAL
- en: '***But it doesn’t!***'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler says it can’t find a sort method that takes a List<SongV2>, so
    maybe it doesn’t like a List of Song objects? It didn’t mind a List<String>, so
    what’s the important difference between Song and String? What’s the difference
    that’s making the compiler fail?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0318-01.png)'
  prefs: []
  type: TYPE_IMG
- en: And of course you probably already asked yourself, “What would it be sorting
    *on*?” How would the sort method even *know* what made one Song greater or less
    than another Song? Obviously if you want the song’s *title* to be the value that
    determines how the songs are sorted, you’ll need some way to tell the sort method
    that it needs to use the title and not, say, the beats per minute.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll get into all that a few pages from now, but first, let’s find out why
    the compiler won’t even let us pass a SongV2 List to the sort() method.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0319-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The sort() method declaration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0319-02.png)'
  prefs: []
  type: TYPE_IMG
- en: From the API docs (looking up the java.util.Collections class and scrolling
    to the sort() method), it looks like the sort() method is declared...*strangely*.
    Or at least different from anything we’ve seen so far.
  prefs: []
  type: TYPE_NORMAL
- en: That’s because the sort() method (along with other things in the whole collection
    framework in Java) makes heavy use of *generics*. Any time you see something with
    angle brackets in Java source code or documentation, it means generics—a feature
    added in Java 5\. So it looks like we’ll have to learn how to interpret the documentation
    before we can figure out why we were able to sort String objects in a List, but
    not a List of Song objects.
  prefs: []
  type: TYPE_NORMAL
- en: Generics means more type-safety
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although generics can be used in other ways, you’ll often use generics to write
    type-safe collections. In other words, code that makes the compiler stop you from
    putting a Dog into a list of Ducks.
  prefs: []
  type: TYPE_NORMAL
- en: Without generics the compiler could not care less what you put into a collection,
    because all collection implementations hold type Object. You could put *anything*
    in any ArrayList without generics; it’s like the ArrayList is declared as ArrayList<Object>.
  prefs: []
  type: TYPE_NORMAL
- en: '**WITHOUT generics**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects go IN as a reference to SoccerBall, Fish, Guitar, and Car objects**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0320-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**And come OUT as a reference of type Object**'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '**WITH generics**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Objects go IN as a reference to only Fish objects**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0320-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**And come out as a reference of type Fish**'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Without generics, the compiler would happily let you put a Pumpkin into an
    ArrayList that was supposed to hold only Cat objects.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**With generics, you can create type-safe collections where more problems are
    caught at compile-time instead of runtime.**'
  prefs: []
  type: TYPE_NORMAL
- en: Learning generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Of the dozens of things you could learn about generics, there are really only
    three that matter to most programmers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Creating instances of generic *classes* (like ArrayList)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you make an ArrayList, you have to tell it the type of objects you’ll allow
    in the list, just as you do with plain old arrays.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/2.png) **Declaring and assigning *variables* of generic types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does polymorphism really work with generic types? If you have an ArrayList<Animal>
    reference variable, can you assign an ArrayList<Dog> to it? What about a List<Animal>
    reference? Can you assign an ArrayList<Animal> to it? You’ll see...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3.png) **Declaring (and invoking) *methods* that take generic
    types**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have a method that has as a parameter, say, an ArrayList of Animal objects,
    what does that really mean? Can you also pass it an ArrayList of Dog objects?
    We’ll look at some subtle and tricky polymorphism issues that are very different
    from the way you write methods that take plain old arrays.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '(This is actually the same point as #2, but that shows you how important we
    think it is.)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using generic CLASSES
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since ArrayList is one of our most-used generic classes, we’ll start by looking
    at its documentation. The two key areas to look at in a generic class are:'
  prefs: []
  type: TYPE_NORMAL
- en: The *class* declaration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *method* declarations that let you add elements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Understanding ArrayList documentation *(Or, what’s the true meaning of “E”?)***'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0322-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The “E” represents the type used to create an instance of ArrayList. When you
    see an “E” in the ArrayList documentation, you can do a mental find/replace to
    exchange it for whatever <type> you use to instantiate ArrayList.
  prefs: []
  type: TYPE_NORMAL
- en: So, new ArrayList<Song> means that “E” becomes “Song” in any method or variable
    declaration that uses “E.”
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Think of “E” as a stand-in for “the type of element you want this collection
    to hold and return.” (E is for Element.)
  prefs: []
  type: TYPE_NORMAL
- en: Using type parameters with ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0323-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Is treated by the compiler as:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the “E” is replaced by the *real* type (also called the *type
    parameter*) that you use when you create the ArrayList. And that’s why the add()
    method for ArrayList won’t let you add anything except objects of a reference
    type that’s compatible with the type of “E.” So if you make an ArrayList**<String>**,
    the add() method suddenly becomes **add(String o)**. If you make the ArrayList
    of type **Dog**, suddenly the add() method becomes **add(Dog o)**.
  prefs: []
  type: TYPE_NORMAL
- en: Using generic METHODS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A generic *class* means that the *class declaration* includes a type parameter.
    A generic *method* means that the *method declaration* uses a type parameter in
    its signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use type parameters in a method in several different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Using a type parameter defined in the class declaration**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0324-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: When you declare a type parameter for the class, you can simply use that type
    any place that you’d use a *real* class or interface type. The type declared in
    the method argument is essentially replaced with the type you use when you instantiate
    the class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **Using a type parameter `that was NOT defined in the
    class declaration`**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0324-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: If the class itself doesn’t use a type parameter, you can still specify one
    for a method, by declaring it in a really unusual (but available) space—*before
    the return type*. This method says that T can be “any type of Animal.”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0325-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Here’s where it gets weird...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***This:***'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '***Is NOT the same as this:***'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Both are legal, but they’re *different*!
  prefs: []
  type: TYPE_NORMAL
- en: The first one, where **<T extends Animal>** is part of the method declaration,
    means that any ArrayList declared of a type that is Animal, or one of Animal’s
    subtypes (like Dog or Cat), is legal. So you could invoke the top method using
    an ArrayList<Dog>, ArrayList<Cat>, or ArrayList<Animal>.
  prefs: []
  type: TYPE_NORMAL
- en: But...the one on the bottom, where the method argument is (ArrayList<Animal>
    list) means that *only* an ArrayList<Animal> is legal. In other words, while the
    first version takes an ArrayList of any type that is a type of Animal (Animal,
    Dog, Cat, etc.), the second version takes *only* an ArrayList of type Animal.
    Not ArrayList<Dog> or ArrayList<Cat>, but only ArrayList<Animal>.
  prefs: []
  type: TYPE_NORMAL
- en: And yes, it does appear to violate the point of polymorphism, but it will become
    clear when we revisit this in detail at the end of the chapter. For now, remember
    that we’re only looking at this because we’re still trying to figure out how to
    sort() that SongList, and that led us into looking at the API for the sort() method,
    which had this strange generic type declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '***For now, all you need to know is that the syntax of the top version is legal
    and that it means you can pass in a ArrayList object instantiated as Animal or
    any Animal subtype.***'
  prefs: []
  type: TYPE_NORMAL
- en: And now back to our sort() method...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0326-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Remember where we were...**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0326-02.png)![image](Images/f0326-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Revisiting the sort() method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So here we are, trying to read the sort() method docs to find out why it was
    OK to sort a list of Strings, but not a list of Song objects. And it looks like
    the answer is...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0327-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The sort() method can take only lists of** **Comparable** **objects.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Song is NOT a subtype of Comparable, so you cannot sort() the list of Songs.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0327-02.png)![image](Images/f0327-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Great point, and one that deserves a full answer! Turn the page...
  prefs: []
  type: TYPE_NORMAL
- en: In generics, “extends” means “extends or implements”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java engineers had to give you a way to put a constraint on a parameterized
    type so that you can restrict it to, say, only subclasses of Animal. But you also
    need to constrain a type to allow only classes that implement a particular interface.
    So here’s a situation where we need one kind of syntax to work for both situations—inheritance
    and implementation. In other words, that works for both *extends* and *implements*.
  prefs: []
  type: TYPE_NORMAL
- en: And the winning word was...*extends*. But it really means “IS-A” and works regardless
    of whether the type on the right is an interface or a class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In generics, the keyword “extends” really means “IS-A” and works for BOTH classes
    and interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0328-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally we know what’s wrong...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Song class needs to implement Comparable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can pass the ArrayList<Song> to the sort() method only if the Song class
    implements Comparable, since that’s the way the sort() method was declared. A
    quick check of the API docs shows the Comparable interface is really simple, with
    only one method to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '**java.lang.Comparable**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0329-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'And the method documentation for compareTo() says:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0329-02.png)'
  prefs: []
  type: TYPE_IMG
- en: It looks like the compareTo() method will be called on one Song object, passing
    that Song a reference to a different Song. The Song running the compareTo() method
    has to figure out if the Song it was passed should be sorted higher, lower, or
    the same in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Your big job now is to decide what makes one song greater than another, and
    then implement the compareTo() method to reflect that. A negative number (any
    negative number) means the Song you were passed is greater than the Song running
    the method. Returning a positive number says that the Song running the method
    is greater than the Song passed to the compareTo() method. Returning zero means
    the Songs are equal (at least for the purpose of sorting...it doesn’t necessarily
    mean they’re the same object). You might, for example, have two Songs by different
    artists with the same title.
  prefs: []
  type: TYPE_NORMAL
- en: (That brings up a whole different can of worms we’ll look at later...)
  prefs: []
  type: TYPE_NORMAL
- en: '**The big question is: what makes *one* song less than, equal to, or greater
    than *another* song?**'
  prefs: []
  type: TYPE_NORMAL
- en: '**You can’t implement the Comparable interface until you make that decision.**'
  prefs: []
  type: TYPE_NORMAL
- en: The new, improved, comparable Song class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We decided we want to sort by title, so we implement the compareTo() method
    to compare the title of the Song passed to the method against the title of the
    song on which the compareTo() method was invoked. In other words, the song running
    the method has to decide how its title compares to the title of the method parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Hmmm...we know that the String class must know about alphabetical order, because
    the sort() method worked on a list of Strings. We know String has a compareTo()
    method, so why not just call it? That way, we can simply let one title String
    compare itself to another, and we don’t have to write the comparing/alphabetizing
    algorithm!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0330-01.png)![image](Images/f0330-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We can sort the list, but...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0331-01.png)'
  prefs: []
  type: TYPE_IMG
- en: There’s a new problem—Lou wants two different views of the song list, one by
    song title and one by artist!
  prefs: []
  type: TYPE_NORMAL
- en: But when you make a collection element comparable (by having it implement Comparable),
    you get only one chance to implement the compareTo() method. So what can you do?
  prefs: []
  type: TYPE_NORMAL
- en: The horrible way would be to use a flag variable in the Song class and then
    do an *if* test in compareTo() and give a different result depending on whether
    the flag is set to use title or artist for the comparison.
  prefs: []
  type: TYPE_NORMAL
- en: But that’s an awful and brittle solution, and there’s something much better.
    Something built into the API for just this purpose—when you want to sort the same
    thing in more than one way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Look at API documentation again. There’s a second sort() method on Collections—and
    it takes a Comparator. There’s also a sort method on List that takes a Comparator.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0331-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a custom Comparator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Comparable** element in a list can compare *itself* to another of its own
    type in only one way, using its compareTo() method. But a **Comparator** is external
    to the element type you’re comparing—it’s a separate class. So you can make as
    many of these as you like! Want to compare songs by artist? Make an ArtistComparator.
    Sort by beats per minute? Make a BpmComparator.
  prefs: []
  type: TYPE_NORMAL
- en: Then all you need to do is call a sort() method that takes a Comparator (Collections.sort
    or List.sort), which will use this Comparator to put things in order.
  prefs: []
  type: TYPE_NORMAL
- en: The sort() method that takes a Comparator will use the Comparator instead of
    the element’s own compareTo() method when it puts the elements in order. In other
    words, if your sort() method gets a Comparator, it won’t even *call* the compareTo()
    method of the elements in the list. The sort() method will instead invoke the
    **compare****()** method on the Comparator.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arrow.png) Invoking the **Collections.sort(List list)** method
    means the list element’s compareTo() method determines the order. The elements
    in the list MUST implement the **Comparable** interface.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/arrow.png) Invoking **List.sort(Comparator c)** or **Collections.sort(List
    list, Comparator c)** means the **Comparator**’s compare() method will be used.
    That means the elements in the list do NOT need to implement the Comparable interface,
    but if they do, the list element’s compareTo() method will NOT be called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**java.util.Comparator**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0332-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**If you pass a Comparator to the sort() method, the sort order is determined
    by the Comparator.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**If you don’t pass a Comparator and the element is Comparable, the sort order
    is determined by the element’s compareTo() method.**'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Jukebox to use a Comparator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’re going to update the Jukebox code in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create a separate class that implements Comparator (and thus the ***compare()***
    method that does the work previously done by ***compareTo()***).
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Make an instance of the Comparator class.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Call the List.sort() method, giving it the instance of the Comparator class.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0333-01.png)![image](Images/f0333-02.png)![image](Images/pencil1.png)'
  prefs: []
  type: TYPE_IMG
- en: Fill-in-the-blanks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each of the questions below, fill in the blank with one of the words from
    the “possible answers” list, to correctly answer the question.
  prefs: []
  type: TYPE_NORMAL
- en: '**Possible Answers:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the following compilable statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What must the class of the objects stored in `myArrayList` implement? ________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method must the class of the objects stored in `myArrayList` implement?
    ________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the class of the objects stored in `myArrayList` implement both `Comparator`
    AND `Comparable`? ________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given the following compilable statements (they both do the same thing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Can the class of the objects stored in `myArrayList` implement `Comparable`?
    ________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the class of the objects stored in `myArrayList` implement `Comparator`?
    ________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Must the class of the objects stored in `myArrayList` implement `Comparable`?
    ________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Must the class of the objects stored in `myArrayList` implement `Comparator`?
    ________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What must the class of the `myCompare` object implement? ________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method must the class of the `myCompare` object implement? __________________
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Images](Images/arr.png) **Answers in [“Fill-in-the-blanks”](#fill_in_the_blanksleft_parenthesisfrom_p).**'
  prefs: []
  type: TYPE_NORMAL
- en: But wait! We’re sorting in two different ways!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we’re able to sort the song list two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Collections.sort(songList), because Song implements **Comparable**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using songLists.sort(artistCompare) because the ArtistCompare class implements
    **Comparator**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While our new code allows us to sort songs by title and by artist, it is reminiscent
    of Frankenstein’s monster, cobbled together bit by bit.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0335-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**A better approach would be to handle all of the sorting definitions in classes
    that implement Comparator.**'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting using only Comparators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having Song implement Comparable and creating a custom Comparator for sorting
    by Artist absolutely works, but it’s confusing to rely on two different mechanisms
    for our sort. It’s much clearer if our code uses the same technique to sort, regardless
    of how Lou wants his songs sorted. The code below has been updated to use Comparators
    for sorting by both Title and Artist; the new code is in bold.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0336-01.png)![image](Images/f0336-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Just the code that matters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Jukebox class does have a lot of code that’s needed for sorting. Let’s zoom
    in on one of the Comparator classes we wrote for Lou. The first thing to notice
    is that all we really want to sort our collection is the one line of code in the
    middle of the class. The rest of the code is just the long-winded syntax that’s
    necessary to let the compiler know what type of class this is and which method
    it implements.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s more than one way to declare small pieces of functionality like this.
    One approach is inner classes, which we’ll look at in a later chapter. You can
    even declare the inner class right where you use it (instead of at the end of
    your class file); this is sometimes called an “argument-defined anonymous inner
    class.” Sounds fun already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While this lets us declare the sorting logic in exactly the location we need
    it (where we call the sort method, instead of in a separate class), there’s still
    a lot of code there for saying “sort by title please”).
  prefs: []
  type: TYPE_NORMAL
- en: What do we REALLY need in order to sort?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0338-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let’s take a look at the API documentation for the sort method on List:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0338-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we were to explain out loud the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could say:'
  prefs: []
  type: TYPE_NORMAL
- en: '**“Call the sort method on the list of songs ![Images](Images/1circle.png)
    and pass it a reference to a Comparator object, which is designed specifically
    to sort Song objects ![Images](Images/2circle.png).”**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If we’re honest, we could say all that without even looking at the TitleCompare
    class. We can work it all out just by looking at the documentation for sort and
    the type of the List that we’re sorting!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0339-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Enter lambdas! Leveraging what the compiler can infer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could write a whole bunch of code to say how to sort a list (like we have
    been doing)...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0340-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Where did all that code go?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To answer this question, let’s take a look at the API documentation for the
    Comparator interface.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0341-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Because equals has been implemented by Object, if we create a custom comparator,
    we know we only *need* to implement the compare method.
  prefs: []
  type: TYPE_NORMAL
- en: We also know exactly the shape of that method—it has to return an int, and it
    takes two arguments of type T (remember generics?). Our lambda expression implements
    the compare() method, without having to declare the class or the method, only
    the details of what goes into the body of the compare() method.
  prefs: []
  type: TYPE_NORMAL
- en: Some interfaces have only ONE method to implement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With interfaces like Comparator, we only have to implement a ***single abstract
    method***, SAM for short. These interfaces are so important that they have several
    special names:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SAM Interfaces** a.k.a. **Functional Interfaces**'
  prefs: []
  type: TYPE_NORMAL
- en: If an interface has only one method that needs to be implemented, that interface
    can be implemented as a ***lambda expression***. You don’t need to create a whole
    class to implement the interface; the compiler knows what the class and method
    would look like. What the compiler *doesn’t* know is the logic that goes *inside*
    that method.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Jukebox code with lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0342-01.png)![image](Images/f0342-02.png)![image](Images/pencil1.png)'
  prefs: []
  type: TYPE_IMG
- en: Reverse Engineer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Assume this code exists in a single file. Your job is to fill in the blanks
    so the program will create the output shown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0343-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [““Reverse Engineer” lambdas exercise”](#quotation_markreverse_engineerquotation)**.'
  prefs: []
  type: TYPE_NORMAL
- en: Uh-oh. The sorting all works, but now we have duplicates...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sorting works great; now we know how to sort on both *title* and *artist*.
    But there’s a new problem we didn’t notice with a test sample of the jukebox songs—***the
    sorted list contains duplicates.***
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the mock code, Lou’s real jukebox application appears to just keep writing
    to the file regardless of whether the same song has already been played (and thus
    written) to the text file. The *SongListMore.txt* jukebox text file is an example.
    It’s a complete record of every song that was played, and might contain the same
    song multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0344-01.png)![image](Images/f0344-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We need a Set instead of a List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From the Collection API, we find three main interfaces, **List**, **Set**, and
    **Map**. ArrayList is a **List**, but it looks like ***Set*** is exactly what
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arrow.png) **LIST** - **when *sequence* matters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections that know about ***index position***.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Lists know where something is in the list. You can have more than one element
    referencing the same object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0345-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/arrow.png) **SET** - **when *uniqueness* matters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections that ***do not allow duplicates***.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Sets know whether something is already in the collection. You can never have
    more than one element referencing the same object (or more than one element referencing
    two objects that are considered equal—we’ll look at what object equality means
    in a moment).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0345-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/arrow.png) **MAP** - **when *finding something by key* matters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections that use ***key-value pairs***.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Maps know the value associated with a given key. You can have two keys that
    reference the same value, but you cannot have duplicate keys. A key can be any
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0345-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The Collection API (part of it)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0346-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the Map interface doesn’t actually extend the Collection interface,
    but Map is still considered part of the “Collection Framework” (also known as
    the “Collection API”). So Maps are still collections, even though they don’t include
    java.util.Collection in their inheritance tree.
  prefs: []
  type: TYPE_NORMAL
- en: '(Note: this is not the complete collection API; there are other classes and
    interfaces, but these are the ones we care most about.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0346-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a HashSet instead of ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We updated the Jukebox code to put the songs in a HashSet to try to eliminate
    our duplicate songs. (Note: we left out some of the Jukebox code, but you can
    copy it from earlier versions.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0347-01.png)![image](Images/f0347-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The Set didn’t help!!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**We still have all the duplicates!**'
  prefs: []
  type: TYPE_NORMAL
- en: What makes two objects equal?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To figure out why using a Set didn’t remove the duplicates, we have to ask—what
    makes two Song references duplicates? They must be considered ***equal***. Is
    it simply two references to the very same object, or is it two separate objects
    that both have the same *title*?
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up a key issue: *reference* equality vs. *object* equality.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arrow.png) **Reference equality**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two references, one object on the heap.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Two references that refer to the same object on the heap are equal. Period.
    If you call the **`hashCode()`** method on both references, you’ll get the same
    result. If you don’t override the hashCode `()` method, the default behavior (remember,
    you inherited this from class Object) is that each object will get a unique number
    (most versions of Java assign a hashcode based on the object’s memory address
    on the heap, so no two objects will have the same hashcode).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to know if two *references* are really referring to the same object,
    use the == operator, which (remember) compares the bits in the variables. If both
    references point to the same object, the bits will be identical.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0348-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arrow.png) **Object equality**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two references, two objects on the heap, but the objects are considered *meaningfully
    equivalent.***'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you want to treat two different Song objects as equal (for example if you
    decided that two Songs are the same if they have matching *title* variables),
    you must override *both* the **hashCode()** and **equals()** methods inherited
    from class Object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we said above, if you *don’t* override hashCode(), the default behavior (from
    Object) is to give each object a unique hashcode value. So you must override hashCode()
    to be sure that two equivalent objects return the same hashcode. But you must
    also override equals() so that if you call it on *either* object, passing in the
    other object, always returns ***true***.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0348-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'How a HashSet checks for duplicates: hashCode() and equals()'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you put an object into a HashSet, it calls the object’s hashCode method
    to determine where to put the object in the Set. But it also compares the object’s
    hash code to the hash code of all the other objects in the HashSet, and if there’s
    no matching hash code, the HashSet assumes that this new object is *not* a duplicate.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if the hash codes are different, the HashSet assumes there’s
    no way the objects can be equal!
  prefs: []
  type: TYPE_NORMAL
- en: So you must override hashCode() to make sure the objects have the same value.
  prefs: []
  type: TYPE_NORMAL
- en: But two objects with the same hash code might *not* be equal (more on this on
    the next page), so if the HashSet finds a matching hash code for two objects—one
    you’re inserting and one already in the set—the HashSet will then call one of
    the object’s equals() methods to see if these hash code–matched objects really
    *are* equal.
  prefs: []
  type: TYPE_NORMAL
- en: And if they’re equal, the HashSet knows that the object you’re attempting to
    add is a duplicate of something in the Set, so the add doesn’t happen.
  prefs: []
  type: TYPE_NORMAL
- en: You don’t get an exception, but the HashSet’s add() method returns a boolean
    to tell you (if you care) whether the new object was added. So if the add() method
    returns *false*, you know the new object was a duplicate of something already
    in the set.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0349-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The Song class with overridden hashCode() and equals()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0350-01.png)![image](Images/f0350-02.png)'
  prefs: []
  type: TYPE_IMG
- en: If we want the set to stay sorted, we’ve got TreeSet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TreeSet is similar to HashSet in that it prevents duplicates. But it also *keeps*
    the list sorted. It works just like the sort() method in that if you make a TreeSet
    without giving it a Comparator, the TreeSet uses each object’s compareTo() method
    for the sort. But you have the option of passing a Comparator to the TreeSet constructor,
    to have the TreeSet use that instead.
  prefs: []
  type: TYPE_NORMAL
- en: The downside to TreeSet is that if you don’t *need* sorting, you’re still paying
    for it with a small performance hit. But you’ll probably find that the hit is
    almost impossible to notice for most apps.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Create a TreeSet instead of HashSet. The TreeSet will use SongV4’s compareTo()
    method to sort the items in songList.
  prefs: []
  type: TYPE_NORMAL
- en: If we want the TreeSet to sort on something different (i.e., to NOT use SongV4’s
    compareTo() method), we need to pass in a Comparator (or a lambda) to the TreeSet
    constructor. Then we’d use songSet.addAll() to add the songList values into the
    TreeSet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Yep, another lambda for sorting. This one sorts by BPM. Remember, this lambda
    implements Comparator.
  prefs: []
  type: TYPE_NORMAL
- en: What you MUST know about TreeSet...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TreeSet looks easy, but make sure you really understand what you need to do
    to use it. We thought it was so important that we made it an exercise so you’d
    *have* to think about it. Do NOT turn the page until you’ve done this. *We mean
    it.*
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arr1.png) **Answers in [“TreeSet exercise”](#treeset_exercise_left_parenthesisfrom_pa).**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. What is the result when you compile this code?
  prefs: []
  type: TYPE_NORMAL
- en: __________________________________________________
  prefs: []
  type: TYPE_NORMAL
- en: 2\. If it compiles, what is the result when you run the TestTree class?
  prefs: []
  type: TYPE_NORMAL
- en: __________________________________________________
  prefs: []
  type: TYPE_NORMAL
- en: 3\. If there is a problem (either compile-time or runtime) with this code, how
    would you fix it?
  prefs: []
  type: TYPE_NORMAL
- en: __________________________________________________
  prefs: []
  type: TYPE_NORMAL
- en: TreeSet elements MUST be comparable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TreeSet can’t read the programmer’s mind to figure out how the objects should
    be sorted. You have to tell the TreeSet *how*.
  prefs: []
  type: TYPE_NORMAL
- en: '**To use a TreeSet, one of these things must be true:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arrow.png) **The elements in the list must be of a type that
    implements** ***Comparable***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Book class on the previous page didn’t implement Comparable, so it wouldn’t
    work at runtime. Think about it, the poor TreeSet’s sole purpose in life is to
    keep your elements sorted, and once again—it had no idea how to sort Book objects!
    It doesn’t fail at compile-time, because the TreeSet add() method doesn’t take
    a Comparable type. The TreeSet add() method takes whatever type you used when
    you created the TreeSet. In other words, if you say new TreeSet<Book>(), the add()
    method is essentially add(Book). And there’s no requirement that the Book class
    implement Comparable! But it fails at runtime when you add the second element
    to the set. That’s the first time the set tries to call one of the object’s compareTo()
    methods and...can’t.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**OR**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/arrow.png) **You use the TreeSet’s overloaded constructor
    that takes a** ***Comparator***'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TreeSet works a lot like the sort() method—you have a choice of using the element’s
    compareTo() method, assuming the element type implemented the Comparable interface,
    OR you can use a custom Comparator that knows how to sort the elements in the
    set. To use a custom Comparator, you call the TreeSet constructor that takes a
    Comparator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0354-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve seen Lists and Sets, now we’ll use a Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lists and Sets are great, but sometimes a Map is the best collection (not Collection
    with a capital “C”—remember that Maps are part of Java collections but they don’t
    implement the Collection interface).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you want a collection that acts like a property list, where you give
    it a name and it gives you back the value associated with that name. Keys can
    be any Java object (or, through autoboxing, a primitive), but you’ll often see
    String keys (i.e., property names) or Integer keys (representing unique IDs, for
    example).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0355-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Each element in a Map is actually TWO objects—a *key* and a *value*. You
    can have duplicate values, but NOT duplicate *keys*.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Map example**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0355-02.png)![image](Images/f0355-03.png)![image](Images/f0356-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating and filling collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for creating, and then filling, a collection crops up again and again.
    You’ve already seen code for creating an ArrayList and adding elements to it quite
    a few times. Code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether you’re creating a List, a Set, or a Map, it looks pretty similar. What’s
    more, these types of collections are often ones where we know what the data is
    right at the start, and then we don’t intend to change it at all during the lifetime
    of the collection. If we wanted to really make sure that no-one changed the collection
    after we’d created it, we’d have to add an extra step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0356-03.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s a lot of code! And it’s a lot of code for something common that we probably
    want to do a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately for us, Java now has “Convenience Factory Methods of Collections”
    (they were added in Java 9). We can use these methods to create common data structures
    and fill them with data, with just one method call.
  prefs: []
  type: TYPE_NORMAL
- en: Convenience Factory Methods for Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Convenience Factory Methods for Collections allow you to easily create a List,
    Set, or Map that’s been prefilled with known data. There are a couple of things
    to understand about using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **The resulting collections cannot be changed.** You
    can’t add to them or alter the values; in fact, you can’t even do the sorting
    that we’ve seen in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **The resulting collections are not the standard Collections
    we’ve seen**. These are not ArrayList, HashSet, HashMap, etc. You can rely on
    them to behave according to their interface: a List will always preserve the order
    in which the elements were placed; a Set will never have duplicates. But you can’t
    rely on them being a specific implementation of List, Set, or Map.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convenience Factory Methods are just that—a convenience that will work for most
    of the cases where you want to create a collection prefilled with data. And for
    those cases where these factory methods don’t suit you, you can still use the
    Collections constructors and add() or put() methods instead.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arrow.png) **Creating a List:** `**List.of()**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create the list of Strings from the last page, we don’t need five lines
    of code; we just need one:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to add Song objects instead of simple Strings, it’s still short
    and descriptive:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/arrow.png) **Creating a Set:** `**Set.of()**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating a Set uses very similar syntax:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/arrow.png) **Creating a Map:** `**Map.of(), Map.ofEntries()**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Maps are different, because they take two objects for each “entry”—a key and
    a value. If you want to put less than 10 entries into your Map, you can use Map.of,
    passing in key, value, key, value, etc.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have more than 10 entries, or if you want to be clearer about how your
    keys are paired up to their values, you can use Map.ofEntries instead:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make the line shorter, you can use a *static import* on Map.entry (we talked
    about static imports in [Chapter 10](ch10.xhtml#numbers_matter_numbers_and_statics)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, back to generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remember earlier in the chapter we talked about how methods that take arguments
    with generic types can be...*weird*. And we mean weird in the polymorphic sense.
    If things start to feel strange here, just keep going—it takes a few pages to
    really tell the whole story. The examples are going to use a class hierarchy of
    Animals.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0358-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Using polymorphic arguments and generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generics can be a little...counterintuitive when it comes to using polymorphism
    with a generic type (the class inside the angle brackets). Let’s create a method
    that takes a List<Animal> and use this to experiment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing in List<Animal>**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0358-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Compiles and runs just fine**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0358-03.png)'
  prefs: []
  type: TYPE_IMG
- en: But will it work with List<Dog>?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A List<Animal> argument can be passed to a method with a List<Animal> parameter.
    So the big question is, will the List<Animal> parameter accept a List<Dog>? Isn’t
    that what polymorphism is for?
  prefs: []
  type: TYPE_NORMAL
- en: '**Passing in List<Dog>**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0359-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**When we compile it:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0359-02.png)![image](Images/f0360-01.png)'
  prefs: []
  type: TYPE_IMG
- en: What could happen if it were allowed...?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Imagine the compiler let you get away with that. It let you pass a List<Dog>
    to a method declared as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: There’s nothing in that method that *looks* harmful, right? After all, the whole
    point of polymorphism is that anything an Animal can do (in this case, the eat()
    method), a Dog can do as well. So what’s the problem with having the method call
    eat() on each of the Dog references?
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s nothing wrong with *that* code. But imagine *this* code instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0360-03.png)'
  prefs: []
  type: TYPE_IMG
- en: So that’s the problem. There’s certainly nothing wrong with adding a Cat to
    a List<Animal>, and that’s the whole point of having a List of a supertype like
    Animal—so that you can put all types of animals in a single Animal List.
  prefs: []
  type: TYPE_NORMAL
- en: But if you passed a Dog List—one meant to hold ONLY Dogs—to this method that
    takes an Animal List, then suddenly you’d end up with a Cat in the Dog list. The
    compiler knows that if it lets you pass a Dog List into the method like that,
    someone could, at runtime, add a Cat to your Dog list. So instead, the compiler
    just won’t let you take the risk.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**If you declare a method to take List<Animal>, it can take ONLY a List<Animal>,
    not List<Dog> or List<Cat>.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0361-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We can do this with wildcards
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It looks unusual, but there *is* a way to create a method argument that can
    accept a List of any Animal subtype. The simplest way is to use a **wildcard**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0361-01.png)'
  prefs: []
  type: TYPE_IMG
- en: So now you’re wondering, “What’s the *difference*? Don’t you have the same problem
    as before?”
  prefs: []
  type: TYPE_NORMAL
- en: And you’d be right for wondering. The answer is NO. When you use the wildcard
    <?> in your declaration, the compiler won’t let you do anything that adds to the
    list!
  prefs: []
  type: TYPE_NORMAL
- en: Using the method’s generic type parameter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What can we do if we define our method like this instead?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, not much as the method stands right now, we don’t need to use “T” for
    anything. But if we made a change to our method to return a List, for example
    of all the animals we had successfully vaccinated, we can declare that the List
    that’s returned has the same generic type as the List that’s passed in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When you call the method, you know you’re going to get the same type back as
    you put in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The List we get back from the takeAnimals method is always the same type
    as the list we pass in.**'
  prefs: []
  type: TYPE_NORMAL
- en: If the method used the wildcard for both method parameter and return type, there’s
    nothing to guarantee they’re the same type. In fact, anything calling the method
    has almost no idea what’s going to be in the collection, other than “some sort
    of animal.”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using the wildcard (“? extends”) is fine when you don’t care much about the
    generic type, you just want to allow all subtypes of some type.
  prefs: []
  type: TYPE_NORMAL
- en: Using a type parameter (“T”) is more helpful when you want to do more with the
    type itself, for example in the method’s return.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the Compiler, advanced
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0363-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Your job is to play compiler and determine which of these statements would compile.
    Some of this code wasn’t covered in the chapter, so you need to work out the answers
    based on what you DID learn, applying the “rules” to these new situations.
  prefs: []
  type: TYPE_NORMAL
- en: The signatures of the methods used in the exercise are in the boxes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0363-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Compiles?**'
  prefs: []
  type: TYPE_NORMAL
- en: '| ![Images](Images/box.png) | **`takeAnimals(new ArrayList<Animal>());`** |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`takeDogs(new ArrayList<Animal>());`** |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`takeAnimals(new ArrayList<Dog>());`** |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`takeDogs(new ArrayList<>());`** |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`List<Dog> dogs = new ArrayList<>(); takeDogs(dogs);`**
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`takeSomeAnimals(new ArrayList<Dog>());`**
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`takeSomeAnimals(new ArrayList<>());`** |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`takeSomeAnimals(new ArrayList<Animal>());`**
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`List<Animal> animals = new ArrayList<>();
    takeSomeAnimals(animals);`** |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`List<Object> objects = new ArrayList<>();
    takeObjects(objects);`** |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`takeObjects(new ArrayList<Dog>());`** |'
  prefs: []
  type: TYPE_TB
- en: '| ![Images](Images/box.png) | **`takeObjects(new ArrayList<Object>());`** |'
  prefs: []
  type: TYPE_TB
- en: '![Images](Images/arr1.png) **Answers in [“BE the Compiler solution”](#be_the_compiler_solution_left_parenthesi).**'
  prefs: []
  type: TYPE_NORMAL
- en: Exercise Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fill-in-the-blanks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Fill-in-the-blanks”](#fill_in_the_blanks))
  prefs: []
  type: TYPE_NORMAL
- en: '**Possible Answers:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the following compilable statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: What must the class of the objects stored in `myArrayList` implement? **Comparable**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method must the class of the objects stored in `myArrayList` implement?
    **compareTo( )**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the class of the objects stored in `myArrayList` implement both `Comparator`
    AND `Comparable`? **yes**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given the following compilable statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Can the class of the objects stored in `myArrayList` implement `Comparable`?
    **yes**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can the class of the objects stored in `myArrayList` implement `Comparator`?
    **yes**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Must the class of the objects stored in `myArrayList` implement `Comparable`?
    **no**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Must the class of the objects stored in `myArrayList` implement `Comparator`?
    **no**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What must the class of the `myCompare` object implement? **Comparator**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method must the class of the `myCompare` object implement? **compare( )**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/pencil1.png)'
  prefs: []
  type: TYPE_IMG
- en: “Reverse Engineer” lambdas exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Reverse Engineer”](#reverse_engineer))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0365-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0365-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Sorting with lambdas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Reverse Engineer”](#reverse_engineer))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0366-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0366-02.png)'
  prefs: []
  type: TYPE_IMG
- en: TreeSet exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“What you MUST know about TreeSet...”](#what_you_must_know_about_treesethellip))
  prefs: []
  type: TYPE_NORMAL
- en: What is the result when you compile this code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**It compiles correctly**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If it compiles, what is the result when you run the TestTree class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**It throws an exception:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If there is a problem (either compile-time or runtime) with this code, how would
    you fix it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0366-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: BE the Compiler solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the Compiler, advanced”](#be_the_compilercomma_advanced))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0367-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Compiles?**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0367-03.png)'
  prefs: []
  type: TYPE_IMG
