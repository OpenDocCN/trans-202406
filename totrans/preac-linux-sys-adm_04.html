<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 4. Managing Users" data-type="chapter" epub:type="chapter"><div class="chapter" id="managing_users">
<h1><span class="label">Chapter 4. </span>Managing Users</h1>
<p>As a system administrator, you’ll spend a significant portion of your time managing users. <a contenteditable="false" data-primary="user management" data-type="indexterm" id="ix_usrmg"/>You’ll also spend time troubleshooting user problems that aren’t account- or permissions-related, such as connectivity problems, broken applications, data corruption, training issues, security issues, and user-created problems.</p>
<p>Managing users covers the following tasks:</p>
<ul>
<li>
<p>Creating user accounts</p>
</li>
<li>
<p>Modifying user accounts</p>
</li>
<li>
<p>Removing user accounts</p>
</li>
<li>
<p>Granting access to files and directories</p>
</li>
<li>
<p>Restricting access to files and directories</p>
</li>
<li>
<p>Enforcing security policies</p>
</li>
<li>
<p>Setting permissions on files and directories</p>
</li>
</ul>
<p>Some user management tasks can be learned from this book, while others are purely experiential and on-the-job training for you. No two user environments are exactly alike, and no two user experiences are exactly alike. In this chapter, you learn some preemptive user management methods, but problems still occur. The techniques you learn in this chapter will get you started on being able to handle an array of user-related problems.</p>
<section data-pdf-bookmark="User and Group ID Numbering Conventions" data-type="sect1"><div class="sect1" id="user_and_group_id_numbering_conventions">
<h1>User and Group ID Numbering Conventions</h1>
<p>There are some <a contenteditable="false" data-primary="user management" data-secondary="user and group ID numbering conventions" data-type="indexterm" id="idm45657875731104"/>guidelines associated with creating and maintaining user accounts on Linux systems, as shown in <a data-type="xref" href="#numbering_conventions_for_user_and_grou">Table 4-1</a>. These aren’t hard and fast rules, but they’re generally followed on most corporate systems.</p>
<table class="border" id="numbering_conventions_for_user_and_grou">
<caption><span class="label">Table 4-1. </span>Numbering conventions for user and group accounts</caption>
<thead>
<tr>
<th>UID</th>
<th>GID</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>Root</td>
</tr>
<tr>
<td>1–999</td>
<td>1–999</td>
<td>System/service accounts</td>
</tr>
<tr>
<td>1000+</td>
<td>1000+</td>
<td>User accounts</td>
</tr>
</tbody>
</table>
<p>User account UID and GID numbers typically begin at 1000 and increment by one for each new account.<a contenteditable="false" data-primary="GIDs (group IDs)" data-type="indexterm" id="idm45657874960976"/><a contenteditable="false" data-primary="UIDs (user IDs)" data-type="indexterm" id="idm45657874960336"/> The UID and GID for the root user are always 0; no other user on the system has these user and group IDs.<a contenteditable="false" data-primary="user IDs" data-see="UIDs" data-type="indexterm" id="idm45657874959312"/><a contenteditable="false" data-primary="group IDs (GIDs)" data-type="indexterm" id="idm45657874958544"/></p>
<p>System and service accounts aren’t human user accounts and typically don’t have an interactive shell associated with them. These accounts are given UIDs and GIDs ranging from 1–999. These separations make system housekeeping much easier than randomly assigning UIDs and GIDs to user accounts.</p>
</div></section>
<section data-pdf-bookmark="Creating User Accounts" data-type="sect1"><div class="sect1" id="creating_user_accounts">
<h1>Creating User Accounts</h1>
<p>Like most tasks in Linux, there’s more than one way to create user accounts. <a contenteditable="false" data-primary="user management" data-secondary="creating user accounts" data-type="indexterm" id="ix_usrmgacc"/>For this book, I stick with the two mainstream methods of creating accounts: <code>useradd</code> and <code>adduser</code>.</p>
<section data-pdf-bookmark="Adding Users with useradd" data-type="sect2"><div class="sect2" id="adding_users_with_useradd">
<h2>Adding Users with useradd</h2>
<p>The <code>useradd</code> command is the standard command-line Linux method of adding new users to a system. <a contenteditable="false" data-primary="useradd command" data-type="indexterm" id="idm45657874947344"/><a contenteditable="false" data-primary="user management" data-secondary="creating user accounts" data-tertiary="adding users with useradd" data-type="indexterm" id="idm45657874946240"/>The <code>useradd</code> command is simple; all you really need to supply is a username as an argument:</p>
<pre data-type="programlisting">
# useradd jsmith</pre>
<p>This creates the home directory, <em>/home/jsmith</em>, fills it with the default complement of hidden environment files, and places an entry into <em>/etc/passwd</em>. <a contenteditable="false" data-primary="home directory (/home)" data-secondary="creating when adding a user" data-type="indexterm" id="idm45657874942864"/>When I create a user account with <code>useradd</code>, I supply a single argument and bit of information (the user’s full name) that otherwise requires me to edit the <em>/etc/passwd</em> file:</p>
<pre data-type="programlisting">
# useradd -c "Jane Smith" jsmith</pre>
<p>The <code>-c</code> option writes the information you supply to it to the fifth field of the <code>/etc/passwd</code> file. <a contenteditable="false" data-primary="useradd command" data-secondary="-c option" data-type="indexterm" id="idm45657874944528"/>If you wish to <a contenteditable="false" data-primary="/etc/passwd file" data-primary-sortas="etc" data-secondary="adding information to with useradd -c" data-type="indexterm" id="idm45657874936464"/>supply more information, such as phone number, email address, or whatever you wish to include, use commas (<code>,</code>) to separate the <span class="keep-together">information:</span></p>
<pre data-type="programlisting">
# useradd -c "Jane Smith,Room 26,212-555-1000,jsmith@example.com" jsmith</pre>
<p>The new user’s <em>/etc/passwd</em> entry:</p>
<pre data-type="programlisting">
jsmith:x:1007:1007:Jane Smith,Room 26,212-555-1000,jsmith@example.com:/home/
jsmith:/bin/bash</pre>
<p>The individual fields in a user’s <em>/etc/passwd</em> entry are as <a contenteditable="false" data-primary="/etc/passwd file" data-primary-sortas="etc" data-secondary="fields in" data-type="indexterm" id="idm45657874930336"/>follows (from left to right):</p>
<ul>
<li>
<p>Username</p>
</li>
<li>
<p><em>/etc/shadow</em> password field</p>
</li>
<li>
<p>User ID</p>
</li>
<li>
<p>Primary group ID</p>
</li>
<li>
<p>The comment field</p>
</li>
<li>
<p>Home directory</p>
</li>
<li>
<p>Default shell</p>
</li>
</ul>
<p>Passwords are not stored in the <em>/etc/passwd</em> file. The <em>/etc/shadow</em> field refers to the <em>/etc/shadow</em> file that contains each user’s encrypted password and is readable only by the root user. <a contenteditable="false" data-primary="passwords" data-secondary="storage in /etc/shadow file" data-type="indexterm" id="idm45657874917520"/><a contenteditable="false" data-primary="/etc/shadow file" data-primary-sortas="etc" data-type="indexterm" id="idm45657874916624"/>Note the <em>/etc/shadow</em> file’s permissions are <code>000</code> on Red Hat Enterprise Linux–based systems. <a contenteditable="false" data-primary="permissions and privileged accounts" data-secondary="permissions on /etc/shadow file" data-type="indexterm" id="idm45657874914176"/>The file permissions vary among distributions but are never readable by regular users:</p>
<pre data-type="programlisting">
----------. 1 root root 1547 Jul 17 10:55 /etc/shadow</pre>
<p>Although Jane Smith’s user account is created, her home directory exists, and there’s an entry in the <em>/etc/passwd</em> file for the account, Jane can’t log into the system. Do you know why? It’s because the account has no password. As the sysadmin, you have to supply an initial password to Jane so that the user can log in. Since you haven’t supplied a password for the account, the <em>/etc/shadow</em> entry shows that there is no password:</p>
<pre data-type="programlisting">
jsmith:!!:18825:0:99999:7:::</pre>
<p>Use the <code>passwd</code> command to<a contenteditable="false" data-primary="passwords" data-secondary="supplying for user account with passwd command" data-type="indexterm" id="idm45657875181488"/> supply a password to the account:</p>
<pre data-type="programlisting">
# passwd jsmith
Changing password for user jsmith.
New password:
Retype new password:
passwd: all authentication tokens updated successfully.</pre>
<p>Now, you have to give the password to Jane before she can successfully log into the system.</p>
</div></section>
<section data-pdf-bookmark="Adding Users with adduser" data-type="sect2"><div class="sect2" id="adding_users_with_adduser">
<h2>Adding Users with adduser</h2>
<p>On some <a contenteditable="false" data-primary="user management" data-secondary="creating user accounts" data-tertiary="adding users with adduser" data-type="indexterm" id="idm45657874904608"/>Linux distributions, <code>adduser</code> is <a contenteditable="false" data-primary="adduser" data-type="indexterm" id="idm45657874903200"/>a symbolic link to <code>useradd</code>:</p>
<pre data-type="programlisting">
lrwxrwxrwx. 1 root root 17 Oct 26 2020 /usr/sbin/adduser -&gt; /usr/sbin/useradd</pre>
<p>On other distributions, <code>adduser</code> is an interactive Perl script that steps you through adding a new user, and <code>useradd</code> is a separate utility with its standard switches and arguments.<a contenteditable="false" data-primary="user management" data-secondary="creating user accounts" data-startref="ix_usrmgacc" data-type="indexterm" id="idm45657874897472"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Modifying User Accounts" data-type="sect1"><div class="sect1" id="modifying_user_accounts">
<h1>Modifying User Accounts</h1>
<p>There’s rarely such a thing as a static user account. <a contenteditable="false" data-primary="user management" data-secondary="modifying user accounts" data-type="indexterm" id="ix_usrmgmodacc"/>Therefore, the <code>usermod</code> command exists to assist you in making those required changes without editing <em>/etc/passwd</em>, a home directory, or configuration files. <a contenteditable="false" data-primary="usermod command" data-type="indexterm" id="idm45657874891568"/>The <code>usermod</code> command is the catchall for changing all things user account related. The following is an abbreviated list of modifications that you can make with the <code>usermod</code> command:</p>
<ul>
<li>
<p>Add the user to a supplementary group</p>
</li>
<li>
<p>Change the user’s comment field in <em>/etc/passwd</em></p>
</li>
<li>
<p>Change the user’s home directory</p>
</li>
<li>
<p>Set an account expiry date</p>
</li>
<li>
<p>Remove an expiry date</p>
</li>
<li>
<p>Change a user’s login name (username)</p>
</li>
<li>
<p>Lock/unlock a user’s account</p>
</li>
<li>
<p>Move the contents of a user’s home directory</p>
</li>
<li>
<p>Change a user’s login shell</p>
</li>
<li>
<p>Change a user’s ID</p>
</li>
</ul>
<p>Some of these options are more frequently used than others. For example, it’s completely reasonable to change a user’s login shell, lock and unlock an account, set or remove an expiry date, or add a user to a supplementary group. Changing a user’s ID once it’s set during account creation is rare, as is relocating a user’s home directory.<a contenteditable="false" data-primary="UIDs (user IDs)" data-secondary="changing" data-type="indexterm" id="idm45657885958272"/></p>
<p>In the following sections, I give examples of the most commonly requested user account changes. Check the man page for details if you need to alter other aspects of a user’s account.</p>
<section class="pagebreak-before" data-pdf-bookmark="Adding a Supplementary Group" data-type="sect2"><div class="sect2" id="adding_a_supplementary_group">
<h2 class="less_space">Adding a Supplementary Group</h2>
<p>When you create a new user account, the system assigns the user a user ID (UID) and a primary group ID (GID). <a contenteditable="false" data-primary="user management" data-secondary="modifying user accounts" data-tertiary="adding a supplementary group" data-type="indexterm" id="idm45657874874992"/><a contenteditable="false" data-primary="GIDs (group IDs)" data-type="indexterm" id="idm45657874879312"/><a contenteditable="false" data-primary="group IDs (GIDs)" data-type="indexterm" id="idm45657874878928"/><a contenteditable="false" data-primary="groups" data-secondary="adding supplementary group for a user" data-type="indexterm" id="idm45657874872496"/>(They can be the same sequential number, but that isn’t always the case.) For example, for the account created earlier for Jane Smith, the UID is <code>1007</code>, and the GID is <code>1007</code>:</p>
<pre data-type="programlisting">
jsmith:x:1007:1007:</pre>
<p>Jane’s primary GID is <code>1007</code>, but she might also work in an area of the company, such as IT, engineering, or application development, that requires her to have access to a group-owned directory. <a contenteditable="false" data-primary="usermod command" data-secondary="usermod -a -G" data-type="indexterm" id="idm45657874868096"/>For this exercise, Jane works in the engineering department as an associate engineer. The engineering department’s shared directory GID is <code>8020</code>. Using <code>usermod</code>, here’s how to grant Jane access to that group’s shared directory:</p>
<pre data-type="programlisting">
# usermod -a -G 8020 jsmith</pre>
<p>This adds Jane’s user account <a contenteditable="false" data-primary="/etc/group file" data-primary-sortas="etc" data-seealso="groups" data-type="indexterm" id="idm45657874863920"/>to the engineering group in the <em>/etc/group</em> file:</p>
<pre data-type="programlisting">
engineering:x:8020:bjones,kdoe,vkundra,adundee,jsmith</pre>
<p>Now Jane can access the engineering group’s shared directory. To correctly add Jane’s account to a new group, use the <code>-a</code> (append) and the <code>-G</code> (supplementary group) together. <a contenteditable="false" data-primary="-a (append) and  -G (supplementary group) options for usermod" data-primary-sortas="a" data-type="indexterm" id="idm45657874859376"/>For example, if you want Jane to access the finance department’s shared directory, you must append her to that group. When adding a user, you can use the GID number or the group’s name:</p>
<pre data-type="programlisting">
# usermod -a -G finance jsmith</pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>You must use the <code>-a</code> (append) and the <code>-G</code> (supplementary group) together. If you don’t use the <code>-a</code> option, your user will be removed from all other supplementary groups and added only to the one you specify.</p>
</div>
<p>A user can be a member of several other groups. For example, a user might be in the finance department (GID <code>8342</code>) but also require access to human resources (GID <code>8901</code>) information. You can also add a user to more than one group at once:</p>
<pre data-type="programlisting">
# usermod -a -G 8342,8901 jsmith</pre>
<p class="pagebreak-after">This command adds Jane Smith to the finance and the human resources group with a single command.</p>
</div></section>
<section data-pdf-bookmark="Changing the User Comments Field" data-type="sect2"><div class="sect2" id="changing_the_user_comments_field">
<h2 class="less_space">Changing the User Comments Field</h2>
<p>Changing the user comments (GECOS) field is a common task. <a contenteditable="false" data-primary="user comments field (GECOS)" data-type="indexterm" id="idm45657874852608"/><a contenteditable="false" data-primary="GECOS (user comments) field" data-secondary="changing" data-type="indexterm" id="idm45657874850416"/><a contenteditable="false" data-primary="user management" data-secondary="modifying user accounts" data-tertiary="changing user comments field" data-type="indexterm" id="idm45657874849184"/>You can edit the <em>/etc/passwd</em> file directly, although it comes with significant risk. The rule of thumb is that if there’s a tool to perform some action or task, you should use it rather than directly editing configuration files. You can easily change the GECOS field using the <code>usermod</code> command <a contenteditable="false" data-primary="usermod command" data-secondary="usermod -c" data-type="indexterm" id="idm45657875859856"/>and the <code>-c</code> option. </p>
<p>Let’s say the company has recently hired a second person named Jane Smith, so you need to distinguish between them by adding a middle initial to the first Jane Smith’s GECOS field:</p>
<pre data-type="programlisting">
# usermod -c "Jane R Smith" jsmith</pre>
<p>This command replaces <code>Jane Smith</code> with <code>Jane R Smith</code>.</p>
<p>The <code>-c</code> option tells the <code>usermod</code> command that you’re editing the “comments” field. <a contenteditable="false" data-primary="chfn command" data-type="indexterm" id="idm45657874843024"/>You can also change this information using the <code>chfn</code> command:</p>
<pre data-type="programlisting">
# chfn -f "Janie Smith" jsmith</pre>
<p>The <code>chfn</code> command changes your finger information. Finger is an old daemon that ran on early Unix systems and some Linux systems and supplied information about users. Almost no one uses it these days because of security issues, but the information is still referred to as finger information. The <code>-f</code> option changes the user’s full name field for the specified account. There are other options for office (<code>-o</code>), office phone (<code>-p</code>), and home phone (<code>-h</code>). Generally, only the user’s full name or the service’s name and purpose are used for the <a contenteditable="false" data-primary="GECOS (user comments) field" data-secondary="information in" data-type="indexterm" id="idm45657874836240"/>GECOS field.</p>
</div></section>
<section data-pdf-bookmark="Setting an Expiration (Expiry) Date on an Account" data-type="sect2"><div class="sect2" id="setting_an_expiration_left_parenthesise">
<h2>Setting an Expiration (Expiry) Date on an Account</h2>
<p>If a user <a contenteditable="false" data-primary="user management" data-secondary="modifying user accounts" data-tertiary="setting expiration date on account" data-type="indexterm" id="idm45657874834704"/>gives notice at a company, moves to<a contenteditable="false" data-primary="expiration (expiry) date, changing on user account" data-type="indexterm" id="idm45657874832752"/> a different business unit, or goes on parental leave, sysadmins might<a contenteditable="false" data-primary="usermod command" data-secondary="usermod -e" data-type="indexterm" id="idm45657874830336"/> decide to disable that user’s account for security reasons until the person returns or before removing the account from a system:</p>
<pre data-type="programlisting">
# usermod -e 2021-07-23 rsmith</pre>
<p>Rob Smith’s account will be disabled (expired) on the specified date in the format YYYY-MM-DD. The <code>-e</code> option sets the account for expiration.</p>
</div></section>
<section data-pdf-bookmark="Changing a User’s Login Shell" data-type="sect2"><div class="sect2" id="changing_a_userapostrophes_login_shell">
<h2>Changing a User’s Login Shell</h2>
<p>The default Linux shell is bash, but some users prefer to use a different shell, so they request that their default shell be changed to one of the many other available shell options.<a contenteditable="false" data-primary="user management" data-secondary="modifying user accounts" data-tertiary="changing user login shell" data-type="indexterm" id="idm45657874825520"/><a contenteditable="false" data-primary="login shell, changing for user" data-type="indexterm" id="idm45657875197920"/><a contenteditable="false" data-primary="shells" data-secondary="changing user’s login shell" data-type="indexterm" id="idm45657874822624"/> There are three methods of changing a user’s default shell: <code>usermod</code>, <code>chsh</code>, and directly editing <em>/etc/passwd</em>. <a contenteditable="false" data-primary="/etc/passwd file" data-primary-sortas="etc" data-secondary="direct editing not recommended" data-type="indexterm" id="idm45657874819856"/>Direct editing of the <em>/etc/passwd</em> file is not recommended.</p>
<p>The <code>usermod</code> command <a contenteditable="false" data-primary="usermod command" data-secondary="usermod -s" data-type="indexterm" id="idm45657874816768"/>method uses the <code>-s</code> option, the new shell, and the username to make the change:</p>
<pre data-type="programlisting">
# usermod -s /bin/sh jsmith</pre>
<p>The updated <em>/etc/passwd</em> file is shown here:</p>
<pre data-type="programlisting">
jsmith:x:1007:1007:Janie Smith:/home/jsmith:/bin/sh</pre>
<p>Only a user with root privileges may edit the <em>/etc/passwd</em> file or use the <code>usermod</code> command. <a contenteditable="false" data-primary="chsh command" data-type="indexterm" id="idm45657874811232"/>However, any user may change their shell with the <code>chsh</code> command:</p>
<pre data-type="programlisting">
$ chsh -s /bin/zsh
Changing shell for jsmith.
Password:
Shell changed.</pre>
<p>The resulting <em>/etc/passwd</em> entry is as follows:</p>
<pre data-type="programlisting">
jsmith:x:1007:1007:Janie Smith:/home/jsmith:/bin/zsh</pre>
<p>For other changes, consult the man page for <code>usermod</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>At the end of any man page, you’ll find a list of related <a contenteditable="false" data-primary="usermod command" data-secondary="man page and list of alternative commands" data-type="indexterm" id="idm45657874803952"/>alternative commands, links to external documentation, and configuration files referenced in the “See Also” section. These are handy to explore and might prove more efficient for making changes. The following is the “See Also” section excerpted from the <a href="https://oreil.ly/nqaH_"><code>usermod</code> man page</a>:</p>
<blockquote>
<p>See Also</p>
<p>chfn(1), chsh(1), passwd(1), crypt(3), gpasswd(8), groupadd(8), groupdel(8), groupmod(8), login.defs(5), useradd(8), userdel(8).</p>
</blockquote>
</div>
<p>Now that you’ve learned to create and modify user accounts, let’s discuss how to remove user accounts.<a contenteditable="false" data-primary="user management" data-secondary="modifying user accounts" data-startref="ix_usrmgmodacc" data-type="indexterm" id="idm45657874798288"/></p>
</div></section>
</div></section>
<section data-pdf-bookmark="Removing User Accounts" data-type="sect1"><div class="sect1" id="removing_user_accounts">
<h1>Removing User Accounts</h1>
<p>Fortunately, system administrators and developers who give names to commands do so in a way that makes them easy to remember. <a contenteditable="false" data-primary="removing user accounts" data-type="indexterm" id="idm45657874796304"/><a contenteditable="false" data-primary="user management" data-secondary="removing user accounts" data-type="indexterm" id="idm45657874794736"/>Command names often describe their functions. The <code>useradd</code> command is one such example. To remove a user account from a system, you use the <code>userdel</code> command, which is just as easy to use as <span class="keep-together"><code>useradd</code> is.<a contenteditable="false" data-primary="userdel command" data-type="indexterm" id="idm45657874793200"/></span></p>
<p class="pagebreak-before">To remove a user account from your system, issue the <code>userdel</code> command and supply the username for the account:</p>
<pre data-type="programlisting">
# userdel jsmith</pre>
<p>This command removes the user’s entry from <em>/etc/passwd</em> and from <em>/etc/shadow</em> but leaves the user’s home directory (<em>/home/jsmith</em>) intact. <a contenteditable="false" data-primary="/etc/shadow file" data-primary-sortas="etc" data-secondary="removal of user from" data-type="indexterm" id="idm45657874787296"/><a contenteditable="false" data-primary="/etc/passwd file" data-primary-sortas="etc" data-secondary="removal of user from" data-type="indexterm" id="idm45657874784544"/>Why do you think that’s a good option? <a contenteditable="false" data-primary="home directory (/home)" data-secondary="retained after removal of user account" data-type="indexterm" id="idm45657874782240"/>Sysadmins often leave a user’s home directory intact after a user has separated from a company or has changed jobs within the company but no longer requires access to a system. Retaining the user’s home directory ensures that only the root user can access any documents left by the user that might be important to the company.</p>
<p>If you make nightly backups of users’ home directories, you don’t necessarily need to retain the user’s home directory. The following <code>userdel</code> command removes the user’s home directory and all files inside it:</p>
<pre data-type="programlisting">
# userdel -r jsmith</pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Destructive Linux commands, such as <code>userdel</code> and <code>rm</code>, are irreversible and can’t be undone once executed. Always be sure that you have the correct user account before pressing the Enter key—and have good backups.</p>
</div>
<p>When it’s time to change passwords, you need to know how to force users to do it. Our next section shows you how.</p>
</div></section>
<section data-pdf-bookmark="Forcing Password Changes" data-type="sect1"><div class="sect1" id="forcing_password_changes">
<h1>Forcing Password Changes</h1>
<p>It’s a matter of trust that the user will change their password when you provide them with an initial password. <a contenteditable="false" data-primary="user management" data-secondary="forcing password changes" data-type="indexterm" id="idm45657874768560"/><a contenteditable="false" data-primary="passwords" data-secondary="forcing password changes" data-type="indexterm" id="idm45657874767792"/>Sysadmins who regularly audit their users’ passwords realize that this “honor system” level of trust doesn’t work 100% of the time. You can easily audit a user’s account settings using the <code>chage</code> command.<a contenteditable="false" data-primary="chage command" data-secondary="chage -l" data-type="indexterm" id="idm45657881140784"/> The <code>-l</code> option lists the current settings for the specified user account:</p>
<pre class="pagebreak-after" data-type="programlisting">
# chage -l rsmith
Last password change                    : Jul 17, 2021
Password expires                        : never
Password inactive                        : never
Account expires                        : never
Minimum number of days between password change    : 0
Maximum number of days between password change    : 99999
Number of days of warning before password expires    : 7</pre>
<p>As you can see, this account’s password never expires, which is a security violation that needs to be fixed. In addition to a regular forced change, you should also set a minimum change period. <a contenteditable="false" data-primary="chage command" data-secondary="chage -m  -M" data-type="indexterm" id="idm45657875261040"/>For example, as shown in the following code listing, I set the <code>rsmith</code> account to force a password change every 90 days (<code>-M 90</code>) with a minimum number of days between password changes to 1 (<code>-m 1</code>). Setting a minimum number of days ensures that users don’t change their passwords 10 times (or whatever the number of the system’s remembered passwords is set to) to reset it to their original password, which amounts to no net password change.</p>
<pre data-type="programlisting">
# chage -m 1 -M 90 rsmith

# chage -l rsmith
Last password change                    : Jul 17, 2021
Password expires                        : Oct 15, 2021
Password inactive                        : never
Account expires                        : never
Minimum number of days between password change    : 1
Maximum number of days between password change    : 90
Number of days of warning before password expires    : 7</pre>
<p>The expiration date set by the system is 90 days after the last password change. If the last password change is in the past, the user must change their password on the next login.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>From the <a href="https://oreil.ly/-NeGX"><code>chage</code> man page</a>: “The <code>chage</code> command changes the number of days between password changes and the last password change date. The system uses this information to determine when users must change their passwords.”</p>
</div>
<p>Passwords are a weak form of authentication because they can be guessed, cracked, or read in plain text if users write them down. Thus, you must ensure that passwords are changed often and not reused.</p>
</div></section>
<section data-pdf-bookmark="Handling Service Accounts" data-type="sect1"><div class="sect1" id="handling_service_accounts">
<h1>Handling Service Accounts</h1>
<p>Nothing stirs controversy among sysadmins and security administrators like the mere mention of service accounts.<a contenteditable="false" data-primary="service accounts" data-type="indexterm" id="idm45657874757872"/><a contenteditable="false" data-primary="user management" data-secondary="handling service accounts" data-type="indexterm" id="idm45657874757232"/> I’m not sure what all the controversy is about because every Linux system has more than 30 service accounts.</p>
<p>An example of a service account is the <em>nobody</em> account, which is the Kernel Overflow User account:</p>
<pre class="pagebreak-after" data-type="programlisting">
nobody:x:65534:65534:Kernel Overflow User:/:/sbin/nologin</pre>
<p>Generally, you can spot a service account because in the <em>/etc/passwd</em> file, you see that the user account has no assigned shell. <a contenteditable="false" data-primary="/sbin/nologin" data-primary-sortas="sbin" data-type="indexterm" id="idm45657874752064"/><a contenteditable="false" data-primary="/etc/passwd file" data-primary-sortas="etc" data-secondary="service accounts in" data-type="indexterm" id="idm45657874750656"/>Service accounts have <em>/sbin/nologin,</em> where the user’s shell should be. This means that the service accounts have no interactive shell or passwords. That doesn’t mean their passwords are blank or null, they simply don’t exist. In other words, if a user account has <em>/sbin/nologin</em> as their shell, they can’t log into the system with any password. <a contenteditable="false" data-primary="sudo (substitute user do) command" data-secondary="service accounts and" data-type="indexterm" id="idm45657875842752"/><a contenteditable="false" data-primary="su (substitute user) command" data-secondary="service accounts and" data-type="indexterm" id="idm45657874747024"/>And no user, not even the root user, can <code>su</code> or <code>sudo</code> to those accounts:</p>
<pre data-type="programlisting">
# su - nobody
This account is currently not available.</pre>
<p>Because service accounts have no interactive shell and no method of switching to one via <code>su</code> or <code>sudo</code>, there’s no security violation associated with having service accounts on a system. The controversy comes from the fact that some system administrators don’t know that service accounts don’t usually have interactive shells or passwords. Services may require an interactive shell account for their service to function. For those services, extreme scrutiny and other security measures should be in place to thwart potential clandestine logins on those accounts.</p>
</div></section>
<section data-pdf-bookmark="Managing Groups Rather Than Users" data-type="sect1"><div class="sect1" id="managing_groups_rather_than_users">
<h1>Managing Groups Rather Than Users</h1>
<p>When managing<a contenteditable="false" data-primary="user management" data-secondary="managing groups rather than users" data-type="indexterm" id="ix_usrmggrp"/> permissions for a set of users, it’s more convenient to define and manage a group than to manage each user separately. <a contenteditable="false" data-primary="groups" data-secondary="managing rather than users" data-type="indexterm" id="ix_grpmg"/>Group management allows you to do the following:</p>
<ul class="left-align">
<li>
<p>Manage permissions on assets such as folders and files</p>
</li>
<li>
<p>Manage permissions according to job function</p>
</li>
<li>
<p>Change permissions for a large number of users rather than for each <span class="keep-together">user individually</span></p>
</li>
<li>
<p>Easily add users to and remove users from a group’s shared folders and files</p>
</li>
<li>
<p>Restrict permissions to sensitive folders and files</p>
</li>
</ul>
<p>It’s very difficult to manage permissions for individual<a contenteditable="false" data-primary="permissions and privileged accounts" data-secondary="difficulty of managing permissions for a user" data-type="indexterm" id="idm45657874720224"/> users because if those permissions need to change, you have to trace permissions for that user on every system on which they have an account. Managing permissions for groups allows sysadmins to manage fine-grained user access on a more global level.</p>
<p>For example, if you have a user who works in the human resources (HR) department and then moves to the finance department, it’s easy to remove that user from the HR group and add them to the finance group. The user immediately has access to all shared files and folders that other finance group members do. And the user no longer has access to HR files and folders.</p>
<p>You learned earlier in this chapter how to add users to supplementary groups. You should practice adding directories to the system, adding a group account, setting that particular group ownership to the directory, and then adding users to the group. You can then <code>su - <em>username</em></code>, becoming that user to test your permissions settings.</p>
<p>The following is one possible scenario for you to work through to learn group management. This example assumes you already have a finance group and users assigned to it. Notice that during this example, the root user exits and returns to a regular account that is part of the finance group. And users can change group ownership and permissions of files they own:</p>
<pre data-type="programlisting">
$ su - root
Password:

# mkdir /opt/finance

# chgrp finance /opt/finance

# ls -la /opt
total 0
drwxr-xr-x.  3 root root     21 Aug 11 21:56 .
dr-xr-xr-x. 18 root root    239 Aug 11 21:08 ..
drwxr-xr-x.  2 root finance   6 Aug 11 21:56 finance

# chmod 770 /opt/finance

# ls -la /opt
total 0
drwxr-xr-x.  3 root root     21 Aug 11 21:56 .
dr-xr-xr-x. 18 root root    239 Aug 11 21:08 ..
drwxrwx---.  2 root finance   6 Aug 11 21:56 finance

# exit
logout

$ cd /opt/finance

$ touch budget.txt

$ ls -la
total 0
drwxrwx---. 2 root  finance 24 Aug 11 21:58 .
drwxr-xr-x. 3 root  root    21 Aug 11 21:56 ..
-rw-rw-r--. 1 khess khess    0 Aug 11 21:58 budget.txt

$ chgrp finance budget.txt

$ ls -la
total 0
drwxrwx---. 2 root  finance 24 Aug 11 21:58 .
drwxr-xr-x. 3 root  root    21 Aug 11 21:56 ..
-rw-rw-r--. 1 khess finance  0 Aug 11 21:58 budget.txt

$ chmod 660 budget.txt

$ ls -la
total 0
drwxrwx---. 2 root  finance 24 Aug 11 21:58 .
drwxr-xr-x. 3 root  root    21 Aug 11 21:56 ..
-rw-rw----. 1 khess finance  0 Aug 11 21:58 budget.txt</pre>
<p>If you understand everything that’s going on in this example, then you’re ready to move on to the next chapter. If you haven’t yet mastered these concepts, work through the chapter examples again and return to this exercise. Remember that creating users, groups, and directories and changing permissions are daily tasks for sysadmins, and practicing these skills is the only way to acquire them and become comfortable using them.<a contenteditable="false" data-primary="groups" data-secondary="managing rather than users" data-startref="ix_grpmg" data-type="indexterm" id="idm45657874718368"/><a contenteditable="false" data-primary="user management" data-secondary="managing groups rather than users" data-startref="ix_usrmggrp" data-type="indexterm" id="idm45657874976752"/></p>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id00004">
<h1>Summary</h1>
<p>This chapter taught you how to create, remove, and change user accounts. You also learned how to set up service accounts and had a brief overview of managing groups. In the next chapter, you will learn about Linux networking, from the basics of why networks are important to more-complex concepts such as network <a contenteditable="false" data-primary="user management" data-startref="ix_usrmg" data-type="indexterm" id="idm45657874700912"/>troubleshooting.</p>
</div></section>
</div></section></div></body></html>