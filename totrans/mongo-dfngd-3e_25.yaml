- en: Chapter 20\. Durability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Durability is a property of database systems that guarantees that write operations
    that have been committed to the database will survive permanently. For example,
    if a ticket reservation system reports that your concert seats have been booked,
    then your seats will remain booked even if some part of the reservation system
    crashes. For MongoDB, we need to consider durability at the cluster (or more specifically,
    replica set) level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: How MongoDB guarantees durability at the replica set member level through journaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How MongoDB guarantees durability at the cluster level using write concern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure your application and MongoDB cluster to give you the level
    of durability you need
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How MongoDB guarantees durability at the cluster level using read concern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set the durability level for transactions in replica sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this chapter, we will discuss durability in replica sets. A three-member
    replica set is the most basic cluster recommended for production applications.
    The discussion here applies to replica sets with more members and to sharded clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Durability at the Member Level Through Journaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To provide durability in the event of a server failure, MongoDB uses a write-ahead
    log (WAL) called the *journal*. A WAL is a commonly used technique for durability
    in database systems. The idea is that we simply write a representation of the
    changes to be made to the database to a durable medium (i.e., to disk) before
    applying those changes to the database itself. In many database systems, a WAL
    is used to provide the atomicity database property as well. However, MongoDB uses
    other techniques to ensure atomic writes.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning in MongoDB 4.0, as an application performs writes to a replica set,
    for the data in all replicated collections MongoDB creates journal entries using
    the same format as the oplog.^([1](ch20.xhtml#idm45882335615752)) As discussed
    in [Chapter 11](ch11.xhtml#chapter-repl-comp), MongoDB uses statement-based replication
    based on an operations log, or *oplog*. The statements in the oplog are a representation
    of the actual MongoDB changes made to each document affected by a write. Therefore,
    oplog statements are easy to apply to any member of a replica set regardless of
    version, hardware, or any other differences between replica set members. In addition,
    each oplog statement is idempotent, meaning that it can be applied any number
    of times and the outcome will always be the same change to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Like most databases, MongoDB maintains in-memory views of both the journal and
    the database data files. By default, it flushes journal entries to disk every
    50 milliseconds and flushes database files to disk every 60 seconds. The 60-second
    interval for flushing data files is called a *checkpoint*. The journal is used
    to provide durability for data written since the last checkpoint. With respect
    to durability concerns, if the server suddenly stops, when it’s restarted the
    journal can be used to replay any writes that were not flushed to disk before
    the shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: For the journal files, MongoDB creates a subdirectory named *journal* under
    the *dbPath* directory. WiredTiger (MongoDB’s default storage engine) journal
    files have names with the format *WiredTigerLog.<sequence>*, where *<sequence>*
    is a zero-padded number starting from *0000000001*. Except for very small log
    records, MongoDB compresses the data written to the journal. Journal files have
    a maximum size limit of approximately 100 MB. Once a journal file exceeds that
    limit, MongoDB creates a new journal file and begins writing new records there.
    Because journal files are only needed to recover data since the last checkpoint,
    MongoDB automatically removes “old” journal files—i.e., those written prior to
    the most recent checkpoint—once a new checkpoint is written.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a crash (or `kill -9`), *mongod* will replay its journal files on
    startup. By default, the greatest extent of lost writes are those made in the
    last 100 ms plus the time it takes to flush the journal writes to disk.
  prefs: []
  type: TYPE_NORMAL
- en: If your application requires a shorter interval for journal flushes, you have
    two options. One is to change the interval using the `--journalCommitInterval`
    option to the *mongod* command. This option accepts values ranging from 1 to 500
    ms. The other option, which we’ll look at in the next section, is to specify in
    the write concern that all writes should journal to disk. Shortening the interval
    for journaling to disk will negatively impact performance, so you need to be sure
    of the implications for your applications before changing the journaling default.
  prefs: []
  type: TYPE_NORMAL
- en: Durability at the Cluster Level Using Write Concern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With write concern, you can specify what level of acknowledgment your application
    requires in response to write requests. In a replica set, network partitions,
    server failures, or data center outages may keep writes from being replicated
    to every member, or even a majority of the members. When a normal state is restored
    to the replica set, it is possible that writes not replicated to a majority of
    members will be rolled back. In those situations, clients and the database may
    have a different view of what data has been committed.
  prefs: []
  type: TYPE_NORMAL
- en: There are applications for which it might be acceptable in some circumstances
    to have writes rolled back. For example, it might be okay to roll back a small
    number of comments in a social application of some kind. MongoDB supports a range
    of durability guarantees at the cluster level to enable application designers
    to select the durability level that works best for their use case.
  prefs: []
  type: TYPE_NORMAL
- en: The w and wtimeout Options for writeConcern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MongoDB query language supports specifying a write concern for all insert
    and update methods. As an example, suppose we have an ecommerce application and
    want to ensure that all orders are durable. Writing an order to the database might
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All insert and update methods take a second parameter, a document. Within that
    document you can specify a value for `writeConcern`. In the preceding example,
    the write concern we have specified indicates that we want to see an acknowledgment
    from the server that the write completed successfully only if the write was successfully
    replicated to a majority of the members of our application’s replica set. In addition,
    the write should return an error if it is not replicated to a majority of replica
    set members in 100 ms or less. In the case of such an error, MongoDB does not
    undo successful data modifications performed before the write concern exceeded
    the time limit—it will be up to the application to choose how to handle timeouts
    in such situations. In general, you should configure the `wtimeout` value so that
    only in unusual circumstances will the application experience timeouts and any
    actions your application takes in response to a timeout error will ensure the
    correct state for your data. In most cases, your application should attempt to
    determine whether the timeout was a result of a transient slowdown in network
    communications or something more signficant.
  prefs: []
  type: TYPE_NORMAL
- en: As the value for `w` in the write concern document, you may specify `"majority"`
    (as was done in this example). Alternatively, you may specify an integer between
    zero and the number of members in the replica set. Finally, it is possible to
    tag replica set members, say to identify those on SSDs versus spinning disks or
    those used for reporting versus OLTP workloads. You may specify a tag set as the
    value of `w` to ensure that writes will only be acknowledged once committed to
    at least one member of the replica set matching the provided tag set.
  prefs: []
  type: TYPE_NORMAL
- en: The j (Journaling) Option for writeConcern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to providing a value for the `w` option, you may also request acknowledgment
    that the write operation has been written to the journal by using the `j` option
    in the write concern document. With a value of `true` for `j`, MongoDB acknowledges
    a successful write only after the requested number of members (the value for `w`)
    have written the operation to their on-disk journal. Continuing our example, if
    we want to ensure all writes are journaled on a majority of members, we can update
    the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Without waiting for journaling, there is a brief window of about 100 ms on each
    member when, if the server process or hardware goes down, a write could be lost.
    However, waiting for journaling before acknowledging writes to members of a replica
    set does have a performance penalty.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential that in addressing durability concerns for your applications,
    you carefully evaluate the requirements your application has and weigh the performance
    impacts of the durability settings you select.
  prefs: []
  type: TYPE_NORMAL
- en: Durability at a Cluster Level Using Read Concern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In MongoDB, `read concerns` allow for the configuration of when results are
    read. This can allow clients to see write results before those writes are durable.
    A read concern can be used with a write concern to control the level of consistency
    and availability guarantees made to an application. They should not be confused
    with `read preferences`, which deal with where the data is read from; specifically,
    read preferences determine the data bearing member(s) in the replica set. The
    default `read preferences` is to read from the primary.
  prefs: []
  type: TYPE_NORMAL
- en: '`Read concern` determines the consistency and isolation properties of the data
    being read. The default `readConcern` is `local`, which returns data with no guarantees
    that the data has been written to the majority of the data bearing replica set
    members. This can result in the data being rolled back in the future. The `majority`
    concern returns only durable data (will not be rolled back) that has been acknowledged
    by the majority of replica set members. In MongoDB 3.4, the `linearizable` concern
    was added. It ensures data returned reflects all successful majority-acknowledged
    writes that have completed prior to the start of the read operation. It may wait
    for concurrently executing writes to finish before providing results.'
  prefs: []
  type: TYPE_NORMAL
- en: In the same fashion, with `write concerns` you will need to weight the performance
    impacts of the `read concerns` against the durability and isolation guarantees
    they provide before selecting the appropriate concern for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Durability of Transactions Using a Write Concern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In MongoDB, operations on individual documents are atomic. You can use embedded
    documents and arrays to express relationships between entities in a single document
    rather than using a normalized data model splitting entities and relationships
    across multiple collections. As a result, many applications do not require multi-document
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: However, for use cases that require atomicity for updates to multiple documents,
    MongoDB provides the ability to perform multi-document transactions against replica
    sets. Multi-document transactions can be used across multiple operations, documents,
    collections, and databases.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions require that all data changes within the transaction are successful.
    If any operation fails, the transaction aborts and all data changes are discarded.
    If all operations are successful, all data changes made in the transaction are
    saved and the writes become visible to future reads.
  prefs: []
  type: TYPE_NORMAL
- en: As with individual write operations, you may specify a write concern for transactions.
    You set the write concern at the transaction level, not at the individual operation
    level. At the time of the commit, transactions use the transaction-level write
    concern to commit the write operations. Write concerns set for individual operations
    inside the transaction will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set the write concern for the transaction commit at the transaction
    start. A write concern of `0` is not supported for transactions. If you use a
    write concern of `1` for a transaction, it can be rolled back if there is a failover.
    You may use a `writeConcern` of `"majority"` to ensure transactions are durable
    in the face of network and server failures that might force a failover in a replica
    set. The following provides an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What MongoDB Does Not Guarantee
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of situations where MongoDB cannot guarantee durability,
    such as if there are hardware issues or filesystem bugs. In particular, if a hard
    disk is corrupt, there is nothing MongoDB can do to protect your data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, different varieties of hardware and software may have different durability
    guarantees. For example, some cheaper or older hard disks report a write’s success
    while the write is queued up to be written, not when it has actually been written.
    MongoDB cannot defend against misreporting at this level: if the system crashes,
    data may be lost.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, MongoDB is only as safe as the underlying system: if the hardware
    or filesystem destroys the data, MongoDB cannot prevent it. Use replication to
    defend against system issues. If one machine fails, hopefully another will still
    be functioning correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: Checking for Corruption
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `validate` command can be used to check a collection for corruption. To
    run `validate` on the *movies* collection, do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The main field you’re looking for is `"valid"`, which will hopefully be `true`.
    If it is not, `validate` will give some details about the corruption it found.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the output from `validate` describes internal structures of the collection
    and timestamps used to understand the order of operations across a cluster. These
    are not particularly useful for debugging. (See [Appendix B](app02.xhtml#appendix_see)
    for more information on collection internals.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can only run `validate` on collections, and it will also check the associated
    indexes in the field `indexDetails`. However, this requires a full `validate`,
    which is configured with the `{ full: true }` option.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch20.xhtml#idm45882335615752-marker)) MongoDB uses a different format
    for writes to the local database, which stores data used in the replication process
    and other instance-specific data, but the principles and application are similar.
  prefs: []
  type: TYPE_NORMAL
