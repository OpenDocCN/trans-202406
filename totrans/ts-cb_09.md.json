["```\ntype Person = {\n  name: string;\n  age: number;\n  profession: string;\n};\n```", "```\ntype Partial<T> = { [P in keyof T]?: T[P]; };\n```", "```\ntype SelectPartial<T, K extends keyof T> = {\n  [P in K]?: T[P]\n};\n```", "```\ntype Age = SelectPartial<Person, \"age\">;\n\n// type Age = { age?: number | undefined };\n```", "```\ntype Exclude<T, U> = T extends U ? never : T;\n```", "```\n// This example shows how TypeScript evaluates a\n// helper type step by step.\n\ntype ExcludeAge = Exclude<\"name\" | \"age\", \"age\">;\n\n// 1\\. Distribute\ntype ExcludeAge =\n  \"name\" extends \"age\" ? never : \"name\" |\n  \"age\" extends \"age\" ? never : \"age\";\n\n// 2\\. Evaluate\ntype ExcludeAge = \"name\" | never;\n\n// 3\\. Remove unnecessary `never`\ntype ExcludeAge = \"name\";\n```", "```\ntype SetOptional<T, K extends keyof T> = {\n  [P in K]?: T[P];\n} &\n  {\n    [P in Exclude<keyof T, K>]: T[P];\n  };\n```", "```\ntype OptionalAge = SetOptional<Person, \"age\">;\n\n/*\ntype OptionalAge = {\n name: string;\n age?: number | undefined;\n profession: string;\n};\n*/\n```", "```\ntype OptionalAgeAndProf = SetOptional<Person, \"age\" | \"profession\">;\n```", "```\ntype SetOptional<T, K extends keyof T> = Partial<Pick<T, K>> & Omit<T, K>;\n```", "```\ntype SetOptional<T, K extends keyof T> = Remap<\n  Partial<Pick<T, K>> & Omit<T, K>\n>;\n```", "```\ntype SetOptional<T, K extends keyof T = keyof T> = Remap<\n  Partial<Pick<T, K>> & Omit<T, K>\n>;\n```", "```\ntype SetRequired<T, K extends keyof T = keyof T> = Remap<\n  Required<Pick<T, K>> & Omit<T, K>\n>;\n```", "```\ntype OnlyRequired<T, K extends keyof T = keyof T> = Remap<\n  Required<Pick<T, K>> & Partial<Omit<T, K>>\n>;\n```", "```\ntype Settings = {\n  mode: \"light\" | \"dark\";\n  playbackSpeed: number;\n  subtitles: {\n    active: boolean;\n    color: string;\n  };\n};\n\nconst defaults: Settings = {\n  mode: \"dark\",\n  playbackSpeed: 1.0,\n  subtitles: {\n    active: false,\n    color: \"white\",\n  },\n};\n```", "```\nfunction applySettings(\n  defaultSettings: Settings,\n  userSettings: Partial<Settings>\n): Settings {\n  return { ...defaultSettings, ...userSettings };\n}\n```", "```\nlet settings = applySettings(defaults, { mode: \"light\" });\n```", "```\nlet settings = applySettings(defaults, { subtitles: { active: true } });\n//                        ^\n// Property 'color' is missing in type '{ active: true; }'\n// but required in type '{ active: boolean; color: string; }'.(2741)\n```", "```\ntype DeepPartial<T> = {\n  [K in keyof T]?: DeepPartial<T[K]>;\n};\n```", "```\ntype DeepPartial<T> = T extends object\n  ? {\n      [K in keyof T]?: DeepPartial<T[K]>;\n    }\n  : T;\n```", "```\ntype DeepPartialSettings = {\n  mode?: \"light\" | \"dark\" | undefined;\n  playbackSpeed?: number | undefined;\n  subtitles?: {\n    active?: boolean | undefined;\n    color?: string | undefined;\n  } | undefined;\n};\n```", "```\nfunction applySettings(\n  defaultSettings: Settings,\n  userSettings: DeepPartial<Settings>\n): Settings {\n  return { ...defaultSettings, ...userSettings };\n//       ^\n// Type '{ mode: \"light\" | \"dark\"; playbackSpeed: number;\n//   subtitles: { active?: boolean | undefined;\n//   color?: string | undefined; }; }' is not assignable to type 'Settings'.\n}\n```", "```\nlet settings = applySettings(defaults, { subtitles: { active: true } });\n\n// results in\n\nlet settings = {\n  mode: \"dark\",\n  playbackSpeed: 1,\n  subtitles: {\n    active: true\n  }\n};\n```", "```\nimport { merge } from \"lodash\";\n\nfunction applySettings(\n  defaultSettings: Settings,\n  userSettings: DeepPartial<Settings>\n): Settings {\n  return merge(defaultSettings, userSettings)\n}\n```", "```\nfunction merge<TObject, TSource>(\n  object: TObject, source: TSource\n): TObject & TSource {\n  // ...\n}\n```", "```\ntype OnlyRequired<T, K extends keyof T = keyof T> =\n  Required<Pick<T, K>> & Partial<Omit<T, K>>;\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n  profession: string;\n};\n\ntype NameRequired = OnlyRequired<Person, \"name\">;\n```", "```\ntype Remap<T> = {\n  [K in keyof T]: T[K];\n};\n```", "```\ntype Subtitles = {\n  active: boolean;\n  color: string;\n};\n\ntype Settings = {\n  mode: \"light\" | \"dark\";\n  playbackSpeed: number;\n  subtitles: Subtitles;\n};\n```", "```\ntype DeepRemap<T> = T extends object\n  ? {\n      [K in keyof T]: DeepRemap<T[K]>;\n    }\n  : T;\n```", "```\ntype SettingsRemapped = DeepRemap<Settings>;\n\n// results in\n\ntype SettingsRemapped = {\n    mode: \"light\" | \"dark\";\n    playbackSpeed: number;\n    subtitles: {\n        active: boolean;\n        color: string;\n    };\n};\n```", "```\ntype Person = {\n  name: string;\n  age?: number;\n};\n\nfunction printPerson(person: Person): void {\n  // ...\n}\n\ntype Student = {\n  name: string;\n  semester: number;\n};\n\nconst student: Student = {\n  name: \"Stefan\",\n  semester: 37,\n};\n\nprintPerson(student); // all good!\n```", "```\ntype Name = {\n  name: string;\n};\n\ntype Test = Name extends Required<Name> ? true : false;\n// type Test = true\n```", "```\ntype Person = {\n  name: string;\n  age?: number;\n};\n\ntype Test = Person extends Required<Person> ? true : false;\n// type Test = false\n```", "```\ntype Test = Required<Person> extends Person ? true : false;\n// type Test = true\n```", "```\ntype RequiredPerson = {\n  [K in keyof Person]: Person[K] extends Required<Person[K]> ? true : false;\n};\n\n/*\ntype RequiredPerson = {\n name: true;\n age?: true | undefined;\n}\n*/\n```", "```\ntype RequiredPerson = {\n  [K in keyof Person]: Person[K] extends NonNullable<Person[K]> ? true : false;\n};\n\n/*\ntype RequiredPerson = {\n name: true;\n age?: false | undefined;\n}\n*/\n```", "```\ntype RequiredPerson = {\n  [K in keyof Person as Person[K] extends Required<Person>[K]\n    ? K\n    : never]: Person[K];\n};\n```", "```\ntype GetRequired<T> = {\n  [K in keyof T as T[K] extends Required<T>[K]\n    ? K\n    : never]: T[K];\n};\n```", "```\ntype RequiredKeys<T> = keyof GetRequired<T>;\n```", "```\ntype GetOptional<T> = Omit<T, RequiredKeys<T>>;\n```", "```\ntype VideoFormatURLs = {\n  format360p: URL;\n  format480p: URL;\n  format720p: URL;\n  format1080p: URL;\n};\n```", "```\nfunction loadVideo(formats: VideoFormatURLs) {\n  // tbd\n}\n\nloadVideo({\n  format360p: new URL(\"...\"),\n  format480p: new URL(\"...\"),\n  format720p: new URL(\"...\"),\n  format1080p: new URL(\"...\"),\n});\n```", "```\nfunction loadVideo(formats: Partial<VideoFormatURLs>) {\n  // tbd\n}\n\nloadVideo({\n  format480p: new URL(\"...\"),\n  format720p: new URL(\"...\"),\n});\n```", "```\nloadVideo({});\n```", "```\ntype AvailableVideoFormats =\n  | {\n      format360p: URL;\n    }\n  | {\n      format480p: URL;\n    }\n  | {\n      format720p: URL;\n    }\n  | {\n      format1080p: URL;\n    };\n```", "```\ntype AvailableVideoFormats =\n  | {\n      format360p: URL;\n    }\n  | {\n      format480p: URL;\n    }\n  | {\n      format720p: URL;\n    }\n  | {\n      format1080p: URL;\n    };\n```", "```\ntype AvailableVideoFormats = keyof VideoFormatURLs;\n```", "```\ntype AvailableVideoFormats = VideoFormatURLs[keyof VideoFormatURLs];\n```", "```\ntype AvailableVideoFormats = {\n  [K in keyof VideoFormatURLs]: K;\n};\n\n/* yields\ntype AvailableVideoFormats = {\n format360p: \"format360p\";\n format480p: \"format480p\";\n format720p: \"format720p\";\n format1080p: \"format1080p\";\n}; */\n```", "```\ntype AvailableVideoFormats = {\n  [K in keyof VideoFormatURLs]: {\n    [P in K]: VideoFormatURLs[P]\n  };\n};\n\n/* yields\ntype AvailableVideoFormats = {\n  format360p: {\n    format360p: URL;\n  };\n  format480p: {\n    format480p: URL;\n  };\n  format720p: {\n    format720p: URL;\n  };\n  format1080p: {\n    format1080p: URL;\n  };\n};\n```", "```\ntype AvailableVideoFormats = {\n  [K in keyof VideoFormatURLs]: {\n    [P in K]: VideoFormatURLs[P]\n  };\n}[keyof VideoFormatURLs];\n\n/* yields\ntype AvailableVideoFormats =\n | {\n format360p: URL;\n }\n | {\n format480p: URL;\n }\n | {\n format720p: URL;\n }\n | {\n format1080p: URL;\n };\n*/\n```", "```\ntype Split<T> = {\n  [K in keyof T]: {\n    [P in K]: T[P];\n  };\n}[keyof T];\n```", "```\nfunction loadVideo(formats: Split<VideoFormatURLs>) {\n  // tbd\n}\n\nloadVideo({});\n//        ^\n// Argument of type '{}' is not assignable to parameter\n// of type 'Split<VideoFormatURLs>'\n\nloadVideo({\n  format480p: new URL(\"...\"),\n}); // all good\n```", "```\ntype Split<T> = {\n  [K in keyof T]: {\n    [P in K]: T[P];\n  };\n}[keyof T];\n```", "```\ntype ExactlyOne<T> = {\n  [K in keyof T]: {\n    [P in K]: T[P];\n  } &\n    {\n      [P in Exclude<keyof T, K>]?: never; // optional never\n    };\n}[keyof T];\n```", "```\ntype ExactlyOneVideoFormat = ({\n    format360p: URL;\n} & {\n    format480p?: never;\n    format720p?: never;\n    format1080p?: never;\n}) | ({\n    format480p: URL;\n} & {\n    format360p?: never;\n    format720p?: never;\n    format1080p?: never;\n}) | ({\n    format720p: URL;\n} & {\n    format320p?: never;\n    format480p?: never;\n    format1080p?: never;\n}) | ({\n    format1080p: URL;\n} & {\n    format320p?: never;\n    format480p?: never;\n    format720p?: never;\n});\n```", "```\nfunction loadVideo(formats: ExactlyOne<VideoFormatURLs>) {\n  // tbd\n}\n\nloadVideo({\n  format360p: new URL(\"...\"),\n}); // works\n\nloadVideo({\n  format360p: new URL(\"...\"),\n  format1080p: new URL(\"...\"),\n});\n// ^\n// Argument of type '{ format360p: URL; format1080p: URL; }'\n// is not assignable to parameter of type 'ExactlyOne<VideoFormatURLs>'.\n```", "```\ntype Split<T, OptionalNever extends boolean = false> = {\n  [K in keyof T]: {\n    [P in K]: T[P];\n  } &\n    (OptionalNever extends false\n      ? {}\n      : {\n          [P in Exclude<keyof T, K>]?: never;\n        });\n}[keyof T];\n\ntype ExactlyOne<T> = Split<T, true>;\n```", "```\ntype AllOrNone<T, Keys extends keyof T> = (\n  | {\n      [K in Keys]-?: T[K]; // all available\n    }\n  | {\n      [K in Keys]?: never; // or none\n    }\n);\n```", "```\ntype AllOrNone<T, Keys extends keyof T> = (\n  | {\n      [K in Keys]-?: T[K];\n    }\n  | {\n      [K in Keys]?: never;\n    }\n) & {\n  [K in Exclude<keyof T, Keys>]: T[K] // the rest, as it was defined\n}\n```", "```\ntype AllOrNone<T, Keys extends keyof T> = (\n  | {\n      [K in Keys]-?: T[K];\n    }\n  | {\n      [K in Keys]?: never;\n    }\n) & Partial<Omit<T, Keys>>; // the rest, but optional\n```", "```\ntype AllOrNone<T, Keys extends keyof T> = (\n  | {\n      [K in Keys]-?: T[K];\n    }\n  | {\n      [K in Keys]?: never;\n    }\n) & Split<T>;\n```", "```\nfunction loadVideo(\n  formats: AllOrNone<VideoFormatURLs, \"format360p\" | \"format480p\">\n) {\n  // TBD\n}\n\nloadVideo({\n  format360p: new URL(\"...\"),\n  format480p: new URL(\"...\"),\n}); // OK\n\nloadVideo({\n  format360p: new URL(\"...\"),\n  format480p: new URL(\"...\"),\n  format1080p: new URL(\"...\"),\n}); // OK\n\nloadVideo({\n  format1080p: new URL(\"...\"),\n}); // OK\n\nloadVideo({\n  format360p: new URL(\"...\"),\n  format1080p: new URL(\"...\"),\n});\n// ^ Argument of type '{ format360p: URL; format1080p: URL; }' is\n// not assignable to parameter of type\n// '({ format360p: URL; format480p: URL; } & ... (abbreviated)\n```", "```\ntype AllOrNone<T, Keys extends keyof T> = (\n  | Required<Pick<T, Keys>>\n  | Partial<Record<Keys, never>>\n) &\n  Split<T>;\n```", "```\ntype BasicVideoData = {\n  // tbd\n};\n\ntype Format320 = { urls: { format320p: URL } };\ntype Format480 = { urls: { format480p: URL } };\ntype Format720 = { urls: { format720p: URL } };\ntype Format1080 = { urls: { format1080p: URL } };\n\ntype Video = BasicVideoData & (Format320 | Format480 | Format720 | Format1080);\n```", "```\nconst video1: Video = {\n  // ...\n  urls: {\n    format320p: new URL(\"https://...\"),\n  },\n}; // OK\n\nconst video2: Video = {\n  // ...\n  urls: {\n    format320p: new URL(\"https://...\"),\n    format480p: new URL(\"https://...\"),\n  },\n}; // OK\n\nconst video3: Video = {\n  // ...\n  urls: {\n    format1080p: new URL(\"https://...\"),\n  },\n}; // OK\n```", "```\ntype FormatKeys = keyof Video[\"urls\"];\n// FormatKeys = never\n\n// This is not what we want here!\nfunction selectFormat(format: FormatKeys): void {\n  // tbd.\n}\n```", "```\ntype Video = BasicVideoData & {\n  urls: {\n    format320p: URL;\n    format480p: URL;\n    format720p: URL;\n    format1080p: URL;\n  };\n};\n\ntype FormatKeys = keyof Video[\"urls\"];\n// type FormatKeys =\n//   \"format320p\" | \"format480p\" | \"format720p\" | \"format1080p\";\n```", "```\ntype UnionToIntersection<T> =\n  (T extends any ? (x: T) => any : never) extends\n  (x: infer R) => any ? R : never;\n```", "```\ntype UnionToIntersection<T> =\n  (T extends any ? (x: T) => any : never) //...\n```", "```\ntype Naked<T> = T extends ...; // a naked type\n\ntype NotNaked<T> = { o: T } extends ...; // a non-naked type\n```", "```\ntype WrapNaked<T> =  T extends any ? { o: T } : never;\n\ntype Foo = WrapNaked<string | number | boolean>;\n\n// A naked type, so this equals to\n\ntype Foo =\n  WrapNaked<string> | WrapNaked<number> | WrapNaked<boolean>;\n\n// equals to\n\ntype Foo =\n  string extends any ? { o: string } : never |\n  number extends any ? { o: number } : never |\n  boolean extends any ? { o: boolean } : never;\n\ntype Foo =\n  { o: string } | { o: number } | { o: boolean };\n```", "```\ntype WrapNaked<T> = { o: T } extends any ? { o: T } : never;\n\ntype Foo = WrapNaked<string | number | boolean>;\n\n// A non-naked type, so this equals to\n\ntype Foo =\n  { o: string | number | boolean } extends any ?\n  { o: string | number | boolean } : never;\n\ntype Foo = { o: string | number | boolean };\n```", "```\ntype UnionToIntersection<T> =\n  (T extends any ? (x: T) => any : never) //...\n```", "```\ntype UnionToIntersection<T> =\n  (T extends any ? (x: T) => any : never) extends\n  (x: infer R) => any ? R : never\n```", "```\ndeclare let b: string;\ndeclare let c: string | number;\n\nc = b // OK\n```", "```\ntype Fun<X> = (...args: X[]) => void;\n\ndeclare let f: Fun<string>;\ndeclare let g: Fun<string | number>;\n\ng = f // this cannot be assigned\n```", "```\ntype UnionToIntersection<T> =\n  (T extends any ? (x: T) => any : never) extends\n  (x: infer R) => any ? R : never;\n\ntype Intersected = UnionToIntersection<Video[\"urls\"]>;\n\n// equals to\n\ntype Intersected = UnionToIntersection<\n  { format320p: URL } |\n  { format480p: URL } |\n  { format720p: URL } |\n  { format1080p: URL }\n>;\n```", "```\ntype Intersected =\n  | UnionToIntersection<{ format320p: URL }>\n  | UnionToIntersection<{ format480p: URL }>\n  | UnionToIntersection<{ format720p: URL }>\n  | UnionToIntersection<{ format1080p: URL }>;\n```", "```\ntype Intersected =\n  | ({ format320p: URL } extends any ?\n      (x: { format320p: URL }) => any : never) extends\n      (x: infer R) => any ? R : never\n  | ({ format480p: URL } extends any ?\n      (x: { format480p: URL }) => any : never) extends\n      (x: infer R) => any ? R : never\n  | ({ format720p: URL } extends any ?\n      (x: { format720p: URL }) => any : never) extends\n      (x: infer R) => any ? R : never\n  | ({ format1080p: URL } extends any ?\n     (x: { format1080p: URL }) => any : never) extends\n      (x: infer R) => any ? R : never;\n```", "```\ntype Intersected =\n  | ((x: { format320p: URL }) => any) extends (x: infer R) => any ? R : never\n  | ((x: { format480p: URL }) => any) extends (x: infer R) => any ? R : never\n  | ((x: { format720p: URL }) => any) extends (x: infer R) => any ? R : never\n  | ((x: { format1080p: URL }) => any) extends (x: infer R) => any ? R : never;\n```", "```\ntype Intersected =\n  | { format320p: URL } | { format480p: URL }\n  | { format720p: URL } | { format1080p: URL };\n```", "```\ntype Intersected =\n  { format320p: URL } & { format480p: URL } &\n  { format720p: URL } & { format1080p: URL };\n```", "```\ntype FormatKeys = keyof UnionToIntersection<Video[\"urls\"]>;\n```", "```\n/**\nA `number` that is an integer.\nYou can't pass a `bigint` as they are already guaranteed to be integers.\nUse-case: Validating and documenting parameters.\n\n@example\n```", "```\n@see NegativeInteger\n@see NonNegativeInteger\n@category Numeric\n*/\n// `${bigint}` is a type that matches a valid bigint\n// literal without the `n` (ex. 1, 0b1, 0o1, 0x1)\n// Because T is a number and not a string we can effectively use\n// this to filter out any numbers containing decimal points\n\nexport type Integer<T extends number> = `${T}` extends `${bigint}` ? T : never;\n```", "```\nexport type PartialDeep<T, Opts extends PartialDeepOptions = {}> =\n  T extends BuiltIns\n  ? T\n  : T extends Map<infer KeyType, infer ValueType>\n    ? PartialMapDeep<KeyType, ValueType, Opts>\n    : T extends Set<infer ItemType>\n      ? PartialSetDeep<ItemType, Opts>\n      : T extends ReadonlyMap<infer KeyType, infer ValueType>\n        ? PartialReadonlyMapDeep<KeyType, ValueType, Opts>\n        : T extends ReadonlySet<infer ItemType>\n          ? PartialReadonlySetDeep<ItemType, Opts>\n          : T extends ((...arguments: any[]) => unknown)\n            ? T | undefined\n            : T extends object\n              ? T extends ReadonlyArray<infer ItemType>\n                ? Opts['recurseIntoArrays'] extends true\n                  ? ItemType[] extends T\n                    ? readonly ItemType[] extends T\n                      ? ReadonlyArray<PartialDeep<ItemType | undefined, Opts>>\n                      : Array<PartialDeep<ItemType | undefined, Opts>>\n                    : PartialObjectDeep<T, Opts>\n                  : T\n                : PartialObjectDeep<T, Opts>\n              : unknown;\n\n/**\nSame as `PartialDeep`, but accepts only `Map`s and as inputs.\nInternal helper for `PartialDeep`.\n*/\ntype PartialMapDeep<KeyType, ValueType, Options extends PartialDeepOptions> =\n  {} & Map<PartialDeep<KeyType, Options>, PartialDeep<ValueType, Options>>;\n\n/**\nSame as `PartialDeep`, but accepts only `Set`s as inputs.\nInternal helper for `PartialDeep`.\n*/\ntype PartialSetDeep<T, Options extends PartialDeepOptions> =\n  {} & Set<PartialDeep<T, Options>>;\n\n/**\nSame as `PartialDeep`, but accepts only `ReadonlyMap`s as inputs.\nInternal helper for `PartialDeep`.\n*/\ntype PartialReadonlyMapDeep<\n  KeyType, ValueType,\n  Options extends PartialDeepOptions\n> = {} & ReadonlyMap<\n    PartialDeep<KeyType, Options>,\n    PartialDeep<ValueType, Options>\n  >;\n\n/**\nSame as `PartialDeep`, but accepts only `ReadonlySet`s as inputs.\nInternal helper for `PartialDeep`.\n*/\ntype PartialReadonlySetDeep<T, Options extends PartialDeepOptions> =\n  {} & ReadonlySet<PartialDeep<T, Options>>;\n\n/**\nSame as `PartialDeep`, but accepts only `object`s as inputs.\nInternal helper for `PartialDeep`.\n*/\ntype PartialObjectDeep<\n  ObjectType extends object,\n  Options extends PartialDeepOptions\n> = {\n  [KeyType in keyof ObjectType]?: PartialDeep<ObjectType[KeyType], Options>\n};\n```"]