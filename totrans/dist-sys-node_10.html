<html><head></head><body><section data-pdf-bookmark="Chapter 9. Distributed Primitives" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_primitives">&#13;
<h1><span class="label">Chapter 9. </span>Distributed Primitives</h1>&#13;
&#13;
&#13;
<p>Data primitives are rather straightforward when dealing with a single-threaded program. Want to make a lock? Just use <a data-primary="distributed primitives" data-type="indexterm" id="idm46291175150792"/><a data-primary="primitives" data-type="indexterm" id="idm46291175150088"/>a boolean. Want a key/value store? A <code>Map</code> instance is your friend. Want to keep an ordered list of data? Reach for an array. When only a single thread reads and writes to an array, it’s as simple as calling <code>Array#push()</code> and <code>Array#pop()</code>. In this situation, the array instance is the complete source of truth. There are no other copies that can get out of sync, no messages in transit that can be received out of order. Persisting the data to disk is as easy as calling <code>JSON.stringify()</code> and <code>fs.writeFileSync()</code>.</p>&#13;
&#13;
<p>Unfortunately, the performance impact of such an approach is huge, and scaling to a sizeable userbase is nearly impossible. Not to mention such a system has a single point of failure! Instead, as you’ve seen throughout this book, the answer to performance and avoiding a single point of failure depends on redundant distributed processes. Care must be put into the storage and manipulation of data, particularly when it comes to distributed systems.</p>&#13;
&#13;
<p>Not every problem can be solved using the same data store. Depending on the data requirements—such as entity relationships, the amount of data, and requirements with consistency, durability, and latency—different solutions must be chosen. It’s not uncommon for an application composed of distributed services to require several data storage tools. Sometimes you need a graph database and sometimes you need a document store, but more often than not you might just need a relational database.</p>&#13;
&#13;
<p>This chapter covers several different data primitives, ones that are easy to represent in a single Node.js process, and shows how they may be modeled in a distributed system. While there are many different tools that can be used to implement various primitives, this chapter focuses on using just one of them. But before diving in, it’s useful to first explore a problem that might seem easy to model with a single instance but ends up being rather complex when modeled in a distributed environment.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The ID Generation Problem" data-type="sect1"><div class="sect1" id="ch_primitives_sec_id">&#13;
<h1>The ID Generation Problem</h1>&#13;
&#13;
<p>Not long ago I found myself on the <a data-primary="primitives" data-secondary="ID generation" data-type="indexterm" id="prim_idgen"/><a data-primary="ID generation" data-type="indexterm" id="prim_idgen1"/>receiving end of several job interviews. This batch of interviews was the most that I’ve ever had to go through in such a short period of time. Ironically, the purpose wasn’t even so that I could find a new job, but that’s a story for another day. During this round of interviews I was asked the same question by multiple companies. This might even be a question that you’ve received yourself:</p>&#13;
<blockquote>&#13;
<p>“How would you design a link shortening service?”</p>&#13;
<p data-type="attribution">Seemingly every Silicon Valley tech company</p>&#13;
</blockquote>&#13;
&#13;
<p>You might already know the song <a data-primary="link shortening" data-type="indexterm" id="idm46291175137320"/>and dance, but just in case you don’t, it goes a little like this: a link shortener is an HTTP service where a user agent can make a request to a short URL (such as <em>http://sho.rt/3cUzamh</em>), and the request will be redirected to a longer URL (like <em>http://example.org/foo/bar?id=123</em>). First, the candidate is supposed to ask a bunch of questions. “How many users will use the service? How long should the short URL be? Is it okay if a user is able to guess a short URL?” Once that’s done, the interviewer takes some notes, and the candidate hits the whiteboard, where they begin drawing architecture diagrams and writing pseudocode.</p>&#13;
&#13;
<p>There are a lot of facets to grading the candidate, and usually the interviewer isn’t so much looking for the perfect answer as they are looking for the candidate to reveal the depth of their computer science knowledge (“…and here we need a DNS server…” or “…a NoSQL key/value store might make more sense than a relational store due to…” or “…a cache for frequently used URLs…”). The part of this question I find most interesting is this: how do you generate IDs used for the short URL?</p>&#13;
&#13;
<p>Ultimately the URL IDs represent a key, and the associated value contains the original full URL. Whether or not the secrecy of the short URL is a requirement, the system will be built differently. Either way, the implications in a distributed environment are pretty similar. For the sake of argument, it’s acceptable in this situation for URLs to be guessable by users. With this requirement it’s then acceptable to have an identifier that is a counter, essentially incrementing from 1 until the service is sunset. Usually there’s some sort of encoding involved to make the URL more efficient. For example, hexadecimal (<code>0-9A-F</code>) allows for representing 16 unique values per byte instead of the 10 values offered by decimal (<code>0-9</code>). Base62 allows for representing 62 unique values per byte (<code>0-9a-zA-Z</code>). For simplicity purposes I’ll just discuss these identifiers in decimal, but in a real system they’d be encoded to save space.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex_link_shortener">Example 9-1</a> demonstrates how this link shortener could be built using a single Node.js process.</p>&#13;
<div data-type="example" id="ex_link_shortener">&#13;
<h5><span class="label">Example 9-1. </span><em>link-shortener.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fs'</code><code class="p">);</code>&#13;
<code class="nx">fs</code><code class="p">.</code><code class="nx">writeFileSync</code><code class="p">(</code><code class="s1">'/tmp/count.txt'</code><code class="p">,</code> <code class="s1">'0'</code><code class="p">);</code> <code class="c1">// only run once</code>&#13;
<code class="kd">function</code> <code class="nx">setUrl</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">id</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">fs</code><code class="p">.</code><code class="nx">readFileSync</code><code class="p">(</code><code class="s1">'/tmp/count.txt'</code><code class="p">).</code><code class="nx">toString</code><code class="p">())</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>&#13;
  <code class="nx">fs</code><code class="p">.</code><code class="nx">writeFileSync</code><code class="p">(</code><code class="s1">'/tmp/count.txt'</code><code class="p">,</code> <code class="nb">String</code><code class="p">(</code><code class="nx">id</code><code class="p">));</code>&#13;
  <code class="nx">fs</code><code class="p">.</code><code class="nx">writeFileSync</code><code class="p">(</code><code class="sb">`/tmp/</code><code class="si">${</code><code class="nx">id</code><code class="si">}</code><code class="sb">.txt`</code><code class="p">,</code> <code class="nx">url</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="sb">`sho.rt/</code><code class="si">${</code><code class="nx">id</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="kd">function</code> <code class="nx">getUrl</code><code class="p">(</code><code class="nx">code</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFileSync</code><code class="p">(</code><code class="sb">`/tmp/</code><code class="si">${</code><code class="nx">code</code><code class="si">}</code><code class="sb">.txt`</code><code class="p">).</code><code class="nx">toString</code><code class="p">();</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>A single-threaded approach can’t get much simpler than that (at the expense of any error handling). When it comes to setting a link, the identifier for the URL is a number, the identifier is mapped to the full URL, and any call to <code>setUrl()</code> with the full URL will atomically write the URL to disk and return with the identifier used to represent the URL. To get the link, the appropriate file is read. Two primitives are required to build this link shortener. The first is a counter (the <code>counter</code> variable), and the second is a map (the files stored in <em>/tmp/</em>). <a data-type="xref" href="#fig_single_thread_get_set">Figure 9-1</a> visualizes how the two <code>setUrl()</code> and <code>getUrl()</code> operations work on a timeline.</p>&#13;
&#13;
<figure><div class="figure" id="fig_single_thread_get_set">&#13;
<img alt="The setUrl() method uses both the counter and the map, while the getUrl() method only uses the map." src="assets/dsnj_0901.png"/>&#13;
<h6><span class="label">Figure 9-1. </span>Single-threaded <code>get</code> and <code>set</code> operations</h6>&#13;
</div></figure>&#13;
&#13;
<p>This diagram breaks up the operations in the single-threaded Node.js application into different lanes representing the primitive being consulted. In this case, the <em>client</em> lane represents an outside entity calling the two methods. If the code sample exposed a web server, then the client could very well be an external client. The <em>logic</em> lane represents the coordination logic around the primitives; basically it represents the JavaScript code itself. The <em>counter</em> lane represents interaction with the counter primitive, and the <em>map</em> lane represents interaction<a data-primary="setUrl() function" data-type="indexterm" id="idm46291175000232"/><a data-primary="functions" data-secondary="setUrl()" data-type="indexterm" id="idm46291174999640"/><a data-primary="getUrl() function" data-type="indexterm" id="idm46291174998696"/><a data-primary="functions" data-secondary="getUrl()" data-type="indexterm" id="idm46291174998024"/> with the map primitive. Only the <code>setUrl()</code> method needs to access the counter; the <code>getUrl()</code> method is much simpler and only reads from the map.</p>&#13;
&#13;
<p>Other than the lack of error handling, this code is technically fine for a single-threaded service. But throw in a second service instance, and the application is completely broken. In particular, the identifier increment is not atomic. Three steps are required to increment: the first is to read the counter value, the second is to increment the value, and the third is to write the value back to persistent storage. If two separate services receive a request at the same time, they’ll both read the same id value (such as 100), they’ll both increment the value (to 101), and they’ll both write the same value to disk (101). They’ll also both write to the same file (<em>101.txt</em>), and the second process to write will then clobber the value written by the first process.</p>&#13;
&#13;
<p>One way to fix this is with another <a data-primary="primitives" data-secondary="locks" data-type="indexterm" id="idm46291174994232"/><a data-primary="locks" data-type="indexterm" id="idm46291174993256"/>primitive, called a lock, though it will introduce a lot of complexity. A lock is essentially a Boolean value. If the value is true, then a resource is locked by one client and should be considered read-only by other clients. If the value is false, then the resource is not locked and a client is to try to set a lock. A lock can be implemented using the filesystem by attempting to create a file, but only if the file doesn’t already exist. This can be done using the <code>wx</code> flag when writing a file:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">fs</code><code class="p">.</code><code class="nx">writeFileSync</code><code class="p">(</code><code class="s1">'/tmp/lock.txt'</code><code class="p">,</code> <code class="s1">''</code><code class="p">,</code> <code class="p">{</code> <code class="nx">flag</code><code class="o">:</code> <code class="s1">'wx'</code> <code class="p">});</code></pre>&#13;
&#13;
<p>Assuming the file doesn’t already exist, this code will create an empty file named <em>lock.txt</em> and will continue running. At that point the application is free to grab the counter value, increment the value, write the counter value again, and release the lock by deleting the lock file with <code>fs.unlinkSync()</code>. However, if the file does exist, then the application needs to do something a little different. For example, the call to <code>fs.writeFileSync()</code> can be made inside of a <code>while</code> loop. If the call throws an error, then catch the error and continue looping. Eventually, the other program should &#13;
<span class="keep-together">finish</span> writing to the counter and will release the lock, at which point the call should &#13;
<span class="keep-together">succeed.</span></p>&#13;
&#13;
<p>Sounds a little far-fetched, I know, but that’s essentially what happens under the hood with multithreaded programming. This loop while waiting for a lock to be unlocked is called a <em>spinlock</em>. What <a data-primary="spinlocks" data-type="indexterm" id="idm46291174972344"/><a data-primary="deadlocks" data-type="indexterm" id="idm46291174971608"/>happens if a client crashes and doesn’t release a lock? The other client would then sit there waiting forever! In more complex situations involving multiple locks, program instance A and program instance B might end up stuck while they wait for each other to release a lock. When this happens it’s called a <em>deadlock</em>. Manually maintaining locks like this in application code is risky business.</p>&#13;
&#13;
<p>This section covered just one situation where a data primitive is made more complex by moving from a single instance to a distributed system, and as you might have imagined, there are many more situations left for you to discover. Now that you’re familiar with how distributed primitives can be complex, you’re ready to get your hands dirty with <a data-primary="primitives" data-secondary="ID generation" data-startref="prim_idgen" data-type="indexterm" id="idm46291174969320"/><a data-primary="ID generation" data-startref="prim_idgen1" data-type="indexterm" id="idm46291174968072"/>a service built to store primitives in a distributed environment.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introduction to Redis" data-type="sect1"><div class="sect1" id="ch_primitives_sec_redis">&#13;
<h1>Introduction to Redis</h1>&#13;
&#13;
<p>Redis is a powerful service <a data-primary="Redis" data-type="indexterm" id="red"/>exposing several useful data structures while providing many different commands to interact with them. Redis has a limitation that many alternative data storage services don’t: the data stored in a Redis instance must fit completely in memory. For this reason, it’s often passed over when considering tools to act as a primary data store—that is, a service to act as the source of truth. More often than not it is pigeonholed into merely serving as a cache.</p>&#13;
&#13;
<p>To truly integrate Redis into your arsenal, and not just treat it as another cache, you must leverage the unique querying capabilities it offers. To do this, you may need to store a subset of data from your primary backing store (such as Postgres) within Redis. Redis often allows for data to be queried in fast and unique ways that other database systems don’t necessarily support.</p>&#13;
&#13;
<p>For example, Redis supports a geospatial <a data-primary="geolocation, Redis" data-type="indexterm" id="idm46291174962248"/>data type. This data type stores a list of latitude and longitude pairs associated with an identifier. The identifier can be used to reference a primary key in the primary data store. This geospatial data structure can be queried to get a list of all IDs belonging to records within a configurable distance of a provided latitude and longitude pair. In this case, by querying Redis with a user’s location, a query can be made to look up entries with the matching identifiers. With this approach, Redis only stores a copy of the identifiers and geolocation; the primary backing store contains all that data and more. Since Redis only has a subset of data &#13;
<span class="keep-together">in this</span> situation, it can be rebuilt using the data in the primary store if Redis were &#13;
<span class="keep-together">to crash.</span></p>&#13;
&#13;
<p>Redis is similar to Node.js in some regards. The commands <a data-primary="Redis" data-secondary="commands" data-type="indexterm" id="idm46291174959112"/><a data-primary="commands" data-secondary="Redis" data-type="indexterm" id="idm46291174958136"/>that are run within Redis happen in a single-threaded manner, with one command always sequentially running after another command. However, the fringes of the service do support some multi-threading, such as I/O when data is read from the network or persisted to disk. Essentially, a single Redis instance is single-threaded. However, Redis can be run as part of a cluster, which helps overcome the memory limitation. Three Redis instances with access to 2GB of memory will be able to store a collective of 6GB of data.</p>&#13;
&#13;
<p>Run the following command to start a Redis server on your machine:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>docker run -it --rm <code class="se">\</code>&#13;
  --name distnode-redis <code class="se">\</code>&#13;
  -p 6379:6379 <code class="se">\</code>&#13;
  redis:6.0.5-alpine</pre>&#13;
&#13;
<p>This command runs Redis while exposing the default port of <code>6379</code>, tying up the terminal window until the server is killed. The server will only display information about the most important operations that happen, such as a server shutdown or when data is written to disk.</p>&#13;
&#13;
<p>The protocol used by Redis <a data-primary="protocols" data-secondary="Redis" data-type="indexterm" id="idm46291174952344"/><a data-primary="Redis" data-secondary="protocols" data-type="indexterm" id="idm46291174888504"/>is extremely simple and is mostly based on sending plain text over the network. Execute the following netcat command to <a data-primary="netcat command" data-type="indexterm" id="idm46291174887288"/><a data-primary="commands" data-secondary="netcat" data-type="indexterm" id="idm46291174886616"/>illustrate this:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code><code class="nb">echo</code> <code class="s2">"PING\r\nQUIT\r\n"</code> <code class="p">|</code> nc localhost 6379&#13;
&gt; +PONG&#13;
&gt; +OK</pre>&#13;
&#13;
<p>In this case, two commands were sent to Redis. The first is <a data-primary="PING Redis command" data-type="indexterm" id="idm46291174881992"/><a data-primary="commands" data-secondary="Redis" data-tertiary="PING" data-type="indexterm" id="idm46291174881384"/><a data-primary="Redis" data-secondary="commands" data-tertiary="PING" data-type="indexterm" id="idm46291174879432"/><a data-primary="QUIT Redis command" data-type="indexterm" id="idm46291174878216"/><a data-primary="commands" data-secondary="Redis" data-tertiary="QUIT" data-type="indexterm" id="idm46291174877544"/><a data-primary="Redis" data-secondary="commands" data-tertiary="QUIT" data-type="indexterm" id="idm46291174876328"/>the <code>PING</code> command and the second is <code>QUIT</code>. The commands are separated by carriage return and linefeed characters to differentiate one command from another. Commands can be combined like this, a feature called pipelining, or they can exist as separate TCP messages. The two responses correlate to the two commands. The <code>QUIT</code> command also instructs the Redis server to close the TCP connection. If you received an error while running this command, check to see if your Redis Docker command is formatted properly.</p>&#13;
&#13;
<p>Echoing text directly over TCP isn’t the easiest way to interact with a service. Redis comes with a REPL that can be used by running the <code>redis-cli</code> command <a data-primary="redis-cli command" data-type="indexterm" id="idm46291174848360"/><a data-primary="commands" data-secondary="redis-cli" data-type="indexterm" id="idm46291174847624"/>inside of the container. The REPL provides some basic autocomplete and coloration features. Run the following command in your terminal to start an interactive Redis REPL:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>docker <code class="nb">exec</code> -it <code class="se">\</code>&#13;
  distnode-redis <code class="se">\</code>&#13;
  redis-cli</pre>&#13;
&#13;
<p>Once you have the REPL up and running, type the command <strong><code>INFO server</code></strong> and press enter. You should then see some information about the server as a response. With your Redis server running and your REPL connected, you’re now ready to experiment with the capabilities <a data-primary="Redis" data-startref="red" data-type="indexterm" id="idm46291174844072"/>of the server.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Redis Operations" data-type="sect1"><div class="sect1" id="idm46291174966408">&#13;
<h1>Redis Operations</h1>&#13;
&#13;
<p>Redis stores data using <a data-primary="Redis" data-secondary="operations" data-type="indexterm" id="red_op"/>key/value pairs. Each key contains data of a specific type, and depending on the data type, different commands may be used to interact with a given key. As of Redis 6, there are over 250 commands available!</p>&#13;
&#13;
<p>When using Redis in a cluster, the name of the key is hashed to determine which Redis instance holds a particular key, a <a data-primary="sharding" data-type="indexterm" id="idm46291174838184"/>technique called <em>sharding</em>. It’s possible to perform operations that deal with multiple keys, but only if those keys all happen to reside in the same instance. Keep this in mind when modeling your data. In this section, you’re going to work with a single Redis instance.</p>&#13;
&#13;
<p>A Redis key is a string <a data-primary="Redis" data-secondary="keys" data-type="indexterm" id="idm46291174836248"/><a data-primary="keys" data-secondary="Redis keys" data-type="indexterm" id="idm46291174835272"/>that can contain binary data, but using a reduced encoding like ASCII<sup><a data-type="noteref" href="ch09.html#idm46291174815176" id="idm46291174815176-marker">1</a></sup> might make application development easier. Since key names are a single string, it’s fairly common for them to contain a compound set of information. For example, a key representing a user might look like <code>user:123</code>, while a key representing the friends of a user might instead resemble <code>user:123:friends</code>. Keys are unique across a Redis database. It’s important to come up with a naming convention ahead of time because any client using the Redis database will need to generate names in the same manner, and unrelated entities shouldn’t have a name collision.</p>&#13;
&#13;
<p>There is metadata attached to every key regardless of the type of data it contains. This includes data like access time, which is useful for cache expiration when the server is configured as an LRU cache, as well as a TTL value, which allows a key to be expired at a specified time.</p>&#13;
&#13;
<p>Create a new directory named <em>redis</em>. In this directory, initialize a new npm project and install the <code>ioredis</code> dependency:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>mkdir redis <code class="o">&amp;&amp;</code> <code class="nb">cd </code>redis&#13;
<code class="nv">$ </code>npm init -y&#13;
<code class="nv">$ </code>npm install ioredis@4.17</pre>&#13;
&#13;
<p>While you’re in the directory, create a new file named <em>basic.js</em>. Add the content from <a data-type="xref" href="#ex_redis_basic">Example 9-2</a> to the file.</p>&#13;
<div data-type="example" id="ex_redis_basic">&#13;
<h5><span class="label">Example 9-2. </span><em>redis/basic.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node</code>&#13;
<code class="c1">// npm install ioredis@4.17</code>&#13;
<code class="kr">const</code> <code class="nx">Redis</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'ioredis'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">redis</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Redis</code><code class="p">(</code><code class="s1">'localhost:6379'</code><code class="p">);</code>&#13;
&#13;
<code class="p">(</code><code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">await</code> <code class="nx">redis</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'foo'</code><code class="p">,</code> <code class="s1">'bar'</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">redis</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'foo'</code><code class="p">);</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'result:'</code><code class="p">,</code> <code class="nx">result</code><code class="p">);</code>&#13;
  <code class="nx">redis</code><code class="p">.</code><code class="nx">quit</code><code class="p">();</code>&#13;
<code class="p">})();</code></pre></div>&#13;
&#13;
<p>The <code>ioredis</code> package <a data-primary="ioredis package" data-type="indexterm" id="idm46291174702424"/><a data-primary="packages" data-secondary="ioredis" data-type="indexterm" id="idm46291174701816"/>exposes methods on the <code>redis</code> object named after the equivalent Redis command. In this case, the <code>redis.get()</code> method <a data-primary="redis.get() method" data-type="indexterm" id="idm46291174699912"/><a data-primary="methods" data-secondary="redis.get()" data-type="indexterm" id="idm46291174699176"/>correlates to the Redis <code>GET</code> command. Arguments passed into these methods then correlate to arguments passed to the underlying Redis command. In this case, the <code>redis.set('foo', 'bar')</code> call in JavaScript results in the <code>SET foo bar</code> command being run in Redis.</p>&#13;
&#13;
<p>Next, execute the file:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>node redis/basic.js&#13;
&gt; result: bar</pre>&#13;
&#13;
<p>If you get the same response, your application was able to successfully communicate with the Redis server. If you receive a connection error, then check the command you used to start the Docker container and ensure the connection string is formatted &#13;
<span class="keep-together">correctly.</span></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>One thing you might have noticed is that the application doesn’t wait for a connection to Redis before sending commands. Internally the <code>ioredis</code> package queues up commands until the connection is ready before dispatching them. This is a convenient pattern used by many database packages. Sending too many commands when an application first runs might constrain resources.</p>&#13;
</div>&#13;
&#13;
<p>The remainder of this section is dedicated to common <a class="orm:hideurl" href="https://redis.io/commands">Redis commands</a>, categorized by the data types they work with. Familiarizing yourself with them will give you an understanding of the capabilities of Redis. If you would like to run them, you can either modify the <em>redis/basic.js</em> script you made or paste <a data-primary="Redis" data-secondary="operations" data-startref="red_op" data-type="indexterm" id="idm46291174688392"/>commands into the Redis REPL that you should still have open.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Strings" data-type="sect2"><div class="sect2" id="idm46291174686888">&#13;
<h2>Strings</h2>&#13;
&#13;
<p>Strings store binary data and <a data-primary="strings, Redis" data-type="indexterm" id="stringRed"/><a data-primary="Redis" data-secondary="strings" data-type="indexterm" id="stringRed1"/>are the most basic data type available in Redis. In a sense, this is the only data type offered by Memcached, a competing cache service. &#13;
<span class="keep-together">If you</span> strictly use Redis as a cache, then you might not ever need to touch another &#13;
<span class="keep-together">data type.</span></p>&#13;
&#13;
<p>The most basic operations that can be performed on a string are to set a value and to get the value. Switch back to your Redis REPL and run the following command:</p>&#13;
&#13;
<pre data-type="programlisting">SET foo "bar"</pre>&#13;
&#13;
<p>When you type <a data-primary="SET Redis command" data-type="indexterm" id="idm46291174661064"/><a data-primary="commands" data-secondary="Redis" data-tertiary="SET" data-type="indexterm" id="idm46291174660328"/><a data-primary="Redis" data-secondary="commands" data-tertiary="SET" data-type="indexterm" id="idm46291174659112"/>the <code>SET</code> command, the <code>redis-cli</code> REPL will offer hints as to the remaining arguments for the command. Many of the Redis commands offer more complex arguments, in particular when it comes to changing metadata. The full form of the <code>SET</code> command, according to the REPL, looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">SET key value [EX seconds|PX milliseconds] [NX|XX] [KEEPTTL]</pre>&#13;
&#13;
<p>Options in square brackets are optional, and the pipe symbol means one or the other can be used. The first option allows the command to set a TTL value and allows a value to be provided using either seconds (<code>EX 1</code>) or milliseconds (<code>PX 1000</code>). The second pair of options deals with replacing existing values. The <code>NX</code> option will only perform a replacement if a key with the same name does not already exist, while the <code>XX</code> option will only set a value if it already does exist. Finally, the <code>KEEPTTL</code> can be used to retain the existing TTL value of a key that already exists.</p>&#13;
&#13;
<p>Now that you’ve set a value in Redis, run the following command to retrieve it:</p>&#13;
&#13;
<pre data-type="programlisting">GET foo&#13;
&gt; "bar"</pre>&#13;
&#13;
<p>In this case, the string <em>bar</em> is returned.</p>&#13;
&#13;
<p>For the most part, Redis doesn’t care about the values stored within keys, but there are a few notable exceptions. The string data type, for example, allows for numeric modifications to the values. As an example of this, run the following commands in your REPL:</p>&#13;
&#13;
<pre data-type="programlisting">SET visits "100"&#13;
&gt; OK&#13;
INCR visits&#13;
&gt; (integer) 101</pre>&#13;
&#13;
<p>The first command sets a key named <em>visits</em> to the string value of <code>100</code>. The next command increments the value of the key and returns the result; in this case, the result is the value <code>101</code>. The <code>INCR</code> and <code>INCRBY</code> commands <a data-primary="INCR Redis command" data-type="indexterm" id="idm46291174676024"/><a data-primary="commands" data-secondary="Redis" data-tertiary="INCR" data-type="indexterm" id="idm46291174675288"/><a data-primary="Redis" data-secondary="commands" data-tertiary="INCR" data-type="indexterm" id="idm46291174674072"/><a data-primary="INCRBY Redis command" data-type="indexterm" id="idm46291174672856"/><a data-primary="commands" data-secondary="Redis" data-tertiary="INCRBY" data-type="indexterm" id="idm46291174672184"/><a data-primary="Redis" data-secondary="commands" data-tertiary="INCRBY" data-type="indexterm" id="idm46291174670968"/>allow applications to atomically increment a value without having to first retrieve the value, increment it locally, and then set the value. This removes the race condition that was present in the single-threaded Node.js service you built in <a data-type="xref" href="#ex_link_shortener">Example 9-1</a>. Note that the return prompt displays some metadata about the result. In this case, it hints that the value is an integer. If you were to run the <strong><code>GET visits</code></strong> command, the value would be retrieved as a string again.</p>&#13;
&#13;
<p>Note that if you hadn’t first set a value for the <em>visits</em> key, the <code>INCR</code> command would assume the missing value was zero. Redis assumes an appropriate empty value with most operations. This makes interacting with Redis in a distributed environment more convenient. For example, without this zero default, if you were to deploy a fleet of Node.js app instances, each of them incrementing the <em>visits</em> value when a request is received, you would need to manually set <em>visits</em> to zero before your applications run.</p>&#13;
&#13;
<p>Redis has dozens of commands dedicated to operating on strings. Values can be appended to a string using <a data-primary="APPEND Redis command" data-type="indexterm" id="idm46291174605864"/><a data-primary="commands" data-secondary="Redis" data-tertiary="APPEND" data-type="indexterm" id="idm46291174605224"/><a data-primary="Redis" data-secondary="commands" data-tertiary="APPEND" data-type="indexterm" id="idm46291174604008"/>the <code>APPEND</code> command. Bitwise read and write operations can be applied to a subset of a string, and increments can use floating point values <a data-primary="strings, Redis" data-startref="stringRed" data-type="indexterm" id="idm46291174602104"/><a data-primary="Redis" data-secondary="strings" data-startref="stringRed1" data-type="indexterm" id="idm46291174601128"/><a data-primary="INCRBYFLOAT Redis command" data-type="indexterm" id="idm46291174599912"/><a data-primary="commands" data-secondary="Redis" data-tertiary="INCRBYFLOAT" data-type="indexterm" id="idm46291174599176"/><a data-primary="Redis" data-secondary="commands" data-tertiary="INCRBYBLOAT" data-type="indexterm" id="idm46291174597960"/>using the <code>INCRBYFLOAT</code> command.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lists" data-type="sect2"><div class="sect2" id="idm46291174686296">&#13;
<h2>Lists</h2>&#13;
&#13;
<p>The list data structure <a data-primary="Redis" data-secondary="lists" data-type="indexterm" id="redlist"/><a data-primary="lists, Redis" data-type="indexterm" id="redlist1"/>stores a linked list of string values and is comparable to a JavaScript array. Much like a JavaScript array, entries are ordered and duplicates are fine.</p>&#13;
&#13;
<p>Run the following commands to add some entries to a list named <em>list</em> and then to retrieve them:</p>&#13;
&#13;
<pre data-type="programlisting">RPUSH list aaa&#13;
&gt; (integer) 1&#13;
RPUSH list bbb&#13;
&gt; (integer) 2&#13;
LRANGE list 0 -1&#13;
&gt; 1) "aaa"&#13;
&gt; 2) "bbb"</pre>&#13;
&#13;
<p>Again, like with strings, Redis assumes the appropriate empty value for the list data type. In this case, when <a data-primary="RPUSH Redis command" data-type="indexterm" id="idm46291174589768"/><a data-primary="commands" data-secondary="Redis" data-tertiary="RPUSH" data-type="indexterm" id="idm46291174589128"/><a data-primary="Redis" data-secondary="commands" data-tertiary="RPUSH" data-type="indexterm" id="idm46291174587912"/>you ran the first <code>RPUSH</code> command, the key named <em>list</em> didn’t already exist. Redis assumed an empty list and added an entry to the list. The result of the <code>RPUSH</code> command is the length of the list, first returning a 1 and later returning a 2. Finally, the <code>LRANGE</code> command <a data-primary="LRANGE Redis command" data-type="indexterm" id="idm46291174584680"/><a data-primary="commands" data-secondary="Redis" data-tertiary="LRANGE" data-type="indexterm" id="idm46291174583944"/><a data-primary="Redis" data-secondary="commands" data-tertiary="LRANGE" data-type="indexterm" id="idm46291174582728"/>gets a list of entries in the list. Much like with JavaScript, Redis assumes list indexes are zero based. The first argument to <code>LRANGE</code> is the starting index, and the second argument is the end index. Negative values go from the end of the list, with -1 representing the final element, -2 the penultimate element, etc. The <code>LRANGE key 0 -1</code> command can always be used to retrieve an entire list regardless of its length.</p>&#13;
&#13;
<p>There are more than a dozen commands related to the list data type available in Redis. <a data-type="xref" href="#table_js_array_redis_list">Table 9-1</a> lists many of the Redis list commands and their equivalent operation if performed on a JavaScript array.</p>&#13;
<table id="table_js_array_redis_list">&#13;
<caption><span class="label">Table 9-1. </span>Redis list commands and equivalent JavaScript array operations</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>Redis command</th>&#13;
<th>JavaScript array equivalent</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Add entry to right</p></td>&#13;
<td><p><code>RPUSH key element</code></p></td>&#13;
<td><p><code>arr.push(element)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Add entry to left</p></td>&#13;
<td><p><code>LPUSH key element</code></p></td>&#13;
<td><p><code>arr.unshift(element)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Take entry from right</p></td>&#13;
<td><p><code>RPOP key element</code></p></td>&#13;
<td><p><code>arr.pop(element)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Take entry from left</p></td>&#13;
<td><p><code>LPOP key element</code></p></td>&#13;
<td><p><code>arr.shift(element)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get length</p></td>&#13;
<td><p><code>LLEN key</code></p></td>&#13;
<td><p><code>arr.length</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Retrieve element at index</p></td>&#13;
<td><p><code>LINDEX key index</code></p></td>&#13;
<td><p><code>x = arr[index]</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Replace element at index</p></td>&#13;
<td><p><code>LSET key index element</code></p></td>&#13;
<td><p><code>arr[index] = x</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Move element</p></td>&#13;
<td><p><code>RPOPLPUSH source dest</code></p></td>&#13;
<td><p><code>dest.push(source.pop())</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get element range</p></td>&#13;
<td><p><code>LRANGE key start stop</code></p></td>&#13;
<td><p><code>arr.slice(start, stop+1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get first occurence</p></td>&#13;
<td><p><code>LPOS key element</code></p></td>&#13;
<td><p><code>arr.indexOf(element)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get last occurence</p></td>&#13;
<td><p><code>RPOS key element</code></p></td>&#13;
<td><p><code>arr.lastIndexOf(element)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Reduce size</p></td>&#13;
<td><p><code>LTRIM key start stop</code></p></td>&#13;
<td><p><code>arr=arr.slice(start,stop+1)</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Some of these commands may seem a little weird at first. For example, why does Redis need the <code>RPOPLPUSH</code> command when it could be rebuilt using a combination of other commands? It all comes down to the need to support many distributed clients performing atomic operations against data in a centralized location. If the <code>RPOPLPUSH</code> command didn’t exist, a client would need to perform both <code>RPOP</code> and <code>LPUSH</code> commands separately, which allows another client to interleave commands that can leave the data in an inconsistent state. <a data-type="xref" href="#ch_primitives_sec_redis_subsec_atomicity">“Seeking Atomicity”</a> discuses <a data-primary="Redis" data-secondary="lists" data-startref="redlist" data-type="indexterm" id="idm46291174541656"/><a data-primary="lists, Redis" data-startref="redlist1" data-type="indexterm" id="idm46291174540408"/>such situations in more detail.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>When the final element from a list is removed, the key is removed entirely from Redis. You can see this by running the <strong><code>RPOP list</code></strong> command twice and then running the <strong><code>KEYS *</code></strong> command; the <em>list</em> key is no longer present. This behavior is different from the string data type, which can contain an empty string.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sets" data-type="sect2"><div class="sect2" id="idm46291174536472">&#13;
<h2>Sets</h2>&#13;
&#13;
<p>A Redis set is an unordered <a data-primary="Redis" data-secondary="sets" data-type="indexterm" id="redset1"/><a data-primary="sets, Redis" data-type="indexterm" id="redset2"/>collection of unique values. It is comparable to <code>new Set()</code> in JavaScript. When inserting redundant values into either a JavaScript or Redis set, the redundant entry will silently be ignored.</p>&#13;
&#13;
<p>Run the following commands in your REPL to add some entries to a set and then to retrieve them:</p>&#13;
&#13;
<pre data-type="programlisting">SADD set alpha&#13;
&gt; (integer) 1&#13;
SADD set beta&#13;
&gt; (integer) 1&#13;
SADD set beta&#13;
&gt; (integer) 0&#13;
SMEMBERS set&#13;
&gt; 1) "beta"     2) "alpha"</pre>&#13;
&#13;
<p>The first <code>SADD</code> command adds <a data-primary="SADD Redis command" data-type="indexterm" id="idm46291174529512"/><a data-primary="commands" data-secondary="Redis" data-tertiary="SADD" data-type="indexterm" id="idm46291174528776"/><a data-primary="Redis" data-secondary="commands" data-tertiary="SADD" data-type="indexterm" id="idm46291174527560"/>an entry named <em>alpha</em> to a set named <em>set</em>. The second command adds an entry named <em>beta</em> to the same set. Both of these commands get a response of 1, meaning that a single entry was successfully added. The third <code>SADD</code> command attempts to add <em>beta</em> to the set again. This time, a 0 was returned, meaning no entries were added. Finally, the <code>SMEMBERS</code> command <a data-primary="SMEMBERS Redis command" data-type="indexterm" id="idm46291174523368"/><a data-primary="commands" data-secondary="Redis" data-tertiary="SMEMBERS" data-type="indexterm" id="idm46291174522632"/><a data-primary="Redis" data-secondary="commands" data-tertiary="SMEMBERS" data-type="indexterm" id="idm46291174521544"/>returns a list of each of the members in the set.</p>&#13;
&#13;
<p><a data-type="xref" href="#table_js_array_redis_set">Table 9-2</a> is a list of some of the Redis set commands and their equivalent operations using a JavaScript <code>Set</code>.</p>&#13;
<table id="table_js_array_redis_set">&#13;
<caption><span class="label">Table 9-2. </span>Redis set commands and equivalent JavaScript <code>set</code> operations</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>Redis command</th>&#13;
<th>JavaScript set equivalent</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Add entry to set</p></td>&#13;
<td><p><code>SADD key entry</code></p></td>&#13;
<td><p><code>set.add(entry)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Count entries</p></td>&#13;
<td><p><code>SCARD key</code></p></td>&#13;
<td><p><code>set.size</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>See if set has entry</p></td>&#13;
<td><p><code>SISMEMBER key entry</code></p></td>&#13;
<td><p><code>set.has(entry)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Remove entry from set</p></td>&#13;
<td><p><code>SREM key entry</code></p></td>&#13;
<td><p><code>set.delete(entry)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Retrieve all entries</p></td>&#13;
<td><p><code>SMEMBERS key</code></p></td>&#13;
<td><p><code>Array.from(set)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Move between sets</p></td>&#13;
<td><p><code>SMOVE src dest entry</code></p></td>&#13;
<td><p><code>s2.delete(entry) &amp;&amp; s1.add(entry)</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Redis exposes several other commands for interacting with sets, notably commands for acting on unions and differences between sets. There is also the &#13;
<span class="keep-together"><code>SRANDMEMBER</code></span> and <code>SPOP</code> commands for <a data-primary="SPOP Redis command" data-type="indexterm" id="idm46291174497656"/><a data-primary="commands" data-secondary="Redis" data-tertiary="SPOP" data-type="indexterm" id="idm46291174496920"/><a data-primary="Redis" data-secondary="commands" data-tertiary="SPOP" data-type="indexterm" id="idm46291174495704"/>reading a random entry of the set and for popping off an entry. The <code>SSCAN</code> command allows a client to iterate through the entries of a set while using a cursor, which is a way of performing pagination of results.</p>&#13;
&#13;
<p>Similar to a list, a set that has <a data-primary="Redis" data-secondary="sets" data-startref="redset1" data-type="indexterm" id="idm46291174493480"/><a data-primary="sets, Redis" data-startref="redset2" data-type="indexterm" id="idm46291174492200"/>all of its entries removed will result in its key being removed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hash" data-type="sect2"><div class="sect2" id="idm46291174491000">&#13;
<h2>Hash</h2>&#13;
&#13;
<p>A Redis hash is a single key <a data-primary="Redis" data-secondary="hash" data-type="indexterm" id="redhash"/><a data-primary="hash, Redis" data-type="indexterm" id="redhash1"/>that contains multiple field/value pairs within it. A Redis hash most closely resembles a <code>new Map()</code> in JavaScript. Values within a hash are also treated as strings, though they do have <em>some</em> of the same operations available as normal Redis strings (like the ability to increment a value). Unlike normal Redis strings, the individual fields in a hash cannot have their own metadata applied (such as a TTL). When it comes to sharding, all fields in a hash will end up on the same machine.</p>&#13;
&#13;
<p>Run the following commands in your REPL to experiment with a hash:</p>&#13;
&#13;
<pre data-type="programlisting">HSET obj a 1&#13;
&gt; (integer) 1&#13;
HSET obj b 2&#13;
&gt; (integer) 1&#13;
HSET obj b 3&#13;
&gt; (integer) 0&#13;
HGETALL obj&#13;
1) "a"      2) "1"      3) "b"      4) "3"</pre>&#13;
&#13;
<p>Much like with the list commands, the hash command for adding an entry returns the number of entries that were added, though with a slightly different meaning. In this case, the first time <code>HSET obj b</code> is called, the <em>b</em> field didn’t already exist, so the result of the operation is a 1, meaning that one new field was added for the first time. The second time the command is run, it returns a 0, meaning that the field wasn’t newly added. Instead, the call replaced the value that already existed. Finally, the &#13;
<span class="keep-together"><code>HGETALL</code></span> command retrieves a list of all the field/value pairs in the hash. Note that the simple protocol used by Redis doesn’t have a way of differentiating a field from &#13;
<span class="keep-together">a value;</span> the two types of data alternate! When using most Redis client packages, &#13;
<span class="keep-together">including</span> <code>ioredis</code>, this is automatically converted into the equivalent JavaScript object &#13;
<span class="keep-together"><code>{a:1,b:2}</code>.</span></p>&#13;
&#13;
<p><a data-type="xref" href="#table_js_array_redis_map">Table 9-3</a> is a list of some of the Redis hash commands and their equivalent operations using a JavaScript <code>Map</code>.</p>&#13;
<table id="table_js_array_redis_map">&#13;
<caption><span class="label">Table 9-3. </span>Redis hash commands and equivalent JavaScript <code>map</code> operations</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>Redis command</th>&#13;
<th>JavaScript map equivalent</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Set an entry</p></td>&#13;
<td><p><code>HSET key field value</code></p></td>&#13;
<td><p><code>map.set(field, value)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Remove an entry</p></td>&#13;
<td><p><code>HDEL key field</code></p></td>&#13;
<td><p><code>map.delete(field)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Has an entry</p></td>&#13;
<td><p><code>HEXISTS key field</code></p></td>&#13;
<td><p><code>map.has(field)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Retrieve an entry</p></td>&#13;
<td><p><code>HGET key field</code></p></td>&#13;
<td><p><code>map.get(field)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get all entries</p></td>&#13;
<td><p><code>HGETALL key</code></p></td>&#13;
<td><p><code>Array.from(map)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>List keys</p></td>&#13;
<td><p><code>HKEYS key</code></p></td>&#13;
<td><p><code>Array.from(map.keys())</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>List values</p></td>&#13;
<td><p><code>HVALS key</code></p></td>&#13;
<td><p><code>Array.from(map.values())</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>To increment a <code>Map</code> entry in JavaScript, you would need to first retrieve the entry, increment the value, and then set it again, assuming the map contains a value that is a <code>Number</code> instance. If the values contained an object with property <code>v</code>, then you could increment them with something like <code>map.get(field).v++</code>. The equivalent command using Redis is <code>HINCRBY key field 1</code>.</p>&#13;
&#13;
<p>Consider that the string data type in Redis can hold anything that can be represented as a string of bytes. This includes a JSON object. With that in mind, why might you choose to use a hash instead of a JSON-encoded string? Hashes are useful when you want to store multiple properties close together, when all properties should have the same TTL, and when you need to atomically manipulate a subset of the keys. It’s also useful when the size of all the field values is so large that you wouldn’t want to retrieve the whole thing at once.</p>&#13;
&#13;
<p>As an example of this, say that you have a 1MB JSON object representing an employee. One of the fields is the employee’s wages. The JSON representation for this might look something like this:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="nt">"wage"</code><code class="p">:</code> <code class="mi">100000</code><code class="p">,</code> <code class="nt">"...other fields"</code><code class="p">:</code> <code class="s2">"..."</code><code class="p">}</code></pre>&#13;
&#13;
<p>To modify the <code>wage</code> field in that document, you would need to call <code>GET key</code> to retrieve it, <code>result = JSON.parse(response)</code> to parse it, <code>result.wage += 1000</code> to increment the wage, <code>payload = JSON.stringify(result)</code> to serialize it, and <code>SET key payload</code> to persist it. These modifications can’t easily be performed atomically because you’d need some sort of lock to prevent other clients from modifying the data simultaneously. There’s also overhead of reading and writing the 1MB payload, as well as for parsing and encoding the payload. By representing this data as a Redis hash, you’re free to directly modify exactly the field you want.</p>&#13;
&#13;
<p>Since all the fields in a hash are stored together on a single Redis instance, it’s important to make sure that the majority of your data isn’t represented using a single massive hash. For example, if you wanted to store payroll information about every employee in Redis, it would be better to use a single key per employee instead of a single hash key <a data-primary="Redis" data-secondary="hash" data-startref="redhash" data-type="indexterm" id="idm46291174439480"/><a data-primary="hash, Redis" data-startref="redhash1" data-type="indexterm" id="idm46291174435112"/>with a field per employee.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sorted Sets" data-type="sect2"><div class="sect2" id="idm46291174490328">&#13;
<h2>Sorted Sets</h2>&#13;
&#13;
<p>A Redis sorted set is one of the <a data-primary="Redis" data-secondary="sorted sets" data-type="indexterm" id="redset3"/><a data-primary="sets, Redis" data-secondary="sorted" data-type="indexterm" id="redset4"/>more complicated data structures available in Redis. It stores a collection of unique string values that are sorted by numeric scores. Entries can be queried based on score ranges. JavaScript doesn’t have a built-in equivalent to a Redis sorted set, though one could be built using multiple data structures.</p>&#13;
&#13;
<p>The stereotypical Redis sorted set example is a leaderboard of player scores for a game. In this use-case, the numeric score is what the player has achieved and the value is an identifier for the player. Redis provides dozens of commands for interacting with sorted sets, many for retrieving entries based on ranges of scores values.</p>&#13;
&#13;
<p>Run the following commands to create an example player leaderboard:</p>&#13;
&#13;
<pre data-type="programlisting">ZADD scores 1000 tlhunter&#13;
ZADD scores 500 zerker&#13;
ZADD scores 100 rupert&#13;
ZINCRBY scores 10 tlhunter&#13;
&gt; "1010"&#13;
ZRANGE scores 0 -1 WITHSCORES&#13;
&gt; 1) "rupert"     2) "100"&#13;
&gt; 3) "zerker"     4) "900"&#13;
&gt; 5) "tlhunter"   6) "1010"</pre>&#13;
&#13;
<p>The first three commands add entries to the sorted set. Calling multiple <code>ZADD</code> calls with the <a data-primary="ZADD Redis command" data-type="indexterm" id="idm46291174426248"/><a data-primary="commands" data-secondary="Redis" data-tertiary="ZADD" data-type="indexterm" id="idm46291174425512"/><a data-primary="Redis" data-secondary="commands" data-tertiary="ZADD" data-type="indexterm" id="idm46291174424296"/>same member will replace the member’s score. The <code>ZADD</code> command returns a 1 when the member is new and a 0 when the entry already exists, much like with lists and sets. The <code>ZINCRBY</code> command increments the score of a member, assuming a score of 0 if the member doesn’t already exist.</p>&#13;
&#13;
<p>The <code>ZRANGE</code> command <a data-primary="ZRANGE Redis command" data-type="indexterm" id="idm46291174420952"/><a data-primary="commands" data-secondary="Redis" data-tertiary="ZRANGE" data-type="indexterm" id="idm46291174420216"/><a data-primary="Redis" data-secondary="commands" data-tertiary="ZRANGE" data-type="indexterm" id="idm46291174419000"/>retrieves a list of entries in the sorted set, based on score order. You can universally use the <code>ZRANGE key 0 -1</code> command to get a list of all members in a sorted set. The <code>WITHSCORES</code> option instructs Redis to also include their scores.</p>&#13;
&#13;
<p><a data-type="xref" href="#table_redis_sorted_set">Table 9-4</a> is a list of some of the commands available with sorted sets.</p>&#13;
<table id="table_redis_sorted_set">&#13;
<caption><span class="label">Table 9-4. </span>Redis sorted set commands</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>Redis command</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Add an entry</p></td>&#13;
<td><p><code>ZADD key score member</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Count entries</p></td>&#13;
<td><p><code>ZCARD key</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Remove an entry</p></td>&#13;
<td><p><code>ZREM key member</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get member’s score</p></td>&#13;
<td><p><code>ZSCORE key member</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Increment member’s score</p></td>&#13;
<td><p><code>ZINCRBY key score member</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get a page of results</p></td>&#13;
<td><p><code>ZRANGE key min max</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get the numeric rank of a member</p></td>&#13;
<td><p><code>ZRANK key member</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get the reverse numeric rank of a member</p></td>&#13;
<td><p><code>ZREVRANK key member</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get members within score range</p></td>&#13;
<td><p><code>ZRANGEBYSCORE key min max</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Remove members within score range</p></td>&#13;
<td><p><code>ZREMRANGEBYSCORE key min max</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Using the leaderboard analogy, you can find out what the numeric rank of a player is by calling <code>ZREVRANK scores tlhunter</code>, which returns a 0 because it has the highest score. Many of the commands have a <code>REV</code> variant that treats the rankings in a reverse manner. Several also have a <code>REM</code> variant that removes the entry from the <a data-primary="Redis" data-secondary="sorted sets" data-startref="redset3" data-type="indexterm" id="idm46291174373496"/><a data-primary="sets, Redis" data-secondary="sorted" data-startref="redset4" data-type="indexterm" id="idm46291174372248"/>sorted set.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generic Commands" data-type="sect2"><div class="sect2" id="idm46291174433448">&#13;
<h2>Generic Commands</h2>&#13;
&#13;
<p>Most of the commands <a data-primary="Redis" data-secondary="commands, generic" data-type="indexterm" id="idm46291174369464"/><a data-primary="commands" data-secondary="Redis" data-type="indexterm" id="idm46291174368456"/>available in Redis are tied to keys with a specific data type. For example, the <code>HDEL</code> command deletes a field from a hash. But there are plenty of commands that either affect keys of any type or globally affect the Redis instance.</p>&#13;
&#13;
<p><a data-type="xref" href="#table_redis_generic_commands">Table 9-5</a> contains some popular commands that affect a key of any data type.</p>&#13;
<table id="table_redis_generic_commands">&#13;
<caption><span class="label">Table 9-5. </span>Generic Redis commands</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>Redis command</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Delete a key</p></td>&#13;
<td><p><code>DEL key</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Check if key exists</p></td>&#13;
<td><p><code>EXISTS key</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Set key expiration</p></td>&#13;
<td><p><code>EXPIRE key seconds</code>, <code>PEXPIRE key ms</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get key expiration</p></td>&#13;
<td><p><code>TTL key</code>, <code>PTTL key</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Remove key expiration</p></td>&#13;
<td><p><code>PERSIST key</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get data type of key</p></td>&#13;
<td><p><code>TYPE key</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Rename a key</p></td>&#13;
<td><p><code>RENAME key newkey</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get list of keys</p></td>&#13;
<td><p><code>KEYS pattern</code> (<code>*</code> means all keys)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Note that the <code>KEYS</code> command helps with local debugging but is inefficient and shouldn’t be used in production.</p>&#13;
&#13;
<p><a data-type="xref" href="#table_redis_server_commands">Table 9-6</a> lists some popular commands that interact with the Redis server in ways that aren’t associated with an individual key.</p>&#13;
<table id="table_redis_server_commands">&#13;
<caption><span class="label">Table 9-6. </span>Redis server commands</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Operation</th>&#13;
<th>Redis Command</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Get the number of keys</p></td>&#13;
<td><p><code>DBSIZE</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Remove all keys</p></td>&#13;
<td><p><code>FLUSHDB</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Get info about server</p></td>&#13;
<td><p><code>INFO</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>List commands being run</p></td>&#13;
<td><p><code>MONITOR</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Save data to disk</p></td>&#13;
<td><p><code>BGSAVE</code>, <code>SAVE</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Close the connection</p></td>&#13;
<td><p><code>QUIT</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Shut the server down</p></td>&#13;
<td><p><code>SHUTDOWN</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Note that the <code>MONITOR</code> command helps with local debugging but is inefficient and shouldn’t be used in production.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Types" data-type="sect2"><div class="sect2" id="idm46291174327208">&#13;
<h2>Other Types</h2>&#13;
&#13;
<p>Redis supports a few other data types and related commands that aren’t covered in this chapter.</p>&#13;
&#13;
<p>One of these command sets deal <a data-primary="Redis" data-secondary="geolocation" data-type="indexterm" id="idm46291174325176"/><a data-primary="geolocation, Redis" data-type="indexterm" id="idm46291174324200"/>with geolocation data. Internally, the geolocation commands operate on a sorted set containing entries scored by latitude and longitude values represented as a geohash. These values can be quickly retrieved using another command to find all the entries located within a configurable radius of a given latitude and longitude pair. This can be useful to do things like find all the businesses within a 1km radius.</p>&#13;
&#13;
<p>There’s also a HyperLogLog data <a data-primary="Redis" data-secondary="Hyperlog" data-type="indexterm" id="idm46291174322584"/>structure, which is a way of storing a compressed representation of a large set of data. This allows you to measure an approximate number of occurrences of <a data-primary="events" data-secondary="number of occurrences" data-type="indexterm" id="idm46291174321304"/>an event. It’s useful for storing sampled data that doesn’t need to be 100% accurate.</p>&#13;
&#13;
<p>Another interesting set of commands <a data-primary="Redis" data-secondary="PubSub commands" data-type="indexterm" id="idm46291174319736"/>available in Redis is the PubSub (Publish/Subscribe) family of commands. These commands allow clients to subscribe to channels to receive messages or publish messages to channels. A copy of the message is sent to every client listening on the channel, though channels can have zero subscribers as well. This makes it convenient to blast information to several clients at once.</p>&#13;
&#13;
<p>Streams are the latest addition to Redis. They are a persistent set of append-only events, similar in use to the PubSub commands in that a client can receive events, but much more powerful. Events are identified by a combination timestamp and sequence number so that identifiers are ordered. Streams use something called &#13;
<span class="keep-together">“Consumer Groups”</span> to allow messages to either fan out to multiple clients or to be consumed by just one client. Redis streams compete with Kafka.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Seeking Atomicity" data-type="sect1"><div class="sect1" id="ch_primitives_sec_redis_subsec_atomicity">&#13;
<h1>Seeking Atomicity</h1>&#13;
&#13;
<p>Atomicity is a property of a series of <a data-primary="Redis" data-secondary="atomicity" data-type="indexterm" id="red_atom"/><a data-primary="atomicity, Redis" data-type="indexterm" id="red_atom1"/>actions where either all or none of the actions are performed. It’s also important that when these actions are being carried out that an intermediary state where only some of the actions have been applied will never be observed from an external client. The <em>hello world</em> example of atomicity is when an account balance of $100 is transferred between account A and account B. For the transfer to be atomic, the balance of account A must be decremented by $100 and the balance of account B must be incremented by $100. If a failure happens, then neither of the changes should happen. And while the transfer is happening, no client should see that one balance changed while the other hasn’t.</p>&#13;
&#13;
<p>Within a single Redis server, every <em>single</em> command that is executed is atomic. For example, the fun-to-pronounce <code>RPOPLPUSH</code> command operates on two separate lists, removing an entry from one and adding it to another. Redis enforces the complete success or failure of that command. At no point will the server end up in a state where the popped value disappears, or is present in both lists, either by failure or from another client performing a read operation on the lists while the command is in progress. On the other hand, running <em>multiple</em> commands in succession is not atomic. For example, if a client were to run <code>RPOP</code> and then <code>LPUSH</code>, another client could read or write to the lists in between the two commands being executed.</p>&#13;
&#13;
<p>Redis provides several “compound commands,” which is a term I just invented meaning that a single command can be used in place of multiple commands. Redis provides such compound commands for common use-cases where atomicity is important. <a data-type="xref" href="#table_redis_compound_commands">Table 9-7</a> is an example of some of these compound commands, as well as their equivalent Redis commands and application pseudocode.</p>&#13;
<table id="table_redis_compound_commands">&#13;
<caption><span class="label">Table 9-7. </span>Redis compound commands</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Command</th>&#13;
<th>Alternative pseudocode</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>INCR key</code></p></td>&#13;
<td><p><code>GET key ; value++ ; SET KEY value</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>SETNX key value</code></p></td>&#13;
<td><p><code>!EXISTS key ; SET key value</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>LPUSHX key value</code></p></td>&#13;
<td><p><code>EXISTS key ; LPUSH key value</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>RPOPLPUSH src dest</code></p></td>&#13;
<td><p><code>RPOP src ; LPUSH dest value</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>GETSET key value</code></p></td>&#13;
<td><p><code>GET key ; SET key value</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>By running a compound command, you’re guaranteed to atomically modify the dataset—and do so efficiently. By running the alternative version of the commands, you’ll need to make multiple round trips from application code, during which time the Redis database is left in an undesirable state. When this happens, another client can read the intermediary state, or the application may crash, leaving the data forever invalid.</p>&#13;
&#13;
<p>This conundrum is illustrated in <a data-type="xref" href="#fig_redis_get_set">Figure 9-2</a> where two clients run the <code>GET</code>, increment, and <code>SET</code> commands simultaneously.</p>&#13;
&#13;
<figure><div class="figure" id="fig_redis_get_set">&#13;
<img alt="Two clients call GET at the same time, receiving the same value of 0, then increment locally to 1 and SET the same value." src="assets/dsnj_0902.png"/>&#13;
<h6><span class="label">Figure 9-2. </span>Sequential Redis commands like <code>GET</code> and <code>SET</code> aren’t atomic</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this case, both client A and client B want to increment a number. They both read the value of <code>counter</code> at about the same time and get the value 0. Next, both clients increment the value locally, calculating a value of 1. Finally, both clients write their incremented values at about the same time, both setting the value to 1, instead of the proper value of 2.</p>&#13;
&#13;
<p>Sometimes you’ll get lucky and an operation that you need to perform with Redis has a single command available. <a data-type="xref" href="#fig_redis_incr">Figure 9-3</a> illustrates the proper way to solve the previous conundrum by using the <code>INCR</code> command.</p>&#13;
&#13;
<figure><div class="figure" id="fig_redis_incr">&#13;
<img alt="Two clients call INCR at the same time, and Redis handles them sequentially, incrementing value to 2." src="assets/dsnj_0903.png"/>&#13;
<h6><span class="label">Figure 9-3. </span><code>INCR</code> is atomic in Redis</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this case, both clients run the <code>INCR</code> command at about the same time. The Redis server handles the details of the mutation internally, and the clients no longer risk losing data. In this case, the value is safely incremented to 2.</p>&#13;
&#13;
<p>Other times you might not get so lucky. For example, you might need to both remove employee ID #42 from a set named <code>employees</code> while also removing the company ID from a hash named <code>employee-42</code>. In this case, there is no Redis command to both remove from a set and remove from a hash. It might take thousands of commands to capture every permutation like this. When this happens, you’ll need to reach for another tool.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Redis does have a feature called <em>pipelining</em> where a client sends a series of commands separated by newlines instead of as individual messages. This ensures that commands are run sequentially for a given client but does not guarantee that other clients won’t run commands in the middle of another client’s pipeline. Individual commands in a pipeline may fail. This means pipelines do not make commands atomic.</p>&#13;
</div>&#13;
&#13;
<p>The ID generation problem mentioned in <a data-type="xref" href="#ch_primitives_sec_id">“The ID Generation Problem”</a> can be solved by using two of these compound commands. The first operation to atomically increment a counter is achieved using the <code>INCR</code> command. A single key is used to represent the next available short URL code. The second operation to set the URL value can be done using the <code>SETNX</code> command. True to the original example where files are written to, the operation <a data-primary="Redis" data-secondary="atomicity" data-startref="red_atom" data-type="indexterm" id="idm46291174275368"/><a data-primary="atomicity, Redis" data-startref="red_atom1" data-type="indexterm" id="idm46291174274120"/>would fail if an entry already exists (which shouldn’t happen).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transactions" data-type="sect1"><div class="sect1" id="idm46291174316424">&#13;
<h1>Transactions</h1>&#13;
&#13;
<p>Redis does provide a mechanism <a data-primary="Redis" data-secondary="transactions" data-type="indexterm" id="redtrans"/><a data-primary="transactions, Redis" data-type="indexterm" id="redtrans1"/>to ensure that multiple commands are executed atomically. This is done by preceding a series of commands with <code>MULTI</code> and then following them with <code>EXEC</code>. This allows all of the commands sent from a single client connection to be executed entirely and without interruption. If any of the commands within the transaction fail, then the effects of the commands that succeeded will be rolled back.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex_redis_transaction">Example 9-3</a> demonstrates how to create a Redis transaction using the <code>ioredis</code> package. Create a new file named <em>redis/transaction.js</em> and add the code to it.</p>&#13;
<div data-type="example" id="ex_redis_transaction">&#13;
<h5><span class="label">Example 9-3. </span><em>redis/transaction.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node&#13;
</code><code class="c1">// npm install ioredis@4.17&#13;
</code><code class="kr">const</code><code> </code><code class="nx">Redis</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'ioredis'</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">redis</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">Redis</code><code class="p">(</code><code class="s1">'localhost:6379'</code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="p">(</code><code class="nx">async</code><code> </code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="p">[</code><code class="nx">res_srem</code><code class="p">,</code><code> </code><code class="nx">res_hdel</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="nx">await</code><code> </code><code class="nx">redis</code><code class="p">.</code><code class="nx">multi</code><code class="p">(</code><code class="p">)</code><code> </code><a class="co" href="#callout_distributed_primitives_CO1-1" id="co_distributed_primitives_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
    </code><code class="p">.</code><code class="nx">srem</code><code class="p">(</code><code class="s2">"employees"</code><code class="p">,</code><code> </code><code class="s2">"42"</code><code class="p">)</code><code> </code><code class="c1">// Remove from Set&#13;
</code><code>    </code><code class="p">.</code><code class="nx">hdel</code><code class="p">(</code><code class="s2">"employee-42"</code><code class="p">,</code><code> </code><code class="s2">"company-id"</code><code class="p">)</code><code> </code><code class="c1">// Delete from Hash&#13;
</code><code>    </code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_distributed_primitives_CO1-2" id="co_distributed_primitives_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'srem?'</code><code class="p">,</code><code> </code><code class="o">!</code><code class="o">!</code><code class="nx">res_srem</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="p">,</code><code> </code><code class="s1">'hdel?'</code><code class="p">,</code><code> </code><code class="o">!</code><code class="o">!</code><code class="nx">res_hdel</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">redis</code><code class="p">.</code><code class="nx">quit</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_distributed_primitives_CO1-1" id="callout_distributed_primitives_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>ioredis</code> exposes a chainable <code>.multi()</code> method to begin a transaction.</p></dd>&#13;
<dt><a class="co" href="#co_distributed_primitives_CO1-2" id="callout_distributed_primitives_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>.exec()</code> method finishes the transaction.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This application runs a transaction containing two commands. The first command removes an employee from a set, and the second removes the employee’s company ID from a hash. Run the following commands in a new terminal window to first create some data and then to execute the Node.js application:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>docker <code class="nb">exec </code>distnode-redis redis-cli SADD employees <code class="m">42</code> tlhunter&#13;
<code class="nv">$ </code>docker <code class="nb">exec </code>distnode-redis redis-cli HSET employee-42 company-id funcorp&#13;
<code class="nv">$ </code>node redis/transaction.js&#13;
&gt; srem? <code class="nb">true </code>hdel? <code class="nb">true</code></pre>&#13;
&#13;
<p>Several results are returned when running a transaction with Redis, one for each of the commands executed in the transaction. The <code>ioredis</code> package represents the result of these commands as an array, which the application destructures into two variables. Each of these variables is also an array, with the first element being an error state (null in this case) and the second being the result of the command (1 in this case). Run the Node.js application a second time and the output should display <code>srem? false hdel? false</code>.</p>&#13;
&#13;
<p>While Redis is receiving a transaction from client A, which is to say that it has received the <code>MULTI</code> command but hasn’t yet received the <code>EXEC</code> command, other clients are still free to issue commands. This is important because a slow client would prevent Redis from responding to other clients. This at first may seem to violate the rules of atomicity, but the key detail is that Redis simply queues up the commands without running them. Once the server finally receives the <code>EXEC</code> command, all the commands in the transaction are then run. It’s at this point that other clients aren’t able to interact with Redis. <a data-type="xref" href="#fig_redis_transaction">Figure 9-4</a> illustrates a swimlane diagram of such a situation.</p>&#13;
&#13;
<p>Transactions are useful but they do have a major limitation: the output of one command can’t be used as input for another. For example, using <code>MULTI</code> and <code>EXEC</code>, it’s not possible to build a version of the <code>RPOPLPUSH</code> command. That command depends &#13;
<span class="keep-together">on the</span> element being output from <code>RPOP</code> to be used as an argument for the <code>LPUSH</code> &#13;
<span class="keep-together">command.</span></p>&#13;
&#13;
<figure><div class="figure" id="fig_redis_transaction">&#13;
<img alt="The Redis server queues up transaction commands until the EXEC command is received." src="assets/dsnj_0904.png"/>&#13;
<h6><span class="label">Figure 9-4. </span>Redis transactions wait for <code>EXEC</code> before committing changes</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s also impossible to perform other types of logic within a transaction. For example, it’s not possible to check if an employee hash has a field named <em>resigned</em> and then conditionally run a command to set the <em>salary</em> field to 0. To overcome these limitations, an <a data-primary="Redis" data-secondary="transactions" data-startref="redtrans" data-type="indexterm" id="idm46291174085800"/><a data-primary="transactions, Redis" data-startref="redtrans1" data-type="indexterm" id="idm46291174084552"/>even more powerful tool is required.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lua Scripting" data-type="sect1"><div class="sect1" id="idm46291174272456">&#13;
<h1>Lua Scripting</h1>&#13;
&#13;
<p>Redis provides a mechanism <a data-primary="Redis" data-secondary="Lua scripts" data-type="indexterm" id="redluscript"/><a data-primary="Lua scripts" data-type="indexterm" id="luscript"/><a data-primary="scripting, Lua" data-type="indexterm" id="scruptlu"/>to execute procedural scripts within the Redis server. This makes complex data interaction possible (for example, reading one key and making a decision before writing to another key). Similar concepts exist in other databases, such as Postgres’s stored procedures or MongoDB’s ability to run JavaScript. Redis chose to use the easily embedded Lua scripting language instead of inventing a new one.</p>&#13;
&#13;
<p>Lua has many of the same features that other languages, such as JavaScript,<sup><a data-type="noteref" href="ch09.html#idm46291174077400" id="idm46291174077400-marker">2</a></sup> come with. It offers arrays (though the indexing approach starts with 1 instead of 0) and tables (like a JavaScript <code>Map</code>), and it is dynamically typed like JavaScript. There is a nil (null) type, booleans, numbers, strings, and functions. It supports <code>for</code> and <code>while</code> loops, <code>if</code> statements, etc. The complete syntax of Lua isn’t covered here, but it is something that you can easily research while writing scripts for Redis.</p>&#13;
&#13;
<p>There are multiple patterns available for running Lua scripts with Redis. The first pattern is simpler to use but is less efficient. Use it by calling the <code>EVAL</code> command while passing in an entire Lua script as a string argument. This isn’t ideal because it consumes bandwidth by sending potentially long scripts each time the command is called. This pattern is akin to running an SQL query where each query call requires an entire copy of the query string.</p>&#13;
&#13;
<p>The second pattern is more efficient but requires additional work to get it right. In this pattern the <code>SCRIPT LOAD</code> command is first called, while also passing in a script as an argument. When Redis receives this command, it will return a SHA1 string to use to reference the command in the future.<sup><a data-type="noteref" href="ch09.html#idm46291174053656" id="idm46291174053656-marker">3</a></sup> This script can later be executed using the <code>EVALSHA</code> command with the SHA1 as an argument. This results in less data sent over the wire.</p>&#13;
&#13;
<p>The <code>EVAL</code> and <code>EVALSHA</code> commands essentially have the same arguments, except that the first argument is either a full script or a script reference, respectively. Here’s what the command signatures look like:</p>&#13;
&#13;
<pre data-type="programlisting">EVAL script numkeys key [key ...] arg [arg ...]&#13;
EVALSHA sha1 numkeys key [key ...] arg [arg ...]</pre>&#13;
&#13;
<p>Recall from before that groups of Redis commands can only affect keys that each exist on the same Redis instance. This applies to transactions as well as Lua scripts. This means Redis needs to know which keys are going to be accessed before attempting to execute the script. For this reason all keys need to be provided as arguments when executing the script.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>It’s possible to embed key names, or even generate them dynamically, within a Lua script without passing the key names in as arguments. Don’t do this! It’ll work when you test it on a single-Redis instance but will cause headaches if you grow to a Redis cluster in the future.</p>&#13;
</div>&#13;
&#13;
<p>Both key names and arguments can be provided when running a script. The second <code>numkeys</code> argument is required so that Redis may differentiate the names of keys from other arguments. This value tells Redis that the next <code>numkeys</code> arguments are keys and that anything <a data-primary="Lua scripts" data-type="indexterm" id="luscript2"/><a data-primary="scripting, Lua" data-startref="scruptlu" data-type="indexterm" id="idm46291174046232"/>after that is a script argument.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing a Lua Script File" data-type="sect2"><div class="sect2" id="idm46291174045128">&#13;
<h2>Writing a Lua Script File</h2>&#13;
&#13;
<p>Now that you’re familiar <a data-primary="Lua scripts" data-secondary="writing" data-type="indexterm" id="luscriptwrite"/><a data-primary="scripting, Lua" data-secondary="writing scripts" data-type="indexterm" id="luwrite"/>with some of the theory behind Lua scripting, you’re ready to build something yourself. For this example, you’re going to build a waiting lobby for a multiplayer game. When players attempt to join a game, they are added to the lobby. If enough players have been added to the lobby, four players in this case, then the players are removed from the lobby and a game is created. A hash is created to contain a collection of actively running games and the players within them. At this point, the application could theoretically notify players that a game has started, but this is an exercise left to the reader.</p>&#13;
&#13;
<p>For the first part of the application, you’ll create a Lua file containing the code to be executed on the Redis server. Create a new file named <em>redis/add-user.lua</em> and add the content from <a data-type="xref" href="#ex_redis_lua">Example 9-4</a> to it. I bet you never thought you’d be writing Lua code in a Node.js book!</p>&#13;
<div data-type="example" id="ex_redis_lua">&#13;
<h5><span class="label">Example 9-4. </span><em>redis/add-user.lua</em></h5>&#13;
&#13;
<pre data-code-language="lua" data-type="programlisting"><code class="kd">local</code> <code class="n">LOBBY</code> <code class="o">=</code> <code class="n">KEYS</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="c1">-- Set</code>&#13;
<code class="kd">local</code> <code class="n">GAME</code> <code class="o">=</code> <code class="n">KEYS</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="c1">-- Hash</code>&#13;
<code class="kd">local</code> <code class="n">USER_ID</code> <code class="o">=</code> <code class="n">ARGV</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="c1">-- String</code>&#13;
&#13;
<code class="n">redis</code><code class="p">.</code><code class="n">call</code><code class="p">(</code><code class="s1">'</code><code class="s">SADD'</code><code class="p">,</code> <code class="n">LOBBY</code><code class="p">,</code> <code class="n">USER_ID</code><code class="p">)</code>&#13;
&#13;
<code class="k">if</code> <code class="n">redis</code><code class="p">.</code><code class="n">call</code><code class="p">(</code><code class="s1">'</code><code class="s">SCARD'</code><code class="p">,</code> <code class="n">LOBBY</code><code class="p">)</code> <code class="o">==</code> <code class="mi">4</code> <code class="k">then</code>&#13;
  <code class="kd">local</code> <code class="n">members</code> <code class="o">=</code> <code class="nb">table.concat</code><code class="p">(</code><code class="n">redis</code><code class="p">.</code><code class="n">call</code><code class="p">(</code><code class="s1">'</code><code class="s">SMEMBERS'</code><code class="p">,</code> <code class="n">LOBBY</code><code class="p">),</code> <code class="s2">"</code><code class="s">,"</code><code class="p">)</code>&#13;
  <code class="n">redis</code><code class="p">.</code><code class="n">call</code><code class="p">(</code><code class="s1">'</code><code class="s">DEL'</code><code class="p">,</code> <code class="n">LOBBY</code><code class="p">)</code> <code class="c1">-- empty lobby</code>&#13;
  <code class="kd">local</code> <code class="n">game_id</code> <code class="o">=</code> <code class="n">redis</code><code class="p">.</code><code class="n">sha1hex</code><code class="p">(</code><code class="n">members</code><code class="p">)</code>&#13;
  <code class="n">redis</code><code class="p">.</code><code class="n">call</code><code class="p">(</code><code class="s1">'</code><code class="s">HSET'</code><code class="p">,</code> <code class="n">GAME</code><code class="p">,</code> <code class="n">game_id</code><code class="p">,</code> <code class="n">members</code><code class="p">)</code>&#13;
  <code class="k">return</code> <code class="p">{</code><code class="n">game_id</code><code class="p">,</code> <code class="n">members</code><code class="p">}</code>&#13;
<code class="k">end</code>&#13;
&#13;
<code class="k">return</code> <code class="kc">nil</code></pre></div>&#13;
&#13;
<p>The Lua scripting environment provided by Redis comes with two global arrays for accessing arguments provided to the script. The first is called <code>KEYS</code>, which contains the list of Redis keys, and the second is <code>ARGV</code>, which contains the normal arguments. The first key is assigned to a variable named <code>LOBBY</code>. This is a Redis set that contains a list of player identifiers. The <code>local</code> keyword is how Lua declares a local variable. The second key is assigned to the variable <code>GAME</code>, which is a hash containing active games. Finally, the only argument to the script is assigned to <code>USER_ID</code>, which is the ID of the player that was just added to the lobby.</p>&#13;
&#13;
<p>Next, the player identifier is added to the <code>LOBBY</code> key. The Redis Lua environment provides the method <code>redis.call()</code> that allows Lua to call Redis commands. The first command being called in this file is the <code>SADD</code> (set add) command.</p>&#13;
&#13;
<p>The next construct is where the first line of imperative programming happens (in this case, an <code>if</code> statement). This statement calls the <code>SCARD</code> (set cardinality) command to count the number of entries on the set. If the number of entries is not equal to 4 (which it isn’t for the very first run), then the <code>if</code> statement body is skipped. Then, the final line is called, and a <code>nil</code> value is returned. The <code>nil</code> value is then converted into a JavaScript <code>null</code> by the <code>ioredis</code> package.</p>&#13;
&#13;
<p>However, once the fourth player has been added to the lobby, the <code>if</code> statement body will execute. The list of players is retrieved from the lobby by using the <code>SMEMBERS</code> (set members) command. This list of players is converted into a comma-separated string using the Lua <code>table.concat()</code> function. Next, the lobby is emptied. Recall that an empty list gets deleted, so in this case the <code>DEL</code> (delete) command is called to essentially clear the list.</p>&#13;
&#13;
<p>Next, an identifier for the game is generated. There are many ways such an ID could have been generated, but in this case, a SHA1 hash of the members string is used. Lua doesn’t come with its own SHA1 function, but the Lua environment that Redis provides does. In this case, the function is provided via <code>redis.sha1hex()</code>. The string that is returned should be unique across all games, assuming the same players can’t join multiple games at the same time.<sup><a data-type="noteref" href="ch09.html#idm46291173911128" id="idm46291173911128-marker">4</a></sup> This identifier is then set into the games hash using <code>HSET</code>, where the field name is the game ID and the value is a comma-separated list of player IDs.</p>&#13;
&#13;
<p>Finally, an array (table) with two elements is returned, where the first is the game ID and the second is the list of players. Scripts can return data of different types between runs, and in this case, the script returns either a table or a nil.</p>&#13;
&#13;
<p>This script atomically adds players to a lobby and creates games. It does require that both the lobby and the game hash be stored in the same Redis instance. You can ensure this happens either by using a single Redis instance or by using curly braces when naming keys. Normally, Redis chooses which instance to host a key on by hashing the key. However, if you wrap a subset of the key name in curly braces, only the value inside of the curly braces is used for the hash. In this case, if the lobby key was named <code>lobby{pvp}</code> and the game key was named <code>game{pvp}</code>, then the keys would always end up together.</p>&#13;
&#13;
<p>The Lua script isn’t too interesting on its own, but things will get a little more exciting once you create <a data-primary="Lua scripts" data-secondary="writing" data-startref="luscriptwrite" data-type="indexterm" id="idm46291173906808"/><a data-primary="scripting, Lua" data-secondary="writing scripts" data-startref="luwrite" data-type="indexterm" id="idm46291173905560"/>a Node.js application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Loading the Lua Script" data-type="sect2"><div class="sect2" id="idm46291174044536">&#13;
<h2>Loading the Lua Script</h2>&#13;
&#13;
<p>This application connects to <a data-primary="Lua scripts" data-secondary="loading" data-type="indexterm" id="luload"/><a data-primary="scripting, Lua" data-secondary="loading" data-type="indexterm" id="luload1"/>the Redis server, evaluates the script, and inserts four players. It’s rather basic and was built to illustrate how to call the commands, instead of integrating with a web server to expose a fully functioning game application.</p>&#13;
&#13;
<p>Create a new file named <em>redis/script.js</em> and add the content from <a data-type="xref" href="#ex_redis_script">Example 9-5</a> to it.</p>&#13;
<div data-type="example" id="ex_redis_script">&#13;
<h5><span class="label">Example 9-5. </span><em>redis/script.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node</code>&#13;
<code class="c1">// npm install ioredis@4.17</code>&#13;
<code class="kr">const</code> <code class="nx">redis</code> <code class="o">=</code> <code class="k">new</code> <code class="p">(</code><code class="nx">require</code><code class="p">(</code><code class="s1">'ioredis'</code><code class="p">))(</code><code class="s1">'localhost:6379'</code><code class="p">);</code>&#13;
<code class="nx">redis</code><code class="p">.</code><code class="nx">defineCommand</code><code class="p">(</code><code class="s2">"adduser"</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">numberOfKeys</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
  <code class="nx">lua</code><code class="o">:</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fs'</code><code class="p">).</code><code class="nx">readFileSync</code><code class="p">(</code><code class="nx">__dirname</code> <code class="o">+</code> <code class="s1">'/add-user.lua'</code><code class="p">)</code>&#13;
<code class="p">});</code>&#13;
<code class="kr">const</code> <code class="nx">LOBBY</code> <code class="o">=</code> <code class="s1">'lobby'</code><code class="p">,</code> <code class="nx">GAME</code> <code class="o">=</code> <code class="s1">'game'</code><code class="p">;</code>&#13;
<code class="p">(</code><code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">await</code> <code class="nx">redis</code><code class="p">.</code><code class="nx">adduser</code><code class="p">(</code><code class="nx">LOBBY</code><code class="p">,</code> <code class="nx">GAME</code><code class="p">,</code> <code class="s1">'alice'</code><code class="p">));</code> <code class="c1">// null</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">await</code> <code class="nx">redis</code><code class="p">.</code><code class="nx">adduser</code><code class="p">(</code><code class="nx">LOBBY</code><code class="p">,</code> <code class="nx">GAME</code><code class="p">,</code> <code class="s1">'bob'</code><code class="p">));</code> <code class="c1">// null</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">await</code> <code class="nx">redis</code><code class="p">.</code><code class="nx">adduser</code><code class="p">(</code><code class="nx">LOBBY</code><code class="p">,</code> <code class="nx">GAME</code><code class="p">,</code> <code class="s1">'cindy'</code><code class="p">));</code> <code class="c1">// null</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">gid</code><code class="p">,</code> <code class="nx">players</code><code class="p">]</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">redis</code><code class="p">.</code><code class="nx">adduser</code><code class="p">(</code><code class="nx">LOBBY</code><code class="p">,</code> <code class="nx">GAME</code><code class="p">,</code> <code class="s1">'tlhunter'</code><code class="p">);</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'GAME ID'</code><code class="p">,</code> <code class="nx">gid</code><code class="p">,</code> <code class="s1">'PLAYERS'</code><code class="p">,</code> <code class="nx">players</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">','</code><code class="p">));</code>&#13;
  <code class="nx">redis</code><code class="p">.</code><code class="nx">quit</code><code class="p">();</code>&#13;
<code class="p">})();</code></pre></div>&#13;
&#13;
<p>This file begins by requiring the <code>ioredis</code> package and establishing a connection. Next, the content of the <em>add-user.lua</em> script is read and passed into the <code>redis.defineCommand()</code> method. This method abstracts away the Lua commands and has the application define a command using a chosen name. In this example, the script is aliased to a command named <em>adduser</em>.</p>&#13;
&#13;
<p>Next, the two key names are declared that are used by the Redis Lua scripts. In this case, the lobby list key is <code>lobby</code> and the game hash is <code>game</code>. Theoretically, these key names can change on a per-call basis since they aren’t part of the scripts themselves. This could allow a game to have multiple lobbies, for example, one for silver-ranked players and one for gold-ranked players.</p>&#13;
&#13;
<p>Next, the async function calls the <code>redis.adduser()</code> method four times to simulate four different players joining the lobby. The previous <code>redis.defineCommand()</code> method you called creates this new <code>redis.adduser()</code> method on the <code>redis</code> object. The arguments to this new method reflect the arguments passed to the Lua script (in this case, the lobby key, the game key, and the player ID). Note that this <em>doesn’t</em> create a command called <code>ADDUSER</code> on the Redis server; it’s just a local JavaScript method.</p>&#13;
&#13;
<p>The calls to <code>redis.adduser()</code> will each run the <em>add-user.lua</em> script stored in Redis. The first three times it is called will each result in a <code>null</code> being returned. However, the final fourth call triggers the game creation logic. When that happens, an array is returned, with the first value being the game ID (<code>gid</code>) and the second returning <a data-primary="Redis" data-secondary="Lua scripts" data-startref="redluscript" data-type="indexterm" id="idm46291173699272"/><a data-primary="Lua scripts" data-secondary="loading" data-startref="luload" data-type="indexterm" id="idm46291173698024"/><a data-primary="scripting, Lua" data-secondary="loading" data-startref="luload1" data-type="indexterm" id="idm46291173696808"/>the list of players (<code>players</code>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tying It All Together" data-type="sect2"><div class="sect2" id="idm46291173695048">&#13;
<h2>Tying It All Together</h2>&#13;
&#13;
<p>With your application file and Lua file now ready, it’s time to run the application. Run the following two commands in two separate terminal windows. The first will run the <code>MONITOR</code> command, which prints all the commands that the Redis server receives. The second command runs the application:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>docker <code class="nb">exec</code> -it distnode-redis redis-cli monitor&#13;
<code class="nv">$ </code>node redis/script.js</pre>&#13;
&#13;
<p>The application displays the results of the four calls to <code>redis.adduser()</code>. In my case, the output from the application looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">null&#13;
null&#13;
null&#13;
GAME ID 523c26dfea8b66ef93468e5d715e11e73edf8620&#13;
  PLAYERS [ 'tlhunter', 'cindy', 'bob', 'alice' ]</pre>&#13;
&#13;
<p>This illustrates that the first three players that joined didn’t cause a game to start, but the fourth player did. With the returned information, the application could then choose to notify the four players, perhaps by pushing a message to them via &#13;
<span class="keep-together">WebSocket.</span></p>&#13;
&#13;
<p>The output from the <code>MONITOR</code> command might prove to be a little more interesting. This command displays a few columns of information. The first is the timestamp of the command, the second is an identifier for the client running the command (or the string <code>lua</code> if run by a Lua script), and the remainder is the command being executed. A simplified version of the output on my machine looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">APP: "info"&#13;
APP: "evalsha" "1c..32" "2" "lobby" "game" "alice"&#13;
APP: "eval" "local...\n" "2" "lobby" "game" "alice"&#13;
LUA: "SADD" "lobby" "alice"&#13;
LUA: "SCARD" "lobby"&#13;
... PREVIOUS 3 LINES REPEATED TWICE FOR BOB AND CINDY ...&#13;
APP: "evalsha" "1c..32" "2" "lobby" "game" "tlhunter"&#13;
LUA: "SADD" "lobby" "tlhunter"&#13;
LUA: "SCARD" "lobby"&#13;
LUA: "SMEMBERS" "lobby"&#13;
LUA: "DEL" "lobby"&#13;
LUA: "HSET" "game" "52..20" "tlhunter,cindy,bob,alice"</pre>&#13;
&#13;
<p>The first command that is executed is the <code>INFO</code> command. The <code>ioredis</code> package runs this to learn the capabilities of the Redis server. Afterwards, <code>ioredis</code> hashes the Lua script itself and attempts to run it for player <em>alice</em> by sending the <code>EVALSHA</code> command with the SHA1 it calculated (abbreviated as <code>1c..32</code>). That command fails, and &#13;
<span class="keep-together"><code>ioredis</code></span> falls back to running <code>EVAL</code> directly, passing in the script’s content (abbreviated as <code>local…</code>). Once that happens the server now has the hash of the script stored in memory. The Lua script calls the <code>SADD</code> and <code>SCARD</code> commands. The <code>EVALSHA</code>, <code>SADD</code>, and <code>SCARD</code> commands are each repeated two more times, once for <em>bob</em> and once for <em>cindy</em>.</p>&#13;
&#13;
<p>Finally, the fourth call is made for player <em>tlhunter</em>. This results in the <code>SADD</code>, <code>SCARD</code>, <code>SMEMBERS</code>, <code>DEL</code>, and <code>HSET</code> commands being run.</p>&#13;
&#13;
<p>At this point, you’re now finished with the Redis server. Switch to the terminal window running the <code>MONITOR</code> command and kill it with Ctrl + C. You can also switch to the terminal running the Redis server and kill it with the same key sequence, unless you’d like to keep it running for more experimentation.</p>&#13;
&#13;
<p>As a rule of thumb, you should only use Lua scripts if it’s impossible to perform the same actions atomically with regular commands and transactions. For one thing, there’s at least a minimal memory overhead of storing scripts in Redis. More importantly, though, is that Redis is single-threaded, and so is the Lua that it executes. Any slow Lua scripts (or even infinite loops) are going to slow down other clients connected to the server. There’s also a performance penalty for parsing code and evaluating it. If you ran a Lua script to execute a single Redis command, it would undoubtedly be slower than running the Redis command directly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46291174815176"><sup><a href="ch09.html#idm46291174815176-marker">1</a></sup> For example, an È has both a single-byte and multibyte UTF representations, which are considered unequal when doing a binary comparison.</p><p data-type="footnote" id="idm46291174077400"><sup><a href="ch09.html#idm46291174077400-marker">2</a></sup> Check out the <a class="orm:hideurl" href="http://luvit.io">Luvit.io</a> project if you’d like to see what a Node.js-like platform implemented in Lua looks like.</p><p data-type="footnote" id="idm46291174053656"><sup><a href="ch09.html#idm46291174053656-marker">3</a></sup> Redis generates a SHA1 hash of the script and uses that to refer to scripts in an internal cache.</p><p data-type="footnote" id="idm46291173911128"><sup><a href="ch09.html#idm46291173911128-marker">4</a></sup> And assuming the players haven’t discovered a SHA1 collision.</p></div></div></section></body></html>