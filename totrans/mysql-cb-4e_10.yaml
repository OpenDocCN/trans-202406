- en: Chapter 10\. Generating Summaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 10.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database systems are not only useful for data storage and retrieval, but they
    can also summarize your data in more concise forms. Summaries are useful when
    you want the overall picture, not the details. They’re more readily understood
    than a long list of records. They enable you to answer questions such as <q>How
    many?</q> or <q>What is the total?</q> or <q>What is the range of values?</q>
    If you run a business, you may want to know how many customers you have in each
    state, or how much sales volume you generate each month.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding examples include two common summary types: counting summaries
    and content summaries. The first (the number of customer records per state) is
    a counting summary. The content of each record is important only for purposes
    of placing it into the proper group or category for counting. Such summaries are
    essentially histograms, where you sort items into a set of bins and count the
    number of items in each bin. The second example (sales volume per month) is a
    content summary, in which sales totals are based on sales values in order records.'
  prefs: []
  type: TYPE_NORMAL
- en: Another summary type produces neither counts nor sums, but simply a list of
    unique values. This is useful if you care *which* values are present rather than
    how many of each there are. To determine the states in which you have customers,
    you need a list of the distinct state names contained in the records, not a list
    consisting of the state value from every record.
  prefs: []
  type: TYPE_NORMAL
- en: The summary types available to you depend on the nature of your data. A counting
    summary can be generated from all kinds of values, whether they be numbers, strings,
    or dates. Summaries that produce sums or averages apply only to numeric values.
    You can count instances of customer state names to produce a demographic analysis
    of your customer base. And sometimes it makes sense to apply one summary technique
    to the result of another. For example, to determine how many states your customers
    live in, generate a list of unique customer states, then count them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Summary operations in MySQL involve the following SQL constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: To compute a summary value from a set of individual values, use one of the functions
    known as aggregate functions. These are so called because they operate on aggregates
    (groups) of values. Aggregate functions include `COUNT()`, which counts rows or
    values in a query result; `MIN()` and `MAX()`, which find smallest and largest
    values; and `SUM()` and `AVG()`, which produce sums and means of values. These
    functions can be used to compute a value for the entire result set, or with a
    `GROUP` `BY` clause to group rows into subsets and obtain an aggregate value for
    each one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To obtain a list of unique values, use `SELECT` `DISTINCT` rather than `SELECT`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To count unique values, use `COUNT(DISTINCT)` rather than `COUNT()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recipes in this chapter first illustrate basic summary techniques, and then
    show how to perform more complex summary operations. You’ll find additional examples
    of summary methods in later chapters, particularly those that cover joins and
    statistical operations. (See [Chapter 16](ch16.xhtml#nch-multi) and [Chapter 17](ch17.xhtml#nch-stats).)
  prefs: []
  type: TYPE_NORMAL
- en: Summary queries sometimes involve complex expressions. For summaries that you
    execute often, keep in mind that views can make queries easier to use. [Recipe
    5.7](ch05.xhtml#nch-select-select-view) demonstrates the basic technique of creating
    a view. [Recipe 10.5](#nch-sum-sum-view) shows how it applies to summary simplification,
    and you’ll easily see how it can be used in later sections of the chapter as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary tables used for examples in this chapter are the `driver_log` and
    `mail` tables. These were also used in [Chapter 9](ch09.xhtml#nch-sort), so they
    should look familiar. A third table used throughout the chapter is `states`, which
    has rows containing a few columns of information for each of the United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `name` and `abbrev` columns list the full state name and the corresponding
    abbreviation. The `statehood` column indicates the day on which the state entered
    the Union. `pop` is the state population from the 2010 census, as reported by
    the US Census Bureau.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses other tables occasionally as well. You can create them with
    scripts found in the *tables* directory of the `recipes` distribution. [Recipe
    7.15](ch07.xhtml#nch-strings-strings-full-text-intro) describes the `reviews`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 10.1 Summarizing with COUNT()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to count the number of rows in an entire table or that match particular
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `COUNT()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `COUNT()` function calculates number of rows. For example, to display the
    rows in a table, use a `SELECT` `*` statement, but to count them instead, use
    `SELECT` `COUNT(*)`. Without a `WHERE` clause, the statement counts all the rows
    in the table, such as in the following statement that shows how many rows the
    `driver_log` table contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t know how many US states there are (perhaps you think there are
    57?), this statement tells you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`COUNT(*)` with no `WHERE` clause performs a full table scan unless storage
    engine optimized this function. For MyISAM tables, that stores exact number of
    rows, this is very quick. For InnoDB tables, that scans all entries in the primary
    key to perform `COUNT(*)`, you may want to avoid using this function because it
    can be slow for large tables. If an approximate row count is good enough, avoid
    a full scan by extracting the `TABLE_ROWS` value from the `INFORMATION_SCHEMA`
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To count only the number of rows that match certain conditions, include an
    appropriate `WHERE` clause in a `SELECT` `COUNT(*)` statement. The conditions
    can be chosen to make `COUNT(*)` useful for answering many kinds of questions:'
  prefs: []
  type: TYPE_NORMAL
- en: How many times did drivers travel more than 200 miles in a day?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many days did Suzi drive?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many of the United States joined the Union in the 19th century?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `COUNT()` function actually has two forms. The form we’ve been using, `COUNT(*)`,
    counts rows. The other form, `COUNT(`*`expr`*`)`, takes a column name or expression
    argument and counts the number of non-`NULL` values. The following statement shows
    how to produce both a row count for a table and a count of the number of non-`NULL`
    values in one of its columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The fact that `COUNT(`*`expr`*`)` doesn’t count `NULL` values is useful for
    producing multiple counts from the same set of rows. To count the number of Saturday
    and Sunday trips in the `driver_log` table with a single statement, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to count weekend versus weekday trips, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `IF()` expressions determine, for each column value, whether it should be
    counted. If so, the expression evaluates to `1` and `COUNT()` counts it. If not,
    the expression evaluates to `NULL` and `COUNT()` ignores it. The effect is to
    count the number of values that satisfy the condition given as the first argument
    to `IF()`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Function `COUNT()` calculates number of elements, so you can replace `1` with
    any other value. The result will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the further discussion on the difference between `COUNT(*)` and `COUNT(expr)`,
    see [Recipe 10.9](#nch-sum-sum-null).
  prefs: []
  type: TYPE_NORMAL
- en: 10.2 Summarizing with MIN() and MAX()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find the smallest or the largest values in the dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use functions `MIN()` and `MAX()` correspondingly.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finding smallest or largest values in a dataset is somewhat akin to sorting,
    except that instead of producing an entire set of sorted values, you select only
    a single value at one end or the other of the sorted range. This operation applies
    to questions about smallest, largest, oldest, newest, most expensive, least expensive,
    and so forth. One way to find such values is to use the `MIN()` and `MAX()` functions.
    (Another way is to use `LIMIT`; see [Recipe 5.9](ch05.xhtml#nch-select-select-limit).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Because `MIN()` and `MAX()` determine the extreme values in a set, they’re
    useful for characterizing ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: What date range is represented by the rows in the `mail` table? What are the
    smallest and largest messages sent?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What are the smallest and largest US state populations?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What are the first and last state names, lexically speaking? What is the length
    of the shortest and longest names?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The final query illustrates that `MIN()` and `MAX()` need not be applied directly
    to column values; they’re also useful for expressions or values derived from column
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 10.3 Summarizing with SUM() and AVG()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to calculate total or average (mean) of a set of values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use functions `SUM()` and `AVG()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`SUM()` and `AVG()` produce the total and average (mean) of a set of values:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the total amount of mail traffic in bytes and the average size of each
    message?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How many miles did the drivers in the `driver_log` table travel? What was the
    average number of miles traveled per day?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the total population of the United States?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The value represents the population reported for the 2021 census.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SUM()` and `AVG()` are numeric functions, so they can’t be used with strings
    or temporal values. But sometimes you can convert nonnumeric values to useful
    numeric forms. Suppose that a table stores `TIME` values that represent elapsed
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the total elapsed time, use `TIME_TO_SEC()` to convert the values
    to seconds before summing them. The resulting sum is also in seconds; pass it
    to `SEC_TO_TIME()` to convert it back to `TIME` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SUM()` and `AVG()` functions are especially useful in statistical applications.
    They’re explored further in [Chapter 17](ch17.xhtml#nch-stats), along with `STD()`,
    a related function that calculates standard deviations.
  prefs: []
  type: TYPE_NORMAL
- en: 10.4 Using DISTINCT to eliminate duplicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to skip duplicate values when performing calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use keyword `DISTINCT`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A summary operation that uses no aggregate functions is determining the unique
    values or rows in a dataset. Do this with `DISTINCT` (or `DISTINCTROW`, a synonym).
    `DISTINCT` boils down a query result, and often is combined with `ORDER` `BY`
    to place values in more meaningful order. This query lists in lexical order the
    drivers named in the `driver_log` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Without `DISTINCT`, the statement produces the same names, but is not nearly
    as easy to understand, even with a small dataset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To determine the number of different drivers, use `COUNT(DISTINCT)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`COUNT(DISTINCT)` ignores `NULL` values. To count `NULL` as one of the values
    in the set if it’s present, use one of the following expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this example we first calculate number of distinct `NOT NULL` values, then
    add `1` if the sum of `NULL` values is greater than zero.
  prefs: []
  type: TYPE_NORMAL
- en: '`DISTINCT` queries often are useful in conjunction with aggregate functions
    to more fully characterize your data. Suppose that a `customer` table contains
    a `state` column indicating customer location. Applying `COUNT(*)` to the `customer`
    table indicates how many customers you have, using `DISTINCT` on the `state` column
    tells you the number of states in which you have customers, and `COUNT(DISTINCT)`
    on the `state` column tells you how many states your customer base represents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When used with multiple columns, `DISTINCT` shows the different combinations
    of values in the columns and `COUNT(DISTINCT)` counts the number of combinations.
    The following statements show the different sender/recipient pairs in the `mail`
    table and the number of such pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 10.5 Creating a View to Simplify Using a Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make it easier to perform a summary.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a view that does it for you.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you often need a given summary, a technique that enables you to avoid typing
    the summarizing expressions repeatedly is to use a view (see [Recipe 5.7](ch05.xhtml#nch-select-select-view)).
    For example, the following view implements the weekend versus weekday trip summary
    discussed in [Recipe 10.1](#nch-sum-sum-basic-count):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting from this view is much easier than selecting directly from the underlying
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: While
  prefs: []
  type: TYPE_NORMAL
- en: 10.6 Finding Values Associated with Minimum and Maximum Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the values for other columns in the row that contains a minimum
    or maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use two statements and a user-defined variable. Or a subquery. Or a join. Or
    a CTE.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MIN()` and `MAX()` find an endpoint of a range of values, but you may also
    be interested in other values from the row in which the value occurs. For example,
    you can find the largest state population like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But that doesn’t show you which state has this population. The obvious attempt
    at getting that information looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Probably everyone tries something like that sooner or later, but it doesn’t
    work. Aggregate functions such as `MIN()` and `MAX()` cannot be used in `WHERE`
    clauses, which require expressions that apply to individual rows. The intent of
    the statement is to determine which row has the maximum population value and display
    the associated state name. The problem is that although you and I know perfectly
    well what we mean by writing such a thing, it makes no sense at all in SQL. The
    statement fails because SQL uses the `WHERE` clause to determine which rows to
    select, but the value of an aggregate function is known only *after* selecting
    the rows from which the function’s value is determined! So, in a sense, the statement
    is self-contradictory. To solve this problem, save the maximum population value
    in a user-defined variable, then compare rows to the variable value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, for a single-statement solution, use a subquery in the `WHERE`
    clause that returns the maximum population value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique also works even if the minimum or maximum value itself isn’t
    actually contained in the row, but is only derived from it. To determine the length
    of the shortest review in the sample Amazon Reviews Data, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to know <q>Which review is that?</q> do this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet another way to select other columns from rows containing a minimum or maximum
    value is to use a join. Select the value into another table, then join it to the
    original table to select the row that matches the value. To find the row for the
    state with the highest population, use a join like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As of MySQL 8.0 you can use Common Table Expressions (CTE) to perform the same
    search.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Two above code snippets use the same idea: create a temporary table to store
    the maximum population number and join it with the original table. But latter
    performs this operation in the single query, so you do not need to care about
    destroying the temporary table after getting the result. We discuss CTE in detail
    in [Recipe 10.18](#nch-sum-sum-with).'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 16.7](ch16.xhtml#nch-multi-multi-per-group) extends the discussion
    here to the problem of finding rows that contain minimum or maximum values for
    multiple groups in a dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: 10.7 Controlling String Case Sensitivity for MIN() and MAX()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MIN()` and `MAX()` select strings in case-sensitive fashion when you don’t
    want them to, or vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use different comparison characteristics of the strings.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 7.1](ch07.xhtml#nch-strings-strings-properties) discusses how string-comparison
    properties depend on whether the strings are binary or nonbinary:'
  prefs: []
  type: TYPE_NORMAL
- en: Binary strings are sequences of bytes. They are compared byte by byte using
    numeric byte values. Character set and lettercase have no meaning for comparisons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nonbinary strings are sequences of characters. They have a character set and
    collation and are compared character by character using the order defined by the
    collation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These properties also apply to string columns used as the argument to the `MIN()`
    or `MAX()` function because they are based on comparison. To alter how these functions
    work with a string column, alter the column’s comparison properties. [Recipe 7.7](ch07.xhtml#nch-strings-strings-compare)
    discusses how to control these properties, and [Recipe 9.4](ch09.xhtml#nch-sort-sort-string)
    shows how they apply to string sorts. The same principles apply to finding minimum
    and maximum string values, so I’ll just summarize here; read [Recipe 9.4](ch09.xhtml#nch-sort-sort-string)
    for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare case-insensitive strings in case-sensitive fashion, order the values
    using a case-sensitive collation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To compare case-sensitive strings in case-insensitive fashion, order the values
    using a case-insensitive collation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Another possibility is to compare values that have all been converted to the
    same lettercase, which makes lettercase irrelevant. However, that also changes
    the retrieved values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Binary strings compare using numeric byte values, so there is no concept of
    lettercase involved. However, because letters in different cases have different
    byte values, comparisons of binary strings effectively are case sensitive. (That
    is, `a` and `A` are unequal.) To compare binary strings using a case-insensitive
    ordering, convert them to nonbinary strings and apply an appropriate collation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the default collation is case insensitive (as is true for `utf8mb4`), you
    can omit the `COLLATE` clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 10.8 Dividing a Summary into Subgroups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a summary for each subgroup of a set of rows, not an overall summary
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `GROUP` `BY` clause to arrange rows into groups.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The summary statements shown so far calculate summary values over all rows
    in the result set. For example, the following statement determines the number
    of records in the `mail` table, and thus the total number of mail messages sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To arrange a set of rows into subgroups and summarize each group, use aggregate
    functions in conjunction with a `GROUP` `BY` clause. To determine the number of
    messages per sender, group the rows by sender name, count how many times each
    name occurs, and display the names with the counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'That query summarizes the same column that is used for grouping (`srcuser`),
    but that’s not always necessary. Suppose that you want a quick characterization
    of the `mail` table, showing for each sender listed in it the total amount of
    traffic sent (in bytes) and the average number of bytes per message. In this case,
    you still use the `srcuser` column to group the rows, but summarize the `size`
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Use as many grouping columns as necessary to achieve a grouping as fine-grained
    as you require. The earlier query that shows the number of messages per sender
    is a coarse summary. To be more specific and find out how many messages each sender
    sent from each host, use two grouping columns. This produces a result with nested
    groups (groups within groups):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding examples in this section used `COUNT()`, `SUM()`, and `AVG()`
    for per-group summaries. You can use `MIN()` or `MAX()`, too. With a `GROUP` `BY`
    clause, they return the smallest or largest value per group. The following query
    groups `mail` table rows by message sender, displaying for each the size of the
    largest message sent and the date of the most recent message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You can group by multiple columns and display a maximum for each combination
    of values in those columns. This query finds the size of the largest message sent
    between each pair of sender and recipient values listed in the `mail` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When using aggregate functions to produce per-group summary values, watch out
    for the following trap, which involves selecting nonsummary table columns not
    related to the grouping columns. Suppose that you want to know the longest trip
    per driver in the `driver_log` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you also want to show the date on which each driver’s longest trip
    occurred? Can you just add `trav_date` to the output column list? Sorry, that
    doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The query does produce a result, but if you compare it to the full table (shown
    here), you’ll see that although the dates for Ben and Henry are correct, the date
    for Suzi is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: So what’s going on? Why does the summary statement produce incorrect results?
    This happens because when you include a `GROUP` `BY` clause in a query, the only
    values that you can meaningfully select are the grouping columns or summary values
    calculated from the groups. If you display additional table columns, they’re not
    tied to the grouped columns and the values displayed for them are indeterminate.
    (For the statement just shown, it appears that MySQL may simply be picking the
    first date for each driver, regardless of whether it matches the driver’s maximum
    mileage value.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To make queries that pick indeterminate values illegal so that you won’t inadvertantly
    suppose that the `trav_date` values are correct, set the `ONLY_FULL_GROUP_BY`
    SQL mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: SQL Mode `ONLY_FULL_GROUP_BY` is part of the default settings since MySQL 5.7\.
    However, we have seen many legacy applications that disable this option. We suggest
    you to always have `ONLY_FULL_GROUP_BY` enabled and fix queries that return error
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: 'The general solution to the problem of displaying contents of rows associated
    with minimum or maximum group values involves a join. The technique is described
    in [Recipe 16.7](ch16.xhtml#nch-multi-multi-per-group). For the problem at hand,
    produce the required results as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, by using CTE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 10.9 Handling NULL Values with Aggregate Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re summarizing a set of values that may include `NULL` values and you need
    to know how to interpret the results.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understand how aggregate functions handle `NULL` values.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most aggregate functions ignore `NULL` values. `COUNT()` is different: `COUNT(`*`expr`*`)`
    ignores `NULL` instances of *`expr`*, but `COUNT(*)` counts rows, regardless of
    content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that an `expt` table contains experimental results for subjects who
    are to be given four tests each and that lists the test score as `NULL` for tests
    not yet administered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'By using a `GROUP` `BY` clause to arrange the rows by subject name, the number
    of tests taken by each subject, as well as the total, average, lowest, and highest
    scores, can be calculated like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the results in the column labeled `n` (number of tests) that
    the query counts only five values, even though the table contains eight. Why?
    Because the values in that column correspond to the number of non-`NULL` test
    scores for each subject. The other summary columns display results that are calculated
    only from the non-`NULL` scores as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes a lot of sense for aggregate functions to ignore `NULL` values. If
    they followed the usual SQL arithmetic rules, adding `NULL` to any other value
    would produce a `NULL` result. That would make aggregate functions really difficult
    to use: to avoid getting a `NULL` result, you’d have to filter out `NULL` values
    every time you performed a summary. By ignoring `NULL` values, aggregate functions
    become a lot more convenient.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, be aware that even though aggregate functions may ignore `NULL` values,
    some of them can still produce `NULL` as a result. This happens if there’s nothing
    to summarize, which occurs if the set of values is empty or contains only `NULL`
    values. The following query is the same as the previous one, with one small difference.
    It selects only `NULL` test scores to illustrate what happens when there’s nothing
    for the aggregate functions to operate on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For `COUNT()`, the number of scores per subject is zero and is reported that
    way. On the other hand, `SUM()`, `AVG()`, `MIN()`, and `MAX()` return `NULL` when
    there are no values to summarize. If you don’t want an aggregate value of `NULL`
    to display as `NULL`, use `IFNULL()` to map it appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`COUNT()` is somewhat different with regard to `NULL` values than the other
    aggregate functions. Like other aggregate functions, `COUNT(`*`expr`*`)` counts
    only non-`NULL` values, but `COUNT(*)` counts rows, no matter what they contain.
    You can see the difference between the forms of `COUNT()` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that there are eight rows in the `expt` table but that only five
    of them have the `score` value filled in. The different forms of `COUNT()` can
    be very useful for counting missing values. Just take the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Missing and nonmissing counts can be determined for subgroups as well. The
    following query does so for each subject, providing an easy way to assess the
    extent to which the experiment has been completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 10.10 Selecting Only Groups with Certain Characteristics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to calculate group summaries but display results only for groups that
    match certain criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `HAVING` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’re familiar with the use of `WHERE` to specify conditions that rows must
    satisfy to be selected by a statement. It’s natural, therefore, to use `WHERE`
    to write conditions that involve summary values. The only trouble is that it doesn’t
    work. To identify drivers in the `driver_log` table who drove more than three
    days, you might write the statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `WHERE` specifies the initial constraints that determine
    which rows to select, but the value of `COUNT()` can be determined only after
    the rows have been selected. The solution is to put the `COUNT()` expression in
    a `HAVING` clause instead. `HAVING` is analogous to `WHERE`, but it applies to
    group characteristics rather than to single rows. That is, `HAVING` operates on
    the already-selected-and-grouped set of rows, applying additional constraints
    based on aggregate function results that aren’t known during the initial selection
    process. The preceding query therefore should be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: When you use `HAVING`, you can still include a `WHERE` clause, but only to select
    rows to be summarized, not to test already calculated summary values.
  prefs: []
  type: TYPE_NORMAL
- en: '`HAVING` can refer to aliases, so the previous query can be rewritten like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 10.11 Using Counts to Determine Whether Values Are Unique
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know whether values in a table are unique.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `HAVING` in conjunction with `COUNT()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`DISTINCT` eliminates duplicates but doesn’t show which values actually were
    duplicated in the original data. You can use `HAVING` to find unique values in
    situations to which `DISTINCT` does not apply. `HAVING` can tell you which values
    were unique or nonunique.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following statements show the days on which only one driver was active,
    and the days on which more than one driver was active. They’re based on using
    `HAVING` and `COUNT()` to determine which `trav_date` values are unique or nonunique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique works for combinations of values, too. For example, to find
    message sender/recipient pairs between whom only one message was sent, look for
    combinations that occur only once in the `mail` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note that this query doesn’t print the count. The previous examples did so,
    to show that the counts were being used properly, but you can refer to an aggregate
    value in a `HAVING` clause without including it in the output column list.
  prefs: []
  type: TYPE_NORMAL
- en: 10.12 Grouping by Expression Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to group rows into subgroups based on values calculated from an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `GROUP` `BY` clause, use an expression that categorizes values.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GROUP` `BY`, like `ORDER` `BY`, can refer to expressions. This means you can
    use calculations as the basis for grouping. As with `ORDER` `BY`, you can write
    the grouping expression directly in the `GROUP` `BY` clause, or use an alias for
    the expression (if it appears in the output column list), and refer to the alias
    in the `GROUP` `BY`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find days of the year on which more than one state joined the Union, group
    by statehood month and day, and then use `HAVING` and `COUNT()` to find the nonunique
    combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 10.13 Summarizing Noncategorical Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to summarize a set of values that are not naturally categorical.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use an expression to group the values into categories.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 10.12](#nch-sum-sum-expr) shows how to group rows by expression results.
    One important application for this is to categorize values that are not categorical.
    This is useful because `GROUP` `BY` works best for columns with repetitive values.
    For example, you might attempt to perform a population analysis by grouping rows
    in the `states` table using values in the `pop` column. That doesn’t work very
    well due to the high number of distinct values in the column. In fact, they’re
    *all* distinct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In situations like this, in which values do not group nicely into a small number
    of sets, use a transformation that forces them into categories. Begin by determining
    the range of population values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see from that result that if you divide the `pop` values by five million,
    they’ll group into eight categories—a reasonable number. (The category ranges
    will be 1 to 5,000,000, 5,000,001 to 10,000,000, and so forth.) To put each population
    value in the proper category, divide by five million, and use the integer result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Hmm. That’s not quite right. The expression groups the population values into
    a small number of categories, but doesn’t report the category values properly.
    Let’s try multiplying the `FLOOR()` results by five:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'That still isn’t correct. The maximum state population was 35,893,799, which
    should go into a category for 40 million, not one for 35 million. The problem
    here is that the category-generating expression groups values toward the lower
    bound of each category. To group values toward the upper bound instead, use the
    following technique. For categories of size *`n`*, place a value *`x`* into the
    proper category using this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'So the final form of our query looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The result shows clearly that the majority of US states have a population of
    five million or less.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some instances, it may be more appropriate to categorize groups on a logarithmic
    scale. For example, treat the state population values that way as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The query shows the number of states that have populations measured in hundreds
    of thousands, millions, and tens of millions, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that aliases in the preceding queries are written using
    backticks (identifier quoting) rather than single quotes (string quoting). Quoted
    aliases in the `GROUP` `BY` clause must use identifier quoting or the alias is
    treated as a constant string expression and the grouping produces the wrong result.
    Identifier quoting clarifies to MySQL that the alias refers to an output column.
    The aliases in the output column list could have been written using string quoting;
    we used backticks there to avoid mixing alias quoting styles within a given query.
  prefs: []
  type: TYPE_NORMAL
- en: 10.14 Finding Smallest or Largest Summary Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to compute per-group summary values but display only the smallest or
    largest of them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a `LIMIT` clause to the statement. Or use a user-defined variable or subquery
    to pick the appropriate summary.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`MIN()` and `MAX()` find the values at the endpoints of a set of values, but
    to find the endpoints of a set of summary values, those functions won’t work.
    Their argument cannot be another aggregate function. For example, you can easily
    find per-driver mileage totals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'To select only the row for the driver with the most miles, the following doesn’t
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, order the rows with the largest `SUM()` values first and use `LIMIT`
    to select the first row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if more than one row has the given summary value, a `LIMIT` `1` query
    won’t tell you that. For example, you might attempt to ascertain the most common
    initial letter for state names like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'But eight state names also begin with `N`. To find all most-frequent values
    when there may be more than one, use a user-defined variable or subquery to determine
    the maximum count, then select those values with a count equal to the maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 10.15 Producing Date-Based Summaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to produce a summary based on date or time values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `GROUP` `BY` to place temporal values into categories of the appropriate
    duration. Often this involves using expressions that extract the significant parts
    of dates or times.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To sort rows temporally, use `ORDER` `BY` with a temporal column. To summarize
    rows instead, based on groupings into time intervals, determine how to categorize
    rows into the proper intervals and use `GROUP` `BY` to group them accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to determine how many drivers were on the road and how many miles
    were driven each day, group the rows in the `driver_log` table by date:^([1](ch10.xhtml#idm45820368189088))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this per-day summary grows lengthier as you add more rows to the table.
    Over time, the number of distinct dates will become so large that the summary
    fails to be useful, and you’d probably decide to increase the category size. For
    example, this query categorizes by month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now the number of summary rows grows much more slowly over time. Eventually,
    you could summarize based only on year to collapse rows even more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uses for temporal categorizations are numerous:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce daily summaries from `DATETIME` or `TIMESTAMP` columns that have
    the potential to contain many unique values, strip the time-of-day part to collapse
    all values occurring within a given day to the same value. Any of the following
    `GROUP` `BY` clauses will do this, although the last one is likely to be slowest:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To produce monthly or quarterly sales reports, group by `MONTH(`*`col_name`*`)`
    or `QUARTER(`*`col_name`*`)` to place dates into the correct part of the year.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10.16 Working with Per-Group and Overall Summary Values Simultaneously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to produce a report that requires different levels of summary detail.
    Or you want to compare per-group summary values to an overall summary value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use two statements that retrieve different levels of summary information. Or
    use a subquery to retrieve one summary value and refer to it in the outer query
    that refers to other summary values. For applications that only display multiple
    summary levels (rather than perform additional calculations on them), `WITH` `ROLLUP`
    might be sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some reports involve multiple levels of summary information. The following
    report displays the total number of miles per driver from the `driver_log` table,
    along with each driver’s miles as a percentage of the total miles in the entire
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The percentages represent the ratio of each driver’s miles to the total miles
    for all drivers. To perform the percentage calculation, you need a per-group summary
    to get each driver’s miles and also an overall summary to get the total miles.
    First, run a query to get the overall mileage total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Then calculate the per-group values and use the overall total to compute the
    percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'To combine the two statements into one, use a subquery that computes the total
    miles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar problem uses multiple summary levels to compare per-group summary
    values with the corresponding overall summary value. Suppose that you want to
    display drivers who had a lower average miles per day than the group average.
    Calculate the overall average in a subquery, and then compare each driver’s average
    to the overall average using a `HAVING` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To display different summary-level values (and not perform calculations involving
    one summary level against another), add `WITH` `ROLLUP` to the `GROUP` `BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: In each case, the output row with `NULL` in the `name` column represents the
    overall sum or average calculated over all drivers.
  prefs: []
  type: TYPE_NORMAL
- en: '`WITH` `ROLLUP` produces multiple summary levels if you group by more than
    one column. The following statement shows the number of mail messages sent between
    each pair of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding `WITH` `ROLLUP` causes the output to include an intermediate count for
    each `srcuser` value (these are the lines with `NULL` in the `dstuser` column),
    plus an overall count at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 10.17 Generating a Report That Includes a Summary and a List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a report that displays a summary, together with the list
    of rows associated with each summary value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use two statements that retrieve different levels of summary information. Or
    use a programming language to do some of the work so that you can use a single
    statement.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that you want to produce a report that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For each driver in the `driver_log` table, the report shows the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: A summary line showing the driver name, the number of days on the road, and
    the number of miles driven.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list that details dates and mileages for the individual trips from which the
    summary values are calculated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This scenario is a variation on the <q>different levels of summary information</q>
    problem discussed in [Recipe 10.16](#nch-sum-sum-mixed). It may not seem like
    it at first because one of the types of information is a list rather than a summary.
    But that’s really just a <q>level zero</q> summary. This kind of problem appears
    in many other forms:'
  prefs: []
  type: TYPE_NORMAL
- en: You have a database that lists contributions to candidates in your political
    party. The party chair requests a printout that shows, for each candidate, the
    number of contributions and total amount contributed, as well as a list of contributor
    names and addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to create a handout for a company presentation that summarizes total
    sales per sales region with a list under each region showing the sales for each
    state in the region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Such problems have multiple solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Run separate statements to get the information for each level of detail that
    you require. (A single query won’t produce per-group summary values and a list
    of each group’s individual rows.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetch the rows that make up the lists and perform the summary calculations yourself
    to eliminate the summary statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s use each approach to produce the driver report shown at the beginning
    of this section. The following implementation (in Python) generates the report
    using one query to summarize the days and miles per driver, and another to fetch
    the individual trip rows for each driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative implementation performs summary calculations within the program,
    which reduces the number of queries required. If you iterate through the trip
    list and calculate the per-driver day counts and mileage totals yourself, a single
    query suffices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Should you require more levels of summary information, this type of problem
    gets more difficult. For example, you might want to precede the report that shows
    driver summaries and trip logs with a line that shows the total miles for all
    drivers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you need either another query to produce the total mileage, or
    another calculation in your program that computes the overall total.
  prefs: []
  type: TYPE_NORMAL
- en: 10.18 Generating Summaries from Temporary Result Sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to generate summaries, but cannot achieve it without using temporary
    result sets.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Common Table Expressions (CTE) by `WITH` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already discussed situations when a temporary table, holding result from
    a query, helps to create a summary. In these cases we referred the temporary table
    from the query, generating resulting summary. See [Recipe 10.6](#nch-sum-sum-assoc)
    and [Recipe 10.8](#nch-sum-sum-subgroup) for examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Temporary tables are not always the best solution for such a task. They have
    a number of disadvantages, particularly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to maintain the table: delete all content when you are going to reuse
    it and drop once you are finished to work with it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CREATE [TEMPORARY] TABLE ... SELECT` statement implicitly commits transaction,
    therefore it cannot be used when there is a possibility that the content of the
    original table changes after the data is inserted into the temporary table. You
    have to create the table first, then insert data into it and generate summary
    in the multiple statement transaction. For example, finding the longest trip per
    driver that we discussed in [Recipe 10.8](#nch-sum-sum-subgroup) may end up with
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Optimizer has less options to improve performance of the query.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common Table Expressions (CTE) allow to create a named temporary result set
    inside the query. Syntax of CTE is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Then you can refer the named result in the following query like if it was a
    regular table. You can define multiple CTE and can refer the same named result
    multiple times when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, example in [Recipe 10.17](#nch-sum-sum-sum-list), showing number of trips
    per driver and total mileage together with trip details could be resolved with
    a CTE.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_nch-sum-sum-with-with_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Keyword `WITH` starts CTE.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_nch-sum-sum-with-trips_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Assign name `trips` to the `SELECT`, retrieving travel data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_nch-sum-sum-with-summaries_co)'
  prefs: []
  type: TYPE_NORMAL
- en: The second named `SELECT` generates summary of the number of trips and total
    mileage per driver.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_nch-sum-sum-with-outer_co)'
  prefs: []
  type: TYPE_NORMAL
- en: The main query refers two named result sets and joins them using `LEFT JOIN`
    as if they were regular tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_nch-sum-sum-with-result_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Each resulting row contains number of trips, total amount of miles driven and
    details of the individual trip.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch10.xhtml#idm45820368189088-marker)) The result includes an entry only
    for dates actually represented in the table. To generate a summary with an entry
    for the range of dates in the table, use a join to fill in the <q>missing</q>
    values. See [Recipe 16.8](ch16.xhtml#nch-multi-multi-fill-hole).
  prefs: []
  type: TYPE_NORMAL
