- en: Chapter 18\. Seeing What Your Application Is Doing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have an application up and running, how do you know what it’s doing?
    This chapter covers how to figure out what kinds of queries MongoDB is running,
    how much data is being written, and other details about what it’s actually doing.
    You’ll learn about:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding slow operations and killing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting and interpreting statistics about your collections and databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using command-line tools to give you a picture of what MongoDB is doing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing the Current Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An easy way to find slow operations is to see what is running. Anything slow
    is more likely to show up and have been running for longer. It’s not guaranteed,
    but it’s a good first step to see what might be slowing down an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the operations that are running, use the `db.currentOp()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This displays a list of operations that the database is performing. Here are
    some of the more important fields in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"opid"`'
  prefs: []
  type: TYPE_NORMAL
- en: The operation’s unique identifier. You can use this number to kill an operation
    (see [“Killing Operations”](#sect2-killing)).
  prefs: []
  type: TYPE_NORMAL
- en: '`"active"`'
  prefs: []
  type: TYPE_NORMAL
- en: Whether this operation is running. If this field is `false`, it means the operation
    has yielded or is waiting for a lock.
  prefs: []
  type: TYPE_NORMAL
- en: '`"secs_running"`'
  prefs: []
  type: TYPE_NORMAL
- en: The duration of this operation in seconds. You can use this to find queries
    that are taking too long.
  prefs: []
  type: TYPE_NORMAL
- en: '`"microsecs_running"`'
  prefs: []
  type: TYPE_NORMAL
- en: The duration of this operation in microseconds. You can use this to find queries
    that are taking too long.
  prefs: []
  type: TYPE_NORMAL
- en: '`"op"`'
  prefs: []
  type: TYPE_NORMAL
- en: The type of operation. This is generally `"query"`, `"insert"`, `"update"`,
    or `"remove"`. Note that database commands are processed as queries.
  prefs: []
  type: TYPE_NORMAL
- en: '`"desc"`'
  prefs: []
  type: TYPE_NORMAL
- en: An identifier for the client. This can be correlated with messages in the logs.
    Every log message related to the connection in our example will be prefixed with
    `[conn3]`, so you can use this to grep the logs for relevant information.
  prefs: []
  type: TYPE_NORMAL
- en: '`"locks"`'
  prefs: []
  type: TYPE_NORMAL
- en: A description of the types of locks taken by this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`"waitingForLock"`'
  prefs: []
  type: TYPE_NORMAL
- en: Whether this operation is currently blocking, waiting to acquire a lock.
  prefs: []
  type: TYPE_NORMAL
- en: '`"numYields"`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of times this operation has yielded, releasing its lock to allow
    other operations to go. Generally, any operation that searches for documents (queries,
    updates, and removes) can yield. An operation will only yield if there are other
    operations enqueued and waiting to take its lock. Basically, if there are no operations
    in the `"waitingForLock"` state, the current operations will not yield.
  prefs: []
  type: TYPE_NORMAL
- en: '`"lockstats.timeAcquiringMicros"`'
  prefs: []
  type: TYPE_NORMAL
- en: How long it took this operation to acquire the locks it needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can filter `currentOp` to only look for operations fulfilling certain criteria,
    such as operations on a certain namespace or ones that have been running for a
    certain length of time. You filter the results by passing in a query argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can query on any field in `currentOp`, using all the normal query operators.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Problematic Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common use for `db.currentOp()` is looking for slow operations. You
    can use the filtering technique described in the previous section to find all
    queries that take longer than a certain amount of time, which may suggest a missing
    index or improper field filtering.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes people will find that unexpected queries are running, generally because
    there’s an app server running an old or buggy version of the software. The `"client"`
    field can help you track down where unexpected operations are coming from.
  prefs: []
  type: TYPE_NORMAL
- en: Killing Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you find an operation that you want to stop, you can kill it by passing
    `db.killOp()` its `"opid"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Not all operations can be killed. In general, operations can only be killed
    when they yield—so updates, finds, and removes can all be killed, but operations
    holding or waiting for a lock usually cannot be killed.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have sent a “kill” message to an operation, it will have a `"killed"`
    field in the `db.currentOp()` output. However, it won’t actually be dead until
    it disappears from the list of current operations.
  prefs: []
  type: TYPE_NORMAL
- en: In MongoDB 4.0, the `killOP` method was extended to allow it to run on a *mongos*.
    It can now kill queries (read operations) that are running across more than one
    shard in a cluster. In previous versions, this involved manually issuing the kill
    command across each shard on the respective primary *mongod*.
  prefs: []
  type: TYPE_NORMAL
- en: False Positives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you look for slow operations, you may see some long-running internal operations
    listed. There are several long-running requests MongoDB may have running, depending
    on your setup. The most common are the replication thread (which will continue
    fetching more operations from the sync source for as long as possible) and the
    writeback listener for sharding. Any long-running query on *local.oplog.rs* can
    be ignored, as well as any [*writebacklistener* commands](https://oreil.ly/95e3x).
  prefs: []
  type: TYPE_NORMAL
- en: If you kill either of these operations, MongoDB will just restart them. However,
    you generally should not do that. Killing the replication thread will briefly
    halt replication, and killing the writeback listener may cause *mongos* to miss
    legitimate write errors.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Phantom Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is an odd, MongoDB-specific issue that you may run into, particularly
    if you’re bulk-loading data into a collection. Suppose you have a job that is
    firing thousands of update operations at MongoDB and MongoDB is grinding to a
    halt. You quickly stop the job and kill off all the updates that are currently
    occurring. However, you continue to see new updates appearing as soon as you kill
    the old ones, even though the job is no longer running!
  prefs: []
  type: TYPE_NORMAL
- en: If you are loading data using unacknowledged writes, your application will fire
    writes at MongoDB, potentially faster than MongoDB can process them. If MongoDB
    gets backed up, these writes will pile up in the operating system’s socket buffer.
    When you kill the writes MongoDB is working on, this allows MongoDB to start processing
    the writes in the buffer. Even if you stop the client from sending writes, any
    writes that made it into the buffer will get processed by MongoDB, since they’ve
    already been “received” (just not processed).
  prefs: []
  type: TYPE_NORMAL
- en: 'The best way to prevent these phantom writes is to do *acknowledged* writes:
    make each write wait until the previous write is complete, not just until the
    previous write is sitting in a buffer on the database server.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the System Profiler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find slow operations you can use the system profiler, which records operations
    in a special *system.profile* collection. The profiler can give you tons of information
    about operations that are taking a long time, but at a cost: it slows down *mongod*’s
    overall performance. Thus, you may only want to turn on the profiler periodically
    to capture a slice of traffic. If your system is already heavily loaded, you may
    wish to use another technique described in this chapter to diagnose issues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the profiler is off and does not record anything. You can turn
    it on by running `db.setProfilingLevel()` in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Level 2 means “profile everything.” Every read and write request received by
    the database will be recorded in the *system.profile* collection of the current
    database. Profiling is enabled per-database and incurs a heavy performance penalty:
    every write has to be written an extra time and every read has to take a write
    lock (because it must write an entry to the *system.profile* collection). However,
    it will give you an exhaustive listing of what your system is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `"client"` field to see which users are sending which operations
    to the database. If you’re using authentication, you can see which user is doing
    each operation, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you do not care about most of the operations that your database is doing,
    just the slow ones. For this, you can set the profiling level to 1\. By default,
    level 1 profiles operations that take longer than 100 ms. You can also specify
    a second argument, which defines what “slow” means to you. This would record all
    operations that took longer than 500 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To turn profiling off, set the profiling level to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s generally not a good idea to set `slowms` to a low value. Even with profiling
    off, `slowms` has an effect on *mongod*: it sets the threshold for printing slow
    operations in the log. Thus, if you set `slowms` to `2`, every operation that
    takes longer than 2 ms will show up in the log, even with profiling off. So, if
    you lower `slowms` to profile something, you might want to raise it again before
    turning off profiling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the current profiling level with `db.getProfilingLevel()`. The
    profiling level is not persistent: restarting the database clears the level.'
  prefs: []
  type: TYPE_NORMAL
- en: There are command-line options for configuring the profiling level, namely ``--profile
    *`level`*`` and ``--slowms *`time`*``, but bumping up the profiling level is generally
    a temporary debugging measure, not something you want to add to your configuration
    long-term.
  prefs: []
  type: TYPE_NORMAL
- en: In MongoDB 4.2, profiler entries and diagnostic log messages were extended for
    read/write operations to help improve the identification of slow queries, with
    the addition of the `queryHash` and `planCacheKey` fields. The `queryHash` string
    represents a hash of the query shape and is dependent only on the query shape.
    Each query shape is associated with a `queryHash`, making it easier to highlight
    those queries using the same shape. The `planCacheKey` is the hash of the key
    for the plan cache entry associated with the query. It includes the details of
    both the query shape and the currently available indexes for the shape. These
    help you correlate the available information from the profiler to assist with
    query performance diagnosis.
  prefs: []
  type: TYPE_NORMAL
- en: If you turn on profiling and the *system.profile* collection does not already
    exist, MongoDB creates a small capped collection for it (a few megabytes in size).
    If you want to run the profiler for an extended period of time, this may not be
    enough space for the number of operations you need to record. You can make a larger
    *system.profile* collection by turning off profiling, dropping the *system.profile*
    collection, and creating a new *system.profile* capped collection that is the
    size you desire. Then enable profiling on the database.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Sizes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to provision the correct amount of disk and RAM, it is useful to know
    how much space documents, indexes, collections, and databases are taking up. See
    [“Calculating the Working Set”](ch22.xhtml#working-set) for information on calculating
    your working set.
  prefs: []
  type: TYPE_NORMAL
- en: Documents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to get the size of a document is to use the shell’s `Object.bsonsize()`
    function. Pass in any document to get the size it would be when stored in MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can see that storing `_id`s as `ObjectId`s is more efficient
    than storing them as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'More practically, you can pass in documents directly from your collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This shows you exactly how many bytes a document is taking up on disk. However,
    this does not count padding or indexes, which can often be significant factors
    in the size of a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For seeing information about a whole collection, there is a `stats` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`stats` starts with the namespace (`"sample_mflix.movies"`) and then the count
    of all documents in the collection. The next couple of fields have to do with
    the size of the collection. `"size"` is what you’d get if you called `Object.bsonsize()`
    on each element in the collection and added up all the sizes: it’s the actual
    number of bytes in memory the documents in the collection are taking up when uncompressed.
    Equivalently, if you take the `"avgObjSize"` and multiply it by `"count"`, you’ll
    get `"size"` uncompressed in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, a total count of the documents’ bytes leaves out the space
    saved by compressing a collection. `"storageSize"` can be a smaller figure than
    `"size"`, reflecting the space saved by compression.
  prefs: []
  type: TYPE_NORMAL
- en: '`"nindexes"` is the number of indexes on the collection. An index is not counted
    in `"nindexes"` until it finishes being built and cannot be used until it appears
    in this list. In general, indexes will be a lot larger than the amount of data
    they store. You can minimize this free space by having right-balanced indexes
    (as described in [“Introduction to Compound Indexes”](ch05.xhtml#sec2-compound)).
    Indexes that are randomly distributed will generally be approximately 50% free
    space, whereas ascending-order indexes will be 10% free space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As your collections get bigger, it may become difficult to read `stats` output
    with sizes in the billions of bytes or beyond. Thus, you can pass in a scaling
    factor: `1024` for kilobytes, `1024*1024` for megabytes, and so on. For example,
    this would get the collection stats in terabytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Databases have a `stats` function that’s similar to collections’:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we have the name of the database, the number of collections it contains,
    and the number of views for the database. `"objects"` is the total count of documents
    across all collections in this database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bulk of the document contains information about the size of your data.
    `"fsTotalSize"` should always be the largest: it is the total size of the disk
    capacity on the filesystem where the MongoDB instance stores data. `"fsUsedSize"`
    represents the total space used in that filesystem by MongoDB currently. This
    should correspond to the total space used by all the files in your data directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The next-largest field is generally going to be `"dataSize"`, which is the size
    of the uncompressed data held in this database. This doesn’t match `"storageSize"`
    because data is typically compressed in WiredTiger. `"indexSize"` is the amount
    of space all of the indexes for this database take up.
  prefs: []
  type: TYPE_NORMAL
- en: '`db.stats()` can take a scale argument the same way that the collections’ `stats`
    function can. If you call `db.stats()` on a nonexistent database, the values will
    all be zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that listing databases on a system with a high lock percent can
    be very slow and block other operations. Avoid doing it, if possible.
  prefs: []
  type: TYPE_NORMAL
- en: Using mongotop and mongostat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB comes with a few command-line tools that can help you determine what
    it’s doing by printing stats every few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'mongotop is similar to the *top* Unix utility: it gives you an overview of
    which collections are busiest. You can also run `mongotop --locks` to give you
    locking statistics for each database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'mongostat gives server-wide information. By default, `mongostat` prints out
    a list of statistics once per second, although this is configurable by passing
    a different number of seconds on the command line. Each of the fields gives a
    count of how many times the activity has happened since the field was last printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insert/query/update/delete/getmore/command`'
  prefs: []
  type: TYPE_NORMAL
- en: Simple counts of how many of each of these operations there have been.
  prefs: []
  type: TYPE_NORMAL
- en: '`flushes`'
  prefs: []
  type: TYPE_NORMAL
- en: How many times *mongod* has flushed data to disk.
  prefs: []
  type: TYPE_NORMAL
- en: '`mapped`'
  prefs: []
  type: TYPE_NORMAL
- en: The amount of memory *mongod* has mapped. This is generally roughly the size
    of your data directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`vsize`'
  prefs: []
  type: TYPE_NORMAL
- en: The amount of virtual memory *mongod* is using. This is generally twice the
    size of your data directory (once for the mapped files, once again for journaling).
  prefs: []
  type: TYPE_NORMAL
- en: '`res`'
  prefs: []
  type: TYPE_NORMAL
- en: The amount of memory *mongod* is using. This should generally be as close as
    possible to all the memory on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: '`locked db`'
  prefs: []
  type: TYPE_NORMAL
- en: The database that spent the most time locked in the last timeslice. This field
    reports the percent of time the database was locked combined with how long the
    global lock was held, meaning that this value might be over 100%.
  prefs: []
  type: TYPE_NORMAL
- en: '`idx miss %`'
  prefs: []
  type: TYPE_NORMAL
- en: The percentage of index accesses that had to page fault (because the index entry
    or section of index being searched was not in memory, so *mongod* had to go to
    disk). This is the most confusingly named field in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '`qr|qw`'
  prefs: []
  type: TYPE_NORMAL
- en: The queue size for reads and writes (i.e., how many reads and writes are blocking,
    waiting to be processed).
  prefs: []
  type: TYPE_NORMAL
- en: '`ar|aw`'
  prefs: []
  type: TYPE_NORMAL
- en: How many active clients there are (i.e., clients currently performing reads
    and writes).
  prefs: []
  type: TYPE_NORMAL
- en: '`netIn`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of network bytes in, as counted by MongoDB (not necessarily the same
    as what the OS would measure).
  prefs: []
  type: TYPE_NORMAL
- en: '`netOut`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of network bytes out, as counted by MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: '`conn`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of connections this server has open, both incoming and outgoing.
  prefs: []
  type: TYPE_NORMAL
- en: '`time`'
  prefs: []
  type: TYPE_NORMAL
- en: The time at which these statistics were taken.
  prefs: []
  type: TYPE_NORMAL
- en: You can run *mongostat* on a replica set or sharded cluster. If you use the
    `--discover` option, *mongostat* will try to find all the members of the set or
    cluster from the member it initially connects to and will print one line per server
    per second for each. For a large cluster, this can get unmanageable fast, but
    it can be useful for small clusters and tools that can consume the data and present
    it in a more readable form.
  prefs: []
  type: TYPE_NORMAL
- en: '*mongostat* is a great way to get a quick snapshot of what your database is
    doing, but for long-term monitoring a tool like MongoDB Atlas or Ops Manager is
    preferred (see [Chapter 22](ch22.xhtml#chapter-mms)).'
  prefs: []
  type: TYPE_NORMAL
