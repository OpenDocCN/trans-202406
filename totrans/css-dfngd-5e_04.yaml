- en: Chapter 4\. Specificity, Inheritance, and the Cascade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chapters [2](ch02.html#selectors) and [3](ch03.html#pseudo_classes_and_elements)
    showed how document structure and CSS selectors allow you to apply a wide variety
    of styles to elements. Knowing that every valid document generates a structural
    tree, you can create selectors that target elements based on their ancestors,
    attributes, sibling elements, and more. The structural tree is what allows selectors
    to function and is also central to a similarly crucial aspect of CSS: inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inheritance* is the mechanism by which some property values are passed on
    from an element to a descendant element. When determining which values should
    apply to an element, a user agent must consider not only inheritance but also
    the *specificity* of the declarations, as well as the origin of the declarations
    themselves. This process of consideration is what’s known as the *cascade*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will explore the interrelation between these three mechanisms—specificity,
    inheritance, and the cascade—in this chapter. For now, the difference between
    the latter two can be summed up this way: when we write `h1 {color: red; color:
    blue;}`, the `<h1>` becomes blue because of the cascade, and any `<span>` inside
    the `<h1>` also becomes blue because of inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Above all, regardless of how abstract things may seem, keep going! Your perseverance
    will be rewarded.
  prefs: []
  type: TYPE_NORMAL
- en: Specificity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You know from Chapters [2](ch02.html#selectors) and [3](ch03.html#pseudo_classes_and_elements)
    that you can select elements by using a wide variety of means. In fact, the same
    element can often be selected by two or more rules, each with its own selector.
    Let’s consider the following three pairs of rules. Assume that each pair will
    match the same element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Only one of the two rules in each pair can be applied, or “win,” since the matched
    elements can be only one color at a time. How do we know which one will win?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is found in the *specificity* of each selector. For every rule, the
    user agent (i.e., a web browser) evaluates the specificity of the selector and
    attaches the specificity to each declaration in the rule within the cascade layer
    that has precedence. When an element has two or more conflicting property declarations,
    the one with the highest specificity will win out.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This isn’t the whole story in terms of conflict resolution, which is a bit more
    complicated than a single paragraph can cover. For now, just keep in mind that
    selector specificity is compared only to other selectors that share the same origin
    and cascade layer. We’ll cover those terms, and more in [“The Cascade”](#the_cascade).
  prefs: []
  type: TYPE_NORMAL
- en: 'A selector’s specificity is determined by the components of the selector itself.
    A specificity value can be expressed in three parts, like this: `0,0,0`. The actual
    specificity of a selector is determined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: For every ID attribute value given in the selector, add `1,0,0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every class attribute value, attribute selection, or pseudo-class given
    in the selector, add `0,1,0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For every element and pseudo-element given in the selector, add `0,0,1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combinators do not contribute anything to the specificity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anything listed inside a `:where()` pseudo-class, and the universal selector,
    adds `0,0,0`. (While they do not contribute anything to the specificity weight,
    they do match elements, unlike combinators.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specificity of an `:is()`, `:not()`, or `:has()` pseudo-class is equal to
    the specificity of the most specific selector in its selector list argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the following rules’ selectors result in the indicated specificities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If an `<em>` element is matched by both the second and fifth rules in this example,
    that element will be maroon because the sixth rule’s specificity outweighs the
    second’s.
  prefs: []
  type: TYPE_NORMAL
- en: Take special note of the next-to-last selector, `*:is(aside#warn, code)`. The
    `:is()` pseudo-class is one of a small group of pseudo-classes for which the specificity
    is equal to the most specific selector in the selector list. Here, the selector
    list is `aside#warn, code`. The `aside#warn` compound selector has a specificity
    of `1,0,1`, and the `code` selector has a specificity of `0,0,1`. Thus, the whole
    `:is()` portion of the selector is set to the specificity of the `aside#warn`
    selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s return to the pairs of rules from earlier in the section and fill
    in the specificities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’ve indicated the winning rule in each pair; in each case, it’s because the
    specificity is higher. Notice how they’re listed and that the order of the rules
    doesn’t matter here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second pair, the selector `h2.grape` wins because it has an extra class:
    `0,1,1` beats out `0,0,1`. In the third pair, the second rule wins because `1,0,1`
    wins out over `0,1,7`. In fact, the specificity value `0,1,0` would win out over
    the value `0,0,13`.'
  prefs: []
  type: TYPE_NORMAL
- en: This happens because the values are compared from left to right. A specificity
    of `1,0,0` will win out over any specificity that begins with a `0`, no matter
    what the rest of the numbers might be. So `1,0,1` wins over `0,1,7` because the
    `1` in the first value’s first position beats the `0` in the second value’s first
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Declarations and Specificity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the specificity of a selector has been determined, the specificity value
    will be conferred on all of its associated declarations. Consider this rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For specificity purposes, the user agent must treat the rule as if it were
    “ungrouped” into separate rules. Thus, the previous example would become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both have a specificity of `0,0,1`, and that’s the value conferred on each declaration.
    The same splitting-up process happens with a grouped selector as well. Given the
    rule,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'the user agent treats it as if it were the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes important when multiple rules match the same element and some
    of the declarations clash. For example, consider these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When applied to the following markup, the content will be rendered as shown
    in [Figure 4-1](#how_different_rules_affect_a_document):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0401](assets/css5_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. How different rules affect a document
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In every case, the user agent determines which rules match a given element,
    calculates all of the associated declarations and their specificities, determines
    which rules win out, and then applies the winners to the element to get the styled
    result. These machinations must be performed on every element, selector, and declaration.
    Fortunately, the user agent does it all automatically and nearly instantly. This
    behavior is an important component of the cascade, which we’ll discuss later in
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving Multiple Matches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When an element is matched by more than one selector in a grouped selector,
    the most specific selector is used. Consider the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have one rule with a grouped selector, and each of the individual selectors
    has a very different specificity. Now suppose we find this in our HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Every one of the selectors in the grouped selector applies to the list item!
    Which one is used for specificity purposes? The most specific. Thus, in this example,
    the blue is applied with a specificity of `1,3,1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed that we repeated the `happy` class name three times
    in one of the selectors. This is a bit of hack that can be used with classes,
    attributes, pseudo-classes, and even ID selectors to increase specificity. Do
    be careful with it, since artificially inflating specificity can create problems
    in the future: you might want to override that rule with another, and that rule
    will need even more classes chained together.'
  prefs: []
  type: TYPE_NORMAL
- en: Zeroed Selector Specificity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The universal selector does not contribute to specificity. It has a specificity
    of `0,0,0`, which is different from having no specificity (as we’ll discuss in
    [“Inheritance”](#inheritance)). Therefore, given the following two rules, a paragraph
    descended from a `<div>` will be black, but all other elements will be gray:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This means the specificity of a selector that contains a universal selector
    along with other selectors is not changed by the presence of the universal selector.
    The following two selectors have exactly the same specificity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The same is true for the `:where()` pseudo-class, regardless of whatever selectors
    might be in its selector list. Thus, `:where(aside#warn, code)` has a specificity
    of `0,0,0`.
  prefs: []
  type: TYPE_NORMAL
- en: Combinators, including `~`, `>`, `+`, and the space character, have no specificity
    at all—not even zero specificity. Thus, they have no impact on a selector’s overall
    specificity.
  prefs: []
  type: TYPE_NORMAL
- en: ID and Attribute Selector Specificity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s important to note the difference in specificity between an ID selector
    and an attribute selector that targets an `id` attribute. Returning to the third
    pair of rules in the example code, we find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The ID selector (`#answer`) in the second rule contributes `1,0,0` to the overall
    specificity of the selector. In the first rule, however, the attribute selector
    (`[id="totals"]`) contributes `0,1,0` to the overall specificity. Thus, given
    the following rules, the element with an `id` of `meadow` will be green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Importance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes a declaration is so important that it outweighs all other considerations.
    CSS calls these *important declarations* (for hopefully obvious reasons) and lets
    you mark them by inserting the flag `!important` just before the terminating semicolon
    in a declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the color value of `#333` is marked with the `!important` flag, whereas
    the background value of `white` is not. If you wish to mark both declarations
    as important, each declaration needs its own `!important` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You must place the `!important` flag correctly, or the declaration may be invalidated:
    `!important` *always* goes at the end of a declaration, just before the semicolon.
    This placement is especially critical when it comes to properties that allow values
    containing multiple keywords, such as `font`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If `!important` were placed anywhere else in the `font` declaration, the entire
    declaration would likely be invalidated and none of its styles applied.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We realize that to those of you who come from a programming background, the
    syntax of this token instinctively translates to “not important.” For whatever
    reason, the bang (`!`) was chosen as the delimiter for important flags, and it
    does *not* mean “not” in CSS, no matter how many other languages give it that
    very meaning. This association is unfortunate, but we’re stuck with it.
  prefs: []
  type: TYPE_NORMAL
- en: Declarations that are marked `!important` do not have a special specificity
    value, but are instead considered separately from unimportant declarations. In
    effect, all `!important` declarations are grouped together, and specificity conflicts
    are resolved within that group. Similarly, all unimportant declarations are considered
    as a group, with any conflicts within the unimportant group as described previously.
    Thus, in any case where an important and an unimportant declaration conflict,
    an important declaration will always win (unless the user agent or user have declared
    the same property as important, which you’ll see later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-2](#important_rules_always_win) illustrates the result of the following
    rules and markup fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0402](assets/css5_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Important rules always win
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s generally bad practice to use `!important` in your CSS, and it is rarely
    needed. If you find yourself reaching for `!important`, stop and look for other
    ways to get the same result without using `!important`. Cascade layers are one
    such possibility; see [“Sorting by Cascade Layer”](#sorting_by_layer) for more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another key concept in understanding how styles are applied to elements is
    *inheritance*. Inheritance is the mechanism by which some styles are applied not
    only to a specified element, but also to its descendants. If a color is applied
    to an `<h1>` element, for example, that color is applied to all text inside the
    `<h1>`, even the text enclosed within child elements of that `<h1>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Both the ordinary `<h1>` text and the `<em>` text are colored gray because the
    `<em>` element inherits the value of `color` from the `<h1>`. If property values
    could not be inherited by descendant elements, the `<em>` text would be black,
    not gray, and we’d have to color the elements separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an unordered list. Let’s say we apply a style of `color: gray;` for
    `<ul>` elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We expect that style applied to a `<ul>` will also be applied to its list items,
    as well as to any content of those list items, including the marker (i.e., the
    bullet next to each list item). Thanks to inheritance, that’s exactly what happens,
    as [Figure 4-3](#inheritance_of_styles) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0403](assets/css5_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Inheritance of styles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s easier to see how inheritance works by turning to a tree diagram of a document.
    [Figure 4-4](#a_simple_tree_diagram) shows the tree diagram for a document much
    like the very simple document shown in [Figure 4-3](#inheritance_of_styles).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0404](assets/css5_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. A simple tree diagram
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When the declaration `color: gray;` is applied to the `<ul>` element, that
    element takes on that declaration. The value is then propagated down the tree
    to the descendant elements and continues on until no more descendants remain to
    inherit the value. Values are *never* propagated upward; an element never passes
    values up to its ancestors.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The upward propagation rule in HTML has a notable exception: background styles
    applied to the `<body>` element can be passed to the `<html>` element, which is
    the document’s root element and therefore defines its canvas. This happens only
    if the `<body>` element has a defined background and the `<html>` element does
    not. A few other properties share this body-to-root behavior, such as `overflow`,
    but it happens only with the `<body>` element. No other elements risk inheriting
    properties from a descendant.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is one of those things about CSS that is so basic that you almost
    never think about it unless you have to. However, you should still keep a couple
    of things in mind.
  prefs: []
  type: TYPE_NORMAL
- en: First, note that many properties are not inherited—generally in order to avoid
    undesirable outcomes. For example, the property `border` (which is used to set
    borders on elements) does not inherit. A quick glance at [Figure 4-5](#why_borders_arenat_inherited)
    reveals why this is the case. If borders were inherited, documents would become
    much more cluttered—unless the author took the extra effort to turn off the inherited
    borders.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0405](assets/css5_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. Why borders aren’t inherited
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As it happens, most of the box-model properties—including margins, padding,
    backgrounds, and borders—are not inherited for the same reason. After all, you
    likely wouldn’t want all of the links in a paragraph to inherit a 30-pixel left
    margin from their parent element!
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, inherited values have no specificity at all, not even zero specificity.
    This seems like an academic distinction until you work through the consequences
    of the lack of inherited specificity. Consider the following rules and markup
    fragment and compare them to the result shown in [Figure 4-6](#zero_specificity_defeats_no_specificity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0406](assets/css5_0406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-6\. Zero specificity defeats no specificity
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since the universal selector applies to all elements and has zero specificity,
    its color declaration’s value of `gray` wins out over the inherited value of `black`,
    which has no specificity at all. (And now you may understand why we listed `:where()`
    and the universal selector as having `0,0,0` specificity: they add no weight,
    but do match elements.) Therefore, the `<em>` element is rendered gray instead
    of black.'
  prefs: []
  type: TYPE_NORMAL
- en: This example vividly illustrates one of the potential problems of using the
    universal selector indiscriminately. Because it can match *any* element or pseudo-element,
    the universal selector often has the effect of short-circuiting inheritance. This
    can be worked around, but it’s usually more sensible to avoid the problem in the
    first place by not using the universal selector by itself indiscriminately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete lack of specificity for inherited values is not a trivial point.
    For example, assume that a stylesheet has been written such that all text in a
    toolbar is to be white on black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will work so long as the element with an `id` of `toolbar` contains nothing
    but plain text. If, however, the text within this element is all hyperlinks (`a`
    elements), then the user agent’s styles for hyperlinks will take over. In a web
    browser, this means they’ll likely be colored blue, since the browser’s internal
    stylesheet probably contains an entry like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'To overcome this problem, you must declare something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: By targeting a rule directly at the `a` elements within the toolbar, you’ll
    get the result shown in [Figure 4-7](#directly_assigning_styles_to_the_relevan).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0407](assets/css5_0407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-7\. Directly assigning styles to the relevant elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another way to get the same result is to use the value `inherit`, covered in
    the next chapter. We can alter the previous example like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This also leads to the result shown in [Figure 4-7](#directly_assigning_styles_to_the_relevan),
    because the value of `color` is explicitly inherited thanks to an assigned rule
    whose selector has specificity.
  prefs: []
  type: TYPE_NORMAL
- en: The Cascade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we’ve skirted one rather important issue: what happens
    when two rules of equal specificity apply to the same element? How does the browser
    resolve the conflict? For example, consider the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Which one wins? Both have a specificity of `0,0,1`, so they have equal weight
    and should both apply. That can’t be the case because the element can’t be both
    red and blue. So which will it be?
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, the name *Cascading Style Sheets* comes into focus: CSS is based on
    a method of causing styles to *cascade* together, which is made possible by combining
    inheritance and specificity with a few rules. The cascade rules for CSS are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find all rules containing a selector that matches a given element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort all declarations applying to the given element by *explicit weight*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Sort all declarations applying to the given element by *origin*. There are
    three basic origins: author, reader, and user agent. Under normal circumstances,
    the author’s styles (that is, your styles as the author of the page) win out over
    the reader’s styles, and both author and reader styles override the user agent’s
    default styles. This is reversed for rules marked `!important`, where user agent
    styles override author styles, and both override reader styles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort all declarations applying to the given element by *encapsulation context*.
    If a style is assigned via a shadow DOM, for example, it has an encapsulation
    context for all elements within that same shadow DOM and does not apply to elements
    outside that shadow DOM. This allows encapsulated styles to override styles that
    are inherited from outside the shadow DOM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort all declarations by whether they are *element attached*. Styles assigned
    via a `style` attribute are element attached. Styles assigned from a stylesheet,
    whether external or embedded, are not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort all declarations by *cascade layer*. For normal-weight styles, the later
    a cascade layer first appears in the CSS, the greater the precedence. Styles without
    a layer are considered to be part of a “default” final pseudo-layer, one that
    has higher precedence than styles in explicitly created layers. For important-weight
    styles, the *earlier* a cascade layer appears in the CSS, the greater its precedence,
    and all important-weight styles in explicitly created layers win out over styles
    in the default layer, important or otherwise. Cascade layers can appear in any
    origin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort all declarations applying to the given element by *specificity*. Those
    elements with a higher specificity have more weight than those with lower specificity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sort all declarations applying to the given element by *order of appearance*.
    The later a declaration appears in the stylesheet or document, the more weight
    it is given. Declarations that appear in an imported stylesheet are considered
    to come before all declarations within the stylesheet that imports them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To be clear about how this all works, let’s consider examples that illustrate
    some of the cascade rules.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by Importance and Origin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If two rules apply to an element, and one is marked `!important`, the important
    rule wins out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Even though a color is assigned in the `style` attribute of the paragraph, the
    `!important` rule wins out, and the paragraph is gray. This occurs because sorting
    by `!important` has higher precedence than sorting by element-attached styles
    (`style=""`). The gray is inherited by the `<em>` element as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that if `!important` is added to the inline style in this situation, *it*
    will be the winner. Thus, given the following, the paragraph (and its descendant
    element) will be black:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the importance is the same, the origin of a rule is considered. If an element
    is matched by normal styles in both the author’s stylesheet and the reader’s stylesheet,
    the author’s styles are used. For example, assume that the following styles come
    from the indicated origins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, emphasized text within paragraphs is colored black, not yellow,
    because the author styles win out over the reader styles. However, if both rules
    are marked `!important`, the situation changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now the emphasized text in paragraphs will be yellow, not black.
  prefs: []
  type: TYPE_NORMAL
- en: As it happens, the user agent’s default styles—which are often influenced by
    the user preferences—are figured into this step. The default style declarations
    are the least influential of all. Therefore, if an author-defined rule applies
    to anchors (e.g., declaring them to be `white`), then this rule overrides the
    user agent’s defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, CSS has eight basic levels to consider in terms of declaration precedence.
    In order of most to least precedence, these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Transition declarations (see [Chapter 18](ch18.html#x-transitions))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User agent important declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader important declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Author important declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Animation declarations (see [Chapter 19](ch19.html#animation))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Author normal declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reader normal declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: User agent declarations
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, a transition style will override all other rules, regardless of whether
    those other rules are marked `!important` or from what origin the rules come.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by Element Attachment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Styles can be attached to an element by using a markup attribute such as `style`.
    These are called *element-attached* styles, and they are outweighed only by considerations
    of origin and weight.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, consider the following rule and markup fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that the rule is applied to the `<h1>` element, you would still probably
    expect the text of the `<h1>` to be green. This happens because every inline declaration
    is element attached, and so has a higher weight than styles that aren’t element
    attached, like the `color: red` rule.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that even elements with `id` attributes that match a rule will obey
    the inline style declaration. Let’s modify the previous example to include an
    `id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the inline declaration’s weight, the text of the `<h1>` element will
    still be green.
  prefs: []
  type: TYPE_NORMAL
- en: Just remember that inline styles are generally a bad practice, so try not to
    use them if at all possible.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by Cascade Layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Cascade layers* allow authors to group styles together so that they share
    a precedence level within the cascade. This might sound like `!important`; in
    some ways they are similar—but in others, very different. This is easier to demonstrate
    than it is to describe. The ability to create cascade layers means authors can
    balance various needs, such as the needs of a component library, against the needs
    of a specific page or part of a web app.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Cascade layers were introduced to CSS at the end of 2021, so browser support
    for them exists only in browsers released from that point forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'If conflicting declarations apply to an element and all have the same explicit
    weight and origin, and none are element attached, they are next sorted by cascade
    layer. The order of precedence for layers is set by the order in which the layers
    are first declared or used, with later declared layers taking precedence over
    earlier declared layers for normal styles. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: These `<h1>` elements will be colored blue. This is because the `page` layer
    comes later in the CSS than the `site` layer, and so has higher precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any style not part of a named cascade layer is assigned to an implicit “default”
    layer, one that has higher precedence than any named layer for unimportant rules.
    Suppose we alter the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<h1>` elements will now be maroon, because the implicit “default” layer
    to which the `h1 {color: maroon;}` belongs has higher precedence than any named
    layer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define a specific precedence order for named cascade layers. Consider
    the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the first line defines an order of precedence for the layers: the `page`
    layer will be given higher precedence than the `site` layer for normal-weight
    rules like those shown in the example. Thus, in this case, `<h1>` elements will
    be blue, because when the layers are sorted, `page` is given more precedence than
    `site`. For important-flagged rules, the order of precedence is reversed. Thus,
    if both rules were marked `!important`, the precedence would flip and `<h1>` elements
    would be red.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s talk a little bit more about how cascade layers specifically work, especially
    since they’re so new to CSS. Let’s say you want to define three layers: one for
    the basic site styles, one for individual page styles, and one for a component
    library whose styles are imported from an external stylesheet. The CSS might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This ordering will have normal-weight `components` styles override and `page`
    and `site` normal-weight styles, and normal-weight `page` styles will override
    only `site` normal-weight styles. Conversely, important `site` styles will override
    all `page` and `components` styles, whether they’re important or normal weight,
    and `page` important styles will override all `components` styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a small example of how layers might be managed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This example has three imported stylesheets, one of which is assigned to the
    `site` layer and two of which are in the `component` layer. Then some rules are
    assigned to the `page` layer, and a couple of rules are placed in the `site` layer.
    The rules in the `@layer site {}` block will be combined with the rules from `/c/site.css`
    into a single `site` layer.
  prefs: []
  type: TYPE_NORMAL
- en: After that, there’s a rule outside the explicit cascade layers, which means
    it’s part of the implicit “default” layer. Rules in this default layer will override
    the styles of any of the other layers. So, given the code shown, paragraphs will
    have top margins of `1em`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But before all of that, a directive sets the precedence order of the named
    layers: `page` overrules `component` and `site`, and `component` overrules `site`.
    Here’s how those various rules are grouped as far as the cascade is concerned,
    with comments to describe their placement in the sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the later a layer comes in the ordering of the layers, the more
    weight it’s given by the cascade’s sorting algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be clear, cascade layers don’t have to be named. Naming just keeps things
    a lot clearer in terms of setting an order for them, and it also enables adding
    styles to the layer. Here are some examples of using unnamed cascade layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the rules imported from *base.css* are assigned to an unnamed
    layer. Even though this layer doesn’t actually have a name, let’s think of it
    as CL1\. Then a rule outside the layers sets paragraph top margins to `1em`. Finally,
    an unnamed layer block has a couple of rules; let’s think of this layer as CL2.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we have rules in three layers: CL1, CL2, and the implicit layer. And
    that’s the order they’re considered in, so in the case of any conflicting normal
    rules, the rules in the implicit default layer (which comes last in the ordering)
    will win over conflicting rules in the other two layers, and rules in CL2 will
    win over conflicting rules in CL1.'
  prefs: []
  type: TYPE_NORMAL
- en: At least, that’s the case for normal-weight rules. For `!important` rules, the
    order of precedence is flipped, so those in CL1 will win over conflicting important
    rules in the other two layers, and important rules in CL2 win over conflicting
    important rules in the implicit layer. Strange but true!
  prefs: []
  type: TYPE_NORMAL
- en: This sorting by order will come up again in just a little bit, but first let’s
    bring specificity into the cascade.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by Specificity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If conflicting declarations apply to an element and those declarations all
    have the same explicit weight, origin, element attachment (or lack thereof), and
    cascade layer, they are then sorted by specificity. The most specific declaration
    wins out, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Given these rules, the text of the paragraph will be silver, as illustrated
    in [Figure 4-8](#higher_specificity_wins_out_over_lower). Why? Because the specificity
    of `p#bright` (`1,0,1`) overrides the specificity of `p` (`0,0,1)`, even though
    the latter rule comes later in the stylesheet. The styles from the `page` layer,
    even though they have the strongest selector (`3,0,1`), aren’t even compared.
    Only the declarations from the layer with precedence are in contention.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0408](assets/css5_0408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-8\. Higher specificity wins out over lower specificity
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember that this rule applies only if the rules are part of the same cascade
    layer. If not, specificity doesn’t matter: a `0,0,1` selector in the implicit
    layer will win over any unimportant rule in an explicitly created cascade layer,
    no matter how high the latter’s specificity gets.'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting by Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, if two rules have exactly the same explicit weight, origin, element
    attachment, cascade layer, and specificity, then the one that appears later in
    the stylesheet wins out, similar to the way cascade layers are sorted in order
    so that later layers win over earlier layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to an earlier example, where we find the following two rules in
    the document’s stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the value of `color` for all `<h1>` elements in the document will
    be `blue`, not `red`. This is because the two rules are tied with each other in
    terms of explicit weight and origin, are in the same cascade layer, and the selectors
    have equal specificity, so the last one declared is the winner. It doesn’t matter
    how close together the elements are in the document tree; even though `<body>`
    and `<h1>` are closer together than `<html>` and `<h1>`, the later one wins. The
    only thing that matters (when the origin, cascade layer, layer, and specificity
    are the same) is the order in which the rules appear in the CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what happens if rules from completely separate stylesheets conflict? For
    example, suppose the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'What if `h1 {color: red;}` appears in *basic.css*? In this case, since there
    are no cascade layers in play, the entire contents of *basic.css* are treated
    as if they were pasted into the stylesheet at the point where the `@import` occurs.
    Thus, any rule contained in the document’s stylesheet occurs later than those
    from the `@import`. If they tie in terms of explicit weight and specificity, the
    document’s stylesheet contains the winner. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the second rule wins out over the imported rule because it is
    the last one specified, and both are in the implicit cascade layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Order sorting is the reason behind the often-recommended ordering of link styles.
    The recommendation is that you write your link styles in the order `link`, `visited`,
    `focus`, `hover`, `active`, or LVFHA, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to the information in this chapter, you now know that the specificity
    of all of these selectors is the same: `0,1,1`. Because they all have the same
    explicit weight, origin, and specificity, the last one that matches an element
    will win out. An unvisited link that is being clicked or otherwise activated,
    such as via the keyboard, is matched by four of the rules—`:link`, `:focus`, `:hover`,
    and `:active`—so the last one of those four will win out. Given the LVFHA ordering,
    `:active` will win, which is likely what the author intended.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume for a moment that you decide to ignore the common ordering and alphabetize
    your link styles instead. This would yield the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Given this ordering, no link would ever show `:hover`, `:focus`, or `:active`
    styles because the `:link` and `:visited` rules come after the other three. Every
    link must be either visited or unvisited, so those styles will always override
    the others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a variation on the LVFHA order that an author might want to
    use. In this ordering, only unvisited links will get a hover style; visited links
    will not. Both visited and unvisited links will get an active style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Such conflicts arise only when all the states attempt to set the same property.
    If each state’s styles address a different property, the order does not matter.
    In the following case, the link styles could be given in any order and would still
    function as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You may also have realized that the order of the `:link` and `:visited` styles
    doesn’t matter. You could order the styles LVFHA or VLFHA with no ill effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to chain pseudo-classes together eliminates all these worries.
    The following could be listed in any order without any overrides, as the specificity
    of the latter two is greater than that of the first two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Because each rule applies to a unique set of link states, they do not conflict.
    Therefore, changing their order will not change the styling of the document. The
    last two rules do have the same specificity, but that doesn’t matter. A hovered
    unvisited link will not be matched by the rule regarding hovered visited links,
    and vice versa. If we were to add active-state styles, order would start to matter
    again. Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If the active styles were moved before the hover styles, they would be ignored.
    Again, this would happen because of specificity conflicts. The conflicts could
    be avoided by adding more pseudo-classes to the chains, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This does have the effect of raising the specificity of the selectors—both
    have a specificity value of `0,3,1`—but they don’t conflict because the actual
    selection states are mutually exclusive. A link can’t be both a visited hovered
    active link *and* an unvisited hovered active link: only one of the two rules
    will match.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Non-CSS Presentational Hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A document could contain presentational hints that are not CSS—for example,
    the deprecated `<font>` element, or the still very much used `height`, `width`,
    and `hidden` attributes. Such presentational hints will be overridden by any author
    or reader styles, but not by the user agent’s styles. In modern browsers, presentational
    hints from outside CSS are treated as if they belong to the user agent’s stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Perhaps the most fundamental aspect of Cascading Style Sheets is the cascade
    itself—the process used to sort out conflicting declarations and determine the
    final document presentation. Integral to this process is the specificity of selectors
    and their associated declarations, and the mechanism of inheritance.
  prefs: []
  type: TYPE_NORMAL
