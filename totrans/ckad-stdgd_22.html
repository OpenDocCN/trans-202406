<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 22. Ingresses" class="praise"><div class="dedication" id="ingresses">
<h1 class="calibre14"><span class="keep-together">Chapter 22. </span>Ingresses</h1>


<p class="author1"><a data-type="xref" href="ch21.xhtml#services" class="calibre10">Chapter 21</a> delved into the purpose and creation of the Service primitive. Once there’s a need to expose the application to external consumers, selecting an appropriate Service type becomes crucial. The most practical choice often involves creating a Service of type LoadBalancer. Such a Service offers load balancing capabilities by assigning an external IP address accessible to consumers outside the Kubernetes cluster.</p>

<p class="author1">However, opting for a LoadBalancer Service for each externally reachable application has drawbacks. In a cloud provider environment, each Service triggers the provisioning of an external load balancer, resulting in increased costs. Additionally, managing a collection of LoadBalancer Service objects can lead to administrative challenges, as a new object must be established for each externally accessible microservice.</p>

<p class="author1">To mitigate these issues, the Ingress primitive comes into play, offering a singular, load-balanced entry point to an application stack. An Ingress possesses the ability to route external HTTP(S) requests to one or more Services within the cluster based on an optional, DNS-resolvable host name and URL context path. This chapter will guide you through the creation and access of an Ingress.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id491">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objective:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Use Ingress rules to expose applications</p>
</li>
</ul>
</div></aside>
<div data-type="warning" epub:type="warning" class="calibre28"><h1 class="calibre68">Accessing an Ingress in minikube</h1>
<p class="author1">Accessing an Ingress in minikube requires special handling. Refer to the Kubernetes tutorial <a href="https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/" class="calibre10">“Set up Ingress on Minikube with the NGINX Ingress Controller”</a> for detailed instructions.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Working with Ingresses" class="praise"><div class="dedication" id="id422">
<h1 class="calibre17">Working with Ingresses</h1>

<p class="author1">The Ingress exposes HTTP (and optionally HTTPS) routes to clients outside of the cluster through an externally-reachable URL. The routing rules configured with the Ingress determine <em class="calibre3">how</em> the traffic should be routed. Cloud provider Kubernetes environments will often deploy an external load balancer. The Ingress receives a public IP address from the load balancer. You can configure rules for routing traffic to multiple Services based on specific URL context paths, as shown in <a data-type="xref" href="#ingress_traffic_routing" class="calibre10">Figure 22-1</a>.</p>

<figure class="calibre35"><div id="ingress_traffic_routing" class="figure">
<img src="Images/ckd2_2201.png" alt="ckd2 2201" class="calibre112"/>
<h6 class="calibre32"><span class="keep-together">Figure 22-1. </span>Managing external access to the Services via HTTP(S)</h6>
</div></figure>

<p class="author1">The scenario depicted in <a data-type="xref" href="#ingress_traffic_routing" class="calibre10">Figure 22-1</a> instantiates an Ingress as the sole entry point for HTTP(S) calls to the domain name “next.example.com.” Based on the provided URL context, the Ingress directs the traffic to either of the fictional Services: one designed for a business application and the other for fetching metrics related to the application.</p>

<p class="author1">Specifically, the URL context path <code class="calibre15">/app</code> is routed to the App Service responsible for managing the business application. Conversely, sending a request to the URL context <code class="calibre15">/metrics</code> results in the call being forwarded to the Metrics Service, which is capable of returning relevant metrics.</p>








<section data-type="sect2" data-pdf-bookmark="Installing an Ingress Controller" class="praise"><div class="dedication" id="id423">
<h2 class="calibre33">Installing an Ingress Controller</h2>

<p class="author1">For Ingress to function, an Ingress controller is essential. This controller assesses the set of rules outlined by an Ingress, dictating the routing of traffic. The choice of Ingress controller often depends on the specific use cases, requirements, and preferences of the Kubernetes cluster administrator. Noteworthy examples of production-grade Ingress controllers include the <a href="https://www.nginx.com/products/nginx-ingress-controller/" class="calibre10">F5 NGINX Ingress Controller</a> or the <a href="https://azure.github.io/application-gateway-kubernetes-ingress/" class="calibre10">AKS Application Gateway Ingress Controller</a>. Additional options can be explored in the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" class="calibre10">Kubernetes documentation</a>.</p>

<p class="author1">You should find at least one Pod that runs the Ingress controller after installing it. This output renders the Pod created by the NGINX Ingress controller residing in the namespace <code class="calibre15">ingress-nginx</code>:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get pods -n ingress-nginx</strong>
NAME                                        READY   STATUS      RESTARTS   AGE
ingress-nginx-admission-create-qqhrp        0/1     Completed   0          60s
ingress-nginx-admission-patch-56z26         0/1     Completed   1          60s
ingress-nginx-controller-7c6974c4d8-2gg8c   1/1     Running     0          60s</pre>

<p class="author1">Once the Ingress controller Pod transitions into the “Running” status, you can assume that the rules defined by Ingress objects will be evaluated.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Deploying Multiple Ingress Controllers" class="praise"><div class="dedication" id="id424">
<h2 class="calibre33">Deploying Multiple Ingress Controllers</h2>

<p class="author1">Certainly, deploying multiple Ingress controllers within a single cluster is a feasible option, especially if a cloud provider has preconfigured an Ingress controller in the Kubernetes cluster. The Ingress API introduces the attribute <code class="calibre15">spec.ingressClassName</code> to facilitate the selection of a specific controller implementation by name. To identify all installed Ingress classes, you can use the following command:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get ingressclasses</strong>
NAME    CONTROLLER             PARAMETERS   AGE
nginx   k8s.io/ingress-nginx   &lt;none&gt;       14m</pre>

<p class="author1">Kubernetes determines the default Ingress class by scanning for the annotation <code class="calibre15">ingressclass.kubernetes.io/is-default-class: "true"</code> within all Ingress class objects. In scenarios where Ingress objects do not explicitly specify an Ingress class using the attribute <code class="calibre15">spec.ingressClassName</code>, they automatically default to the Ingress class marked as the default through this annotation. This mechanism provides flexibility in managing Ingress classes and allows for a default behavior when no specific class is specified in individual Ingress objects.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Configuring Ingress Rules" class="praise"><div class="dedication" id="id425">
<h2 class="calibre33">Configuring Ingress Rules</h2>

<p class="author1">When creating an Ingress, you have the flexibility to define one or multiple rules. Each rule encompasses the specification of an optional host, a set of URL context paths, and the backend responsible for routing the incoming traffic. This structure allows for fine-grained control over how external HTTP(S) requests are directed within the Kubernetes cluster, catering to different services based on specified conditions. <a data-type="xref" href="#ingress_rules" class="calibre10">Table 22-1</a> describes the three rules.</p>
<table id="ingress_rules" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 22-1. </span>Ingress rules</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Type</th>
<th class="calibre63">Example</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1">An optional host</p></td>
<td class="calibre65"><p class="author1">
<span class="keep-together"><code class="calibre60">next.example.com</code></span></p></td>
<td class="calibre65"><p class="author1">If provided, the rules apply to that host. If no host is defined, all inbound HTTP(S) traffic is handled (e.g., if made through the IP address of the Ingress).</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1">A list of paths</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">/app</code></p></td>
<td class="calibre65"><p class="author1">Incoming traffic must match the host and path to correctly forward the traffic to a Service.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1">The backend</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">app-service:8080</code></p></td>
<td class="calibre65"><p class="author1">A combination of a Service name and port.</p></td>
</tr>
</tbody>
</table>

<p class="author1">An Ingress controller can optionally define a default backend that is used as a fallback route should none of the configured Ingress rules match. You can learn more about it in the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#default-backend" class="calibre10">documentation of the Ingress primitive</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating Ingresses" class="praise"><div class="dedication" id="id426">
<h2 class="calibre33">Creating Ingresses</h2>

<p class="author1">You can create an Ingress with the imperative <code class="calibre15">create ingress</code> command. The main command-line option you need to provide is <code class="calibre15">--rule</code>, which defines the rules in a comma-separated fashion. The notation for each key-value pair is <code class="calibre15">&lt;host&gt;/&lt;path&gt;=&lt;service&gt;:&lt;port&gt;</code>. Let’s create an Ingress object with two rules:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create ingress next-app</strong> \
  <strong class="calibre38">--rule="next.example.com/app=app-service:8080"</strong> \
  <strong class="calibre38">--rule="next.example.com/metrics=metrics-service:9090"</strong>
ingress.networking.k8s.io/next-app created</pre>

<p class="author1">If you look at the output of the <code class="calibre15">create ingress --help</code> command, more fine-grained rules can be specified.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Support for TLS termination</h1>
<p class="author1">Port 80 for HTTP traffic is implied, as we didn’t specify a reference to a TLS Secret object. If you have specified <code class="calibre15">tls=mysecret</code> in the rule definition, then the port 443 would be listed here as well. For more information on enabling HTTPS traffic, see the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#tls" class="calibre10">Kubernetes documentation</a>. The exam does not cover configuring TLS termination for an Ingress.</p>
</div>

<p class="author1">Using a YAML manifest to define Ingress is often more intuitive and preferred by many. It provides a clearer and more structured way to express the desired configuration. The Ingress defined as a YAML manifest is shown in <a data-type="xref" href="#ingress_manifest" class="calibre10">Example 22-1</a>.</p>
<div id="ingress_manifest" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 22-1. </span>An Ingress defined by a YAML manifest</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">networking.k8s.io/v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Ingress</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">next-app</code><code class="w">
</code><code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">nginx.ingress.kubernetes.io/rewrite-target</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/$1</code><code class="w">   </code><a class="calibre10" id="co_ingresses_CO1-1" href="#callout_ingresses_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">host</code><code class="p">:</code><code class="w"> </code><code class="calibre15">next.example.com</code><code class="w">                            </code><a class="calibre10" id="co_ingresses_CO1-2" href="#callout_ingresses_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">http</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">paths</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">backend</code><code class="p">:</code><code class="w">
</code><code class="w">          </code><code class="nt">service</code><code class="p">:</code><code class="w">
</code><code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">app-service</code><code class="w">
</code><code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w">
</code><code class="w">              </code><code class="nt">number</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w">
</code><code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/app</code><code class="w">
</code><code class="w">        </code><code class="nt">pathType</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Exact</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">host</code><code class="p">:</code><code class="w"> </code><code class="calibre15">next.example.com</code><code class="w">                            </code><a class="calibre10" id="co_ingresses_CO1-3" href="#callout_ingresses_CO1-3"><img src="Images/3.png" alt="3" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">http</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">paths</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">backend</code><code class="p">:</code><code class="w">
</code><code class="w">          </code><code class="nt">service</code><code class="p">:</code><code class="w">
</code><code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">metrics-service</code><code class="w">
</code><code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w">
</code><code class="w">              </code><code class="nt">number</code><code class="p">:</code><code class="w"> </code><code class="calibre15">9090</code><code class="w">
</code><code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/metrics</code><code class="w">
</code><code class="w">        </code><code class="nt">pathType</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Exact</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_ingresses_CO1-1" href="#co_ingresses_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Assigns a NGNIX ingress-specific annotation for rewriting the URL.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_ingresses_CO1-2" href="#co_ingresses_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Defines the rule that maps the <code class="calibre15">app-service</code> backend to the URL <em class="calibre3">next.example.com/app</em>.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_ingresses_CO1-3" href="#co_ingresses_CO1-3"><img src="Images/3.png" alt="3" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Defines the rule that maps the <code class="calibre15">metrics-service</code> backend to the URL <em class="calibre3">next.example.com/metrics</em>.</p></dd>
</dl>

<p class="author1">The Ingress YAML manifest contains one major difference from the live object representation created by the imperative command: the assignment of an Ingress controller annotation. Some Ingress controller implementations provide annotations to customize their behavior. You can find the full list of annotations that come with the NGINX Ingress controller in the <a href="https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md" class="calibre10">corresponding documentation</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Defining Path Types" class="praise"><div class="dedication" id="id427">
<h2 class="calibre33">Defining Path Types</h2>

<p class="author1">The previous YAML manifest demonstrates one of the options for specifying a path type via the attribute <code class="calibre15">spec.rules[].http.paths[].pathType</code>. The path type defines how an incoming request is evaluated against the declared path. <a data-type="xref" href="#ingress_path_types" class="calibre10">Table 22-2</a> indicates the evaluation for incoming requests and their paths. See the <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types" class="calibre10">Kubernetes documentation</a> for a more comprehensive list.</p>
<table id="ingress_path_types" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 22-2. </span>Ingress path types</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Path Type</th>
<th class="calibre63">Rule</th>
<th class="calibre63">Incoming Request</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">Exact</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">/app</code></p></td>
<td class="calibre65"><p class="author1">Matches <code class="calibre60">/app</code> but does not match 
<span class="keep-together"><code class="calibre60">/app/test</code></span> or 
<span class="keep-together"><code class="calibre60">/app/</code></span></p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">Prefix</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">/app</code></p></td>
<td class="calibre65"><p class="author1">Matches <code class="calibre60">/app</code> and <code class="calibre60">/app/</code> but does not match 
<span class="keep-together"><code class="calibre60">/app/test</code></span></p></td>
</tr>
</tbody>
</table>

<p class="author1">The key distinction between the <code class="calibre15">Exact</code> and <code class="calibre15">Prefix</code> path types lies in their treatment of trailing slashes. The <code class="calibre15">Prefix</code> path type focuses solely on the provided prefix of a URL context path, allowing it to accommodate requests with URLs that include a trailing slash. In contrast, the <code class="calibre15">Exact</code> path type is more stringent, requiring an exact match of the specified URL context path without considering a trailing slash.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Listing Ingresses" class="praise"><div class="dedication" id="id428">
<h2 class="calibre33">Listing Ingresses</h2>

<p class="author1">Listing Ingresses can be achieved with the <code class="calibre15">get ingress</code> command. You will see some of the information you specified when creating the Ingress (e.g., the hosts):</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get ingress</strong>
NAME       CLASS   HOSTS              ADDRESS        PORTS   AGE
next-app   nginx   next.example.com   192.168.66.4   80      5m38s</pre>

<p class="author1">The Ingress automatically selected the default Ingress class <code class="calibre15">nginx</code> configured by the Ingress controller. You can find the information under the <code class="calibre15">CLASS</code> column. The value listed under the <code class="calibre15">ADDRESS</code> columns is the IP address provided by the external load balancer.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Rendering Ingress Details" class="praise"><div class="dedication" id="id429">
<h2 class="calibre33">Rendering Ingress Details</h2>

<p class="author1">The <code class="calibre15">describe ingress</code> command is a valuable tool for obtaining detailed information about an Ingress resource. It presents the rules in a clear table format, which aids in understanding the routing configurations. Additionally, when troubleshooting, it’s essential to pay attention to any additional messages or events.</p>

<p class="author1">In the provided output, it’s evident that there might be an issue with the Services named app-service and metrics-service that are mapped in the Ingress rules. This discrepancy between the specified services and their existence can lead to routing errors:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl describe ingress next-app</strong>
Name:             next-app
Labels:           &lt;none&gt;
Namespace:        default
Address:          192.168.66.4
Ingress Class:    nginx
Default backend:  &lt;default&gt;
Rules:
  Host              Path  Backends
  ----              ----  --------
  next.example.com
                    /app       app-service:8080 (&lt;error: endpoints \
                    "app-service" not found&gt;)
                    /metrics   metrics-service:9090 (&lt;error: endpoints \
                    "metrics-service" not found&gt;)
Annotations:        &lt;none&gt;
Events:
  Type    Reason  Age                   From                      ...
  ----    ------  ----                  ----                      ...
  Normal  Sync    6m45s (x2 over 7m3s)  nginx-ingress-controller  ...</pre>

<p class="author1">Furthermore, observing the event log that shows syncing activity by the Ingress controller is crucial. Any warnings or errors in this log can provide insights into potential issues during the synchronization process.</p>

<p class="author1">To address the problem, ensure that the specified Services in the Ingress rules actually exist and are accessible within the Kubernetes cluster. Additionally, review the event log for any relevant messages that might indicate the cause of the discrepancy.</p>

<p class="author1">Let’s resolve the issue of not being able to route to the backends configured in the Ingress object. The following commands create the Pods and Services:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl run app --image=k8s.gcr.io/echoserver:1.10 --port=8080 \
  -l app=app-service</strong>
pod/app created
<strong class="calibre38">$ kubectl run metrics --image=k8s.gcr.io/echoserver:1.10 --port=8080 \
  -l app=metrics-service</strong>
pod/metrics created
<strong class="calibre38">$ kubectl create service clusterip app-service --tcp=8080:8080</strong>
service/app-service created
<strong class="calibre38">$ kubectl create service clusterip metrics-service --tcp=9090:8080</strong>
service/metrics-service created</pre>

<p class="author1">Inspecting the Ingress object doesn’t show any errors for the configured rules. If you’re now able to see a list of resolvable backends along with the corresponding Pod virtual IP addresses and ports, the Ingress object is correctly configured, and the backends are recognized and accessible:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl describe ingress next-app</strong>
Name:             next-app
Labels:           &lt;none&gt;
Namespace:        default
Address:          192.168.66.4
Ingress Class:    nginx
Default backend:  &lt;default&gt;
Rules:
  Host              Path  Backends
  ----              ----  --------
  next.example.com
                    /app       app-service:8080 (10.244.0.6:8080)
                    /metrics   metrics-service:9090 (10.244.0.7:8080)
Annotations:        &lt;none&gt;
Events:
  Type    Reason  Age                From                      Message
  ----    ------  ----               ----                      -------
  Normal  Sync    13m (x2 over 13m)  nginx-ingress-controller  Scheduled for sync</pre>

<p class="author1">It’s worth coming back to the Ingress details if you experience any issues with routing traffic through an Ingress endpoint.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Accessing an Ingress" class="praise"><div class="dedication" id="id430">
<h2 class="calibre33">Accessing an Ingress</h2>

<p class="author1">To enable the routing of incoming HTTP(S) traffic through the Ingress and subsequently to the configured Service, it’s crucial to set up a DNS entry mapping to the external address. This typically involves configuring either an A record or a CNAME record. The <a href="https://github.com/kubernetes-sigs/external-dns" class="calibre10">ExternalDNS project</a> is a valuable tool that can assist in managing these DNS records automatically.</p>

<p class="author1">For local testing on a Kubernetes cluster on your machine, follow these steps:</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Find the IP address of the load balancer used by the Ingress.</p>
</li>
<li class="calibre56">
<p class="author1">Add the IP address to hostname mapping to your <em class="calibre3">/etc/hosts</em> file.</p>
</li>

</ol>

<p class="author1">By adding the IP address to your local <em class="calibre3">/etc/hosts</em> file, you simulate the DNS resolution locally, allowing you to test the behavior of the Ingress without relying on actual DNS records:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get ingress next-app \
  --output=jsonpath="{.status.loadBalancer.ingress[0]['ip']}"</strong>
192.168.66.4
<strong class="calibre38">$ sudo vim /etc/hosts</strong>
...
192.168.66.4   next-app
</pre>

<p class="author1">You can now send HTTP requests to the backend. This call matches the <code class="calibre15">Exact</code> path rule and therefore returns a HTTP 200 response code from the application:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ wget next.example.com/app --timeout=5 --tries=1</strong>
--2021-11-30 19:34:57--  http://next.example.com/app
Resolving next.example.com (next.example.com)... 192.168.66.4
Connecting to next.example.com (next.example.com)|192.168.66.4|:80... \
connected.
HTTP request sent, awaiting response... 200 OK</pre>

<p class="author1">This next call uses a URL with a trailing slash. The Ingress path rule doesn’t support this case, and therefore the call doesn’t go through. You will receive a HTTP 404 response code. For the second call to work, you’d have to change the path rule to 
<span class="keep-together"><code class="calibre15">Prefix</code>:</span></p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ wget next.example.com/app/ --timeout=5 --tries=1</strong>
--2021-11-30 15:36:26--  http://next.example.com/app/
Resolving next.example.com (next.example.com)... 192.168.66.4
Connecting to next.example.com (next.example.com)|192.168.66.4|:80... \
connected.
HTTP request sent, awaiting response... 404 Not Found
2021-11-30 15:36:26 ERROR 404: Not Found.</pre>

<p class="author1">You can observe the same behavior for the Metrics Service configured with the URL context path <code class="calibre15">metrics</code>. Feel free to try that out as well.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id431">
<h1 class="calibre17">Summary</h1>

<p class="author1">The resource type Ingress defines rules for routing cluster-external HTTP(S) traffic to one or many Services. Each rule defines a URL context path to target a Service. For an Ingress to work, you first need to install an Ingress controller. An Ingress controller periodically evaluates those rules and ensures that they apply to the cluster. To expose the Ingress, a cloud provider usually stands up an external load balancer that lends an external IP address to the Ingress.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id432">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Know the difference between a Service and an Ingress</dt>
<dd class="calibre20">
<p class="calibre21">An Ingress is not to be confused with a Service. The Ingress is meant for routing cluster-external HTTP(S) traffic to one or many Services based on an optional hostname and mandatory path. A Service routes traffic to a set of Pods.</p>
</dd>
<dt class="calibre19">Understand the role of an Ingress controller</dt>
<dd class="calibre20">
<p class="calibre21">An Ingress controller needs to be installed before an Ingress can function properly. Without installing an Ingress controller, Ingress rules will have no effect. You can choose from a range of Ingress controller implementations, all documented on the Kubernetes documentation page. Assume that an Ingress controller will be preinstalled for you in the exam environment.</p>
</dd>
<dt class="calibre19">Practice the definition of Ingress rules</dt>
<dd class="calibre20">
<p class="calibre21">You can define one or many rules in an Ingress. Every rule consists of an optional host, the URL context path, and the Service DNS name and port. Try defining more than a single rule and how to access the endpoint. You will not have to understand the process for configuring TLS termination for an Ingress—this aspect is covered by the CKS exam.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id433">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_018.xhtml#appendix_a_ingresses" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Create a new Deployment named <code class="calibre15">web</code> that controls a single replica running the image <code class="calibre15">bmuschko/nodejs-hello-world:1.0.0</code> on port 3000. Expose the Deployment with a Service named <code class="calibre15">web</code> of type <code class="calibre15">ClusterIP</code>. The Service routes traffic to the Pods controlled by the Deployment <code class="calibre15">web</code>. Make a request to the endpoint of the application on the context path /. You should see the message “Hello World.”</p>

<p class="author1">Create an Ingress that exposes the path / for the host hello-world.exposed. The traffic should be routed to the Service created earlier. List the Ingress object.</p>

<p class="author1">Add an entry in <em class="calibre3">/etc/hosts</em> that maps the load balancer IP address to the host hello-world.exposed. Make a request to <a href="http://hello-world.exposed" class="calibre10"><em class="calibre3">http://hello-world.exposed</em></a>. You should see the message “Hello World.”</p>
</li>
<li class="calibre56">
<p class="author1">Any application has been exposed by an Ingress. Some of your end users report an issue with connecting to the application from outside of the cluster. Inspect the existing setup and fix the problem for your end users.</p>

<p class="author1">Navigate to the directory <em class="calibre3">app-a/ch22/troubleshooting</em> of the checked-out GitHub repository <a href="https://github.com/bmuschko/ckad-study-guide" class="calibre10"><em class="calibre3">bmuschko/ckad-study-guide</em></a>. Create the objects from the YAML manifest <em class="calibre3">setup.yaml</em>. Inspect the objects in the namespace <code class="calibre15">s96</code>. Create an entry in <em class="calibre3">/etc/hosts</em> for the hostname faulty.ingress.com.</p>

<p class="author1">Perform a HTTP call to faulty.ingress.com/ using <code class="calibre15">wget</code> or <code class="calibre15">curl</code>. Inspect the connection error.</p>

<p class="author1">Change the configuration to ensure that end users can connect to the Ingress. Verify proper connectivity by performing another HTTP call.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>