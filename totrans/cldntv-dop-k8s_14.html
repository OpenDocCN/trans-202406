<html><head></head><body><section data-pdf-bookmark="Chapter 12. Deploying Kubernetes Applications" data-type="chapter" epub:type="chapter"><div class="chapter" id="deploying">&#13;
<h1><span class="label">Chapter 12. </span>Deploying Kubernetes Applications</h1>&#13;
&#13;
<blockquote class="epigraph">&#13;
<p>I lay on my back, surprised at how calm and focused I felt, strapped to four and a half million pounds of explosives.</p>&#13;
<p data-type="attribution">Ron Garan, astronaut</p>&#13;
</blockquote>&#13;
&#13;
<p><a data-primary="Kubernetes" data-secondary="application deployment" data-type="indexterm" id="ix_12-deploying-adoc0"/>In this chapter, we’ll deal with the question of how to turn your manifest files into running applications. We’ll learn how to build Helm charts for your applications, and look at some alternative tools for manifest management: Tanka, kustomize, Kapitan, and kompose.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building Manifests with Helm" data-type="sect1"><div class="sect1" id="idm45979378219488">&#13;
<h1>Building Manifests with Helm</h1>&#13;
&#13;
<p><a data-primary="application deployment" data-secondary="building manifests with Helm" data-type="indexterm" id="ix_12-deploying-adoc1"/>We saw in <a data-type="xref" href="ch02.html#firststeps">Chapter 2</a> how to deploy and manage applications with Kubernetes resources created from YAML manifests. There’s nothing stopping you from managing all your Kubernetes applications using just the raw YAML files in this way, but it’s not ideal. Not only is it difficult to maintain these files, but there is also a problem of distribution.</p>&#13;
&#13;
<p>Suppose you want to make your application available to other people to run in their own clusters. You can distribute the manifest files to them, but they will inevitably need to customize some of the settings for their own environment.</p>&#13;
&#13;
<p>To do this, they will have to make their own copy of the Kubernetes configs, find where the various settings are defined (perhaps duplicated in several places), and edit them.</p>&#13;
&#13;
<p>Over time, they will need to maintain their own copies of the files, and when you make updates available, they will have to pull and reconcile them manually with their local changes.</p>&#13;
&#13;
<p>This eventually starts to become painful. What we want is the ability to separate the raw manifest files from the particular settings and variables that you or any user of the application might need to adjust. Ideally we could then make these available in a standard format, which anyone can download and install to a Kubernetes cluster.</p>&#13;
&#13;
<p>Once we have this, then each application can expose not only configuration values, but also any dependencies it has on other apps or services. An intelligent package management tool could then install and run an application, along with all its dependencies, in a single command.</p>&#13;
&#13;
<p>In <a data-type="xref" href="ch04.html#helm-intro">“Helm: A Kubernetes Package Manager”</a>, we introduced the Helm tool and showed you how to use it to install public charts. Let’s look at Helm charts in a little more detail now, and see how to create our own.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What’s Inside a Helm Chart?" data-type="sect2"><div class="sect2" id="helmcharts">&#13;
<h2>What’s Inside a Helm Chart?</h2>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="contents" data-type="indexterm" id="idm45979378209808"/>In the demo repo, open up the <em>hello-helm3/k8s</em> directory to see what’s inside our Helm chart.</p>&#13;
&#13;
<p>Every Helm chart has a standard structure. First, the chart is contained in a directory with the same name as the chart (<code>demo</code> in this case):</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="go">demo</code>&#13;
<code class="go">├── Chart.yaml</code>&#13;
<code class="go">├── production-values.yaml</code>&#13;
<code class="go">├── staging-values.yaml</code>&#13;
<code class="go">├── templates</code>&#13;
<code class="go">│   ├── deployment.yaml</code>&#13;
<code class="go">│   └── service.yaml</code>&#13;
<code class="go">└── values.yaml</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Chart.yaml file" data-type="sect3"><div class="sect3" id="idm45979378186080">&#13;
<h3>The Chart.yaml file</h3>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="Chart.yaml" data-type="indexterm" id="idm45979378203168"/>Next, it contains a file named <em>Chart.yaml</em>, which specifies the chart name and version:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="nt">sources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">https://github.com/cloudnativedevops/demo</code><code class="w"/>&#13;
<code class="nt">version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1.0.1</code><code class="w"/></pre>&#13;
&#13;
<p>There are lots of optional fields you can supply in <em>Chart.yaml</em>, including a link to the project source code, as here, but the only required information is the name and version.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The values.yaml file" data-type="sect3"><div class="sect3" id="idm45979378181280">&#13;
<h3>The values.yaml file</h3>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="values.yaml" data-type="indexterm" id="idm45979378179968"/>There is also a file named <em>values.yaml</em>, which contains user-modifiable settings that the chart author has exposed:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">environment</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">development</code><code class="w"/>&#13;
<code class="nt">container</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cloudnatived/demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">tag</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hello</code><code class="w"/>&#13;
<code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"/></pre>&#13;
&#13;
<p>This looks a bit like a Kubernetes YAML manifest, but there’s an important difference. The <em>values.yaml</em> file is completely free-form YAML, with no predefined schema: it’s up to you to choose what variables are defined, their names, and their values.</p>&#13;
&#13;
<p>There don’t have to be any variables at all in your Helm chart, but if there are, you can put them in <em>values.yaml</em> and then refer to them elsewhere in the chart.</p>&#13;
&#13;
<p>Ignore the <em>production-values.yaml</em> and <em>staging-values.yaml</em> files for the moment; we’ll explain what they’re for shortly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Helm Templates" data-type="sect2"><div class="sect2" id="idm45979378089136">&#13;
<h2>Helm Templates</h2>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="templates" data-type="indexterm" id="idm45979378087696"/>So where are these variables referenced? If you look in the <em>templates</em> subdirectory, you’ll see a couple of familiar-looking files:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">ls k8s/demo/templates</code></strong><code class="go">&#13;
</code><code class="go">deployment.yaml service.yaml</code></pre>&#13;
&#13;
<p>These are just the same as the Deployment and Service manifest files from the previous example, except that now they are <em>templates</em>: instead of referring to things like the container name directly, they contain a placeholder that Helm will replace with the actual value from <em>values.yaml</em>.</p>&#13;
&#13;
<p>Here’s what the template Deployment looks like:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.container.name</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="l-Scalar-Plain">-{{ .Values.environment }}</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.replicas</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.container.name</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.container.name</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">environment</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.environment</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.container.name</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.container.image</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="l-Scalar-Plain">:{{ .Values.container.tag }}</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.container.port</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ENVIRONMENT</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.environment</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><a data-primary="Go templates" data-type="indexterm" id="idm45979377824768"/><a data-primary="Helm chart" data-secondary="Go template syntax" data-type="indexterm" id="idm45979377824128"/>The curly braces indicate a place where Helm should substitute the value of a variable, but they’re actually part of <em>Go template syntax</em>.</p>&#13;
&#13;
<p>(Yes, Go is everywhere. Kubernetes and Helm themselves are written in Go, so it’s no surprise that Helm charts use Go templates.)</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Interpolating Variables" data-type="sect2"><div class="sect2" id="idm45979377862848">&#13;
<h2>Interpolating Variables</h2>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="variables" data-type="indexterm" id="idm45979377861376"/>There are several variables referenced in this template:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nn">...</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><strong><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="w"> </code><code class="nv">.Values.container.name</code><code class="w"> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code class="l-Scalar-Plain">-{{</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">.Values.environment</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">}}</code></strong></pre>&#13;
&#13;
<p>This whole section of text, including the curly braces, will be <em>interpolated</em> (that is, replaced) with the values of <code>container.name</code> and <code>environment</code>, taken from <span class="keep-together"><em>values.yaml</em></span>. The generated result will look like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nn">...</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><strong><code class="l-Scalar-Plain">demo-development</code></strong></pre>&#13;
&#13;
<p>This is powerful, because values like <code>container.name</code> are referenced more than once in the template. Naturally, it’s referenced in the Service template, too:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><strong><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="w"> </code><code class="nv">.Values.container.name</code><code class="w"> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code></strong><code class="l-Scalar-Plain">-service-{{</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">.Values.environment</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">}}</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><strong><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="w"> </code><code class="nv">.Values.container.name</code><code class="w"> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code></strong><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="w"> </code><code class="nv">.Values.container.port</code><code class="w"> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="w"> </code><code class="nv">.Values.container.port</code><code class="w"> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><strong><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="w"> </code><code class="nv">.Values.container.name</code><code class="w"> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code></strong><code class="w">&#13;
</code><code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterIP</code></pre>&#13;
&#13;
<p>You can see how many times <code>.Values.container.name</code> is referenced, for example. Even in a simple chart like this, you need to repeat the same bits of information many times. Using Helm variables eliminates this duplication. All you need to do to change the container name, for example, is to edit <em>values.yaml</em> and reinstall the chart, and the change will be propagated throughout all the templates.</p>&#13;
&#13;
<p>The Go template format is very powerful, and you can use it to do much more than simple variable substitutions: it supports loops, expressions, conditionals, and even calling functions. Helm charts can use these features to generate fairly complex configuration from input values, unlike the simple substitutions in our example.</p>&#13;
&#13;
<p>You can read more about how to write Helm templates in the Helm <a href="https://oreil.ly/4u06b">documentation</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Quoting Values in Templates" data-type="sect2"><div class="sect2" id="idm45979377637488">&#13;
<h2>Quoting Values in Templates</h2>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="quoting values" data-type="indexterm" id="idm45979377657232"/>You can use the <code>quote</code> function in Helm to automatically quote values in your templates:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="nv">.Values.MyName | quote</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/></pre>&#13;
&#13;
<p>Only string values should be quoted—don’t use the <code>quote</code> function with numeric values like port numbers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Specifying Dependencies" data-type="sect2"><div class="sect2" id="idm45979377600336">&#13;
<h2>Specifying Dependencies</h2>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="specifying dependencies" data-type="indexterm" id="idm45979377651824"/>What if your chart relies on other charts? For example, if your app uses Redis, the Helm chart for your app might need to specify the <code>redis</code> chart as a dependency.</p>&#13;
&#13;
<p>You can do this using the <code>dependencies</code> section in the <code>Chart.yaml</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">dependencies</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">redis</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">~15.4.1</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">repository</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://charts.bitnami.com/bitnami</code><code class="w"/></pre>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="commands" data-tertiary="dependency update" data-type="indexterm" id="idm45979377579296"/>Now run the <code>helm dependency update</code> command, and Helm will download those charts, ready to install along with your own application. These dependencies can be local charts, or hosted remotely in public Helm repositories.</p>&#13;
&#13;
<p>You can also overwrite any of the default values of any charts that you pull in as dependencies (often referred to as subcharts). See the <a href="https://oreil.ly/rF4rq">Helm docs on subchart values</a> for more details.</p>&#13;
&#13;
<p>The <code>~</code> symbol in the version tells Helm that you would be willing to automatically upgrade to a newer version of the chart up to the next minor release version. For example, <code>~15.4.1</code> means that Helm will install the newest <code>15.4.x</code> version, stopping before <code>15.5.x</code>. Helm, like many other package managers, also uses a <em>.lock</em> file, so after updating you should see a <em>Chart.lock</em> file generated that tracks the exact versions used at the time.<a data-startref="ix_12-deploying-adoc1" data-type="indexterm" id="idm45979377545200"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploying Helm Charts" data-type="sect1"><div class="sect1" id="idm45979378218896">&#13;
<h1>Deploying Helm Charts</h1>&#13;
&#13;
<p><a data-primary="application deployment" data-secondary="deploying Helm charts" data-type="indexterm" id="ix_12-deploying-adoc2"/>Let’s look at what’s involved in actually using a Helm chart to deploy an application. One of the most valuable features of Helm is the ability to specify, change, update, and override configuration settings. In this section, we’ll see how that works. This example is in the directory of the <a href="https://oreil.ly/xeLdl">cloudnativedevops GitHub demo repo</a> if you wish to follow along.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Variables" data-type="sect2"><div class="sect2" id="idm45979377541056">&#13;
<h2>Setting Variables</h2>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="setting variables" data-type="indexterm" id="idm45979377539888"/>We’ve seen that the author of a Helm chart can put all the user-modifiable settings in <code>values.yaml</code>, along with the default values for those settings. So how does the <em>user</em> of a chart change or override those settings to suit their local site or environment? <a data-primary="Helm" data-secondary="commands" data-tertiary="install" data-type="indexterm" id="idm45979377537648"/>The <code>helm install</code> and <code>helm upgrade</code> commands let you specify additional values files on the command line, which will override any defaults in <em>values.yaml</em>. Let’s look at an example.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating an environment variable" data-type="sect3"><div class="sect3" id="idm45979377534864">&#13;
<h3>Creating an environment variable</h3>&#13;
&#13;
<p><a data-primary="environment variables" data-secondary="setting with Helm" data-type="indexterm" id="idm45979377533456"/>Suppose you want to deploy a version of the application in a staging environment. For the purposes of our example, it doesn’t really matter what that means in practice, but let’s say the application knows whether it’s in staging or production based on the value of an environment variable named <code>ENVIRONMENT</code>, and changes its behavior accordingly. How does that environment variable get created?</p>&#13;
&#13;
<p>Looking again at the <em>deployment.yaml</em> template, this environment variable is supplied to the container using this code:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nn">...</code><code class="w"/>&#13;
<code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ENVIRONMENT</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.environment</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/></pre>&#13;
&#13;
<p>The value of <code>environment</code> comes from <em>values.yaml</em>, as you’d expect:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">environment</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">development</code><code class="w"/>&#13;
<code class="nn">...</code><code class="w"/></pre>&#13;
&#13;
<p>So installing the chart with the default values will result in the container’s <span class="keep-together"><code>ENVIRONMENT</code></span> variable containing <code>development</code>. Suppose you want to change that to <code>staging</code>. You could edit the <em>values.yaml</em> file, as we’ve seen, but a better way is to create an additional YAML file containing a value for just that one variable:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">environment</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">staging</code><code class="w"/></pre>&#13;
&#13;
<p>You’ll find this value in the file <em>k8s/demo/staging-values.yaml</em>, which isn’t part of the Helm chart—we’ve just supplied it to save you a little typing.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Specifying Values in a Helm Release" data-type="sect2"><div class="sect2" id="idm45979377477760">&#13;
<h2>Specifying Values in a Helm Release</h2>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="commands" data-tertiary="upgrade" data-type="indexterm" id="idm45979377476512"/><a data-primary="Helm" data-secondary="flags" data-tertiary="--values" data-type="indexterm" id="idm45979377475424"/>To specify an extra values file with the <code>helm upgrade</code> command, use the <code>--values</code> flag, like this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helm upgrade --install demo-staging&#13;
</code><code class="go">--values=./k8s/demo/staging-values.yaml ./k8s/demo</code></strong></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note that in these examples we are using <code>helm upgrade --install</code> instead of <code>helm install</code>. Doing it this way means you can use the same command whether your helm release has already been installed or not. If you prefer to use just <code>helm install</code> first and <code>helm upgrade</code> on following deploys, that will also work.</p>&#13;
</div>&#13;
&#13;
<p>This will create a new release, with a new name (<code>demo-staging</code>), and the running container’s <code>ENVIRONMENT</code> variable will be set to <code>staging</code> instead of <code>development</code>. The variables listed in the extra values file we specified with <code>--values</code> are combined with those in the default values file (<em>values.yaml</em>). In this case, there’s only one variable (<code>environment</code>) and the value from <em>staging-values.yaml</em> overrides that from the default values file.</p>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="flags" data-tertiary="--set" data-type="indexterm" id="idm45979377386736"/>You can also specify values directly on the command line, using the <code>--set</code> flag. This can be useful for things like changing an image tag version or testing a quick change. Typically you should instead create a separate YAML file containing whatever value overrides are needed for a particular envrionment, like the <em>staging-values.yaml</em> file in the example, track that file in your source control repository, and apply it using the <code>--values</code> flag.</p>&#13;
&#13;
<p>While you’ll naturally want to set configuration values this way for installing your own Helm charts, you can do it with public charts too. To see the list of values a chart makes available for you to set, run <code>helm get values</code> with a chart name:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helm inspect values ./k8s/demo</code></strong></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Updating an App with Helm" data-type="sect2"><div class="sect2" id="updatinghelm">&#13;
<h2>Updating an App with Helm</h2>&#13;
&#13;
<p>You’ve learned how to install a Helm chart with the default values, and with a custom values file, but what about changing some values for an application that’s already running?</p>&#13;
&#13;
<p><a data-primary="Pod objects" data-secondary="replicas" data-type="indexterm" id="idm45979377365792"/><a data-primary="replicas" data-secondary="changing number of" data-type="indexterm" id="idm45979377364816"/>The <code>helm upgrade</code> command will do this for you. Suppose you want to change the number of replicas (the number of copies of the Pod that Kubernetes should run) for the demo application. By default it’s 1, as you can see from the <em>values.yaml</em> file:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"/></pre>&#13;
&#13;
<p>You know how to override this using a custom values file, so edit the <em>staging-values.yaml</em> file to add a suitable setting:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">environment</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">staging</code><code class="w">&#13;
</code><strong><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2</code></strong></pre>&#13;
&#13;
<p>Run the same command as before to apply your changes to the <em>existing</em> <code>demo-staging</code> Deployment, rather than creating a new one:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helm upgrade --install demo-staging&#13;
</code><code class="go">--values=./k8s/demo/staging-values.yaml ./k8s/demo</code></strong><code class="go">&#13;
</code><code class="go">Release "demo-staging" has been upgraded. Happy Helming!</code></pre>&#13;
&#13;
<p>You can run <code>helm upgrade</code> as many times as you like to update a running Deployment, and Helm will cheerfully oblige.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rolling Back to Previous Versions" data-type="sect2"><div class="sect2" id="idm45979377367360">&#13;
<h2>Rolling Back to Previous Versions</h2>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="commands" data-tertiary="rollback" data-type="indexterm" id="idm45979377279488"/>If you decide you don’t like the version you’ve just deployed, or there turns out to be a problem, it’s easy to roll back to a previous version, using the <code>helm rollback</code> command, and specifying the number of a previous release (as shown in <code>helm history</code> output):</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helm rollback demo-staging 1</code></strong><code class="go">&#13;
</code><code class="go">Rollback was a success! Happy Helming!</code></pre>&#13;
&#13;
<p>In fact, the rollback doesn’t have to be to a previous release; let’s say you roll back to revision 1, and then decide you want to roll <em>forward</em> to revision 2. If you run <code>helm rollback demo-staging 2</code>, that’s exactly what will happen.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Automatic rollback with helm" data-type="sect3"><div class="sect3" id="idm45979377254640">&#13;
<h3>Automatic rollback with helm</h3>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="flags" data-tertiary="--atomic" data-type="indexterm" id="idm45979377253600"/>You can have Helm automatically roll back an unsuccessful deployment. If you add the <code>--atomic</code> flag to the <code>helm upgrade</code> command then Helm will wait for your deployment to succeed. If it goes into a <code>FAILED</code> state, it will automatically roll back to the last successful release. You would want to make sure that you have an alert in place for this situation by checking for a failed deploy so that you can go debug what happened, otherwise you may not notice that your deploy didn’t actually succeed!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a Helm Chart Repo" data-type="sect2"><div class="sect2" id="chartrepo">&#13;
<h2>Creating a Helm Chart Repo</h2>&#13;
&#13;
<p><a data-primary="Helm chart" data-secondary="repository" data-type="indexterm" id="idm45979377248864"/>So far we’ve used Helm to install charts from a local directory. You don’t need your own chart repo to use Helm, as it’s common to store an application’s Helm chart in the application’s own repo.</p>&#13;
&#13;
<p>But if you do want to maintain your own Helm chart repo, it’s very straightforward. The charts need to be available over HTTP, and there’s a variety of ways you can do this: put them in a cloud storage bucket, host your own <a href="https://chartmuseum.com">ChartMuseum server</a>, use Artifactory, use GitHub Pages, or use an existing web server if you have one.</p>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="commands" data-tertiary="repo index" data-type="indexterm" id="idm45979377228208"/>Once all your charts are collected together under a single directory, run <code>helm repo index</code> to create the <em>index.yaml</em> file that contains the repo metadata.</p>&#13;
&#13;
<p>Your chart repo is ready to use! See the Helm <a href="https://oreil.ly/glEyY">documentation</a> for more details on managing chart repos.</p>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="commands" data-tertiary="repo add" data-type="indexterm" id="idm45979377224576"/>To install charts from your repo, you’ll first of all need to add the repo to Helm’s list:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helm repo add myrepo http://myrepo.example.com</code></strong><code class="go">&#13;
</code><strong><code class="go">helm install myrepo/myapp</code></strong></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing Helm Chart Secrets with Sops" data-type="sect2"><div class="sect2" id="helmsops">&#13;
<h2>Managing Helm Chart Secrets with Sops</h2>&#13;
&#13;
<p><a data-primary="Helm" data-secondary="managing secrets with Sops" data-type="indexterm" id="ix_12-deploying-adoc3"/><a data-primary="Secrets" data-secondary="managing with Sops" data-type="indexterm" id="ix_12-deploying-adoc4"/><a data-primary="Sops" data-secondary="with Helm charts" data-type="indexterm" id="ix_12-deploying-adoc5"/>We saw in <a data-type="xref" href="ch10.html#secrets">“Kubernetes Secrets”</a> how to store secret data in Kubernetes, and how to pass it to applications via environment variables or mounted files. If you have more than one or two secrets to manage, you may find it easier to create a single file containing all the secrets, rather than individual files each containing one secret. And if you’re using Helm to deploy your app, you can make that file a values file, and encrypt it with Sops (see <a data-type="xref" href="ch10.html#sops">“Encrypting Secrets with Sops”</a>).</p>&#13;
&#13;
<p>We’ve built an example for you to try in the demo repo, in the <em>hello-sops</em> directory:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">cd hello-sops</code></strong><code class="go">&#13;
</code><strong><code class="go">tree</code></strong><code class="go">&#13;
</code><code class="go">.&#13;
</code><code class="go">├── k8s&#13;
</code><code class="go">│   └── demo&#13;
</code><code class="go">│       ├── Chart.yaml&#13;
</code><code class="go">│       ├── production-secrets.yaml&#13;
</code><code class="go">│       ├── production-values.yaml&#13;
</code><code class="go">│       ├── staging-secrets.yaml&#13;
</code><code class="go">│       ├── staging-values.yaml&#13;
</code><code class="go">│       ├── templates&#13;
</code><code class="go">│       │   ├── deployment.yaml&#13;
</code><code class="go">│       │   └── secrets.yaml&#13;
</code><code class="go">│       └── values.yaml&#13;
</code><code class="go">└── temp.yaml&#13;
</code><code class="go">&#13;
</code><code class="go">3 directories, 9 files</code></pre>&#13;
&#13;
<p>This is a similar Helm chart layout to our earlier example (see <a data-type="xref" href="#helmcharts">“What’s Inside a Helm Chart?”</a>). Here, we’ve defined a <code>Deployment</code> and a <code>Secret</code>. But in this example, we have added a twist to make it easier to manage multiple secrets for different environments.</p>&#13;
&#13;
<p>Let’s see the secrets our application will need:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">cat k8s/demo/production-secrets.yaml</code></strong><code class="go">&#13;
</code><code class="go">secret_one: ENC[AES256_GCM,data:ekH3xIdCFiS4j1I2ja8=,iv:C95KilXL...1g==,type:str]&#13;
</code><code class="go">secret_two: ENC[AES256_GCM,data:0Xcmm1cdv3TbfM3mIkA=,iv:PQOcI9vX...XQ==,type:str]&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
<p>Here we have used Sops to encrypt the values of multiple secrets for our application to use.</p>&#13;
&#13;
<p>Now take a look at the Kubernetes <em>secrets.yaml</em> file:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">cat k8s/demo/templates/secrets.yaml</code></strong><code class="go">&#13;
</code><code class="go">apiVersion: v1&#13;
</code><code class="go">kind: Secret&#13;
</code><code class="go">metadata:&#13;
</code><code class="go">  name: {{ .Values.container.name }}-secrets&#13;
</code><code class="go">type: Opaque&#13;
</code><code class="go">data:&#13;
</code><code class="go">    {{ $environment := .Values.environment }}&#13;
</code><code class="go">    app_secrets.yaml: {{ .Files.Get (nospace (cat $environment "-secrets.yaml"))&#13;
</code><code class="go">        | b64enc }}</code></pre>&#13;
&#13;
<p>On the last two lines, we’ve added some Go templating into the Helm chart to read secrets from either the <em>production-secrets.yaml</em> or the <em>staging-secrets.yaml</em> files, depending on which <code>environment</code> is set in the <em>values.yaml</em> file.</p>&#13;
&#13;
<p>The end result will be a single Kubernetes <code>Secret</code> named <em>demo-secrets</em>, containing all of the key-value pairs defined in either secret file. This <code>Secret</code> will get mounted in the Deployment as a single file named <em>secrets.yaml</em> for the application to use.</p>&#13;
&#13;
<p><a data-primary="b64enc" data-type="indexterm" id="idm45979377111216"/><a data-primary="base64" data-secondary="in Helm charts" data-type="indexterm" id="idm45979377110624"/>We’ve also added <code>...| b64enc</code> to the end of the last line. This is another handy shortcut using Helm’s Go templating to automatically convert the secret data from plain text to <code>base64</code>, which, by default, is what Kubernetes expects secrets to be (see <a data-type="xref" href="ch10.html#base64">“base64”</a>).</p>&#13;
&#13;
<p>We need to first temporarily decrypt the files using Sops, and then apply the changes to a Kubernetes cluster. Here is a command pipeline to deploy a staging version of the demo application, with its staging secrets:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="go">sops -d k8s/demo/staging-secrets.yaml &gt; temp-staging-secrets.yaml &amp;&amp; \</code>&#13;
<code class="go">helm upgrade --install staging-demo --values staging-values.yaml \</code>&#13;
<code class="go">--values temp-staging-secrets.yaml ./k8s/demo &amp;&amp; rm temp-staging-secrets.yaml</code></pre>&#13;
&#13;
<p>Here’s how that works:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Sops decrypts the <em>staging-secrets</em> file and writes the decrypted output to <em>temp-staging-secrets</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Helm installs the <code>demo</code> chart using values from <em>staging-values</em> and <em>temp-staging-secrets</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <em>temp-staging-secrets</em> file is deleted.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Because all this happens in one step, we don’t leave a file containing plain-text secrets lying around for the wrong people to find. This is very similar to how the <a href="https://oreil.ly/BX6uf"><code>helm-secrets</code></a> plugin works, so if this workflow appeals to you for managing secrets, it would be worth looking at this project<a data-startref="ix_12-deploying-adoc5" data-type="indexterm" id="idm45979377074128"/><a data-startref="ix_12-deploying-adoc4" data-type="indexterm" id="idm45979377073456"/><a data-startref="ix_12-deploying-adoc3" data-type="indexterm" id="idm45979377072784"/>.<a data-startref="ix_12-deploying-adoc2" data-type="indexterm" id="idm45979377071984"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing Multiple Charts with Helmfile" data-type="sect1"><div class="sect1" id="idm45979377071152">&#13;
<h1>Managing Multiple Charts with Helmfile</h1>&#13;
&#13;
<p><a data-primary="application deployment" data-secondary="managing multiple charts with Helmfile" data-type="indexterm" id="ix_12-deploying-adoc6"/><a data-primary="Helmfile" data-secondary="managing multiple charts with" data-type="indexterm" id="ix_12-deploying-adoc7"/>When we introduced Helm in <a data-type="xref" href="ch04.html#helm-intro">“Helm: A Kubernetes Package Manager”</a>, we showed you how to deploy the demo application Helm chart to a Kubernetes cluster. As useful as Helm is, it only operates on one chart at a time. How do you know what applications should be running in your cluster, together with the custom settings you applied when you installed them with Helm?</p>&#13;
&#13;
<p>There’s a neat tool called <a href="https://oreil.ly/pptjH">Helmfile</a> that can help you do this. Much as Helm makes it possible for you to deploy a single application using templating and variables, Helmfile enables you to deploy everything that should be installed on your cluster, with a single command.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What’s in a Helmfile?" data-type="sect2"><div class="sect2" id="idm45979377043648">&#13;
<h2>What’s in a Helmfile?</h2>&#13;
&#13;
<p><a data-primary="Helmfile" data-secondary="contents" data-type="indexterm" id="idm45979377042400"/>There’s an example of how to use Helmfile in the <code>demo</code> repository. In the <em>hello-helmfile</em> folder, you’ll find <em>helmfile.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">repositories</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus-community</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">url</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://prometheus-community.github.io/helm-charts</code><code class="w"/>&#13;
&#13;
<code class="nt">releases</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">chart</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">../hello-helm3/k8s/demo</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">values</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"../hello-helm3/k8s/demo/production-values.yaml"</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kube-state-metrics</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kube-state-metrics</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">chart</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus-community/kube-state-metrics</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">chart</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus-community/prometheus</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">set</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.create</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>repositories</code> section defines the Helm chart repositories we are going to reference. In this case, the only repository is <code>prometheus-community</code>, the official <span class="keep-together">Prometheus</span> helm repository. If you’re using your own Helm chart repo (see <a data-type="xref" href="#chartrepo">“Creating a Helm Chart Repo”</a>), add it here.</p>&#13;
&#13;
<p>Next, we define a set of <code>releases</code>: applications we would like to deploy to the cluster. Each release specifies some of the following metadata:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>name</code> of the Helm chart to deploy</p>&#13;
</li>&#13;
<li>&#13;
<p><code>namespace</code> to deploy it to</p>&#13;
</li>&#13;
<li>&#13;
<p><code>chart</code> is the URL or path to the chart itself</p>&#13;
</li>&#13;
<li>&#13;
<p><code>values</code> gives the path to a <em>values.yaml</em> file to use with the Deployment</p>&#13;
</li>&#13;
<li>&#13;
<p><code>set</code> sets any extra values in addition to those in the values file</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We’ve defined three releases here: the demo app, plus Prometheus (see <a data-type="xref" href="ch16.html#prometheus">“Prometheus”</a>) and <code>kube-state-metrics</code> (see <a data-type="xref" href="ch16.html#k8smetrics">“Kubernetes Metrics”</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chart Metadata" data-type="sect2"><div class="sect2" id="idm45979376902704">&#13;
<h2>Chart Metadata</h2>&#13;
&#13;
<p><a data-primary="Helmfile" data-secondary="chart metadata" data-type="indexterm" id="idm45979376901264"/>Note that we’ve specified a relative path to the <code>demo</code> chart and values files:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">chart</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">../hello-helm3/k8s/demo</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">values</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"../hello-helm3/k8s/demo/production-values.yaml"</code><code class="w"/></pre>&#13;
&#13;
<p>So your charts don’t need to be in a chart repository for Helmfile to manage them; you could keep them all in the same source code repo, for example.</p>&#13;
&#13;
<p>For the <code>prometheus</code> chart, we’ve specified <code>prometheus-community/prometheus</code>. Since this isn’t a filesystem path, Helmfile knows to look for the chart at the URL for the repo, which we defined earlier in the <code>repositories</code> section:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus-community</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">url</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://prometheus-community.github.io/helm-charts/</code><code class="w"/></pre>&#13;
&#13;
<p>All charts have various default values set in their respective <em>values.yaml</em> files. In the <code>set:</code> sections of Helmfile, you can specify any values that you would like to overwrite when installing the application.</p>&#13;
&#13;
<p>In this example, for the <code>prometheus</code> release, we wanted to ensure that the value for <code>rbac.create</code> is set to <code>true</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">chart</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prometheus-community/prometheus</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">set</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.create</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Applying the Helmfile" data-type="sect2"><div class="sect2" id="idm45979376718800">&#13;
<h2>Applying the Helmfile</h2>&#13;
&#13;
<p>The <em>helmfile.yaml</em>, then, specifies everything that should be running in the cluster (or at least, a subset of it) in a declarative way, just like Kubernetes manifests. When you apply this declarative manifest, Helmfile will bring the cluster into line with your specification.</p>&#13;
&#13;
<p><a data-primary="Helmfile" data-secondary="sync command" data-type="indexterm" id="idm45979376752176"/>To do this, run:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">helmfile sync</code></strong><code class="go">&#13;
</code><code class="go">Adding repo prometheus-&#13;
</code><code class="go">community https://prometheus-community.github.io/helm-charts&#13;
</code><code class="go">"prometheus-community" has been added to your repositories&#13;
</code><code class="go">&#13;
</code><code class="go">Building dependency release=demo, chart=../hello-helm3/k8s/demo&#13;
</code><code class="go">Affected releases are:&#13;
</code><code class="go">  demo (../hello-helm3/k8s/demo) UPDATED&#13;
</code><code class="go">  kube-state-metrics (prometheus-community/kube-state-metrics) UPDATED&#13;
</code><code class="go">  prometheus (prometheus-community/prometheus) UPDATED&#13;
</code><code class="go">  prometheus-node-&#13;
</code><code class="go">  exporter (prometheus-community/prometheus-node-exporter) UPDATED&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
<p>It’s just as though you had run <code>helm install</code>/<code>helm upgrade</code> in turn for each of the Helm charts you’ve defined.</p>&#13;
&#13;
<p>You might like to run <code>helm sync</code> automatically as part of your continuous deployment pipeline, for example (see <a data-type="xref" href="ch14.html#continuous">Chapter 14</a>). Instead of manually running <code>helm install</code> to add a new application to the cluster, you could just edit your Helmfile, check it into source control, and wait for the automation to roll out your changes. In <a data-type="xref" href="ch14.html#gitops">“GitOps”</a>, we will also introduce another way to manage multiple helm releases using a centralized tool.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Use a single source of truth. Don’t mix deploying individual charts manually with Helm, and declaratively managing all your charts across the cluster with Helmfile or a GitOps tool. If you apply a Helmfile, and then also use Helm to deploy or modify applications out of band, you will no longer have a single source of truth for your cluster. This is bound to lead to problems, so pick a process for how you will manage your deployments and be consistent in how you use it.</p>&#13;
</div>&#13;
&#13;
<p>If Helmfile isn’t quite to your liking, <a href="https://oreil.ly/DizPj">Helmsman</a> is a similar tool that does more or less the same thing.</p>&#13;
&#13;
<p>As with any new tool, we recommend reading through the docs, comparing the various options, trying them out, and then deciding which suits you.<a data-startref="ix_12-deploying-adoc7" data-type="indexterm" id="idm45979376702192"/><a data-startref="ix_12-deploying-adoc6" data-type="indexterm" id="idm45979376701488"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Advanced Manifest Management Tools" data-type="sect1"><div class="sect1" id="idm45979376678032">&#13;
<h1>Advanced Manifest Management Tools</h1>&#13;
&#13;
<p><a data-primary="application deployment" data-secondary="manifest management tools" data-type="indexterm" id="ix_12-deploying-adoc8"/><a data-primary="Helmfile" data-secondary="alternatives to" data-type="indexterm" id="ix_12-deploying-adoc9"/>While Helm is a great tool, and widely used, it does have a few limitations. Writing and editing Helm templates isn’t a lot of fun. Kubernetes YAML files are complicated, verbose, and repetitive. Therefore, so are Helm templates.</p>&#13;
&#13;
<p>Several new tools are under development that try to address these problems, and make it easier to work with Kubernetes manifests: either by describing them in a more powerful language than YAML, such as <a href="https://jsonnet.org">Jsonnet</a>, or by grouping the YAML files into basic patterns and customizing them with overlay files.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kustomize" data-type="sect2"><div class="sect2" id="idm45979376672880">&#13;
<h2>kustomize</h2>&#13;
&#13;
<p><a data-primary="kustomize" data-type="indexterm" id="idm45979376671344"/><a href="https://oreil.ly/nc9B6">kustomize</a> is probably the other most popular manifest management tool alongside Helm. In fact, as of Kubernetes version 1.14, kustomize was included inside the <code>kubectl</code> CLI tool. You can also use it separately by installing the <code>kustomize</code> binary following their <a href="https://oreil.ly/ePdt1">instructions</a>. Instead of templating, kustomize uses plain YAML files with overrides to allow for substitution and reuse. You start with the <em>base</em> YAML manifests, and use <em>overlays</em> to patch the manifests for different environments or configurations. kustomize will generate the final manifests from the base files plus the overlays.</p>&#13;
&#13;
<p>We have a working example in the <em>hello-kustomize</em> directory of the <a href="https://oreil.ly/LAI8f">cloudnativedevops GitHub demo repo</a>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">cd hello-kustomize/demo/base</code></strong><code class="go">&#13;
</code><strong><code class="go">kubectl kustomize ./</code></strong><code class="go">&#13;
</code><code class="go">apiVersion: v1&#13;
</code><code class="go">kind: Service&#13;
</code><code class="go">metadata:&#13;
</code><code class="go">  labels:&#13;
</code><code class="go">    app: demo&#13;
</code><code class="go">    org: acmeCorporation&#13;
</code><code class="go">  name: demo-service&#13;
</code><code class="go">...&#13;
</code><code class="go">---&#13;
</code><code class="go">apiVersion: apps/v1&#13;
</code><code class="go">kind: Deployment&#13;
</code><code class="go">metadata:&#13;
</code><code class="go">  labels:&#13;
</code><code class="go">    app: demo&#13;
</code><code class="go">    org: acmeCorporation&#13;
</code><code class="go">  name: demo&#13;
</code><code class="go">spec:&#13;
</code><code class="go">  replicas: 1&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
<p>In this example, kustomize reads our <em>kustomization.yaml</em> file, sets <code>commonLabels</code> on both the Deployment and Service for <code>app</code> and <code>org</code>, and displays the final rendered output of the updated manifests. What makes this different from Helm is that the original <em>deployment.yaml</em> and <em>service.yaml</em> files here are perfectly valid and usable YAML as-is, yet we still can add some flexibility like adding multiple common labels across our manifests using kustomize.</p>&#13;
&#13;
<p>The <code>patchesStrategicMerge</code> kustomize setting allows us to override a field, such as changing the replica count per environment:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl kustomize ../overlays/production</code></strong><code class="go">&#13;
</code><code class="go">...&#13;
</code><code class="go">apiVersion: apps/v1&#13;
</code><code class="go">kind: Deployment&#13;
</code><code class="go">metadata:&#13;
</code><code class="go">  labels:&#13;
</code><code class="go">    app: demo&#13;
</code><code class="go">    org: acmeCorporation&#13;
</code><code class="go">  name: prod-demo&#13;
</code><code class="go">spec:&#13;
</code><code class="go">  replicas: 3&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
<p>Again, you should see the final result of the rendered Deployment and Service manifests, but notice how we were able to change the <code>replicas</code> field for production environment to <code>3</code> based on the <em>replicas.yaml</em> file in the <em>overlays/production</em> directory.</p>&#13;
&#13;
<p>Another useful modification we applied here is the <code>namePrefix</code> setting. Our new Deployment is now named <code>name: prod-demo</code> instead of the default <code>name: demo</code> defined in the <em>base</em> directory, and our Service is renamed to <code>prod-demo-service</code>. Kustomize comes with other similar helpers for making tweaks to your manifests for different situations, all while keeping the original YAML manifests in a usable, valid state.</p>&#13;
&#13;
<p>To apply your kustomize-customized manifests, you can use <code>kubectl apply -k</code> (instead of the <code>kubectl apply -f</code>), and <code>kubectl</code> will use kustomize to read the YAML files, render any overlays or modifications, and then apply the final result into the cluster.</p>&#13;
&#13;
<p>If templating YAML files does not appeal to you, then kustomize is worth checking out. You may encounter community projects that offer you the option to install their applications using either their Helm chart or with kustomize, so it is worthwhile to become familiar with how it works.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tanka" data-type="sect2"><div class="sect2" id="idm45979376672256">&#13;
<h2>Tanka</h2>&#13;
&#13;
<p><a data-primary="Tanka" data-type="indexterm" id="idm45979376598256"/>Sometimes declarative YAML isn’t enough, especially for large and complex deployments where you need to be able to use computation and logic. For example, you might want to set the number of replicas dynamically based on the size of the cluster. For this, you need a real programming language.</p>&#13;
&#13;
<p><a data-primary="Jsonnet" data-type="indexterm" id="idm45979376574336"/><a href="https://oreil.ly/MBVrB">Tanka</a> lets you author Kubernetes manifests using a language called Jsonnet, which is an extended version of JSON (which is a declarative data format equivalent to YAML, and Kubernetes can understand JSON format manifests too). Jsonnet adds important capabilities to JSON—variables, loops, arithmetic, conditional statements, error handling, and so on.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kapitan" data-type="sect2"><div class="sect2" id="idm45979376572848">&#13;
<h2>Kapitan</h2>&#13;
&#13;
<p><a data-primary="Kapitan" data-type="indexterm" id="idm45979376571840"/><a href="https://oreil.ly/ekar1">Kapitan</a> is another manifest management tool, focused on sharing configuration values across multiple applications or even clusters. It can also be used for other types of tooling, such as terraform code, Dockerfiles, and Jinja2 template docs. Kapitan has a hierarchical database of config values (called the <em>inventory</em>) that lets you reuse manifest patterns by plugging in different values, depending on the environment or application, and they are generated using either the Jsonnet or Python-based Kadet backend engines:</p>&#13;
&#13;
<pre data-type="programlisting">local kube = import "lib/kube.libjsonnet";&#13;
local kap = import "lib/kapitan.libjsonnet";&#13;
local inventory = kap.inventory();&#13;
local p = inventory.parameters;&#13;
&#13;
{&#13;
    "00_namespace": kube.Namespace(p.namespace),&#13;
    "10_serviceaccount": kube.ServiceAccount("default")&#13;
}</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kompose" data-type="sect2"><div class="sect2" id="idm45979376568608">&#13;
<h2>kompose</h2>&#13;
&#13;
<p><a data-primary="kompose" data-type="indexterm" id="idm45979376567408"/>If you’ve been running production services in Docker containers, but not using Kubernetes, you may be familiar with Docker Compose.</p>&#13;
&#13;
<p>Compose lets you define and deploy sets of containers that work together: for example, a web server, a backend application, and a database such as Redis. A single <em>docker-compose.yml</em> file could be used to define how these containers talk to each other.</p>&#13;
&#13;
<p><a href="https://oreil.ly/vh2AU">kompose</a> is a tool to convert <em>docker-compose.yml</em> files into Kubernetes manifests, to help you migrate from Docker Compose to Kubernetes, without having to write your own Kubernetes manifests or Helm charts from scratch.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ansible" data-type="sect2"><div class="sect2" id="ansible">&#13;
<h2>Ansible</h2>&#13;
&#13;
<p><a data-primary="Ansible" data-type="indexterm" id="idm45979376562128"/>You may already be familiar with Ansible, a popular infrastructure automation tool. It’s not Kubernetes-specific, but it can manage many different kinds of resources, using extension modules, much like Puppet (see <a data-type="xref" href="ch03.html#puppet">“Puppet Kubernetes Module”</a>).</p>&#13;
&#13;
<p>As well as installing and configuring Kubernetes clusters, Ansible can manage Kubernetes resources like Deployments and Services directly, using the <a href="https://oreil.ly/dJTLA"><code>k8s</code> module</a>.</p>&#13;
&#13;
<p>Like Helm, Ansible can template Kubernetes manifests using its standard templating language (Jinja), and it has a more sophisticated notion of variable lookup, using a hierarchical system. For example, you can set common values for a group of applications, or a deployment environment such as <code>staging</code>.</p>&#13;
&#13;
<p>If you’re already using Ansible in your organization, it’s definitely worth evaluating whether you should use it for managing Kubernetes resources too. If your infrastructure is based solely on Kubernetes, then Ansible may be more power than you need, but for mixed infrastructures it can be very helpful to use just one tool to manage everything:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kube_resource_configmaps</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">my-resource-env</code><code class="p">:</code><code class="w"> </code><code class="s">"{{</code><code class="nv"> </code><code class="s">lookup('template',</code><code class="nv"> </code><code class="s">template_dir</code><code class="nv"> </code><code class="s">+</code><code class="w"/>&#13;
<code class="s">'/my-resource-env.j2')</code><code class="nv"> </code><code class="s">}}"</code><code class="w"/>&#13;
<code class="nt">kube_resource_manifest_files</code><code class="p">:</code><code class="w"> </code><code class="s">"{{</code><code class="nv"> </code><code class="s">lookup('fileglob',</code><code class="nv"> </code><code class="s">template_dir</code><code class="nv"> </code><code class="s">+</code><code class="w"/>&#13;
<code class="s">'/*manifest.yml')</code><code class="nv"> </code><code class="s">}}"</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">hosts</code><code class="p">:</code><code class="w"> </code><code class="s">"{{</code><code class="nv"> </code><code class="s">application</code><code class="nv"> </code><code class="s">}}-{{</code><code class="nv"> </code><code class="s">env</code><code class="nv"> </code><code class="s">}}-runner"</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">roles</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">kube-resource</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kubeval" data-type="sect2"><div class="sect2" id="kubeval">&#13;
<h2>kubeval</h2>&#13;
&#13;
<p><a data-primary="kubeval" data-type="indexterm" id="idm45979376473216"/>Unlike the other tools we’ve discussed in this section, <a href="https://oreil.ly/87Nh5"><code>kubeval</code></a> isn’t for generating or templating Kubernetes manifests, but for validating them.</p>&#13;
&#13;
<p>Each version of Kubernetes has a different schema for its YAML or JSON manifests, and it’s important to be able to check automatically that your manifests match the schema. For example, <code>kubeval</code> will check that you’ve specified all the required fields for a particular object, and that the values are of the right type.</p>&#13;
&#13;
<p><a data-primary="manifest" data-secondary="validating" data-type="indexterm" id="idm45979376530256"/><code>kubectl</code> also validates manifests when they’re applied, and will give you an error when you try to apply an invalid manifest. But it’s also very useful to be able to <span class="keep-together">validate</span> them beforehand. <code>kubeval</code> doesn’t need access to a cluster, and it can also validate against any version of Kubernetes.</p>&#13;
&#13;
<p>It’s a good idea to add <code>kubeval</code> to your continuous deployment pipeline so that manifests are automatically validated whenever you make changes to them. You can also use <code>kubeval</code> to test, for example, whether your manifests need any adjustments to work on the latest version of Kubernetes before you actually upgrade.<a data-startref="ix_12-deploying-adoc9" data-type="indexterm" id="idm45979376526080"/><a data-startref="ix_12-deploying-adoc8" data-type="indexterm" id="idm45979376525376"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45979376524448">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>While you can deploy applications to Kubernetes using just raw YAML manifests, it’s inconvenient. Helm is a powerful tool that can help with this, provided you understand how to get the best out of it.</p>&#13;
&#13;
<p>There are lots of different tools that will make Kubernetes manifest management much easier in the future. It’s important to be familiar with the basics of using Helm because many popular tools are offered to you as Helm charts for installing in your clusters:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A chart is a Helm package specification, including metadata about the package, some configuration values for it, and template Kubernetes objects that reference those values.</p>&#13;
</li>&#13;
<li>&#13;
<p>Installing a chart creates a Helm release. Each time you install an instance of a chart, a new release is created. When you update a release with different config values, Helm increments the release revision number.</p>&#13;
</li>&#13;
<li>&#13;
<p>To customize a Helm chart for your own requirements, create a custom values file overriding just the settings you care about, and add it to the <code>helm install</code> or <code>helm upgrade</code> command line.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can use a variable (<code>environment</code>, for example) to select different sets of values or secrets depending on the deployment environment: staging, production, and so on.</p>&#13;
</li>&#13;
<li>&#13;
<p>With Helmfile, you can declaratively specify a set of Helm charts and values to be applied to your cluster, and install or update all of them with a single command.</p>&#13;
</li>&#13;
<li>&#13;
<p>Helm can be used along with Sops for handling secret configuration in your charts. It can also use a  function to automatically base64-encode your secrets, which Kubernetes expects them to be.</p>&#13;
</li>&#13;
<li>&#13;
<p>Helm is not the only available tool for managing Kubernetes manifests. Kustomize is another powerful tool and is even built into <code>kubectl</code>. Kustomize takes a different approach than Helm and rather than interpolating variables, it just uses YAML overlays to tweak manifests.</p>&#13;
</li>&#13;
<li>&#13;
<p>Tanka and Kapitan are alternative manifest management tools that use Jsonnet, a different templating language.</p>&#13;
</li>&#13;
<li>&#13;
<p>A quick way to test and validate manifests is to use <code>kubeval</code>, which will check for valid syntax and  common errors in manifests.<a data-startref="ix_12-deploying-adoc0" data-type="indexterm" id="idm45979376443968"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>