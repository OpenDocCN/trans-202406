- en: Chapter 1\. CSS Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Cascading Style Sheets* (*CSS*), a powerful programming language that transforms
    the presentation of a document or a collection of documents, has spread to nearly
    every corner of the web as well as many ostensibly nonweb environments. For example,
    embedded-device displays often use CSS to style their user interfaces, many RSS
    clients let you apply CSS to feeds and feed entries, and some instant message
    clients use CSS to format chat windows. Aspects of CSS can be found in the syntax
    used by JavaScript (JS) frameworks and even in JS itself. It’s everywhere!'
  prefs: []
  type: TYPE_NORMAL
- en: A Brief History of (Web) Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS was first proposed in 1994, just as the web was beginning to really catch
    on. At the time, browsers gave all sorts of styling power to the user—the presentation
    preferences in NCSA Mosaic, for example, permitted the user to define each element’s
    font family, size, and color. None of this was available to document authors;
    all they could do was mark a piece of content as a paragraph, as a heading of
    some level, as preformatted text, or one of a dozen other element types. If a
    user configured their browser to make all level-one headings tiny and pink and
    all level-six headings huge and red, well, that was their lookout.
  prefs: []
  type: TYPE_NORMAL
- en: It was into this milieu that CSS was introduced. Its goal was to provide a simple,
    declarative styling language that was flexible for web page authors and, most
    importantly, provided styling power to authors and users alike. By means of the
    *cascade*, these styles could be combined and prioritized so that both site authors
    and readers had a say—though readers always had the last say.
  prefs: []
  type: TYPE_NORMAL
- en: Work quickly advanced, and by late 1996, CSS1 was finished. While the newly
    established CSS Working Group moved forward with CSS2, browsers struggled to implement
    CSS1 in an interoperable way. Although each piece of CSS was fairly simple on
    its own, the combination of those pieces created some surprisingly complex behaviors.
    Unfortunate missteps also occurred, such as the infamous discrepancy in box model
    implementations. These problems threatened to derail CSS altogether, but fortunately
    some clever proposals were implemented, and browsers began to harmonize. Within
    a few years, thanks to increasing interoperability and high-profile developments
    such as the CSS-based redesign of *Wired* magazine and the CSS Zen Garden, CSS
    began to catch on.
  prefs: []
  type: TYPE_NORMAL
- en: Before all that happened, though, the CSS Working Group had finalized the CSS2
    specification in early 1998\. Once CSS2 was finished, work immediately began on
    CSS3, as well as a clarified version of CSS2 called CSS2.1\. In keeping with the
    spirit of the times, what was initially coined *CSS3* was constructed as a series
    of (theoretically) standalone modules instead of a single monolithic specification.
    This approach reflected the then-active XHTML specification, which was split into
    modules for similar reasons.
  prefs: []
  type: TYPE_NORMAL
- en: The rationale for modularizing CSS was that each module could be worked on at
    its own pace, and particularly critical (or popular) modules could be advanced
    along the World Wide Web Consortium’s (W3C’s) progress track without being held
    up by others. Indeed, this has turned out to be the case. By early 2012, three
    CSS Level 3 modules (along with CSS1 and CSS 2.1) had reached full Recommendation
    status—CSS Color Level 3, CSS Namespaces, and Selectors Level 3\. At that same
    time, seven modules were at Candidate Recommendation status, and several dozen
    others were in various stages of Working Draft-ness. Under the old approach, colors,
    selectors, and namespaces would have had to wait for every other part of the specification
    to be done or cut before they could be part of a completed specification. Thanks
    to modularization, they didn’t have to wait.
  prefs: []
  type: TYPE_NORMAL
- en: So while we can’t really point to a single tome and say, “This is CSS,” we can
    talk of features by the module name under which they are introduced. The flexibility
    permitted by modules more than makes up for the semantic awkwardness they sometimes
    create. (If you want something approximating a single monolithic specification,
    the CSS Working Group publishes yearly “Snapshot” documents.)
  prefs: []
  type: TYPE_NORMAL
- en: With that established, we’re ready to start understanding CSS. Let’s start by
    covering the basics of what goes inside a stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: Stylesheet Contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside a stylesheet, you’ll find a number of *rules* that look a little something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Styles such as these make up the bulk of any stylesheet—simple or complex, short
    or long. But which parts are which, and what do they represent?
  prefs: []
  type: TYPE_NORMAL
- en: Rule Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To illustrate the concept of rules in more detail, let’s break down the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each *rule* has two fundamental parts: the selector and the declaration block.
    The declaration block is composed of one or more declarations, and each declaration
    is a pairing of a property and a value. Every stylesheet is made up of a series
    of these rules. [Figure 1-1](#the_structure_of_a_rule) shows the parts of a rule.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0101](assets/css5_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. The structure of a rule
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *selector*, shown on the left side of the rule, defines which piece of the
    document will be selected for styling. In [Figure 1-1](#the_structure_of_a_rule),
    `<h1>` (heading level 1) elements are selected. If the selector were `p`, then
    all `<p>` (paragraph) elements would be selected.
  prefs: []
  type: TYPE_NORMAL
- en: The right side of the rule contains the *declaration block*, which is made up
    of one or more declarations. Each *declaration* is a combination of a CSS *property*
    and a *value* of that property. In [Figure 1-1](#the_structure_of_a_rule), the
    declaration block contains two declarations. The first states that this rule will
    cause parts of the document to have a `color` of `red`, and the second states
    that part of the document will have a `background` of `yellow`. So, all of the
    `<h1>` elements in the document (defined by the selector) will be styled in red
    text with a yellow background.
  prefs: []
  type: TYPE_NORMAL
- en: Vendor Prefixing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you’ll see pieces of CSS with hyphens and labels in front of them,
    like this: `-o-border-image`. These *vendor prefixes* were a way for browser vendors
    to mark properties, values, or other bits of CSS as being experimental or proprietary
    (or both). As of early 2023, a few vendor prefixes are in the wild, with the most
    common shown in [Table 1-1](#common_vendor_prefixes).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-1\. Some common vendor prefixes
  prefs: []
  type: TYPE_NORMAL
- en: '| Prefix | Vendor |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-epub-` | International Digital Publishing Forum ePub format |'
  prefs: []
  type: TYPE_TB
- en: '| `-moz-` | Gecko-based browsers (e.g., Mozilla Firefox) |'
  prefs: []
  type: TYPE_TB
- en: '| `-ms-` | Microsoft Internet Explorer |'
  prefs: []
  type: TYPE_TB
- en: '| `-o-` | Opera-based browsers |'
  prefs: []
  type: TYPE_TB
- en: '| `-webkit-` | WebKit-based browsers (e.g., Apple Safari and Google Chrome)
    |'
  prefs: []
  type: TYPE_TB
- en: As [Table 1-1](#common_vendor_prefixes) indicates, the generally accepted format
    of a vendor prefix is a hyphen, a label, and a hyphen, although a few prefixes
    erroneously omit the first hyphen.
  prefs: []
  type: TYPE_NORMAL
- en: The uses and abuses of vendor prefixes are long, tortuous, and beyond the scope
    of this book. Suffice to say that they started out as a way for vendors to test
    out new features, thus helping speed interoperability without worrying about being
    locked into legacy behaviors that were incompatible with other browsers. This
    avoided a whole class of problems that nearly strangled CSS in its infancy. Unfortunately,
    prefixed properties were then publicly deployed by web authors and ended up causing
    a whole new class of problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of early 2023, vendor-prefixed CSS features are nearly nonexistent, with
    old prefixed properties and values being slowly but steadily removed from browser
    implementations. You’ll quite likely never write prefixed CSS, but you may encounter
    it in the wild or inherit it in a legacy codebase. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s saying the same thing four times: once each for the WebKit, Gecko (Firefox),
    and Opera browser lines, and then finally the CSS-standard way. Again, this is
    no longer necessary. We’re including it here only to give you an idea of what
    it might look like, should you come across this in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: Whitespace Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS is basically insensitive to whitespace between rules, and largely insensitive
    to whitespace within rules, although a few exceptions exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, CSS treats whitespace just like HTML does: any sequence of whitespace
    characters is collapsed to a single space for parsing purposes. Thus, you can
    format this hypothetical `rainbow` rule in the following ways,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'as well as any other separation patterns you can think up. The only restriction
    is that the separating characters be whitespace: an empty space, a tab, or a newline,
    alone or in combination, as many as you like.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can format series of rules with whitespace in any fashion you
    like. These are just five examples out of an effectively infinite number of possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the first rule, whitespace can be largely omitted. Indeed,
    this is usually the case with *minified* CSS, which is CSS that’s had every last
    possible bit of extraneous whitespace removed, usually by an automated server-side
    script of some sort. The rules after the first two use progressively more extravagant
    amounts of whitespace until, in the last rule, pretty much everything that can
    be separated onto its own line has been.
  prefs: []
  type: TYPE_NORMAL
- en: All of these approaches are valid, so you should pick the formatting that makes
    the most sense—that is, is easiest to read—in your eyes, and stick with it.
  prefs: []
  type: TYPE_NORMAL
- en: CSS Comments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSS does allow for comments. These are very similar to C/C++ comments in that
    they are surrounded by /`*` and `*`/:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Comments can span multiple lines, just as in C++:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s important to remember that CSS comments cannot be nested. So, for example,
    this would *not* be correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One way to create “nested” comments accidentally is to temporarily comment out
    a large block of a stylesheet that already contains a comment. Since CSS doesn’t
    permit nested comments, the “outside” comment will end where the “inside” comment
    ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, there is no “rest of the line” comment pattern such as `//`
    or `#` (the latter of which is reserved for ID selectors anyway). The only comment
    pattern in CSS is /`*` `*`/. Therefore, if you wish to place comments on the same
    line as markup, you need to be careful about how you place them. For example,
    this is the correct way to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Given this example, if each line isn’t marked off, most of the stylesheet will
    become part of the comment and thus will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, only the first rule (`h1 {color: gray;}`) will be applied
    to the document. The rest of the rules, as part of the comment, are ignored by
    the browser’s rendering engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: CSS comments are treated by the CSS parser as if they do not exist at all, and
    so do not count as whitespace for parsing purposes. This means you can put them
    into the middle of rules—even right inside declarations!
  prefs: []
  type: TYPE_NORMAL
- en: Markup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*There is no markup in stylesheets*. This might seem obvious, but you’d be
    surprised. The one exception is HTML comment markup, which is permitted inside
    `<style>` elements for historical reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That’s it, and even that isn’t recommended anymore; the browsers that needed
    it have faded into near oblivion.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of markup, it’s time to take a very slight detour to talk about the
    elements that our CSS will be used to style, and how those can be affected by
    CSS in the most fundamental ways.
  prefs: []
  type: TYPE_NORMAL
- en: Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Elements* are the basis of document structure. In HTML, the most common elements
    are easily recognizable, such as `<p>`, `<table>`, `<span>`, `<a>`, and `<article>`.
    Every single element in a document plays a part in its presentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Replaced and Nonreplaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although CSS depends on elements, not all elements are created equal. For example,
    images and paragraphs are not the same type of element. In CSS, elements generally
    take two forms: replaced and nonreplaced.'
  prefs: []
  type: TYPE_NORMAL
- en: Replaced elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Replaced elements* are used to indicate content that is to be replaced by
    something not directly represented in the document. Probably the most familiar
    HTML example is the `<img>` element, which is replaced by an image file external
    to the document itself. In fact, `<img>` has no actual content, as you can see
    in this simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This markup fragment contains only an element name and an attribute. The element
    presents nothing unless you point it to external content (in this case, an image
    file whose location is given by the `src` attribute). If you point to a valid
    image file, the image will be placed in the document. If not, the browser will
    either display nothing or will show a “broken image” placeholder.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `input` element can also be replaced—by a radio button, checkbox,
    text input box, or other, depending on its type.
  prefs: []
  type: TYPE_NORMAL
- en: Nonreplaced elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The majority of HTML elements are *nonreplaced elements*. Their content is presented
    by the user agent (generally a browser) inside a box generated by the element
    itself. For example, `<span>hi there</span>` is a nonreplaced element, and the
    text “hi there” will be displayed by the user agent. This is true of paragraphs,
    headings, table cells, lists, and almost everything else in HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Element Display Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSS has two basic display roles: *block formatting context* and *inline formatting
    context*. Many more display types exist, but these are the most basic, and the
    types to which most, if not all, other display types refer. The block and inline
    contexts will be familiar to authors who have spent time with HTML markup and
    its display in web browsers. The display roles are illustrated in [Figure 1-2](#block-_and_inline-level_elements_in_an).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0102](assets/css5_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. Block- and inline-level elements in an HTML document
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Block-level elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, *block-level elements* generate an element box that (by default)
    fills its parent element’s content area and cannot have other elements at its
    sides. In other words, it generates “breaks” before and after the element box.
    The most familiar block elements from HTML are `<p>` and `<div>`. Replaced elements
    can be block-level elements, but usually they are not.
  prefs: []
  type: TYPE_NORMAL
- en: In CSS, this is referred to as an element generating a *block formatting context*.
    It also means that the element generates a block *outer display type*. The parts
    inside the element may have different display types.
  prefs: []
  type: TYPE_NORMAL
- en: Inline-level elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, *inline-level elements* generate an element box within a line of
    text and do not break up the flow of that line. The best inline element example
    is the `<a>` element in HTML. Other candidates are `<strong>` and `<em>`. These
    elements do not generate a “break” before or after themselves, so they can appear
    within the content of another element without disrupting its display.
  prefs: []
  type: TYPE_NORMAL
- en: In CSS, this is referred to as an element generating an *inline formatting context*.
    It also means that the element generates an *inline outer display* type. The parts
    inside the element may have different display types. (In CSS, there is no restriction
    on how display roles can be nested within each other.)
  prefs: []
  type: TYPE_NORMAL
- en: To see how this works, let’s consider the CSS property `display`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that there are a *lot* of values here, only two of which
    we’ve mentioned: `block` and `inline`. Most of these values are dealt with elsewhere
    in the book; for example, `grid` and `inline-grid` are covered in [Chapter 12](ch12.html#grid-layout),
    and the table-related values are all covered in [Chapter 13](ch13.html#title-table-layout-in-css).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s concentrate on `block` and `inline`. Consider the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here we have two elements (`<body>` and `<p>`) that are generating block formatting
    contexts, and one element (`<em>`) with an inline formatting context. According
    to the HTML specification, `<em>` can descend from `<p>`, but the reverse is not
    true. Typically, the HTML hierarchy works out so that inlines descend from blocks,
    but not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS, on the other hand, has no such restrictions. You can leave the markup
    as it is but change the display roles of the two elements like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This causes the elements to generate a block box inside an inline box. This
    is perfectly legal and violates no part of CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'While changing the display roles of elements can be useful in HTML documents,
    it becomes downright critical for XML documents. An XML document is unlikely to
    have any inherent display roles, so it’s up to the author to define them. For
    example, you might wonder how to lay out the following snippet of XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Since the default value of `display` is `inline`, the content would be rendered
    as inline text by default, as illustrated in [Figure 1-3](#default_display_of_an_xml_document).
    This isn’t a terribly useful display.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0103](assets/css5_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3\. Default display of an XML document
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can define the basics of the layout with `display`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We’ve now set five of the seven elements to be block and two to be inline. This
    means each of the block elements will generate its own block formatting context,
    and the two inlines will generate their own inline formatting contexts.
  prefs: []
  type: TYPE_NORMAL
- en: We could take the preceding rules as a starting point, add a few other styles
    for greater visual impact, and get the result shown in [Figure 1-4](#styled_display_of_an_xml_document).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0104](assets/css5_0104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4\. Styled display of an XML document
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: That said, before learning how to write CSS in detail, we need to look at how
    to associate CSS with a document. After all, without tying the two together, there’s
    no way for the CSS to affect the document. We’ll explore this in an HTML setting
    since it’s the most familiar.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing CSS and HTML Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve mentioned that HTML documents have an inherent structure, and that’s
    a point worth repeating. In fact, that’s part of the problem with web pages of
    old: too many of us forgot that documents are supposed to have an internal structure,
    which is altogether different from a visual structure. In our rush to create the
    coolest-looking pages on the web, we bent, warped, and generally ignored the idea
    that pages should contain information with some structural meaning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That structure is an inherent part of the relationship between HTML and CSS;
    without it, there couldn’t be a relationship at all. To understand it better,
    let’s look at an example HTML document and break it down by pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 1-5](#a_simple_document) shows the result of this markup and the applied
    styles.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0105](assets/css5_0105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-5\. A simple document
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, let’s examine the various ways this document connects to CSS.
  prefs: []
  type: TYPE_NORMAL
- en: The <link> Tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, consider the use of the `<link>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `<link>` tag’s basic purpose is to allow HTML authors to associate other
    documents with the document containing the `<link>` tag. CSS uses it to link stylesheets
    to the document.
  prefs: []
  type: TYPE_NORMAL
- en: These stylesheets, which are not part of the HTML document but are still used
    by it, are referred to as *external stylesheets*. This is because they’re stylesheets
    that are external to the HTML document. (Go figure.)
  prefs: []
  type: TYPE_NORMAL
- en: To successfully load an external stylesheet, `<link>` should be placed inside
    the `<head>` element, though it can also appear inside the `<body>` element. This
    will cause the web browser to locate and load the stylesheet and use whatever
    styles it contains to render the HTML document; [Figure 1-6](#a_representation_of_how_external_style)
    depicts the stylesheet called *sheet1.css* being linked to the document.
  prefs: []
  type: TYPE_NORMAL
- en: Also shown in [Figure 1-6](#a_representation_of_how_external_style) is the loading
    of the external *sheet2.css* via an `@import` declaration. Imports must be placed
    at the beginning of the stylesheet that contains them.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0106](assets/css5_0106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-6\. A representation of how external stylesheets are applied to documents
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And what is the format of an external stylesheet? It’s a list of rules, just
    like those you saw in the previous section and in the example HTML document; but
    in this case, the rules are saved into their own file. Just remember that no HTML
    or any other markup language can be included in the stylesheet—only style rules.
    Here are the contents of an external stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: That’s all there is to it—no HTML markup or comments at all, just plain-and-simple
    style declarations. These are saved into a plain-text file and are usually given
    an extension of *.css*, as in *sheet1.css*.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An external stylesheet cannot contain any document markup at all, only CSS rules
    and CSS comments. The presence of markup in an external stylesheet can cause some
    or all of it to be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the rest of the `<link>` tag, the attributes and values are fairly straightforward.
    The `rel` attribute stands for *relation*, and in this case, the relation is `stylesheet`.
    Note that the `rel` attribute is *required*. CSS has an optional `type` attribute
    whose default value is `text/css`, so you can include `type="text/css"` or leave
    it out, whichever you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: These attribute values describe the relationship and type of data that will
    be loaded using the `<link>` tag. That way, the web browser knows that the stylesheet
    is a CSS stylesheet, a fact that will determine how the browser will deal with
    the data it imports. (Other style languages may be used in the future. In such
    a future, if you are using a different style language, the `type` attribute will
    need to be declared.)
  prefs: []
  type: TYPE_NORMAL
- en: Next, we find the `href` attribute. The value of this attribute is the URL of
    your stylesheet. This URL can be either absolute or relative—that is, either relative
    to the URL of the document containing the URL, or else a complete URL that points
    to a unique location on the web. In our example, the URL is relative. It could
    have been something absolute, like *[*http://example.com/sheet1.css*](http://example.com/sheet1.css)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have a `media` attribute. The value of this attribute is one or
    more *media descriptors*, which are rules regarding media types and the features
    of those media, with each rule separated by a comma. Thus, for example, you can
    use a linked stylesheet in both screen and print media:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Media descriptors can get quite complicated and are explained in detail in [Chapter 21](ch21.html#css-at-rules).
    For now, we’ll stick with the basic media types shown. The default value is `all`,
    which means the CSS will be applied in all media.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that more than one linked stylesheet can be associated with a document.
    In these cases, only those `<link>` tags with a `rel` of `stylesheet` will be
    used in the initial display of the document. Thus, if you wanted to link two stylesheets
    named *basic.css* and *splash.css*, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause the browser to load both stylesheets, combine the rules from
    each, and apply them all to the document in all media types (because the `media`
    attribute is omitted, its default value `all` is used). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The one attribute that isn’t in this example markup, but could be, is `title`.
    This attribute is not often used but could become important in the future and,
    if used improperly, can have unexpected effects. Why? We’ll explore that in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate stylesheets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s possible to define *alternate stylesheets* that users can select in some
    browsers. These are defined by making the value of the `rel` attribute `alternate
    stylesheet`, and they are used in document presentation only if selected by the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should a browser be able to use alternate stylesheets, it will use the values
    of the `<link>` element’s `title` attributes to generate a list of style alternatives.
    So you could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Users could then pick the style they want to use, and the browser would switch
    from the first one, labeled `Default` in this case, to whichever the user picked.
    [Figure 1-7](#a_browser_offering_alternate_style) shows one way in which this
    selection mechanism might be accomplished (and in fact was, early in the resurgence
    of CSS).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0107](assets/css5_0107.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-7\. A browser offering alternate stylesheet selection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of early 2023, alternate stylesheets are supported in most Gecko-based browsers
    like Firefox. The Chromium and WebKit families do not support selecting alternate
    stylesheets. Compare this to the build date of the browser shown in [Figure 1-7](#a_browser_offering_alternate_style),
    which is late 2002.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to group alternate stylesheets together by giving them the
    same `title` value. Thus, you make it possible for the user to pick a different
    presentation for your site in both screen and print media:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If a user selects Big Text from the alternate stylesheet selection mechanism
    in a conforming user agent, *bigtext.css* will be used to style the document in
    the screen medium, and *print-bigtext.css* will be used in the print medium. Neither
    *sheet1.css* nor *print-sheet1.css* will be used in any medium.
  prefs: []
  type: TYPE_NORMAL
- en: Why is that? Because if you give a `<link>` with a `rel` of `stylesheet` a title,
    you are designating that stylesheet as a *preferred stylesheet*. Its use is preferred
    to alternate stylesheets, and it will be used when the document is first displayed.
    Once you select an alternate stylesheet, however, the preferred stylesheet will
    *not* be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if you designate a number of stylesheets as preferred, all but
    one of them will be ignored. Consider the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: All three `<link>` elements now refer to preferred stylesheets, thanks to the
    presence of a `title` attribute on all three, but only one of them will actually
    be used in that manner. The other two will be ignored completely. Which two? There’s
    no way to be certain, as HTML doesn’t provide a method of determining which preferred
    stylesheets should be ignored and which should be used.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t give a stylesheet a title, it becomes a *persistent stylesheet*
    and is always used in the display of the document. Often, this is exactly what
    an author wants, especially since alternate stylesheets are not widely supported
    and are almost completely unknown to users.
  prefs: []
  type: TYPE_NORMAL
- en: The <style> Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `<style>` element is one way to include a stylesheet, and it appears in
    the document itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The styles between the opening and closing `<style>` tags are referred to as
    the *document stylesheet* or the *embedded stylesheet* (because this kind of stylesheet
    is embedded within the document). It contains styles that apply to the document,
    but it can also contain multiple links to external stylesheets via the `@import`
    directive, discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can give `<style>` elements a `media` attribute, which functions in the
    same manner as it does on linked stylesheets. This, for example, will restrict
    an embedded stylesheet’s rules to be applied in print media only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can also label an embedded stylesheet with a `<title>` element, in the same
    manner and for the same reasons discussed in the previous section on alternate
    stylesheets.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `<link>` element, the `<style>` element can use the attribute `type`;
    in the case of a CSS document, the correct value is `"text/css"`. The `type` attribute
    is optional in HTML as long as you’re loading CSS, because the default value for
    the `type` attribute on the `<style>` element is `text/css`. It would be necessary
    to explicitly declare a `type` value only if you were using some other styling
    language, perhaps in a future where such a thing is supported. For the time being,
    though, the attribute remains wholly optional.
  prefs: []
  type: TYPE_NORMAL
- en: The @import Directive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we’ll discuss the stuff that is found inside the `<style>` tag. First,
    we have something very similar to `<link>`, the `@import` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like `<link>`, `@import` can be used to direct the web browser to load
    an external stylesheet and use its styles in the rendering of the HTML document.
    The only major difference is in the syntax and placement of the command. As you
    can see, `@import` is found inside the `<style>` element. It must be placed first,
    before the other CSS rules, or it won’t work at all. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `<link>`, a document can have more than one `@import` statement. Unlike
    `<link>`, however, the stylesheets of every `@import` directive will be loaded
    and used; there is no way to designate alternate stylesheets with `@import`. So,
    given the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: …all three external stylesheets will be loaded, and all of their style rules
    will be used in the display of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `<link>`, you can restrict imported stylesheets to one or more media
    by providing media descriptors after the stylesheet’s URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As noted in [“The <link> Tag”](#the_link_tag), media descriptors can get quite
    complicated and are explained in detail in [Chapter 21](ch21.html#css-at-rules).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@import` directive can be highly useful if you have an external stylesheet
    that needs to use the styles found in other external stylesheets. Since external
    stylesheets cannot contain any document markup, the `<link>` element can’t be
    used—but `@import` can. Therefore, you might have an external stylesheet that
    contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Well, maybe not those exact styles, but hopefully you get the idea. Note the
    use of both absolute and relative URLs in the previous example. Either URL form
    can be used, just as with `<link>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that the `@import` directives appear at the beginning of the stylesheet,
    as they did in the example document. As we said previously, CSS requires the `@import`
    directives to come before any rules in a stylesheet, though they can be preceded
    by `@charset` and `@layer` declarations. An `@import` that comes after other rules
    (e.g., `body {color`: `red;}`) will be ignored by conforming user agents.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some versions of Internet Explorer for Windows did not ignore any `@import`
    directive, even those that come after other rules, but all modern browsers do
    ignore improperly placed `@import` directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another descriptor that can be added to an `@import` directive is a *cascade
    layer* identifier. This assigns all of the styles in the imported stylesheet to
    a cascade layer, which is a concept we’ll explore in [Chapter 4](ch04.html#specificity_comma_inheritance).
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'That assigns the styles from *basic-text.css* to the `basic` cascade layer.
    If you want to assign the styles to an unnamed layer, use `layer` without the
    parenthetical naming, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that this ability is a difference between `@import` and `<link>`, as the
    latter cannot be labeled with a cascade layer.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Linking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In another, far more obscure way to associate CSS with a document, you can link
    the two via HTTP headers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under Apache HTTP Server, this can be accomplished by adding a reference to
    the CSS file in a *.htaccess* file. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause supporting browsers to associate the referenced stylesheet
    with any documents served from under that *.htaccess* file. The browser will then
    treat it as if it were a linked stylesheet. Alternatively, and probably more efficiently,
    you can add an equivalent rule to the server’s *httpd.conf* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The effect is exactly the same in supporting browsers. The only difference is
    in where you declare the linking.
  prefs: []
  type: TYPE_NORMAL
- en: You probably noticed the use of the term “supporting browsers.” As of late 2022,
    the widely used browsers that support HTTP linking of stylesheets are the Firefox
    family and Opera. That restricts this technique mostly to development environments
    based on one of those browsers. In such a situation, you can use HTTP linking
    on the test server to mark when you’re on the development site as opposed to the
    public site. It’s also an interesting way to hide styles from Chromium browsers,
    assuming you have a reason to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Equivalents to this linking technique are used in common scripting languages
    such as PHP and IIS, both of which allow the author to emit HTTP headers. It’s
    also possible to use such languages to explicitly write `link` elements into the
    document based on the server offering up the document. This is a more robust approach
    in terms of browser support: every browser supports the `link` element.'
  prefs: []
  type: TYPE_NORMAL
- en: Inline Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to just assign a few styles to one individual element, without
    the need for embedded or external stylesheets, you can employ the HTML attribute
    `style`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `style` attribute can be associated with any HTML tag whatsoever, even tags
    found outside of `<body>` (`<head>` or `<title>`, for instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of a `style` attribute is fairly ordinary. In fact, it looks very
    much like the declarations found in the `<style>` container, except here the curly
    braces are replaced by double quotation marks. So `<p style="color`: `maroon;
    background`: `yellow;">` will set the text color to be maroon and the background
    to be yellow *for that paragraph only*. No other part of the document will be
    affected by this declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can place only a declaration block, not an entire stylesheet,
    inside an inline `style` attribute. Therefore, you can’t put an `@import` into
    a `style` attribute, nor can you include any complete rules. The only thing you
    can put into the value of a `style` attribute is what might go between the curly
    braces of a rule.
  prefs: []
  type: TYPE_NORMAL
- en: Use of the `style` attribute is discouraged. Many of the primary advantages
    of CSS—the ability to organize centralized styles that control an entire document’s
    appearance or the appearance of all documents on a web server—are negated when
    you place styles into a `style` attribute. In many ways, inline styles are not
    much better than the ancient `<font>` tag, even if they do have a good deal more
    flexibility in terms of which visual effects they can apply.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With CSS, you can completely change the way elements are presented by a user
    agent. You can do this at a basic level with the `display` property, and in a
    different way by associating stylesheets with a document. The user will never
    know whether this is done via an external or embedded stylesheet, or even with
    an inline style. The real importance of external stylesheets is the way in which
    they allow you to put all of a site’s presentation information in one place, and
    point all of the documents to that place. This not only makes site updates and
    maintenance a breeze, but also helps to save bandwidth, since all of the presentation
    is removed from documents.
  prefs: []
  type: TYPE_NORMAL
- en: To make the most of the power of CSS, you need to know how to associate a set
    of styles with the elements in a document. To fully understand how CSS can do
    all of this, you need a firm grasp of the way CSS selects pieces of a document
    for styling, which is the subject of the next few chapters.
  prefs: []
  type: TYPE_NORMAL
