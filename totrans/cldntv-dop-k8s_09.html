<html><head></head><body><section data-pdf-bookmark="Chapter 7. Kubernetes Power Tools" data-type="chapter" epub:type="chapter"><div class="chapter" id="powertools">&#13;
<h1><span class="label">Chapter 7. </span>Kubernetes Power Tools</h1>&#13;
&#13;
<blockquote class="epigraph">&#13;
<p>My mechanic told me, “I couldn’t repair your brakes, so I made your horn louder.”</p>&#13;
<p data-type="attribution">Steven Wright</p>&#13;
</blockquote>&#13;
&#13;
<p><a data-primary="Kubernetes" data-secondary="tools and utilities" data-type="indexterm" id="ix_07-tools-adoc0"/>People always ask us, “What about all these Kubernetes tools? Do I need them? If so, which ones? And what do they all do?”</p>&#13;
&#13;
<p>In this chapter, we’ll explore a small part of the landscape of tools and utilities that help you work with Kubernetes. We’ll show you some advanced techniques with <code>kubectl</code>, and a few useful utilities such as <code>jq</code>, <code>kubectx</code>/<code>kubens</code>, <code>kube-ps1</code>, Click, <code>kubed-sh</code>, Stern, and BusyBox.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mastering kubectl" data-type="sect1"><div class="sect1" id="idm45979386854192">&#13;
<h1>Mastering kubectl</h1>&#13;
&#13;
<p><a data-primary="kubectl" data-type="indexterm" id="ix_07-tools-adoc1"/>We’ve already met <code>kubectl</code>, starting in <a data-type="xref" href="ch02.html#firststeps">Chapter 2</a>, and as it’s the primary tool for interacting with Kubernetes, you may already be comfortable with the basics. Let’s look at some more advanced features of <code>kubectl</code> now, including some tips and tricks that may be new to you.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shell Aliases" data-type="sect2"><div class="sect2" id="shellaliases">&#13;
<h2>Shell Aliases</h2>&#13;
&#13;
<p><a data-primary="aliases" data-type="indexterm" id="idm45979386847744"/><a data-primary="kubectl" data-secondary="shell aliases" data-type="indexterm" id="idm45979386847040"/>One of the first things that most Kubernetes users do to make their lives easier is to create a shell alias for the <code>kubectl</code> command. For example, we have the following alias set up in our <em>.bash_profile</em> or <em>.zshrc</em> files:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nb">alias</code><code> </code><code class="nv">k</code><code class="o">=</code><em><code>kubectl</code></em></pre>&#13;
&#13;
<p>Instead of having to type out <code>kubectl</code> in full for every command, we can just use <code>k</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">k get pods</code></strong></pre>&#13;
&#13;
<p>If there are some <code>kubectl</code> commands that you use a lot, you might like to create aliases for them too. Here are some possible examples:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nb">alias</code><code> </code><code class="nv">kg</code><code class="o">=</code><em><code>kubectl</code><code> </code><code>get</code></em><code>&#13;
</code><code class="nb">alias</code><code> </code><code class="nv">kgdep</code><code class="o">=</code><em><code>kubectl</code><code> </code><code>get</code><code> </code><code>deployment</code></em><code>&#13;
</code><code class="nb">alias</code><code> </code><code class="nv">ksys</code><code class="o">=</code><em><code>kubectl</code><code> </code><code>--namespace</code><code class="o">=</code><code>kube-system</code></em><code>&#13;
</code><code class="nb">alias</code><code> </code><code class="nv">kd</code><code class="o">=</code><em><code>kubectl</code><code> </code><code>describe</code></em></pre>&#13;
&#13;
<p>Google engineer Ahmet Alp Balkan has worked out a logical <a href="https://oreil.ly/KoGV0">system of aliases</a> like these, and created a script to generate them all for you (currently around eight hundred aliases).</p>&#13;
&#13;
<p>You don’t have to use those, though; we suggest you start with <code>k</code>, and add aliases that are memorable to you, for the commands you use most frequently.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Short Flags" data-type="sect2"><div class="sect2" id="shortflags">&#13;
<h2>Using Short Flags</h2>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="abbreviated flags" data-type="indexterm" id="idm45979386770976"/>Like most command-line tools, <code>kubectl</code> supports abbreviated forms of many of its flags and switches. This can save you a lot of typing.</p>&#13;
&#13;
<p>For example, you can abbreviate the <code>--namespace</code> flag to just <code>-n</code> (see <a data-type="xref" href="ch05.html#namespaces">“Using Namespaces”</a>):</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods -n kube-system</code></strong></pre>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="--selector" data-type="indexterm" id="idm45979386743024"/>It’s very common to have <code>kubectl</code> operate on resources matching a set of labels, with the <code>--selector</code> flag (see <a data-type="xref" href="ch09.html#labels">“Labels”</a>). Fortunately, this can be shortened to <code>-l</code> (<code>labels</code>):</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods -l "environment=staging"</code></strong></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Abbreviating Resource Types" data-type="sect2"><div class="sect2" id="idm45979386735792">&#13;
<h2>Abbreviating Resource Types</h2>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="abbreviated resource types" data-type="indexterm" id="idm45979386716960"/>A common use for <code>kubectl</code> is to list resources of various types, such as Pods, Deployments, Services, and namespaces. The usual way to do this is to use <code>kubectl get</code> followed by, for example, <code>deployments</code>.</p>&#13;
&#13;
<p>To speed this up, <code>kubectl</code> supports short forms of these resource types:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get po</code></strong><code class="go">&#13;
</code><strong><code class="go">kubectl get deploy</code></strong><code class="go">&#13;
</code><strong><code class="go">kubectl get svc</code></strong><code class="go">&#13;
</code><strong><code class="go">kubectl get ns</code></strong></pre>&#13;
&#13;
<p>Other useful abbreviations include <code>no</code> for <code>nodes</code>, <code>cm</code> for <code>configmaps</code>, <code>sa</code> for <span class="keep-together"><code>serviceaccounts</code></span>, <code>ds</code> for <code>daemonsets</code>, and <code>pv</code> for <code>persistentvolumes</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Auto-Completing kubectl Commands" data-type="sect2"><div class="sect2" id="idm45979386688880">&#13;
<h2>Auto-Completing kubectl Commands</h2>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="auto-completion" data-type="indexterm" id="idm45979386682768"/><a data-primary="kubectl" data-secondary="flags" data-tertiary="-h" data-type="indexterm" id="idm45979386681792"/>If you’re using the <code>bash</code> or <code>zsh</code> shells, you can have them auto-complete <code>kubectl</code> commands. Run this command to see instructions on how to enable auto-completion for your shell:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl completion -h</code></strong></pre>&#13;
&#13;
<p>Follow the instructions, and you should be able to press Tab to complete partial <code>kubectl</code> commands. Try it now:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl cl&lt;TAB&gt;</code></strong></pre>&#13;
&#13;
<p>The command should complete to <code>kubectl cluster-info</code>.</p>&#13;
&#13;
<p>If you type just <code>kubectl</code> and hit Tab twice, you’ll see all the commands available:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl &lt;TAB&gt;&lt;TAB&gt;</code></strong><code class="go">&#13;
</code><code class="go">alpha           attach          cluster-info    cordon          describe   ...</code></pre>&#13;
&#13;
<p>You can use the same technique to list all the flags that you can use with the current command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods --&lt;TAB&gt;&lt;TAB&gt;</code></strong><code class="go">&#13;
</code><code class="go">--all-namespaces   --cluster=   --label-columns=   ...</code></pre>&#13;
&#13;
<p>Usefully, <code>kubectl</code> will also auto-complete the names of Pods, Deployments, namespaces, and so on:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl -n kube-system describe pod &lt;TAB&gt;&lt;TAB&gt;</code></strong><code class="go">&#13;
</code><code class="go">event-exporter-v0.1.9-85bb4fd64d-2zjng&#13;
</code><code class="go">kube-dns-autoscaler-79b4b844b9-2wglc&#13;
</code><code class="go">fluentd-gcp-scaler-7c5db745fc-h7ntr&#13;
</code><code class="go">...</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Help" data-type="sect2"><div class="sect2" id="idm45979386683712">&#13;
<h2>Getting Help</h2>&#13;
&#13;
<p>The best command-line tools include thorough documentation, and <code>kubectl</code> is no exception. You can get a complete overview of the available commands with <code>kubectl -h</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl -h</code></strong></pre>&#13;
&#13;
<p>You can go further and get detailed documentation on each command, with all the available options, and a set of examples, by typing <code>kubectl COMMAND -h</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get -h</code></strong></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Help on Kubernetes Resources" data-type="sect2"><div class="sect2" id="idm45979386524368">&#13;
<h2>Getting Help on Kubernetes Resources</h2>&#13;
&#13;
<p>As well as documenting itself, <code>kubectl</code> can also give you help on Kubernetes objects, such as Deployments or Pods. <a data-primary="kubectl" data-secondary="commands" data-tertiary="explain" data-type="indexterm" id="idm45979386506256"/>The <code>kubectl explain</code> command will show documentation on the specified type of resource:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl explain pods</code></strong></pre>&#13;
&#13;
<p>You can get further information on a specific field of a resource, with <code>kubectl explain RESOURCE.FIELD</code>. In fact, you can drill down as far as you like with <code>explain</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl explain deploy.spec.template.spec.containers.livenessProbe.exec</code></strong></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Showing More Detailed Output" data-type="sect2"><div class="sect2" id="idm45979386463872">&#13;
<h2>Showing More Detailed Output</h2>&#13;
&#13;
<p>You already know that <code>kubectl get</code> will list resources of various types, such as Pods:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods</code></strong><code class="go">&#13;
</code><code class="go">NAME                    READY     STATUS    RESTARTS   AGE&#13;
</code><code class="go">demo-54f4458547-pqdxn   1/1       Running   6          5d</code></pre>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="-o wide" data-type="indexterm" id="idm45979386442896"/>You can see extra information, such as the node each Pod is running on, by using the <code>-o wide</code> flag:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods -o wide</code></strong><code class="go">&#13;
</code><code class="go">NAME                    ... IP           NODE&#13;
</code><code class="go">demo-54f4458547-pqdxn   ... 10.76.1.88   gke-k8s-cluster-1-n1-standard...</code></pre>&#13;
&#13;
<p>(We’ve omitted the information that you see without <code>-o wide</code>, just for reasons of space.)</p>&#13;
&#13;
<p>Depending on the resource type, <code>-o wide</code> will show you different information. For example, with nodes:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get nodes -o wide</code></strong><code class="go">&#13;
</code><code class="go">NAME       STATUS   ROLES          AGE   VERSION   INTERNAL-IP...&#13;
</code><code class="go">minikube   Ready    control-plane  40d   v1.21.2   192.168.49.2...</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Working with JSON Data and jq" data-type="sect2"><div class="sect2" id="idm45979386390272">&#13;
<h2>Working with JSON Data and jq</h2>&#13;
&#13;
<p><a data-primary="jq" data-type="indexterm" id="idm45979386388960"/><a data-primary="JSON" data-type="indexterm" id="idm45979386388288"/><a data-primary="kubectl" data-secondary="flags" data-tertiary="-o json" data-type="indexterm" id="idm45979386387616"/>The default output format for <code>kubectl get</code> is plain text, but it can also print information in JSON format:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods -n kube-system -o json</code></strong><code class="go">&#13;
</code><code class="go">{&#13;
</code><code class="go">    "apiVersion": "v1",&#13;
</code><code class="go">    "items": [&#13;
</code><code class="go">        {&#13;
</code><code class="go">            "apiVersion": "v1",&#13;
</code><code class="go">            "kind": "Pod",&#13;
</code><code class="go">            "metadata": {&#13;
</code><code class="go">                "creationTimestamp": "2021-07-16T03:07:53Z",&#13;
</code><code class="go">                ...</code></pre>&#13;
&#13;
<p>Not surprisingly, this produces a lot of output (about five thousand lines on our cluster). Fortunately, because the output is in the widely used JSON format, you can use other tools to filter it, such as the invaluable <code>jq</code>.</p>&#13;
&#13;
<p>If you don’t have <a href="https://stedolan.github.io/jq"><code>jq</code></a> already, you can  <a href="https://stedolan.github.io/jq/download">install it</a> in the usual way for your system (<code>brew install jq</code> for macOS, <code>apt install jq</code> for Debian/Ubuntu, and so on).</p>&#13;
&#13;
<p>Once you’ve got <code>jq</code> installed, you can use it to query and filter <code>kubectl output</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods -n kube-system -o json | jq '.items[].metadata.name'</code></strong><code class="go">&#13;
</code><code class="go">"coredns-558bd4d5db-2m5tv"&#13;
</code><code class="go">"etcd-minikube"&#13;
</code><code class="go">"kube-apiserver-minikube"&#13;
</code><code class="go">"kube-controller-manager-minikube"&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
<p><code>jq</code> is a very powerful tool for querying and transforming JSON data.</p>&#13;
&#13;
<p>For example, to list your busiest nodes by the number of Pods running on each:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods -o json --all-namespaces | jq '.items |&#13;
</code><code class="go">  group_by(.spec.nodeName) | map({"nodeName": .[0].spec.nodeName,&#13;
</code><code class="go">  "count": length}) | sort_by(.count) | reverse'</code></strong></pre>&#13;
&#13;
<p>There’s a handy <a href="https://jqplay.org">online playground</a> for <code>jq</code> where you can paste in JSON data and try out different <code>jq</code> queries to get the exact result you want.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="-o jsonpath" data-type="indexterm" id="idm45979386296480"/>If you don’t have access to <code>jq</code>, <code>kubectl</code> also supports <a href="https://oreil.ly/s7xIv">JSONPath queries</a>. JSONPath is a JSON query language that isn’t quite as powerful as <code>jq</code>, but useful for quick one-liners:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>kubectl get pods -o=jsonpath=<em>{.items[0].metadata.name}</em></strong>&#13;
demo-66ddf956b9-pnknx</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Watching Objects" data-type="sect2"><div class="sect2" id="idm45979386389680">&#13;
<h2>Watching Objects</h2>&#13;
&#13;
<p>When you’re waiting for a bunch of Pods to start up, it can be annoying to have to keep typing <code>kubectl get pods...</code> every few seconds to see if anything’s happened.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="--watch" data-type="indexterm" id="idm45979386272688"/><code>kubectl</code> provides the <code>--watch</code> flag (<code>-w</code> for short) to save you having to do this. For example:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods --watch</code></strong><code class="go">&#13;
</code><code class="go">NAME                      READY     STATUS           RESTARTS   AGE&#13;
</code><code class="go">demo-95444875c-z9xv4   0/1       ContainerCreating   0          1s&#13;
</code><code class="go">... [time passes] ...&#13;
</code><code class="go">demo-95444875c-z9xv4   0/1       Completed           0          2s&#13;
</code><code class="go">demo-95444875c-z9xv4   1/1       Running             0          2s</code></pre>&#13;
&#13;
<p>Every time the status of one of the matching Pods changes, you’ll see an update in your terminal. (See <a data-type="xref" href="#kubespy">“Watching Kubernetes Resources with kubespy”</a> for a neat way to watch any kind of resource.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Describing Objects" data-type="sect2"><div class="sect2" id="idm45979386258096">&#13;
<h2>Describing Objects</h2>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="describe" data-type="indexterm" id="idm45979386257024"/>For really detailed information about Kubernetes objects, you can use the <code>kubectl describe</code> command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl describe pods demo-d94cffc44-gvgzm</code></strong></pre>&#13;
&#13;
<p>The <code>Events</code> section can be particularly useful for troubleshooting containers that aren’t working properly, as it records each stage of the container’s life cycle, along with any errors that occurred.<a data-startref="ix_07-tools-adoc1" data-type="indexterm" id="idm45979386656720"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Working with Resources" data-type="sect1"><div class="sect1" id="idm45979386853536">&#13;
<h1>Working with Resources</h1>&#13;
&#13;
<p><a data-primary="resources" data-secondary="tools and utilities for" data-type="indexterm" id="ix_07-tools-adoc2"/><a data-primary="tools and utilities" data-secondary="working with Resources" data-type="indexterm" id="ix_07-tools-adoc3"/>So far, you’ve used <code>kubectl</code> mostly for querying or listing things, as well as applying declarative YAML manifests with <code>kubectl apply</code>. However, <code>kubectl</code> also has a complete set of <em>imperative</em> commands: operations that create or modify resources directly.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Imperative kubectl Commands" data-type="sect2"><div class="sect2" id="idm45979386227280">&#13;
<h2>Imperative kubectl Commands</h2>&#13;
&#13;
<p>We showed one example of this in <a data-type="xref" href="ch02.html#runningdemo">“Running the Demo App”</a>, using the <code>kubectl run</code> command, which implicitly creates a Pod to run the specified container.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="create" data-type="indexterm" id="idm45979386207280"/>You can also explicitly create most resources using <code>kubectl create</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl create namespace my-new-namespace</code></strong><code class="go">&#13;
</code><code class="go">namespace "my-new-namespace" created</code></pre>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="delete" data-type="indexterm" id="idm45979386201760"/>Similarly, <code>kubectl delete</code> will delete a resource:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl delete namespace my-new-namespace</code></strong><code class="go">&#13;
</code><code class="go">namespace "my-new-namespace" deleted</code></pre>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="edit" data-type="indexterm" id="idm45979386175072"/>The <code>kubectl edit</code> command gives you the power to view and modify any resource:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl edit deployments my-deployment</code></strong></pre>&#13;
&#13;
<p>This will open your default editor with a YAML manifest file representing the specified resource.</p>&#13;
&#13;
<p>This is a good way to get a detailed look at the configuration of any resource, but you can also make any changes you like in the editor. When you save the file and quit the editor, <code>kubectl</code> will update the resource, exactly as though you had run <code>kubectl apply</code> on the manifest file for the resource.</p>&#13;
&#13;
<p>If you introduced any errors, such as invalid YAML, <code>kubectl</code> will tell you and reopen the file for you to fix the problem.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When Not to Use Imperative Commands" data-type="sect2"><div class="sect2" id="dontuseimperative">&#13;
<h2>When Not to Use Imperative Commands</h2>&#13;
&#13;
<p>Throughout this book we’ve emphasized the importance of using <em>declarative</em> infrastructure as code. So it shouldn’t come as a surprise that we don’t recommend you use imperative <code>kubectl</code> commands.</p>&#13;
&#13;
<p>Although they can be very useful for quickly testing things or trying out ideas, the major problem with imperative commands is that you have no single <em>source of truth</em>. There’s no way to know who ran what imperative commands on the cluster at what time, and what the effect was. As soon as you run any imperative command, the state of the cluster becomes out of sync with the manifest files stored in version control.</p>&#13;
&#13;
<p>The next time someone applies the YAML manifests, whatever changes you made imperatively will be overwritten and lost. This can lead to surprising results, and potentially adverse effects on critical services:</p>&#13;
<blockquote>Alice is on-call, when suddenly there is a large increase in load on the service she is managing. Alice uses the <code>kubectl scale</code> command to increase the number of replicas from 5 to 10. Several days later, Bob edits the YAML manifests in version control to use a new container image, but he doesn’t notice that the number of replicas in the file is currently 5, not the 10 that are active in production. Bob proceeds with the rollout, which cuts the number of replicas by half, causing an immediate overload or outage.&#13;
<p data-type="attribution">Kelsey Hightower et al., <cite><em>Kubernetes Up &amp; Running</em></cite></p>&#13;
</blockquote>&#13;
&#13;
<p>Alice forgot to update the files in version control after she made her imperative change, but that’s easy to do, especially under the stress of an incident (see <a data-type="xref" href="ch16.html#on-call">“On-Call Should Not Be Hell”</a>). Real life doesn’t always follow best practices.</p>&#13;
&#13;
<p>Similarly, before reapplying the manifest files, Bob should have checked the diff using <code>kubectl diff</code> (see <a data-type="xref" href="#diffing">“Diffing Resources”</a>) to see what would change. But if you’re not expecting something to be different, it’s easy to overlook it. And maybe Bob hasn’t read this book.</p>&#13;
&#13;
<p>The best way to avoid this kind of problem is to always make changes by editing and applying the resource files under version control. We will cover this more in <a data-type="xref" href="ch14.html#gitops">“GitOps”</a> later on.</p>&#13;
<div data-type="tip"><h1>Best Practice</h1>&#13;
<p>Don’t use <code>kubectl</code> imperative commands such as <code>create</code> or <code>edit</code> on production clusters. Instead, always manage resources with version-controlled YAML manifests, applied with <code>kubectl apply</code> (or Helm charts).</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generating Resource Manifests" data-type="sect2"><div class="sect2" id="idm45979386147536">&#13;
<h2>Generating Resource Manifests</h2>&#13;
&#13;
<p>Even though we don’t recommend using <code>kubectl</code> in imperative mode to make changes to your cluster, imperative commands can be a great time-saver when creating Kubernetes YAML files from scratch.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="-o yaml" data-type="indexterm" id="idm45979386117392"/>Rather than typing a lot of boilerplate into an empty file, you can use <code>kubectl</code> to give you a head start by generating the YAML manifest for you:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl create deployment  demo --image=cloudnatived/demo:hello</code></strong><code class="go">&#13;
</code><strong><code class="go">--dry-run=client -o yaml</code></strong><code class="go">&#13;
</code><code class="go">    </code><strong><code class="go">&gt;deployment.yaml</code></strong></pre>&#13;
&#13;
<p>The <code>--dry-run=client</code> flag tells <code>kubectl</code> not to actually create the resource, but merely to print out what it would have created. The <code>-o yaml</code> flag gives you the resource manifest in YAML format. The <code>&gt;</code> character writes the output of the command to a file that you can then use to make any edits, and finally apply it to create the resource in the cluster.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exporting Resources" data-type="sect2"><div class="sect2" id="exportflag">&#13;
<h2>Exporting Resources</h2>&#13;
&#13;
<p>As well as helping you create new resource manifests, <code>kubectl</code> can also produce manifest files for resources that already exist in the cluster. For example, maybe you created a Deployment using imperative commands (<code>kubectl create</code>), edited and adjusted it to get the settings just right, and now you want to write a declarative YAML manifest for it that you can add to version control.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="-o" data-type="indexterm" id="idm45979386099328"/>To do this, use the <code>-o</code> flag with <code>kubectl get</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl create deployment newdemo --image=cloudnatived/demo:hello</code></strong><code class="go">&#13;
</code><code class="go">deployment.apps/newdemo created&#13;
</code><strong><code class="go">kubectl get deployments newdemo -o yaml &gt;deployment.yaml</code></strong></pre>&#13;
&#13;
<p>This output will contain some extra information, like the <code>status</code> section that you can remove (before saving with your other manifests), update, and apply with <code>kubectl apply -f</code>.</p>&#13;
&#13;
<p>If you’ve been using imperative <code>kubectl</code> commands to manage your cluster up to now, and you’d like to switch to the declarative style that we recommend in this book, this is a great way to do it. Export all the resources in your cluster to manifest files using <code>kubectl</code> with the <code>-o</code> flag, as shown in the example, and you’ll be all set.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Diffing Resources" data-type="sect2"><div class="sect2" id="diffing">&#13;
<h2>Diffing Resources</h2>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="diff" data-type="indexterm" id="idm45979386071328"/>Before you apply Kubernetes manifests using <code>kubectl apply</code>, it’s very useful to be able to see exactly what would change on the cluster. The <code>kubectl diff</code> command will do this for you:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl diff -f deployment.yaml</code></strong><code class="go">&#13;
</code><code class="go">-  replicas: 10&#13;
</code><code class="go">+  replicas: 5</code></pre>&#13;
&#13;
<p>You can use this <code>diff</code> output to check whether the changes you made will actually have the effect you expected. Also, it will warn you if the state of the live resource is out of sync with the YAML manifest, perhaps because someone edited it imperatively since you last applied it.</p>&#13;
<div data-type="tip"><h1>Best Practice</h1>&#13;
<p>Use <code>kubectl diff</code> to check what would change before applying any updates to your production cluster.<a data-startref="ix_07-tools-adoc3" data-type="indexterm" id="idm45979386042944"/><a data-startref="ix_07-tools-adoc2" data-type="indexterm" id="idm45979386042240"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Working with Containers" data-type="sect1"><div class="sect1" id="idm45979386041312">&#13;
<h1>Working with Containers</h1>&#13;
&#13;
<p><a data-primary="containers" data-secondary="tools and utilities for" data-type="indexterm" id="ix_07-tools-adoc4"/><a data-primary="tools and utilities" data-secondary="working with containers" data-type="indexterm" id="ix_07-tools-adoc5"/>Most of what goes on in a Kubernetes cluster happens inside containers, so when things go wrong, it can be hard to see what’s happening. Here are a few useful ways to work with running containers using <code>kubectl</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Viewing a Container’s Logs" data-type="sect2"><div class="sect2" id="containerlogs">&#13;
<h2>Viewing a Container’s Logs</h2>&#13;
&#13;
<p><a data-primary="logs" data-secondary="viewing" data-type="indexterm" id="idm45979386015552"/>When you’re trying to get a container working and it’s not behaving as it should, one of the most useful sources of information is the container’s <em>logs</em>. In Kubernetes, logs are considered to be whatever a container writes to the <em>standard output</em> and <em>standard error</em> streams; if you were running the program in a terminal, these are what you would see printed in the terminal.</p>&#13;
&#13;
<p>In production applications, especially distributed ones, you’ll need to be able to aggregate logs from multiple services, store them in a persistent database, and query and graph them. This is a big topic, and one we’ll treat in much more detail in <a data-type="xref" href="ch15.html#observability">Chapter 15</a>.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="logs" data-type="indexterm" id="idm45979386011264"/>Inspecting the log messages from specific containers is still a very useful troubleshooting technique, though, and you can do this directly with <code>kubectl logs</code>, followed by the name of a Pod:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl logs -n kube-system --tail=20 kube-dns-autoscaler-69c5cbdcdd-94h7f</code></strong><code class="go">&#13;
</code><code class="go">autoscaler.go:49] Scaling Namespace: kube-system, Target: deployment/kube-dns&#13;
</code><code class="go">autoscaler_server.go:133] ConfigMap not found: configmaps "kube-dns-autoscaler"&#13;
</code><code class="go">k8sclient.go:117] Created ConfigMap kube-dns-autoscaler in namespace kube-system&#13;
</code><code class="go">plugin.go:50] Set control mode to linear&#13;
</code><code class="go">linear_controller.go:59] ConfigMap version change (old:  new: 526) - rebuilding</code></pre>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="--tail" data-type="indexterm" id="idm45979386002064"/>Most long-running containers will generate a <em>lot</em> of log output, so you’ll usually want to restrict it to just the most recent lines, using the <code>--tail</code> flag, as in this example. (The container logs will be shown with timestamps, but we’ve trimmed those here to fit the messages on the page.)</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="--follow" data-type="indexterm" id="idm45979385999664"/>To watch a container as it’s running, and stream its log output to your terminal, use the <code>--follow</code> flag (<code>-f</code> for short):</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl logs --namespace kube-system --tail=10 --follow etcd-docker-for-desktop</code></strong><code class="go">&#13;
</code><code class="go">etcdserver: starting server... [version: 3.1.12, cluster version: 3.1]&#13;
</code><code class="go">embed: ClientTLS: cert = /var/lib/localkube/certs/etcd/server.crt, key = ...&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
<p>As long as you leave the <code>kubectl logs</code> command running with the <code>--follow</code> flag, you’ll continue to see any new output from the Pod.</p>&#13;
&#13;
<p>It can be particularly useful to view the Kubernetes API server’s logs; for example, if you have RBAC permission errors (see <a data-type="xref" href="ch11.html#rbac">“Introducing Role-Based Access Control (RBAC)”</a>), they’ll show up here. If you have access to your control plane nodes, you can find the <code>kube-apiserver</code> Pod in the <code>kube-system</code> namespace and use <code>kubectl logs</code> to see its output.</p>&#13;
&#13;
<p>If you’re using a managed service, where the control plane nodes are not visible to you, check your provider’s documentation to see how to find the control plane logs.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><a data-primary="kubectl" data-secondary="flags" data-tertiary="--container" data-type="indexterm" id="idm45979385966448"/>When there are multiple containers in a Pod, you can specify which one you want to see the logs for using the <code>--container</code> flag (<code>-c</code> for short):</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl logs -n kube-system metrics-server</code></strong><code class="go">&#13;
</code><code class="go">    </code><strong><code class="go">-c metrics-server-nanny</code></strong><code class="go">&#13;
</code><code class="go">...</code></pre>&#13;
</div>&#13;
&#13;
<p>For more sophisticated log watching, you may want to use a dedicated tool like Stern instead (see <a data-type="xref" href="#stern">“Stern”</a>).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Attaching to a Container" data-type="sect2"><div class="sect2" id="idm45979386016704">&#13;
<h2>Attaching to a Container</h2>&#13;
&#13;
<p>When looking at the logs of a container isn’t enough, you might need to attach your local terminal to the container instead. <a data-primary="kubectl" data-secondary="commands" data-tertiary="attach" data-type="indexterm" id="idm45979385935472"/>This lets you see the container’s output directly. To do this, use <code>kubectl attach</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl attach demo-54f4458547-fcx2n</code></strong><code class="go">&#13;
</code><code class="go">Defaulting container name to demo.&#13;
</code><code class="go">Use </code><em><code class="go">kubectl describe pod/demo-54f4458547-fcx2n</code></em><code class="go"> to see all of the containers&#13;
</code><code class="go">in this pod.&#13;
</code><code class="go">If you don't see a command prompt, try pressing enter.</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Watching Kubernetes Resources with kubespy" data-type="sect2"><div class="sect2" id="kubespy">&#13;
<h2>Watching Kubernetes Resources with kubespy</h2>&#13;
&#13;
<p><a data-primary="kubespy" data-type="indexterm" id="idm45979385904448"/>When you deploy changes to your Kubernetes manifests, there’s often an anxious period of waiting to see what happens next.</p>&#13;
&#13;
<p>Often when you deploy an application, lots of things need to happen behind the scenes, as Kubernetes creates your resources, spins up Pods, and so on.</p>&#13;
&#13;
<p>Because this happens <em>automagically</em>, as engineers like to say, it can be difficult to tell what’s going on. <code>kubectl get</code> and <code>kubectl describe</code> can give you snapshots of individual resources, but what we’d really like is a way to see the state of Kubernetes resources changing in real time.</p>&#13;
&#13;
<p>Enter <a href="https://oreil.ly/YqyBk">kubespy</a>, a neat tool from the Pulumi project.<sup><a data-type="noteref" href="ch07.html#idm45979385899936" id="idm45979385899936-marker">1</a></sup> kubespy can watch an individual resource in the cluster and show you what’s happening to it over time.</p>&#13;
&#13;
<p>For example, if you point kubespy at a Service resource, it will show you when the Service is created, when it’s allocated an IP address, when its endpoints are connected, and so on.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Forwarding a Container Port" data-type="sect2"><div class="sect2" id="idm45979385877328">&#13;
<h2>Forwarding a Container Port</h2>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="port-forward" data-type="indexterm" id="idm45979385876160"/>We’ve used <code>kubectl port-forward</code> before, in <a data-type="xref" href="ch02.html#runningdemo">“Running the Demo App”</a>, to forward a Kubernetes Service to a port on your local machine. But you can also use it to forward a container port, if you want to connect directly to a specific Pod. Just specify the Pod name and the local and remote ports:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl port-forward demo-54f4458547-vm88z 9999:8888</code></strong><code class="go">&#13;
</code><code class="go">Forwarding from 127.0.0.1:9999 -&gt; 8888&#13;
</code><code class="go">Forwarding from [::1]:9999 -&gt; 8888</code></pre>&#13;
&#13;
<p>Now port 9999 on your local machine will be forwarded to port 8888 on the container, and you can connect to it with a web browser, for example.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Executing Commands on Containers" data-type="sect2"><div class="sect2" id="idm45979385868368">&#13;
<h2>Executing Commands on Containers</h2>&#13;
&#13;
<p>The isolated nature of containers is great when you want to run reliable, secure workloads. But it can be a little inconvenient when something’s not working right, and you can’t see why.</p>&#13;
&#13;
<p>When you’re running a program on your local machine and it misbehaves, you have the power of the command line at your disposal to troubleshoot it: you can look at the running processes with <code>ps</code>, list and display files with <code>ls</code> and <code>cat</code>, and even edit the files directly with a text editor.</p>&#13;
&#13;
<p>Very often, with a malfunctioning container, it would be useful to have a shell running in the container so that we can do this kind of interactive debugging.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="exec" data-type="indexterm" id="idm45979385864720"/>Using the <code>kubectl exec</code> command, you can run a specified command in any container, including a shell:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl run alpine --image alpine --command -- sleep 999</code></strong><code class="go">&#13;
</code><code class="go">pod/alpine created&#13;
</code><code class="go">&#13;
</code><strong><code class="go">kubectl get pods</code></strong><code class="go">&#13;
</code><code class="go">NAME     READY   STATUS    RESTARTS   AGE&#13;
</code><code class="go">alpine   1/1     Running   0          39s&#13;
</code><code class="go">&#13;
</code><strong><code class="go">kubectl exec -it alpine -- /bin/sh</code></strong><code class="go">&#13;
</code><code class="go">/ # </code><strong><code class="go">ps</code></strong><code class="go">&#13;
</code><code class="go">PID   USER       TIME COMMAND&#13;
</code><code class="go">    1 root       0:00 sleep 999&#13;
</code><code class="go">    7 root       0:00 /bin/sh&#13;
</code><code class="go">   11 root       0:00 ps</code></pre>&#13;
&#13;
<p>If the Pod has more than one container in it, <code>kubectl exec</code> will run the command in the first container by default. Alternatively, you can specify the container with the <code>-c</code> flag:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl exec -it -c container2 POD_NAME -- /bin/sh</code></strong></pre>&#13;
&#13;
<p>(If the container doesn’t have a shell, see <a data-type="xref" href="#addingbusybox">“Adding BusyBox to Your Containers”</a>.)</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running Containers for Troubleshooting" data-type="sect2"><div class="sect2" id="runningcxrs">&#13;
<h2>Running Containers for Troubleshooting</h2>&#13;
&#13;
<p>In addition to running commands on an existing container, sometimes it’s handy to be able to run commands like <code>wget</code> or <code>nslookup</code> in the cluster, to see the results that your application would get. You’ve already learned how to run containers in the cluster with <code>kubectl run</code>, but here are a few useful examples of running one-off container commands for debugging purposes.</p>&#13;
&#13;
<p>First, let’s run an instance of the demo application to test against:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl run demo --image cloudnatived/demo:hello --expose --port 8888</code></strong><code class="go">&#13;
</code><code class="go">service/demo created&#13;
</code><code class="go">pod/demo created</code></pre>&#13;
&#13;
<p>The <code>demo</code> service should have been allocated an IP address and a DNS name of <code>demo</code> that is accessible from inside the cluster. Let’s check that, using the <code>nslookup</code> command running inside a container:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl run nslookup --image=busybox:1.28 --rm -it --restart=Never \&#13;
</code><code class="go">--command -- nslookup demo</code></strong><code class="go">&#13;
</code><code class="go">Server:    10.79.240.10&#13;
</code><code class="go">Address 1: 10.79.240.10 kube-dns.kube-system.svc.cluster.local&#13;
</code><code class="go">&#13;
</code><code class="go">Name:      demo&#13;
</code><code class="go">Address 1: 10.79.242.119 demo.default.svc.cluster.local</code></pre>&#13;
&#13;
<p>Good news: the DNS name works, so we should be able to make an HTTP request to it using <code>wget</code> and see the result:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl run wget --image=busybox:1.28 --rm -it --restart=Never \&#13;
</code><code class="go">--command -- wget -qO- http://demo:8888</code></strong><code class="go">&#13;
</code><code class="go">Hello, 世界&#13;
</code><code class="go">pod "wget" deleted</code></pre>&#13;
&#13;
<p>You can see that this pattern of <code>kubectl run</code> commands uses a common set of flags:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="go">kubectl run NAME --image=IMAGE </code><strong><code class="go">--rm -it --restart=Never --command -- ...</code></strong></pre>&#13;
&#13;
<p>What do these do?</p>&#13;
<dl>&#13;
<dt><a data-primary="kubectl" data-secondary="flags" data-tertiary="--rm" data-type="indexterm" id="idm45979385689888"/><code>--rm</code></dt>&#13;
<dd>&#13;
<p>This tells Kubernetes to delete the resources created in this command for attached containers so that it doesn’t clutter up your nodes’ local storage.</p>&#13;
</dd>&#13;
<dt><a data-primary="kubectl" data-secondary="flags" data-tertiary="-it" data-type="indexterm" id="idm45979385687344"/><code>-it</code></dt>&#13;
<dd>&#13;
<p>This runs the container interactively (<code>i</code>), via a terminal (<code>t</code>), so that you see the output from the container in your own terminal, and can send keystrokes to it if you need to.</p>&#13;
</dd>&#13;
<dt><a data-primary="kubectl" data-secondary="flags" data-tertiary="--restart" data-type="indexterm" id="idm45979385683696"/><code>--restart=Never</code></dt>&#13;
<dd>&#13;
<p>This tells Kubernetes to skip its usual helpful behavior of restarting a container whenever it exits. Since we only want to run the container one time, we can disable the default restart policy.</p>&#13;
</dd>&#13;
<dt><a data-primary="kubectl" data-secondary="flags" data-tertiary="--command" data-type="indexterm" id="idm45979385667728"/><code>--command --</code></dt>&#13;
<dd>&#13;
<p>This specifies a command to run, instead of the container’s default entrypoint. Everything following the <code>--</code> will be passed to the container as a command line, complete with arguments.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using BusyBox Commands" data-type="sect2"><div class="sect2" id="idm45979385793968">&#13;
<h2>Using BusyBox Commands</h2>&#13;
&#13;
<p><a data-primary="BusyBox" data-type="indexterm" id="idm45979385663376"/>Although you can run any container available to you, the <code>busybox</code> image is particularly useful because it contains a wealth of the most commonly used Unix commands, such as <code>cat</code>, <code>echo</code>, <code>find</code>, <code>grep</code>, and <code>kill</code>. You can see a complete list of <a href="https://oreil.ly/KiiEE">BusyBox commands</a> on their website.</p>&#13;
&#13;
<p>BusyBox also includes a lightweight bash-like shell, called <code>ash</code>, which is compatible with standard <code>/bin/sh</code> shell scripts. So to get an interactive shell in your cluster, you can run:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl run busybox --image=busybox:1.28 --rm -it --restart=Never /bin/sh</code></strong></pre>&#13;
&#13;
<p><a data-primary="aliases" data-type="indexterm" id="idm45979385655216"/>Because the pattern for running commands from the BusyBox image is always the same, you could even make a shell alias for it (see <a data-type="xref" href="#shellaliases">“Shell Aliases”</a>):</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>alias bb=<em>kubectl run busybox --image=busybox:1.28 --rm -it --restart=Never&#13;
    --command --</em></strong>&#13;
<strong>bb nslookup demo</strong>&#13;
...&#13;
<strong>bb wget -qO- http://demo:8888</strong>&#13;
...&#13;
<strong>bb sh</strong>&#13;
If you don't see a command prompt, try pressing enter.&#13;
/ #</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding BusyBox to Your Containers" data-type="sect2"><div class="sect2" id="addingbusybox">&#13;
<h2>Adding BusyBox to Your Containers</h2>&#13;
&#13;
<p>If your container already has a shell in it (for example, if it’s built from a Linux base image, such as <code>alpine</code>), then you can get shell access on the container by running:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>kubectl exec -it <em>POD_NAME</em>-- /bin/sh</strong></pre>&#13;
&#13;
<p>But what if there’s no <em>/bin/sh</em> in the container? For example, if you’re using a minimal, scratch image as described in <a data-type="xref" href="ch02.html#multistagedockerfile">“Understanding Dockerfiles”</a>.</p>&#13;
&#13;
<p>The simplest way to make your containers easily debuggable, while keeping the images very small, is to copy the <code>busybox</code> executable into them at build time. It’s only 1 MiB, which is a small price to pay for having a usable shell and a set of Unix utilities.</p>&#13;
&#13;
<p>You learned in the earlier discussion of multistage builds that you can copy a file from a previously built container into a new container using the Dockerfile <code>COPY --from</code> command. A lesser-known feature of this command is that you can also copy a file from any public image, not just one that you built locally.</p>&#13;
&#13;
<p>The following Dockerfile shows how to do this with the demo image:</p>&#13;
&#13;
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">golang:1.17-alpine</code><code class="w"> </code><code class="k">AS</code><code class="w"> </code><code class="s">build</code><code>&#13;
</code><code>&#13;
</code><code class="k">WORKDIR</code><code class="w"> </code><code class="s">/src/</code><code>&#13;
</code><code class="k">COPY</code><code class="w"> </code><code>main.go</code><code> </code><code>go.*</code><code> </code><code>/src/</code><code>&#13;
</code><code class="k">RUN</code><code class="w"> </code><code class="nv">CGO_ENABLED</code><code class="o">=</code><code class="m">0</code><code> </code><code>go</code><code> </code><code>build</code><code> </code><code>-o</code><code> </code><code>/bin/demo</code><code>&#13;
</code><code>&#13;
</code><code class="k">FROM</code><code class="w"> </code><code class="s">scratch</code><code>&#13;
</code><code class="k">COPY</code><code class="w"> </code><code>--from</code><code class="o">=</code><code>build</code><code> </code><code>/bin/demo</code><code> </code><code>/bin/demo</code><code>&#13;
</code><strong><code class="k">COPY</code><code class="w"> </code><code>--from</code><code class="o">=</code><code>busybox:1.28</code><code> </code><code>/bin/busybox</code><code> </code><code>/bin/busybox</code></strong><code>&#13;
</code><code class="k">ENTRYPOINT</code><code class="w"> </code><code class="p">[</code><code class="s2">"/bin/demo"</code><code class="p">]</code></pre>&#13;
&#13;
<p>Here, the <code>--from=busybox:1.28</code> references the public BusyBox library image.<sup><a data-type="noteref" href="ch07.html#idm45979385568432" id="idm45979385568432-marker">2</a></sup> You could copy a file from any image you like (such as <code>alpine</code>, for example).</p>&#13;
&#13;
<p>Now you still have a very small container, but you can also get a shell on it, by running:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>kubectl exec -it <em>POD_NAME</em> -- /bin/busybox sh</strong></pre>&#13;
&#13;
<p>Instead of executing <code>/bin/sh</code> directly, you execute <code>/bin/busybox</code> followed by the name of the command you want; in this case, <code>sh</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing Programs on a Container" data-type="sect2"><div class="sect2" id="idm45979385650080">&#13;
<h2>Installing Programs on a Container</h2>&#13;
&#13;
<p>If you need some programs that aren’t included in BusyBox, or aren’t available in a public container image, you can run a Linux image such as <code>alpine</code> or <code>ubuntu</code> instead, and install whatever you need on it:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl run alpine --image alpine --rm -it --restart=Never /bin/sh</code></strong><code class="go">&#13;
</code><code class="go">If you don't see a command prompt, try pressing enter.&#13;
</code><code class="go">/ # </code><strong><code class="go">apk --update add emacs</code></strong></pre>&#13;
&#13;
<p>Keep in mind that these temporary debugging containers would likely need to run as the root user in order to install new packages, and, once the container exits, any changes inside the container would be lost. This process would only be for one-off troubleshooting sessions, not something you should rely on for long-running applications that you want to stick around on the cluster.<a data-startref="ix_07-tools-adoc5" data-type="indexterm" id="idm45979385537184"/><a data-startref="ix_07-tools-adoc4" data-type="indexterm" id="idm45979385536688"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Contexts and Namespaces" data-type="sect1"><div class="sect1" id="idm45979386040720">&#13;
<h1>Contexts and Namespaces</h1>&#13;
&#13;
<p><a data-primary="contexts" data-type="indexterm" id="ix_07-tools-adoc6"/><a data-primary="namespaces" data-secondary="tools and utilities for" data-type="indexterm" id="ix_07-tools-adoc7"/><a data-primary="tools and utilities" data-secondary="contexts and namespaces" data-type="indexterm" id="ix_07-tools-adoc8"/>So far in this book we’ve been working with a single Kubernetes cluster, and all the <code>kubectl</code> commands you’ve run have naturally applied to that cluster.</p>&#13;
&#13;
<p>So what happens when you have more than one cluster? For example, maybe you have a Kubernetes cluster on your machine for local testing and a production cluster in the cloud, and perhaps another remote cluster for staging and development. How does <code>kubectl</code> know which one you mean?</p>&#13;
&#13;
<p>To solve this problem, <code>kubectl</code> has <em>contexts</em>. A context is a combination of a cluster, a user, and a namespace (see <a data-type="xref" href="ch05.html#namespaces">“Using Namespaces”</a>).</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="contexts" data-type="indexterm" id="idm45979385507984"/>When you run <code>kubectl</code> commands, they’re always executed in the <em>current context</em>. Let’s look at an example:</p>&#13;
&#13;
<pre class="less_space pagebreak-before" data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl config get-contexts</code></strong><code class="go">&#13;
</code><code class="go">CURRENT   NAME                CLUSTER        AUTHINFO     NAMESPACE&#13;
</code><code class="go">          gke                 gke_test_us-w  gke_test_us  myapp&#13;
</code><code class="go">*         docker-for-desktop  docker-for-d   docker-for-d</code></pre>&#13;
&#13;
<p>These are the contexts <code>kubectl</code> currently knows about. Each context has a name, and refers to a particular cluster, a username that authenticates to the cluster, and a namespace within the cluster. The <code>docker-for-desktop</code> context, as you might expect, refers to my local Kubernetes cluster.</p>&#13;
&#13;
<p>The current context is shown with a <code>*</code> in the first column (in the example, it’s <code>docker-for-desktop</code>). <a data-primary="kubectl" data-secondary="commands" data-tertiary="cluster-info" data-type="indexterm" id="idm45979385494480"/>If I run a <code>kubectl</code> command now, it will operate on the Docker Desktop cluster, in the default namespace (because the <code>NAMESPACE</code> column is blank, indicating that the context refers to the default namespace):</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>kubectl cluster-info</strong>&#13;
Kubernetes control plane is running at <a href="https://192.168.49.2:8443"><em class="hyperlink">https://192.168.49.2:8443</em></a>&#13;
CoreDNS is running at <a href="https://192.168.49.2:8443/api/v1/namespaces/"><em class="hyperlink">https://192.168.49.2:8443/api/v1/namespaces/</em></a>...&#13;
&#13;
To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'.</pre>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="config" data-type="indexterm" id="idm45979385472016"/>You can switch to another context using the <code>kubectl config use-context</code> <span class="keep-together">command</span>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl config use-context gke</code></strong><code class="go">&#13;
</code><code class="go">Switched to context "gke".</code></pre>&#13;
&#13;
<p>You could think of contexts as being like bookmarks: they let you switch easily to a particular cluster and a particular namespace. To create a new context, use <code>kubectl config set-context</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl config set-context myapp --cluster=gke --namespace=myapp</code></strong><code class="go">&#13;
</code><code class="go">Context "myapp" created.</code></pre>&#13;
&#13;
<p>Now whenever you switch to the <code>myapp</code> context, your current context will be the <code>myapp</code> namespace on the Docker Desktop cluster.</p>&#13;
&#13;
<p>If you forget what your current context is, <code>kubectl config current-context</code> will tell you:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl config current-context</code></strong><code class="go">&#13;
</code><code class="go">myapp</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kubeconfig files" data-type="sect2"><div class="sect2" id="idm45979385432784">&#13;
<h2>kubeconfig files</h2>&#13;
&#13;
<p><a data-primary="kubeconfig files" data-type="indexterm" id="idm45979385431888"/>These contexts for different Kubernetes clusters are stored by default in a file (or multiple files) typically located at <em>~/.kube/config</em> on your machine. This can be customized using the <code>KUBECONFIG</code> environment variable if you wish to use a different path per the docs on managing kubeconfig files found <a href="https://oreil.ly/lZ0Lc">here</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kubectx and kubens" data-type="sect2"><div class="sect2" id="idm45979385412624">&#13;
<h2>kubectx and kubens</h2>&#13;
&#13;
<p><a data-primary="kubectx" data-type="indexterm" id="idm45979385410640"/><a data-primary="kubens" data-type="indexterm" id="idm45979385409936"/>If, like us, you type for a living, you probably don’t like typing any more keystrokes than you have to. For faster switching of <code>kubectl</code> contexts, you can use the <code>kubectx</code> and <code>kubens</code> tools. Follow the <a href="https://oreil.ly/CAGwf">instructions</a> on GitHub to install both <code>kubectx</code> and <code>kubens</code>.</p>&#13;
&#13;
<p>Now you can use the <code>kubectx</code> command to switch contexts:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectx docker-for-desktop</code></strong><code class="go">&#13;
</code><code class="go">Switched to context "docker-for-desktop".</code></pre>&#13;
&#13;
<p>One nice feature of <code>kubectx</code> is that <code>kubectx -</code> will switch to your previous context, so you can quickly toggle between two contexts:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectx -</code></strong><code class="go">&#13;
</code><code class="go">Switched to context "gke".&#13;
</code><strong><code class="go">kubectx -</code></strong><code class="go">&#13;
</code><code class="go">Switched to context "docker-for-desktop".</code></pre>&#13;
&#13;
<p>Just <code>kubectx</code> on its own will list all the contexts you have stored, with the current context highlighted.</p>&#13;
&#13;
<p>Switching namespaces is something you’ll probably do more often than switching contexts, so the <code>kubens</code> tool is ideal for this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubens</code></strong><code class="go">&#13;
</code><strong><code class="go">default</code></strong><code class="go">&#13;
</code><code class="go">kube-public&#13;
</code><code class="go">kube-system&#13;
</code><code class="go">&#13;
</code><strong><code class="go">kubens kube-system</code></strong><code class="go">&#13;
</code><code class="go">Context "docker-for-desktop" modified.&#13;
</code><code class="go">Active namespace is "kube-system".&#13;
</code><code class="go">&#13;
</code><strong><code class="go">kubens -</code></strong><code class="go">&#13;
</code><code class="go">Context "docker-for-desktop" modified.&#13;
</code><code class="go">Active namespace is "default".</code></pre>&#13;
&#13;
<p>You can also install these using the <a href="https://oreil.ly/JOhBN"><code>krew</code></a> package manager tool, which opens up an entire ecosystem of helpful plugins that make working with Kubernetes easier.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The <code>kubectx</code> and <code>kubens</code> tools do one thing well, and they’re very useful additions to your Kubernetes toolbox. <code>krew</code> makes it easy to install similar helper tools.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kube-ps1" data-type="sect2"><div class="sect2" id="idm45979385411968">&#13;
<h2>kube-ps1</h2>&#13;
&#13;
<p><a data-primary="kube-ps1" data-type="indexterm" id="idm45979385318112"/>If you use the <code>bash</code> or <code>zsh</code> shells, there’s a little <a href="https://oreil.ly/Pfgnm">utility</a> that will add the current Kubernetes context to your prompt.</p>&#13;
&#13;
<p>With <code>kube-ps1</code> installed, you can’t forget which context you’re in:<a data-startref="ix_07-tools-adoc8" data-type="indexterm" id="idm45979385292400"/><a data-startref="ix_07-tools-adoc7" data-type="indexterm" id="idm45979385291760"/><a data-startref="ix_07-tools-adoc6" data-type="indexterm" id="idm45979385291088"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">source "/usr/local/opt/kube-ps1/share/kube-ps1.sh"</code></strong><code class="go">&#13;
</code><strong><code class="go">PS1="[$(kube_ps1)]$ "</code></strong><code class="go">&#13;
</code><code class="go">[(⎈ |docker-for-desktop:default)]&#13;
</code><strong><code class="go">kubectx cloudnativedevops</code></strong><code class="go">&#13;
</code><code class="go">Switched to context "cloudnativedevops".&#13;
</code><code class="gp-VirtualEnv">(⎈ |cloudnativedevops:myapp)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes Shells and Tools" data-type="sect1"><div class="sect1" id="idm45979385535360">&#13;
<h1>Kubernetes Shells and Tools</h1>&#13;
&#13;
<p><a data-primary="tools and utilities" data-secondary="Kubernetes shells and tools" data-type="indexterm" id="ix_07-tools-adoc9"/>While using <code>kubectl</code> in an ordinary shell is perfectly sufficient for most things you’ll want to do with a Kubernetes cluster, there are other options.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kube-shell" data-type="sect2"><div class="sect2" id="idm45979385278128">&#13;
<h2>kube-shell</h2>&#13;
&#13;
<p><a data-primary="kube-shell" data-type="indexterm" id="idm45979385276928"/>If <code>kubectl</code> auto-completion isn’t fancy enough for you, there’s always <a href="https://oreil.ly/klA3D"><code>kube-shell</code></a>, a wrapper for <code>kubectl</code> that provides a pop-up menu of possible completions for each command (see <a data-type="xref" href="#img-kube-shell">Figure 7-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="img-kube-shell">&#13;
<img alt="Screenshot of kube-shell" src="assets/cnd2_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span><code>kube-shell</code> is an interactive Kubernetes client</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Click" data-type="sect2"><div class="sect2" id="idm45979385250064">&#13;
<h2>Click</h2>&#13;
&#13;
<p><a data-primary="Click" data-type="indexterm" id="idm45979385248864"/>A more sophisticated Kubernetes terminal experience is provided by <a href="https://oreil.ly/ilnpq"><em>Click</em></a>.</p>&#13;
&#13;
<p>Click is like an interactive version of <code>kubectl</code>, which <em>remembers</em> the current object you’re working with. For example, when you want to find and describe a Pod in <code>kubectl</code>, you usually have to list all the matching Pods first, then copy and paste the unique name of the Pod you’re interested in into a new command.</p>&#13;
&#13;
<p>Instead, with Click you can select any resource from a list by typing its number (for example, <code>1</code> for the first item). That’s now the current resource, and the next Click command will operate on that resource by default. To make finding the object you want easier, Click supports searching by regular expressions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="kubed-sh" data-type="sect2"><div class="sect2" id="idm45979385243808">&#13;
<h2>kubed-sh</h2>&#13;
&#13;
<p><a data-primary="kubed-sh" data-type="indexterm" id="idm45979385242608"/>While <code>kube-shell</code> and Click provide local shells that know a little about Kubernetes, <a href="https://kubed.sh"><code>kubed-sh</code></a> (pronounced <em>kube-dash</em>) is a more intriguing idea: a shell that runs, in some sense, <em>on</em> the cluster itself.</p>&#13;
&#13;
<p><code>kubed-sh</code> will pull and run the necessary containers to execute JavaScript, Ruby, or Python programs on your current cluster. You can create, for example, a Ruby script on your local machine, and use <code>kubed-sh</code> to execute the script as a Kubernetes Deployment.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stern" data-type="sect2"><div class="sect2" id="stern">&#13;
<h2>Stern</h2>&#13;
&#13;
<p><a data-primary="logs" data-secondary="viewing" data-type="indexterm" id="idm45979385236624"/><a data-primary="Stern" data-type="indexterm" id="idm45979385235648"/>While <code>kubectl logs</code> is a useful command (see <a data-type="xref" href="#containerlogs">“Viewing a Container’s Logs”</a>), it’s not as convenient as it could be. For example, before you can use it, you first have to find out the unique name of the Pod and container whose logs you want to see, and specify these on the command line, which generally means at least one copy and paste.</p>&#13;
&#13;
<p>Also, if you’re using <code>-f</code> to follow logs from a particular container, whenever the container is restarted, your log stream will stop. You’ll have to find out the new name of the container and run <code>kubectl logs</code> again to follow it. And you can only follow logs from one Pod at a time.</p>&#13;
&#13;
<p>A more sophisticated log-streaming tool would allow you to specify a group of Pods with a regular expression matching their names or labels, and it would be able to keep on streaming logs even if individual containers are restarted.</p>&#13;
&#13;
<p>Fortunately, that’s exactly what the <a href="https://oreil.ly/5fNnO">Stern</a> tool does. Stern tails the logs from all Pods matching a regular expression (for example <code>demo.*</code>). If there are multiple containers within the Pod, Stern will show you log messages from each, prefixed by its name.</p>&#13;
&#13;
<p>The <code>--since</code> flag lets you limit the output to recent messages (within the last 10 minutes, in the example).</p>&#13;
&#13;
<p>Instead of matching specific Pod names with a regular expression, you can use any Kubernetes label selector expression, just as with <code>kubectl</code>. Combined with the <code>--all-namespaces</code> flag, this is ideal for watching logs from multiple containers.<a data-startref="ix_07-tools-adoc9" data-type="indexterm" id="idm45979385227120"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubernetes IDEs" data-type="sect1"><div class="sect1" id="idm45979385226208">&#13;
<h1>Kubernetes IDEs</h1>&#13;
&#13;
<p><a data-primary="IDEs" data-type="indexterm" id="idm45979385225072"/>As you use Kubernetes more and more, you will quickly find that you need ways to efficiently find, view, and edit all of the YAML manifests involved. You will be jumping around between different applications across different namespaces and clusters. Your favorite text editor and <code>kubectl</code> may be all that you need, but there are also some great tools that are worth trying out that add nice features and visualizations for interacting with Kubernetes.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lens" data-type="sect2"><div class="sect2" id="lens">&#13;
<h2>Lens</h2>&#13;
&#13;
<p><a data-primary="Lens" data-type="indexterm" id="idm45979385222256"/><a href="https://oreil.ly/5JwOQ">Lens</a> is a GUI application that works like an advanced visualizer and IDE specifically made for interacting with Kubernetes clusters. You can use it as a dashboard explorer to see what is happening inside of your cluster. Lens makes it easy to jump between contexts and namespaces to get an overview of what is running and includes an integrated Terminal you can use for <code>kubectl</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="VS Code Kubernetes Extension" data-type="sect2"><div class="sect2" id="idm45979385220224">&#13;
<h2>VS Code Kubernetes Extension</h2>&#13;
&#13;
<p><a data-primary="VS Code" data-type="indexterm" id="idm45979385219024"/>VS Code is a popular text editor with a huge ecosystem of extensions for just about anything. Like Lens, you can use the <a href="https://oreil.ly/4sQU3">Kubernetes extension</a> as a dashboard tool for your cluster. It also includes special integration with Azure for creating AKS clusters and directly deploying applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building Your Own Kubernetes Tools" data-type="sect1"><div class="sect1" id="client-go">&#13;
<h1>Building Your Own Kubernetes Tools</h1>&#13;
&#13;
<p><a data-primary="tools and utilities" data-secondary="building your own" data-type="indexterm" id="idm45979385214848"/>Combined with query tools like <code>jq</code> and the standard set of Unix utilities (<code>cut</code>, <code>grep</code>, <code>xargs</code>, and friends), <code>kubectl</code> can be used for some fairly sophisticated scripting of Kubernetes resources. As we’ve seen in this chapter, there are also many third-party tools available that you can use as part of automated scripts.</p>&#13;
&#13;
<p>This approach has its limits, however. It’s fine to cook up ingenious one-liners and ad hoc shell scripts for interactive debugging and exploration, but they can be hard to understand and maintain.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="automation" data-type="indexterm" id="idm45979385210368"/>For real systems programs automating your production workflows, we strongly recommend you use a real systems programming language. <a data-primary="client-go" data-type="indexterm" id="idm45979385209120"/>Go is the logical choice, since it was good enough for the Kubernetes authors—and naturally, Kubernetes includes a <a href="https://oreil.ly/XYJYq">full-featured client library</a> for use in Go programs.</p>&#13;
&#13;
<p>Because the <code>client-go</code> library gives you complete access to the Kubernetes API, you can do anything with it that <code>kubectl</code> can do, and more. The following snippet shows how to list all the Pods in your cluster, for example:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="o">...</code><code class="w"/>&#13;
<code class="nx">podList</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">clientset</code><code class="p">.</code><code class="nx">CoreV1</code><code class="p">().</code><code class="nx">Pods</code><code class="p">(</code><code class="s">""</code><code class="p">).</code><code class="nx">List</code><code class="p">(</code><code class="nx">metav1</code><code class="p">.</code><code class="nx">ListOptions</code><code class="p">{})</code><code class="w"/>&#13;
<code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
<code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"There are"</code><code class="p">,</code><code class="w"> </code><code class="nb">len</code><code class="p">(</code><code class="nx">podList</code><code class="p">.</code><code class="nx">Items</code><code class="p">),</code><code class="w"> </code><code class="s">"pods in the cluster:"</code><code class="p">)</code><code class="w"/>&#13;
<code class="k">for</code><code class="w"> </code><code class="nx">_</code><code class="p">,</code><code class="w"> </code><code class="nx">i</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="k">range</code><code class="w"> </code><code class="nx">podList</code><code class="p">.</code><code class="nx">Items</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="nx">i</code><code class="p">.</code><code class="nx">ObjectMeta</code><code class="p">.</code><code class="nx">Name</code><code class="p">)</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
<code class="o">...</code><code class="w"/></pre>&#13;
&#13;
<p>You can also create or delete Pods, Deployments, or any other resources. You can even implement your own custom resource types.</p>&#13;
&#13;
<p>If you need a feature that’s missing from Kubernetes, you can implement it yourself, using the client library.</p>&#13;
&#13;
<p>Other programming languages, such as Python, Java, and dotnet, also have official <a href="https://oreil.ly/vRTPf">Kubernetes client libraries</a> you can use in the same way. There are also community-maintained libraries for other programming languages as well.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45979385216384">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>There is a bewildering profusion of Kubernetes tools available, and more are released every week. You could be forgiven for feeling a little weary when reading about yet another tool you apparently can’t do without.</p>&#13;
&#13;
<p>The fact is, you don’t need most of these tools. Kubernetes itself, via <code>kubectl</code>, can do most everything you want it to. The rest is just for fun and convenience.</p>&#13;
&#13;
<p>Nobody knows everything, but everybody knows something. In writing this chapter, we’ve incorporated tips and tricks from lots of experienced Kubernetes engineers, from books, blog posts, and documentation, and one or two little discoveries of our own. Everybody we’ve shown it to, no matter how expert, learned at least one useful thing. That makes us happy.</p>&#13;
&#13;
<p>It’s worth taking a little time to get familiar with <code>kubectl</code> and explore its possibilities; it’s the most important Kubernetes tool you have, and you’ll be using it a lot.</p>&#13;
&#13;
<p>Here are a few of the most important things to know:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>kubectl</code> includes complete and exhaustive documentation on itself, available with <code>kubectl -h</code>, and on every Kubernetes resource, field, or feature, using <code>kubectl explain</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>When you want to do complicated filtering and transformations on <code>kubectl</code> output, for example in scripts, select JSON format with <code>-o json</code>. Once you have JSON data, you can use power tools like <code>jq</code> to query it.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>--dry-run=client</code> option to <code>kubectl</code>, combined with <code>-o YAML</code> to get YAML output, lets you use imperative commands to generate Kubernetes manifests. This is a big time-saver when creating manifest files for new applications, for example.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can turn existing resources into YAML manifests, too, using the <code>-o</code> flag to <code>kubectl get</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>kubectl diff</code> will tell you what <em>would</em> change if you applied a manifest, without actually changing it.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can see the output and error messages from any container with <code>kubectl logs</code>, stream them continuously with the <code>--follow</code> flag, or do more sophisticated multi-Pod log tailing with Stern.</p>&#13;
</li>&#13;
<li>&#13;
<p>To troubleshoot problem containers, you can attach to them with <code>kubectl attach</code> or get a shell on the container with <code>kubectl exec -it ... -- /bin/sh</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can run any public container image with <code>kubectl run</code> to help solve problems, including the multitalented BusyBox tool, which contains all your favorite Unix commands.</p>&#13;
</li>&#13;
<li>&#13;
<p>Kubernetes contexts are like bookmarks, marking your place in a particular cluster and namespace. You can switch conveniently between contexts and namespaces using the <code>kubectx</code> and <code>kubens</code> tools.</p>&#13;
</li>&#13;
<li>&#13;
<p>Click is a powerful Kubernetes shell that gives you all the functionality of <code>kubectl</code>, but with added state: it remembers the currently selected object from one command to the next, so you don’t have to specify it every time.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lens is a great standalone application you can use to manage Kubernetes clusters. VS Code also has a Kubernetes extension, allowing you to interact with your clusters alongside of your code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Kubernetes is designed to be automated and controlled by code. When you need to go beyond what <code>kubectl</code> provides, the Kubernetes <code>client-go</code> library gives you complete control over every aspect of your cluster using Go code.<a data-startref="ix_07-tools-adoc0" data-type="indexterm" id="idm45979385043424"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45979385899936"><sup><a href="ch07.html#idm45979385899936-marker">1</a></sup> <a href="https://www.pulumi.com">Pulumi</a> is a cloud native IaC framework.</p><p data-type="footnote" id="idm45979385568432"><sup><a href="ch07.html#idm45979385568432-marker">2</a></sup> Versions of the BusyBox image later than 1.28 have <a href="https://oreil.ly/XxKDS">a problem doing DNS lookups</a> in Kubernetes.</p></div></div></section></body></html>