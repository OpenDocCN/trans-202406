- en: Chapter 5\. Message Passing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message passing is a very broad and sometimes contentious topic in computer
    science, and there are many patterns and systems that have come and gone or abided,
    like “pub/sub” (“publish” and “subscribe”), event dispatchers, callbacks, observers,
    message queues, etc. The truth is, these are often very similar, and you’d be
    hard pressed to define practical differences between some of them. Regardless,
    this is a critical function in any application, and there are some consensus strategies
    in mobile application development that we’ll explain here.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a callback to react to an operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dispatch a message to any interested subscribers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Listen for and react to messages dispatched within a system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android, you usually use callbacks for direct message passing and dispatch
    events with the statistically available and thread-safe `LocalBroadcastManager`.
    Note that `LocalBroadcastManager` sends `Intent` instances to be received by `BroadcastReceiver`
    instances—this is the same mechanism used by system-wide messages, many provided
    by other apps or operating system components; however, `LocalBroadcastManager`
    only notifies `BroadcastReceivers` in your app, which is both a good thing (safe)
    but also a little limiting—if you want to communicate between apps or with the
    underlying framework, you have to go beyond the brevity and simple API provided
    by `LocalBroadcastManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Use a Callback to React to an Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java and Android, the most direct route of passing a message is to send
    a callback along with an operation. A callback is an object instance created solely
    to receive a result and act on it and is often a simple anonymous instance of
    a functional interface. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Someone might invoke it with a full instance of the `Callback` interface, a
    lambda, or a method reference:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambda in Java then Kotlin
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Method reference in Java then Kotlin
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Instance in Java only
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is no direct equivalent in Kotlin, since rather than interfaces, function
    parameters are defined as lambdas. Use the syntax for lambdas instead, and see
    [the Kotlin documentation](https://oreil.ly/lr8Ja) for information on higher-order
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it’s a pretty direct route and allows you as the developer to
    define your program’s reaction to the result of an operation with enormous flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a trivial but functional example. This time we use a callback for both
    a successful operation as well as an unsuccessful outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke it elsewhere, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A more practical example might be one where you have many operations that might
    throw exceptions, like network requests that require authentication and return
    JSON responses that must be successfully parsed, and then local disk or database
    operations to save the results. You might have an `Activity` that handles all
    of this logic and want common failure logic (e.g., showing a `Snackbar` to the
    user with some human-friendly copy describing the failure, but not interrupting
    the user’s experience or crashing the app). Something like this class might be
    helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You could use these utilities in a controller that might look like these:'
  prefs: []
  type: TYPE_NORMAL
- en: Those are the basics of using callbacks! It’s a pretty straightforward pattern,
    and you’ve probably seen, or even used, something similar already.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch a Message to Any Interested Subscribers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A less familiar API is one that’s Android specific and not available outside
    the framework: `LocalBroadcastManager`. Let’s jump right in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LocalBroadcastManager` is a singleton—a single instance is used and managed
    throughout your app. You are able to access the singleton instance by passing
    any `Context` instance to the static `getInstance` method: `LocalBroadcastManager
    lbm = LocalBroadcastManager.getInstance(context);`. You’ll never need to worry
    about the constructor or configuration. Furthermore, it’s thread-safe out of the
    box!'
  prefs: []
  type: TYPE_NORMAL
- en: The really great thing about this class being a singleton is that you’re able
    to send and receive messages between two objects that know nothing about each
    other. For example, you may broadcast messages from an `Adapter` class that manages
    several different `RecyclerViews` in your app, without knowing what (if anything)
    will happen when that message is received. In one list view, you may want to update
    the list in response to one particular kind of message; in another list, you may
    want to react very differently—maybe even `finish` the `Activity` for the same
    message. The `Adapter` doesn’t have to know about the instances of the `RecyclerView`
    or the various `Activity` instances that house them, and vice versa—the `LocalBroadcastManager`
    sounds the alarm, and any interested party can react however you choose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LocalBroadcastManager` instance has two methods we use regularly: they
    are `sendBroadcast` and `registerReceiver`. As you’ve probably guessed, `sendBroadcast`
    dispatches a message and notifies any other class that has registered a receiver
    for that kind of message. A third method, `unregisterReceiver`, is important as
    well, so that we can stop listening for messages if a listener is removed from
    the application (and thereby prevent memory leaks!).'
  prefs: []
  type: TYPE_NORMAL
- en: Messages like this are represented by the `Intent` class, the same class used
    to start new `Activities` and describe system-wide dispatches. An `Intent` instance
    has an “action” property, which you can set in the constructor by passing a `String`;
    you can even add more actions later with the `addAction` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `LocalBroadastManager` dispatches an `Intent` using the `sendBroadcast`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Once this is invoked, any `BroadcastReceiver` that has previously been registered
    for this action on the same global instance of `LocalBroadcastManager` will call
    its `onReceive` method with the `Intent` instance you sent as the second argument
    to `onReceive`. Note that only `BroadcastReceiver` instances that were registered
    with an `IntentFilter` that includes an action that matches the action of the
    `Intent` instance will fire. So, in the preceding example, if you create a broadcast
    with an `Intent` constructed using a different action—like `Intent intent = new
    Intent("user-login");`—the `BroadcastReceiver` in this example will not fire,
    because the actions do not match.
  prefs: []
  type: TYPE_NORMAL
- en: Listen for, and React to, Messages Dispatched Within a System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look at how we register to become notified of a broadcast.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a `BroadcastReceiver` instance, an object instance that extends
    the base `BroadcastReceiver` class and will react to messages we’re interested
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need an `IntentFilter` instance, which is really just a list of string
    action types that we’re interested in:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is other functionality the `IntentFilter` offers, but the most common
    is the basic `String` action filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can pass those to the `registerReceiver` method, and we’ll be notified
    any time a broadcast is sent with the action “data-received”:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `LocalBroadcastReceiver` is thread-safe, so you can send a broadcast
    from a background thread and listen for it on the UI thread safely. However, the
    broadcast itself is asynchronous, meaning that it will not necessarily fire in
    the order of statements in your program. There is, however, a `broadcastSync`
    method that will send the broadcast immediately and serially.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also very important to remember to unregister `BroadcastReceivers` that
    are no longer being used, like those defined in an `Activity` that has been `finished`.
    Otherwise, memory leaks can occur.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of third-party messaging systems available in Java and Android,
    including Otto by Square and EventBus by GreenRobot. There’s also the `Observable`
    API used by the very popular RxJava Android library, but to my mind the observable
    pattern is different enough from traditional pub-sub that it deserves to be addressed
    independently.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s extremely simple to write your own event bus (a full-featured
    event dispatch and receiver system) in Java; we have written one [in about 40
    lines](https://oreil.ly/en-O6).
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few ways to handle message passing in iOS. Like Android, a common
    pattern for this is through the use of callbacks and notifications. Let’s examine
    the differences and determine the right time to use either one of these tried-and-true
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Use a Callback to React to an Operation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common form of message passing in Swift and iOS is done through closures.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Closures are standalone functions that act as objects. They can be properties
    on another object and passed around as method parameters or stored for later use.
    In its most basic form a closure might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Essentially, a closure is a spring-loaded snippet of code that can be called
    any time. Another name for them is “anonymous functions,” and they’re very useful!
  prefs: []
  type: TYPE_NORMAL
- en: 'Use of closures as callbacks is most powerful and appropriate in asynchronous
    situations—say when waiting for a network call to complete. Here’s an example
    of how a hypothetical API client might utilize closures to communicate with an
    API without causing the entire app to become unresponsive while waiting for a
    reply from a server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through this code.
  prefs: []
  type: TYPE_NORMAL
- en: First, the `completion` property is a stored instance of a closure the containing
    class can use later. It should be noted that this is a nullable property and can
    be `nil` if we don’t want something to happen whenever a network call completes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `fetchData` is a placeholder method that eventually calls `onSuccess`
    or `onError` whenever a response is received from our hypothetical API.
  prefs: []
  type: TYPE_NORMAL
- en: Now, this is the important part. Whenever `onSuccess` or `onError` are invoked,
    they call the stored closure and pass in some data via method parameters. Any
    data could be passed to the closure, but in this example a boolean indicating
    if an operation was a success and an optional error if an error occurred are given
    to the closure.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on to how this object is used, we can see that the class is instantiated
    as `api`, and a closure is given to the `completion` variable from before that
    prints whether or not an operation was a success or failure to the console. This
    is the same closure that is referenced and called in `onSuccess` and `onError`
    within the `NetworkService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Last, we call `fetchData` from the object we’ve created so that we can kick
    off the network call and receive our response from the API.
  prefs: []
  type: TYPE_NORMAL
- en: Escaping and nonescaping closures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the harder aspects of closures to understand is memory management. Whenever
    a closure is created, the variables and instances contained within it are “closed
    around,” and strong references to these objects are created. The result of this
    is that the objects stick around even after they’ve gone out of scope so they
    can be used by the closure. Here’s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: First, we create an object that increments itself by one every time `increment`
    is called. We instantiate an object of that type. Then, we pass that object into
    a closure so that a strong reference to it is made. This allows that object to
    stick around past when it would normally be out of scope. The end result of this
    is that when `closure()` is called, the object is still around and is able to
    increment our count by one for the number of times it’s called (in this case,
    two times).
  prefs: []
  type: TYPE_NORMAL
- en: This is relevant because it has to do with memory management of the objects
    created. Swift—and its predecessor, Objective-C—is susceptible to a class of bugs
    known as retain cycles. This is when an object cannot go out of scope and be cleared
    from memory because other objects hold on to a reference of it. Because closures
    create a strong reference to objects contained within them, they are essentially
    adding a “tally mark” to the list of objects that object is owned by. This tells
    the compiler not to clear it from memory so that it can used by the other objects.
    In our preceding example, this is helpful for the closure because `incrementor`
    stays in scope and can be called later when the closure is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a closure is passed as a parameter in Swift, if the closure does not outlive
    the function being called, the closure is called a `nonescaping` closure. By default,
    this is the type of closure implicitly declared for every closure passed as an
    argument. An example of a nonescaping closure is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ve changed our `Incrementor` class’s `increment()` method to now take a closure
    as a method parameter so that the method signature is now `increment(with:)`.
    This closure is called as soon as the `count` variable is incremented by one.
    In our example, we pass in a closure that simply `print`s the `count` variable
    by calling it directly from the `incrementor` object. We’ve referenced `incrementor`
    directly, which means a strong reference is created by the compiler and `incrementor`
    will not be freed from memory until our application completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the argument `closure` passed into `increment(with:)` is a
    nonescaping closure. It never will outlive the function that’s being called. Let’s
    take a look at an escaping closure to see what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we’ve added a new `printingMethod` to store our passed in closure.
    Then, within `increment(with:)`, we assign the closure passed in to the `printingMethod`
    variable. If you try this in the code editor, you’ll get a compiler error when
    you try to assign a value to `printingMethod` because you didn’t indicate this
    closure was an escaping closure. It’s a simple fix. Just add an `escaping` keyword
    to the closure passed in to the `increment(with:)` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The full example now looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This resolves the compiler error. But we’ve created a pesky bug known as a retain
    cycle. They’re easy to create and tough to debug. It’s not very noticeable in
    our small example, but if you had a large object or an object that was created
    a lot of times, you could quickly run out of available memory for your application
    or run into unwanted and unexpected side effects. So, where is our bug?
  prefs: []
  type: TYPE_NORMAL
- en: Remember how we mentioned that creating a closure creates a strong reference,
    or adds a “tally mark,” to an object so it won’t be cleared out of memory until
    all its references are gone? Well, in our example, we create a strong reference
    to `incrementor` in our `printCount` closure. But, we create a strong reference
    to our closure when we store it as `printingMethod` inside our `increment(with:)`
    method. The object is storing a strong reference to itself so that object can
    never go out of scope and be cleared from memory!
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, Swift has a way to turn a strong reference into what is known as a
    weak reference through capture lists. Let’s declare `incrementor` as a weak reference
    inside the closure we pass into the `increment(with:)` method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we’ve used `[weak incrementor]` to note that `incrementor` should
    be a weak reference instead of a strong reference. We’ve also added a `guard`
    statement to our closure to check to make sure `incrementor` isn’t `nil` before
    we attempt to access it. This means that we no longer have a retain cycle because
    `Incrementor` doesn’t store a strong reference of itself when it stores the closure
    to `printingMethod` inside the `increment(with:)` method; it’s storing a weakly
    referenced version of itself. So, when the last `incrementor` is called, the virtual
    tally sheet can make it to zero and the object can be freed from memory.
  prefs: []
  type: TYPE_NORMAL
- en: Now, closures are certainly the more modern approach to passing messages between
    objects, but sometimes they are a bit of overkill. They’re also prone to memory
    reference bugs, as just now demonstrated, and threading mistakes without careful
    attention and deliberate care. Within Cocoa Touch one finds they are not the only
    way for an object to get its message across. Let’s check out delegates and see
    how they differ from closure-based callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Delegates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Delegates have been a part of Cocoa Touch since its inception. They provide
    logical simplicity but tend to be a bit more verbose than closures. Here’s our
    same `NetworkService` class from before written to use a delegate instead of a
    closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Stepping through this code, we can see a protocol named `NetworkServiceDelegate`
    is defined. The method signature for our callback method is similar to our `completion`
    closure with `Bool` and `Error` arguments but is named instead of anonymous.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we provide a place within `NetworkService` to store our delegate in the
    aptly named property, `delegate`. This property is labeled as `weak` to prevent
    a reference cycle where a delegate stores its parent object; this would prevent
    either object from ever being freed from memory and is an easy thing to miss.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that a lot of the code is the same, but instead of calling the closure
    in `NetworkService`, we’re not calling the delegate directly through `delegate?.fetchDidComplete(success:with:)`.
  prefs: []
  type: TYPE_NORMAL
- en: To actually call our API, we need to create an object that instantiates `NetworkService`,
    sets itself as the delegate, and calls `fetchData()` to fetch data from the network.
    In this example, this is the purpose of the `APIClient` class.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the actual implementation of the delegate method required in our `NetworkServiceDelegate`
    protocol at the start of the example is written as an extension to the `APIClient`
    class. Whenever we call the `fetchData` method, the method `fetchDidComplete(success:with:)`
    will be called, and our success or failure message will be printed out to the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: As you can more than likely see, this is slightly more verbose than a closure
    can be, but the calls are fairly straightforward. Now, it can become unwieldy
    quickly, but given how deeply ingrained within Cocoa Touch this callback pattern
    is, you’ll inevitably run into it at some point. A good rule of thumb is to use
    closures for any operation where asynchronicity matters or there is one path that
    a closure could be called from and use delegates when you (or multiple objects)
    want synchronous calls about whether or not an action should be completed or the
    status of a call.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, it’s possible closures and delegates will not meet the requirements
    necessary without extra, and unnecessary, complexity. When the need for multiple
    closures executing in tandem or multiple delegates receiving the same message
    arises, it’s probably time to consider `NotificationCenter` and friends.
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch a Message to Any Interested Subscribers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notifications are a built-in and convenient way to send messages to other parts
    of your app to allow for decoupling between components. In order to receive the
    notifications being sent, an object “listens” for a shared object to post a message
    with a specific name. There can be data attached to that message, and it propagates
    throughout the application to any objects that are subscribed. Cocoa Touch calls
    these “notifications,” and this pattern is sometimes called “pub-sub” or “observer”
    in other languages and frameworks. The equivalent on Android is `LocalBroadcastManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When we say “notifications,” we’re referring to a `Notification` object and
    not a push notification. And, to complicate matters further, “notification” means
    something entirely different on Android and corresponds to events in the system
    tray.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with posting a notification. Notification names are strings at
    their core, so you can post a notification with a raw string like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Within this code block, the shared `NotificationCenter.default` object is used
    to post a notification with the name “didFinish.” Now, this is a great way to
    get started, but it’s not something you’d want to include in a finished app sent
    to the App Store. The issue lies in how brittle this implementation is by using
    a raw string when posting the notification. Objects that want to listen for your
    notification will use the name of the notification to react. If, for example,
    you were to decide to change the name of the notification to something else, for
    example `didFinishDownload`, then any object subscribed to `didFinish` would not
    receive your notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not too difficult to fix this. You’ll notice that the `post` method isn’t
    ingesting the raw string itself, we’re actually wrapping it in an enum called
    `Notification.Name`. To solve our problem, we can create a property on a class
    or structure that is a type of this enum and use that to *store* the raw string
    instead of passing it around and listening for it directly. This change allows
    any object to target that property when listening for notifications, so any changes
    to the property value (e.g., the notification name) will automatically be picked
    up by our listeners. Here’s an example of how this might look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In our example, the class `SomeObject` defines a new static property named `didFinishNotification`.
    This contains the value of the enum we defined at the call site in the first example.
    Later, in the notification posting method, we use this property instead of declaring
    the value ourselves. This allows us to change the name of the notification from
    “didFinish” to something that might be more in line with best practices to prevent
    name collisions like “SomeObjectDidFinishNotification.”
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible, and a fairly common practice, to attach data to a notification.
    You do this by using a slightly different `post` method that has an extra argument
    for a dictionary of values. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we are passing in a dictionary that contains a key named “downloadCount”
    with a value of `3`. We could pass all kinds of data as long as it fits in a dictionary
    (i.e., as long as it conforms to `Hashable`). For example, if we wanted to pass
    an object, we might use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll notice in our example, we’re using predetermined raw strings again.
    It’s easy to demonstrate for our examples but best to avoid in finished code due
    to the brittle connections it creates. We can fix this in a way similar to our
    notification names by including a property on our class that corresponds to this
    key like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By using static properties for dictionary keys, you can add some compile-time
    safety to your notifications and make your code a bit more stable. When our notification
    properties start going beyond a notification name or two, it’s standard practice
    to split the code off into an extension, as shown previously.
  prefs: []
  type: TYPE_NORMAL
- en: We’re posting notifications and passing data around, but there is still no one
    listening to what we’re saying. Let’s start subscribing to these notifications
    and see what that looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Listen for, and React to, Messages Dispatched Within a System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to subscribe to a notification in Swift: one with selectors
    (`@objc` methods) and one with closures. Both are very similar in nature but require
    slight differences to the code and the logic. Here’s what it looks like to use
    a selector (which is arguably much more common):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Let’s break down this code.
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ve added a `listenForNotifications` method to our example class. Within
    this method, we add ourselves as observers to the notification we created previously,
    `SomeObject.didFinishNotification` . We add any object as an observer, a child
    object we are controlling as an example, but by passing `self` as the first argument,
    the object is assigning itself directly. We’re targeting the `didFinishDownload(_:)`
    selector, which is defined in the following as an Objective-C style method by
    using the `@objc` keyword in front of the method declaration.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as part of the `didFinishDownload(_:)` method, there is a `Notification`
    object passed in. This object contains a `userInfo` property. This is an optional
    `Dictionary` where the notification payload we passed in our previous example
    is accessed. Using our previously defined notification payload keys, `SomeObject.didFinishNotificationDownloadCountKey`
    in our example, we can access the data from the notification and then print it
    out to the console in the next line.
  prefs: []
  type: TYPE_NORMAL
- en: Closures Instead of Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a closure to observe a notification is similar to the preceding selector-style
    observation. Here’s the same notification observation from our example as a closure
    instead of a selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'First, it’s important to point out the main difference between selector and
    closure observation: the observer is stored as a variable named `observer`. This
    object is created as a result of the `addObserver(forName:object:queue:using:)`
    method call inside of `listenForNotifications()`. We need to store a reference
    to this object because otherwise, our notification will actually get deallocated
    and will never be called. Later, once we unsubscribe from notifications, we will
    set this property to `nil` to allow everything to get deallocated from memory.'
  prefs: []
  type: TYPE_NORMAL
- en: The body of the closure passed in is the same as our `didFinishDownload(_:)`
    selector in the previous example; it grabs the payload passed as part of the notification
    and then prints out the value to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Stop Listening for Notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve shown how to post a notification and how to listen for a notification.
    The last step in the process is to show how to stop listening for notifications.
    Given all the apparatus required to post notifications and listen for them, removing
    yourself as an observer is remarkably straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This unsubscribes an object from all notifications it might be listening for
    and is something of a hammer for selector-style notifications but often a succinct
    way to sever ties to `NotificationCenter`. A better practice for selector-style
    notification subscriptions is to unsubscribe to the notifications by name. This
    is done with a method call like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code unsubscribes from only the `SomeObject.didFinishNotification` notification
    and leaves all other subscriptions intact.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The importance of removing an object as an observer from notifications might
    not be immediately obvious. By removing an object, you are effectively removing
    a reference count on that object and allowing it to be freed from memory if it’s
    no longer referenced by other objects. Memory leaks are a common and easy mistake
    to make, particularly with closure-based notification observation. Always remove
    yourself as an observer and don’t forget to `nil` out the observer objects for
    closure-based observation.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting specific objects with notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although it wasn’t mentioned earlier, you can target specific objects when
    observing notifications, allowing you to receive only notifications that object
    posts. You do this by passing the object as an argument in the `addObserver` method
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Threading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Notifications are received on the same thread from which they are posted. This
    means that in order to update a user interface when a notification was received
    on a background thread, it’s important to use something like `DispatchQueue` to
    dispatch to the main thread. This can be done by wrapping the code that needs
    to run on the main thread with a `DispatchQueue.main.async { … }` block like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Key-value observation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cocoa Touch has an entire system of message passing that wasn’t touched on
    due to the complexity of the subject: key-value observation (KVO). It’s possible
    to observe a single property of an object and receive updates whenever that property’s
    value is updated. Unfortunately, it’s a poorly designed and older API; you can
    only use it on objects that inherit from `NSObject`. It’s also easy to make mistakes
    without careful use, and even then, in the opinion of the authors, it’s rare when
    one of the preceding methods isn’t a better-suited option.'
  prefs: []
  type: TYPE_NORMAL
- en: If, however, you are interested, you can find out information about KVO from
    Apple’s [Key-Value Observing Programming Guide](https://oreil.ly/j8oQV).
  prefs: []
  type: TYPE_NORMAL
- en: What We’ve Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve covered a lot of ground in this chapter. You’ve seen:'
  prefs: []
  type: TYPE_NORMAL
- en: How to pass messages in a variety of ways in iOS and Android. There are direct
    callbacks that are very much a one-to-one way to pass messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How decoupled message passing is handled in both Android (`LocalBroadcastManager`)
    and iOS (`NotificationCenter`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many ways pass messages in your app. The lines blur depending on the
    situation, but given the methods described here, you can start making different
    parts of your application talk to each other. This is important in creating a
    maintainable and decoupled architecture.
  prefs: []
  type: TYPE_NORMAL
