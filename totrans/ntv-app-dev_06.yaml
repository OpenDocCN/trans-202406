- en: Chapter 5\. Message Passing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 消息传递
- en: Message passing is a very broad and sometimes contentious topic in computer
    science, and there are many patterns and systems that have come and gone or abided,
    like “pub/sub” (“publish” and “subscribe”), event dispatchers, callbacks, observers,
    message queues, etc. The truth is, these are often very similar, and you’d be
    hard pressed to define practical differences between some of them. Regardless,
    this is a critical function in any application, and there are some consensus strategies
    in mobile application development that we’ll explain here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递在计算机科学中是一个非常广泛且有时具有争议性的主题，有许多已经出现或存在的模式和系统，如“发布/订阅”、“事件分派器”、“回调”、“观察者”、“消息队列”等。事实上，这些通常非常相似，您很难定义它们之间的实际差异。但无论如何，在任何应用程序中，这都是一个关键的功能，在移动应用程序开发中有一些共识策略，我们将在这里解释。
- en: Tasks
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: 'In this chapter, you’ll learn to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习：
- en: Use a callback to react to an operation.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用回调以响应操作。
- en: Dispatch a message to any interested subscribers.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息分派给任何感兴趣的订阅者。
- en: Listen for and react to messages dispatched within a system.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 监听并响应系统内分派的消息。
- en: Android
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android
- en: In Android, you usually use callbacks for direct message passing and dispatch
    events with the statistically available and thread-safe `LocalBroadcastManager`.
    Note that `LocalBroadcastManager` sends `Intent` instances to be received by `BroadcastReceiver`
    instances—this is the same mechanism used by system-wide messages, many provided
    by other apps or operating system components; however, `LocalBroadcastManager`
    only notifies `BroadcastReceivers` in your app, which is both a good thing (safe)
    but also a little limiting—if you want to communicate between apps or with the
    underlying framework, you have to go beyond the brevity and simple API provided
    by `LocalBroadcastManager`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，您通常使用回调进行直接的消息传递，并使用统计可用和线程安全的`LocalBroadcastManager`分派事件。请注意，`LocalBroadcastManager`发送`Intent`实例以供`BroadcastReceiver`实例接收——这与系统范围消息使用的机制相同，许多是由其他应用程序或操作系统组件提供的；然而，`LocalBroadcastManager`只通知您的应用程序中的`BroadcastReceiver`，这既是一件好事（安全），也稍微有些局限性——如果您希望在应用程序之间通信或与底层框架通信，则必须超越`LocalBroadcastManager`提供的简洁和简单API。
- en: Use a Callback to React to an Operation
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回调以响应操作
- en: 'In Java and Android, the most direct route of passing a message is to send
    a callback along with an operation. A callback is an object instance created solely
    to receive a result and act on it and is often a simple anonymous instance of
    a functional interface. Here’s an example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和Android中，传递消息的最直接方式是将回调与操作一起发送。回调是专门创建的对象实例，仅用于接收结果并对其进行操作，通常是功能接口的简单匿名实例。这里有一个例子：
- en: 'Someone might invoke it with a full instance of the `Callback` interface, a
    lambda, or a method reference:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 某人可能会使用`Callback`接口的完整实例、lambda表达式或方法引用来调用它：
- en: Lambda in Java then Kotlin
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java然后Kotlin中的lambda表达式
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Method reference in Java then Kotlin
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Java然后Kotlin中的方法引用
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Instance in Java only
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仅在Java中使用实例
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is no direct equivalent in Kotlin, since rather than interfaces, function
    parameters are defined as lambdas. Use the syntax for lambdas instead, and see
    [the Kotlin documentation](https://oreil.ly/lr8Ja) for information on higher-order
    functions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中没有直接的等价物，因为函数参数被定义为lambda而不是接口。请改用lambda的语法，并参阅[Kotlin文档](https://oreil.ly/lr8Ja)了解有关高阶函数的信息。
- en: As you can see, it’s a pretty direct route and allows you as the developer to
    define your program’s reaction to the result of an operation with enormous flexibility.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，这是一条非常直接的路径，并允许您作为开发人员定义您的程序对操作结果的反应，具有极大的灵活性。
- en: 'Here’s a trivial but functional example. This time we use a callback for both
    a successful operation as well as an unsuccessful outcome:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单但功能性的例子。这次我们同时使用回调来处理成功的操作和失败的结果：
- en: 'You could use this as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像这样使用它：
- en: 'Invoke it elsewhere, like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他地方调用它，如下所示：
- en: 'A more practical example might be one where you have many operations that might
    throw exceptions, like network requests that require authentication and return
    JSON responses that must be successfully parsed, and then local disk or database
    operations to save the results. You might have an `Activity` that handles all
    of this logic and want common failure logic (e.g., showing a `Snackbar` to the
    user with some human-friendly copy describing the failure, but not interrupting
    the user’s experience or crashing the app). Something like this class might be
    helpful:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际的例子可能是这样的：你有许多可能抛出异常的操作，比如需要身份验证并返回必须成功解析的JSON响应的网络请求，然后是本地磁盘或数据库操作来保存结果。你可能有一个处理所有这些逻辑的`Activity`，并希望有通用的失败处理逻辑（例如，向用户显示一个包含描述失败的友好文本的`Snackbar`，但不中断用户体验或使应用崩溃）。类似这样的类可能会很有帮助：
- en: 'You could use these utilities in a controller that might look like these:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在类似这样的控制器中使用这些实用程序：
- en: Those are the basics of using callbacks! It’s a pretty straightforward pattern,
    and you’ve probably seen, or even used, something similar already.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是使用回调的基础！这是一个非常直接的模式，你可能已经见过或者使用过类似的东西。
- en: Dispatch a Message to Any Interested Subscribers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向任何感兴趣的订阅者发送消息
- en: 'A less familiar API is one that’s Android specific and not available outside
    the framework: `LocalBroadcastManager`. Let’s jump right in.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太熟悉的API是Android特有的，不在框架外部可用的`LocalBroadcastManager`。让我们直接开始吧。
- en: 'The `LocalBroadcastManager` is a singleton—a single instance is used and managed
    throughout your app. You are able to access the singleton instance by passing
    any `Context` instance to the static `getInstance` method: `LocalBroadcastManager
    lbm = LocalBroadcastManager.getInstance(context);`. You’ll never need to worry
    about the constructor or configuration. Furthermore, it’s thread-safe out of the
    box!'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalBroadcastManager`是一个单例——整个应用程序中只使用和管理一个实例。你可以通过将任何`Context`实例传递给静态的`getInstance`方法来访问单例实例：`LocalBroadcastManager
    lbm = LocalBroadcastManager.getInstance(context);`。你永远不需要担心构造函数或配置。此外，它在开箱即用时是线程安全的！'
- en: The really great thing about this class being a singleton is that you’re able
    to send and receive messages between two objects that know nothing about each
    other. For example, you may broadcast messages from an `Adapter` class that manages
    several different `RecyclerViews` in your app, without knowing what (if anything)
    will happen when that message is received. In one list view, you may want to update
    the list in response to one particular kind of message; in another list, you may
    want to react very differently—maybe even `finish` the `Activity` for the same
    message. The `Adapter` doesn’t have to know about the instances of the `RecyclerView`
    or the various `Activity` instances that house them, and vice versa—the `LocalBroadcastManager`
    sounds the alarm, and any interested party can react however you choose.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类作为单例的真正好处在于，你能够在两个互不了解的对象之间发送和接收消息。例如，你可以从管理应用程序中多个不同`RecyclerView`的`Adapter`类广播消息，而不知道当接收到该消息时会发生什么（如果有的话）。在一个列表视图中，你可能希望根据特定类型的消息更新列表；在另一个列表中，你可能希望有非常不同的反应——甚至在相同的消息中`finish`掉`Activity`。`Adapter`不需要知道`RecyclerView`的实例或包含它们的各种`Activity`实例，反之亦然——`LocalBroadcastManager`发出警报，任何感兴趣的方可以根据需要做出反应。
- en: 'The `LocalBroadcastManager` instance has two methods we use regularly: they
    are `sendBroadcast` and `registerReceiver`. As you’ve probably guessed, `sendBroadcast`
    dispatches a message and notifies any other class that has registered a receiver
    for that kind of message. A third method, `unregisterReceiver`, is important as
    well, so that we can stop listening for messages if a listener is removed from
    the application (and thereby prevent memory leaks!).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalBroadcastManager`实例有两个我们经常使用的方法：它们是`sendBroadcast`和`registerReceiver`。正如你可能已经猜到的那样，`sendBroadcast`发送消息并通知任何已注册接收该类型消息的其他类。第三个方法`unregisterReceiver`也很重要，这样我们就可以在应用程序中删除侦听器时停止侦听消息（从而防止内存泄漏！）。'
- en: Messages like this are represented by the `Intent` class, the same class used
    to start new `Activities` and describe system-wide dispatches. An `Intent` instance
    has an “action” property, which you can set in the constructor by passing a `String`;
    you can even add more actions later with the `addAction` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的消息由`Intent`类表示，与用于启动新`Activities`和描述系统范围派发的相同类。`Intent`实例有一个“action”属性，在构造函数中可以通过传递一个`String`来设置；甚至可以使用`addAction`方法后续添加更多操作。
- en: 'The `LocalBroadastManager` dispatches an `Intent` using the `sendBroadcast`
    method:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalBroadastManager`使用`sendBroadcast`方法来发送`Intent`：'
- en: Once this is invoked, any `BroadcastReceiver` that has previously been registered
    for this action on the same global instance of `LocalBroadcastManager` will call
    its `onReceive` method with the `Intent` instance you sent as the second argument
    to `onReceive`. Note that only `BroadcastReceiver` instances that were registered
    with an `IntentFilter` that includes an action that matches the action of the
    `Intent` instance will fire. So, in the preceding example, if you create a broadcast
    with an `Intent` constructed using a different action—like `Intent intent = new
    Intent("user-login");`—the `BroadcastReceiver` in this example will not fire,
    because the actions do not match.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用这个方法，之前在同一个全局`LocalBroadcastManager`实例上注册过这个动作的任何`BroadcastReceiver`都会调用它们的`onReceive`方法，并且第二个参数将是您发送的`Intent`实例。请注意，只有在`IntentFilter`包含与`Intent`实例的动作匹配的动作的`BroadcastReceiver`实例才会被触发。因此，在前面的例子中，如果您创建一个使用不同动作构造的`Intent`，如`Intent
    intent = new Intent("user-login");`，则本例中的`BroadcastReceiver`将不会触发，因为动作不匹配。
- en: Listen for, and React to, Messages Dispatched Within a System
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听和响应系统内分发的消息
- en: Let’s look at how we register to become notified of a broadcast.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何注册以便在广播时收到通知。
- en: 'First, we need a `BroadcastReceiver` instance, an object instance that extends
    the base `BroadcastReceiver` class and will react to messages we’re interested
    in:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`BroadcastReceiver`实例，这是一个扩展基础`BroadcastReceiver`类的对象实例，它将会对我们感兴趣的消息做出响应：
- en: 'Next, we need an `IntentFilter` instance, which is really just a list of string
    action types that we’re interested in:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个`IntentFilter`实例，它实际上只是我们感兴趣的一系列字符串动作类型的列表：
- en: Note
  id: totrans-40
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is other functionality the `IntentFilter` offers, but the most common
    is the basic `String` action filter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntentFilter`提供了其他功能，但最常见的是基本的`String`动作过滤器。'
- en: 'Now we can pass those to the `registerReceiver` method, and we’ll be notified
    any time a broadcast is sent with the action “data-received”:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将这些传递给`registerReceiver`方法，这样每次使用“data-received”动作发送广播时，我们都会收到通知：
- en: Note that `LocalBroadcastReceiver` is thread-safe, so you can send a broadcast
    from a background thread and listen for it on the UI thread safely. However, the
    broadcast itself is asynchronous, meaning that it will not necessarily fire in
    the order of statements in your program. There is, however, a `broadcastSync`
    method that will send the broadcast immediately and serially.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`LocalBroadcastReceiver`是线程安全的，因此您可以在后台线程发送广播，并在UI线程安全地监听。但广播本身是异步的，这意味着它不一定按照程序中语句的顺序触发。然而，有一个`broadcastSync`方法可以立即和串行地发送广播。
- en: It’s also very important to remember to unregister `BroadcastReceivers` that
    are no longer being used, like those defined in an `Activity` that has been `finished`.
    Otherwise, memory leaks can occur.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还非常重要的是记得注销不再使用的`BroadcastReceivers`，比如在已经`finished`的`Activity`中定义的那些。否则可能会发生内存泄漏。
- en: There are a number of third-party messaging systems available in Java and Android,
    including Otto by Square and EventBus by GreenRobot. There’s also the `Observable`
    API used by the very popular RxJava Android library, but to my mind the observable
    pattern is different enough from traditional pub-sub that it deserves to be addressed
    independently.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java和Android中有许多第三方消息系统，包括Square的Otto和GreenRobot的EventBus。还有非常流行的RxJava Android库使用的`Observable`
    API，但在我看来，观察者模式与传统的发布-订阅模式有足够的不同，值得单独讨论。
- en: Finally, it’s extremely simple to write your own event bus (a full-featured
    event dispatch and receiver system) in Java; we have written one [in about 40
    lines](https://oreil.ly/en-O6).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Java中编写自己的事件总线（一个完整的事件分发和接收系统）非常简单；我们已经在[大约40行代码](https://oreil.ly/en-O6)中编写了一个。
- en: iOS
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS
- en: There are a few ways to handle message passing in iOS. Like Android, a common
    pattern for this is through the use of callbacks and notifications. Let’s examine
    the differences and determine the right time to use either one of these tried-and-true
    patterns.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS中有几种处理消息传递的方式。与Android类似，其中一种常见的模式是通过回调和通知来实现。让我们来分析这些模式之间的区别，并确定何时使用其中一种成熟的模式。
- en: Use a Callback to React to an Operation
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回调来响应操作
- en: The most common form of message passing in Swift and iOS is done through closures.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Swift和iOS中最常见的消息传递形式是通过闭包实现的。
- en: Closures
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closures are standalone functions that act as objects. They can be properties
    on another object and passed around as method parameters or stored for later use.
    In its most basic form a closure might look like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是作为对象而存在的独立函数。它们可以作为另一个对象的属性，并作为方法参数传递或存储以供将来使用。在其最基本的形式中，闭包可能看起来像这样：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Essentially, a closure is a spring-loaded snippet of code that can be called
    any time. Another name for them is “anonymous functions,” and they’re very useful!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，闭包是可以随时调用的弹簧加载的代码片段。它们的另一个名称是“匿名函数”，它们非常有用！
- en: 'Use of closures as callbacks is most powerful and appropriate in asynchronous
    situations—say when waiting for a network call to complete. Here’s an example
    of how a hypothetical API client might utilize closures to communicate with an
    API without causing the entire app to become unresponsive while waiting for a
    reply from a server:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步情况下，闭包作为回调函数的使用是最强大且最合适的，比如等待网络调用完成时。以下是一个假设的API客户端如何利用闭包与服务器通信而不会导致整个应用程序在等待服务器响应时无响应的示例：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s walk through this code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这段代码。
- en: First, the `completion` property is a stored instance of a closure the containing
    class can use later. It should be noted that this is a nullable property and can
    be `nil` if we don’t want something to happen whenever a network call completes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`completion`属性是一个存储在类中可以稍后使用的闭包实例。需要注意的是，这是一个可为空的属性，如果我们不想在网络调用完成时执行任何操作，它可以是`nil`。
- en: Next, `fetchData` is a placeholder method that eventually calls `onSuccess`
    or `onError` whenever a response is received from our hypothetical API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`fetchData`是一个占位方法，当我们的假设API接收到响应时最终调用`onSuccess`或`onError`。
- en: Now, this is the important part. Whenever `onSuccess` or `onError` are invoked,
    they call the stored closure and pass in some data via method parameters. Any
    data could be passed to the closure, but in this example a boolean indicating
    if an operation was a success and an optional error if an error occurred are given
    to the closure.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是重要的部分。每当调用`onSuccess`或`onError`时，它们都会调用存储的闭包，并通过方法参数传递一些数据。闭包可以传递任何数据，但在这个例子中，传递给闭包的是一个布尔值，指示操作是否成功，以及一个可选的错误（如果发生错误）。
- en: Moving on to how this object is used, we can see that the class is instantiated
    as `api`, and a closure is given to the `completion` variable from before that
    prints whether or not an operation was a success or failure to the console. This
    is the same closure that is referenced and called in `onSuccess` and `onError`
    within the `NetworkService` class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到这个对象的使用方法，我们可以看到该类被实例化为`api`，并且从之前的`completion`变量中传递了一个闭包，用于将操作成功或失败的信息打印到控制台。这个闭包在`NetworkService`类中的`onSuccess`和`onError`中被引用和调用。
- en: Last, we call `fetchData` from the object we’ve created so that we can kick
    off the network call and receive our response from the API.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们调用从我们创建的对象中调用`fetchData`，以便启动网络调用并从API接收响应。
- en: Escaping and nonescaping closures
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逃逸闭包和非逃逸闭包
- en: 'One of the harder aspects of closures to understand is memory management. Whenever
    a closure is created, the variables and instances contained within it are “closed
    around,” and strong references to these objects are created. The result of this
    is that the objects stick around even after they’ve gone out of scope so they
    can be used by the closure. Here’s an example of this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包理解中较难的一个方面是内存管理。每当创建一个闭包时，其中包含的变量和实例被“闭合”，并且创建这些对象的强引用。其结果是，即使这些对象超出作用域，它们仍然存在以便闭包使用。以下是一个例子：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we create an object that increments itself by one every time `increment`
    is called. We instantiate an object of that type. Then, we pass that object into
    a closure so that a strong reference to it is made. This allows that object to
    stick around past when it would normally be out of scope. The end result of this
    is that when `closure()` is called, the object is still around and is able to
    increment our count by one for the number of times it’s called (in this case,
    two times).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个对象，每次调用`increment`时自增一次。我们实例化了这种类型的对象。然后，我们将该对象传递给一个闭包，以便对它进行强引用。这允许该对象在通常会超出作用域时继续存在。这样做的最终结果是，当调用`closure()`时，对象仍然存在，并且能够在每次调用时将我们的计数增加一次（在本例中，两次）。
- en: This is relevant because it has to do with memory management of the objects
    created. Swift—and its predecessor, Objective-C—is susceptible to a class of bugs
    known as retain cycles. This is when an object cannot go out of scope and be cleared
    from memory because other objects hold on to a reference of it. Because closures
    create a strong reference to objects contained within them, they are essentially
    adding a “tally mark” to the list of objects that object is owned by. This tells
    the compiler not to clear it from memory so that it can used by the other objects.
    In our preceding example, this is helpful for the closure because `incrementor`
    stays in scope and can be called later when the closure is called.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为它涉及到所创建对象的内存管理。Swift及其前身Objective-C容易受到称为保留周期的错误影响。当一个对象因其他对象持有其引用而无法退出作用域并从内存中清除时，就会发生这种情况。由于闭包对其中包含的对象创建了强引用，它们实质上是在“计分板”上为拥有该对象的其他对象增加了一个记号。这告诉编译器不要清除它，以便其他对象可以使用它。在前面的例子中，对于闭包来说，这是有帮助的，因为`incrementor`保持在作用域内，并且可以在稍后调用闭包时调用。
- en: 'When a closure is passed as a parameter in Swift, if the closure does not outlive
    the function being called, the closure is called a `nonescaping` closure. By default,
    this is the type of closure implicitly declared for every closure passed as an
    argument. An example of a nonescaping closure is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当闭包作为Swift的参数传递时，如果闭包不超出被调用的函数的生存期，那么该闭包被称为`nonescaping`闭包。默认情况下，对于每个作为参数传递的闭包，都会隐式声明为这种类型的闭包。一个非逃逸闭包的示例如下：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve changed our `Incrementor` class’s `increment()` method to now take a closure
    as a method parameter so that the method signature is now `increment(with:)`.
    This closure is called as soon as the `count` variable is incremented by one.
    In our example, we pass in a closure that simply `print`s the `count` variable
    by calling it directly from the `incrementor` object. We’ve referenced `incrementor`
    directly, which means a strong reference is created by the compiler and `incrementor`
    will not be freed from memory until our application completes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经修改了`Incrementor`类的`increment()`方法，现在它接受一个闭包作为方法参数，因此方法签名现在是`increment(with:)`。当`count`变量增加一个单位时，立即调用此闭包。在我们的示例中，我们传递了一个闭包，它只是直接从`incrementor`对象中调用`print`打印`count`变量。我们直接引用了`incrementor`，这意味着编译器创建了一个强引用，并且`incrementor`在我们的应用程序完成之前不会从内存中释放。
- en: 'In our example, the argument `closure` passed into `increment(with:)` is a
    nonescaping closure. It never will outlive the function that’s being called. Let’s
    take a look at an escaping closure to see what that looks like:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，传递给`increment(with:)`的参数`closure`是一个非逃逸闭包。它永远不会超出被调用的函数的生存期。让我们看看逃逸闭包的示例是什么样子：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, we’ve added a new `printingMethod` to store our passed in closure.
    Then, within `increment(with:)`, we assign the closure passed in to the `printingMethod`
    variable. If you try this in the code editor, you’ll get a compiler error when
    you try to assign a value to `printingMethod` because you didn’t indicate this
    closure was an escaping closure. It’s a simple fix. Just add an `escaping` keyword
    to the closure passed in to the `increment(with:)` method like so:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们添加了一个新的`printingMethod`来存储我们传入的闭包。然后，在`increment(with:)`内部，我们将传入的闭包赋值给`printingMethod`变量。如果您在代码编辑器中尝试此操作，当您尝试为`printingMethod`分配一个值时，您将收到一个编译器错误，因为您没有指示此闭包是一个逃逸闭包。这是一个简单的修复方法。只需在传递给`increment(with:)`方法的闭包中添加一个`escaping`关键字，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The full example now looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在完整的示例看起来是这样的：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This resolves the compiler error. But we’ve created a pesky bug known as a retain
    cycle. They’re easy to create and tough to debug. It’s not very noticeable in
    our small example, but if you had a large object or an object that was created
    a lot of times, you could quickly run out of available memory for your application
    or run into unwanted and unexpected side effects. So, where is our bug?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了编译器错误。但是我们创建了一个讨厌的bug，称为保留周期。它们很容易创建，但很难调试。在我们的小例子中并不太明显，但如果你有一个大对象或者一个被多次创建的对象，你可能会很快耗尽应用程序的可用内存，或者遇到意外的副作用和不期而遇的问题。那么我们的bug在哪里呢？
- en: Remember how we mentioned that creating a closure creates a strong reference,
    or adds a “tally mark,” to an object so it won’t be cleared out of memory until
    all its references are gone? Well, in our example, we create a strong reference
    to `incrementor` in our `printCount` closure. But, we create a strong reference
    to our closure when we store it as `printingMethod` inside our `increment(with:)`
    method. The object is storing a strong reference to itself so that object can
    never go out of scope and be cleared from memory!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们提到过创建闭包会创建一个强引用，或者给一个对象添加一个“记分牌”，这样它就不会在所有引用都消失之前被清除出内存？在我们的例子中，我们在`printCount`闭包中创建了一个对`incrementor`的强引用。但是，当我们将其存储为`increment(with:)`方法内部的`printingMethod`时，我们创建了对闭包的强引用。对象正在存储对自身的强引用，以便该对象永远不会超出作用域并从内存中清除！
- en: 'Luckily, Swift has a way to turn a strong reference into what is known as a
    weak reference through capture lists. Let’s declare `incrementor` as a weak reference
    inside the closure we pass into the `increment(with:)` method like so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Swift有一种方法可以通过捕获列表将强引用转换为所谓的弱引用。让我们在我们传递给`increment(with:)`方法的闭包内部将`incrementor`声明为弱引用，像这样：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we’ve used `[weak incrementor]` to note that `incrementor` should
    be a weak reference instead of a strong reference. We’ve also added a `guard`
    statement to our closure to check to make sure `incrementor` isn’t `nil` before
    we attempt to access it. This means that we no longer have a retain cycle because
    `Incrementor` doesn’t store a strong reference of itself when it stores the closure
    to `printingMethod` inside the `increment(with:)` method; it’s storing a weakly
    referenced version of itself. So, when the last `incrementor` is called, the virtual
    tally sheet can make it to zero and the object can be freed from memory.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`[weak incrementor]`来指示`incrementor`应该是一个弱引用而不是一个强引用。我们还在闭包中添加了一个`guard`语句，以确保在尝试访问之前`incrementor`不为`nil`。这意味着我们不再有保留周期，因为在存储`increment(with:)`方法内部的闭包到`printingMethod`时，`Incrementor`没有存储自身的强引用；它存储的是一个弱引用版本。因此，当最后一个`incrementor`被调用时，虚拟记分牌可以归零，并且对象可以从内存中释放。
- en: Now, closures are certainly the more modern approach to passing messages between
    objects, but sometimes they are a bit of overkill. They’re also prone to memory
    reference bugs, as just now demonstrated, and threading mistakes without careful
    attention and deliberate care. Within Cocoa Touch one finds they are not the only
    way for an object to get its message across. Let’s check out delegates and see
    how they differ from closure-based callbacks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，闭包显然是在对象之间传递消息的更现代方法，但有时它们可能有点过度。它们也容易出现内存引用错误，正如刚刚展示的那样，并且在不仔细注意和故意处理的情况下容易出现线程错误。在Cocoa
    Touch中，人们发现它们并不是对象传递消息的唯一方式。让我们来看看代理与基于闭包的回调函数有何不同。
- en: Delegates
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理
- en: 'Delegates have been a part of Cocoa Touch since its inception. They provide
    logical simplicity but tend to be a bit more verbose than closures. Here’s our
    same `NetworkService` class from before written to use a delegate instead of a
    closure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 自从它的创立以来，代理已经成为Cocoa Touch的一部分。它们提供了逻辑简单性，但通常比闭包更冗长。这是我们之前使用委托而不是闭包编写的相同`NetworkService`类：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Stepping through this code, we can see a protocol named `NetworkServiceDelegate`
    is defined. The method signature for our callback method is similar to our `completion`
    closure with `Bool` and `Error` arguments but is named instead of anonymous.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们可以看到一个名为`NetworkServiceDelegate`的协议被定义了。我们的回调方法的方法签名与我们的`completion`闭包类似，带有`Bool`和`Error`参数，但是使用的是命名而不是匿名。
- en: Next, we provide a place within `NetworkService` to store our delegate in the
    aptly named property, `delegate`. This property is labeled as `weak` to prevent
    a reference cycle where a delegate stores its parent object; this would prevent
    either object from ever being freed from memory and is an easy thing to miss.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在`NetworkService`中提供了一个地方来存储我们的委托，这个属性被适当命名为`delegate`。这个属性被标记为`weak`，以防止委托存储其父对象的引用循环；这将防止任一对象被从内存中释放，并且很容易被忽略。
- en: You can see that a lot of the code is the same, but instead of calling the closure
    in `NetworkService`, we’re not calling the delegate directly through `delegate?.fetchDidComplete(success:with:)`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到很多代码是相同的，但是不是通过在`NetworkService`中调用闭包，而是直接通过`delegate?.fetchDidComplete(success:with:)`调用委托。
- en: To actually call our API, we need to create an object that instantiates `NetworkService`,
    sets itself as the delegate, and calls `fetchData()` to fetch data from the network.
    In this example, this is the purpose of the `APIClient` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用我们的 API，我们需要创建一个对象，实例化`NetworkService`，将自身设置为代理，并调用`fetchData()`从网络获取数据。在这个示例中，这就是`APIClient`类的目的。
- en: Finally, the actual implementation of the delegate method required in our `NetworkServiceDelegate`
    protocol at the start of the example is written as an extension to the `APIClient`
    class. Whenever we call the `fetchData` method, the method `fetchDidComplete(success:with:)`
    will be called, and our success or failure message will be printed out to the
    console.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在示例开始时我们`NetworkServiceDelegate`协议所需的代理方法实际实现写成了`APIClient`类的扩展。每当我们调用`fetchData`方法时，将调用`fetchDidComplete(success:with:)`方法，并将成功或失败的消息打印到控制台。
- en: As you can more than likely see, this is slightly more verbose than a closure
    can be, but the calls are fairly straightforward. Now, it can become unwieldy
    quickly, but given how deeply ingrained within Cocoa Touch this callback pattern
    is, you’ll inevitably run into it at some point. A good rule of thumb is to use
    closures for any operation where asynchronicity matters or there is one path that
    a closure could be called from and use delegates when you (or multiple objects)
    want synchronous calls about whether or not an action should be completed or the
    status of a call.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您很可能看到的那样，这比闭包稍微啰嗦一些，但调用非常直接。现在，它可能很快变得难以控制，但考虑到这种回调模式在 Cocoa Touch 中的深入根植，您最终将不可避免地遇到它。一个好的经验法则是，在任何需要异步性或有一个闭包可能会被调用的路径时使用闭包，并在您（或多个对象）想要同步调用有关是否应完成操作或调用状态的情况下使用委托。
- en: Eventually, it’s possible closures and delegates will not meet the requirements
    necessary without extra, and unnecessary, complexity. When the need for multiple
    closures executing in tandem or multiple delegates receiving the same message
    arises, it’s probably time to consider `NotificationCenter` and friends.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，闭包和委托可能不符合必要的要求，而需要额外且不必要的复杂性。当需要多个闭包并行执行或多个委托接收相同消息时，很可能是考虑`NotificationCenter`和相关内容的时候了。
- en: Dispatch a Message to Any Interested Subscribers
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分发消息给任何感兴趣的订阅者
- en: Notifications are a built-in and convenient way to send messages to other parts
    of your app to allow for decoupling between components. In order to receive the
    notifications being sent, an object “listens” for a shared object to post a message
    with a specific name. There can be data attached to that message, and it propagates
    throughout the application to any objects that are subscribed. Cocoa Touch calls
    these “notifications,” and this pattern is sometimes called “pub-sub” or “observer”
    in other languages and frameworks. The equivalent on Android is `LocalBroadcastManager`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是向应用程序中的其他部分发送消息的一种内置和方便的方式，以实现组件之间的解耦。为了接收正在发送的通知，一个对象会“监听”一个共享对象，以便发布具有特定名称的消息。该消息可以附带数据，并传播到订阅的任何对象中。Cocoa
    Touch 将这些称为“通知”，在其他语言和框架中，这种模式有时被称为“发布-订阅”或“观察者”。在 Android 上的等效物是`LocalBroadcastManager`。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When we say “notifications,” we’re referring to a `Notification` object and
    not a push notification. And, to complicate matters further, “notification” means
    something entirely different on Android and corresponds to events in the system
    tray.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说“通知”时，我们指的是一个`Notification`对象，而不是推送通知。并且，为了使事情更加复杂，对于 Android 来说，“通知”意味着系统托盘中的事件。
- en: 'Let’s start with posting a notification. Notification names are strings at
    their core, so you can post a notification with a raw string like so:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从发布通知开始。通知名称本质上是字符串，因此您可以像这样使用原始字符串发布通知：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Within this code block, the shared `NotificationCenter.default` object is used
    to post a notification with the name “didFinish.” Now, this is a great way to
    get started, but it’s not something you’d want to include in a finished app sent
    to the App Store. The issue lies in how brittle this implementation is by using
    a raw string when posting the notification. Objects that want to listen for your
    notification will use the name of the notification to react. If, for example,
    you were to decide to change the name of the notification to something else, for
    example `didFinishDownload`, then any object subscribed to `didFinish` would not
    receive your notification.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码块中，共享的`NotificationCenter.default`对象用于发布名称为“didFinish”的通知。现在，这是一个很好的入门方式，但不适合包含在发送到App
    Store的成品应用程序中。问题在于使用原始字符串时，这种实现非常脆弱。希望监听您的通知的对象将使用通知的名称来做出反应。例如，如果您决定将通知名称更改为其他名称，例如`didFinishDownload`，那么任何订阅`didFinish`的对象都将不会收到您的通知。
- en: 'It’s not too difficult to fix this. You’ll notice that the `post` method isn’t
    ingesting the raw string itself, we’re actually wrapping it in an enum called
    `Notification.Name`. To solve our problem, we can create a property on a class
    or structure that is a type of this enum and use that to *store* the raw string
    instead of passing it around and listening for it directly. This change allows
    any object to target that property when listening for notifications, so any changes
    to the property value (e.g., the notification name) will automatically be picked
    up by our listeners. Here’s an example of how this might look:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 修复这个问题并不难。您会注意到`post`方法并不直接接收原始字符串，而是将其包装在名为`Notification.Name`的枚举中。为了解决这个问题，我们可以在类或结构体上创建一个此枚举类型的属性，并使用它来*存储*原始字符串，而不是直接传递和监听它。这种改变允许任何对象针对该属性进行目标设置，因此属性值的任何更改（例如通知名称）都将自动被我们的监听器捕获。以下是这种做法的示例：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In our example, the class `SomeObject` defines a new static property named `didFinishNotification`.
    This contains the value of the enum we defined at the call site in the first example.
    Later, in the notification posting method, we use this property instead of declaring
    the value ourselves. This allows us to change the name of the notification from
    “didFinish” to something that might be more in line with best practices to prevent
    name collisions like “SomeObjectDidFinishNotification.”
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，类`SomeObject`定义了一个名为`didFinishNotification`的新静态属性。这个属性包含我们在第一个示例中在调用站点定义的枚举的值。稍后，在通知发布方法中，我们使用这个属性而不是自己声明值。这样做可以让我们将通知的名称从“didFinish”更改为更符合最佳实践、防止名称冲突的名称，例如“SomeObjectDidFinishNotification”。
- en: 'It’s also possible, and a fairly common practice, to attach data to a notification.
    You do this by using a slightly different `post` method that has an extra argument
    for a dictionary of values. Here’s an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用稍有不同的`post`方法，在通知中附加数据，这是一种相当常见的做法。以下是一个示例：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, we are passing in a dictionary that contains a key named “downloadCount”
    with a value of `3`. We could pass all kinds of data as long as it fits in a dictionary
    (i.e., as long as it conforms to `Hashable`). For example, if we wanted to pass
    an object, we might use the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们传入了一个包含键名为“downloadCount”、值为`3`的字典。只要符合`Hashable`协议，我们可以传递各种数据，例如对象。如果我们想要传递一个对象，我们可以使用以下代码：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You’ll notice in our example, we’re using predetermined raw strings again.
    It’s easy to demonstrate for our examples but best to avoid in finished code due
    to the brittle connections it creates. We can fix this in a way similar to our
    notification names by including a property on our class that corresponds to this
    key like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到在我们的示例中，我们再次使用预定义的原始字符串。这对于演示示例很容易，但在成品代码中最好避免使用，因为它会创建脆弱的连接。我们可以通过在类上包含与此键对应的属性来类似解决通知名称的问题，如下所示：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By using static properties for dictionary keys, you can add some compile-time
    safety to your notifications and make your code a bit more stable. When our notification
    properties start going beyond a notification name or two, it’s standard practice
    to split the code off into an extension, as shown previously.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为字典键使用静态属性，您可以为通知添加一些编译时安全性，使您的代码更加稳定。当我们的通知属性开始超出一个或两个通知名称时，将代码拆分成扩展是标准做法，如前面所示。
- en: We’re posting notifications and passing data around, but there is still no one
    listening to what we’re saying. Let’s start subscribing to these notifications
    and see what that looks like.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在发布通知并传递数据，但还没有人在听我们说什么。让我们开始订阅这些通知，看看是什么样子。
- en: Listen for, and React to, Messages Dispatched Within a System
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监听并对系统中分派的消息做出反应
- en: 'There are two ways to subscribe to a notification in Swift: one with selectors
    (`@objc` methods) and one with closures. Both are very similar in nature but require
    slight differences to the code and the logic. Here’s what it looks like to use
    a selector (which is arguably much more common):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中订阅通知有两种方式：一种是使用选择器（`@objc` 方法），另一种是使用闭包。两者在本质上非常相似，但在代码和逻辑上有轻微的差异。以下是使用选择器的示例（这种方式在某种程度上更为常见）：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Let’s break down this code.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来分解这段代码。
- en: First, we’ve added a `listenForNotifications` method to our example class. Within
    this method, we add ourselves as observers to the notification we created previously,
    `SomeObject.didFinishNotification` . We add any object as an observer, a child
    object we are controlling as an example, but by passing `self` as the first argument,
    the object is assigning itself directly. We’re targeting the `didFinishDownload(_:)`
    selector, which is defined in the following as an Objective-C style method by
    using the `@objc` keyword in front of the method declaration.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在示例类中添加了一个 `listenForNotifications` 方法。在这个方法中，我们将自己添加为先前创建的通知 `SomeObject.didFinishNotification`
    的观察者。我们将任何对象作为观察者，作为我们控制的一个子对象的示例，但通过将 `self` 作为第一个参数传递，对象直接进行了分配。我们的目标是 `didFinishDownload(_:)`
    选择器，在此之后使用 `@objc` 关键字定义了这个方法。
- en: Now, as part of the `didFinishDownload(_:)` method, there is a `Notification`
    object passed in. This object contains a `userInfo` property. This is an optional
    `Dictionary` where the notification payload we passed in our previous example
    is accessed. Using our previously defined notification payload keys, `SomeObject.didFinishNotificationDownloadCountKey`
    in our example, we can access the data from the notification and then print it
    out to the console in the next line.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `didFinishDownload(_:)` 方法的一部分中，传递了一个 `Notification` 对象。这个对象包含一个 `userInfo`
    属性。这是一个可选的 `Dictionary`，我们可以在其中访问我们在上一个示例中传递的通知载荷。使用我们之前定义的通知载荷键 `SomeObject.didFinishNotificationDownloadCountKey`，我们可以访问通知中的数据，然后在下一行将其打印到控制台。
- en: Closures Instead of Selectors
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用闭包而不是选择器
- en: 'Using a closure to observe a notification is similar to the preceding selector-style
    observation. Here’s the same notification observation from our example as a closure
    instead of a selector:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用闭包来观察通知与之前的选择器样式观察非常相似。以下是与之前示例中的选择器不同的闭包形式的相同通知观察：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'First, it’s important to point out the main difference between selector and
    closure observation: the observer is stored as a variable named `observer`. This
    object is created as a result of the `addObserver(forName:object:queue:using:)`
    method call inside of `listenForNotifications()`. We need to store a reference
    to this object because otherwise, our notification will actually get deallocated
    and will never be called. Later, once we unsubscribe from notifications, we will
    set this property to `nil` to allow everything to get deallocated from memory.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是指出选择器和闭包观察之间的主要区别：观察者存储为名为 `observer` 的变量。这个对象是在 `listenForNotifications()`
    方法内部调用 `addObserver(forName:object:queue:using:)` 方法的结果。我们需要存储对这个对象的引用，否则我们的通知实际上会被释放，从而永远不会被调用。稍后，一旦我们取消订阅通知，我们将将此属性设置为
    `nil`，以允许从内存中释放所有内容。
- en: The body of the closure passed in is the same as our `didFinishDownload(_:)`
    selector in the previous example; it grabs the payload passed as part of the notification
    and then prints out the value to the console.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 传递进来的闭包体与我们之前的 `didFinishDownload(_:)` 选择器相同；它获取作为通知一部分传递的载荷，然后将值打印到控制台。
- en: Stop Listening for Notifications
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止监听通知
- en: 'We’ve shown how to post a notification and how to listen for a notification.
    The last step in the process is to show how to stop listening for notifications.
    Given all the apparatus required to post notifications and listen for them, removing
    yourself as an observer is remarkably straightforward:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何发布通知和如何监听通知。这个过程的最后一步是展示如何停止监听通知。考虑到发布通知和监听通知所需的所有设备，从观察者中移除自己实际上非常简单。
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This unsubscribes an object from all notifications it might be listening for
    and is something of a hammer for selector-style notifications but often a succinct
    way to sever ties to `NotificationCenter`. A better practice for selector-style
    notification subscriptions is to unsubscribe to the notifications by name. This
    is done with a method call like so:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这会取消对象对其可能正在监听的所有通知的订阅，对于选择器样式的通知来说，这有点像是使用锤子，但通常是断开与 `NotificationCenter` 的关系的简洁方式。对于选择器样式的通知订阅，最好的做法是按名称取消订阅通知。方法调用如下所示：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This code unsubscribes from only the `SomeObject.didFinishNotification` notification
    and leaves all other subscriptions intact.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码仅取消订阅 `SomeObject.didFinishNotification` 通知，并保留所有其他订阅。
- en: Warning
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The importance of removing an object as an observer from notifications might
    not be immediately obvious. By removing an object, you are effectively removing
    a reference count on that object and allowing it to be freed from memory if it’s
    no longer referenced by other objects. Memory leaks are a common and easy mistake
    to make, particularly with closure-based notification observation. Always remove
    yourself as an observer and don’t forget to `nil` out the observer objects for
    closure-based observation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 删除对象作为观察者从通知中移除的重要性可能并不显而易见。通过移除对象，实际上是在减少该对象的引用计数，如果没有其他对象引用它，它将被释放出内存。内存泄漏是一个常见且容易犯的错误，特别是在基于闭包的通知观察中。始终将自己从观察者中移除，并不要忘记为基于闭包的观察对象设置为
    `nil`。
- en: Targeting specific objects with notifications
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对特定对象的通知
- en: 'Although it wasn’t mentioned earlier, you can target specific objects when
    observing notifications, allowing you to receive only notifications that object
    posts. You do this by passing the object as an argument in the `addObserver` method
    as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然之前没有提到，但在观察通知时可以针对特定对象，这样你就只会接收到该对象发布的通知。可以通过在 `addObserver` 方法中传递对象作为参数来实现：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Threading
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程
- en: 'Notifications are received on the same thread from which they are posted. This
    means that in order to update a user interface when a notification was received
    on a background thread, it’s important to use something like `DispatchQueue` to
    dispatch to the main thread. This can be done by wrapping the code that needs
    to run on the main thread with a `DispatchQueue.main.async { … }` block like so:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通知是在发布它们的同一线程上接收的。这意味着，为了在后台线程接收到通知时更新用户界面，使用诸如 `DispatchQueue` 的内容将其调度到主线程非常重要。可以通过像这样用
    `DispatchQueue.main.async { ... }` 包裹需要在主线程上运行的代码块来完成这一点：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Key-value observation
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 键-值观察
- en: 'Cocoa Touch has an entire system of message passing that wasn’t touched on
    due to the complexity of the subject: key-value observation (KVO). It’s possible
    to observe a single property of an object and receive updates whenever that property’s
    value is updated. Unfortunately, it’s a poorly designed and older API; you can
    only use it on objects that inherit from `NSObject`. It’s also easy to make mistakes
    without careful use, and even then, in the opinion of the authors, it’s rare when
    one of the preceding methods isn’t a better-suited option.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Cocoa Touch 有一个完整的消息传递系统，由于主题的复杂性而未触及：键-值观察（KVO）。可以观察对象的单个属性，并在该属性的值更新时接收更新。不幸的是，它是一个设计不佳且较老的
    API；只能在继承自 `NSObject` 的对象上使用。即使小心使用，也很容易出错。甚至在作者看来，前面提到的方法通常也不是更合适的选项之一。
- en: If, however, you are interested, you can find out information about KVO from
    Apple’s [Key-Value Observing Programming Guide](https://oreil.ly/j8oQV).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您感兴趣，可以从苹果的[键-值观察编程指南](https://oreil.ly/j8oQV)获取有关 KVO 的信息。
- en: What We’ve Learned
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们学到了什么
- en: 'We’ve covered a lot of ground in this chapter. You’ve seen:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们覆盖了很多内容。你已经看到了：
- en: How to pass messages in a variety of ways in iOS and Android. There are direct
    callbacks that are very much a one-to-one way to pass messages.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在 iOS 和 Android 中以各种方式传递消息。有直接回调，这是一种非常一对一的消息传递方式。
- en: How decoupled message passing is handled in both Android (`LocalBroadcastManager`)
    and iOS (`NotificationCenter`).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android (`LocalBroadcastManager`) 和 iOS (`NotificationCenter`) 中处理解耦消息传递的方式。
- en: There are many ways pass messages in your app. The lines blur depending on the
    situation, but given the methods described here, you can start making different
    parts of your application talk to each other. This is important in creating a
    maintainable and decoupled architecture.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中传递消息有许多方法。根据情况的不同，界限可能变得模糊，但通过这里描述的方法，你可以开始使应用程序的不同部分彼此交流。这对于创建可维护和解耦的架构至关重要。
