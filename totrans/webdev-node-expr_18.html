<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Security"><div class="chapter" id="ch_security">
<h1><span class="label">Chapter 18. </span>Security</h1>


<p><a data-type="indexterm" data-primary="security" id="ix_ch-18-security-asciidoc0"/>Most websites and applications these days have some kind of security requirement.  If you are allowing people to log in, or if you’re storing personally identifiable information (PII), you’ll want to implement security for your site. In this chapter, we’ll be discussing <em>HTTP Secure</em> (HTTPS), which establishes a foundation on which you can build a secure website, and authentication mechanisms, with a focus on third-party authentication.</p>

<p>Security is a big topic that could fill up an entire book.  For that reason, our focus is going to be on leveraging existing authentication modules.  Writing your own authentication system is certainly possible, but is a large and complicated undertaking.  Furthermore, there are good reasons to prefer a third-party login approach, which we will discuss later in this chapter.</p>






<section data-type="sect1" data-pdf-bookmark="HTTPS"><div class="sect1" id="idm45053577755320">
<h1>HTTPS</h1>

<p><a data-type="indexterm" data-primary="HTTPS (HTTP Secure)" id="ix_ch-18-security-asciidoc1"/><a data-type="indexterm" data-primary="security" data-secondary="HTTPS" id="ix_ch-18-security-asciidoc2"/>The first step in providing secure services is using HTTPS.  The nature of the internet makes it possible for a third party to intercept packets being transmitted between clients and servers.  HTTPS encrypts those packets, making it extremely <span class="keep-together">difficult</span> for an attacker to get access to the information being transmitted.  (I say “very difficult,” not “impossible,” because there’s no such thing as perfect security.  However, HTTPS is considered sufficiently secure for banking, corporate security, and <span class="keep-together">healthcare.)</span></p>

<p>You can think of HTTPS as sort of a foundation for securing your website.  It does not provide authentication, but it lays the groundwork for authentication.  For example, your authentication system probably involves transmitting a password; if that password is transmitted unencrypted, no amount of authentication sophistication will secure your system.  Security is as strong as the weakest link, and the first link in that chain is the network protocol.</p>

<p><a data-type="indexterm" data-primary="public key certificate" id="idm45053577748600"/><a data-type="indexterm" data-primary="SSL (public key) certificate" id="idm45053577747672"/>The HTTPS protocol is based on the server having a <em>public-key certificate</em>, sometimes called an SSL certificate.  The current standard format for SSL certificates is called <em>X.509</em>.  <a data-type="indexterm" data-primary="certificate authorities (CAs)" id="idm45053577745928"/>The idea behind certificates is that there are <em>certificate authorities</em> (CAs) that issue certificates.  <a data-type="indexterm" data-primary="trusted root certificates" id="idm45053577744648"/>A certificate authority makes <em>trusted root certificates</em> available to browser vendors.  Browsers include these trusted root certificates when you install a browser, and that’s what establishes the chain of trust between the CA and the browser.  For this chain to work, your server must use a certificate issued by a CA.</p>

<p>The upshot of this is that to provide HTTPS, you need a certificate from a CA, so how does one go about acquiring such a thing?  Broadly speaking, you can generate your own, get one from a free CA, or purchase one from a commercial CA.</p>








<section data-type="sect2" data-pdf-bookmark="Generating Your Own Certificate"><div class="sect2" id="idm45053577742392">
<h2>Generating Your Own Certificate</h2>

<p><a data-type="indexterm" data-primary="HTTPS (HTTP Secure)" data-secondary="generating your own certificate" id="idm45053577740888"/><a data-type="indexterm" data-primary="SSL (public key) certificate" data-secondary="generating your own" id="idm45053577739848"/>Generating your own certificate is easy, but generally suitable only for development and testing purposes (and possibly for intranet deployment).  Because of the hierarchical nature established by certificate authorities, browsers will trust only certificates generated by a known CA (and that’s probably not you).  If your website uses a certificate from a CA that’s not known to the browser, the browser will warn you in very alarming language that you’re establishing a secure connection with an unknown (and therefore untrusted) entity.  In development and testing, this is fine: you and your team know that you generated your own certificate, and you expect this behavior from browsers.  If you were to deploy such a website to production for consumption by the public, they would turn away in droves.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you control the distribution and installation of browsers, you can automatically install your own root certificate when you install the browser. This will prevent people using that browser from being warned when they connect to your website.  This is not trivial to set up, however, and applies only to environments in which you control the browser(s) being used.  Unless you have a very solid reason to take this approach, it’s generally more trouble than it’s worth.</p>
</div>

<p><a data-type="indexterm" data-primary="OpenSSL" id="idm45053577736040"/>To generate your own certificate, you’ll need an OpenSSL implementation. <a data-type="xref" href="#implement_info">Table 18-1</a> shows how to acquire an implementation.</p>
<table id="implement_info">
<caption><span class="label">Table 18-1. </span>Acquiring an implementation for different platforms</caption>
<thead>
<tr>
<th>Platform</th>
<th>Instructions</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>macOS</p></td>
<td><p><code>brew install openssl</code></p></td>
</tr>
<tr>
<td><p>Ubuntu, Debian</p></td>
<td><p><code>sudo apt-get install openssl</code></p></td>
</tr>
<tr>
<td><p>Other Linux</p></td>
<td><p>Download from <a href="http://www.openssl.org/source/;"><em class="hyperlink">http://www.openssl.org/source/;</em></a> extract tarball and follow instructions</p></td>
</tr>
<tr>
<td><p>Windows</p></td>
<td><p>Download from <a href="http://gnuwin32.sourceforge.net/packages/openssl.htm"><em class="hyperlink">http://gnuwin32.sourceforge.net/packages/openssl.htm</em></a></p></td>
</tr>
</tbody>
</table>
<div data-type="tip"><h6>Tip</h6>
<p>If you are a Windows user, you may need to specify the location of the OpenSSL configuration file, which can be tricky due to Windows pathnames.  The surefire way is to locate the <em>openssl.cnf</em> file (usually in the <em>share</em> directory of the installation), and before you run the <code>openssl</code> command, set the <code>OPENSSL_CNF</code> environment variable: <code>SET OPENSSL_CONF=openssl.cnf</code>.</p>
</div>

<p>Once you’ve installed OpenSSL, you can generate a private key and a public certificate:</p>

<pre data-type="programlisting">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout meadowlark.pem
	-out meadowlark.crt</pre>

<p>You will be asked for some details, such as your country code, city, and state, <a data-type="indexterm" data-primary="fully qualified domain name (FQDN)" id="idm45053577715880"/>fully qualified domain name (<em>FQDN</em>, also called <em>common name</em> or <em>fully qualified hostname</em>), and email address.  Since this certificate is for development/testing purposes, the values you provide are not particularly important (in fact, they’re all optional, but leaving them out will result in a certificate that will be regarded with even more suspicion by a browser).  The common name (FQDN) is what the browser uses to identify the domain.  So if you’re using <em>localhost</em>, you can use that for your FQDN, or you can use the IP address of the server, or the server name, if available.  The encryption will still work if the common name and domain you use in the URL don’t match, but your browser will give you an additional warning about the <span class="keep-together">discrepancy.</span></p>

<p>If you’re curious about the details of this command, you can read about them on the <a href="http://bit.ly/2q64psm">OpenSSL documentation page</a>.  It is worth pointing out that the <code>-nodes</code> option doesn’t have anything to do with Node, or even the plural word “nodes”: it actually means “no DES,” meaning the private key is not DES-encrypted.</p>

<p>The result of this command is two files, <em>meadowlark.pem</em> and <em>meadowlark.crt</em>.  <a data-type="indexterm" data-primary="PEM (Privacy-Enhanced Electronic Mail) file" id="idm45053577709192"/><a data-type="indexterm" data-primary="Privacy-enhanced Electronic Mail (PEM) file" id="idm45053577708360"/>The Privacy-Enhanced Electronic Mail (PEM) file is your private key, and should not be made available to the client.  The CRT file is the self-signed certificate that will be sent to the browser to establish a secure connection.</p>

<p>Alternatively, there are websites that will provide free self-signed certificates, such as <a href="http://bit.ly/354ClEL">this one</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Using a Free Certificate Authority"><div class="sect2" id="idm45053577741800">
<h2>Using a Free Certificate Authority</h2>

<p><a data-type="indexterm" data-primary="HTTPS (HTTP Secure)" data-secondary="using a free certificate authority" id="idm45053577704936"/><a data-type="indexterm" data-primary="SSL (public key) certificate" data-secondary="using a free certificate authority" id="idm45053577703896"/>HTTPS is based on trust, and it’s an unfortunate reality that one of the easiest ways to gain trust on the internet is to buy it.  And it’s not all snake oil, either: establishing the security infrastructure, insuring certificates, and maintaining relationships with browser vendors is expensive.</p>

<p>Buying a certificate is not your only legitimate option for production-ready certificates: <a data-type="indexterm" data-primary="Let's Encrypt" id="idm45053577701976"/><a href="https://letsencrypt.org">Let’s Encrypt</a>, a free, automated CA based on open source, has become a great option.  As a matter of fact, unless you’re already invested in an infrastructure that offers free or inexpensive certificates as its part of your hosting (AWS, for example), Let’s Encrypt is a great option.  The only downside to Let’s Encrypt is that the maximum lifetime for their certificates is 90 days.  This downside is offset by the fact that Let’s Encrypt makes it very easy to automatically renew the certificates, and recommends setting up an automated process to do so every 60 days to ensure the certificates don’t expire.</p>

<p>All of the major certificate vendors (such as Comodo and Symantec) offer free trial certificates that last anywhere from 30 to 90 days.  This is a valid option if you want to test a commercial certificate, but you will need to purchase a certificate before the trial period is up if you want to ensure continuity of service.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Purchasing a Certificate"><div class="sect2" id="idm45053577698984">
<h2>Purchasing a Certificate</h2>

<p><a data-type="indexterm" data-primary="SSL (public key) certificate" data-secondary="purchasing" id="ix_ch-18-security-asciidoc3"/>Currently, 90% of the approximately 50 root certificates distributed with every major browser are owned by four companies: Symantec (which purchased VeriSign), Comodo Group, Go Daddy, and GlobalSign.  Purchasing directly from a CA can be quite expensive: it usually starts around $300 per year (though some offer certificates for less than $100 per year).  A less expensive option is going through a reseller, from whom you can get an SSL certificate for as little as $10 per year or less.</p>

<p>It’s important to understand exactly what it is you’re paying for, and why you would pay $10, $150, or $300 (or more) for a certificate.  The first important point to understand is that there is no difference whatsoever in the level of encryption offered between a $10 certificate and a $1,500 certificate.  This is something that expensive certificate authorities would rather you not know: their marketing tries hard to obscure this fact.</p>

<p>If you choose to go with a commercial certificate vendor, I recommend the following three considerations in making your choice:</p>
<dl>
<dt>Customer support</dt>
<dd>
<p>If you ever have problems with your certificate, whether it be browser support (customers will let you know if your certificate is flagged by their browser as not trustworthy), installation issues, or renewal hassles, you will appreciate good <span class="keep-together">customer</span> support.  This is one reason you might purchase a more expensive certificate.  Often, your hosting provider will resell certificates, and in my experience, they provide a higher level of customer support, because they want to keep you as a hosting client as well.</p>
</dd>
<dt>Single-domain, multisubdomain, wildcard, and multidomain certificates</dt>
<dd>
<p><a data-type="indexterm" data-primary="single-domain certificates" id="idm45053577690152"/>The most inexpensive certificates are usually <em>single domain</em>.  That may not sound so bad, but remember that it means that if you purchase a certificate for <em>meadowlarktravel.com</em>, then the certificate will not work for <em>www.meadowlarktravel.com</em>, or vice versa.  For this reason, I tend to avoid single-domain certificates, though it can be a good option for the extremely budget conscious (you can always set up redirects to funnel requests to the proper domain).  <a data-type="indexterm" data-primary="multisubdomain certificates" id="idm45053577687496"/><em>Multisubdomain certificates</em> are good in that you can purchase a single certificate that covers <em class="keep-together">meadowlarktravel.com</em>, <em>www.meadowlark.com</em>, <em>blog.meadowlarktravel.com</em>, <em>shop.meadowlarktravel.com</em>, etc.  The downside is that you have to know in advance what subdomains you want to use.</p>

<p>If <a data-type="indexterm" data-primary="wildcard certificates" id="idm45053577683912"/>you see yourself adding or using different subdomains over the course of a year (that need to support HTTPS), you might be better off going with a <em>wildcard</em> certificate, which are generally more expensive.  But they will work for <em>any</em> subdomain, and you never have to specify what the subdomains are.</p>

<p>Lastly, there are <em>multidomain certificates</em>, which, like wildcard certificates, tend to be more expensive.  These certificates support whole multiple domains so, for example, you could have <em>meadowlarktravel.com</em>, <em>meadowlarktravel.us</em>, <em>meadowlarktravel.com</em>, and the <em>www</em> variants.</p>
</dd>
<dt>Domain, organization, and extended validation certificates</dt>
<dd>
<p>There are three kinds of certificates: domain, organization, and extended validation.  <a data-type="indexterm" data-primary="domain certificates" id="idm45053577677544"/><em>Domain certificates</em>, as the name indicates, simply provide confidence that you’re doing business with the <em>domain</em> that you think you are.  <a data-type="indexterm" data-primary="organization certificates" id="idm45053577675928"/><em>Organization certificates</em>, on the other hand, provide some assurance about the actual organization you’re dealing with.  They’re more difficult to get: there’s usually paperwork involved, and you must provide things like state and/or federal business name records, physical addresses, etc.  Different certificate vendors will require different documentation, so make sure to ask your certificate vendor what’s required to get one of these certificates.  <a data-type="indexterm" data-primary="extended valuation" id="idm45053577674424"/>Lastly are <em>extended validation certificates</em>, which are the Rolls Royce of SLL certificates.  They are like organization certificates in that they verify the existence of the organization, but they require a higher standard of proof, and can even require expensive audits to establish your data security practices (though this seems to be increasingly rare).  They can be had for as little as $150 for a single domain.</p>

<p>I recommend either the less expensive domain certificates or the extended validation certificates.  Organization certificates, while they verify the existence of your organization, are not displayed any differently than browsers, so in my experience, unless the user actually examines the certificate (which is rare), there will be no apparent difference between this and a domain certificate.  Extended validation certificates, on the other hand, usually display some clues to users that they are dealing with a legitimate business (such as the URL bar being displayed in green, and the organization name being displayed next to the SSL icon).</p>
</dd>
</dl>

<p><a data-type="indexterm" data-primary="certificate insurance" id="idm45053577671480"/>If you’ve dealt with SSL certificates before, you might be wondering why I didn’t mention certificate insurance.  I’ve omitted that price differentiator because essentially it’s insurance against something that’s almost impossible.  The idea is that if someone suffers financial loss due to a transaction on your website, and they can <em>prove it was due to inadequate encryption</em>, the insurance is there to cover your damages.  While it is certainly possible that, if your application involves financial transactions, someone may attempt to take legal action against you for financial loss, the likelihood of it being due to <span class="keep-together">inadequate</span> encryption is essentially zero.  If I were to attempt to seek damages from a company due to financial loss linked to their online services, the absolute last approach I would take is to attempt to prove that the SSL encryption was broken.  If you’re faced with two certificates that differ only in price and insurance coverage, buy the cheaper certificate.</p>

<p>The process of purchasing a certificate starts with the creation of a private key (as we did previously for the self-signed certificate).  <a data-type="indexterm" data-primary="certificate signing request (CSR)" id="idm45053577667720"/><a data-type="indexterm" data-primary="CSR (certificate signing request)" id="idm45053577667048"/>You will then generate a <em>certificate signing request</em> (CSR) that will be uploaded during the certificate purchase process (the certificate issuer will provide instructions for doing this).  Note that the certificate issuer never has access to your private key, nor is your private key transmitted over the internet, which protects the security of the private key.  The issuer will then send you the certificate, which will have an extension of <em>.crt</em>, <em>.cer</em>, or <em>.der</em> (the certificate will be in a format called Distinguished Encoding Rules or DER, hence the less common <em>.der</em> extension).  You will also receive any certificates in the certificate chain.  It is safe to email this certificate because it won’t work without the private key you generated.<a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc3" id="idm45053577663432"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Enabling HTTPS for Your Express App"><div class="sect2" id="idm45053577662664">
<h2>Enabling HTTPS for Your Express App</h2>

<p><a data-type="indexterm" data-primary="Express" data-secondary="enabling HTTPS for Express app" id="idm45053577661384"/><a data-type="indexterm" data-primary="HTTPS (HTTP Secure)" data-secondary="enabling for Express app" id="idm45053577660392"/>You can modify your Express app to serve your website over HTTPS.  In practice and in production, this is extremely uncommon, which we’ll learn about in the next section.  However, for advanced applications, testing, and your own understanding of HTTPS, it’s useful to know how to serve HTTPS.</p>

<p>Once you have your private key and certificate, using them in your app is easy.  Let’s revisit how we’ve been creating our server:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'port'</code><code class="p">),</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Express started in </code><code class="si">${</code><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'env'</code><code class="p">)</code><code class="si">}</code><code class="sb"> mode `</code> <code class="o">+</code>
    <code class="sb">`on port + </code><code class="si">${</code><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'port'</code><code class="p">)</code><code class="si">}</code><code class="sb">.`</code><code class="p">)</code>
<code class="p">})</code></pre>

<p>Switching over to HTTPS is simple.  I recommend that you put your private key and SSL cert in a subdirectory called <em>ssl</em> (though it’s quite common to keep it in your project root).  Then you just use the <code>https</code> module instead of <code>http</code>, and pass an <code>options</code> object along to the <code>createServer</code> method:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">https</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'https'</code><code class="p">)</code>
<code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fs'</code><code class="p">)</code>           <code class="c1">// usually at top of file</code>

<code class="c1">// ...the rest of your application configuration</code>

<code class="kr">const</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">key</code><code class="o">:</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFileSync</code><code class="p">(</code><code class="nx">__dirname</code> <code class="o">+</code> <code class="s1">'/ssl/meadowlark.pem'</code><code class="p">),</code>
  <code class="nx">cert</code><code class="o">:</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFileSync</code><code class="p">(</code><code class="nx">__dirname</code> <code class="o">+</code> <code class="s1">'/ssl/meadowlark.crt'</code><code class="p">),</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">port</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">3000</code>
<code class="nx">https</code><code class="p">.</code><code class="nx">createServer</code><code class="p">(</code><code class="nx">options</code><code class="p">,</code> <code class="nx">app</code><code class="p">).</code><code class="nx">listen</code><code class="p">(</code><code class="nx">port</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Express started in </code><code class="si">${</code><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'env'</code><code class="p">)</code><code class="si">}</code><code class="sb"> mode `</code> <code class="o">+</code>
    <code class="sb">`on port + </code><code class="si">${</code><code class="nx">port</code><code class="si">}</code><code class="sb">.`</code><code class="p">)</code>
<code class="p">})</code></pre>

<p>That’s all there is to it.  Assuming you’re still running your server on port 3000, you can now connect to <em><a href="https://localhost:3000"><em class="hyperlink">https://localhost:3000</em></a></em>.  If you try to connect to <em><a href="http://localhost:3000"><em class="hyperlink">http://localhost:3000</em></a></em>, it will simply time out.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="A Note on Ports"><div class="sect2" id="idm45053577497512">
<h2>A Note on Ports</h2>

<p><a data-type="indexterm" data-primary="HTTPS (HTTP Secure)" data-secondary="ports for" id="idm45053577496136"/><a data-type="indexterm" data-primary="ports" data-secondary="HTTPS" id="idm45053577494936"/>Whether you know it or not, when you visit a website, you’re <em>always</em> connecting to a specific port, even though it’s not specified in the URL.  <a data-type="indexterm" data-primary="HTTP" data-secondary="default port for" id="idm45053577493480"/>If you don’t specify a port, port 80 is assumed for HTTP.  As a matter of fact, most browsers will simply not display the port number if you explicitly specify port 80.  For example, navigate to <em><a href="http://www.apple.com:80"><em class="hyperlink">http://www.apple.com:80</em></a></em>; chances are, when the page loads, the browser will simply strip off the <em>:80</em>.  It’s still connecting on port 80; it’s just implicit.</p>

<p><a data-type="indexterm" data-primary="HTTPS (HTTP Secure)" data-secondary="default port for" id="idm45053577490408"/>Similarly, there’s a standard port for HTTPS, 443.  Browser behavior is similar: if you connect to <em><a href="https://www.google.com:443"><em class="hyperlink">https://www.google.com:443</em></a></em>, most browsers will simply not display the <em class="keep-together">:443</em>, but that’s the port they’re connecting over.</p>

<p>If you’re not using port 80 for HTTP or port 443 for HTTPS, you’ll have to explicitly specify the port <em>and</em> the protocol to connect correctly.  There’s no way to run HTTP and HTTPS on the same port (technically, it’s possible, but there’s no good reason to do it, and the implementation would be very complicated).</p>

<p>If you want to run your HTTP app on port 80, or your HTTPS app on port 443 so you don’t have to specify the port explicitly, you have two things to consider.  First is that many systems already have a default web server running on port 80.</p>

<p>The other thing to know is that on most operating systems, ports 1–1023
require elevated privileges to open.  For
example, <a data-type="indexterm" data-primary="Linux" data-secondary="port access" id="idm45053577484712"/><a data-type="indexterm" data-primary="macOS" data-secondary="port access" id="idm45053577483736"/>on a Linux or macOS machine, if you attempt to start your app on
port 80, it will probably fail with an <code>EACCES</code> error.  To run on port 80
or 443 (or any port under 1024), you’ll need to elevate your privileges by
using the <code>sudo</code> command.  If you don’t have administrator rights, you will
be unable to start the server directly on port 80 or 443.</p>

<p>Unless you’re managing your own servers, you probably don’t have root access to your hosted account: so what happens when you want to run on port 80 or 443?  Generally, hosting providers have some kind of proxy service that runs with elevated privileges that will pass requests through to your app, which is running on a nonprivileged port.  We’ll learn more about this in the next section.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="HTTPS and Proxies"><div class="sect2" id="idm45053577480520">
<h2>HTTPS and Proxies</h2>

<p><a data-type="indexterm" data-primary="HTTPS (HTTP Secure)" data-secondary="proxies and" id="idm45053577478920"/><a data-type="indexterm" data-primary="proxies" id="idm45053577477944"/>As we’ve seen, it’s very easy to use HTTPS with Express, and for development, it will work fine.  However, when you want to scale your site out to handle more traffic, you will want to use a proxy server such as NGINX (see <a data-type="xref" href="ch12.xhtml#ch_production_concerns">Chapter 12</a>).  If your site is running in a shared hosting environment, it is almost certain that there will be a proxy server that will route requests to your application.</p>

<p>If you’re using a proxy server, then the client (the user’s browser) will communicate with the <em>proxy server</em>, not your server.  The proxy server, in turn, will most likely communicate with your app over regular HTTP (since your app and the proxy server will be running together on a trusted network).  You will often hear people say that the HTTPS <em>terminates</em> at the proxy server, or that the proxy is performing “SSL termination.”</p>

<p>For the most part, once you or your hosting provider has correctly configured the proxy server to handle HTTPS requests, you won’t need to do any additional work.  The exception to that rule is if your application needs to handle both secure and insecure requests.</p>

<p>There are three solutions to this problem.  The first is simply to configure your proxy to redirect all HTTP traffic to HTTPS, in essence forcing all communication with your application to be over HTTPS.  This approach is becoming much more common, and it’s certainly an easy solution to the problem.</p>

<p>The second approach is to somehow communicate the protocol used in the client-proxy communication to the server.  <a data-type="indexterm" data-primary="X-Forwarded-Proto header" id="idm45053577472360"/>The usual way to communicate this is through the <code>X-Forwarded-Proto</code> header.  <a data-type="indexterm" data-primary="NGINX" id="idm45053577471176"/>For example, to set this header in NGINX:</p>

<pre data-type="programlisting">proxy_set_header X-Forwarded-Proto $scheme;</pre>

<p>Then, in your app, you could test to see if the protocol was HTTPS:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c1">// the following is essentially</code>
  <code class="c1">// equivalent to: if(req.secure)</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">headers</code><code class="p">[</code><code class="s1">'x-forwarded-proto'</code><code class="p">]</code> <code class="o">===</code> <code class="s1">'https'</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'line is secure'</code><code class="p">)</code>
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'you are insecure!'</code><code class="p">)</code>
  <code class="p">}</code>
<code class="p">})</code></pre>
<div data-type="caution"><h6>Caution</h6>
<p>In NGINX, there is a separate <code>server</code> configuration block for HTTP and HTTPS.  If you fail to set the <code>X-Forwarded-Protocol</code> in the configuration block corresponding to HTTP, you open yourself up to the possibility of a client spoofing the header and thereby fooling your application into thinking that the connection is secure even though it isn’t.  If you take this approach, make sure you <em>always</em> set the <code>X-Forwarded-Protocol</code> header.</p>
</div>

<p>When you’re using a proxy, Express provides some convenience properties
that make the proxy more “transparent” (as if you weren’t using one,
without sacrificing the benefits).  To take advantage of that, tell
Express to trust the proxy by using <code>app.enable('trust
proxy')</code>.  Once you do, <code>req.protocol</code>, <code>req.secure</code>, and <code>req.ip</code>
will refer to the client’s connection to the proxy, not to your app.<a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc2" id="idm45053577431912"/><a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc1" id="idm45053577373944"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Cross-Site Request Forgery"><div class="sect1" id="idm45053577754824">
<h1>Cross-Site Request Forgery</h1>

<p><a data-type="indexterm" data-primary="cross-site request forgery (CSRF)" id="idm45053577371976"/><a data-type="indexterm" data-primary="security" data-secondary="cross-site request forgery attacks" id="idm45053577371304"/><em>Cross-site request forgery</em> (CSRF) attacks exploit the fact that users generally trust their browser and visit multiple sites in the same session.  In a CSRF attack, script on a malicious site makes requests of another site: if you are logged in on the other site, the malicious site can successfully access secure data from another site.</p>

<p>To prevent CSRF attacks, you must have a way to make sure a request
legitimately came from your website.  The way we do this is to pass a
unique token to the browser.  When the browser then submits a form, the
server checks to make sure the token matches.  <a data-type="indexterm" data-primary="csurf middleware" id="idm45053577368760"/>The <code>csurf</code>
middleware will handle the token creation and
verification for you; all you’ll have to do is make sure the token is
included in requests to the server.  Install the <code>csurf</code> middleware (<code>npm
install csurf</code>); then link it in and add a token to <code>res.locals</code>.
Make sure you link in the <code>csurf</code> middleware after you link in
<code>body-parser</code>, <code>cookie-parser</code>, and <code>express-session</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// this must come after we link in body-parser,</code>
<code class="c1">// cookie-parser, and express-session</code>
<code class="kr">const</code> <code class="nx">csrf</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'csurf'</code><code class="p">)</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">csrf</code><code class="p">({</code> <code class="nx">cookie</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}))</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">((</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">locals</code><code class="p">.</code><code class="nx">_csrfToken</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">csrfToken</code><code class="p">()</code>
  <code class="nx">next</code><code class="p">()</code>
<code class="p">})</code></pre>

<p>The <code>csurf</code> middleware adds the <code>csrfToken</code> method to the request object.  We don’t have to assign it to <code>res.locals</code>; we could just pass <code>req.csrfToken()</code> explicitly to every view that needs it, but this is generally less work.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Note that the package itself is called <code>csurf</code>, but most of the variables and methods are <code>csrf</code>, without the “u.”  It’s easy to get tripped up here, so mind your vowels!</p>
</div>

<p>Now on all of your forms (and AJAX calls), you’ll have to provide a field called <code>_csrf</code>, which must match the generated token.  Let’s see how we would add this to one of our forms:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;form</code> <code class="na">action=</code><code class="s">"/newsletter"</code> <code class="na">method=</code><code class="s">"POST"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;input</code> <code class="na">type=</code><code class="s">"hidden"</code> <code class="na">name=</code><code class="s">"_csrf"</code> <code class="na">value=</code><code class="s">"{{_csrfToken}}"</code><code class="nt">&gt;</code>
  Name: <code class="nt">&lt;input</code> <code class="na">type=</code><code class="s">"text"</code> <code class="na">name=</code><code class="s">"name"</code><code class="nt">&gt;&lt;br&gt;</code>
  Email: <code class="nt">&lt;input</code> <code class="na">type=</code><code class="s">"email"</code> <code class="na">name=</code><code class="s">"email"</code><code class="nt">&gt;&lt;br&gt;</code>
  <code class="nt">&lt;button</code> <code class="na">type=</code><code class="s">"submit"</code><code class="nt">&gt;</code>Submit<code class="nt">&lt;/button&gt;</code>
<code class="nt">&lt;/form&gt;</code></pre>

<p>The <code>csurf</code> middleware will handle the rest: if the body contains fields, but no valid <code>_csrf</code> field, it will raise an error (make sure you have an error route in your middleware!).  Go ahead and remove the hidden field and see what happens.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you have an API, you probably don’t want the <code>csurf</code> middleware interfering with it.  If you want to restrict access to your API from other websites, you should look into the “API key” functionality of an API library like <code>connect-rest</code>.  To prevent <code>csurf</code> from interfering with your middleware, link it in before you link in <code>csurf</code>.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Authentication"><div class="sect1" id="idm45053577372792">
<h1>Authentication</h1>

<p><a data-type="indexterm" data-primary="authentication" id="ix_ch-18-security-asciidoc4"/><a data-type="indexterm" data-primary="security" data-secondary="authentication" id="ix_ch-18-security-asciidoc5"/>Authentication is a big, complicated topic.  Unfortunately, it’s also a vital part of most nontrivial web applications.  The most important piece of wisdom I can impart to you is <em>don’t try to do it yourself</em>.  If you look at your business card and it doesn’t say “Security Expert,” you probably aren’t prepared for the complex considerations involved in designing a secure authentication system.</p>

<p>I’m not saying that you shouldn’t try to understand the security systems in your application.  I’m just recommending that you don’t try to build it yourself.  Feel free to study the open source code of the authentication techniques I’m going to recommend.  It will certainly give you some insight as to why you might not want to take on this task unaided!</p>








<section data-type="sect2" data-pdf-bookmark="Authentication Versus Authorization"><div class="sect2" id="idm45053577200600">
<h2>Authentication Versus Authorization</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="authorization versus" id="idm45053577199192"/><a data-type="indexterm" data-primary="authorization" data-secondary="authentication versus" id="idm45053577198216"/>While the two terms are often used interchangeably, there is a difference.  <em class="keep-together">Authentication</em> refers to verifying users’ identities.  That is, they are who they say they are.  <em>Authorization</em> refers to determining what a user is authorized to access, modify, or view.  For example, customers might be authorized to access their account information, whereas a Meadowlark Travel employee would be authorized to access another person’s account information or sales notes.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Authentication is often abbreviated as <em>authN</em> and “authorization” as <em>authZ</em>.</p>
</div>

<p>Usually (but not always), authentication comes first, and then authorization is determined.  Authorization can be very simple (authorized/not authorized), broad (user/administrator), or very fine-grained, specifying read, write, delete, and update privileges against different account types.  The complexity of your authorization system is dependent on the type of application you’re writing.</p>

<p>Because authorization is so dependent on the details of your application, I’ll be giving only a rough outline in this book, using a very broad authentication scheme (customer/employee). I will often use the abbreviation “auth,” but only when it is clear from the context whether it means “authentication” or “authorization,” or when it doesn’t matter.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The Problem with Passwords"><div class="sect2" id="idm45053577191928">
<h2>The Problem with Passwords</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="passwords" id="idm45053577190824"/><a data-type="indexterm" data-primary="passwords" id="idm45053577189848"/>The problem with passwords is that every security system is only as strong as its weakest link.  And passwords require the user to invent a password—and there’s your weakest link.  Humans are notoriously bad at coming up with secure passwords.  In an analysis of security breaches in 2018, the most popular password is “123456.”  “password” is second.  Even in the security conscious year of 2018, people are still choosing abysmally bad passwords.  Having password policies requiring, for example, a capital letter, a number, and a punctuation mark is just going to result in a password of “Password1!”.</p>

<p>Even analyzing passwords against a list of common passwords doesn’t do much to stop the problem.  Then people start writing down their higher-quality passwords on notepads, leaving them in unencrypted files on their computers, or emailing them to <span class="keep-together">themselves.</span></p>

<p>At the end of the day, it’s a problem that you, the app designer, cannot do much to fix.  However, there are things you can do that promote more secure passwords.  One is to pass the buck and rely on a third party for authentication.  The other is to make your login system friendly to password management services, like 1Password, Bitwarden, and LastPass.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Third-Party Authentication"><div class="sect2" id="idm45053577186152">
<h2>Third-Party Authentication</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="third-party" id="idm45053577184696"/><a data-type="indexterm" data-primary="third-party authentication" id="idm45053577183720"/>Third-party authentication takes advantage of the fact that pretty much everyone on the internet has an account on at least one major service, such as Google, Facebook, Twitter, or LinkedIn.  All of these services provide a mechanism to authenticate and identify your users through their service.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="indexterm" data-primary="delegated authentication" id="idm45053577181688"/><a data-type="indexterm" data-primary="federated authentication" id="idm45053577180968"/>Third-party authentication is often referred to as <em>federated</em> <em class="keep-together">authentication</em> or <em>delegated authentication</em>.  The terms are largely interchangeable, though federated authentication is usually associated with Security Assertion Markup Language (SAML) and OpenID, and delegated authentication is often associated with OAuth.</p>
</div>

<p>Third-party authentication has three major advantages.  First, your authentication burden is lowered.  You do not have to worry about authenticating individual users, only interacting with a trusted third party.  The second advantage is that it reduces <em>password fatigue</em>: the stress associated with having too many accounts.  I use <a href="http://lastpass.com">LastPass</a>, and I just checked my password vault: I have almost 400 passwords.  As a technology professional, I may have more than your average internet user, but it’s not uncommon for even a casual internet user to have dozens or even hundreds of accounts.  Lastly, third-party authentication is <em>frictionless</em>: it allows your users to start using your site more quickly, with credentials they already have.  Often, if users see that they have to create yet <em>another</em> username and password, they will simply move on.</p>

<p>If you don’t use a password manager, the chances are, you’re using the same password for most of those sites (most people have a “secure” password they use for banking and the like, and an “insecure” password they use for everything else).  The problem with this approach is that if even <em>one</em> of the sites you use that password for is breached, and your password becomes known, then hackers will try using that same password with other services.  It’s like putting all of your eggs in one basket.</p>

<p>Third-party authentication has its downsides.  Hard as it is to believe, there <em>are</em> folks out there who don’t have an account on Google, Facebook, Twitter, or LinkedIn.  Then, among the people who <em>do</em> have such accounts, suspicion (or a desire for privacy) may make them unwilling to use those credentials to log onto your website.  Many websites solve this particular problem by encouraging users to use an existing account, but those who don’t have them (or are unwilling to use them to access your service) can create a new login for your service.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Storing Users in Your Database"><div class="sect2" id="idm45053577171944">
<h2>Storing Users in Your Database</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="storing user records in database" id="idm45053577170648"/><a data-type="indexterm" data-primary="databases" data-secondary="storing user records in" id="idm45053577169608"/>Whether or not you rely on a third party to authenticate your users, you will want to store a record of users in your own database.  For example, if you’re using Facebook for authentication, that only verifies a user’s identity.  If you need to save settings specific to that user, you can’t reasonably use Facebook for that: you have to store information about that user in your own database.  Also, you probably want to associate an email address with your users, and they may not wish to use the same email address they use for Facebook (or whatever third-party authentication service you use).  Lastly, storing user information in your database allows you to perform authentication yourself, should you wish to provide that option.</p>

<p>So let’s create a model for our users, <em>models/user.js</em>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">mongoose</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'mongoose'</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">userSchema</code> <code class="o">=</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Schema</code><code class="p">({</code>
  <code class="nx">authId</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>
  <code class="nx">name</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>
  <code class="nx">email</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>
  <code class="nx">role</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>
  <code class="nx">created</code><code class="o">:</code> <code class="nb">Date</code><code class="p">,</code>
<code class="p">})</code>

<code class="kr">const</code> <code class="nx">User</code> <code class="o">=</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">model</code><code class="p">(</code><code class="s1">'User'</code><code class="p">,</code> <code class="nx">userSchema</code><code class="p">)</code>
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">User</code></pre>

<p>And modify <em>db.js</em> with the appropriate abstractions (if you’re using PostgreSQL, I’ll leave it as an exercise to hook up this abstraction):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">User</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./models/user'</code><code class="p">)</code>

<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>
  <code class="c1">//...</code>
  <code class="nx">getUserById</code><code class="o">:</code> <code class="nx">async</code> <code class="nx">id</code> <code class="o">=&gt;</code> <code class="nx">User</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">id</code><code class="p">),</code>
  <code class="nx">getUserByAuthId</code><code class="o">:</code> <code class="nx">async</code> <code class="nx">authId</code> <code class="o">=&gt;</code> <code class="nx">User</code><code class="p">.</code><code class="nx">findOne</code><code class="p">({</code> <code class="nx">authId</code> <code class="p">}),</code>
  <code class="nx">addUser</code><code class="o">:</code> <code class="nx">async</code> <code class="nx">data</code> <code class="o">=&gt;</code> <code class="k">new</code> <code class="nx">User</code><code class="p">(</code><code class="nx">data</code><code class="p">).</code><code class="nx">save</code><code class="p">(),</code>
<code class="p">}</code></pre>

<p><a data-type="indexterm" data-primary="MongoDB" data-secondary="storing users in database" id="idm45053577087368"/>Recall that every object in a MongoDB database has its own unique ID, stored in its <code>_id</code> property.  However, that ID is controlled by MongoDB, and we need some way to map a user record to a third-party ID, so we have our own ID property, called <code>authId</code>.  Since we’ll be using multiple authentication strategies, that ID will be a combination of a strategy type and a third-party ID, to prevent collisions.  For example, a Facebook user might have an <code>authId</code> of <code>facebook:525764102</code>, whereas a Twitter user would have an <code>authId</code> of <code>twitter:376841763</code>.</p>

<p>We will be using two roles in our example: “customer” and “employee.”</p>
</div></section>













<section data-type="sect2" class="pagebreak-before" data-pdf-bookmark="Authentication Versus Registration and the User Experience"><div class="sect2" id="idm45053577000168">
<h2>Authentication Versus Registration and the User Experience</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="registration versus" id="idm45053576998648"/><a data-type="indexterm" data-primary="registration" data-secondary="authentication versus" id="idm45053576997672"/>Authentication refers to verifying a user’s identity, either with a trusted third party, or through credentials you’ve provided the user (such as a username and password).  <span class="keep-together">Registration</span> is the process by which a user gets an account on your site (from our perspective, registration is when we create a user record in the database).</p>

<p><a data-type="indexterm" data-primary="registration" data-secondary="user experience and" id="idm45053576995304"/><a data-type="indexterm" data-primary="user experience, registration and" id="idm45053576994328"/>When users join your site for the first time, it should be clear to them that they’re registering.  <a data-type="indexterm" data-primary="third-party authentication" id="idm45053576993448"/>Using a third-party authentication system, we could register them without their knowledge if they successfully authenticate through the third party.  This is not generally considered a good practice, and it should be clear to users that they’re registering for your site (whether they’re authenticating through a third party or not), and provide a clear mechanism for canceling their membership.</p>

<p><a data-type="indexterm" data-primary="third-party confusion" id="idm45053576992008"/>One user experience situation to consider is “third-party confusion.”  If a user registers in January for your service using Facebook, then returns in July, and is confronted with a screen offering the choices of logging in with Facebook, Twitter, Google, or LinkedIn, the user may very well have forgotten what registration service was originally used.  This is one of the pitfalls of third-party authentication, and there is precious little you can do about it.  It’s another good reason to ask the user to provide an email address: this way, you can give the user an option to look up their account by email, and send an email to that address specifying what service was used for authentication.</p>

<p>If you feel that you have a firm grasp on the social networks your users use, you can ease this problem by having a primary authentication service.  For example, if you feel pretty confident that the majority of your users have a Facebook account, you could have a big button that says, “Log in with Facebook.”  Then, using smaller buttons or even just text links, say, “or log in with Google, Twitter, or LinkedIn.”  This approach can cut down on the instance of third-party confusion.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Passport"><div class="sect2" id="idm45053576989432">
<h2>Passport</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="Passport for" id="ix_ch-18-security-asciidoc6"/><a data-type="indexterm" data-primary="Passport" data-secondary="authentication with" id="ix_ch-18-security-asciidoc7"/><em>Passport</em> is a very popular and robust authentication module for Node/Express.  It is not tied to any one authentication mechanism; rather, it is based on the idea of pluggable authentication <em>strategies</em> (including a local strategy if you don’t want to use third-party authentication).  Understanding the flow of authentication information can be overwhelming, so we’ll start with just one authentication mechanism and add more later.</p>

<p>The detail that’s important to understand is that, with third-party authentication, your app <em>never receives a password</em>.  That is handled entirely by the third party.  This is a good thing: it’s putting the burden of secure handling and storage of passwords on the third party.<sup><a data-type="noteref" id="idm45053576983016-marker" href="ch18.xhtml#idm45053576983016">1</a></sup></p>

<p>The whole process, then, relies on redirects (it must, if your application is never to receive the user’s third-party password).  At first, you might be confused about why you can pass <em>localhost</em> URLs to the third party and still successfully authenticate (after all, the third-party server handling your request doesn’t know about <em>your</em> <em>localhost</em>).  It works because the third party simply instructs <em>your browser</em> to redirect, and your browser is inside your network, and can therefore redirect to local addresses.</p>

<p>The basic flow is shown in <a data-type="xref" href="#img_security_third_party_authentication">Figure 18-1</a>.  This diagram shows the important flow of functionality, making it clear that the authentication actually occurs on the third-party website.  Enjoy the simplicity of the diagram—things are about to get a lot more <span class="keep-together">complicated.</span></p>

<p>When you use Passport, there are four steps that your app will be responsible for.  Consider a more detailed view of the third-party authentication flow, as shown in <a data-type="xref" href="#img_security_third_party_authentication_detail">Figure 18-2</a>.</p>

<figure><div id="img_security_third_party_authentication" class="figure">
<img src="Images/bwne_1801.png" alt="Third Party Authentication Flow" width="824" height="705"/>
<h6><span class="label">Figure 18-1. </span>Third-party authentication flow</h6>
</div></figure>

<p>For simplicity, we are using Meadowlark Travel to represent your app, and Facebook for the third-party authentication mechanism. <a data-type="xref" href="#img_security_third_party_authentication_detail">Figure 18-2</a> illustrates how the user goes from the login page to the secure Account Info page (the Account Info page is just used for illustration purposes: this could be any page on your website that requires authentication).</p>

<p>This diagram shows detail you don’t normally think about, but is important to understand in this context.  In particular, when you visit a URL, <em>you</em> aren’t making the request of the server: the browser is actually doing that.  That said, the browser can do three things: make an HTTP request, display the response, and perform a redirect (which is essentially making another request and displaying another response…which in turn could be another redirect).</p>

<p>In the Meadowlark column, you can see the four steps your application is actually responsible for.  Fortunately, we’ll be leveraging Passport (and pluggable strategies) to perform the details of those steps; otherwise, this book would be much, much longer.</p>

<figure><div id="img_security_third_party_authentication_detail" class="figure">
<img src="Images/bwne_1802.png" alt="Detailed View of Third Party Authentication Flow" width="1567" height="1493"/>
<h6><span class="label">Figure 18-2. </span>Detailed view of third-party authentication flow</h6>
</div></figure>

<p>Before we get into implementation details, let’s consider each of the steps in a little more detail:</p>
<dl>
<dt>Login page</dt>
<dd>
<p>The login page is where the user can choose the login method.  If you’re using a third-party authentication, it’s usually just a button or a link.  If you’re using local authentication, it will include username and password fields.  If the user attempts to access a URL requiring authentication (such as <code>/account</code> in our example) without being logged in, this is probably the page you will want to redirect to (alternatively, you could redirect to a Not Authorized page with a link to the login page).</p>
</dd>
<dt>Construct authentication request</dt>
<dd>
<p>In this step, you’ll be constructing a request to be sent to a third party (via a redirect).  The details of this request are complicated and specific to the authentication <span class="keep-together">strategy.</span>  Passport (and the strategy plugin) will be doing all the heavy lifting here.  The auth request includes protection against man-in-the-middle attacks, as well as other vectors an attacker might exploit.  Usually the auth request is short-lived, so you can’t store it and expect to use it later: this helps prevent attacks by limiting the window in which an attacker has time to act.  This is where you can request additional information from the third-party authorization mechanism.  For example, it’s common to request the user’s name, and possibly email address.  Keep in mind that the more information you request from users, the less likely they are to authorize your application.</p>
</dd>
<dt>Verify authentication response</dt>
<dd>
<p>Assuming the user authorized your application, you’ll get back a valid auth response from the third party, which is proof of the user’s identity.  Once again, the details of this validation are complicated and will be handled by Passport (and the strategy plugin).  If the auth response indicates that the user is not authorized (if invalid credentials were entered, or your application wasn’t authorized by the user), you would then redirect to an appropriate page (either back to the login page, or to a Not Authorized or Unable to Authorize page).  Included in the auth response will be an ID for the user that is unique <em>to that specific third party</em>, as well as any additional details you requested in step 2.  To enable step 4, we must “remember” that the user is authorized.  The usual way to do this is to set a session variable containing the user’s ID, indicating that this session has been authorized (cookies can also be used, though I recommend using sessions).</p>
</dd>
<dt>Verify authorization</dt>
<dd>
<p>In step 3, we stored a user ID in the session.  The presence of that user ID allows us to retrieve a user object from the database that contains information about what the user is authorized to do.  In this manner, we don’t have to authenticate with the third party for every request (which would result in a slow and painful user experience).  This task is simple, and we no longer need Passport for this: we have our own user object that contains our own authentication rules.  (If that object isn’t available, it indicates the request isn’t authorized, and we can redirect to the login or Not Authorized page.)</p>
</dd>
</dl>
<div data-type="tip"><h6>Tip</h6>
<p>Using Passport for authentication is a fair amount of work, as you’ll see in this chapter.  However, authentication is an important part of your application, and I feel that it is wise to invest some time in getting it right.  <a data-type="indexterm" data-primary="LockIt" id="idm45053576928376"/>There are projects such as <a href="http://bit.ly/lock_it">LockIt</a> that try to provide a more “off the shelf” solution.  <a data-type="indexterm" data-primary="Auth0" id="idm45053576926888"/>Another increasingly popular option is <a href="https://auth0.com">Auth0</a>, which is very robust but isn’t as easy to set up as LockIt.  To make the most effective use of LockIt or Auth0 (or similar solutions), however, it behooves you to understand the details of authentication and authorization, which is what this chapter is designed to do.  Also, if you ever need to customize an authentication solution, Passport is a great place to start.</p>
</div>










<section data-type="sect3" data-pdf-bookmark="Setting up Passport"><div class="sect3" id="idm45053576924760">
<h3>Setting up Passport</h3>

<p><a data-type="indexterm" data-primary="Facebook" data-secondary="as authentication provider" id="ix_ch-18-security-asciidoc8"/><a data-type="indexterm" data-primary="Facebook app" id="ix_ch-18-security-asciidoc9"/><a data-type="indexterm" data-primary="Passport" data-secondary="setup" id="ix_ch-18-security-asciidoc10"/>To keep things simple, we’ll start with a single authentication provider.  Arbitrarily, we’ll choose Facebook.  Before we can set up Passport and the Facebook strategy, we’ll need to do a little configuration in Facebook.  For Facebook authentication, you’ll need a <em>Facebook app</em>.  If you already have a suitable Facebook app, you can use that, or you can create a new one specifically for authentication.  If possible, you should use your organization’s official Facebook account to create the app.  That is, if you worked for Meadowlark Travel, you would use the Meadowlark Travel Facebook account to create the app (you can always add your personal Facebook account as an administrator of the app for ease  of administration).  For testing purposes, it’s fine to use your own Facebook account, but using a personal account for production will appear unprofessional and suspicious to your users.</p>

<p>The details of Facebook app administration seem to change fairly frequently, so I am not going to explain the details here.  Consult the <a href="http://bit.ly/372bc7c">Facebook developer documentation</a> if you need details on creating and administering your app.</p>

<p>For development and testing purposes, you will need to associate the development/testing domain name with the app.  Facebook allows you to use <em>localhost</em> (and port numbers), which is great for testing purposes.  Alternatively, you can specify a local IP address, which can be helpful if you’re using a virtualized server, or another server on your network for testing.  The important thing is that the URL you enter into your browser to test the app (for example, <em>http://localhost:3000</em>) is associated with the Facebook app.  Currently, you can associate only one domain with your app: if you need to be able to use multiple domains, you will have to create multiple apps (for example, you could have Meadowlark Dev, Meadowlark Test, and Meadowlark Staging; your production app can simply be called Meadowlark Travel).</p>

<p>Once you’ve configured your app, you will need its unique app ID, and its app secret, both of which can be found on the Facebook app management page for that app.</p>
<div data-type="tip"><h6>Tip</h6>
<p>One of the biggest frustrations you’ll probably face is receiving a message from Facebook such as “Given URL is not allowed by the Application configuration.”  This indicates that the hostname and port in the callback URL do not match what you’ve configured in your app.  If you look at the URL in your browser, you will see the encoded URL, which should give you a clue.  For example, if I’m using 192.168.0.103:3443, and I get that message, I look at the URL.  If I see <em>redirect_uri=https%3A%2F%2F192.68.0.103%3A3443%2F</em>
<em>auth%2Ffacebook%2Fcallback</em> in the querystring, I can quickly spot the mistake: I used 68 instead of 168 in my hostname.</p>
</div>

<p>Now let’s install Passport and the Facebook authentication strategy:</p>

<pre data-type="programlisting">npm install passport passport-facebook</pre>

<p>Before we’re done, there’s going to be a lot of authentication code
(especially if we’re supporting multiple strategies), and we don’t want to
clutter up <em>meadowlark.js</em> with all that code.  Instead, we’ll create a
module called <em>lib/auth.js</em>.  This is going to be a large file, so we’re
going to take it piece by piece (see <em>ch18</em> in the companion repo for the
finished example).  We’ll start with the imports and two methods that
Passport requires, <code>serializeUser</code> and <code>deserializeUser</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">passport</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'passport'</code><code class="p">)</code>
<code class="kr">const</code> <code class="nx">FacebookStrategy</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'passport-facebook'</code><code class="p">).</code><code class="nx">Strategy</code>

<code class="kr">const</code> <code class="nx">db</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'../db'</code><code class="p">)</code>

<code class="nx">passport</code><code class="p">.</code><code class="nx">serializeUser</code><code class="p">((</code><code class="nx">user</code><code class="p">,</code> <code class="nx">done</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">done</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">user</code><code class="p">.</code><code class="nx">_id</code><code class="p">))</code>

<code class="nx">passport</code><code class="p">.</code><code class="nx">deserializeUser</code><code class="p">((</code><code class="nx">id</code><code class="p">,</code> <code class="nx">done</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">db</code><code class="p">.</code><code class="nx">getUserById</code><code class="p">(</code><code class="nx">id</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="nx">done</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">user</code><code class="p">))</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">err</code> <code class="o">=&gt;</code> <code class="nx">done</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="kc">null</code><code class="p">))</code>
<code class="p">})</code></pre>

<p>Passport uses <code>serializeUser</code> and <code>deserializeUser</code> to map requests to the authenticated user, allowing you to use whatever storage method you want.  In our case, we are only going to store our database ID (the <code>_id</code> property) in the session.  The way we’re using the ID here makes “serialize” and “deserialize” soft of into misnomers: we’re actually just storing a user ID in the session.  Then, when needed, we can get a user object by finding that ID in the database.</p>

<p>Once these two methods are implemented, as long as there is an active session, and the user has successfully authenticated, <code>req.session.passport.user</code> will be the corresponding user object as retrieved from the database.</p>

<p>Next, we’re going to choose what to export.  To enable Passport’s functionality, we’ll need to do two distinct activities: initialize Passport, and register routes that will handle authentication and the redirected callbacks from our third-party authentication services.  We don’t want to combine these two in one function because in our main application file, we may want to choose when Passport is linked into the middleware chain (remember that order is significant when adding middleware).  So, instead of having our module export function that does either of these things, we’re going to have it return a function that returns an object that has the methods we need.  Why not just return an object to start with?  Because we need to bake in some configuration values.  Also, since we need to link the Passport middleware into our application, a function is an easy way to pass in the Express application object:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">(</code><code class="nx">app</code><code class="p">,</code> <code class="nx">options</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c1">// if success and failure redirects aren't specified,</code>
  <code class="c1">// set some reasonable defaults</code>
  <code class="k">if</code><code class="p">(</code><code class="o">!</code><code class="nx">options</code><code class="p">.</code><code class="nx">successRedirect</code><code class="p">)</code> <code class="nx">options</code><code class="p">.</code><code class="nx">successRedirect</code> <code class="o">=</code> <code class="s1">'/account'</code>
  <code class="k">if</code><code class="p">(</code><code class="o">!</code><code class="nx">options</code><code class="p">.</code><code class="nx">failureRedirect</code><code class="p">)</code> <code class="nx">options</code><code class="p">.</code><code class="nx">failureRedirect</code> <code class="o">=</code> <code class="s1">'/login'</code>
  <code class="k">return</code> <code class="p">{</code>
    <code class="nx">init</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/* TODO */</code> <code class="p">},</code>
    <code class="nx">registerRoutes</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/* TODO */</code> <code class="p">},</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p>Before we get into the details of the <code>init</code> and <code>registerRoutes</code> methods, let’s look at how we’ll use this module (hopefully that will make this business of returning a function that returns an object a little more clear):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">createAuth</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./lib/auth'</code><code class="p">)</code>

<code class="c1">// ...other app configuration</code>

<code class="kr">const</code> <code class="nx">auth</code> <code class="o">=</code> <code class="nx">createAuth</code><code class="p">(</code><code class="nx">app</code><code class="p">,</code> <code class="p">{</code>
  <code class="c1">// baseUrl is optional; it will default to localhost if you omit it;</code>
  <code class="c1">// it can be helpful to set this if you're not working on</code>
  <code class="c1">// your local machine.  For example, if you were using a staging server,</code>
  <code class="c1">// you might set the BASE_URL environment variable to</code>
  <code class="c1">// https://staging.meadowlark.com</code>
  <code class="nx">baseUrl</code><code class="o">:</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">BASE_URL</code><code class="p">,</code>
  <code class="nx">providers</code><code class="o">:</code> <code class="nx">credentials</code><code class="p">.</code><code class="nx">authProviders</code><code class="p">,</code>
  <code class="nx">successRedirect</code><code class="o">:</code> <code class="s1">'/account'</code><code class="p">,</code>
  <code class="nx">failureRedirect</code><code class="o">:</code> <code class="s1">'/unauthorized'</code><code class="p">,</code>
<code class="p">})</code>

<code class="c1">// auth.init() links in Passport middleware:</code>
<code class="nx">auth</code><code class="p">.</code><code class="nx">init</code><code class="p">()</code>

<code class="c1">// now we can specify our auth routes:</code>
<code class="nx">auth</code><code class="p">.</code><code class="nx">registerRoutes</code><code class="p">()</code></pre>

<p>Notice that, in addition to specifying the success and failure redirect
paths, we also specify a property called <code>providers</code>, which we’ve
externalized in the credentials file (see <a data-type="xref" href="ch13.xhtml#ch_persistence">Chapter 13</a>).  We’ll need
to add the <code>authProviders</code> property to <em>.credentials.development.json</em>:</p>

<pre data-type="programlisting" data-code-language="json"><code class="s2">"authProviders"</code><code class="err">:</code> <code class="p">{</code>
  <code class="nt">"facebook"</code><code class="p">:</code> <code class="p">{</code>
    <code class="nt">"appId"</code><code class="p">:</code> <code class="s2">"your_app_id"</code><code class="p">,</code>
    <code class="nt">"appSecret"</code><code class="p">:</code> <code class="s2">"your_app_secret"</code>
  <code class="p">}</code>
<code class="p">}</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>Another reason to bundle our authentication code in a module like this is that we can reuse it for other projects; as a matter of fact, there are already some authentication packages that do essentially what we’re doing here.  However, it’s important to understand the details of what’s going on, so even if you end up using a module someone else wrote, this will help you understand everything that’s going on in your authentication flow.</p>
</div>

<p>Now let’s take care of our <code>init</code> method (previously a “TODO” in <em>auth.js</em>):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">init</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
  <code class="kd">var</code> <code class="nx">config</code> <code class="o">=</code> <code class="nx">options</code><code class="p">.</code><code class="nx">providers</code>

  <code class="c1">// configure Facebook strategy</code>
  <code class="nx">passport</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="k">new</code> <code class="nx">FacebookStrategy</code><code class="p">({</code>
    <code class="nx">clientID</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">facebook</code><code class="p">.</code><code class="nx">appId</code><code class="p">,</code>
    <code class="nx">clientSecret</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">facebook</code><code class="p">.</code><code class="nx">appSecret</code><code class="p">,</code>
    <code class="nx">callbackURL</code><code class="o">:</code> <code class="p">(</code><code class="nx">options</code><code class="p">.</code><code class="nx">baseUrl</code> <code class="o">||</code> <code class="s1">''</code><code class="p">)</code> <code class="o">+</code> <code class="s1">'/auth/facebook/callback'</code><code class="p">,</code>
  <code class="p">},</code> <code class="p">(</code><code class="nx">accessToken</code><code class="p">,</code> <code class="nx">refreshToken</code><code class="p">,</code> <code class="nx">profile</code><code class="p">,</code> <code class="nx">done</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">authId</code> <code class="o">=</code> <code class="s1">'facebook:'</code> <code class="o">+</code> <code class="nx">profile</code><code class="p">.</code><code class="nx">id</code>
    <code class="nx">db</code><code class="p">.</code><code class="nx">getUserByAuthId</code><code class="p">(</code><code class="nx">authId</code><code class="p">)</code>
      <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="k">if</code><code class="p">(</code><code class="nx">user</code><code class="p">)</code> <code class="k">return</code> <code class="nx">done</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">user</code><code class="p">)</code>
        <code class="nx">db</code><code class="p">.</code><code class="nx">addUser</code><code class="p">({</code>
          <code class="nx">authId</code><code class="o">:</code> <code class="nx">authId</code><code class="p">,</code>
          <code class="nx">name</code><code class="o">:</code> <code class="nx">profile</code><code class="p">.</code><code class="nx">displayName</code><code class="p">,</code>
          <code class="nx">created</code><code class="o">:</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(),</code>
          <code class="nx">role</code><code class="o">:</code> <code class="s1">'customer'</code><code class="p">,</code>
        <code class="p">})</code>
          <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="nx">done</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">user</code><code class="p">))</code>
          <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">err</code> <code class="o">=&gt;</code> <code class="nx">done</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="kc">null</code><code class="p">))</code>
      <code class="p">})</code>
      <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="k">if</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="k">return</code> <code class="nx">done</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
      <code class="p">})</code>
  <code class="p">}))</code>

  <code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">passport</code><code class="p">.</code><code class="nx">initialize</code><code class="p">())</code>
  <code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">passport</code><code class="p">.</code><code class="nx">sessionp</code><code class="p">))</code>
<code class="p">},</code></pre>

<p>This is a pretty dense bit of code, but most of it is actually just Passport boilerplate.  The important bit is inside the function that gets passed to the <code>FacebookStrategy</code> instance.  When this function gets called (after the user has successfully authenticated), the <code>profile</code> parameter contains information about the Facebook user.  Most important, it includes a Facebook ID: that’s what we’ll use to associate a Facebook account to our own user object.  Note that we namespace our <code>authId</code> property by prefixing <code><em>facebook:</em></code>.  Slight as the chance may be, this prevents the possibility of a Facebook ID colliding with a Twitter or Google ID (it also allows us to examine user models to see what authentication method a user is using, which could be useful).  If the database already contains an entry for this namespaced ID, we simply return it (this is when <code>serializeUser</code> gets called, which will put our own user ID into the session).  If no user record is returned, we create a new user object and save it to the database.</p>

<p>The last thing we have to do is create our <code>registerRoutes</code> method (don’t worry, this one is much shorter):</p>

<pre data-type="programlisting" data-code-language="js">  <code class="nx">registerRoutes</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/auth/facebook'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">redirect</code><code class="p">)</code> <code class="nx">req</code><code class="p">.</code><code class="nx">session</code><code class="p">.</code><code class="nx">authRedirect</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">redirect</code>
      <code class="nx">passport</code><code class="p">.</code><code class="nx">authenticate</code><code class="p">(</code><code class="s1">'facebook'</code><code class="p">)(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code>
    <code class="p">})</code>
    <code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/auth/facebook/callback'</code><code class="p">,</code> <code class="nx">passport</code><code class="p">.</code><code class="nx">authenticate</code><code class="p">(</code><code class="s1">'facebook'</code><code class="p">,</code>
      <code class="p">{</code> <code class="nx">failureRedirect</code><code class="o">:</code> <code class="nx">options</code><code class="p">.</code><code class="nx">failureRedirect</code> <code class="p">}),</code>
      <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="c1">// we only get here on successful authentication</code>
        <code class="kr">const</code> <code class="nx">redirect</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">session</code><code class="p">.</code><code class="nx">authRedirect</code>
        <code class="k">if</code><code class="p">(</code><code class="nx">redirect</code><code class="p">)</code> <code class="k">delete</code> <code class="nx">req</code><code class="p">.</code><code class="nx">session</code><code class="p">.</code><code class="nx">authRedirect</code>
        <code class="nx">res</code><code class="p">.</code><code class="nx">redirect</code><code class="p">(</code><code class="mi">303</code><code class="p">,</code> <code class="nx">redirect</code> <code class="o">||</code> <code class="nx">options</code><code class="p">.</code><code class="nx">successRedirect</code><code class="p">)</code>
      <code class="p">}</code>
    <code class="p">)</code>
  <code class="p">},</code></pre>

<p>Now we have the path <em>/auth/facebook</em>; visiting this path will automatically redirect the visitor to Facebook’s authentication screen (this is done by <code>passport.authenticate('facebook’)</code>), step 2 in <a data-type="xref" href="#img_security_third_party_authentication">Figure 18-1</a>.  Note that we check to see if there’s a querystring parameter <code>redirect</code>; if there is, we save it in the session.  This is so we can automatically redirect to the intended destination after completing authentication.  Once the user authorizes with Twitter, the browser will be redirected back to your site—specifically, to the <em>/auth/facebook/callback</em> path (with the optional <code>redirect</code> querystring indicating where the user was originally).</p>

<p>Also on the querystring are authentication tokens that Passport will verify.  If the verification fails, Passport will redirect the browser to <code>options.failureRedirect</code>.  If the verification is successful, Passport will call <code>next</code>, which is where your application comes back in.  Note how the middleware is chained in the handler for <em>/auth/facebook/callback</em>: <code>passport.authenticate</code> is called first.  If it calls <code>next</code>, control passes over to your function, which then redirects to either the original location or <code>options.successRedirect</code>, if the <code>redirect</code> querystring parameter wasn’t specified.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Omitting the <code>redirect</code> querystring parameter can simplify your authentication routes, which may be tempting if you have only one URL that requires authentication.  However, having this functionality <span class="keep-together">available</span> will eventually come in handy and provide a better user experience.  No doubt you’ve experienced this yourself before: you’ve found the page you want, and you’re instructed to log in.  You do, and you’re redirected to a default page, and you have to navigate back to the original page.  It’s not a very satisfying user experience.</p>
</div>

<p>The “magic” that Passport is doing during this process is saving the user (in our case, just a database user ID) to the session.  This is a good thing, because the browser is <em>redirecting</em>, which is a different HTTP request: without having that <span class="keep-together">information</span> in the session, we wouldn’t have any way to know that the user had been authenticated!  Once a user has been successfully authenticated, <code>req.session.passport.user</code> will be set, and that’s how future requests will know that the user has been authenticated.</p>

<p>Let’s look at our <code>/account</code> handler to see how it checks to make sure the user is authenticated (this route handler will be in our main application file, or in a separate routing module, not in <em>/lib/auth.js</em>):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/account'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code><code class="p">(</code><code class="o">!</code><code class="nx">req</code><code class="p">.</code><code class="nx">user</code><code class="p">)</code>
    <code class="k">return</code> <code class="nx">res</code><code class="p">.</code><code class="nx">redirect</code><code class="p">(</code><code class="mi">303</code><code class="p">,</code> <code class="s1">'/unauthorized'</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'account'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">username</code><code class="o">:</code> <code class="nx">req</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code> <code class="p">})</code>
<code class="p">})</code>
<code class="c1">// we also need an 'unauthorized' page</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/unauthorized'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">403</code><code class="p">).</code><code class="nx">render</code><code class="p">(</code><code class="s1">'unauthorized'</code><code class="p">)</code>
<code class="p">})</code>
<code class="c1">// and a way to logout</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/logout'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">req</code><code class="p">.</code><code class="nx">logout</code><code class="p">()</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">redirect</code><code class="p">(</code><code class="s1">'/'</code><code class="p">)</code>
<code class="p">})</code></pre>

<p>Now only authenticated users will see the account page; everyone else will be redirected to a Not Authorized page<a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc10" id="idm45053576121560"/><a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc9" id="idm45053576120952"/><a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc8" id="idm45053576005944"/>.<a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc7" id="idm45053576005160"/><a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc6" id="idm45053576004472"/></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Role-Based Authorization"><div class="sect2" id="idm45053576988808">
<h2>Role-Based Authorization</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="role-based authorization" id="ix_ch-18-security-asciidoc11"/><a data-type="indexterm" data-primary="authorization" data-secondary="role-based" id="ix_ch-18-security-asciidoc12"/><a data-type="indexterm" data-primary="role-based authorization" id="ix_ch-18-security-asciidoc13"/>So far, we’re not technically doing any authorization (we’re only differentiating between authorized and unauthorized users).  However, let’s say we want only customers to see their account views (employees might have an entirely different view where they can see user account information).</p>

<p>Remember that in a single route, you can have multiple functions, which get called in order.  Let’s create a function called <code>customerOnly</code> that will allow only customers:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">customerOnly</code> <code class="o">=</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">user</code> <code class="o">&amp;&amp;</code> <code class="nx">req</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">role</code> <code class="o">===</code> <code class="s1">'customer'</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>
  <code class="c1">// we want customer-only pages to know they need to logon</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">redirect</code><code class="p">(</code><code class="mi">303</code><code class="p">,</code> <code class="s1">'/unauthorized'</code><code class="p">)</code>
<code class="p">}</code></pre>

<p>Let’s also create am <code>employeeOnly</code> function that will operate a little differently.  Let’s say we have a path <em>/sales</em> that we want to be available only to employees.  Furthermore, we don’t want nonemployees to even be aware of its existence, even if they stumble on it by accident.  If a potential attacker went to the <em>/sales</em> path, and saw a Not Authorized page, that is a little information that might make an attack easier (simply by knowing that the page is there).  So, for a little added security, we want nonemployees to see a regular 404 page when they visit the <em>/sales</em> page, giving potential attackers nothing to work with:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">employeeOnly</code> <code class="o">=</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">user</code> <code class="o">&amp;&amp;</code> <code class="nx">req</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">role</code> <code class="o">===</code> <code class="s1">'employee'</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>
  <code class="c1">// we want employee-only authorization failures to be "hidden", to</code>
  <code class="c1">// prevent potential hackers from even knowing that such a page exists</code>
  <code class="nx">next</code><code class="p">(</code><code class="s1">'route'</code><code class="p">)</code>
<code class="p">}</code></pre>

<p>Calling <code>next('route’)</code> will not simply execute the next handler in the route: it will skip this route altogether.  Assuming there’s not a route further on down the line that will handle <code>/account</code>, this will eventually pass to the 404 handler, giving us the desired result.</p>

<p>Here’s how easy it is to put these functions to use:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// customer routes</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/account'</code><code class="p">,</code> <code class="nx">customerOnly</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'account'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">username</code><code class="o">:</code> <code class="nx">req</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code> <code class="p">})</code>
<code class="p">})</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/account/order-history'</code><code class="p">,</code> <code class="nx">customerOnly</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'account/order-history'</code><code class="p">)</code>
<code class="p">})</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/account/email-prefs'</code><code class="p">,</code> <code class="nx">customerOnly</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'account/email-prefs'</code><code class="p">)</code>
<code class="p">})</code>

<code class="c1">// employer routes</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/sales'</code><code class="p">,</code> <code class="nx">employeeOnly</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
	<code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'sales'</code><code class="p">)</code>
<code class="p">})</code></pre>

<p>It should be clear that role-based authorization can be as simple or as complicated as you wish.  For example, what if you want to allow multiple roles?  You could use the following function and route:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">allow</code> <code class="o">=</code> <code class="nx">roles</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">user</code> <code class="o">&amp;&amp;</code> <code class="nx">roles</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s1">','</code><code class="p">).</code><code class="nx">includes</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">role</code><code class="p">))</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">redirect</code><code class="p">(</code><code class="mi">303</code><code class="p">,</code> <code class="s1">'/unauthorized'</code><code class="p">)</code>
<code class="p">}</code></pre>

<p>Hopefully that example gives you an idea of how creative you can be with role-based authorization.  You could even authorize on other properties, such as the length of time a user has been a member or how many vacations that user has booked with you.<a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc13" id="idm45053575592040"/><a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc12" id="idm45053575597032"/><a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc11" id="idm45053575596424"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Adding Authentication Providers"><div class="sect2" id="idm45053576003528">
<h2>Adding Authentication Providers</h2>

<p><a data-type="indexterm" data-primary="authentication" data-secondary="adding additional providers" id="idm45053575594440"/>Now that our framework is in place, adding more authentication providers is easy.  Let’s say we want to authenticate with Google.  Before we start adding code, you’ll have to set up a project on your Google account.</p>

<p>Go to your <a href="http://bit.ly/2KcY1X0">Google Developers Console</a> and choose a project from the navigation bar (if you don’t already have a project, click New Project and follow the instructions.  Once you’ve selected a project, click “Enable APIs and Services” and enable Cloud Identity API.  Click Credentials, and then Create Credentials, and choose “OAuth client ID,” and then “Web application.”  Enter the appropriate URLs for your app: for testing you can use <em>http://localhost:3000</em> for the authorized origins, and <em>http://localhost:3000/auth/google/callback</em> for authorized redirect URIs.</p>

<p>Once you have got everything set up on the Google side, run <code>npm install passport-google-oauth20</code>, and add the following code to <em>lib/auth.js</em>:<a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc5" id="idm45053575716360"/><a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc4" id="idm45053575715560"/></p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// configure Google strategy</code>
<code class="nx">passport</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="k">new</code> <code class="nx">GoogleStrategy</code><code class="p">({</code>
  <code class="nx">clientID</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">google</code><code class="p">.</code><code class="nx">clientID</code><code class="p">,</code>
  <code class="nx">clientSecret</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">google</code><code class="p">.</code><code class="nx">clientSecret</code><code class="p">,</code>
  <code class="nx">callbackURL</code><code class="o">:</code> <code class="p">(</code><code class="nx">options</code><code class="p">.</code><code class="nx">baseUrl</code> <code class="o">||</code> <code class="s1">''</code><code class="p">)</code> <code class="o">+</code> <code class="s1">'/auth/google/callback'</code><code class="p">,</code>
<code class="p">},</code> <code class="p">(</code><code class="nx">token</code><code class="p">,</code> <code class="nx">tokenSecret</code><code class="p">,</code> <code class="nx">profile</code><code class="p">,</code> <code class="nx">done</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">authId</code> <code class="o">=</code> <code class="s1">'google:'</code> <code class="o">+</code> <code class="nx">profile</code><code class="p">.</code><code class="nx">id</code>
  <code class="nx">db</code><code class="p">.</code><code class="nx">getUserByAuthId</code><code class="p">(</code><code class="nx">authId</code><code class="p">)</code>
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="k">if</code><code class="p">(</code><code class="nx">user</code><code class="p">)</code> <code class="k">return</code> <code class="nx">done</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">user</code><code class="p">)</code>
      <code class="nx">db</code><code class="p">.</code><code class="nx">addUser</code><code class="p">({</code>
        <code class="nx">authId</code><code class="o">:</code> <code class="nx">authId</code><code class="p">,</code>
        <code class="nx">name</code><code class="o">:</code> <code class="nx">profile</code><code class="p">.</code><code class="nx">displayName</code><code class="p">,</code>
        <code class="nx">created</code><code class="o">:</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(),</code>
        <code class="nx">role</code><code class="o">:</code> <code class="s1">'customer'</code><code class="p">,</code>
      <code class="p">})</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="nx">done</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">user</code><code class="p">))</code>
        <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">err</code> <code class="o">=&gt;</code> <code class="nx">done</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="kc">null</code><code class="p">))</code>
    <code class="p">})</code>
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'whoops, there was an error: '</code><code class="p">,</code> <code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code>
      <code class="k">if</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="k">return</code> <code class="nx">done</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
    <code class="p">})</code>
<code class="p">}))</code></pre>

<p>And the following to the <code>registerRoutes</code> method:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/auth/google'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">redirect</code><code class="p">)</code> <code class="nx">req</code><code class="p">.</code><code class="nx">session</code><code class="p">.</code><code class="nx">authRedirect</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">redirect</code>
  <code class="nx">passport</code><code class="p">.</code><code class="nx">authenticate</code><code class="p">(</code><code class="s1">'google'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">scope</code><code class="o">:</code> <code class="p">[</code><code class="s1">'profile'</code><code class="p">]</code> <code class="p">})(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code>
<code class="p">})</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/auth/google/callback'</code><code class="p">,</code> <code class="nx">passport</code><code class="p">.</code><code class="nx">authenticate</code><code class="p">(</code><code class="s1">'google'</code><code class="p">,</code>
  <code class="p">{</code> <code class="nx">failureRedirect</code><code class="o">:</code> <code class="nx">options</code><code class="p">.</code><code class="nx">failureRedirect</code> <code class="p">}),</code>
  <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// we only get here on successful authentication</code>
    <code class="kr">const</code> <code class="nx">redirect</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">session</code><code class="p">.</code><code class="nx">authRedirect</code>
    <code class="k">if</code><code class="p">(</code><code class="nx">redirect</code><code class="p">)</code> <code class="k">delete</code> <code class="nx">req</code><code class="p">.</code><code class="nx">session</code><code class="p">.</code><code class="nx">authRedirect</code>
    <code class="nx">res</code><code class="p">.</code><code class="nx">redirect</code><code class="p">(</code><code class="mi">303</code><code class="p">,</code> <code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">redirect</code> <code class="o">||</code> <code class="nx">options</code><code class="p">.</code><code class="nx">successRedirect</code><code class="p">)</code>
  <code class="p">}</code>
<code class="p">)</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45053577205544">
<h1>Conclusion</h1>

<p>Congratulations on making it through the most intricate chapter!  It’s unfortunate that such an important feature (authentication and authorization) is so complicated, but in a world rife with security threats, it’s an unavoidable complexity.  Fortunately, projects like Passport (and the excellent authentication schemes based on it) lessen our burden somewhat.  Still, I encourage you not to give short shrift to this area of your application: exercising diligence in the area of security will make you a good internet citizen.  Your users may never thank you for it, but woe be to the owners of an application who allow user data to be compromised because of poor security.<a data-type="indexterm" data-startref="ix_ch-18-security-asciidoc0" id="idm45053575220968"/></p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45053576983016"><sup><a href="ch18.xhtml#idm45053576983016-marker">1</a></sup> It is unlikely that the third party is storing passwords either.  A password can be verified by storing something called a <em>salted hash</em>, which is a one-way transformation of the password.  That is, once you generate a hash from a password, you can’t recover the password.  <em>Salting</em> the hash provides additional protection against certain kinds of attacks.</p></div></div></section></div>



  </body></html>