- en: Chapter 11\. Stateless Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Stateless Service* pattern describes how to create and operate applications
    that are composed of identical ephemeral replicas. These applications are best
    suited for dynamic cloud environments where they can be rapidly scaled and made
    highly available.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The microservices architecture style is the dominant choice for implementing
    new greenfield cloud native applications. Among the driving principles of this
    architecture are things such as how it addresses a single concern, how it owns
    its data, how it has a well-encapsulated deployment boundary, and others. Typically,
    such applications also follow the [twelve-factor app principles](https://12factor.net),
    which makes them easy to operate with Kubernetes on dynamic cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: Applying some of these principles requires understanding the business domain,
    identifying the service boundary, or applying domain-driven design or a similar
    methodology during the service implementation. Implementing some of the other
    principles may involve making the services ephemeral, which means the service
    can be created, scaled, and destroyed with no side effects. These latter concerns
    are easier to address when a service is stateless rather than stateful.
  prefs: []
  type: TYPE_NORMAL
- en: A stateless service does not maintain any state internally within the instance
    across service interactions. In our context, it means a container is stateless
    if it does not hold any information from requests in its internal storage (memory
    or temporary filesystem) that is critical for serving future requests. A stateless
    process has no stored knowledge of or reference to past requests, so each request
    is made as if from scratch. Instead, if the process needs to store such information,
    it should store it in an external storage such as a database, message queue, mounted
    filesystem, or some other data store that can be accessed by other instances.
    A good thought experiment is to imagine the instances of your services deployed
    on different nodes and a load-balancer that randomly distributes the requests
    to the instances without any sticky session (i.e., without an affinity between
    a client and a specific service instance). If the service can fulfill its purpose
    in this setup, it is likely a stateless service (or it has a mechanism for state
    distribution among the instances, such as a data grid).
  prefs: []
  type: TYPE_NORMAL
- en: Stateless services are made of identical, replaceable instances that often offload
    state to external permanent storage systems and use load-balancers for distributing
    incoming requests among themselves. In this chapter, we will see specifically
    which Kubernetes abstractions can help operate such stateless applications.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3, “Declarative Deployment”](ch03.html#DeclarativeDeployment), you
    learned how to use the concept of Deployment to control how an application should
    be updated to the next version, using the `RollingUpdate` and `Recreate` strategies.
    But this is only the upgrading aspect of Deployment. At a broader level, a Deployment
    represents an application deployed in the cluster. Kubernetes doesn’t have the
    notion of an `Application` or a `Container` as top-level entities. Instead, an
    application is typically composed of a collection of Pods managed by a controller
    such as ReplicaSet, Deployment, or StatefulSet, combined with ConfigMap, Secret,
    Service, PersistentVolumeClaim, etc. The controller that is used for managing
    stateless Pods is ReplicaSet, but that is a lower-level internal control structure
    used by a Deployment. Deployment is the recommended user-facing abstraction for
    creating and updating stateless applications, which creates and manages the ReplicaSets
    behind the scene. A ReplicaSet should be used when the update strategies provided
    by Deployment are not suitable, or a custom mechanism is required, or no control
    over the update process is needed at all.
  prefs: []
  type: TYPE_NORMAL
- en: Instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary purpose of a ReplicaSet is to ensure a specified number of identical
    Pod replicas running at any given time. The main sections of a ReplicaSet definition
    include the number of replicas indicating how many Pods it should maintain, a
    selector that specifies how to identify the Pods it manages, and a Pod template
    for creating new Pod replicas. Then, a ReplicaSet creates and deletes Pods as
    needed to maintain the desired replica count using the given Pod template, as
    demonstrated in [Example 11-1](#stateless-service-instances).
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-1\. ReplicaSet definition for a stateless Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_stateless_service_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Desired number of Pod replicas to maintain running.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_stateless_service_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Label selector used to identify the Pods to manage.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_stateless_service_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Template specifying the data for creating new Pods.
  prefs: []
  type: TYPE_NORMAL
- en: The template is used when the ReplicaSet needs to create new Pods to meet the
    desired number of replicas. But a ReplicaSet is not limited to managing the Pods
    specified by the template. If a bare Pod has no owner reference (meaning it is
    not managed by a controller), and it matches the label selector, it will be acquired
    by setting the owner reference and managed by the ReplicaSet. This setup can lead
    to a ReplicaSet owning a nonidentical set of Pods created by different means,
    and terminate existing bare Pods that exceed the declared replica count. To avoid
    such undesired side effects, it is recommended that you ensure bare Pods do not
    have labels matching ReplicaSet selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether you create a ReplicaSet directly or through a Deployment,
    the end result will be that the desired number of identical Pod replicas are created
    and maintained. The added benefit of using Deployment is that we can control how
    the replicas are upgraded and rolled back, which we described in detail in [Chapter 3,
    “Declarative Deployment”](ch03.html#DeclarativeDeployment). Next, the replicas
    are scheduled to the available nodes as per the policies we covered in [Chapter 6,
    “Automated Placement”](ch06.html#AutomatedPlacement). The ReplicaSet’s job is
    to restart the containers if needed and scale out or in when the number of replicas
    is increased or decreased, respectively. With this behavior, Deployment and ReplicaSet
    can automate the lifecycle management of stateless applications.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pods created by ReplicaSet are ephemeral and may disappear at any time, such
    as when a Pod is evicted because of resource starvation or because the node the
    Pod is running on fails. In such a situation, the ReplicaSet will create a new
    Pod that will have a new name, hostname, and IP address. If the application is
    stateless, as we’ve defined earlier in the chapter, new requests should be handled
    from the newly created Pod the same way as by any other Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how the application within the container connects to the other
    systems to accept requests or poll for messages, for example, you may require
    a Kubernetes Service. If the application is starting an egress connection to a
    message broker or database, and that is the only way it exchanges data, then there
    is no need for a Kubernetes Service. But more often, stateless services are contacted
    by other services over synchronous request/response-driven protocols such as HTTP
    and gRPC. Since the Pod IP address changes with every Pod restart, it is better
    to use a permanent IP address based on a Kubernetes Service that service consumers
    can use. A Kubernetes Service has a fixed IP address that doesn’t change during
    the lifetime of the Service, and it ensures the client requests are always load-balanced
    across instances and routed to the healthy and ready-to-accept-requests Pods.
    We cover different types of Kubernetes Services in [Chapter 13, “Service Discovery”](ch13.html#ServiceDiscovery).
    In [Example 11-2](#stateless-service-discovery), we use a simple Service to expose
    the Pods internally within the cluster to other Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-2\. Exposing a stateless service
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_stateless_service_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the service that can be used to reach the matching Pods.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_stateless_service_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Selector matching the Pod labels from the ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition in this example will create a Service named `random-generator`
    that accepts TCP connections on port 80 and routes them to port 8080 on all the
    matching Pods with selector `app: random-generator`. Once a Service is created,
    it is assigned a `clusterIP` that is accessible only from within the Kubernetes
    cluster, and that IP remains unchanged as long as the Service definition exists.
    This acts as a permanent entrypoint to all matching Pods that are ephemeral and
    have changing IP addresses.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that Deployment and the resulting ReplicaSet are only responsible for
    maintaining the desired number of stateless Pods that match the label selector.
    They are unaware of any Kubernetes Service that might be directing traffic to
    the same set of Pods or a different combination of Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Few stateless services don’t need any state and can process requests based only
    on the data provided in every request. Most stateless services require state,
    but they are stateless because they offload the state to some other stateful system
    or data store, such as a filesystem. Any Pod, whether it is created by a ReplicaSet
    or not, can declare and use file storage through volumes. Different types of volumes
    can be used to store state. Some of these are cloud-provider-specific storage,
    while others allow mounting network storage or even sharing filesystems from the
    node where the Pod is placed. In this section, we’ll look at the `persistentVolumeClaim`
    volume type, which allows you to use manually or dynamically provisioned persistent
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: A PersistentVolume (PV) represents a storage resource abstraction in a Kubernetes
    cluster that has a lifecycle independent of any Pod lifecycle that is using it.
    A Pod cannot directly refer to a PV; however, a Pod uses PersistentVolumeClaim
    (PVC) to request and bind to the PV, which points to the actual durable storage.
    This indirect connection allows for a separation of concerns and Pod lifecycle
    decoupling from PV. A cluster administrator can configure storage provisioning
    and define PVs. The developer creating Pod definitions can use PVC to use the
    storage. With this indirection, even if the Pod is deleted, the ownership of the
    PV remains attached to the PVC and continues to exist. [Example 11-3](#stateless-service-storage)
    shows a storage claim that can be used in a Pod template.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-3\. A claim for a PersistentVolume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_stateless_service_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the claim that can be referenced from a Pod template.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_stateless_service_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates that only a single node can mount the volume for reading and writing.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_stateless_service_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Requesting 1 GiB of storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a PVC is defined, it can be referenced from a Pod template through the
    `persistentVolumeClaim` field. One of the interesting fields of PersistentVolumeClaim
    is `accessModes`. It controls how the storage is mounted to the nodes and consumed
    by the Pods. For example, network filesystems can be mounted to multiple nodes
    and can allow reading and writing to multiple applications at the same time. Other
    storage implementations can be mounted to only a single node at a time and can
    be accessed only by the Pods scheduled on that node. Let’s look at different `accessModes`
    offered by Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: ReadWriteOnce
  prefs: []
  type: TYPE_NORMAL
- en: This represents a volume that can be mounted to a single node at a time. In
    this mode, one or multiple Pods running on the node could carry out read and write
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: ReadOnlyMany
  prefs: []
  type: TYPE_NORMAL
- en: The volume can be mounted to multiple nodes, but it allows read-only operations
    to all Pods.
  prefs: []
  type: TYPE_NORMAL
- en: ReadWriteMany
  prefs: []
  type: TYPE_NORMAL
- en: In this mode, the volume can be mounted by many nodes and allows both read and
    write operations.
  prefs: []
  type: TYPE_NORMAL
- en: ReadWriteOncePod
  prefs: []
  type: TYPE_NORMAL
- en: Notice that all of the access modes described so far offer per-node granularity.
    Even `ReadWriteOnce` allows multiple Pods on the same node to read from and write
    to the same volume simultaneously. Only `ReadWriteOncePod` access mode guarantees
    that only a single Pod has access to a volume. This is invaluable in scenarios
    where at most one writer application is allowed to access data for data-consistency
    guarantees. Use this mode with caution as it will turn your services into a singleton
    and prevent scaling out. If another Pod replica uses the same PVC, the Pod will
    fail to start because the PVC is already in use by another Pod. As of this writing,
    `ReadWriteOncePod` doesn’t honor preemption either, which means a lower-priority
    Pod will hold on to the storage and not be preempted from the node in favor of
    a higher-priority Pod waiting on the same `ReadWriteOncePod` claim.
  prefs: []
  type: TYPE_NORMAL
- en: In a ReplicaSet, all Pods are identical; they share the same PVC and refer to
    the same PV. This is in contrast to StatefulSets covered in the next chapter,
    where PVCs are created dynamically for each stateful Pod replica. This is one
    of the major differences between how stateless and stateful workloads are handled
    in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A complex distributed system is usually composed of multiple services, some
    of which will be stateful and perform some form of distributed coordination, some
    of which might be short-lived jobs, and some of which might be highly scalable
    stateless services. Stateless services are composed of identical, swappable, ephemeral,
    and replaceable instances. They are ideal for handling short-lived requests and
    can scale up and down rapidly without having any dependencies among the instances.
    As shown in [Figure 11-1](#img-stateless-service-application), Kubernetes offers
    a number of useful primitives to manage such applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![A Distributed Stateless Application on Kubernetes](assets/kup2_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. A distributed stateless application on Kubernetes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the lowest level, the Pod abstraction ensures that one or more containers
    are observed with liveness checks and are always up and running. Building on that,
    the ReplicaSet also ensures that the desired number of stateless Pods are always
    running on the healthy nodes. Deployments automate the upgrade and rollback mechanism
    of Pod replicas. When there is incoming traffic, the Service abstraction discovers
    and distributes traffic to healthy Pod instances with passing readiness probes.
    When a persistent file storage is required, PVCs can request and mount storage.
  prefs: []
  type: TYPE_NORMAL
- en: Although Kubernetes offers these building blocks, it will not enforce any direct
    relationship between them. It is your responsibility to combine them to match
    the application nature. You have to understand how liveness checks and ReplicaSet
    control Pods’ lifecycles, and how they relate to readiness probes and Service
    definitions controlling how the traffic is directed to the Pods. You should also
    understand how PVCs and `accessMode` control where the storage is mounted and
    how it is accessed. When Kubernetes primitives are not sufficient, you should
    know how to combine it with other frameworks such as Knative and KEDA and how
    to autoscale and even turn stateless applications into serverless. The latter
    frameworks are covered in [Chapter 29, “Elastic Scale”](ch29.html#ElasticScale).
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Stateless Service Example](https://oreil.ly/h0Ytj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ReplicaSet](https://oreil.ly/XugMo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Persistent Volumes](https://oreil.ly/HvApe)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Storage Classes](https://oreil.ly/qxFrz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Access Modes](https://oreil.ly/iovaa)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
