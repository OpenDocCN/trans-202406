<html><head></head><body><section data-pdf-bookmark="Chapter 2. First Steps with Kubernetes" data-type="chapter" epub:type="chapter"><div class="chapter" id="firststeps">&#13;
<h1><span class="label">Chapter 2. </span>First Steps with Kubernetes</h1>&#13;
&#13;
<blockquote class="epigraph"><a data-primary="Kubernetes" data-secondary="first steps" data-type="indexterm" id="ix_02-firststeps-adoc0"/>You’ve taken your first step into a larger world.&#13;
<p data-type="attribution">Obi-Wan Kenobi, <cite><em>Star Wars: A New Hope</em></cite></p>&#13;
</blockquote>&#13;
&#13;
<p>Enough with the theory; let’s start working with Kubernetes and containers. In this chapter, you’ll build a simple containerized application and deploy it to a local Kubernetes cluster running on your machine. In the process, you’ll meet some very important cloud native technologies and concepts: Docker, Git, Go, container registries, and the <code>kubectl</code> tool.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>This chapter is interactive! Throughout this book, we’ll ask you to follow along with the examples by installing things on your own computer, typing commands, and running containers. We find that’s a much more effective way to learn than just having things explained in words. You can find all of the examples on <a href="https://oreil.ly/LAI8f">GitHub</a>.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running Your First Container" data-type="sect1"><div class="sect1" id="idm45979403636336">&#13;
<h1>Running Your First Container</h1>&#13;
&#13;
<p>As we saw in <a data-type="xref" href="ch01.html#revolution">Chapter 1</a>, the container is one of the key concepts in cloud native development. The most popular tool for building and running containers is Docker. There are other tools for running containers, but we will cover that in more detail later.</p>&#13;
&#13;
<p>In this section, we’ll use the Docker Desktop tool to build a simple demo application, run it locally, and push the image to a container registry.</p>&#13;
&#13;
<p>If you’re already very familiar with containers, skip straight to <a data-type="xref" href="#hellokube">“Hello, Kubernetes”</a>, where the real fun starts. If you’re curious to know what containers are and how they work—and to get a little practical experience with them before you start learning about Kubernetes—read on.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing Docker Desktop" data-type="sect2"><div class="sect2" id="idm45979403631408">&#13;
<h2>Installing Docker Desktop</h2>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="installing" data-type="indexterm" id="idm45979403630032"/><a data-primary="Docker" data-secondary="introduction" data-type="indexterm" id="idm45979403629056"/>Docker Desktop is a free package for Mac and Windows. It comes with a complete Kubernetes development environment that you can use to test your applications on your laptop or desktop.</p>&#13;
&#13;
<p>Let’s install Docker Desktop now and use it to run a simple containerized application. If you already have Docker installed, skip this section and go straight on to <a data-type="xref" href="#runningcontainer">“Running a Container Image”</a>.</p>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="version" data-type="indexterm" id="idm45979403626288"/>Download a version of the <a href="https://oreil.ly/Klafa">Docker Desktop Community Edition</a> suitable for your computer, then follow the instructions for your platform to install Docker and start it up.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Docker Desktop isn’t currently available for Linux, so Linux users will need to install <a href="https://oreil.ly/4B1K5">Docker Engine</a> instead, and then <a href="https://oreil.ly/ExEjc">Minikube</a> (see <a data-type="xref" href="#minikube">“Minikube”</a>).</p>&#13;
</div>&#13;
&#13;
<p>Once you’ve done that, you should be able to open a terminal and run the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">docker version</code></strong><code class="go">&#13;
</code><code class="go"> ...&#13;
</code><code class="go"> Version:           20.10.7&#13;
</code><code class="go"> ...</code></pre>&#13;
&#13;
<p>The exact output will be different depending on your platform, but if Docker is correctly installed and running, you’ll see something like the example output shown.</p>&#13;
&#13;
<p>On Linux systems, you may need to run <code>sudo docker version</code> instead. You can add your account to the docker group with <code>sudo usermod -aG docker $USER &amp;&amp; newgrp docker</code> and then you won’t need to use <code>sudo</code> each time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Is Docker?" data-type="sect2"><div class="sect2" id="idm45979391785936">&#13;
<h2>What Is Docker?</h2>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="components" data-type="indexterm" id="idm45979403363424"/><a href="https://docs.docker.com">Docker</a> is actually several different, but related, things: a container image format, a container runtime library that manages the life cycle of containers, a command-line tool for packaging and running containers, and an API for container management. The details needn’t concern us here, since Kubernetes supports Docker containers as one of many components, though an important one.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running a Container Image" data-type="sect2"><div class="sect2" id="runningcontainer">&#13;
<h2>Running a Container Image</h2>&#13;
&#13;
<p>What exactly is a container image? The technical details don’t really matter for our purposes, but you can think of an image as being like a ZIP file. It’s a single binary file that has a unique ID and holds everything needed to run the container.</p>&#13;
&#13;
<p>Whether you’re running the container directly with Docker, or on a Kubernetes cluster, all you need to specify is a container image ID or URL, and the system will take care of finding, downloading, unpacking, and starting the container for you.</p>&#13;
&#13;
<p>We’ve written a little demo application that we’ll use throughout the book to illustrate what we’re talking about. You can download and run the application using a container image we prepared earlier. <a data-primary="Docker" data-secondary="commands" data-tertiary="container run" data-type="indexterm" id="idm45979400139984"/>Run the following command to try it out:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">docker container run -p 9999:8888 --name hello cloudnatived/demo:hello</code></strong></pre>&#13;
&#13;
<p>Leave this command running, and point your browser to <em>http://localhost:9999/</em>.</p>&#13;
&#13;
<p>You should see a friendly message:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="go">Hello, 世界</code></pre>&#13;
&#13;
<p>Anytime you make a request to this URL, our demo application will be ready and waiting to greet you.</p>&#13;
&#13;
<p>Once you’ve had as much fun as you can stand, stop the container by pressing Ctrl-C in your terminal.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Demo Application" data-type="sect1"><div class="sect1" id="idm45979399645472">&#13;
<h1>The Demo Application</h1>&#13;
&#13;
<p>So how does it work? Let’s download the source code for the demo application that runs in this container and have a look.</p>&#13;
&#13;
<p>You’ll need Git installed for this part.<sup><a data-type="noteref" href="ch02.html#idm45979391921824" id="idm45979391921824-marker">1</a></sup> If you’re not sure whether you already have Git, try the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">git version</code></strong><code class="go">&#13;
</code><code class="go">git version 2.32.0</code></pre>&#13;
&#13;
<p><a data-primary="Git" data-secondary="installing" data-type="indexterm" id="idm45979401778896"/>If you don’t already have Git, follow the <a href="https://git-scm.com/download">installation instructions</a> for your platform.</p>&#13;
&#13;
<p><a data-primary="Git" data-secondary="clone command" data-type="indexterm" id="idm45979401005504"/>Once you’ve installed Git, run this command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">git clone https://github.com/cloudnativedevops/demo.git</code></strong><code class="go">&#13;
</code><code class="go">Cloning into </code><em><code class="go">demo</code></em><code class="go">...&#13;
</code><code class="go">...</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Looking at the Source Code" data-type="sect2"><div class="sect2" id="demo-source">&#13;
<h2>Looking at the Source Code</h2>&#13;
&#13;
<p>This Git repository contains the demo application we’ll be using throughout this book. To make it easier to see what’s going on at each stage, the repo contains each successive version of the app in a different subdirectory. The first one is named simply <em>hello</em>. To look at the source code, run this command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">cd demo/hello</code></strong><code class="go">&#13;
</code><strong><code class="go">ls</code></strong><code class="go">&#13;
</code><code class="go">Dockerfile  README.md&#13;
</code><code class="go">go.mod      main.go</code></pre>&#13;
&#13;
<p>Open the file <em>main.go</em> in your favorite editor (we recommend <a href="https://code.visualstudio.com">Visual Studio Code</a>, which has excellent support for Go, Docker, and Kubernetes development). You’ll see this source code:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">package</code><code class="w"> </code><code class="nx">main</code><code class="w"/>&#13;
&#13;
<code class="kn">import</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="s">"fmt"</code><code class="w"/>&#13;
<code class="w">        </code><code class="s">"log"</code><code class="w"/>&#13;
<code class="w">        </code><code class="s">"net/http"</code><code class="w"/>&#13;
<code class="p">)</code><code class="w"/>&#13;
&#13;
<code class="kd">func</code><code class="w"> </code><code class="nx">handler</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprintln</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code><code class="w"> </code><code class="s">"Hello, 世界"</code><code class="p">)</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">http</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code><code class="w"> </code><code class="nx">handler</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Running demo app. Press Ctrl+C to exit..."</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">log</code><code class="p">.</code><code class="nx">Fatal</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">":8888"</code><code class="p">,</code><code class="w"> </code><code class="kc">nil</code><code class="p">))</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introducing Go" data-type="sect2"><div class="sect2" id="idm45979390640800">&#13;
<h2>Introducing Go</h2>&#13;
&#13;
<p><a data-primary="Go language, introduction to" data-type="indexterm" id="idm45979390639792"/>Our demo application is written in the Go programming language.</p>&#13;
&#13;
<p>Go is a modern programming language (developed at Google since 2009) that prioritizes simplicity, safety, and readability, and is designed for building large-scale concurrent applications, especially network services. It’s also a lot of fun to program in.<sup><a data-type="noteref" href="ch02.html#idm45979390606064" id="idm45979390606064-marker">2</a></sup></p>&#13;
&#13;
<p>Kubernetes itself is written in Go, as are Docker, Terraform, and many other popular open source projects. This makes Go a good choice for developing cloud native applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How the Demo App Works" data-type="sect2"><div class="sect2" id="idm45979390604016">&#13;
<h2>How the Demo App Works</h2>&#13;
&#13;
<p>As you can see, the demo app is pretty simple, even though it implements an HTTP server (Go comes with a powerful standard library). The core of it is this function, called <code>handler</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code><code class="w"> </code><code class="nx">handler</code><code class="p">(</code><code class="nx">w</code><code class="w"> </code><code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code><code class="w"> </code><code class="nx">r</code><code class="w"> </code><code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprintln</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code><code class="w"> </code><code class="s">"Hello, 世界"</code><code class="p">)</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>As the name suggests, it handles HTTP requests. The request is passed in as an argument to the function (though the function doesn’t do anything with it, yet).</p>&#13;
&#13;
<p>An HTTP server also needs a way to send something back to the client. The <code>http.ResponseWriter</code> object enables our function to send a message back to the user to display in their browser: in this case, just the string <code>Hello, 世界</code>.</p>&#13;
&#13;
<p>The first example program in any language traditionally prints <code>Hello, world</code>. But because Go natively supports Unicode (the international standard for text representation), example Go programs often print <code>Hello, 世界</code> instead, just to show off. If you don’t happen to speak Chinese, that’s OK: Go does!</p>&#13;
&#13;
<p>The rest of the program takes care of registering the <code>handler</code> function as the handler for HTTP requests, printing a message that the app is starting, and actually starting the HTTP server to listen and serve on port 8888.</p>&#13;
&#13;
<p>That’s the whole app! It doesn’t do much yet, but we will add capabilities to it as we go on.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building a Container" data-type="sect1"><div class="sect1" id="idm45979402468320">&#13;
<h1>Building a Container</h1>&#13;
&#13;
<p><a data-primary="containers" data-secondary="building" data-type="indexterm" id="idm45979390500192"/>You know that a container image is a single file that contains everything the container needs to run, but how do you build an image in the first place? Well, to do that, you use the <code>docker image build</code> command, which takes as input a special text file called a <em>Dockerfile</em>. The Dockerfile specifies exactly what needs to go into the container image.</p>&#13;
&#13;
<p>One of the key benefits of containers is the ability to build on existing images to create new images. For example, you could take a container image containing the complete Ubuntu operating system, add a single file to it, and the result will be a new image.</p>&#13;
&#13;
<p>In general, a Dockerfile has instructions for taking a starting image (a so-called <em>base image</em>), transforming it in some way, and saving the result as a new image.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Dockerfiles" data-type="sect2"><div class="sect2" id="multistagedockerfile">&#13;
<h2>Understanding Dockerfiles</h2>&#13;
&#13;
<p><a data-primary="Dockerfile" data-type="indexterm" id="idm45979390526880"/>Let’s see the Dockerfile for our demo application (it’s in the <em>hello</em> subdirectory of the app repo):</p>&#13;
&#13;
<pre data-code-language="dockerfile" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">golang:1.17-alpine</code><code class="w"> </code><code class="k">AS</code><code class="w"> </code><code class="s">build</code>&#13;
&#13;
<code class="k">WORKDIR</code><code class="w"> </code><code class="s">/src/</code>&#13;
<code class="k">COPY</code><code class="w"> </code>main.go go.* /src/&#13;
<code class="k">RUN</code><code class="w"> </code><code class="nv">CGO_ENABLED</code><code class="o">=</code><code class="m">0</code> go build -o /bin/demo&#13;
&#13;
<code class="k">FROM</code><code class="w"> </code><code class="s">scratch</code>&#13;
<code class="k">COPY</code><code class="w"> </code>--from<code class="o">=</code>build /bin/demo /bin/demo&#13;
<code class="k">ENTRYPOINT</code><code class="w"> </code><code class="p">[</code><code class="s2">"/bin/demo"</code><code class="p">]</code></pre>&#13;
&#13;
<p><a data-primary="containers" data-secondary="multi-stage builds" data-type="indexterm" id="idm45979390478816"/>The exact details of how this works don’t matter for now, but it uses a fairly standard build process for Go containers called <em>multistage builds</em>. <a data-primary="Alpine Linux" data-type="indexterm" id="idm45979390467328"/>The first stage starts from an official <code>golang</code> container image, which is just an operating system (in this case Alpine Linux) with the Go language environment installed. It runs the <code>go build</code> command to compile the <em>main.go</em> file we saw earlier.</p>&#13;
&#13;
<p>The result of this is an executable binary file named <em>demo</em>. The second stage takes a completely empty container image (called a <em>scratch</em> image, as in <em>from scratch</em>) and copies the <em>demo</em> binary into it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Minimal Container Images" data-type="sect2"><div class="sect2" id="minimalcontainers-intro">&#13;
<h2>Minimal Container Images</h2>&#13;
&#13;
<p><a data-primary="containers" data-secondary="minimal" data-type="indexterm" id="idm45979390434864"/>Why the second build stage? Well, the Go language environment, and the rest of Alpine Linux, is really only needed in order to <em>build</em> the program. To run the program, all it takes is the <em>demo</em> binary, so the Dockerfile creates a new scratch container to put it in. The resulting image is very small (about 6 MiB)—and that’s the image that can be deployed in production.</p>&#13;
&#13;
<p>Without the second stage, you would have ended up with a container image about 350 MiB in size, 98% of which is unnecessary and will never be executed. The smaller the container image, the faster it can be uploaded and downloaded, and the faster it will be to start up.</p>&#13;
&#13;
<p>Minimal containers also have a reduced attack surface for security issues. The fewer programs there are in your container, the fewer potential vulnerabilities.</p>&#13;
&#13;
<p>Because Go is a compiled language that can produce self-contained executables, it’s ideal for writing minimal containers. By comparison, the official Ruby container image is 850 MB; about 140 times bigger than our Alpine Go image, and that’s before you’ve added your Ruby program! Another great resource to look at for using lean containers is <a href="https://oreil.ly/V3AFm"><em>distroless</em> images</a>, which only contain runtime dependencies and keep your final container image size small.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running Docker Image Build" data-type="sect2"><div class="sect2" id="idm45979390430528">&#13;
<h2>Running Docker Image Build</h2>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="commands" data-tertiary="image build" data-type="indexterm" id="idm45979390429520"/>We’ve seen that the Dockerfile contains instructions for the <code>docker image build</code> tool to turn our Go source code into an executable container. Let’s go ahead and try it. In the <em>hello</em> directory, run the following command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">docker image build -t myhello .</code></strong><code class="go">&#13;
</code><code class="go">Sending build context to Docker daemon  4.096kB&#13;
</code><code class="go">Step 1/7 : FROM golang:1.17-alpine AS build&#13;
</code><code class="go">...&#13;
</code><code class="go">Successfully built eeb7d1c2e2b7&#13;
</code><code class="go">Successfully tagged myhello:latest</code></pre>&#13;
&#13;
<p>Congratulations, you just built your first container! You can see from the output that Docker performs each of the actions in the Dockerfile in sequence on the newly formed container, resulting in an image that’s ready to use.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Naming Your Images" data-type="sect2"><div class="sect2" id="idm45979390420656">&#13;
<h2>Naming Your Images</h2>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="naming and tagging images" data-type="indexterm" id="idm45979390419536"/>When you build an image, by default it just gets a hexadecimal ID, which you can use to refer to it later (for example, to run it). These IDs aren’t particularly memorable or easy to type, so Docker allows you to give the image a human-readable name, using the <code>-t</code> switch to <code>docker image build</code>. In the previous example you named the image <code>myhello</code>, so you should be able to use that name to run the image now.</p>&#13;
&#13;
<p>Let’s see if it works:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">docker container run -p 9999:8888 myhello</code></strong></pre>&#13;
&#13;
<p>You’re now running your own copy of the demo application, and you can check it by browsing to the same URL as before (<em>http://localhost:9999/</em>).</p>&#13;
&#13;
<p>You should see <code>Hello, 世界</code>. When you’re done running this image, press Ctrl-C to stop the <code>docker container run</code> command.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45979390390848">&#13;
<h5>Exercise</h5>&#13;
<p>If you’re feeling adventurous, modify the <em>main.go</em> file in the demo application and change the greeting so that it says, “Hello, world” in your favorite language (or change it to say whatever you like). Rebuild the container and run it to check that it works.</p>&#13;
&#13;
<p>Congratulations, you’re now a Go programmer! But don’t stop there: take the interactive <a href="https://tour.golang.org/welcome/1">Tour of Go</a> to learn more.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Port Forwarding" data-type="sect2"><div class="sect2" id="idm45979390387696">&#13;
<h2>Port Forwarding</h2>&#13;
&#13;
<p><a data-primary="port forwarding" data-secondary="explanation" data-type="indexterm" id="idm45979390386224"/>Programs running in a container are isolated from other programs running on the same machine, which means they can’t have direct access to resources like network ports.</p>&#13;
&#13;
<p>The demo application listens for connections on port 8888, but this is the <em>container’s</em> own private port 8888, not a port on your computer. In order to connect to the container’s port 8888, you need to <em>forward</em> a port on your local machine to that port on the container. It could be (<em>almost</em>) any port, including 8888, but we’ll use 9999 instead, to make it clear which is your port, and which is the container’s.</p>&#13;
&#13;
<p><a data-primary="port forwarding" data-secondary="with Docker" data-type="indexterm" id="idm45979390366704"/>To tell Docker to forward a port, you can use the <code>-p</code> switch, just as you did earlier in <a data-type="xref" href="#runningcontainer">“Running a Container Image”</a>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">docker container run -p HOST_PORT:CONTAINER_PORT ...</code></strong></pre>&#13;
&#13;
<p>Once the container is running, any requests to <code>HOST_PORT</code> on the local computer will be forwarded automatically to <code>CONTAINER_PORT</code> on the container, which is how you’re able to connect to the app with your browser.</p>&#13;
&#13;
<p>We said that you can use <em>almost</em> any port earlier because any port number below <code>1024</code> is considered a <a href="https://oreil.ly/q5SAU"><em>priviliged</em> port</a>, meaning that in order to use those ports, your process must run as a user with special permissions, such as <code>root</code>. Normal nonadministrator users cannot use ports below 1024, so, to avoid permission issues, we’ll stick with higher port numbers in our example.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Container Registries" data-type="sect1"><div class="sect1" id="containerregistries">&#13;
<h1>Container Registries</h1>&#13;
&#13;
<p><a data-primary="container registry" data-type="indexterm" id="idm45979390356944"/>In <a data-type="xref" href="#runningcontainer">“Running a Container Image”</a>, you were able to run an image just by giving its name, and Docker downloaded it for you automatically.</p>&#13;
&#13;
<p>You might reasonably wonder where it’s downloaded from. While you can use Docker perfectly well by just building and running local images, it’s much more useful if you can push and pull images from a <em>container registry</em>. The registry allows you to store images and retrieve them using a unique name (like <span class="keep-together"><code>cloudnatived/demo:hello</code></span>).</p>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="commands" data-tertiary="container run" data-type="indexterm" id="idm45979390335648"/>The default registry for the <code>docker container run</code> command is Docker Hub, but you can specify a different one, or set up your own.</p>&#13;
&#13;
<p>For now, let’s stick with Docker Hub. <a data-primary="Docker Hub" data-secondary="Docker ID creation" data-type="indexterm" id="idm45979390333504"/>While you can download and use any public container image from Docker Hub, to push your own images you’ll need an account (called a <em>Docker ID</em>). Follow the instructions on <a href="https://hub.docker.com">Docker Hub</a> to create your <span class="keep-together">Docker ID.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authenticating to the Registry" data-type="sect2"><div class="sect2" id="idm45979390330608">&#13;
<h2>Authenticating to the Registry</h2>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="commands" data-tertiary="login" data-type="indexterm" id="idm45979390329392"/><a data-primary="Docker Hub" data-secondary="authentication" data-type="indexterm" id="idm45979390328144"/>Once you’ve got your Docker ID, the next step is to connect your local Docker client with Docker Hub, using your ID and password:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>docker login</strong>&#13;
Login with your Docker ID to push and pull images from Docker Hub. If you don't&#13;
have a Docker ID, head over to https://hub.docker.com to create one.&#13;
Username: <strong><em>YOUR_DOCKER_ID</em></strong>&#13;
Password: <strong><em>YOUR_DOCKER_PASSWORD</em></strong>&#13;
Login Succeeded</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Naming and Pushing Your Image" data-type="sect2"><div class="sect2" id="idm45979390324208">&#13;
<h2>Naming and Pushing Your Image</h2>&#13;
&#13;
<p>In order to be able to push a local image to the registry, you need to name it using this format: <code>_YOUR_DOCKER_ID_/myhello</code>.</p>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="commands" data-tertiary="image tag" data-type="indexterm" id="idm45979390321648"/>To create this name, you don’t need to rebuild the image; instead, run this command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>docker image tag myhello <em>YOUR_DOCKER_ID</em>/myhello</strong></pre>&#13;
&#13;
<p>This is so that when you push the image to the registry, Docker knows which account to store it in.</p>&#13;
&#13;
<p><a data-primary="Docker" data-secondary="commands" data-tertiary="image push" data-type="indexterm" id="idm45979390317904"/>Go ahead and push the image to Docker Hub, using this command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>docker image push <em>YOUR_DOCKER_ID</em>/myhello</strong>&#13;
The push refers to repository [docker.io/<em>YOUR_DOCKER_ID</em>/myhello]&#13;
b2c591f16c33: Pushed&#13;
latest: digest:&#13;
sha256:7ac57776e2df70d62d7285124fbff039c9152d1bdfb36c75b5933057cefe4fc7&#13;
size: 528</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running Your Image" data-type="sect2"><div class="sect2" id="idm45979390314032">&#13;
<h2>Running Your Image</h2>&#13;
&#13;
<p>Congratulations! Your container image is now available to run anywhere (at least, anywhere with access to the internet), using the command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>docker container run -p 9999:8888 <em>YOUR_DOCKER_ID</em>/myhello</strong></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hello, Kubernetes" data-type="sect1"><div class="sect1" id="hellokube">&#13;
<h1>Hello, Kubernetes</h1>&#13;
&#13;
<p>Now that you’ve built and pushed your first container image to a registry, you can run it using the <code>docker container run</code> command, but that’s not very exciting. Let’s do something a little more adventurous and run it in Kubernetes.</p>&#13;
&#13;
<p>There are lots of ways to get a Kubernetes cluster, and we’ll explore some of them in more detail in <a data-type="xref" href="ch03.html#gettingk8s">Chapter 3</a>. If you already have access to a Kubernetes cluster, that’s great, and if you like, you can use it for the rest of the examples in this chapter.</p>&#13;
&#13;
<p>If not, don’t worry. Docker Desktop includes Kubernetes support (Linux users, see <a data-type="xref" href="#minikube">“Minikube”</a> instead). To enable it, open the Docker Desktop Preferences, select the Kubernetes tab, and check Enable. See the <a href="https://oreil.ly/4eBpc">Docker Desktop Kubernetes docs</a> for more info.</p>&#13;
&#13;
<p>It will take a few minutes to install and start Kubernetes. Once that’s done, you’re ready to run the demo app!</p>&#13;
&#13;
<p>Linux users will also need to install the <code>kubectl</code> tool, following the instructions on the <a href="https://oreil.ly/EXGeU">Kubernetes Documentation site</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running the Demo App" data-type="sect2"><div class="sect2" id="runningdemo">&#13;
<h2>Running the Demo App</h2>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="run" data-type="indexterm" id="idm45979390300848"/>Let’s start by running the demo image you built earlier. Open a terminal and run the <code>kubectl</code> command with the following arguments:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong>kubectl run demo --image=<em>YOUR_DOCKER_ID</em>/myhello --port=9999 --labels app=demo</strong>&#13;
pod/demo created</pre>&#13;
&#13;
<p>Don’t worry about the details of this command for now: it’s basically the Kubernetes equivalent of the <code>docker container run</code> command you used earlier in this chapter to run the demo image. If you haven’t built your own image yet, you can use ours: <span class="keep-together"><code>--image=cloudnatived/demo:hello</code></span>.</p>&#13;
&#13;
<p>Recall that you needed to forward port 9999 on your local machine to the container’s port 8888 in order to connect to it with your web browser. <a data-primary="kubectl" data-secondary="commands" data-tertiary="port-forward" data-type="indexterm" id="idm45979390294800"/><a data-primary="port forwarding" data-secondary="with kubectl" data-type="indexterm" id="idm45979390293552"/>You’ll need to do the same thing here, using <code>kubectl port-forward</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl port-forward pod/demo 9999:8888</code></strong><code class="go">&#13;
</code><code class="go">Forwarding from 127.0.0.1:9999 -&gt; 8888&#13;
</code><code class="go">Forwarding from [::1]:9999 -&gt; 8888</code></pre>&#13;
&#13;
<p>Leave this command running and open a new terminal to carry on.</p>&#13;
&#13;
<p>Connect to <em>http://localhost:9999/</em> with your browser to see the <code>Hello, 世界</code> message.</p>&#13;
&#13;
<p><a data-primary="kubectl" data-secondary="commands" data-tertiary="get" data-type="indexterm" id="idm45979390285568"/>It may take a few seconds for the container to start and for the app to be available. If it isn’t ready after half a minute or so, try this command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl get pods --selector app=demo</code></strong><code class="go">&#13;
</code><code class="go">NAME                    READY     STATUS    RESTARTS   AGE&#13;
</code><code class="go">demo                    1/1       Running   0          9m</code></pre>&#13;
&#13;
<p>When the container is running and you connect to it with your browser, you’ll see this message in the terminal:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="go">Handling connection for 9999</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="If the Container Doesn’t Start" data-type="sect2"><div class="sect2" id="idm45979390302032">&#13;
<h2>If the Container Doesn’t Start</h2>&#13;
&#13;
<p><a data-primary="Running status" data-type="indexterm" id="idm45979390253648"/>If the <code>STATUS</code> is not shown as <code>Running</code>, there may be a problem. <a data-primary="ErrImagePull status" data-type="indexterm" id="idm45979390251920"/><a data-primary="ImagePullBackOff status" data-type="indexterm" id="idm45979390251312"/>For example, if the status is <code>ErrImagePull</code> or <code>ImagePullBackoff</code>, it means Kubernetes wasn’t able to find and download the image you specified. You may have made a typo in the image name; check your <code>kubectl run</code> command.</p>&#13;
&#13;
<p><a data-primary="ContainerCreating status" data-type="indexterm" id="idm45979390231072"/>If the status is <code>ContainerCreating</code>, then all is well; Kubernetes is still downloading and starting the image. Just wait a few seconds and check again.</p>&#13;
&#13;
<p>Once you are done, you’ll want to clean up your demo container:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><strong><code class="go">kubectl delete pod demo</code></strong><code class="go">&#13;
</code><code class="go">pod "demo" deleted</code></pre>&#13;
&#13;
<p>We’ll cover more of the Kubernetes terminology in the coming chapters, but for now you can think of a <em>Pod</em> as a container running in Kubernetes, similar to how you ran a Docker container on your computer.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Minikube" data-type="sect1"><div class="sect1" id="minikube">&#13;
<h1>Minikube</h1>&#13;
&#13;
<p><a data-primary="Minikube" data-type="indexterm" id="idm45979390203360"/>If you don’t want to use, or can’t use, the Kubernetes support in Docker Desktop, there is an alternative: the well-loved Minikube. Like Docker Desktop, Minikube provides a single-node Kubernetes cluster that runs on your own machine (in fact, in a virtual machine, but that doesn’t matter).</p>&#13;
&#13;
<p>To install Minikube, follow the instructions in the official <a href="https://oreil.ly/zGROa">Minikube “Get Started!” guide</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45979390201200">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>If, like us, you quickly grow impatient with wordy essays about why Kubernetes is so great, we hope you enjoyed getting to grips with some practical tasks in this chapter. If you’re an experienced Docker or Kubernetes user already, perhaps you’ll forgive the refresher course. We want to make sure that everybody feels quite comfortable with building and running containers in a basic way, and that you have a Kubernetes environment you can play and experiment with, before getting on to more advanced things.</p>&#13;
&#13;
<p>Here’s what you should take away from this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>All the source code examples (and many more) are available in the <a href="https://oreil.ly/LAI8f">demo repository</a> that accompanies this book.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Docker tool lets you build containers locally, push them to or pull them from a container registry such as Docker Hub, and run container images locally on your machine.</p>&#13;
</li>&#13;
<li>&#13;
<p>A container image is completely specified by a Dockerfile: a text file that contains instructions about how to build the container.</p>&#13;
</li>&#13;
<li>&#13;
<p>Docker Desktop lets you run a small (single-node) Kubernetes cluster on your Mac or Windows machine. Minikube is another option and works on Linux.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>kubectl</code> tool is the primary way of interacting with a Kubernetes cluster. It can be used to create resources in Kubernetes, view the status of the cluster and Pods, and apply Kubernetes configuration in the form of YAML manifests.<a data-startref="ix_02-firststeps-adoc0" data-type="indexterm" id="idm45979390177152"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45979391921824"><sup><a href="ch02.html#idm45979391921824-marker">1</a></sup> If you’re not familiar with Git, read Scott Chacon and Ben Straub’s excellent book <a href="https://git-scm.com/book/en/v2"><em>Pro Git</em></a> (Apress).</p><p data-type="footnote" id="idm45979390606064"><sup><a href="ch02.html#idm45979390606064-marker">2</a></sup> If you’re new to Go, Jon Bodner’s <a href="https://oreil.ly/aNSCq"><em>Learning Go</em></a> (O’Reilly) is an invaluable guide.</p></div></div></section></body></html>