<html><head></head><body><section data-pdf-bookmark="Chapter 8. Transactions" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch08">&#13;
<h1><span class="label">Chapter 8. </span>Transactions</h1>&#13;
&#13;
&#13;
<p>MySQL has <a data-primary="transactions" data-type="indexterm" id="transactions1"/>nontransactional storage engines, like MyISAM, but InnoDB is the default and the presumptive norm.&#13;
Therefore, practically speaking, every MySQL query executes in a transaction by default, even a single <code>SELECT</code> statement.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This chapter does not apply if you happen to be using another storage engine, like Aria or MyRocks.&#13;
But more than likely, you’re using InnoDB, in which case: every MySQL query is a transaction.</p>&#13;
</div>&#13;
&#13;
<p>From our point of view as engineers, transactions appear conceptual: <code>BEGIN</code>, execute queries, and <code>COMMIT</code>.&#13;
Then we trust MySQL (and InnoDB) to uphold the ACID <a data-primary="ACID (atomicity, consistency, isolation, and durability) properties" data-type="indexterm" id="idm45829101643904"/>properties: atomicity, consistency, isolation, and durability.&#13;
When the application workload—queries, indexes, data, and access patterns—is well optimized, transactions are a nonissue with respect to performance.&#13;
(Most database topics are a nonissue when the workload is well optimized.)&#13;
But behind the scenes, transactions invoke a whole new world of considerations because upholding ACID properties  while maintaining performance is not an easy feat.&#13;
Fortunately, MySQL shines at executing transactions.</p>&#13;
&#13;
<p>As with replication lag in the previous chapter, the inner workings of transactions are beyond the scope of this book, but understanding a few basic concepts is pivotal to avoiding common problems that hoist transactions from the lowest levels of MySQL to the tops of engineers’ minds.&#13;
A little understanding avoids a lot of problems.</p>&#13;
&#13;
<p>This chapter examines MySQL transactions with respect to avoiding common problems.&#13;
There are five major sections.&#13;
The first descends into row locking with respect to transaction isolation levels.&#13;
The second examines how InnoDB manages concurrent data access while guaranteeing ACID properties: MVCC and the undo logs.&#13;
The third describes the history list length and how it indicates problematic transactions.&#13;
The fourth enumerates common problems with transactions to avoid.&#13;
The fifth is a foray into reporting transaction details in MySQL.<a data-primary="transactions" data-startref="transactions1" data-type="indexterm" id="idm45829099967104"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Row Locking" data-type="sect1"><div class="sect1" id="row-locking">&#13;
<h1>Row Locking</h1>&#13;
&#13;
<p>Reads do not lock rows <a data-primary="transactions" data-secondary="row locking" data-type="indexterm" id="transactions-row-locking_index1"/><a data-primary="row locking" data-type="indexterm" id="transactions-row-locking_index2"/>(except for <code>SELECT</code>…<code>FOR SHARE</code> and <code>SELECT</code>…<code>FOR UPDATE</code>), but writes always lock rows.&#13;
That’s simple and expected, but the tricky question is: which rows must be locked?&#13;
Of course, the rows being written must be locked.&#13;
But in a <code>REPEATABLE READ</code> transaction, InnoDB can lock significantly more rows than it writes.&#13;
This section illustrates and explains why.&#13;
But first, we must shift terminology into the vernacular of InnoDB data locking.</p>&#13;
&#13;
<p>Since tables are indexes (recall <a data-type="xref" href="ch02.html#tables-are-indexes">“InnoDB Tables Are Indexes”</a>), rows are index <em>records</em>.<a data-primary="index records" data-type="indexterm" id="index-records-ch8"/>&#13;
InnoDB row locking is discussed in terms of <em>locking records</em>, <a data-primary="locking records" data-type="indexterm" id="idm45829099265264"/>not locking rows, because of index record gaps.&#13;
A <em>gap</em> <a data-primary="gap (index records)" data-type="indexterm" id="gap-index-records-ch8"/>is a range of values between two index records, as illustrated in <a data-type="xref" href="#trx-idx-values">Figure 8-1</a>: a primary key with two records, two pseudo-records (infimum and supremum), and three gaps.</p>&#13;
&#13;
<figure><div class="figure" id="trx-idx-values">&#13;
<img alt="emsp 0801" src="assets/emsp_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>Index record gaps</h6>&#13;
</div></figure>&#13;
&#13;
<p>Records are depicted as solid squares with index values inside: 2 and 5 in this example.&#13;
Pseudo-records <a data-primary="pseudo-records" data-type="indexterm" id="idm45829102549920"/>are depicted as solid arrows on each end of the index: <em>infimum</em> and <em>supremum</em>.&#13;
Every InnoDB B-tree index has these two pseudo-records: infimum represents all index values less than the minimum record (2 in this example); supremum represents all index values greater than the maximum record (5 in this example).&#13;
Index records don’t begin at 2 or end at 5; technically, they begin and end at the infimum and supremum, and examples in this section reveal the importance of this detail.&#13;
Gaps are depicted as dashed squares with no index value.&#13;
If the primary key is a single unsigned four-byte integer, then the three gaps are (in interval notation):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>[0, 2)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>(2, 5)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>(5, 4294967295]</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>When discussing row locking, the term <em>record</em> is used instead of <em>row</em> because records have gaps, but it could be misleading to say that rows have gaps.&#13;
For example, if the application has two rows with values 2 and 5, that does not entail a gap in the rows comprising values 3 and 4 because maybe these aren’t valid values for the application.&#13;
But with respect to an index, between record values 2 and 5, values 3 and 4 constitute a valid record gap (presuming an integer column).&#13;
To put it succinctly: the application deals in rows; InnoDB row locking deals in records.&#13;
Examples in this section demonstrate that gap locks are surprisingly pervasive and arguably more important than individual record locks.<a data-primary="index records" data-startref="index-records-ch8" data-type="indexterm" id="idm45829097919488"/><a data-primary="gap (index records)" data-startref="gap-index-records-ch8" data-type="indexterm" id="idm45829097918512"/></p>&#13;
&#13;
<p>The term <em>data locks</em> <a data-primary="data locks" data-type="indexterm" id="idm45829103197216"/>refers to all types of locks.&#13;
There are many types of data locks, but <a data-type="xref" href="#lock-types">Table 8-1</a> lists the fundamental InnoDB data locks.</p>&#13;
<table id="lock-types">&#13;
<caption><span class="label">Table 8-1. </span>Fundamental InnoDB data locks</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Lock type</th>&#13;
<th>Abbreviation</th>&#13;
<th>Locks gap</th>&#13;
<th>Locks</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><em>Record lock</em></p></td>&#13;
<td><p><code>REC_NOT_GAP</code></p></td>&#13;
<td/>&#13;
<td><p>Locks a single record</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>Gap lock</em></p></td>&#13;
<td><p><code>GAP</code></p></td>&#13;
<td><p>✓</p></td>&#13;
<td><p>Locks the gap before (less than) a record</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>Next-key lock</em></p></td>&#13;
<td/>&#13;
<td><p>✓</p></td>&#13;
<td><p>Locks a single record and the gap before it</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>Insert intention lock</em></p></td>&#13;
<td><p><code>INSERT_INTENTION</code></p></td>&#13;
<td/>&#13;
<td><p>Allows <code>INSERT</code> into gap</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The best way to understand the fundamental InnoDB data locks is with real transactions, real locks, and illustrations.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of MySQL 8.0.16, data locks are easy to examine using Performance Schema tables <code>data_locks</code> and <code>data_lock_waits</code>.&#13;
The following examples use these Performance Schema tables.</p>&#13;
&#13;
<p>In MySQL 5.7 and older, you must first <code>SET GLOBAL innodb_status_output_locks=ON</code>, which requires <code>SUPER</code> MySQL privileges, then execute <code>SHOW ENGINE INNODB STATUS</code> and shift through the output to find the relevant transaction and locks.&#13;
It’s not easy—even experts strain to carefully parse the output.&#13;
Since MySQL 5.7 is not the current release, I do not use its output in this section; but since MySQL 5.7 is still widely used, refer to my blog post <a href="https://oreil.ly/pIAM6">“MySQL Data Locks: Mapping 8.0 to 5.7”</a> for an illustrated guide to mapping data lock output from MySQL 5.7 to MySQL 8.0.</p>&#13;
</div>&#13;
&#13;
<p>Let’s reuse the tried and true table <code>elem</code> but simplified as shown in <a data-type="xref" href="#trx-elem">Example 8-1</a>.</p>&#13;
<div class="pagebreak-before less_space" data-type="example" id="trx-elem">&#13;
<h5><span class="label">Example 8-1. </span>Table <code>elem</code> simplified</h5>&#13;
&#13;
<pre data-type="programlisting">CREATE TABLE `elem` (&#13;
  `id` int unsigned NOT NULL,&#13;
  `a`  char(2) NOT NULL,&#13;
  `b`  char(2) NOT NULL,&#13;
  `c`  char(2) NOT NULL,&#13;
  PRIMARY KEY (`id`),&#13;
  KEY `idx_a` (`a`)&#13;
) ENGINE=InnoDB;&#13;
&#13;
+----+-----+----+----+&#13;
| id | a   | b  | c  |&#13;
+----+-----+----+----+&#13;
|  2 | Au  | Be | Co |&#13;
|  5 | Ar  | Br | C  |&#13;
+----+-----+----+----+</pre></div>&#13;
&#13;
<p>The table <code>elem</code> is nearly the same as before, but now the nonunique index <code>idx_a</code> only covers column <code>a</code>, and there are only two rows, which create two primary key values as shown earlier in <a data-type="xref" href="#trx-idx-values">Figure 8-1</a>.&#13;
Since row locks are really index record locks and there are no indexes on columns <code>b</code> and <code>c</code>, you can ignore these two columns; they’re shown only for completeness and the nostalgia of simpler chapters, like <a data-type="xref" href="ch02.html#ch02">Chapter 2</a> when row locks were just rows locks.</p>&#13;
&#13;
<p>Since <a href="https://oreil.ly/86J7d"><code>autocommit</code></a> is enabled by default, the following examples begin with <code>BEGIN</code> to start an explicit transaction.&#13;
Locks are released when a transaction ends; therefore, the transaction is kept active—no <code>COMMIT</code> or <code>ROLLBACK</code>—to examine the data locks that the SQL statement following <code>BEGIN</code> has acquired (or is waiting to acquire).&#13;
At the end of each example, data locks are printed by querying the table <code>per​for​m⁠ance_schema.data_locks</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Record and Next-Key Locks" data-type="sect2"><div class="sect2" id="trx-record-locks">&#13;
<h2>Record and Next-Key Locks</h2>&#13;
&#13;
<p>An <code>UPDATE</code> on table <code>elem</code> using the primary key to match rows acquires four data locks in the default transaction isolation level, <code>REPEATABLE READ</code>:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
UPDATE elem SET c='' WHERE id BETWEEN 2 AND 5;&#13;
&#13;
&#13;
SELECT index_name, lock_type, lock_mode, lock_status, lock_data&#13;
FROM   performance_schema.data_locks&#13;
WHERE  object_name = 'elem';</pre>&#13;
&#13;
<pre class="pagebreak-before less_space" data-type="programlisting">+------------+-----------+---------------+-------------+-----------------------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data             |&#13;
+------------+-----------+---------------+-------------+-----------------------+&#13;
| NULL       | TABLE     | IX            | GRANTED     | NULL                  |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2                     |&#13;
| PRIMARY    | RECORD    | X             | GRANTED     | supremum pseudo-record|&#13;
| PRIMARY    | RECORD    | X             | GRANTED     | 5                     |&#13;
+------------+-----------+---------------+-------------+-----------------------+</pre>&#13;
&#13;
<p>Before illustrating and explaining these data locks, I will briefly describe what each row means:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The first row is a <em>table lock</em>, <a data-primary="table lock" data-type="indexterm" id="idm45829097856992"/>as indicated by the <code>lock_type</code> column.&#13;
InnoDB is a row-level locking storage engine, but MySQL also requires table locks—refer back to <a data-type="xref" href="ch01.html#Lock-time">“Lock time”</a>.&#13;
There will be a table lock for every table referenced by queries in the transaction.&#13;
I include table locks for completeness, but ignore them since we’re focusing on record locks.</p>&#13;
</li>&#13;
<li>&#13;
<p>The second row is a <em>record lock</em> <a data-primary="record lock" data-type="indexterm" id="record-lock"/>on primary key value 2, as indicated by all the columns.&#13;
The cryptic column is <code>lock_mode</code>: <code>X</code> means an exclusive lock (<code>S</code> [not shown] means a shared lock), and <code>REC_NOT_GAP</code> means a record lock.</p>&#13;
</li>&#13;
<li>&#13;
<p>The third row is a <em>next-key lock</em> <a data-primary="next-key lock" data-type="indexterm" id="next-key-lock"/>on the supremum pseudo-record.&#13;
In column <code>lock_mode</code>, a solitary <code>X</code> or <code>S</code> means an exclusive or shared next-key lock, respectively.&#13;
Imagine it as <code>X,NEXT_KEY</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The fourth row is a <em>next-key lock</em> on primary key value 5.&#13;
Again, the solitary <code>X</code> in column <code>lock_mode</code> means an exclusive next-key lock.&#13;
Imagine it as <code>X,NEXT_KEY</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#trx-idx-next-key-locks">Figure 8-2</a> illustrates the impact of these data locks.</p>&#13;
&#13;
<figure><div class="figure" id="trx-idx-next-key-locks">&#13;
<img alt="emsp 0802" src="assets/emsp_0802.png"/>&#13;
<h6><span class="label">Figure 8-2. </span>Record and next-key locks on primary key, <code>REPEATABLE READ</code> transaction</h6>&#13;
</div></figure>&#13;
&#13;
<p>Locked records are shaded; unlocked records are white.&#13;
The record lock on primary key value 2 is shaded darkly.&#13;
This record is locked because its corresponding row matches the table condition: <code>id BETWEEN 2 AND 5</code>.</p>&#13;
&#13;
<p>The next-key lock on primary key value 5 is shaded medium-dark, and the gap before it is shaded lightly.&#13;
This record is locked because its corresponding row matches the table condition, too.&#13;
The gap before this record is locked because it’s a next-key lock.&#13;
The gap comprises the nonexistent primary key values 3 and 4 (to which there are no corresponding rows).</p>&#13;
&#13;
<p>Similarly, the next-key lock on the supremum pseudo-record is shaded medium-dark, and the gap before it is shaded lightly.&#13;
The gap comprises all primary key values greater than 5.&#13;
The intriguing question is: why lock the supremum pseudo-record, which <em>includes</em> all primary key values greater than 5, when the table condition <em>excludes</em> primary key values greater than 5?&#13;
The answer is equally intriguing, but I must defer it until <a data-type="xref" href="#trx-gap-locks">“Gap Locks”</a>.</p>&#13;
&#13;
<p>Let’s confirm that the gaps are locked by trying to insert a row (using another transaction with autocommit enabled):</p>&#13;
&#13;
<pre data-type="programlisting">mysql&gt; INSERT INTO elem VALUES (3, 'Au', 'B', 'C');&#13;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction&#13;
&#13;
+------------+-----------+------------------------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode              | lock_status | lock_data |&#13;
+------------+-----------+------------------------+-------------+-----------+&#13;
| PRIMARY    | RECORD    | X,GAP,INSERT_INTENTION | WAITING     | 5         |&#13;
....&#13;
&#13;
mysql&gt; INSERT INTO elem VALUES (6, 'Au', 'B', 'C');&#13;
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction&#13;
&#13;
+------------+-----------+--------------------+-------------+--------------- ----+&#13;
| index_name | lock_type | lock_mode          | lock_status | lock_data          |&#13;
+------------+-----------+--------------------+-------------+--------------------+&#13;
| PRIMARY    | RECORD    | X,INSERT_INTENTION | WAITING     | supremum pseudo... |&#13;
...</pre>&#13;
&#13;
<p>The first <code>INSERT</code> times out trying to acquire an insert intention lock on the gap between values 2 and 5, which is where the new value (3) would be inserted.&#13;
Although column <code>lock_data</code> lists value 5, this record is <em>not</em> locked because this not a record or next-key lock: it’s an insert intentions lock, which is a special type of gap lock (for <code>INSERT</code>); therefore, it locks the gap before the value 5.&#13;
More on insert intention locks in <a data-type="xref" href="#trx-ii">“Insert Intention Locks”</a>.</p>&#13;
&#13;
<p>The second <code>INSERT</code> times out trying to acquire a next-key lock on the supremum pseudo-record because the new value, 6, is greater than the current maximum value, 5, so it would be inserted between the maximum record and the supremum pseudo-record.</p>&#13;
&#13;
<p>These <code>INSERT</code> statements prove that <a data-type="xref" href="#trx-idx-next-key-locks">Figure 8-2</a> is not wrong: nearly the entire index is locked except for values less than 2.&#13;
Why does InnoDB use next-key locks that lock the gaps instead of record locks?&#13;
Because the transaction isolation level is <code>REPEATABLE READ</code>, but that’s only part of the answer.&#13;
The complete answer is not straightforward, so bear with me for a moment.&#13;
By locking the gaps before the affected records, next-key locks isolate the entire range of records that the query accesses, which is the <em>I</em> in <a data-primary="ACID (atomicity, consistency, isolation, and durability) properties" data-type="indexterm" id="idm45829097828272"/>ACID: isolation.&#13;
That prevents a phenomenon called <a href="https://oreil.ly/DYs9L"><em>phantom rows</em></a> (or <em>phantom reads</em>) <a data-primary="phantom rows" data-type="indexterm" id="idm45829097826400"/>when, at a later time, a transaction reads rows that it did not read at an earlier time.&#13;
The new rows are <em>phantoms</em> because, like a ghost, they appear mysteriously.&#13;
(<em>Phantom</em> is the actual term in the ANSI SQL-92 standard.)&#13;
Phantom rows violate the principle of isolation, which is why certain transaction isolation levels forbid them.&#13;
Now the truly mysterious part of this explanation: the ANSI SQL-92 standard <em>allows</em> phantom rows in <code>REPEATABLE READ</code> but InnoDB prevents them with next-key locking.&#13;
But let’s not go down the proverbial rabbit hole by asking why InnoDB prevents phantom rows in <code>REPEATABLE READ</code>. Knowing why doesn’t change the fact, and it’s not uncommon for database servers to implement transaction isolation levels differently than the standard.<sup><a data-type="noteref" href="ch08.html#idm45829097823024" id="idm45829097823024-marker">1</a></sup>&#13;
For completeness, however, know that the ANSI SQL-92 standard forbids phantom rows only in the highest transaction isolate level: <code>SERIALIZABLE</code>.&#13;
InnoDB supports <code>SERIALIZABLE</code>, but I don’t cover it in this chapter because it’s not commonly used.&#13;
<code>REPEATABLE READ</code> is the default in MySQL and InnoDB uses next-key locks to prevent phantom rows in <code>REPEATABLE READ</code>.</p>&#13;
&#13;
<p>Transaction isolation level <code>READ COMMITTED</code> disables gap locking, which includes next-key locks.&#13;
To prove it, change the transaction isolation level to <code>READ COMMITTED</code>:</p>&#13;
&#13;
<pre data-type="programlisting">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;&#13;
BEGIN;&#13;
UPDATE elem SET c='' WHERE id BETWEEN 2 AND 5;&#13;
&#13;
&#13;
SELECT index_name, lock_type, lock_mode, lock_status, lock_data&#13;
FROM   performance_schema.data_locks&#13;
WHERE  object_name = 'elem';&#13;
+------------+-----------+---------------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data |&#13;
+------------+-----------+---------------+-------------+-----------+&#13;
| NULL       | TABLE     | IX            | GRANTED     | NULL      |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2         |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 5         |&#13;
+------------+-----------+---------------+-------------+-----------+</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>SET TRANSACTION</code> applies once to the next transaction.&#13;
After the next transaction, subsequent transactions use the default transaction isolation level.&#13;
See <a href="https://oreil.ly/46zcp"><code>SET TRANSACTION</code></a> for details.</p>&#13;
</div>&#13;
&#13;
<p>The same <code>UPDATE</code> statement in a <code>READ COMMITTED</code> transaction acquires records locks only on the matching rows, as illustrated in <a data-type="xref" href="#trx-idx-records-locks">Figure 8-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="trx-idx-records-locks">&#13;
<img alt="emsp 0803" src="assets/emsp_0803.png"/>&#13;
<h6><span class="label">Figure 8-3. </span>Record locks on primary key, <code>READ COMMITTED</code> transaction</h6>&#13;
</div></figure>&#13;
&#13;
<p>Why not use <code>READ COMMITTED</code>?&#13;
That question relates to an access pattern trait (<a data-type="xref" href="ch04.html#ap-trx-iso">“Transaction Isolation”</a>) that makes it entirely application-specific, even query-specific.&#13;
In a transaction, <code>READ COMMITTED</code> has two important side effects:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The same read statement can return different rows if re-executed.</p>&#13;
</li>&#13;
<li>&#13;
<p>The same write statement can affect different rows if re-executed.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These side effects explain why InnoDB does not need to use a consistent snapshot <a data-primary="consistent snapshot" data-type="indexterm" id="idm45829097805616"/>for reads or lock the gaps for writes: <code>READ COMMITTED</code> allows the transaction to read or write different records (for committed changes) at different times.&#13;
(<a data-type="xref" href="#mvcc">“MVCC and the Undo Logs”</a> defines <em>consistent snapshot</em>.)&#13;
Carefully consider these side effects with respect to your application.&#13;
If you are certain they will not cause a transaction to read, write, or return incorrect data, then <code>READ COMMITTED</code> reduces locks and undo logs, which helps improve performance.<a data-primary="record lock" data-startref="record-lock" data-type="indexterm" id="idm45829097802416"/><a data-primary="next-key lock" data-startref="next-key-lock" data-type="indexterm" id="idm45829097801360"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Gap Locks" data-type="sect2"><div class="sect2" id="trx-gap-locks">&#13;
<h2>Gap Locks</h2>&#13;
&#13;
<p>Gap locks <a data-primary="gap locks" data-type="indexterm" id="gap-locks2"/>are purely prohibitive: they prevent other transactions from inserting rows into the gap.&#13;
That’s all they do.</p>&#13;
&#13;
<p>Multiple transactions can lock the same gap because all gaps locks are compatible with other gap locks.&#13;
But since gap locks prevent <em>other</em> transactions from inserting rows into the gap, only one transaction can insert rows into a gap when it’s the only transaction locking the gap.&#13;
Two or more locks on the same gap prevent all transactions from inserting rows into the gap.</p>&#13;
&#13;
<p>The purpose of a gap lock is narrow: prevent other transactions from inserting rows into the gap.&#13;
But the creation of a gap lock is wide: any query that accesses the gap.&#13;
Reading nothing can create a gap lock that blocks inserting rows:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
SELECT * FROM elem WHERE id = 3 FOR SHARE;&#13;
&#13;
&#13;
SELECT index_name, lock_type, lock_mode, lock_status, lock_data&#13;
FROM   performance_schema.data_locks&#13;
WHERE  object_name = 'elem';&#13;
+------------+-----------+-----------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode | lock_status | lock_data |&#13;
+------------+-----------+-----------+-------------+-----------+&#13;
| NULL       | TABLE     | IS        | GRANTED     | NULL      |&#13;
| PRIMARY    | RECORD    | S,GAP     | GRANTED     | 5         |&#13;
+------------+-----------+-----------+-------------+-----------+</pre>&#13;
&#13;
<p>Prima facie, that <code>SELECT</code> seems innocuous: a <code>SELECT</code> in <code>REPEATABLE READ</code> uses a consistent snapshot, <a data-primary="consistent snapshot" data-type="indexterm" id="idm45829097792480"/>and <code>FOR SHARE</code> only creates shared locks, so it won’t block other reads.&#13;
More importantly, the <code>SELECT</code> doesn’t match any rows: table <code>elem</code> has primary key values 2 and 5, not 3.&#13;
No rows, no locks—right?&#13;
Wrong.&#13;
By accessing the gap with <code>READ REPEATABLE</code> and <code>SELECT</code>…<code>FOR SHARE</code>, you summon a lone gap lock: <a data-type="xref" href="#trx-idx-s-gap">Figure 8-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="trx-idx-s-gap">&#13;
<img alt="emsp 0804" src="assets/emsp_0804.png"/>&#13;
<h6><span class="label">Figure 8-4. </span>Lone gap lock</h6>&#13;
</div></figure>&#13;
&#13;
<p>I call it a <em>lone</em> gap lock <a data-primary="lone gap lock" data-type="indexterm" id="idm45829097786176"/>because it doesn’t accompany a next-key lock or insert intention lock; it stands alone.&#13;
All gap locks—shared or exclusive—prevent other transactions from inserting rows into the gap.&#13;
That innocuous <code>SELECT</code> statement is actually an insidious <code>INSERT</code> blocker.&#13;
The larger the gap, the larger the block, which the next section illustrates with a secondary index.</p>&#13;
&#13;
<p>The easy creation of gap locks by any access to the gap is part of the answer to the intriguing question in <a data-type="xref" href="#trx-record-locks">“Record and Next-Key Locks”</a>: why lock the supremum pseudo-record, which <em>includes</em> all primary key values greater than 5, when the table condition <em>excludes</em> primary key values greater than 5?&#13;
First, let me dial the intrigue to maximum.&#13;
Here’s the original query and its data locks:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
UPDATE elem SET c='' WHERE id BETWEEN 2 AND 5;&#13;
&#13;
+------------+-----------+---------------+-------------+------------------------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data              |&#13;
+------------+-----------+---------------+-------------+------------------------+&#13;
| NULL       | TABLE     | IX            | GRANTED     | NULL                   |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2                      |&#13;
| PRIMARY    | RECORD    | X             | GRANTED     | supremum pseudo-record |&#13;
| PRIMARY    | RECORD    | X             | GRANTED     | 5                      |&#13;
+------------+-----------+---------------+-------------+------------------------+</pre>&#13;
&#13;
<p class="pagebreak-before less_space">Now, here’s the same query but with an <code>IN</code> clause instead of a <code>BETWEEN</code> clause:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
UPDATE elem SET c='' WHERE id IN (2, 5);&#13;
&#13;
+------------+-----------+---------------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data |&#13;
+------------+-----------+---------------+-------------+-----------+&#13;
| NULL       | TABLE     | IX            | GRANTED     | NULL      |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2         |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 5         |&#13;
+------------+-----------+---------------+-------------+-----------+</pre>&#13;
&#13;
<p>Both transactions are <code>REPEATABLE READ</code>, and both queries have the exact same EXPLAIN plan: range access on primary key.&#13;
But the new query acquires record locks only on the matching rows.&#13;
What is this magic?&#13;
<a data-type="xref" href="#trx-id-in">Figure 8-5</a> shows what’s happening for each query.</p>&#13;
&#13;
<figure><div class="figure" id="trx-id-in">&#13;
<img alt="emsp 0805" src="assets/emsp_0805.png"/>&#13;
<h6><span class="label">Figure 8-5. </span>Range access for <code>BETWEEN</code> versus <code>IN</code>, <code>REPEATABLE READ</code> transaction</h6>&#13;
</div></figure>&#13;
&#13;
<p>Row access for <code>BETWEEN</code> happens as you might expect: from 2 to 5 and everything between.&#13;
In simplistic terms, the sequence of row access for <code>BETWEEN</code> is:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Read row at index value 2</p>&#13;
</li>&#13;
<li>&#13;
<p>Row matches: record lock</p>&#13;
</li>&#13;
<li>&#13;
<p>Next index value: 5</p>&#13;
</li>&#13;
<li>&#13;
<p>Traverse the gap from 2 to 5</p>&#13;
</li>&#13;
<li>&#13;
<p>Read row at index value 5</p>&#13;
</li>&#13;
<li>&#13;
<p>Row matches: next-key lock</p>&#13;
</li>&#13;
<li>&#13;
<p>Next index value: supremum</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<ol class="pagebreak-before less_space" start="8">&#13;
<li>&#13;
<p>Traverse the gap from 5 to supremum</p>&#13;
</li>&#13;
<li>&#13;
<p>End of the index: next-key lock</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>But the sequence of row access for <code>IN</code> is much simpler:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Read row at index value 2</p>&#13;
</li>&#13;
<li>&#13;
<p>Row matches: record lock</p>&#13;
</li>&#13;
<li>&#13;
<p>Read row at index value 5</p>&#13;
</li>&#13;
<li>&#13;
<p>Row matches: record lock</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Despite having the exact same EXPLAIN plan and matching the same rows, the queries access rows differently.&#13;
The original query (<code>BETWEEN</code>) accesses the gaps; therefore, it uses next-key locks to lock the gaps.&#13;
The new query (<code>IN</code>) does not access the gaps; therefore, it uses record locks.&#13;
But make no mistake: the <code>IN</code> clause does not preclude gap locking.&#13;
If the new query table condition is <code>IN (2, 3, 5)</code>, that accesses the gap between value 2 and 5 and causes a gap lock (not a next-key lock):</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
UPDATE elem SET c='' WHERE id IN (2, 3, 5);&#13;
&#13;
+------------+-----------+---------------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data |&#13;
+------------+-----------+---------------+-------------+-----------+&#13;
| NULL       | TABLE     | IX            | GRANTED     | NULL      |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2         |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 5         |&#13;
| PRIMARY    | RECORD    | X,GAP         | GRANTED     | 5         |&#13;
+------------+-----------+---------------+-------------+-----------+</pre>&#13;
&#13;
<p>You have a lone gap lock: <code>X,GAP</code>.&#13;
But notice: there is no next-key lock on the supremum pseudo-record because <code>IN (2, 3, 5)</code> does not access that gap.&#13;
Mind the gap.</p>&#13;
&#13;
<p>Gap locking is easy to disable by using <code>READ COMMITTED</code>.&#13;
A <code>READ COMMITTED</code> transaction doesn’t need gap locks (or next-key locks) because records in the gap are allowed to change, and each query accesses the latest latest changes (committed rows) when it executes.&#13;
Even the lone gap lock summoned by <code>SELECT * FROM elem WHERE id = 3 FOR SHARE</code> is quashed by <code>READ COMMITTED</code>.<a data-primary="gap locks" data-startref="gap-locks2" data-type="indexterm" id="idm45829097748816"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Secondary Indexes" data-type="sect2"><div class="sect2" id="trx-secondary-indexes">&#13;
<h2>Secondary Indexes</h2>&#13;
&#13;
<p>Secondary indexes <a data-primary="secondary indexes" data-type="indexterm" id="secondary-indexes2_index1"/><a data-primary="indexes" data-secondary="secondary" data-type="indexterm" id="secondary-indexes2_index2"/>introduce potentially wide-ranging consequences with respect to row locking, especially nonunique indexes.&#13;
Recall that simplified table <code>elem</code> (<a data-type="xref" href="#trx-elem">Example 8-1</a>) has a nonunique secondary index on column <code>a</code>.&#13;
With that in mind, let’s see how the following <code>UPDATE</code> in a <code>REPEATABLE READ</code> transaction locks records on the secondary index and the primary key:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
UPDATE elem SET c='' WHERE a BETWEEN 'Ar' AND 'Au';&#13;
&#13;
&#13;
SELECT   index_name, lock_type, lock_mode, lock_status, lock_data&#13;
FROM     performance_schema.data_locks&#13;
WHERE    object_name = 'elem'&#13;
ORDER BY index_name;&#13;
+------------+-----------+---------------+-------------+------------------------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data              |&#13;
+------------+-----------+---------------+-------------+------------------------+&#13;
| NULL       | TABLE     | IX            | GRANTED     | NULL                   |&#13;
| a          | RECORD    | X             | GRANTED     | supremum pseudo-record |&#13;
| a          | RECORD    | X             | GRANTED     | 'Au', 2                |&#13;
| a          | RECORD    | X             | GRANTED     | 'Ar', 5                |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2                      |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 5                      |&#13;
+------------+-----------+---------------+-------------+------------------------+</pre>&#13;
&#13;
<p><a data-type="xref" href="#trx-idx-gap-lock">Figure 8-6</a> illustrates those six records locks: four on the secondary index and two on the primary key.</p>&#13;
&#13;
<figure><div class="figure" id="trx-idx-gap-lock">&#13;
<img alt="emsp 0806" src="assets/emsp_0806.png"/>&#13;
<h6><span class="label">Figure 8-6. </span>Next-key locks on secondary index, <code>REPEATABLE READ</code> transaction</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>UPDATE</code> only matches two rows, but it locks the entire secondary index, which prevents inserting any values.&#13;
The locks on the secondary index are similar to those in <a data-type="xref" href="#trx-idx-next-key-locks">Figure 8-2</a>.&#13;
But now there is a next-key lock on the first record in the secondary index record: tuple <code>('Ar', 5)</code>, where 5 is the corresponding primary key value.&#13;
This next-key lock isolates the range from new duplicate “Ar” values.&#13;
For example, it prevents inserting the tuple <code>('Ar', 1)</code>, which sorts before  <code>('Ar', 5)</code>.</p>&#13;
&#13;
<p>Normally, InnoDB does not lock an entire secondary index.&#13;
That happens in these examples only because there are only two index records (in both the primary key and the nonunique secondary index).&#13;
But recall <a data-type="xref" href="ch02.html#extreme-selectivity">“Extreme Selectivity”</a>: the lower the selectivity, the larger the gaps.&#13;
As an extreme example, if a nonunique index has 5 unique values evenly distributed over 100,000 rows, that is 20,000 records per row (100,000 rows / 5 cardinality), or 20,000 records per gap.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The lower the index selectivity, the larger the record gaps.</p>&#13;
</div>&#13;
&#13;
<p><code>READ COMMITTED</code> avoids gap locking, even for nonunique secondary indexes because only matching rows are locked with record locks.&#13;
But let’s not make it too easy on ourselves; let’s keep examining InnoDB data locks on nonunique secondary indexes for different kinds of data changes.</p>&#13;
&#13;
<p>At the end of the previous section, changing the <code>BETWEEN</code> clause to an <code>IN</code> clause averted gap locking, but that does not work with a nonunique index.&#13;
In fact, InnoDB <em>adds</em> a gap lock in this case:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
UPDATE elem SET c='' WHERE a IN ('Ar', 'Au');&#13;
&#13;
&#13;
SELECT   index_name, lock_type, lock_mode, lock_status, lock_data&#13;
FROM     performance_schema.data_locks&#13;
WHERE    object_name = 'elem'&#13;
ORDER BY index_name;&#13;
+------------+-----------+---------------+-------------+------------------------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data              |&#13;
+------------+-----------+---------------+-------------+------------------------+&#13;
| a          | RECORD    | X,GAP         | GRANTED     | 'Au', 2                |&#13;
...</pre>&#13;
&#13;
<p>I removed the original data locks from the output (they’re identical) to highlight the new gap lock on tuple <code>('Au', 2)</code>.&#13;
Strictly speaking, this gap lock is redundant with the next-key lock on the same tuple, but it does not result in incorrect locking or data access.&#13;
Therefore, just let it be and never forget: InnoDB is full of wonders and mysteries.&#13;
And what would life be without a few of those?</p>&#13;
&#13;
<p>It’s important to examine data locks because InnoDB is full of surprises.&#13;
Although this section is detailed and meticulous, it’s barely below the surface—InnoDB locking is deep, and in the depths hide secrets.&#13;
For example, what data locks might InnoDB require if “Au” is changed to “Go”?&#13;
Let’s examine the data locks of that change:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
UPDATE elem SET a = 'Go' WHERE a = 'Au';&#13;
&#13;
+------------+-----------+---------------+-------------+------------------------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data              |&#13;
+------------+-----------+---------------+-------------+------------------------+&#13;
| NULL       | TABLE     | IX            | GRANTED     | NULL                   |&#13;
| a          | RECORD    | X             | GRANTED     | supremum pseudo-record |&#13;
| a          | RECORD    | X             | GRANTED     | 'Au', 2                |&#13;
| a          | RECORD    | X,GAP         | GRANTED     | 'Go', 2                |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2                      |&#13;
+------------+-----------+---------------+-------------+------------------------+</pre>&#13;
&#13;
<p><a data-type="xref" href="#trx-idx-si-update">Figure 8-7</a> visualizes those four data locks.</p>&#13;
&#13;
<figure><div class="figure" id="trx-idx-si-update">&#13;
<img alt="emsp 0807" src="assets/emsp_0807.png"/>&#13;
<h6><span class="label">Figure 8-7. </span>Update nonunique secondary index value, <code>REPEATABLE READ</code> transaction</h6>&#13;
</div></figure>&#13;
&#13;
<p>The “Au” value is gone—changed to “Go”—but InnoDB still holds a next-key lock on the tuple: <code>('Au', 2)</code>.&#13;
The new “Go” does not have record lock or next-key lock, only a gap lock before the tuple: <code>('Go', 2)</code>.&#13;
So what’s locking the new “Go” record?&#13;
Is this some kind of <code>REPEATABLE READ</code> side effect?&#13;
Let’s change the transaction isolation level and re-examine the data locks:</p>&#13;
&#13;
<pre data-type="programlisting">SET TRANSACTION ISOLATION LEVEL READ COMMITTED;&#13;
BEGIN;&#13;
UPDATE elem SET a = 'Go' WHERE a = 'Au';&#13;
&#13;
+------------+-----------+---------------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode     | lock_status | lock_data |&#13;
+------------+-----------+---------------+-------------+-----------+&#13;
| NULL       | TABLE     | IX            | GRANTED     | NULL      |&#13;
| a          | RECORD    | X,REC_NOT_GAP | GRANTED     | 'Au', 2   |&#13;
| PRIMARY    | RECORD    | X,REC_NOT_GAP | GRANTED     | 2         |&#13;
+------------+-----------+---------------+-------------+-----------+</pre>&#13;
&#13;
<p>Switching to <code>READ COMMITTED</code> disables gap locking as expected, but where is the lock—any lock—on the new “Go” value?&#13;
“Writes always lock rows,” or at least that’s what I said at the beginning of <a data-type="xref" href="#row-locking">“Row Locking”</a>.&#13;
And yet, InnoDB reports no locks for this write…</p>&#13;
&#13;
<p>What if I told you that InnoDB is so optimized that it can lock without locking?&#13;
Let’s use the next type of data lock, insert intention, to stare perilously deep into InnoDB locking and resolve this mystery.<a data-primary="secondary indexes" data-startref="secondary-indexes2_index1" data-type="indexterm" id="idm45829097711888"/><a data-primary="indexes" data-secondary="secondary" data-startref="secondary-indexes2_index2" data-type="indexterm" id="idm45829097710944"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Insert Intention Locks" data-type="sect2"><div class="sect2" id="trx-ii">&#13;
<h2>Insert Intention Locks</h2>&#13;
&#13;
<p>An <em>insert intention lock</em> <a data-primary="insert intention locks" data-type="indexterm" id="insert-intention-locks"/>is a special type of gap lock that means the transaction will insert a row into the gap when the gap is not locked by other transactions.&#13;
Only gap locks block insert intention locks.&#13;
(Remember: <em>gap locks</em> include next-key locks because the latter are a combination of record lock and gap lock.)&#13;
Insert intention locks are compatible with (do not block) other insert intention locks.&#13;
This is important for <code>INSERT</code> performance because it allows multiple transactions to insert different rows into the same gap at the same time.&#13;
How does InnoDB handle duplicate keys?&#13;
I return to this question after demonstrating other facets of insert intention locks that make the answer more clear.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Gap locks <em>prevent</em> <code>INSERT</code>.&#13;
Insert intention locks <em>allow</em> <code>INSERT</code>.</p>&#13;
</div>&#13;
&#13;
<p>Insert intention locks are special for three reasons:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Insert intention locks do not lock the gap because, as the term <em>intention</em> implies, they represent a <em>future</em> action: inserting a row <em>when</em> there are no gap locks held by other transactions.</p>&#13;
</li>&#13;
<li>&#13;
<p>Insert intention locks are created and reported only when they conflict with gap locks held by other transactions; otherwise, insert intention locks are not created or reported by the transaction inserting the row.</p>&#13;
</li>&#13;
<li>&#13;
<p>If an insert intention lock is created, it is used once and released immediately once granted; but InnoDB continues to report it until the transaction is complete.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In a sense, insert intention locks aren’t locks because they don’t block access.&#13;
They’re more like wait conditions that InnoDB uses to signal when a transaction can proceed with an <code>INSERT</code>.&#13;
Granting the insert intention lock is the signal.&#13;
But if a transaction doesn’t have to wait because there are no conflict gap locks, then it doesn’t wait, and you won’t see an insert intention lock because none was created.</p>&#13;
&#13;
<p>Let’s see insert intention locks in action.&#13;
Start by locking the gap between primary key values 2 and 5; then, in a second transaction, try to insert a row with primary key value 3:</p>&#13;
&#13;
<pre data-type="programlisting">-- First transaction&#13;
BEGIN;&#13;
UPDATE elem SET c='' WHERE id BETWEEN 2 AND 5;&#13;
&#13;
-- Second transaction&#13;
BEGIN;&#13;
INSERT INTO elem VALUES (3, 'As', 'B', 'C');&#13;
&#13;
+------------+-----------+------------------------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode              | lock_status | lock_data |&#13;
+------------+-----------+------------------------+-------------+-----------+&#13;
| PRIMARY    | RECORD    | X,GAP,INSERT_INTENTION | WAITING     | 5         |&#13;
...</pre>&#13;
&#13;
<p><code>X,GAP,INSERT_INTENTION</code> in column <code>lock_mode</code> is an insert intention lock.&#13;
It’s also listed as <code>X,INSERT_INTENTION</code> (not shown) when locking and inserting into the gap between the maximum record value and the supremum pseudo-record.</p>&#13;
&#13;
<p>The first transaction locks the gap before primary key value 5.&#13;
That gap lock blocks the second transaction from inserting into the gap, so it creates an insert intention lock and waits.&#13;
Once the first transaction commits (or rolls back), the gap <span class="keep-together">is unlocked</span>, the insert intention lock is granted, and the second transaction inserts <span class="keep-together">the row</span>:</p>&#13;
&#13;
<pre data-type="programlisting">-- First transaction&#13;
COMMIT;&#13;
&#13;
-- Second transaction&#13;
-- INSERT executes&#13;
&#13;
+------------+-----------+------------------------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode              | lock_status | lock_data |&#13;
+------------+-----------+------------------------+-------------+-----------+&#13;
| NULL       | TABLE     | IX                     | GRANTED     | NULL      |&#13;
| PRIMARY    | RECORD    | X,GAP,INSERT_INTENTION | GRANTED     | 5         |&#13;
+------------+-----------+------------------------+-------------+-----------+</pre>&#13;
&#13;
<p>As noted earlier, InnoDB continues to report an insert intention lock even though, once granted, it is used once and released immediately.&#13;
Consequently, it looks like the gap is locked, but it’s an illusion—a ploy by InnoDB to lure us in deeper.&#13;
You can prove that it’s an illusion by inserting another row into the gap at primary key value 4; it does not block.&#13;
Why does InnoDB continue to report an insert intention lock that’s not really there?&#13;
Few mortals know, and it matters not.&#13;
Look past the illusion to see it for what it <em>was</em>: in the past, the transaction blocked before inserting a row into <span class="keep-together">the gap</span>.</p>&#13;
&#13;
<p>For completeness and a segue into deeper aspects of InnoDB locking, especially with respect to insert intention locks, here is what you see when an <code>INSERT</code> does not block on gap locks:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
INSERT INTO elem VALUES (9, 'As', 'B', 'C'); -- Does not block&#13;
&#13;
+------------+-----------+-----------+-------------+-----------+&#13;
| index_name | lock_type | lock_mode | lock_status | lock_data |&#13;
+------------+-----------+-----------+-------------+-----------+&#13;
| NULL       | TABLE     | IX        | GRANTED     | NULL      |&#13;
+------------+-----------+-----------+-------------+-----------+</pre>&#13;
&#13;
<p>No record locks at all.&#13;
That’s how insert intention locks work on the surface, but we came here to stare perilously deep into InnoDB locking, so let’s go deeper by asking the question that led us here: why is there no record (or next-key) lock on the newly inserted row?&#13;
This is the same mystery from the previous section: no lock on the new “Go” value.</p>&#13;
&#13;
<p>This is the secret: InnoDB has explicit <a data-primary="explicit locks" data-type="indexterm" id="idm45829097682784"/><a data-primary="InnoDB" data-secondary="explicit locks" data-type="indexterm" id="idm45829097682080"/>and implicit locks <a data-primary="implicit locks" data-type="indexterm" id="implicit-locks-ch8"/><a data-primary="InnoDB" data-secondary="implicit locks" data-type="indexterm" id="InnoDB-implicit-locks-ch8"/>and it only reports explicit locks.<sup><a data-type="noteref" href="ch08.html#idm45829097678720" id="idm45829097678720-marker">2</a></sup>&#13;
Explicit locks exist as lock structures in memory; therefore, InnoDB can report them.&#13;
But implicit locks do not exist: there is no lock structure; therefore, InnoDB has nothing to report.</p>&#13;
&#13;
<p>In the previous example, <code>INSERT INTO elem VALUES (9, 'As', 'B', 'C')</code>, the index record for the new row exists, but the row is not committed (because the transaction has not committed).&#13;
If another transaction attempts to lock the row, it detects three conditions:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The row is not committed.</p>&#13;
</li>&#13;
<li>&#13;
<p>The row belongs to another transaction.</p>&#13;
</li>&#13;
<li>&#13;
<p>The row is not explicitly locked.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Then magic happens: the requesting transaction—the transaction attempting to lock the record—converts the implicit lock to an explicit lock <em>on behalf of</em> the owning transaction—the transaction that created the record.&#13;
Yes, that means one transaction creates a lock for another transaction—but that’s not the confusing part.&#13;
Since the requesting transaction creates the lock that it’s trying to acquire, at first glance InnoDB seems to report that the transaction is waiting for a lock that it holds—the transaction is blocked on itself.&#13;
There’s a way to see through this illusion, but we’ve gone too deep.</p>&#13;
&#13;
<p>I hope that, as an engineer using MySQL, you never need to descend to this depth of InnoDB locking to achieve remarkable performance with MySQL.&#13;
But I led us down here for two reasons.&#13;
First, despite the illusions, the fundamentals of InnoDB row locking with respect to transaction isolation levels are tractable and applicable.&#13;
You are now fantastically well prepared to handle every common InnoDB row locking issue—and more.&#13;
Second, InnoDB made me do it because I stared too deeply for too long; and when it all blurred into one, I knew that I had fallen from the precipice and could never return.&#13;
Don’t ask why it locks the supremum pseudo-record beyond the table condition range.&#13;
Don’t ask why it has redundant gap locks.&#13;
Don’t ask why it converts implicit locks.&#13;
Don’t ask; else the questions never cease.&#13;
Go on; save yourself.<a data-primary="implicit locks" data-startref="implicit-locks-ch8" data-type="indexterm" id="idm45829097670160"/><a data-primary="InnoDB" data-secondary="implicit locks" data-startref="InnoDB-implicit-locks-ch8" data-type="indexterm" id="idm45829097669184"/><a data-primary="transactions" data-secondary="row locking" data-startref="transactions-row-locking_index1" data-type="indexterm" id="idm45829097667952"/><a data-primary="row locking" data-startref="transactions-row-locking_index2" data-type="indexterm" id="idm45829097666720"/><a data-primary="insert intention locks" data-startref="insert-intention-locks" data-type="indexterm" id="idm45829097665760"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="MVCC and the Undo Logs" data-type="sect1"><div class="sect1" id="mvcc">&#13;
<h1>MVCC and the Undo Logs</h1>&#13;
&#13;
<p>InnoDB uses <a data-primary="transactions" data-secondary="multiversion concurrency control (MVCC) and undo logs" data-type="indexterm" id="transactions-mvcc-ch8"/><a data-primary="multiversion concurrency control (MVCC)" data-type="indexterm" id="mvcc-ch8"/><a data-primary="undo logs" data-type="indexterm" id="undo-logs-ch8"/>multiversion concurrency control (MVCC) and undo logs to accomplish the <em>A</em>, <em>C</em>, and <em>I</em> properties of <a data-primary="ACID (atomicity, consistency, isolation, and durability) properties" data-type="indexterm" id="idm45829097658720"/>ACID.&#13;
(To accomplish the <em>D</em>, InnoDB uses a transaction log—see <a data-type="xref" href="ch06.html#metrics-trx-log">“Transaction log”</a>.)&#13;
<em>Multiversion concurrency control</em> means that changes to a row create a new version of the row.&#13;
MVCC is not unique to InnoDB; it’s a common method that many data stores use.&#13;
When a row is first created, it’s version 1.&#13;
When it’s first updated, it’s version 2.&#13;
The basis of MVCC is that simple, but it quickly becomes more complex and interesting.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Using the term <em>undo logs</em> is an intentional simplification because the full structure of undo logging is complex.&#13;
The term <em>undo logs</em> is sufficiently precise to learn what it does and how it affects <span class="keep-together">performance</span>.</p>&#13;
</div>&#13;
&#13;
<p><em>Undo logs</em> record how to roll back changes to a previous row version.&#13;
<a data-type="xref" href="#trx-mvcc">Figure 8-8</a> shows a single row with five versions and five undo logs that allow MySQL to roll back changes to previous row versions.</p>&#13;
&#13;
<p>That row harkens back to <a data-type="xref" href="ch02.html#tables-are-indexes">“InnoDB Tables Are Indexes”</a> in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>: it’s the row with primary key value 2 in table <code>elem</code>, depicted as the primary key leaf node.&#13;
For brevity, I include only the primary key value (2), the row version (v1 through v5), and column <code>a</code> value (“Au” for v5); the other two columns, <code>b</code> and <code>c</code>, are not shown.</p>&#13;
&#13;
<p>Version 5 (bottom right in <a data-type="xref" href="#trx-mvcc">Figure 8-8</a>) is the current row that all new transactions will read, but let’s begin at the beginning.&#13;
The row is created as iron (“Fe”): version 1 in the upper left corner.&#13;
There’s an undo log for version 1 because <code>INSERT</code> creates the first version of a row.&#13;
Then column <code>a</code> is modified (<code>UPDATE</code>) to change iron to titanium (“Ti”): version 2.&#13;
Upon creating version 2, MySQL also creates an undo log that records how to roll back version 2 changes, which restores version 1.&#13;
(In the next paragraph, I explain why version 1 has a solid outline [and a camera icon] but version 2 has a dashed outline.)&#13;
Then column <code>a</code> is modified to change titanium to silver (“Ag”): version 3.&#13;
MySQL creates an undo log that records how to roll back version 3 changes, and this undo log is linked to the previous so that MySQL can, if needed, roll back and restore version 2.&#13;
Two more row updates occur: silver to Californium (“Cf”) for version 4, and Californium to gold (“Au”) for version 5.</p>&#13;
&#13;
<figure><div class="figure" id="trx-mvcc">&#13;
<img alt="emsp 0808" src="assets/emsp_0808.png"/>&#13;
<h6><span class="label">Figure 8-8. </span>One row with five versions and five undo logs</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There are two sets of undo logs: <em>insert undo logs</em> for <code>INSERT</code> and <em>update undo logs</em> for <code>UPDATE</code> and <code>DELETE</code>.&#13;
For simplicity, I refer only to undo logs, which comprises both sets.</p>&#13;
</div>&#13;
&#13;
<p>Version 1 has a solid outline and camera icon because an active transaction (not shown) holds a consistent snapshot <a data-primary="consistent snapshot" data-type="indexterm" id="consistent-snapshot-ch8"/>at this point in the history of the database.&#13;
Let me unpack that sentence.&#13;
InnoDB supports four <a href="https://oreil.ly/xH5Gs">transaction isolation levels</a>, but only two are commonly used: <code>REPEATABLE READ</code> (the default) and <code>READ COMMITTED</code>.</p>&#13;
&#13;
<p>In a <code>REPEATABLE READ</code> transaction, the first read establishes a <em>consistent snapshot</em> (or <em>snapshot</em> for short): a virtual view of the database (all tables) at the moment when the <code>SELECT</code> is executed.&#13;
The snapshot is held until the end of the transaction and used by all subsequent reads to access rows only at this point in the history of the database.&#13;
Changes made by other transactions after this point are not figuratively visible within the original transaction.&#13;
Presuming that other transactions are modifying the database, the snapshot of the original transaction becomes an increasingly old view of the database while the transaction remains active (does not <code>COMMIT</code> or <code>ROLLBACK</code>).&#13;
It’s like the original transaction is stuck in the 1980s and the only musicians it listens to are Pat Benatar, Stevie Nicks, and Taylor Dayne: old but still great.</p>&#13;
&#13;
<p>Since version 5 is the current row, new transactions establish a snapshot from its point in database history, which is why it has a solid outline and camera icon.&#13;
The important question is: why do versions 2, 3, and 4 still exist when there are no transactions holding snapshots at their respective points in database history?&#13;
They exist to maintain the snapshot for version 1 because MySQL uses undo logs to reconstruct old row versions.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>MySQL uses undo logs to reconstruct old row versions for <span class="keep-together">snapshots</span>.</p>&#13;
</div>&#13;
&#13;
<p>It’s easy to reconstruct <a data-type="xref" href="#trx-mvcc">Figure 8-8</a>.&#13;
First, immediately after inserting the row in <a data-type="xref" href="#trx-mvcc">Figure 8-8</a>, start a transaction and establish a  snapshot on version 1 of the row by executing a <code>SELECT</code> statement:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
&#13;
SELECT a FROM elem WHERE id = 2;&#13;
&#13;
-- Returns row version 1: 'Fe'</pre>&#13;
&#13;
<p>Since there’s no <code>COMMIT</code>, that transaction is still active and holding its snapshot on the entire database, which is simply row version 1 in this example.&#13;
Let’s call this the <em>original transaction</em>.</p>&#13;
&#13;
<p>Then update the row four times to create version 5:</p>&#13;
&#13;
<pre data-type="programlisting">-- autocommit enabled&#13;
UPDATE elem SET a = 'Ti' WHERE id = 2;&#13;
UPDATE elem SET a = 'Ag' WHERE id = 2;&#13;
UPDATE elem SET a = 'Cf' WHERE id = 2;&#13;
UPDATE elem SET a = 'Au' WHERE id = 2;</pre>&#13;
&#13;
<p><a href="https://oreil.ly/nG8wa"><code>autocommit</code></a> is enabled by default in MySQL, which is why the first (active) transaction needs an explicit <code>BEGIN</code> but the four <code>UPDATE</code> statements do not.&#13;
Now MySQL is in a state represented by <a data-type="xref" href="#trx-mvcc">Figure 8-8</a>.</p>&#13;
&#13;
<p>If the original transaction executes <code>SELECT a FROM elem WHERE id = 2</code> again, it reads version 5 (that’s not a typo) but (figuratively) sees that that version is newer than the point in database history established by its snapshot.&#13;
Consequently, MySQL uses the undo logs to roll back the row and reconstruct version 1, which is consistent with the snapshot established by the first <code>SELECT</code> statement.&#13;
When the original transaction commits, and presuming no other active transactions are holding old snapshots, then MySQL can purge all the related undo logs because new transactions always begin with the current row version.&#13;
When transactions are working well, the whole process is immaterial to performance.&#13;
But you already know: problematic transactions can negatively affect the performance of the entire process.&#13;
<a data-type="xref" href="#trx-problems">“Common Problems”</a> looks at how and why; but until then, there are more details to know about MVCC and the undo logs.</p>&#13;
&#13;
<p>In a <code>READ COMMITTED</code> transaction, each read establishes a new snapshot.&#13;
As a result, each read accesses the latest committed row version, hence <code>READ COMMITTED</code>.&#13;
Since snapshots are used, undo logs are still created, but this is almost never an issue with <code>READ COMMITTED</code> because each snapshot is held only for the duration of the read.&#13;
If a read takes a very long time <em>and</em> there’s significant write throughput on the database, you might notice the accrual of redo logs (as an increase in history list length).&#13;
Otherwise, <code>READ COMMITTED</code> is virtually free of undo logging.</p>&#13;
&#13;
<p>Snapshots only affect reads (<code>SELECT</code>)—they’re never used for writes.&#13;
Writes always secretly read current rows, even if the transaction cannot “see” them with <code>SELECT</code>.&#13;
This double vision averts chaos.&#13;
For example, imagine that another transaction inserts a new row with primary key value 11.&#13;
If the original transaction tries to insert a row with the same primary key value, MySQL will return a duplicate key value because the primary key value exists even though the transaction cannot see it with <code>SELECT</code>.&#13;
Moreover, snapshots are very consistent: in a transaction, there is no way to advance the snapshot to a newer point in database history.&#13;
If the application executing the transaction needs a newer snapshot, it must commit the transaction and begin a new one to establish a new snapshot.</p>&#13;
&#13;
<p>Writes generate undo logs that are kept until the end of the transaction—regardless of transaction isolation level.&#13;
Until now, I have focused on undo logs with respect to reconstructing old row versions for snapshots, but they are also used on <code>ROLLBACK</code> to revert changes made by writes.</p>&#13;
&#13;
<p>One last thing to know about MVCC: undo logs are saved in the InnoDB buffer pool.&#13;
You might recall from <a data-type="xref" href="ch06.html#metrics-page-flushing">“Page flushing”</a> that “<em>Misc pages</em> contain miscellaneous internal data not covered in this book.”&#13;
Misc pages include undo logs (and many more internal data structures).&#13;
Since undo logs reside in buffer pool pages, they use memory and are periodically flushed to disk.</p>&#13;
&#13;
<p>There are a few system variables and metrics related to the undo logs; as an engineer using MySQL, you only need to know and monitor one: HLL, first introduced in <a data-type="xref" href="ch06.html#metrics-hll">“History list length (metric)”</a> and explained further in the next section.&#13;
Otherwise, MVCC and the undo logs work flawlessly as long as the application avoids all <a data-type="xref" href="#trx-problems">“Common Problems”</a>.&#13;
One such problem is abandoned transactions, so let’s avoid that by committing the original transaction:</p>&#13;
&#13;
<pre data-type="programlisting">COMMIT;</pre>&#13;
&#13;
<p>Goodbye, consistent snapshot.&#13;
Goodbye, undo logs.&#13;
Hello, history list length…<a data-primary="consistent snapshot" data-startref="consistent-snapshot-ch8" data-type="indexterm" id="idm45829097602848"/><a data-primary="multiversion concurrency control (MVCC)" data-startref="mvcc-ch8" data-type="indexterm" id="idm45829097601872"/><a data-primary="undo logs" data-startref="undo-logs-ch8" data-type="indexterm" id="idm45829097600864"/><a data-primary="transactions" data-secondary="multiversion concurrency control and undo logs (MVCC)" data-startref="transactions-mvcc-ch8" data-type="indexterm" id="idm45829097599920"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="History List Length" data-type="sect1"><div class="sect1" id="hll">&#13;
<h1>History List Length</h1>&#13;
&#13;
<p>History list length (HLL) <a data-primary="transactions" data-secondary="history list length (HLL)" data-type="indexterm" id="transitions-history-list-length1-ch8"/><a data-primary="history list length (HLL)" data-type="indexterm" id="history-list-length1-ch8"/>gauges the amount of old row versions not purged or flushed.</p>&#13;
&#13;
<p>Historically (no pun intended), HLL has been difficult to define because the full structure of undo logging is complex:</p>&#13;
&#13;
<pre data-type="programlisting">Rollback segments&#13;
└── Undo slots&#13;
    └── Undo log segments&#13;
        └── Undo logs&#13;
            └── Undo log records</pre>&#13;
&#13;
<p>That complexity obscures any simple relationship between undo logging and HLL, including the unit of measurement.&#13;
The simplest functional (although not technically correct) unit of HLL is <em>changes</em>.&#13;
If the HLL value is 10,000, you can read that as 10,000 changes.&#13;
By understanding <a data-type="xref" href="#mvcc">“MVCC and the Undo Logs”</a>, you know that changes are kept (not purged) in memory (not flushed) in order to reconstruct old row versions.&#13;
Therefore, it’s accurate enough to say that HLL gauges the amount of old row versions not purged or flushed.</p>&#13;
&#13;
<p>HLL greater than 100,000 is a problem—do not ignore it.&#13;
Even though the true technical nature of HLL is elusive—even for MySQL experts—its usefulness is clear and undeniable: HLL is the harbinger of transaction-related problems.&#13;
Always monitor HLL (see <a data-type="xref" href="ch06.html#metrics-hll">“History list length (metric)”</a>), alert when it’s too high (greater than 100,000), and fix the problem, which is undoubtedly one of the common problems discussed in the next section.</p>&#13;
&#13;
<p>Although I caution against alerting on thresholds in <a data-type="xref" href="ch06.html#thresholds">“Wild Goose Chase (Thresholds)”</a>, HLL is an exception: alerting when HLL is greater than 100,000 is reliable and actionable.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Alert on HLL greater than 100,000.</p>&#13;
</div>&#13;
&#13;
<p>In theory, HLL has a maximum value, but MySQL performance is sure to crumble long before that value.<sup><a data-type="noteref" href="ch08.html#idm45829097586336" id="idm45829097586336-marker">3</a></sup>&#13;
For example, just a few weeks ago as I write this, an instance of MySQL in the cloud crashed at HLL 200,000, which took a long-running transaction four hours to amass before crashing MySQL and causing a two-hour outage.</p>&#13;
&#13;
<p>Since undo logging is incredibly efficient, there is huge leeway in HLL with respect to the value at which MySQL performance will degrade or—worst case—crash.&#13;
I have seen MySQL crash at 200,000, but I have also seen it run just fine well beyond 200,000.&#13;
One thing is certain: if HLL increases unchecked, it <em>will</em> cause a problem: either noticeably slow performance, or MySQL will crash.</p>&#13;
&#13;
<p>I want you to be the first engineer in history to use MySQL and never have a HLL problem.&#13;
That’s a lofty goal, but I encourage you to shoot for the stars.&#13;
To that end, I intentionally flooded a MySQL instance with <code>UPDATE</code> statements to drive up the HLL—to amass thousands of old row versions.&#13;
<a data-type="xref" href="#hll-response-time">Table 8-2</a> shows the effect of HLL on query response time for a single row point-select: <code>SELECT * FROM elem WHERE id=5</code> in an active <code>REPEATABLE READ</code> transaction.</p>&#13;
<table id="hll-response-time">&#13;
<caption><span class="label">Table 8-2. </span>Effect of HLL on query response time</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>HLL</th>&#13;
<th>Response time (ms)</th>&#13;
<th>Baseline increase (%)</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>0.200 ms</p></td>&#13;
<td/>&#13;
</tr>&#13;
<tr>&#13;
<td><p>495</p></td>&#13;
<td><p>0.612 ms</p></td>&#13;
<td><p>206%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>1,089</p></td>&#13;
<td><p>1.012 ms</p></td>&#13;
<td><p>406%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>2,079</p></td>&#13;
<td><p>1.841 ms</p></td>&#13;
<td><p>821%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>5,056</p></td>&#13;
<td><p>3.673 ms</p></td>&#13;
<td><p>1,737%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>11,546</p></td>&#13;
<td><p>8.527 ms</p></td>&#13;
<td><p>4,164%</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>This example does <em>not</em> mean that HLL will increase query response time as shown; it only proves that HLL can increase query response time.&#13;
From <a data-type="xref" href="#mvcc">“MVCC and the Undo Logs”</a> and this section you know why: the <code>SELECT</code> in the active <code>REPEATABLE READ</code> transaction has a consistent snapshot <a data-primary="consistent snapshot" data-type="indexterm" id="consistent-snapshot2-ch8"/>on row 5 (<code>id=5</code>), but the <code>UPDATE</code> statements on that row generate new row versions.&#13;
Each time the <code>SELECT</code> is executed, it slogs through the undo logs to reconstruct the original row version for the consistent snapshot, and that slog increases query response time.</p>&#13;
&#13;
<p>Increasing query response time is proof enough, but we’re professionals, so let’s prove it irrefutably.&#13;
At the end of <a data-type="xref" href="#mvcc">“MVCC and the Undo Logs”</a>, I mention that undo logs are stored as pages in the InnoDB buffer pool.&#13;
As a result, the <code>SELECT</code> should access an inordinate number of pages.&#13;
To prove this, I use <a href="https://oreil.ly/OWUYR">Percona Server</a> because its enhanced slow query log prints the number of distinct pages accessed when configured with <code>log_slow_verbosity = innodb</code>:</p>&#13;
&#13;
<pre data-type="programlisting"># Query_time: 0.008527&#13;
# InnoDB_pages_distinct: 366</pre>&#13;
&#13;
<p>Normally, the <code>SELECT</code> in this example accesses a single page to look up one row by primary key.&#13;
But when the consistent snapshot for the <code>SELECT</code> is old (and HLL is large), InnoDB slogs through hundreds of undo log pages to reconstruct the old <a data-primary="consistent snapshot" data-startref="consistent-snapshot2-ch8" data-type="indexterm" id="idm45829097552880"/>row.</p>&#13;
&#13;
<p>MVCC, undo logs, and HLL are all normal and good trade-offs: a little performance for a lot of concurrency.&#13;
It’s only when HLL is inordinately large—greater than 100,000–that you should take action to fix the cause, which is almost universally one of the following common problems.<a data-primary="history list length (HLL)" data-startref="history-list-length1-ch8" data-type="indexterm" id="idm45829097551040"/><a data-primary="transactions" data-secondary="history list length (HLL)" data-startref="transactions-history-list-length1-ch8" data-type="indexterm" id="idm45829097550032"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Common Problems" data-type="sect1"><div class="sect1" id="trx-problems">&#13;
<h1>Common Problems</h1>&#13;
&#13;
<p>Transaction <a data-primary="transactions" data-secondary="common problems" data-type="indexterm" id="common-problems"/>problems arise from the queries that constitute the transaction, how quickly the application executes those queries, and how quickly the application commits the transaction.&#13;
Although a single query with <a href="https://oreil.ly/oQtD2"><code>autocommit</code></a> enabled is technically a transaction that can cause the following problems (except for <a data-type="xref" href="#trx-lost">“Abandoned Transactions”</a>), the main focus is multistatement transactions that begin with <code>BEGIN</code> (or <code>START TRANSACTION</code>), execute several queries, and end with <code>COMMIT</code> (or <code>ROLLBACK</code>).&#13;
The performance impact of a multistatement transaction can be greater than the sum of its parts—the queries that constitute the transaction—because locks and undo logs are held until the transaction commits (or rolls back).&#13;
Remember: MySQL is very patient—almost too patient.&#13;
If the application does not commit a transaction, MySQL will wait even until the consequences of that active transaction ring its death knell.</p>&#13;
&#13;
<p>Fortunately, none of these problems are difficult to detect or fix.&#13;
HLL is the harbinger of most transaction problems, which is why you should always monitor it: see <a data-type="xref" href="ch06.html#metrics-hll">“History list length (metric)”</a> and <a data-type="xref" href="#hll">“History List Length”</a>.&#13;
To keep the details of each problem uncluttered, I explain how to find and report problematic transactions in <a data-type="xref" href="#trx-reporting">“Reporting”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Large Transactions (Transaction Size)" data-type="sect2"><div class="sect2" id="trx-size">&#13;
<h2>Large Transactions (Transaction Size)</h2>&#13;
&#13;
<p>A large <a data-primary="transactions" data-secondary="size" data-type="indexterm" id="transactions-size-ch8"/>transaction <a data-primary="large transactions" data-type="indexterm" id="large-transactions"/>modifies an inordinate number of rows.&#13;
How many rows is <em>inordinate</em>?&#13;
That is relative, but engineers always know when they see it.&#13;
For example, if you see that a transaction has modified 250,000 rows and you know that there are only 500,000 rows in the whole database, that’s inordinate.&#13;
(Or at the very least, it’s a suspicious access pattern: see <a data-type="xref" href="ch04.html#ap-result-set">“Result Set”</a>.)</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Generally, <em>transaction size</em> refers to the number of rows modified: the more rows modified, the larger the transaction.&#13;
For <a href="https://oreil.ly/wH10S">MySQL Group Replication</a>, <em>transaction size</em> has a slightly different meaning: see <a href="https://oreil.ly/cJhWF">“Group Replication Limitations”</a> in the MySQL manual.</p>&#13;
</div>&#13;
&#13;
<p>If the transaction is running in the default isolation level, <code>REPEATABLE READ</code>, then it’s safe to presume that it has locked a greater number of records than modified rows because of gap locking—as detailed in <a data-type="xref" href="#row-locking">“Row Locking”</a>.&#13;
If the transaction is running in <code>READ COMMITTED</code> isolation level, then it’s only acquiring record locks for each modified row.&#13;
Either way, a large transaction is a large source of lock contention that can severely degrade write throughput and response time.</p>&#13;
&#13;
<p>Don’t forget replication (see <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>): large transactions are a main cause of <span class="keep-together">replication</span> lag (see <a data-type="xref" href="ch07.html#repl-tps">“Transaction Throughput”</a>) and decrease the effectiveness of multithreaded replication (see <a data-type="xref" href="ch07.html#repl-mtr">“Reducing Lag: Multithreaded Replication”</a>).</p>&#13;
&#13;
<p>Large transactions can be noticeably slow to commit (or roll back) as previously addressed in <a data-type="xref" href="#mvcc">“MVCC and the Undo Logs”</a>, <a data-type="xref" href="ch07.html#repl-binlog-events">“Binary Log Events”</a>, and <a data-type="xref" href="ch06.html#trx-log">Figure 6-7</a>.&#13;
It’s quick and easy to modify rows because the data changes happen in memory, but commit is the reckoning when MySQL does significant work to persist and replicate the data changes.</p>&#13;
&#13;
<p>Smaller transactions are better.&#13;
How small?&#13;
That, too, is relative and complicated to calibrate because, as I just noted, transactions cause a reckoning on commit, which means you have to calibrate several subsystems.&#13;
(It’s even more complicated when you factor in the cloud, which tends to limit and tweak little details, like IOPS.)&#13;
Except for bulk operations which require calibrating a batch size (see <a data-type="xref" href="ch03.html#batch-size">“Batch Size”</a>), calibrating transaction size is not commonly needed because, although the problem is common, it’s typically a one-off problem: found, fixed, and doesn’t reoccur (for awhile, at least).&#13;
<a data-type="xref" href="#trx-reporting">“Reporting”</a> shows you how to find large transactions.</p>&#13;
&#13;
<p>The fix is to find the query (or queries) in the transaction that modify too many rows, and change them to modify fewer rows.&#13;
But that depends entirely on the query, its purpose in the application, and why it’s modifying too many rows.&#13;
Whatever the reason, Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch01.html#ch01">1</a>–<a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04">4</a> equip you to understand and fix the query.</p>&#13;
&#13;
<p>Finally, if you closely follow the principle of least data (see <a data-type="xref" href="ch03.html#principle-of-least-data">“Principle of Least Data”</a>), transaction size may never be a problem.<a data-primary="transactions" data-secondary="size" data-startref="transactions-size-ch8" data-type="indexterm" id="idm45829097511744"/><a data-primary="large transactions" data-startref="large-transactions" data-type="indexterm" id="idm45829097510528"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Long-Running Transactions" data-type="sect2"><div class="sect2" id="trx-long-running">&#13;
<h2>Long-Running Transactions</h2>&#13;
&#13;
<p>A long-running transaction <a data-primary="long-running transactions" data-type="indexterm" id="long-running-transactions"/>takes too long to complete (commit or roll back).&#13;
How long is <em>too long</em>?&#13;
That depends:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Longer than acceptable for the application or users</p>&#13;
</li>&#13;
<li>&#13;
<p>Long enough to cause problems (likely contention) with other transactions</p>&#13;
</li>&#13;
<li>&#13;
<p>Long enough to cause a history list length alert</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Unless you’re proactively addressing performance, the second and third points are more likely to bring a long-running transaction to your attention.</p>&#13;
&#13;
<p>Presuming that the application isn’t waiting between queries (which is the next problem: <a data-type="xref" href="#trx-stalled">“Stalled Transactions”</a>), long-running transactions have two causes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The queries that constitute the transaction are too slow.</p>&#13;
</li>&#13;
<li>&#13;
<p>The application executes too many queries in the transaction.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You fix the first cause with the techniques from Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch01.html#ch01">1</a>–<a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.html#ch05">5</a>.&#13;
Remember: undo logs and row locks for all queries in a transaction are held until the transaction commits.&#13;
On the upside, this means that optimizing slow queries to fix a long-running transaction has collateral benefits: the individual queries are faster <em>and</em> the transaction as a whole is faster, which can increase overall transaction throughput.&#13;
The downside is that a long-running transaction might be quick enough for the application but too long for other transactions.&#13;
For example, let’s say that a transaction takes one second to execute, which is fine for the application, but during that second it holds row locks needed by another, faster transaction.&#13;
This creates a tricky problem to debug because the fast transaction might run slowly in production but quickly in isolation when analyzed in the laboratory (on your laptop, for example).&#13;
The difference, of course, is that the concurrency and contention of transactions in production is largely or completely absent in the lab.&#13;
In this case, you must debug data lock contention, which is not easy for several reasons, the least of which is that data locks are fleeting.&#13;
See the note following <a data-type="xref" href="#lock-types">Table 8-1</a>, and talk with your DBA or a MySQL expert.</p>&#13;
&#13;
<p>You fix the second cause by modifying the application to execute fewer queries in the transaction.&#13;
This occurs when the application attempts a bulk operation or programmatically generates queries inside a transaction without limiting the number of queries.&#13;
Either way, the fix is to reduce or limit the number of queries in the transaction.&#13;
Even if the transaction isn’t long-running, this is a best practice to ensure that it won’t accidentally become long-running.&#13;
For example, maybe when the application is new it only inserts 5 rows per transaction; but years later, when the application has millions of users, it’s inserting 500 rows per transaction because a limit wasn’t built in from the beginning.</p>&#13;
&#13;
<p><a data-type="xref" href="#trx-reporting">“Reporting”</a> shows you how to find long-running transactions.<a data-primary="long-running transactions" data-startref="long-running-transactions" data-type="indexterm" id="idm45829097490608"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stalled Transactions" data-type="sect2"><div class="sect2" id="trx-stalled">&#13;
<h2>Stalled Transactions</h2>&#13;
&#13;
<p>A stalled transaction <a data-primary="stalled transactions" data-type="indexterm" id="idm45829097487920"/>is waiting too long after <code>BEGIN</code>, between queries, or before <span class="keep-together"><code>COMMIT</code></span>.&#13;
Stalled transactions are likely to be long-running transactions, but the causes are different: time waiting between queries (stalled) rather than time waiting for queries (long-running).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In practice, a stalled transaction appears as a long-running transaction because the end result is the same: slow transaction response time.&#13;
Analyzing the transaction is required to determine if the response time is due to stalls or slow queries.&#13;
Absent that analysis, engineers (and MySQL experts) often refer to any slow transaction as long-running.</p>&#13;
</div>&#13;
&#13;
<p>Granted, there’s always some wait time between queries (at least due to network latency required to send queries and receive result sets), but as in the previous two problems, you’ll know a stalled transaction when you see it.&#13;
To put it figuratively: the whole is much greater than the sum of its parts.&#13;
To put it technically: the transaction response time from <code>BEGIN</code> to <code>COMMIT</code> is much greater than the sum of the query response times.</p>&#13;
&#13;
<p>Since stalled transactions are waiting <em>between</em> queries (including after <code>BEGIN</code> and before <code>COMMIT</code>), MySQL is not culpable: the waits are caused by the application, and the reasons are limitless.&#13;
A common reason is doing time-consuming application logic while a transaction is active, instead of before or after the transaction.&#13;
But sometimes this can’t be avoided; consider the following example:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
SELECT &lt;row&gt;&#13;
--&#13;
-- Time-consuming application logic based on the row&#13;
--&#13;
UPDATE &lt;row&gt;&#13;
COMMIT;</pre>&#13;
&#13;
<p>The solution in this case depends on the application logic.&#13;
I’d begin by asking the most fundamental question: do these queries need to be a transaction?&#13;
Can the row change after reading and before updating?&#13;
If the row changes, does that break the logic?&#13;
If nothing else, can the <code>READ COMMITTED</code> isolation level be used to disable gap locking?&#13;
Engineers are clever and find ways to fix cases like this; the first step is finding them, which is covered in <a data-type="xref" href="#trx-reporting">“Reporting”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Abandoned Transactions" data-type="sect2"><div class="sect2" id="trx-lost">&#13;
<h2>Abandoned Transactions</h2>&#13;
&#13;
<p>An abandoned transaction <a data-primary="abandoned transactions" data-type="indexterm" id="idm45829097475440"/>is an active transaction without an active client connection.&#13;
There are two main causes of abandoned transactions:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Application connection leaks</p>&#13;
</li>&#13;
<li>&#13;
<p>Half-closed connections</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>An application bug can leak database connections (like leaking memory or threads): the code-level connection object goes out of scope, so it’s no longer used, but it’s still referenced by other code, so it’s neither closed nor freed (probably resulting in a small memory leak, too).&#13;
Apart from application-level profiling, debugging, or leak detection to verify this bug directly, you can verify it indirectly if restarting the application fixes (closes) the abandoned transactions.&#13;
In MySQL, you can see what are likely to be abandoned transactions (as shown in <a data-type="xref" href="#trx-reporting">“Reporting”</a>), but you cannot verify this bug in MySQL because MySQL doesn’t know that the connection has been abandoned.</p>&#13;
&#13;
<p>Half-closed connections do not happen under normal circumstances because MySQL rolls back a transaction when the client connection closes for any reason detectable by MySQL or the operating system.&#13;
But problems outside MySQL and the operating system can cause the client side of the connection to close without closing the MySQL side—that’s why it’s called a <em>half-closed</em> connection.&#13;
MySQL is especially prone to half-closed connections because its network protocol is almost entirely command and response: the client sends commands, and MySQL sends a response.&#13;
(If you’re curious, clients send a query to MySQL with a <a href="https://oreil.ly/I4RjE"><code>COM_QUERY</code></a> packet.)&#13;
Between command and response, the client and MySQL observe total silence—not a single byte is transmitted.&#13;
As peaceful as that sounds, it means that half-closed connections go unnoticed until <a href="https://oreil.ly/zP2bf"><code>wait_timeout</code></a> seconds have passed, which defaults to 28,800 (8 hours).</p>&#13;
&#13;
<p>Whether an application bug causing connection leaks or a half-closed connection mistaken for meditative network silence, the end result is the same if either occurs while a transaction is active (not committed): the transaction stays active.&#13;
Any consistent snapshot <a data-primary="consistent snapshot" data-type="indexterm" id="idm45829097466192"/>or data locks stay active, too, because MySQL doesn’t know that the transaction has been abandoned.</p>&#13;
&#13;
<p>Truth be told, MySQL likes the silence; as do I. But we’re paid to work, so let’s examine how to find and report all four transaction problems.<a data-primary="transactions" data-secondary="common problems" data-startref="common-problems" data-type="indexterm" id="idm45829097464704"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reporting" data-type="sect1"><div class="sect1" id="trx-reporting">&#13;
<h1>Reporting</h1>&#13;
&#13;
<p>The <a href="https://oreil.ly/fgU04">MySQL Performance Schema</a> makes <a data-primary="transactions" data-secondary="reporting" data-type="indexterm" id="transactions-reporting"/>detailed transaction reporting possible; but at the time of this writing, there are no tools that make it easy.&#13;
I wish I could tell you to use existing open source tools, but there are none.&#13;
The following SQL statements are the state of the art.&#13;
When new art is developed, I’ll let you know at <a href="https://hackmysql.com/trx">MySQL Transaction Reporting</a>.&#13;
Until then, let’s get the job done the old-fashioned way: <em>copy-paste</em>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Active Transactions: Latest" data-type="sect2"><div class="sect2" id="trx-stmt-latest">&#13;
<h2>Active Transactions: Latest</h2>&#13;
&#13;
<p>The SQL <a data-primary="active transactions: latest" data-type="indexterm" id="active-transactions-latest"/>statement in <a data-type="xref" href="#trx-report-latest">Example 8-2</a> reports the latest query for all transactions active longer than 1 second.&#13;
This report answers the question: which transactions are long-running and what are they doing right now?</p>&#13;
<div data-type="example" id="trx-report-latest">&#13;
<h5><span class="label">Example 8-2. </span>Report latest query for transactions active longer than 1 second</h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code>&#13;
  <code class="n">ROUND</code><code class="p">(</code><code class="n">trx</code><code class="p">.</code><code class="n">timer_wait</code><code class="o">/</code><code class="mi">1000000000000</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code> <code class="k">AS</code> <code class="n">trx_runtime</code><code class="p">,</code>&#13;
  <code class="n">trx</code><code class="p">.</code><code class="n">thread_id</code> <code class="k">AS</code> <code class="n">thread_id</code><code class="p">,</code>&#13;
  <code class="n">trx</code><code class="p">.</code><code class="n">event_id</code> <code class="k">AS</code> <code class="n">trx_event_id</code><code class="p">,</code>&#13;
  <code class="n">trx</code><code class="p">.</code><code class="n">isolation_level</code><code class="p">,</code>&#13;
  <code class="n">trx</code><code class="p">.</code><code class="n">autocommit</code><code class="p">,</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">current_schema</code> <code class="k">AS</code> <code class="n">db</code><code class="p">,</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">sql_text</code> <code class="k">AS</code> <code class="n">query</code><code class="p">,</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">rows_examined</code> <code class="k">AS</code> <code class="n">rows_examined</code><code class="p">,</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">rows_affected</code> <code class="k">AS</code> <code class="n">rows_affected</code><code class="p">,</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">rows_sent</code> <code class="k">AS</code> <code class="n">rows_sent</code><code class="p">,</code>&#13;
  <code class="n">IF</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">end_event_id</code> <code class="k">IS</code> <code class="k">NULL</code><code class="p">,</code> <code class="s1">'running'</code><code class="p">,</code> <code class="s1">'done'</code><code class="p">)</code> <code class="k">AS</code> <code class="n">exec_state</code><code class="p">,</code>&#13;
  <code class="n">ROUND</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">timer_wait</code><code class="o">/</code><code class="mi">1000000000000</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code> <code class="k">AS</code> <code class="n">exec_time</code>&#13;
<code class="k">FROM</code>&#13;
       <code class="n">performance_schema</code><code class="p">.</code><code class="n">events_transactions_current</code> <code class="n">trx</code>&#13;
  <code class="k">JOIN</code> <code class="n">performance_schema</code><code class="p">.</code><code class="n">events_statements_current</code>   <code class="n">stm</code> <code class="k">USING</code> <code class="p">(</code><code class="n">thread_id</code><code class="p">)</code>&#13;
<code class="k">WHERE</code>&#13;
      <code class="n">trx</code><code class="p">.</code><code class="n">state</code> <code class="o">=</code> <code class="s1">'ACTIVE'</code>&#13;
  <code class="k">AND</code> <code class="n">trx</code><code class="p">.</code><code class="n">timer_wait</code> <code class="o">&gt;</code> <code class="mi">1000000000000</code> <code class="o">*</code> <code class="mi">1</code><code class="err">\</code><code class="k">G</code></pre></div>&#13;
&#13;
<p>To increase the time, change the 1 before <code>\G</code>.&#13;
Performance Schema timers use picoseconds, so <code>1000000000000 * 1</code> is one second.</p>&#13;
&#13;
<p>The output of <a data-type="xref" href="#trx-report-latest">Example 8-2</a> resembles the following:</p>&#13;
&#13;
<pre data-type="programlisting">*************************** 1. row ***************************&#13;
    trx_runtime: 20729.094&#13;
      thread_id: 60&#13;
   trx_event_id: 1137&#13;
isolation_level: REPEATABLE READ&#13;
     autocommit: NO&#13;
             db: test&#13;
          query: SELECT * FROM elem&#13;
  rows_examined: 10&#13;
  rows_affected: 0&#13;
      rows_sent: 10&#13;
     exec_state: done&#13;
      exec_time: 0.038</pre>&#13;
&#13;
<p>The following is a bit more information about the fields (columns) of <a data-type="xref" href="#trx-report-latest">Example 8-2</a>:</p>&#13;
<dl>&#13;
<dt><code>trx_runtime</code></dt>&#13;
<dd>&#13;
<p>How long the <a data-primary="trx_runtime" data-type="indexterm" id="idm45829097268816"/>transaction has been running (active) in seconds with millisecond precision.&#13;
(I forgot about this transaction, which is why it’s been active for almost six hours in the example.)</p>&#13;
</dd>&#13;
<dt><code>thread_id</code></dt>&#13;
<dd>&#13;
<p>The thread ID <a data-primary="thread_id" data-type="indexterm" id="idm45829097266352"/>of the client connection that is executing the transaction.&#13;
This is used in <a data-type="xref" href="#trx-stmt-history">“Active Transaction: History”</a>.&#13;
Performance Schema events use thread IDs and event IDs to link data to client connections and events, respectively.&#13;
Thread IDs are different than process IDs common to other parts of MySQL.</p>&#13;
</dd>&#13;
<dt><code>trx_event_id</code></dt>&#13;
<dd>&#13;
<p>The transaction <a data-primary="trx_event_id" data-type="indexterm" id="idm45829097263072"/>event ID.&#13;
This is used in <a data-type="xref" href="#trx-stmt-history">“Active Transaction: History”</a>.</p>&#13;
</dd>&#13;
<dt><code>isolation_level</code></dt>&#13;
<dd>&#13;
<p>Transaction isolation <a data-primary="transaction isolation" data-type="indexterm" id="idm45829097259744"/>level: <code>READ REPEATABLE</code> or <code>READ COMMITTED</code>.&#13;
(The other isolation levels, <code>SERIALIZABLE</code> and <code>READ UNCOMMITTED</code>, are rarely used; if you see them, it might be an application bug.)&#13;
Recall <a data-type="xref" href="#row-locking">“Row Locking”</a>: the transaction isolation level affects row locking and whether or not <code>SELECT</code> uses a <a data-primary="consistent snapshot" data-type="indexterm" id="idm45829097255936"/>consistent snapshot.</p>&#13;
</dd>&#13;
<dt><code>autocommit</code></dt>&#13;
<dd>&#13;
<p>If <code>YES</code>, then <code>autocommit</code> <a data-primary="autocommit" data-type="indexterm" id="idm45829097252640"/>is enabled and it’s a single-statement transaction.&#13;
If <code>NO</code>, then the transaction was started with <code>BEGIN</code> (or <code>START TRANSACTION</code>) and it’s most likely a multistatement transaction.</p>&#13;
</dd>&#13;
<dt><code>db</code></dt>&#13;
<dd>&#13;
<p>Current database of <code>query</code>.&#13;
The current database means <code>USE db</code>.&#13;
The query can access other databases with database-qualified table names, such as <code>db.table</code>.</p>&#13;
</dd>&#13;
<dt><code>query</code></dt>&#13;
<dd>&#13;
<p>The latest query <a data-primary="query" data-secondary="definition" data-type="indexterm" id="idm45829097246304"/>either executed by or executing in the transaction.&#13;
If <code>exec_state = running</code>, then <code>query</code> is currently executing in the transaction.&#13;
If <code>exec_state = done</code>, then <code>query</code> is the last query that the transaction executed.&#13;
In both cases the transaction is active (not committed), but in the latter case it’s idle with respect to executing a query.</p>&#13;
</dd>&#13;
<dt><code>rows_examined</code></dt>&#13;
<dd>&#13;
<p>Total number <a data-primary="rows_examined" data-type="indexterm" id="idm45829097241840"/>of rows examined by <code>query</code>.&#13;
This does not include past queries executed in the transaction.</p>&#13;
</dd>&#13;
<dt><code>rows_examined</code></dt>&#13;
<dd>&#13;
<p>Total number of rows modified by <code>query</code>.&#13;
This does not include past queries executed in the transaction.</p>&#13;
</dd>&#13;
<dt><code>rows_sent</code></dt>&#13;
<dd>&#13;
<p>Total number of <a data-primary="rows_sent" data-type="indexterm" id="idm45829097237104"/>rows sent (result set) by <code>query</code>.&#13;
This does not include past queries executed in the transaction.</p>&#13;
</dd>&#13;
<dt><code>exec_state</code></dt>&#13;
<dd>&#13;
<p>If <code>done</code>, then <a data-primary="exec_state" data-type="indexterm" id="idm45829097233664"/>the transaction is idle with respect to executing a query, and <code>query</code> was the last query that it executed.&#13;
If <code>running</code>, then transaction is currently executing <code>query</code>.&#13;
In both cases, the transaction is active (not committed).</p>&#13;
</dd>&#13;
<dt><code>exec_time</code></dt>&#13;
<dd>&#13;
<p>Execution time <a data-primary="exec_time" data-type="indexterm" id="idm45829097229984"/>of <code>query</code> in seconds (with millisecond precision).</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The Performance Schema tables <code>events_transactions_current</code> and <code>events_statements_current</code> contain more fields, but this report selects only the essential fields.</p>&#13;
&#13;
<p>This report is a true workhorse because it can reveal all four <a data-type="xref" href="#trx-problems">“Common Problems”</a>:</p>&#13;
<dl>&#13;
<dt>Large transactions</dt>&#13;
<dd>&#13;
<p>Look <a data-primary="large transactions" data-type="indexterm" id="idm45829097224720"/>at <code>rows_affected</code> (row modified) and <code>rows_sent</code> to see the transaction size (in terms of rows).&#13;
Experiment with adding a condition like <code>trx.rows_affected &gt; 1000</code>.</p>&#13;
</dd>&#13;
<dt>Long-running transactions</dt>&#13;
<dd>&#13;
<p>Adjust the <code>1</code> at <a data-primary="long-running transactions" data-type="indexterm" id="idm45829097220640"/>the end of condition <code>trx.timer_wait &gt; 1000000000000 * 1</code> to filter for longer-running queries.</p>&#13;
</dd>&#13;
<dt>Stalled transactions</dt>&#13;
<dd>&#13;
<p>If <code>exec_state = done</code> and <a data-primary="stalled transactions" data-type="indexterm" id="idm45829097217664"/>stays that way for a while, the transaction is stalled. Since this report only lists the latest query of active transactions, the query should change quickly—<code>exec_state = done</code> should be fleeting.</p>&#13;
</dd>&#13;
<dt>Abandoned transactions</dt>&#13;
<dd>&#13;
<p>If <code>exec_state = done</code> remains <a data-primary="abandoned transactions" data-type="indexterm" id="idm45829097214448"/>for a long time, it’s possible the transaction is abandoned because it stops being reported after commit.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The output of this report should be volatile because active transactions should be fleeting.&#13;
If it reports a transaction long enough for you to see it multiple times, then the transaction is probably exhibiting one of the <a data-type="xref" href="#trx-problems">“Common Problems”</a>.&#13;
In this case, use its <code>thread_id</code> and <code>statement_event_id</code> (as in <a data-type="xref" href="#trx-stmt-history">“Active Transaction: History”</a>) to report its history—past queries—which helps reveal why the transaction is a problem.</p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45829097209936">&#13;
<h5>Information Schema INNODB_TRX</h5>&#13;
<p>Using the MySQL Performance Schema is the best practice and the future of MySQL performance reporting.&#13;
But the <a href="https://oreil.ly/2AOhC">MySQL Information Schema</a> is still widely used and it can report long-running transactions by querying table <code>inform​a⁠tion_schema.innodb_trx</code>:</p>&#13;
&#13;
<pre data-type="programlisting">SELECT&#13;
  trx_mysql_thread_id AS process_id,&#13;
  trx_isolation_level,&#13;
  TIMEDIFF(NOW(), trx_started) AS trx_runtime,&#13;
  trx_state,&#13;
  trx_rows_locked,&#13;
  trx_rows_modified,&#13;
  trx_query AS query&#13;
FROM&#13;
  information_schema.innodb_trx&#13;
WHERE&#13;
  trx_started &lt; CURRENT_TIME - INTERVAL 1 SECOND\G&#13;
&#13;
&#13;
*************************** 1. row ***************************&#13;
         process_id: 13&#13;
trx_isolation_level: REPEATABLE READ&#13;
        trx_runtime: 06:43:33&#13;
          trx_state: RUNNING&#13;
    trx_rows_locked: 4&#13;
  trx_rows_modified: 1&#13;
              query: NULL</pre>&#13;
&#13;
<p>In this example, <code>query</code> is <code>NULL</code> because the transaction is not executing any query.&#13;
If it were, this field would contain the query.</p>&#13;
&#13;
<p>I advise using the Performance Schema because it contains significantly more detail—essentially everything there is to know about what happens inside MySQL.&#13;
All the examples in this book use the Performance Schema when possible; in rare cases, some information is still only available in the Information Schema.</p>&#13;
&#13;
<p>To learn more about table <code>information_schema.innodb_trx</code>, read <a href="https://oreil.ly/jqVNx">“The INFORMATION_SCHEMA INNODB_TRX Table”</a> in the MySQL <span class="keep-together">manual</span>.<a data-primary="active transactions: latest" data-startref="active-transactions-latest" data-type="indexterm" id="idm45829097201120"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Active Transactions: Summary" data-type="sect2"><div class="sect2" id="trx-stmt-summary">&#13;
<h2>Active Transactions: Summary</h2>&#13;
&#13;
<p>The SQL <a data-primary="active transactions: summary" data-type="indexterm" id="active-transactions-summary"/>statement in <a data-type="xref" href="#trx-report-summary">Example 8-3</a> reports the summary of queries executed for all transactions active longer than 1 second.&#13;
This report answers the question: which transactions are long-running and how much work have they been doing?</p>&#13;
<div data-type="example" id="trx-report-summary">&#13;
<h5><span class="label">Example 8-3. </span>Report transaction summary</h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code>&#13;
  <code class="n">trx</code><code class="p">.</code><code class="n">thread_id</code> <code class="k">AS</code> <code class="n">thread_id</code><code class="p">,</code>&#13;
  <code class="k">MAX</code><code class="p">(</code><code class="n">trx</code><code class="p">.</code><code class="n">event_id</code><code class="p">)</code> <code class="k">AS</code> <code class="n">trx_event_id</code><code class="p">,</code>&#13;
  <code class="k">MAX</code><code class="p">(</code><code class="n">ROUND</code><code class="p">(</code><code class="n">trx</code><code class="p">.</code><code class="n">timer_wait</code><code class="o">/</code><code class="mi">1000000000000</code><code class="p">,</code><code class="mi">3</code><code class="p">))</code> <code class="k">AS</code> <code class="n">trx_runtime</code><code class="p">,</code>&#13;
  <code class="k">SUM</code><code class="p">(</code><code class="n">ROUND</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">timer_wait</code><code class="o">/</code><code class="mi">1000000000000</code><code class="p">,</code><code class="mi">3</code><code class="p">))</code> <code class="k">AS</code> <code class="n">exec_time</code><code class="p">,</code>&#13;
  <code class="k">SUM</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">rows_examined</code><code class="p">)</code> <code class="k">AS</code> <code class="n">rows_examined</code><code class="p">,</code>&#13;
  <code class="k">SUM</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">rows_affected</code><code class="p">)</code> <code class="k">AS</code> <code class="n">rows_affected</code><code class="p">,</code>&#13;
  <code class="k">SUM</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">rows_sent</code><code class="p">)</code> <code class="k">AS</code> <code class="n">rows_sent</code>&#13;
<code class="k">FROM</code>&#13;
       <code class="n">performance_schema</code><code class="p">.</code><code class="n">events_transactions_current</code> <code class="n">trx</code>&#13;
  <code class="k">JOIN</code> <code class="n">performance_schema</code><code class="p">.</code><code class="n">events_statements_history</code>   <code class="n">stm</code>&#13;
    <code class="k">ON</code> <code class="n">stm</code><code class="p">.</code><code class="n">thread_id</code> <code class="o">=</code> <code class="n">trx</code><code class="p">.</code><code class="n">thread_id</code> <code class="k">AND</code> <code class="n">stm</code><code class="p">.</code><code class="n">nesting_event_id</code> <code class="o">=</code> <code class="n">trx</code><code class="p">.</code><code class="n">event_id</code>&#13;
<code class="k">WHERE</code>&#13;
      <code class="n">stm</code><code class="p">.</code><code class="n">event_name</code> <code class="k">LIKE</code> <code class="s1">'statement/sql/%'</code>&#13;
  <code class="k">AND</code> <code class="n">trx</code><code class="p">.</code><code class="n">state</code> <code class="o">=</code> <code class="s1">'ACTIVE'</code>&#13;
  <code class="k">AND</code> <code class="n">trx</code><code class="p">.</code><code class="n">timer_wait</code> <code class="o">&gt;</code> <code class="mi">1000000000000</code> <code class="o">*</code> <code class="mi">1</code>&#13;
<code class="k">GROUP</code> <code class="k">BY</code> <code class="n">trx</code><code class="p">.</code><code class="n">thread_id</code><code class="err">\</code><code class="k">G</code></pre></div>&#13;
&#13;
<p>To increase the time, change the 1 before <code>\G</code>.&#13;
The fields are the same as in <a data-type="xref" href="#trx-stmt-latest">“Active Transactions: Latest”</a> but this report aggregates past queries for each transaction.&#13;
A stalled transaction (not currently executing a query) might have done a lot of work in the past, which this report reveals.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>When a query finishes executing, it’s logged in table <code>performance_schema.events_statements_history</code> but also remains in table <code>performance_schema.events_statements_current</code>.&#13;
Therefore, the report only includes completed queries and should not be joined to the latter table unless active queries are filtered out.</p>&#13;
</div>&#13;
&#13;
<p>This report is better to find large transactions—<a data-type="xref" href="#trx-size">“Large Transactions (Transaction Size)”</a>—since it includes past queries.<a data-primary="active transactions: summary" data-startref="active-transactions-summary" data-type="indexterm" id="idm45829097008944"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Active Transaction: History" data-type="sect2"><div class="sect2" id="trx-stmt-history">&#13;
<h2>Active Transaction: History</h2>&#13;
&#13;
<p>The SQL <a data-primary="active transactions: history" data-type="indexterm" id="active-transactions-history"/>statement in <a data-type="xref" href="#trx-report-history">Example 8-4</a> reports the history of queries executed for a single transaction.&#13;
This report answers the question: how much work did each query transaction do?&#13;
You must replace the zeros with <code>thread_id</code> and <code>trx_event_id</code> values from the output of <a data-type="xref" href="#trx-report-latest">Example 8-2</a>.</p>&#13;
<div data-type="example" id="trx-report-history">&#13;
<h5><span class="label">Example 8-4. </span>Report transaction history</h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">rows_examined</code> <code class="k">AS</code> <code class="n">rows_examined</code><code class="p">,</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">rows_affected</code> <code class="k">AS</code> <code class="n">rows_affected</code><code class="p">,</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">rows_sent</code> <code class="k">AS</code> <code class="n">rows_sent</code><code class="p">,</code>&#13;
  <code class="n">ROUND</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">timer_wait</code><code class="o">/</code><code class="mi">1000000000000</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code> <code class="k">AS</code> <code class="n">exec_time</code><code class="p">,</code>&#13;
  <code class="n">stm</code><code class="p">.</code><code class="n">sql_text</code> <code class="k">AS</code> <code class="n">query</code>&#13;
<code class="k">FROM</code>&#13;
  <code class="n">performance_schema</code><code class="p">.</code><code class="n">events_statements_history</code> <code class="n">stm</code>&#13;
<code class="k">WHERE</code>&#13;
       <code class="n">stm</code><code class="p">.</code><code class="n">thread_id</code> <code class="o">=</code> <code class="mi">0</code>&#13;
  <code class="k">AND</code>  <code class="n">stm</code><code class="p">.</code><code class="n">nesting_event_id</code> <code class="o">=</code> <code class="mi">0</code>&#13;
<code class="k">ORDER</code> <code class="k">BY</code> <code class="n">stm</code><code class="p">.</code><code class="n">event_id</code><code class="p">;</code></pre></div>&#13;
&#13;
<p>Replace the zeros with values from the output of <a data-type="xref" href="#trx-report-latest">Example 8-2</a>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Replace the zero in <code>stm.thread_id = 0</code> with <code>thread_id</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Replace the zero in <code>stm.nesting_event_id = 0</code> with <code>trx_event_id</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The output of <a data-type="xref" href="#trx-report-history">Example 8-4</a> looks like:</p>&#13;
&#13;
<pre data-type="programlisting">+---------------+---------------+-----------+-----------+---------------------+&#13;
| rows_examined | rows_affected | rows_sent | exec_time | query               |&#13;
+---------------+---------------+-----------+-----------+---------------------+&#13;
|            10 |             0 |        10 |     0.000 | SELECT * FROM elem  |&#13;
|             2 |             1 |         0 |     0.003 | UPDATE elem SET ... |&#13;
|             0 |             0 |         0 |     0.002 | COMMIT              |&#13;
+---------------+---------------+-----------+-----------+---------------------+</pre>&#13;
&#13;
<p>Apart from the <code>BEGIN</code> that started the transactions, this transaction executed two queries, then <code>COMMIT</code>.&#13;
The <code>SELECT</code> was the first query, and the <code>UPDATE</code> was the second query.&#13;
It’s not a riveting example, but it demonstrates the query execution history of a transaction, plus basic query metrics.&#13;
History is invaluable when debugging problematic transactions because you can see which queries are slow (<code>exec_time</code>) or large (in terms of rows), as well as the point at which the application stalls (when you know that the transaction will execute more queries).<a data-primary="active transactions: history" data-startref="active-transactions-history" data-type="indexterm" id="idm45829096893040"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Committed Transactions: Summary" data-type="sect2"><div class="sect2" id="trx-stmt-committed">&#13;
<h2>Committed Transactions: Summary</h2>&#13;
&#13;
<p>The <a data-primary="committed transactions: summary" data-type="indexterm" id="committed-transactions-summary"/>previous three reports are for active transactions, but committed transactions are also revealing.&#13;
The SQL statement in <a data-type="xref" href="#trx-report-committed">Example 8-5</a> reports basic metrics for committed (completed) transactions.&#13;
It’s like a slow query log for transactions.</p>&#13;
<div data-type="example" id="trx-report-committed">&#13;
<h5><span class="label">Example 8-5. </span>Report basic metrics for committed transactions</h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code>&#13;
  <code class="n">ROUND</code><code class="p">(</code><code class="k">MAX</code><code class="p">(</code><code class="n">trx</code><code class="p">.</code><code class="n">timer_wait</code><code class="p">)</code><code class="o">/</code><code class="mi">1000000000</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code> <code class="k">AS</code> <code class="n">trx_time</code><code class="p">,</code>&#13;
  <code class="n">ROUND</code><code class="p">(</code><code class="k">SUM</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">timer_end</code><code class="o">-</code><code class="n">stm</code><code class="p">.</code><code class="n">timer_start</code><code class="p">)</code><code class="o">/</code><code class="mi">1000000000</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code> <code class="k">AS</code> <code class="n">query_time</code><code class="p">,</code>&#13;
  <code class="n">ROUND</code><code class="p">((</code><code class="k">MAX</code><code class="p">(</code><code class="n">trx</code><code class="p">.</code><code class="n">timer_wait</code><code class="p">)</code><code class="o">-</code><code class="k">SUM</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">timer_end</code><code class="o">-</code><code class="n">stm</code><code class="p">.</code><code class="n">timer_start</code><code class="p">))</code><code class="o">/</code><code class="mi">1000000000</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>&#13;
    <code class="k">AS</code> <code class="n">idle_time</code><code class="p">,</code>&#13;
  <code class="k">COUNT</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">event_id</code><code class="p">)</code><code class="o">-</code><code class="mi">1</code> <code class="k">AS</code> <code class="n">query_count</code><code class="p">,</code>&#13;
  <code class="k">SUM</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">rows_examined</code><code class="p">)</code> <code class="k">AS</code> <code class="n">rows_examined</code><code class="p">,</code>&#13;
  <code class="k">SUM</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">rows_affected</code><code class="p">)</code> <code class="k">AS</code> <code class="n">rows_affected</code><code class="p">,</code>&#13;
  <code class="k">SUM</code><code class="p">(</code><code class="n">stm</code><code class="p">.</code><code class="n">rows_sent</code><code class="p">)</code> <code class="k">AS</code> <code class="n">rows_sent</code>&#13;
<code class="k">FROM</code>&#13;
      <code class="n">performance_schema</code><code class="p">.</code><code class="n">events_transactions_history</code> <code class="n">trx</code>&#13;
 <code class="k">JOIN</code> <code class="n">performance_schema</code><code class="p">.</code><code class="n">events_statements_history</code>   <code class="n">stm</code>&#13;
   <code class="k">ON</code> <code class="n">stm</code><code class="p">.</code><code class="n">nesting_event_id</code> <code class="o">=</code> <code class="n">trx</code><code class="p">.</code><code class="n">event_id</code>&#13;
<code class="k">WHERE</code>&#13;
      <code class="n">trx</code><code class="p">.</code><code class="n">state</code> <code class="o">=</code> <code class="s1">'COMMITTED'</code>&#13;
  <code class="k">AND</code> <code class="n">trx</code><code class="p">.</code><code class="n">nesting_event_id</code> <code class="k">IS</code> <code class="k">NOT</code> <code class="k">NULL</code>&#13;
<code class="k">GROUP</code> <code class="k">BY</code>&#13;
  <code class="n">trx</code><code class="p">.</code><code class="n">thread_id</code><code class="p">,</code> <code class="n">trx</code><code class="p">.</code><code class="n">event_id</code><code class="p">;</code></pre></div>&#13;
&#13;
<p>The fields of <a data-type="xref" href="#trx-report-committed">Example 8-5</a> are:</p>&#13;
<dl>&#13;
<dt><code>trx_time</code></dt>&#13;
<dd>&#13;
<p>Total transaction time, in milliseconds with microsecond precision.</p>&#13;
</dd>&#13;
<dt><code>query_time</code></dt>&#13;
<dd>&#13;
<p>Total query execution time, in milliseconds with microsecond precision.</p>&#13;
</dd>&#13;
<dt><code>idle_time</code></dt>&#13;
<dd>&#13;
<p>Transaction time minus query time, in milliseconds with microsecond precision.&#13;
Idle time indicates how much the application stalled while executing the queries in the transaction.</p>&#13;
</dd>&#13;
<dt><code>query_count</code></dt>&#13;
<dd>&#13;
<p>Number of queries executed in the transaction.</p>&#13;
</dd>&#13;
<dt><code>rows_*</code></dt>&#13;
<dd>&#13;
<p>Total number of rows examined, affected, and sent (respectively) by all queries executed in the transaction.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The output of <a data-type="xref" href="#trx-report-committed">Example 8-5</a> looks like the following:</p>&#13;
&#13;
<pre data-type="programlisting">+----------+----------+-----------+---------+-----------+-----------+-----------+&#13;
| trx_time | qry_time | idle_time | qry_cnt | rows_exam | rows_affe | rows_sent |&#13;
+----------+----------+-----------+---------+-----------+-----------+-----------+&#13;
| 5647.892 |    1.922 |  5645.970 |       2 |        10 |         0 |        10 |&#13;
|    0.585 |    0.403 |     0.182 |       2 |        10 |         0 |        10 |&#13;
+----------+----------+-----------+---------+-----------+-----------+-----------+</pre>&#13;
&#13;
<p>For this example, I executed the same transaction twice: first manually, then copy-pasted.&#13;
The manual execution took 5.6 seconds (5647.892) and was mostly idle time due to typing.&#13;
But a transaction programmatically executed should be mostly query execution time, as shown in the second row: 403 microseconds of execution time, and only 182 microseconds of idle time.<a data-primary="transactions" data-secondary="reporting" data-startref="transactions-reporting" data-type="indexterm" id="idm45829096676720"/><a data-primary="committed transactions: summary" data-startref="committed-transactions-summary" data-type="indexterm" id="idm45829096675472"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45829096674416">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This <a data-primary="transactions" data-type="indexterm" id="idm45829096673152"/>chapter examined MySQL transactions with respect to avoiding common problems.&#13;
The major takeaway points are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Transaction isolation levels affect row locking (data locks).</p>&#13;
</li>&#13;
<li>&#13;
<p>The fundamental InnoDB data locks are: <em>record lock</em> (locks a single index record), <em>next-key lock</em> (locks a single index record plus the record gap before it), <em>gap lock</em> (locks the range [gap] between two records), and <em>insert intention lock</em> (allows <code>INSERT</code> into a gap; more like a wait condition than a lock).</p>&#13;
</li>&#13;
<li>&#13;
<p>The default transaction isolation level, <code>REPEATABLE READ</code>, uses gap locking to isolate the range of rows accessed.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>READ COMMITTED</code> transaction isolation level disables gap locking.</p>&#13;
</li>&#13;
<li>&#13;
<p>InnoDB uses <em>consistent snapshots</em> in <code>REPEATABLE READ</code> transactions to make reads (<code>SELECT</code>) return the same rows despite changes to those rows by other transactions.</p>&#13;
</li>&#13;
<li>&#13;
<p>Consistent snapshots require InnoDB to save row changes in undo logs to reconstruct old row versions.</p>&#13;
</li>&#13;
<li>&#13;
<p>History list length (HLL) gauges the amount of old row versions not purged or flushed.</p>&#13;
</li>&#13;
<li>&#13;
<p>HLL is a harbinger of doom: always monitor and alert on HLL greater than 100,000.</p>&#13;
</li>&#13;
<li>&#13;
<p>Data locks and undo logs are released when a transaction ends, with <code>COMMIT</code> or <code>ROLLBACK</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Four common problems beset transactions: large transactions (modify too many rows), long-running transactions (slow response time from <code>BEGIN</code> to <code>COMMIT</code>), stalled transactions (superfluous waits between queries), and abandoned transactions (client connection vanished during active transaction).</p>&#13;
</li>&#13;
<li>&#13;
<p>The MySQL Performance Schema makes detailed transaction reporting possible.</p>&#13;
</li>&#13;
<li>&#13;
<p>Transaction performance is as important as query performance.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The next chapter enumerates common MySQL challenges and how to mitigate them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Practice: Alert on History List Length" data-type="sect1"><div class="sect1" id="idm45829096653712">&#13;
<h1>Practice: Alert on History List Length</h1>&#13;
&#13;
<p>The goal of this <a data-primary="transactions" data-secondary="history list length (HLL)" data-type="indexterm" id="transactions-history-list-length2-ch8"/><a data-primary="history list length (HLL)" data-type="indexterm" id="history-list-length2-ch8"/>practice is to alert on history list length (HLL) greater than 100,000.&#13;
(Recall <a data-type="xref" href="#hll">“History List Length”</a>.)&#13;
This depends on your systems for monitoring (collecting metrics) and alerting, but fundamentally it’s no different than alerting on other metrics.&#13;
Therefore, the needed work is twofold:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Collect and report the HLL value.</p>&#13;
</li>&#13;
<li>&#13;
<p>Create an alert on HLL greater than 100,000.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>All MySQL monitors should be able to collect and report HLL.&#13;
If your current monitoring cannot, seriously consider a better monitor because HLL is a fundamental metric.&#13;
Read the documentation for your monitor to learn how to make it collect and report HLL.&#13;
HLL can change quickly, but there’s leeway before MySQL is at risk due to high HLL.&#13;
Therefore, you can report HLL slowly: every minute.</p>&#13;
&#13;
<p>Once your monitor is collecting and reporting HLL, set an alert on HLL greater than 100,000 for 20 minutes.&#13;
But recall <a data-type="xref" href="ch06.html#thresholds">“Wild Goose Chase (Thresholds)”</a>: you might need to adjust the 20 minute threshold, but note that HLL greater than 100,000 for longer than 20 minutes is quite abnormal.</p>&#13;
&#13;
<p>In case you need to query the HLL value manually:</p>&#13;
&#13;
<pre data-type="programlisting">SELECT name, count&#13;
FROM   information_schema.innodb_metrics&#13;
WHERE  name = 'trx_rseg_history_len';</pre>&#13;
&#13;
<p>Historically, HLL was parsed from the output of <code>SHOW ENGINE INNODB STATUS</code>: look for “History list length” under section header “TRANSACTIONS” in MySQL.</p>&#13;
&#13;
<p>I hope that you’re never alerted for HLL, but having the alert is a best practice, and it has saved many applications from an outage.&#13;
An HLL alert is a friend.<a data-primary="transactions" data-secondary="history list length (HLL)" data-startref="transactions-history-list-length2-ch8" data-type="indexterm" id="idm45829096640896"/><a data-primary="history list length (HLL)" data-startref="history-list-length2-ch8" data-type="indexterm" id="idm45829096639568"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Practice: Examine Row Locks" data-type="sect1"><div class="sect1" id="idm45829096653280">&#13;
<h1>Practice: Examine Row Locks</h1>&#13;
&#13;
<p>The goal of this <a data-primary="transactions" data-secondary="row locking" data-type="indexterm" id="idm45829096636720"/>practice is to examine row locks for real queries from your application and, if possible, understand why the query acquires each lock.&#13;
<em>If possible</em> is a necessary disclaimer given that InnoDB row locking can be inscrutable.</p>&#13;
&#13;
<p>Use a development or staging instance of MySQL; do not use production.&#13;
Also, use MySQL 8.0.16 or newer because it has the best data lock reporting using the Performance Schema table <code>data_locks</code>, as shown in <a data-type="xref" href="#row-locking">“Row Locking”</a>.&#13;
If you can only use MySQL 5.7, then you’ll need to examine data locks using <code>SHOW ENGINE INNODB STATUS</code>: refer to <a href="https://oreil.ly/f9uqy">MySQL Data Locks</a> for an illustrated guide to mapping data lock output from MySQL 5.7 to MySQL 8.0.</p>&#13;
&#13;
<p>Use real table definitions and as much real data (rows) as possible.&#13;
If possible, dump data from production and load into your development or staging MySQL instances.</p>&#13;
&#13;
<p>If there are particular queries or transactions that you’re curious about, begin by examining their data locks.&#13;
Otherwise, begin with slow queries—recall <a data-type="xref" href="ch01.html#query-profile">“Query profile”</a>.</p>&#13;
&#13;
<p>Since locks are released when a transaction completes, you need to use explicit transactions, as shown in <a data-type="xref" href="#row-locking">“Row Locking”</a>:</p>&#13;
&#13;
<pre data-type="programlisting">BEGIN;&#13;
&#13;
--&#13;
-- Execute one or several queries&#13;
--&#13;
&#13;
SELECT index_name, lock_type, lock_mode, lock_status, lock_data&#13;
FROM   performance_schema.data_locks&#13;
WHERE  object_name = 'elem';</pre>&#13;
&#13;
<p>Replace <code>elem</code> with your table name, and remember to <code>COMMIT</code> or <code>ROLLBACK</code> to release the locks.</p>&#13;
&#13;
<p>To change the transaction isolation level for the next (and only the next) transaction, execute <code>SET TRANSACTION ISOLATION LEVEL READ COMMITTED</code> before <code>BEGIN</code>.</p>&#13;
&#13;
<p>This is expert-level practice, so any effort and understanding is an achievement.&#13;
Congratulations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45829097823024"><sup><a href="ch08.html#idm45829097823024-marker">1</a></sup> To go down the rabbit hole, follow <a href="https://oreil.ly/WF6NT">“A Critique of ANSI SQL Isolation Levels”</a>: a classic read on the subject of ANSI SQL-92 isolation levels.</p><p data-type="footnote" id="idm45829097678720"><sup><a href="ch08.html#idm45829097678720-marker">2</a></sup> Thank you to Jakub Łopuszański <a data-primary="Łopuszański, Jakub" data-type="indexterm" id="idm45829097678192"/>for revealing and teaching me this secret.</p><p data-type="footnote" id="idm45829097586336"><sup><a href="ch08.html#idm45829097586336-marker">3</a></sup> In <em>storage/innobase/trx/trx0purge.cc</em> of the MySQL 8.0 source code, a debug block logs a warning when HLL is greater than 2,000,000.</p></div></div></section></body></html>