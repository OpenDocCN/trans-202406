- en: Chapter 7\. Secret Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 机密管理
- en: 'In any application stack, we are almost guaranteed to run into secret data.
    This is the data that applications want to keep, well, secret. Commonly, we associate
    secrets with credentials. Often these credentials are used to access systems within
    or external to the cluster, such as databases or message queues. We also run into
    secret data when using private keys, which may support our application’s ability
    to perform mutual TLS with other applications. These kinds of concerns are covered
    in [Chapter 11](ch11.html#building_platform_services). The existence of secrets
    bring in many operational concerns to consider, such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序堆栈中，我们几乎肯定会遇到机密数据。这是应用程序希望保持秘密的数据。通常，我们将机密与凭据关联起来。通常这些凭据用于访问集群内或外的系统，如数据库或消息队列。当使用私钥时，我们也会遇到机密数据，这些私钥可能支持我们的应用程序与其他应用程序进行双向TLS通信。这些类型的问题在第11章中有详细讨论。机密的存在带来了许多需要考虑的操作问题，例如：
- en: Secret rotation policies
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 机密轮换策略
- en: How long is a secret allowed to remain before it must be changed?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 机密可以保留多长时间之前必须更改？
- en: Key (encryption) rotation policies
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥（加密）轮换策略
- en: Assuming secret data is encrypted at the application layer before being persisted
    to disk, how long is an encryption key allowed to stay around before it must be
    rotated?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 假设机密数据在持久化到磁盘之前在应用层进行了加密，那么加密密钥可以在多长时间内保留不变？
- en: Secret storage policies
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 机密存储策略
- en: What requirements must be satisfied in order to store secret data? Do you need
    to persist secrets to isolated hardware? Do you need your secret management solution
    to integrate with a hardware security module (HSM)?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 存储机密数据需要满足哪些要求？您是否需要将机密持久化到隔离的硬件中？您的机密管理解决方案是否需要与硬件安全模块（HSM）集成？
- en: Remediation plan
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 补救计划
- en: If secret(s) or encryption key(s) are compromised, how do you plan to remediate?
    Can your plan or automation be run without impact to applications?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机密或加密密钥泄露，您计划如何进行补救？您的计划或自动化是否可以在不影响应用程序的情况下运行？
- en: A good starting point is to determine what layer to offer secret management
    for your applications. Some organizations choose to not solve this at a platform
    level and instead expect application teams to inject secrets into their applications
    dynamically. For example, if an organization is running a secret management system
    such as Vault, applications can talk directly to the API to authenticate and retrieve
    secrets. Application frameworks may even offer libraries to talk directly to these
    systems. For example, Spring offers the spring-vault project to authenticate against
    Vault, retrieve secrets, and inject their values directly into Java classes. While
    possible to do at the application layer, many platform teams aspire to offer enterprise-grade
    secret capabilities as platform services, perhaps in a way that application developers
    need not be concerned with how the secret got there or what external provider
    (e.g., Vault) is being used under the hood.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的起点是确定为应用程序提供机密管理的哪一层。一些组织选择不在平台级别解决此问题，而是期望应用团队动态地将机密注入其应用程序中。例如，如果一个组织正在运行像Vault这样的机密管理系统，应用程序可以直接与API通信以进行身份验证和检索机密。应用程序框架甚至可以提供库直接与这些系统通信。例如，Spring提供了spring-vault项目来对接Vault，检索机密并直接将其值注入Java类中。尽管可以在应用程序层面完成此操作，但许多平台团队希望提供企业级别的机密能力作为平台服务，使应用程序开发人员无需关心机密是如何到达那里或者在幕后使用了哪个外部提供者（例如Vault）。
- en: In this chapter we’ll dive into how to think about secret data in Kubernetes.
    We’ll start at lower-level layers Kubernetes runs on and work up to the APIs Kubernetes
    exposes that make secret data available to workloads. Like many topics in this
    book, you’ll find these considerations and recommendations to live on a spectrum—one
    end of the spectrum includes how secure you’re willing to get relative to engineering
    effort and tolerance for risk, and the other end focuses on what level of abstractions
    you’d like to provide to developers consuming this platform.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨如何在Kubernetes中处理机密数据。我们将从Kubernetes运行的较低级别层开始，逐步向上工作到Kubernetes公开的API，使机密数据可供工作负载使用。像本书中的许多主题一样，您会发现这些考虑和建议存在一个光谱上——一个端点包括您愿意相对于工程投入和风险承受能力有多安全，另一个端点侧重于您希望为使用此平台的开发人员提供什么级别的抽象。
- en: Defense in Depth
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度防御
- en: Protection of our secret data largely comes down to what depths we’re willing
    to go to make it secure. As much as we’d like to say we always choose the most
    secure options, the reality is we make sensible decisions that keep us “safe enough”
    and ideally harden them over time. This comes with risk and technical debt that
    is quintessential to our work. However, there’s no denying that a misjudgment
    of what is “safe enough” can quickly make us famous, and not in a good way. In
    the following sections, we’ll look at these layers of security and call out some
    of the most critical points.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 保护我们机密数据的关键在于我们愿意采取多深的措施来确保其安全。尽管我们很想说我们总是选择最安全的选项，但现实是我们做出合理的决策，保持“足够安全”，并在时间上加以加固。这伴随着风险和技术债务，这是我们工作的本质。然而，不可否认的是对“足够安全”判断失误可能很快让我们声名大噪，但不是以好的方式。在接下来的章节中，我们将深入探讨这些安全层次，并指出一些最关键的要点。
- en: Defense can start literally at the physical layer. A prime example is Google.
    It has multiple [whitepapers](https://cloud.google.com/security/overview/whitepaper),
    and even a video on [YouTube](https://oreil.ly/dtHUx), that describe its approach
    to datacenter security. This includes metal detectors, vehicle barriers capable
    of stopping a semi truck, and several layers of building security just to get
    into the datacenter. This attention to detail extends beyond what is live and
    racked. When drives are retired, Google has authorized staff zero-out the data
    and then potentially crush and shred the drives. While the subject of physical
    security is interesting, this book will not go into depth around physical security
    of your datacenter, but the steps cloud providers take to ensure the security
    of their hardware are amazing, and that’s just the start.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 防御可以从物理层面开始。一个典型例子是谷歌。它有多篇[白皮书](https://cloud.google.com/security/overview/whitepaper)，甚至还有一段[YouTube](https://oreil.ly/dtHUx)视频介绍其数据中心安全方法。这包括金属探测器、能够阻止半挂卡车的车辆屏障，以及多层楼宇安全措施以进入数据中心。这种注意细节的扩展超出了现场设备的范围。当驱动器退役时，谷歌授权员工将数据清零，然后可能粉碎和撕碎驱动器。虽然物理安全的主题很有趣，但本书不会深入讨论数据中心物理安全问题，而是云服务提供商为确保其硬件安全所采取的步骤令人惊叹，而这只是个开始。
- en: Let’s say a human did somehow get access to a disk before it was zeroed out
    or crushed. Most cloud providers and datacenters are securing their physical disks
    by ensuring the drive is encrypted at rest. Providers may do this with their own
    encryption keys and/or they allow customers to provide their own keys, which makes
    it near impossible for providers to access your unencrypted data. This is a perfect
    example of defense in depth. We are protected from a physical standpoint, intra-datacenter,
    and we extend that to encrypting data on the physical disks themselves, closing
    off further opportunities for bad actors internally to do anything with users’
    data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 假设人类在磁盘被清零或压碎之前某种方式获取了访问权限。大多数云服务提供商和数据中心通过确保磁盘在静止状态下进行加密来保护其物理磁盘。提供商可能使用他们自己的加密密钥和/或允许客户提供自己的密钥，这使得提供商几乎无法访问您的未加密数据。这是深度防御的一个完美例子。我们从物理层面、数据中心内部和扩展到对物理磁盘上数据加密，关闭了内部恶意行为者进一步处理用户数据的机会。
- en: Disk Encryption
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 磁盘加密
- en: Let’s take a closer look at the disk encryption domain. There are several ways
    to encrypt disks. A common method in Linux for full block encryption is leveraging
    Linux Unified Key System (LUKS). LUKS works in conjunction with the dm-crypt encryption
    subsystem, which has been available in the Linux kernel since version 2.6\. For
    dedicated storage systems such as vSAN, ceph, or Gluster, each provide one or
    many means to provide encryption at rest. In cloud providers, the default encryption
    behavior can vary. For AWS, you should explore its documentation to enable encryption
    for Elastic Block Storage. AWS offers the ability to enable encryption by default,
    which we recommend as a best-practice setting. Google Cloud, on the other hand,
    performs encryption at rest as its default mode. Similar to AWS, it can be configured
    with the Key Management Service (KMS), which enables you to customize the encryption
    behavior, such as providing your own encryption keys.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看磁盘加密领域。有多种加密磁盘的方法。在 Linux 中，用于全块加密的常见方法是利用 Linux Unified Key System
    (LUKS)。LUKS 与 dm-crypt 加密子系统配合工作，在 Linux 内核 2.6 版本以来就可用。对于像 vSAN、ceph 或 Gluster
    等专用存储系统，每种都提供一种或多种加密静止状态的方式。在云提供商中，默认的加密行为可能会有所不同。例如，对于 AWS，您应该查阅其文档以启用弹性块存储的加密。AWS
    提供了启用默认加密的能力，这是我们推荐的最佳实践设置。而 Google Cloud 则以加密静止状态作为其默认模式。与 AWS 类似，它可以配置密钥管理服务
    (KMS)，从而使您能够自定义加密行为，例如提供自己的加密密钥。
- en: Regardless of the trust you do or don’t have for your cloud provider or datacenter
    operators, we highly recommend encryption at rest as your default practice. Encryption
    at rest essentially means the data is *stored* encrypted. Not only is this good
    for mitigating attack vectors, but it provides some protection against possible
    mistakes. For example, the world of virtual machines has made it trivial to create
    snapshots of hosts. Snapshots end up like any other file, data that is too easy
    to accidentally expose to an internal or external network. In the spirit of defense
    in depth, we should protect ourselves against this scenario where, if we select
    the wrong button via a UI or field in an API, the leaked data is useless for those
    without private key access. [Figure 7-1](#permission_setting) shows the UI for
    how easily these permissions can be toggled.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不论你对云服务提供商或数据中心运营商的信任程度如何，我们强烈建议将数据加密设为默认做法。加密数据在静止状态下意味着数据是*存储*加密的。这不仅有助于减少攻击向量，还能提供一定的保护，防止可能的错误。例如，虚拟机技术使得创建主机快照变得非常简单。快照最终成为像任何其他文件一样的数据，太容易意外暴露于内部或外部网络。为了多层防御的精神，我们应该保护自己免受这种情况的影响，即使通过用户界面或API字段选择了错误按钮，泄漏的数据对于没有私钥访问权限的人是毫无用处的。[图 7-1](#permission_setting)显示了如何轻松切换这些权限的用户界面。
- en: '![prku 0701](assets/prku_0701.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0701](assets/prku_0701.png)'
- en: Figure 7-1\. Permission setting on an AWS snapshot, as the warning says “making
    public” will give others access to create a volume from this snapshot and, potentially,
    access the data.
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-1\. AWS 快照上的权限设置，警告称“公开”将允许其他人从此快照创建卷，并有可能访问数据。
- en: Transport Security
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传输安全
- en: With a better understanding of encrypted data at rest, how about data that is
    actively in flight? Without having explored the Kubernetes secret architecture
    yet, let’s look at the paths a secret can take when being transported between
    services. [Figure 7-2](#diagram_demonstrating_points_where_a_secret_may_pass_over_the_wire)
    shows some of the interaction points for secrets. The arrows represent the secret
    moving through the network between hosts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于加密的静止数据有了更好的理解，那么处于活动状态中的数据呢？尽管尚未探索 Kubernetes 密钥管理架构，让我们来看看在服务之间传输时，密钥可能经过的路径。[图 7-2](#diagram_demonstrating_points_where_a_secret_may_pass_over_the_wire)展示了一些密钥在网络主机之间移动的交互点。
- en: '![prku 0702](assets/prku_0702.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0702](assets/prku_0702.png)'
- en: Figure 7-2\. Diagram demonstrating points where a secret may pass over the wire.
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 展示密钥可能通过网络传输的交点的图示。
- en: The figure shows secret data moving across the network to reach different hosts.
    No matter how strong our encryption at rest strategy is, if any of the interaction
    points do not communicate over TLS, we have exposed our secret data. As seen [Figure 7-2](#diagram_demonstrating_points_where_a_secret_may_pass_over_the_wire),
    this includes the human-to-system interaction, kubectl, and the system-to-system
    interaction, kubelet to API server. In summary, it’s crucial communications with
    the API server and etcd that happen exclusively over TLS. We won’t spend much
    time discussing this need as it is the default for almost every mode of installing
    or bootstrapping Kubernetes clusters. Often the only configuration you may wish
    to do is to provide a Certificate Authority (CA) to generate the certificates.
    However, keep in mind these certificates are internal to Kubernetes system components.
    With this in mind, you might not need to overwrite the default CA Kubernetes will
    generate.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图表显示了秘密数据通过网络传输到不同主机的情况。无论我们的静态加密策略有多强大，如果任何交互点没有通过 TLS 进行通信，我们就暴露了我们的秘密数据。正如所示
    [图 7-2](#diagram_demonstrating_points_where_a_secret_may_pass_over_the_wire)，这包括人与系统的交互，kubectl，以及系统与系统之间的交互，kubelet
    到 API 服务器。总之，与 API 服务器和 etcd 的通信必须专门通过 TLS 进行。我们不会花太多时间讨论这个需求，因为几乎每种 Kubernetes
    集群的安装或引导模式都是默认的。通常，您可能唯一希望执行的配置就是提供一个证书颁发机构（CA）来生成证书。但请记住，这些证书是 Kubernetes 系统组件内部使用的。有了这个理解，您可能不需要覆盖
    Kubernetes 将生成的默认 CA。
- en: Application Encryption
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用加密
- en: Application encryption is the encryption we perform within our system components
    or workloads running in Kubernetes. Application encryption can have many layers
    itself. For example, a workload in Kubernetes can encrypt data before persisting
    it to Kubernetes, which could then encrypt it, and then persisting it to etcd
    where it’ll be encrypted at the filesystem level. The first two encryption points
    are considered “application-level.” That’s a lot of encryption!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 应用加密是在我们的系统组件或运行在 Kubernetes 中的工作负载内执行的加密。应用加密本身可以有多个层级。例如，Kubernetes 中的工作负载可以在将数据持久化到
    Kubernetes 之前加密数据，然后 Kubernetes 可能再次加密数据，并将其持久化到 etcd，在那里它将在文件系统级别加密。前两个加密点被认为是“应用级别”的。这是很多层加密啊！
- en: 'While we won’t always have encryption or decryption take place at that many
    levels, there is something to be said about data being encrypted at least once
    at the application level. Consider what we’ve talked about thus far: encryption
    over TLS and encryption at rest. If we’d stopped there, we’d have a decent start.
    When secret data is in flight, it will be encrypted, and it’ll also be encrypted
    on the physical disk. But what about on the running system? While the bits persisted
    to disk may be encrypted, if a user were to gain access to the system they would
    likely be able to read the data! Consider your encrypted desktop computer where
    you may keep sensitive credentials in a dotfile (we’ve all done it). If I steal
    your computer and try to access this data by sledding the drive, I won’t be able
    to get the information I’m after. However, if I succeed at booting your computer
    *and logging in as you*, I now have full access to this data.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们并不总是会在这么多层次上进行加密或解密，但至少在应用级别对数据进行加密是有意义的。考虑到我们迄今为止讨论的内容：TLS 上的加密和静态数据的加密。如果我们止步于此，我们已经有了一个不错的开始。当机密数据在传输时，它将被加密，并且在物理磁盘上也将被加密。但在运行系统时怎么办呢？尽管存储到磁盘的比特可能已经加密，如果用户能够访问系统，他们可能能够读取这些数据！想象一下你的加密桌面电脑，你可能在一个
    dotfile 中保存了敏感凭据（我们都这样做过）。如果我偷走了你的电脑并尝试通过“滑雪”磁盘来访问这些数据，我将无法获取我想要的信息。然而，如果我成功地启动你的计算机并“以你的身份”登录，我现在可以完全访问这些数据。
- en: 'Application encryption is the act of encrypting that data with a key at the
    userspace level. In this computer example, I could use a (strongly) password protected
    gpg key to encrypt that dotfile, requiring my user to decrypt it before it can
    be used. Writing a simple script can automate this process and you’re off to the
    races with a far *deeper* security model. As the attacker logged in as you, even
    the decryption key is useless because without the password it’s just useless bits.
    The same consideration applies to Kubernetes. Going forward we’re going to assume
    two things are set up in your cluster:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序加密是在用户空间级别使用密钥加密数据的行为。在这个计算机示例中，我可以使用一个（强大的）密码保护的gpg密钥来加密那个dotfile，需要我的用户在可以使用它之前对其进行解密。编写一个简单的脚本可以自动化这个过程，你可以用更深的*安全模型*来做。作为登录为您的攻击者，即使解密密钥是无用的，因为没有密码它只是无用的位。这个考虑对Kubernetes也是适用的。我们将假定在您的集群中设置了两个事物：
- en: Encryption at rest is enabled in the filesystem and/or storage systems used
    by Kubernetes.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes使用的文件系统和/或存储系统中启用了静态加密。
- en: TLS is enabled for all Kubernetes components and etcd.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为所有Kubernetes组件和etcd启用了TLS。
- en: With this, let’s begin our exploration of encryption at the Kubernetes application
    level.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，让我们开始探讨Kubernetes应用层的加密。
- en: The Kubernetes Secret API
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes Secret API
- en: 'The Kubernetes Secret API is one of the most-used APIs in Kubernetes. While
    there are many ways for us to populate the Secret objects, the API provides a
    consistent means for workloads to interact with secret data. Secret objects heavily
    resemble ConfigMaps. They also have similar mechanics around how workloads can
    consume the objects, via environment variables or volume data. Consider the following
    Secret object:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes Secret API是Kubernetes中最常用的API之一。虽然我们可以以多种方式填充Secret对象，但API为工作负载提供了一种一致的方式与秘密数据交互。秘密对象与ConfigMaps非常相似。它们在工作负载如何消耗对象的机制上也有类似的机制，通过环境变量或卷数据。考虑以下Secret对象：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `data` field, `dbuser` and `dbkey` are base64 encoded. All Kubernetes
    secret data is. If you wish to submit nonencoded string data to the API server,
    you can use the `stringData` field as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在`data`字段中，`dbuser`和`dbkey`是base64编码的。所有Kubernetes秘密数据都是。如果您希望向API服务器提交非编码字符串数据，可以使用以下`stringData`字段：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When applied, the `stringData` will be encoded at the API server and applied
    to etcd. A common misconception is that Kubernetes is encoding this data as a
    practice of security. This is not the case. Secret data can contain all kinds
    of strange characters or binary data. In order to ensure it’s stored correctly,
    it is base64 encoded. By default, the key mechanism for ensuring that Secrets
    aren’t compromised is RBAC. Understanding the implications of RBAC verbs as they
    pertain to Secrets is crucial to prevent introducing vectors of attack:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用时，`stringData`将在API服务器上编码并应用于etcd。一个常见的误解是，Kubernetes将此数据编码为安全实践。事实并非如此。秘密数据可以包含各种奇怪的字符或二进制数据。为了确保它被正确存储，它被base64编码。默认情况下，确保秘密不被泄露的关键机制是RBAC。理解RBAC动词在秘密中的意义对于防止引入攻击向量至关重要。
- en: '`get`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`'
- en: Retrieve the data of a known secret by its name.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称检索已知秘密的数据。
- en: '`list`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`'
- en: Get a list of all secrets and/or *secret data*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 获取所有秘密和/或*秘密数据*的列表。
- en: '`watch`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`'
- en: Watch any secret change and/or change to *secret data*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查看任何秘密更改和/或更改为*秘密数据*。
- en: As you can imagine, small RBAC mistakes, such as giving the user list access,
    expose every Secret in a Namespace or, worse, the entire cluster if a ClusterRoleBinding
    is accidentally used. The truth is, in many cases, users don’t need any of these
    permissions. This is because a user’s RBAC does not determine what secrets the
    workload can have access to. Generally the kubelet is responsible for making the
    secret available to the container(s) in a Pod. In summary, as long as your Pod
    references a valid secret, the kubelet will make it available through the means
    you specify. There are a few options to how we expose the secret in the workload,
    which is covered next.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以想象的那样，小的RBAC错误，比如给用户列出访问权限，会暴露命名空间中的每一个秘密，或者更糟糕的是整个集群如果意外使用了ClusterRoleBinding。事实上，在许多情况下，用户根本不需要这些权限。这是因为用户的RBAC并不决定工作负载可以访问哪些秘密。通常，kubelet负责使秘密对容器中的Pod可用。总之，只要您的Pod引用了有效的秘密，kubelet将通过您指定的方式使其可用。有几种选项可以在工作负载中公开秘密，下面将介绍。
- en: Secret Consumption Models
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秘密消费模型
- en: For workloads wishing to consume a Secret, there are several choices. The preference
    on how secret data is ingested may depend on the application. However, there are
    trade-offs to the approach you choose. In the coming sections, we’ll look at three
    means of consuming secret data in workloads.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于希望使用秘密的工作负载，有几种选择。如何摄取秘密数据的偏好可能取决于应用程序。但是，选择的方法存在一些权衡。在接下来的几节中，我们将看一下在工作负载中消费秘密数据的三种方法。
- en: Environment variables
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境变量
- en: 'Secret data may be injected into environment variables. In the workload YAML,
    an arbitrary key and reference to the secret may be specified. This can be a nice
    feature for workloads moving onto Kubernetes that already expect an environment
    variable by reducing the need to change application codes. Consider the following
    Pod example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将秘密数据注入到环境变量中。在工作负载的YAML中，可以指定任意键和对秘密的引用。对于已预期通过减少应用程序代码的需求而在Kubernetes上移动的工作负载，这可能是一个不错的功能。考虑以下Pod示例：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_secret_management_CO1-1)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secret_management_CO1-1)'
- en: The environment variable key that will be available in the application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中可用的环境变量键。
- en: '[![2](assets/2.png)](#co_secret_management_CO1-2)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secret_management_CO1-2)'
- en: The name of the Secret object in Kubernetes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中秘密对象的名称。
- en: '[![3](assets/3.png)](#co_secret_management_CO1-3)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secret_management_CO1-3)'
- en: The key in the Secret object that should be injected into the `USER` variable.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注入到`USER`变量中的秘密对象中的键。
- en: The downside to exposing secrets in environment variables is their inability
    to be hot reloaded. A change in a Secret object will not be reflected until the
    Pod is re-created. This could occur through manual intervention or system events
    such as the need to reshedule. Additionally, it is worth calling out that some
    consider secrets in environment variables to be less secure than reading from
    volume mounts. This point can be debated, but it is fair to call out some of the
    common opportunities to leak. Namely, when processes or container runtimes are
    inspected, there may be ways to see the environment variables in plain text. Additionally,
    some frameworks, libraries, or languages may support debug or crash modes where
    they dump (spew) environment variables out to the logs. Before using environment
    variables, these risks should be considered.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在环境变量中暴露秘密的缺点在于它们无法进行热重新加载。在秘密对象更改后，直到重新创建Pod，更改才会生效。这可能通过手动干预或系统事件（如需要重新调度）发生。此外，有人认为环境变量中的秘密比从卷挂载中读取的方式不安全。这一点可能会有争议，但公平地指出一些常见的泄露机会是值得的。即在检查进程或容器运行时时，可能会以明文方式看到环境变量。此外，一些框架、库或语言可能支持调试或崩溃模式，其中它们会将环境变量输出到日志中。在使用环境变量之前，应考虑这些风险。
- en: Volumes
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 卷
- en: 'Alternatively, secret objects may be injected via volumes. In the workload’s
    YAML, a volume is configured where the secret is referenced. The container that
    the secret should be injected into references that volume using a `volumeMount`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，秘密对象可以通过卷注入。在工作负载的YAML中，配置了一个卷，其中引用了秘密。应将秘密注入到的容器使用`volumeMount`引用该卷：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_secret_management_CO2-3)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secret_management_CO2-3)'
- en: Pod-level volumes available for mounting. Name specified must be referenced
    in the mount.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可挂载的Pod级别卷。指定的名称必须在挂载中引用。
- en: '[![2](assets/2.png)](#co_secret_management_CO2-1)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secret_management_CO2-1)'
- en: The volume object to mount into the container filesystem.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂载到容器文件系统中的卷对象。
- en: '[![3](assets/3.png)](#co_secret_management_CO2-2)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secret_management_CO2-2)'
- en: Where in the container filesystem the mount is made available.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载在容器文件系统中的位置。
- en: 'With this Pod manifest, the secret data is available under */etc/credentials*
    with each key/value pair in the secret object getting its own file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此Pod清单，秘密数据在*/etc/credentials*下可用，秘密对象中的每个键/值对都有自己的文件：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The biggest benefit to the volume approach is that secrets may be updated dynamically,
    without the Pod restarting. When a change to the secret is seen, the kubelet will
    reload the secret and it’ll show as updated in the container’s filesystem. It’s
    important to call out that the kubelet is using tmpfs, on Linux, to ensure secret
    data is stored exclusively in memory. We can see this by examining the mount table
    file on the Linux host:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过卷的方法最大的好处是可以动态更新秘密，而无需重启 Pod。当看到秘密发生变化时，kubelet 将重新加载秘密，并且在容器的文件系统中显示为已更新。需要强调的是，kubelet
    在 Linux 上使用 tmpfs 确保秘密数据仅存储在内存中。我们可以通过查看 Linux 主机上的挂载表文件来验证这一点：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the `nginx` Pod is removed from this host, this mount is discarded. With
    this model in mind, it’s especially important to consider that Secret data should
    *never* be large in size. Ideally it holds credentials or keys and is never used
    as a pseudo database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从此主机上移除 `nginx` Pod，则此挂载将被丢弃。在考虑这种模型时，特别需要注意的是，秘密数据*永远*不应该很大。理想情况下，它仅包含凭据或密钥，永远不应用作伪数据库。
- en: From an application perspective, a simple watch on the directory or file, then
    re-injecting values into the application, is all it would take to handle a secret
    change. No need to understand or communicate with the Kubernetes API server. This
    is an ideal pattern we’ve seen success with in many workloads.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序的角度来看，只需在目录或文件上进行简单的监控，然后将值重新注入应用程序即可处理秘密变更。无需理解或与 Kubernetes API 服务器通信。我们在许多工作负载中看到了这种模式的成功应用。
- en: Client API Consumption
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端 API 消费
- en: The last consumption model, Client API Consumption, is not a core Kubernetes
    feature. This model puts the onus on the application to communicate with the kube-apiserver
    to retrieve Secret(s) and inject them into the application. There are several
    frameworks and libraries out there that make communicating with Kubernetes trivial
    for your application. For Java, Spring’s Spring Cloud Kubernetes brings this functionality
    to Spring applications. It takes the commonly used Spring PropertySource type
    and enables it to be wired up by connecting to Kubernetes and retreiving Secrets
    and/or ConfigMaps.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的消费模型，客户端 API 消费，并不是核心 Kubernetes 功能。这种模型要求应用程序与 kube-apiserver 通信以检索 Secret(s)
    并将其注入应用程序。有许多框架和库可以使应用程序轻松与 Kubernetes 通信。例如，对于 Java，Spring 的 Spring Cloud Kubernetes
    将此功能引入到了 Spring 应用程序中。它将常用的 Spring PropertySource 类型连接到 Kubernetes，以检索 Secret
    和/或 ConfigMap。
- en: Now that we have covered consumption of secrets at a workload level, it is time
    to talk about storing secret data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了在工作负载级别消费秘密的方式，是时候谈谈存储秘密数据了。
- en: Secret Data in etcd
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: etcd 中的秘密数据
- en: Like most Kubernetes objects, Secrets are stored in etcd. By default, *no* encryption
    is done at the Kubernetes layer before persisting Secrets to etcd. [Figure 7-3](#default_secret)
    shows the flow of a secret from manifest to etcd.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数 Kubernetes 对象一样，Secrets 存储在 etcd 中。默认情况下，在将 Secrets 持久化到 etcd 之前，Kubernetes
    层不进行任何加密。[图 7-3](#default_secret) 展示了从清单到 etcd 的秘密流程。
- en: '![prku 0703](assets/prku_0703.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0703](assets/prku_0703.png)'
- en: Figure 7-3\. Default secret data flow in Kubernetes (the colocated etcd is sometimes
    run on a separate host).
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. Kubernetes 中默认的秘密数据流程（有时 colocated etcd 运行在单独的主机上）。
- en: While Kubernetes did *not* encrypt the secret data, this does not imply access
    to the data upon gaining hardware access. Remember that encryption at rest can
    be performed on disks through methods such as Linux Unified Key Setup (LUKS),
    where physical access to hardware gives you access only to encrypted data. For
    many cloud providers and enterprise datacenters, this is a default mode of operation.
    However, should we gain `ssh` access to the server running etcd and a user that
    has privileges or can escalate to see its filesystem, then we can potentially
    gain access to the secret data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 并*不*加密秘密数据，但这并不意味着在获得硬件访问权限后可以访问数据。请记住，可以通过诸如 Linux 统一密钥设置（LUKS）之类的方法对磁盘上的数据进行加密，这样即使物理访问硬件，也只能访问到加密数据。对于许多云提供商和企业数据中心来说，这是默认的操作模式。然而，如果我们获得了对运行
    etcd 的服务器的`ssh`访问权限，并且有特权或者可以升级权限来查看其文件系统，则我们可能会获取到秘密数据。
- en: For some cases, this default model can be acceptable. etcd can be run external
    to the Kubernetes API server, ensuring it is separated by at least a hypervisor.
    In this model, an attacker would likely need to obtain root access to the etcd
    node, find the data location, and then read the secrets from the etcd database.
    The other entry point would be an adversary getting root access to the API server,
    locating the API server and etcd certs, then impersonating the API server in communicating
    with etcd to read secrets. Both cases assume potentially other breaches. For example,
    the attacker would have had to gain access to the internal network or subnet that
    is running the control-plane components. Additionally, they’d need to get the
    appropriate key to `ssh` into the node. Frankly, it’s far more likely that an
    RBAC mistake or application compromise would expose a secret before this case.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些情况，这种默认模型可能是可接受的。etcd可以在Kubernetes API服务器外部运行，确保至少由一个分区隔离。在这种模型中，攻击者可能需要获取etcd节点的root访问权限，找到数据位置，然后从etcd数据库中读取秘密。另一个入口点将是对手获取API服务器的root访问权限，找到API服务器和etcd证书，然后冒充API服务器与etcd通信以读取秘密。这两种情况都假设可能存在其他漏洞。例如，攻击者必须获取正在运行控制平面组件的内部网络或子网的访问权限。此外，他们需要获取适当的密钥以便`ssh`进入节点。坦率地说，在这种情况之前，RBAC错误或应用程序的妥协将暴露秘密更有可能。
- en: 'To better understand the threat model, let’s work through an example of how
    an attacker could gain access to Secrets. Let’s consider the case where an attacker
    SSHs and gains root access to the kube-apiserver node. The attacker could set
    up a script as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解威胁模型，让我们通过一个示例来说明攻击者如何获取秘密的过程。假设攻击者通过SSH访问并获得了kube-apiserver节点的root访问权限。攻击者可以设置以下脚本：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The certificate and key locations seen in this snippet are the default when
    Kubernetes was bootstrapped by kubeadm, which is also used by many tools such
    as cluster-api. etcd stores the secret data within the directory */registry/secrets/${NAMESPACE}/${SECRET_NAME}*.
    Using this script to get a secret, named `login1`, would look as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段中看到的证书和密钥位置是Kubernetes通过kubeadm引导时的默认设置，这也是许多工具如cluster-api所使用的。etcd将秘密数据存储在目录*/registry/secrets/${NAMESPACE}/${SECRET_NAME}*中。使用此脚本获取名为`login1`的秘密将如下所示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this, we have successfully compromised the secret `login1`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们成功地泄露了秘密`login1`。
- en: Even though storing Secrets without encryption can be acceptable, many platform
    operators choose not to stop here. Kubernetes supports a few ways to encrypt the
    data within etcd, furthering the depth of your defense with respect to secrets.
    These include models to support encryption at rest (where encryption occurs at
    the Kubernetes layer) before it rests in etcd. These models include static-key
    encryption and envelope encryption.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 即使存储未加密的秘密可能被接受，许多平台运营商选择不止步于此。Kubernetes支持几种在etcd内部加密数据的方式，从而进一步加深了您在秘密保护方面的防御深度。这些方式包括支持在静止状态下加密（即在Kubernetes层进行加密）之前在etcd中存储秘密的模型。这些模型包括静态密钥加密和信封加密。
- en: Static-Key Encryption
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态密钥加密
- en: The Kubernetes API server supports encrypting secrets at rest. This is achieved
    by providing the Kubernetes API server with an encryption key, which it will use
    to encrypt all secret objects before persisting them to etcd. [Figure 7-4](#encryption_key)
    shows the flow of a secret when static-key encryption is in play.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API服务器支持在静止状态下加密秘密。这通过向Kubernetes API服务器提供加密密钥来实现，它将用于在将所有秘密对象持久化到etcd之前对其进行加密。[图7-4](#encryption_key)展示了在使用静态密钥加密时秘密的流动过程。
- en: '![prku 0704](assets/prku_0704.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0704](assets/prku_0704.png)'
- en: Figure 7-4\. The relationship between an encryption key, on the API server,
    being used to encrypt secrets before storing them in etcd.
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-4. 在API服务器上使用的加密密钥与在将秘密存储到etcd之前对其进行加密之间的关系。
- en: The key, held within an `EncryptionConfiguration`, is used to encrypt and decrypt
    Secret objects as they move through the API server. Should an attacker get access
    to etcd, they would see the encrypted data within, meaning the Secret data is
    not compromised. Keys can be created using a variety of providers, including secretbox,
    aescbc, and aesgcm.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 放置在`EncryptionConfiguration`中的密钥用于在秘密对象通过API服务器时进行加密和解密。如果攻击者访问了etcd，他们将看到其中的加密数据，这意味着秘密数据并未泄露。可以使用各种提供者（包括secretbox、aescbc和aesgcm）创建密钥。
- en: 'Each provider has its own trade-offs, and we recommend working with your security
    team to select the appropriate option. Kubernetes issue #81127 is a good read
    on some considerations around these providers. If your enterprise needs to comply
    with standards such as the Federal Information Processing Standards (FIPS), these
    choices should be carefully considered. In our example we’ll use secretbox, which
    acts as a fairly performant and secure encryption provider.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 每个提供商都有自己的权衡，我们建议与您的安全团队合作选择合适的选项。Kubernetes问题＃81127对于这些提供商的一些考虑是一个很好的阅读资料。如果您的企业需要符合Federal
    Information Processing Standards（FIPS）等标准，应仔细考虑这些选择。在我们的示例中，我们将使用secretbox，它作为一种性能良好且安全的加密提供程序。
- en: 'To set up static-key encryption, we must generate a 32-byte key. Our encryption
    and decryption model is symmetric, so a single key serves both purposes. How you
    generate a key can vary enterprise to enterprise. Using a Linux host, we can easily
    use `/dev/urandom` if we’re satisfied with its entropy:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置静态密钥加密，我们必须生成一个32字节的密钥。我们的加密和解密模型是对称的，因此一个单独的密钥可以同时用于两个目的。如何生成密钥可能会因企业而异。如果我们对其熵满意，可以在Linux主机上轻松使用`/dev/urandom`：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using this key data, an EncryptionConfiguration should be added to all nodes
    running a kube-apiserver. This static file should be added using configuration
    management such as ansible or KubeadmConfigSpec if using Cluster API. This ensures
    keys can be added, deleted, and rotated. The following example assumes the configuration
    is stored at */etc/kubernetes/pki/secrets/encryption-config.yaml*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个密钥数据，应该在运行kube-apiserver的所有节点上添加EncryptionConfiguration。如果使用Cluster API，应使用配置管理工具如ansible或KubeadmConfigSpec添加此静态文件。这确保了密钥可以添加、删除和轮转。以下示例假定配置存储在*/etc/kubernetes/pki/secrets/encryption-config.yaml*中：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The list of providers is ordered, meaning encryption will always occur using
    the first key and decryption will be attempted in order of keys listed. Identity
    is the default plain-text provider and should be last. If it’s first, secrets
    will not be encrypted.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者列表是有序的，这意味着加密将始终使用第一个密钥，解密将按密钥列表的顺序尝试。身份是默认的明文提供者，应该放在最后。如果它是第一个，密码将不会加密。
- en: To respect the preceding configuration, every instance of the kube-apiserver
    must be updated to load the EncryptionConfiguration locally. In */etc/kubernetes/manifests/kube-apiserver.yaml*,
    an argument can be added as follows.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循上述配置，必须更新kube-apiserver的每个实例以在本地加载EncryptionConfiguration。在*/etc/kubernetes/manifests/kube-apiserver.yaml*中，可以添加参数如下。
- en: '[PRE10]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the kube-apiserver(s) restart, this change will take effect and secrets
    will be encrypted before being sent to etcd. The kube-apiserver restart may be
    automatic. For example, when using static Pods to run the API server, a change
    to the manifest file will trigger a restart. Once you’re past stages of experimentation,
    it’s recommended you pre-provision hosts with this file and ensure the `encryption-provider`
    is enabled by default. The EncryptionConfiguration file can be added using configuration
    management tools such as Ansible or, with cluster-api, by setting that static
    file in a kubeadmConfigSpec. Note this cluster-api approach will put the EncryptionConfiguration
    in user data; make sure the user data is encrypted! Adding the `encryption-provider-config`
    flag to the API server can be done by adding the argument to the `apiServer` within
    a ClusterConfiguration, assuming you’re using kubeadm. Otherwise, ensure the flag
    is present based on your mechanism for starting the server.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦kube-apiserver(s)重新启动，此更改将生效，并且在发送到etcd之前将加密密码。kube-apiserver的重启可能是自动的。例如，当使用静态Pod来运行API服务器时，对清单文件的更改将触发重新启动。一旦您经过实验阶段，建议预先使用此文件预配置主机，并确保默认情况下启用`encryption-provider`。可以使用配置管理工具如Ansible或者使用cluster-api，在kubeadmConfigSpec中设置该静态文件来添加EncryptionConfiguration文件。请注意，这种cluster-api方法将EncryptionConfiguration放在用户数据中；确保用户数据已加密！通过向ClusterConfiguration中的apiServer添加参数，可以通过向API服务器添加`encryption-provider-config`标志来完成。假设您正在使用kubeadm，否则，请根据启动服务器的机制确保标志存在。
- en: 'To validate the encryption, you can apply a new secret object to the API server.
    Assuming the secret is named `login2`, using the script from the previous section
    we can retrieve it as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证加密，您可以将一个新的secret对象应用到API服务器上。假设秘密的名称是`login2`，使用上一节的脚本，我们可以如下检索它：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here we can see the data is fully encrypted in etcd. Note there is metadata
    specifying which provider (`secretbox`) and key (`secret-key-1`) was used to do
    the encryption. This is important to Kubernetes as it supports many providers
    and keys at once. Any object created before the encryption key was set; let’s
    assume `login1` can be queried and will still show up in plain text:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们可以看到数据完全加密在etcd中。请注意，有元数据指定了使用的提供者（`secretbox`）和密钥（`secret-key-1`）进行加密。这对Kubernetes很重要，因为它同时支持多个提供者和密钥。任何在设置加密密钥之前创建的对象，假设`login1`，可以查询并仍然以明文显示：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This demonstrates two important concepts. One, `login1` is *not* encrypted.
    While the encryption key is in place, only newly created or altered secret objects
    will be encrypted using this key. Secondly, when passing back through the kube-apiserver,
    no provider/key mapping is present and no decryption will be attempted. This latter
    concept is important because it is highly recommended you rotate encryption keys
    over a defined span. Let’s say you rotate once every three months. When three
    months have elapsed, we’d alter the EncryptionConfiguation as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了两个重要概念。其一，`login1` *未* 加密。虽然加密密钥已就位，但只有新创建或修改的秘密对象将使用此密钥进行加密。其二，当通过kube-apiserver返回时，不存在提供者/密钥映射，也不会尝试解密。后一概念很重要，因为强烈建议您在定义的时间内轮换加密密钥。假设您每三个月轮换一次。当三个月过去后，我们将如下更改EncryptionConfiguation：
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It is *crucial* that `secret-key-1` is not removed. While it will not be used
    for new encryption, it is used for existing secret objects, previously encrypted
    by it, for decryption! The removal of this key will prevent the API server from
    returning secret objects, such as `login2`, to clients. Since this key is first,
    it will be used for all new encryption. When secret objects are updated, they
    will be re-encrypted using this new key over time. Until then, the original key
    can remain in the list as a fallback decryption option. If you delete the key,
    you’ll see the following responses from your client:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*关键*在于不要删除`secret-key-1`。虽然它将不会用于新的加密，但它用于以前由它加密的现有秘密对象的解密！删除此密钥将阻止API服务器向客户端返回秘密对象，例如`login2`。由于此密钥是第一个，它将用于所有新的加密。更新秘密对象时，它们将随时间重新使用此新密钥进行重新加密。在此之前，原始密钥可以作为后备解密选项保留在列表中。如果删除该密钥，您将从客户端看到以下响应：'
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Envelope Encryption
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信封加密
- en: 'Kubernetes 1.10 and later supports integrating with a KMS to achieve envelope
    encryption. Envelope encryption involves two keys: the key encryption key (KEK)
    and the data encryption key (DEK). KEKs are stored externally in a KMS and aren’t
    at risk unless the KMS provider is compromised. KEKs are used to encrypt DEKs,
    which are responsible for encrypting Secret objects. Each Secret object gets its
    own unique DEK to encrypt and decrypt the data. Since DEKs are encrypted by a
    KEK, they can be stored with the data itself, preventing the kube-apiserver from
    needing to be aware of many keys. Architecturally, the flow of envelope encryption
    would look like the diagram shown in [Figure 7-5](#envelope_encryption).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 1.10及更高版本支持与KMS集成以实现信封加密。信封加密涉及两个密钥：密钥加密密钥（KEK）和数据加密密钥（DEK）。KEK存储在KMS中并且只有在KMS提供者被ompromise的情况下才会有风险。KEK用于加密DEK，DEK负责加密Secret对象。每个Secret对象都有其自己独特的DEK用于加密和解密数据。由于DEK由KEK加密，它们可以与数据本身一起存储，从而使kube-apiserver无需了解许多密钥。从架构上讲，信封加密的流程将看起来像[图7-5](#envelope_encryption)中显示的图表。
- en: '![prku 0705](assets/prku_0705.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0705](assets/prku_0705.png)'
- en: Figure 7-5\. Flow to encrypt secrets using envelope encryption. The KMS layer
    lives outside the cluster.
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-5. 使用信封加密加密秘密的流程。KMS层位于集群外。
- en: 'There can be some variance in how this flow works, based on a KMS provider,
    but generally this demonstrates how envelope encryption functions. There are multiple
    benefits to this model:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据KMS提供者的不同，此流程的工作方式可能会有所不同，但通常这演示了信封加密的功能。这种模型有多个好处：
- en: KMS is external to Kubernetes, increasing security via isolation.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KMS外部到Kubernetes，通过隔离增强安全性。
- en: Centralization of KEKs enables easy rotation of keys.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KEK的集中化使密钥轻松旋转。
- en: Separation of DEK and KEK means that secret data is never sent to or known by
    the KMS
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEK和KEK的分离意味着秘密数据永远不会被发送到或被KMS知道
- en: KMS is concerned only with decrypting DEKs.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KMS仅关注解密DEK。
- en: Encryption of DEKs means they are easy to store alongside their secret, making
    management of keys in relation to their secrets easy.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DEK的加密意味着它们很容易与其密钥一起存储，使得与其密钥相关的管理变得容易。
- en: 'The provider plug-ins work by running a privileged container implementing a
    gRPC server that can communicate with a remote KMS. This container runs exclusively
    on master nodes where a kube-apiserver is present. Then, similar to setting up
    encryption in the previous section, an EncryptionConfiguration must be added to
    master nodes with settings to communicate with the KMS plug-in:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 提供者插件通过在运行kube-apiserver的主节点上运行实现gRPC服务器的特权容器来工作，该容器可以与远程KMS通信。然后，类似于在上一节设置加密时，必须向主节点添加一个EncryptionConfiguration，其中包含与KMS插件通信的设置：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Assuming the EncryptionConfiguration is saved on each master node at */etc/kubernetes/pki/secrets/encryption-config.yaml*,
    the kube-apiserver arguments must be updated to include the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 假设EncryptionConfiguration保存在每个主节点的*/etc/kubernetes/pki/secrets/encryption-config.yaml*，则必须更新kube-apiserver的参数以包含以下内容：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Changing the value should restart the kube-apiserver. If it doesn’t, a restart
    is required for the change to take effect.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更改该值应重新启动kube-apiserver。如果没有重新启动，则需要重新启动才能生效。
- en: From a design perspective, this is a viable model. However, KMS plug-in implementations
    are scarce and the ones that do exist are immature. When we wrote this book, the
    following data points are true. There are no tagged releases for the aws-encryption-provider
    (AWS) or the k8s-cloudkms-plugin (Google). Azure’s plug-in kubernetes-kms has
    notable limitations, such as no support for key rotation. So with the exception
    of running in a managed service, such as GKE where the KMS plug-in is automatically
    available and supported by Google, usage may prove unstable. Lastly, the only
    cloud provider-agnostic KMS plug-in available was kubernetes-vault-kms-plugin,
    which was only partially implemented and has been archived (abandoned).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计角度来看，这是一个可行的模型。然而，KMS插件的实现非常稀缺，现有的实现也比较不成熟。在我们撰写本书时，以下数据点是真实的。对于aws-encryption-provider（AWS）或k8s-cloudkms-plugin（Google），都没有标记的发布版本。Azure的插件kubernetes-kms存在显著的限制，比如不支持密钥轮换。因此，除了在如GKE这样的托管服务中运行，其中KMS插件是自动可用且受Google支持的情况下，使用可能会不稳定。最后，唯一的跨云提供商通用的KMS插件是kubernetes-vault-kms-plugin，但它只部分实现，并且已经归档（放弃）。
- en: External Providers
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部提供者
- en: Kubernetes is not what we’d consider an enterprise-grade secret store. While
    it does offer a Secret API that will be used for things like Service Accounts,
    for enterprise secret data it may fall short. There is nothing inherently wrong
    with using it to store application secrets, as long as the risks and options are
    understood, which is largely what this chapter has described thus far! However,
    many of our clients demand more than what the Secret API can offer, especially
    those working in sectors such as financial services. These users need capabilities
    such as integration with a hardware security module (HSM) and have advanced key
    rotation policies.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes并不是我们认为的企业级秘密存储系统。虽然它确实提供了Secret API，可用于诸如服务账户之类的东西，但对于企业秘密数据，它可能表现不佳。使用它来存储应用程序秘密并没有什么本质上的问题，只要理解风险和选项，这正是本章节迄今为止主要描述的内容！然而，许多客户需要比Secret
    API能提供的更多，特别是那些在金融服务等行业工作的用户。这些用户需要诸如与硬件安全模块（HSM）集成和高级密钥轮换策略之类的能力。
- en: Our guidance is generally to start with what Kubernetes offers and see if the
    approaches to harden its security (i.e., encryption) are adequate. As described
    in the previous section, KMS encryption models that offer envelope encryption
    provide a pretty strong story around the safety of secret data in etcd. If we
    need to extend beyond this (and we often do), we then look to what secret management
    tooling preexists that the engineering team(s) have operational knowledge of.
    Running secret management systems in a production-ready capacity can be a challenging
    task, similar to running any stateful service where the data contained within
    needs to be not only highly available but protected from potential attackers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的建议通常是从Kubernetes提供的功能开始，并查看是否适用于加固其安全性（即加密）的方法。正如前一节所述，提供信封加密的KMS加密模型在etcd中保护秘密数据的安全性方面具有相当强大的功能。如果需要进一步扩展（我们通常会这样做），我们会寻找工程团队已有操作知识的秘密管理工具。在生产环境中运行秘密管理系统可能是一项具有挑战性的任务，类似于运行任何需要不仅高可用性而且需要保护免受潜在攻击者侵害的有状态服务。
- en: Vault
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 金库
- en: Vault is an open source project by HashiCorp. It is by far the most popular
    project we run into with our clients when it comes to secret management solutions.
    Vault has found several ways to integrate in the cloud native space. Work has
    been done around providing first-class integration in frameworks such as Spring
    and in Kubernetes itself. One emerging pattern is to run Vault within Kubernetes
    and enable Vault to use the TokenReview API to authenticate requests against the
    Kubernetes API Server. Next, we’ll explore two common Kubernetes integration points,
    including sidecar and initContainer injection along with a newer approach, CSI
    integration.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 是 HashiCorp 推出的开源项目。在我们的客户中，当涉及到秘密管理解决方案时，它迄今为止是最受欢迎的项目。Vault 在云原生领域找到了几种集成方式。已经在提供类似
    Spring 和 Kubernetes 本身的框架中进行了工作，提供了一流的集成。一个新兴的模式是在 Kubernetes 中运行 Vault，并允许 Vault
    使用 TokenReview API 对抗 Kubernetes API Server 进行身份验证请求。接下来，我们将探讨两个常见的 Kubernetes
    集成点，包括 sidecar 和 initContainer 注入以及一个更新的方法，CSI 集成。
- en: Cyberark
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cyberark
- en: Cyberark is another popular option we see with clients. As a company, it’s been
    around for a while, and often we find preexisting investments to exist and a desire
    to integrate Kubernetes with it. Cyberark offers a Credential Provider and Dynamic
    Access Provider (DAP). DAP provides multiple enterprise mechanisms Kubernetes
    administrators may want to integrate with. Similar to Vault, it supports the ability
    to use initContainers alongside your application to communicate with DAP.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Cyberark 是另一个我们与客户见到的流行选择。作为一家公司，它已经存在了一段时间，并且我们经常发现已有的投资和希望将 Kubernetes 与其集成的愿望。Cyberark
    提供凭据提供程序和动态访问提供程序（DAP）。DAP 提供多种企业机制，Kubernetes 管理员可能希望与之集成。与 Vault 类似，它支持与应用程序一起使用
    initContainers 与 DAP 进行通信的能力。
- en: Injection Integration
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注入集成
- en: Once an external secret store is available to workloads in Kubernetes, there
    are several options for retrieval. This section covers these approaches, our recommendations,
    and trade-offs. We’ll cover each design approach to consuming secrets and describe
    Vault’s implementation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦外部密钥存储对 Kubernetes 中的工作负载可用，有几种检索选项。本节介绍了这些方法、我们的建议以及权衡。我们将介绍每种设计方法来使用秘密并描述
    Vault 的实现。
- en: This approach runs an initContainer and/or sidecar container to communicate
    with an external secret store. Typically, secrets are injected into the Pod’s
    filesystem, making them available to all containers running in a Pod. We highly
    recommend this approach when possible. The major benefit is that it decouples
    the secret store entirely from the application. However, this does make the platform
    more complex, as facilitating secret injection is now an offering of the Kubernetes-based
    platform.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当可能时，此方法运行一个 initContainer 和/或 sidecar 容器与外部秘密存储通信。通常，秘密被注入到 Pod 的文件系统中，使其对所有运行在
    Pod 中的容器可用。我们强烈推荐此方法。其主要优点是完全将秘密存储与应用程序解耦。但是，这确实使平台更复杂，因为现在 Kubernetes 平台的服务之一是促进秘密注入。
- en: Vault’s implementation of this model uses a MutatingWebhook pointed at a vault-agent-injector.
    As Pods are created, based on annotations, the vault-agent-injector adds an initContainer
    (used for retrieval of the initial secret) and a sidecar container to keep secrets
    updated, if needed. [Figure 7-6](#sidecar_injection_architecture_along_with_my_app)
    demonstrates this flow of interaction between the Pod and Vault.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 实现这一模型的方式是使用指向 vault-agent-injector 的 MutatingWebhook。随着 Pod 的创建，基于注释，vault-agent-injector
    添加一个 initContainer（用于检索初始秘密）和一个 sidecar 容器以保持必要时更新的秘密。[图 7-6](#sidecar_injection_architecture_along_with_my_app)
    展示了 Pod 和 Vault 之间交互流的过程。
- en: '![prku 0706](assets/prku_0706.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0706](assets/prku_0706.png)'
- en: Figure 7-6\. Sidecar injection architecture. Along with my-app-container, all
    Vault Pods are run as sidecars.
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. Sidecar 注入架构。除了 my-app-container，所有 Vault Pod 都作为 sidecar 运行。
- en: 'The configuration of the MutatingWebhook that will inject these vault-specific
    containers is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 将注入这些特定于 vault 的容器的 MutatingWebhook 的配置如下所示：
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The MutatingWebhook is invoked on every Pod CREATE or UPDATE event. While evaluation
    will occur on every Pod, not every Pod will be mutated, or injected with a vault-agent.
    The vault-agent-injector is looking for two annotations in every Pod spec:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: MutatingWebhook 在每个 Pod 创建或更新事件时被调用。虽然每个 Pod 都会进行评估，但并不是每个 Pod 都会被改变或者注入 vault-agent。vault-agent-injector
    在每个 Pod 规范中寻找两个注释：
- en: '`vault.hashicorp.com/agent-inject: "true"`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`vault.hashicorp.com/agent-inject: "true"`'
- en: Instructs the injector to include a vault-agent initContainer, which retrieves
    secrets and writes them to the Pod’s filesystem, prior to other containers starting.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 指示注入器包含一个vault-agent initContainer，该容器检索秘密并将其写入Pod的文件系统，以在其他容器启动之前完成。
- en: '`vault.hashicorp.com/agent-inject-status: "update"`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`vault.hashicorp.com/agent-inject-status: "update"`'
- en: Instructs the injector to include a vault-agent sidecar, which runs alongside
    the workload. It will update the secret, should it change in Vault. The initContainer
    still runs in this mode. This parameter is optional and when it is not included,
    the sidecar is not added.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 指示注入器包含一个运行在工作负载旁边的vault-agent sidecar。它将在Vault中的秘密更改时更新该秘密。此模式下仍然运行initContainer。此参数是可选的，当不包括时，不会添加sidecar。
- en: 'When the vault-agent-injector does a mutation based on `vault.hashicorp.com/agent-inject:
    "true"`, the following is added:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '当vault-agent-injector根据`vault.hashicorp.com/agent-inject: "true"`进行突变时，将添加以下内容：'
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the vault-agent-injector sees the annotation `vault.hashicorp.com/agent-inject-status:
    "update"`, the following is added:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '当vault-agent-injector看到注解`vault.hashicorp.com/agent-inject-status: "update"`时，将添加以下内容：'
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'With the agents present, they will retrieve and download secrets based on the
    Pod annotations, such as the following annotation that requests a database secret
    from Vault:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 存在代理后，它们将基于Pod的注解检索和下载秘密，例如请求从Vault获取数据库秘密的以下注解：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By default, the secret value will be persisted as if a Go map was printed out.
    Syntactically, it appears as follows. All secrets are put into */vault/secrets*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，秘密值将被持久化，就像打印出Go map一样。从语法上看，它如下所示。所有秘密都放在*/vault/secrets*中：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To ensure that formatting of a secret is optimal for consumption, Vault supports
    adding templates into the annotation of Pods. This uses standard Go templating.
    For example, to create a JDBC connection string, the following template can be
    applied to a secret named `creds`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保秘密的格式对使用最佳，Vault支持将模板添加到Pod的注解中。这使用了标准的Go模板。例如，要创建一个JDBC连接字符串，可以将以下模板应用于名为`creds`的秘密：
- en: '[PRE22]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A primary area of complexity in this model is authentication and authorization
    of the requesting Pod. Vault provides several [authentication methods](https://www.vaultproject.io/docs/auth).
    When running Vault within Kubernetes and especially in this sidecar injection
    model, you may wish to set up Vault to authenticate against Kubernetes so that
    Pods can provide their existing Service Account tokens as identity. Setting up
    this authentication mechanism appears as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模型中的主要复杂性区域是请求Pod的身份验证和授权。Vault提供了多种[认证方法](https://www.vaultproject.io/docs/auth)。在Kubernetes中运行Vault，特别是在此sidecar注入模型中，您可能希望设置Vault针对Kubernetes进行身份验证，以便Pod可以将其现有的服务账户令牌作为身份提供。设置此身份验证机制如下所示：
- en: '[PRE23]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_secret_management_CO3-1)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secret_management_CO3-1)'
- en: This environment variable should be present in the Vault Pod by default.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此环境变量默认应出现在Vault Pod中。
- en: '[![2](assets/2.png)](#co_secret_management_CO3-2)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secret_management_CO3-2)'
- en: Location of this Pod’s Service Account token, used to auth against the Kubernetes
    API server when performing TokenReview requests.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此Pod的服务账户令牌位置，用于对抗Kubernetes API服务器进行TokenReview请求时进行身份验证。
- en: 'When requests for secrets enter Vault, the requester’s Service Account can
    then be validated by Vault. Vault does this by communicating through the Kubernetes
    TokenReview API to validate the identity of the requester. Assuming the identity
    is validated, Vault must then determine whether the Service Account is authorized
    to access the secret. These authorization policies and bindings between Service
    Accounts and policies must be configured and maintained within Vault. In Vault,
    a policy is written as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当秘密请求进入Vault时，Vault可以通过与Kubernetes TokenReview API通信来验证请求者的身份。假设身份已验证，Vault接着必须确定服务账户是否被授权访问秘密。必须在Vault中配置和维护这些授权策略和服务账户与策略之间的绑定。在Vault中，策略编写如下：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This has created a policy in Vault referred to as `team-a`, which provides
    read access to all the secrets within *secret/data/team-a/*:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这在Vault中创建了一个名为`team-a`的策略，它提供对*secret/data/team-a/*中所有秘密的读取访问权限：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last step is to associate the requester’s Service Account with the policy
    so Vault can authorize access:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将请求者的服务账户与策略关联，以便Vault授权访问：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_secret_management_CO4-1)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secret_management_CO4-1)'
- en: Name of the requester’s Service Account.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 请求者的服务账户名称。
- en: '[![2](assets/2.png)](#co_secret_management_CO4-2)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secret_management_CO4-2)'
- en: Namespace of the requester.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请求者的命名空间。
- en: '[![3](assets/3.png)](#co_secret_management_CO4-3)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secret_management_CO4-3)'
- en: Binding to associate this account to one or many policies.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定以将此帐户关联到一个或多个策略。
- en: '[![4](assets/4.png)](#co_secret_management_CO4-4)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_secret_management_CO4-4)'
- en: Duration the vault-specific authorization token should live for. Once expired,
    authn/authz is performed again.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Vault 特定授权令牌应该存活多久。一旦过期，将再次执行认证/授权。
- en: The vault-specific process we have explored so far likely applies to any variety
    of external secret management stores. You’ll be faced with some amount of overhead
    regarding integration of identity and authorization around secret access when
    dealing with systems beyond Kubernetes core.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今探索的 Vault 特定过程可能适用于任何种类的外部秘密管理存储。在处理超出 Kubernetes 核心的系统时，你将面临一定程度的身份和授权集成开销。
- en: CSI Integration
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSI 集成
- en: A newer approach to secret store integration is to leverage the secrets-store-csi-driver.
    At the time of this writing, this is a Kubernetes subproject within kubernetes-sigs.
    This approach enables integration with secret management systems at a lower level.
    Namely, it enables Pods to gain access to externally hosted secrets without running
    a sidecar or initContainer to inject secret data into the Pod. The result is secret
    interaction feeling more like a platform service and less like something applications
    need to integrate with. The secrets-store-csi-driver runs a driver Pod (as a DaemonSet)
    on every host, simliar to how you’d expect a CSI driver to work with a storage
    provider.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密存储集成的较新方法是利用 secrets-store-csi-driver。在撰写本文时，这是 kubernetes-sigs 内的 Kubernetes
    子项目。此方法使得可以在更低级别上集成秘密管理系统。具体来说，它使得 Pod 能够访问外部托管的秘密，而无需运行 sidecar 或 initContainer
    将秘密数据注入到 Pod 中。结果是秘密交互更像是一个平台服务，而不是应用程序需要集成的东西。secrets-store-csi-driver 在每个主机上运行一个驱动
    Pod（作为 DaemonSet），类似于你期望 CSI 驱动程序与存储提供程序合作的方式。
- en: The driver then relies on a provider that is responsible for secret lookup in
    the external system. In the case of Vault, this would involve installing the `vault-provider`
    binary on every host. The binary location is expected to be where the driver’s
    `provider-dir` mount is set. This binary may preexist on the host or, most commonly,
    it is installed via a DaemonSet-like process. The overall architecture would appear
    close to what’s shown in [Figure 7-7](#CSI_driver).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，驱动程序依赖于负责在外部系统中查找秘密的提供程序。在 Vault 的情况下，这将涉及在每台主机上安装 `vault-provider` 二进制文件。二进制文件的位置应该是驱动程序的
    `provider-dir` 挂载设置的地方。这个二进制文件可能已经存在于主机上，或者通常通过类似于 DaemonSet 的进程进行安装。整体架构看起来与
    [图 7-7](#CSI_driver) 所示的接近。
- en: '![prku 0707](assets/prku_0707.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0707](assets/prku_0707.png)'
- en: Figure 7-7\. CSI driver interaction flow.
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 第 7-7 图。CSI 驱动程序的交互流程。
- en: 'This is a fairly new approach that seems promising based on its UX and ability
    to abstract secret providers. However, it does pose additional challenges. For
    example, how is identity handled when the Pod itself is not requesting the secret?
    This is something the driver and/or provider must figure out since they’re making
    requests on behalf of the Pod. For now, we can look at the primary API, which
    includes the SecretProviderClass. To interact with an external system such as
    Vault, the SecretProviderClass would look as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基于其用户体验和抽象秘密提供程序能力而显有前景的相对较新的方法。然而，它确实带来了额外的挑战。例如，当 Pod 本身没有请求秘密时，身份如何处理？这是驱动程序和/或提供程序必须解决的问题，因为它们代表
    Pod 发出请求。目前，我们可以查看主要的 API，其中包括 SecretProviderClass。要与 Vault 等外部系统进行交互，SecretProviderClass
    将如下所示：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_secret_management_CO5-1)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_secret_management_CO5-1)'
- en: This is the location of Vault and would have the Service name (`vault`) followed
    by the Namespace `secret-store`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Vault 的位置，应该是服务名称 (`vault`) 后跟命名空间 `secret-store`。
- en: '[![2](assets/2.png)](#co_secret_management_CO5-2)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_secret_management_CO5-2)'
- en: This is the path in Vault the Key/Value object was written to.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Vault 中写入 Key/Value 对象的路径。
- en: '[![3](assets/3.png)](#co_secret_management_CO5-3)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_secret_management_CO5-3)'
- en: This is the actual object to lookup in `team-a`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 `team-a` 中查找的实际对象。
- en: 'With the SecretProviderClass in place, a Pod can consume and reference this
    as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 有了 SecretProviderClass，Pod 可以如下消费和引用此内容：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When this Pod starts, the driver and provider attempt to retrieve the secret
    data. The secret data will appear in a volume mount as any Kubernetes secret would,
    assuming authentication and authorization to the external provider is successful.
    From the driver Pod on the node, you can examine the logs to see the command sent
    to the provider:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当此 Pod 启动时，驱动程序和提供程序尝试检索秘密数据。假设对外部提供者的身份验证和授权成功，秘密数据将以卷挂载的形式出现，就像任何 Kubernetes
    密钥一样。从节点上的驱动 Pod，您可以查看日志，看到发送给提供程序的命令：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In summary, secret-store-csi-drive is an approach worth keeping an eye on. Over
    time, if the project stabilizes and providers begin to mature, we could see the
    approach becoming common for those building application platforms on top of Kubernetes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，secret-store-csi-driver 是值得关注的一种方法。随着项目的稳定和提供者开始成熟，随着时间的推移，我们可能会看到这种方法在构建基于
    Kubernetes 的应用程序平台时变得普遍起来。
- en: Secrets in the Declarative World
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在声明式世界中的 Secrets
- en: A common aspiration of application deployments, continuous integration, and
    continuous delivery is to move purely into a declarative model. This is the same
    model used in Kubernetes where you declare a desired state and over time controllers
    work to reconcile the desired state with current state. For application developers
    and DevOps teams, these aspirations commonly surface in a pattern called GitOps.
    A central tenet of most GitOps approaches is to use one or many git repositories
    as the source of truth for workloads. When a commit is seen on some branch or
    tag, it can be picked up by build and deploy processes, often inside a cluster.
    This eventually aims to make the available workload capable of receiving traffic.
    Models such as GitOps are covered at greater length in [Chapter 15](ch15.html#chapter15).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 应用部署、持续集成和持续交付的共同愿景是纯粹地转向声明式模型。这与 Kubernetes 中使用的模型相同，在这里你声明一个期望的状态，随着时间推移，控制器会努力协调期望状态与当前状态。对于应用开发者和
    DevOps 团队来说，这些愿景通常表现为一个称为 GitOps 的模式。大多数 GitOps 方法的核心是将一个或多个 git 仓库作为工作负载的真实来源。当在某个分支或标签上看到提交时，它可以被构建和部署流程接收，通常在集群内完成。最终目标是使可用的工作负载能够接收流量。类似
    GitOps 的模型在[第15章](ch15.html#chapter15)中有更详尽的讨论。
- en: When taking a purist-declarative approach, secret data creates a unique challenge.
    Sure you can commit your configurations alongside your code, but what about the
    credentials and keys used by your application? We have a feeling an API key showing
    up in a commit might make some people unhappy. There are some ways around this.
    One is, of course, to keep secret data outside of this declarative model and repent
    your sins toward the GitOps gods. Another is to consider “sealing” your secret
    data, in a way that accessing the data exposes nothing about the meaningful value,
    which is what we’ll explore in the next section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当采用纯粹声明式方法时，秘密数据会带来独特的挑战。当然，您可以将配置与代码一起提交，但是应用程序使用的凭据和密钥怎么办？我们觉得在提交中出现 API 密钥可能会让某些人感到不安。有一些解决方法。当然，其中之一是将秘密数据保留在声明式模型之外，并且对
    GitOps 的神灵忏悔你的罪行。另一种方法是考虑“封存”您的秘密数据，以一种访问数据不会暴露有意义值的方式，这将在下一节中探讨。
- en: Sealing Secrets
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封 Secrets
- en: How can we truly seal a secret? The concept is nothing new. Using asymmetric
    cryptography, we can ensure a way to encrypt secrets, commit them to places, and
    not worry about anyone exposing the data. In this model, we have an encryption
    key (typically public) and a decryption key (typically private). The idea is that
    any secret created by the encryption key cannot have its value compromised without
    the private key being compromised. Of course, we need to ensure many things to
    stay safe in this model, such as choose a cipher we can trust, ensure the private
    key is *always* safe, and establish both encryption key and secret data rotation
    policies. A model we’ll explore in the coming sections is how this looks when
    a private key is generated in the cluster, and developers can be distributed their
    own encryption key that they can use on their secret data.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何真正地封存一个秘密？这个概念并不新鲜。使用非对称加密，我们可以确保一种方法来加密秘密，将其提交到指定位置，而不必担心有人暴露数据。在这种模型中，我们有一个加密密钥（通常是公钥）和一个解密密钥（通常是私钥）。其思想是，由加密密钥创建的任何秘密，如果没有私钥被泄露，其值就无法被破解。当然，我们需要确保在这种模型中安全的许多事情，例如选择一个可信赖的密码算法，确保私钥始终安全，并建立加密密钥和秘密数据轮换策略。我们将在即将到来的章节中探讨的模型是，在集群中生成私钥时，开发者可以分发他们自己的加密密钥，用于他们的秘密数据。
- en: Sealed Secrets Controller
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封的 Secrets 控制器
- en: Bitnami-labs/sealed-secrets is a commonly used, open source project for achieving
    what has been described. However, should you choose alternative tooling or build
    something yourself, the key concepts are unlikely to change drastically.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Bitnami-labs/sealed-secrets 是一个常用的开源项目，用于实现上述描述。然而，如果您选择替代工具或自行构建，关键概念不太可能发生重大变化。
- en: 'The key component to this project is a sealed-secret-controller that runs inside
    the cluster. By default, it generates the keys needed to perform encryption and
    decryption. On the client side, developers use a command-line utility called kubeseal.
    Being that we’re using asymmetric encryption, kubeseal needs to know only about
    the public key (for encryption). Once developers encrypt their data using it,
    they won’t even be able to decrypt the values directly. To get started, we first
    deploy the controller to the cluster:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的关键组件是运行在集群内部的 sealed-secret-controller。默认情况下，它会生成执行加密和解密所需的密钥。在客户端，开发人员使用名为
    kubeseal 的命令行实用程序。由于我们使用的是非对称加密，kubeseal 只需知道公钥（用于加密）。一旦开发人员使用它加密其数据，他们甚至无法直接解密这些值。为了开始工作，我们首先将控制器部署到集群中：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By default, the controller will create encryption and decryption keys for us.
    However, it is possible to bring your own certificates. The public (cert) and
    private (key) are stored in a Kubernetes Secret under *kube-system/sealed-secret-key*.
    The next step is allowing developers to retrieve the encryption key so they can
    get to work. This should *not* be done by accessing the Kubernetes Secret directly.
    Instead, the controller exposes an endpoint that can be used to retrieve the encryption
    key. How you access this service is up to you, but clients need to be able to
    call it using the following command, which has its flow detailed in [Figure 7-8](#sealed_secret):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，控制器将为我们创建加密和解密密钥。但是，也可以使用自己的证书。公（证书）和私（键）存储在 *kube-system/sealed-secret-key*
    下的 Kubernetes Secret 中。下一步是允许开发人员检索加密密钥，以便他们开始工作。这不应通过直接访问 Kubernetes Secret 来完成。相反，控制器公开了一个端点，可以用于检索加密密钥。如何访问此服务取决于您，但客户端需要能够使用以下命令调用它，其流程在[图
    7-8](#sealed_secret)中有详细介绍：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![prku 0708](assets/prku_0708.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0708](assets/prku_0708.png)'
- en: Figure 7-8\. Sealed-secret-controller architecture.
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-8\. Sealed-secret-controller 架构。
- en: Once the public key is loaded in kubeseal, you can generate SealedSecret CRDs
    that contain (encrypted) secret data. These CRDs are stored in etcd. The sealed-secret-controller
    makes the secrets available using standard Kubernetes Secrets. To ensure SealedSecret
    data is converted to a Secret correctly, you can specify templates in the SealedSecret
    object.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 kubeseal 中加载了公钥，就可以生成包含（加密的）秘密数据的 SealedSecret CRD。这些 CRD 存储在 etcd 中。sealed-secret-controller
    通过标准的 Kubernetes Secrets 使秘密数据可用。为确保 SealedSecret 数据正确转换为 Secret，您可以在 SealedSecret
    对象中指定模板。
- en: 'You can start with a Kubernetes Secret, like any other:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 Kubernetes Secret 开始，就像任何其他的一样：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To “seal” the secret, you can run kubeseal against it and generate an encrypted
    output in JSON:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要“密封”秘密，您可以对其运行 kubeseal，并生成 JSON 中的加密输出：
- en: '[PRE33]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding SealedSecret object can be placed anywhere. As long as the sealing
    key, held by the sealed-secret-controller is not compromised, the data will be
    safe. Rotation is especially important in this model, which is covered in a subsequent
    section.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 SealedSecret 对象可以放置在任何地方。只要 sealed-secret-controller 持有的密封密钥未被泄露，数据就是安全的。在这个模型中，特别重要的是轮换，这在后续部分中有详细介绍。
- en: Once applied, the flow and storage look as described in [Figure 7-9](#sealed_secret_controller).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用，流程和存储看起来如[图 7-9](#sealed_secret_controller)所描述。
- en: 'The Secret object made by the sealed-secret-controller is owned by its corresponding
    SealedSecret CRD:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由 sealed-secret-controller 制作的 Secret 对象归其相应的 SealedSecret CRD 所有：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![prku 0709](assets/prku_0709.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0709](assets/prku_0709.png)'
- en: Figure 7-9\. Sealed-secret-controller interaction around managing sealed and
    unsealed secrets.
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-9\. 围绕管理密封和非密封秘密的 Sealed-secret-controller 交互。
- en: This means that if the SealedSecret is deleted, its corresponding Secret object
    will be garbage collected.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果删除 SealedSecret，则其对应的 Secret 对象将被垃圾收集。
- en: Key Renewal
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密钥更新
- en: If the sealed-secret private key is leaked (perhaps due to RBAC misconfiguration),
    every secret should be considered compromised. It’s especially important that
    the sealing key is renewed on an interval and that you understand the scope of
    “renewal.” The default behavior is for this key to be renewed every 30 days. It
    does not replace the existing keys; instead, it is appended to the existing list
    of keys capable of unsealing the data. However, the new key is used for all new
    encryption activity. Most importantly, existing sealed secrets are not re-encrypted.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果密封的密钥泄漏（可能是由于 RBAC 配置错误），则应该视每个密钥为已泄漏。特别重要的是要定期更新密封密钥，并理解“更新”的范围。默认行为是每 30
    天更新一次此密钥。它不会替换现有的密钥，而是追加到能够解封数据的现有密钥列表中。然而，新密钥用于所有新的加密活动。最重要的是，现有的密封密钥不会重新加密。
- en: 'In the event of a leaked key, you should:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生密钥泄漏事件，您应该：
- en: Immediately rotate your encryption key.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即旋转您的加密密钥。
- en: Rotate all existing secrets.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转所有现有的秘密。
- en: Remember that just re-encrypting isn’t good enough. For example, someone could
    easily go into git history, find the old encrypted asset, and use the compromised
    key on it. Generally speaking, you should have rotation and renewal strategies
    for passwords and keys, respectively.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，仅重新加密是不够的。例如，某人可以轻松地进入 git 历史记录，找到旧的加密资产，并使用已泄露的密钥对其进行操作。一般来说，您应该有密码和密钥的旋转和更新策略。
- en: SealedSecrets uses a trick where the Namespace is used during encryption. This
    provides an isolation mechanic where a SealedSecret truly belongs to the Namespace
    it was created in and cannot just be moved between them. Generally, this default
    behavior is the most secure and should just be left as is. However, it does support
    configurable access policies, which are covered in the sealed-secrets documentation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: SealedSecrets 使用一个技巧，在加密过程中使用 Namespace。这提供了一种隔离机制，使得 SealedSecret 真正属于其创建的
    Namespace，而不能仅仅在它们之间移动。一般来说，这种默认行为是最安全的，应该保持不变。然而，它确实支持可配置的访问策略，这在 sealed-secrets
    文档中有所覆盖。
- en: Multicluster Models
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多集群模型
- en: Another key consideration for sealed-secret models is deployment topologies
    involving many clusters. Many of these topologies treat clusters ephemerally.
    In cases such as these, it may be harder to run sealed-secret-style controllers
    because—unless you are sharing private keys among them all—you now need to worry
    about having unique keys for each cluster. Additionally, the point of interaction
    a developer has to get the encryption key (as described in previous sections)
    goes from one cluster to many. While by no means an impossible problem to solve,
    it is worth considering.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 封密模型的另一个关键考虑因素是涉及多个集群的部署拓扑。这些拓扑中的许多将集群视为临时的。在这些情况下，可能更难以运行封密样式的控制器，因为——除非您在它们之间共享私钥——否则现在您需要担心为每个集群使用唯一的密钥。此外，开发人员获取加密密钥的交互点（如前述章节所述）从一个集群变为多个集群。虽然这并不是一个不可能解决的问题，但值得考虑。
- en: Best Practices for Secrets
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密的最佳实践
- en: Application consumption of secrets is highly dependent on the language and frameworks
    at play. While variance is high, there are general best practices we recommend
    and encourage application developers to consider.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序对秘密的消耗高度依赖于所涉及的语言和框架。尽管差异很大，但我们推荐通用的最佳实践，并鼓励应用程序开发人员考虑。
- en: Always Audit Secret Interaction
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 始终审核秘密交互
- en: A Kubernetes cluster should be configured with auditing enabled. Auditing allows
    you to specify the events that occur around specific resources. This will tell
    you when and by whom a resource was interacted with. For mutations, it will also
    detail what changed. Auditing secret events is critical in reacting to access
    issues. For details about auditing, see the cluster audit documentation.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群应配置为启用审核。审核允许您指定围绕特定资源发生的事件。这将告诉您资源何时以及由谁进行了交互。对于变更，它还将详细说明发生了什么变化。审计秘密事件对于响应访问问题至关重要。有关审核的详细信息，请参阅集群审核文档。
- en: Don’t Leak Secrets
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要泄漏秘密
- en: While leaking secrets is never desirable, in multitenant Kubernetes environments
    it’s important to consider how secrets can be leaked. A common occurrence is to
    accidentally log a secret. For example, we have seen this a few times when platform
    engineers build operators (covered in [Chapter 11](ch11.html#building_platform_services)).
    These operators often deal with secrets for the systems they are managing and
    potentially external systems they need to connect to. During the development phase,
    it can be common to log this secret data for the sake of debugging. Logs go to
    stdout/stderr and are, in many Kubernetes-based platforms, forwarded to a log
    analysis platform. This means the secret may pass in plain text through many environments
    and systems.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然泄漏机密从未是理想的情况，但在多租户 Kubernetes 环境中，重要的是考虑如何可能泄漏机密。一个常见的情况是意外记录密钥。例如，我们曾在平台工程师构建操作者时几次看到这种情况（在
    [第 11 章](ch11.html#building_platform_services) 中有介绍）。这些操作者通常处理他们正在管理的系统以及可能需要连接的外部系统的密钥。在开发阶段，为了调试的目的，记录这些秘密数据是很常见的。日志输出到
    stdout/stderr，并且在许多基于 Kubernetes 的平台上，会转发到日志分析平台。这意味着秘密可能以明文形式通过许多环境和系统传递。
- en: Kubernetes is primarily a declarative system. Developers write manifests that
    can easily contain secret data, especially when testing. Developers should work
    with caution to ensure that secrets used while testing don’t get committed into
    source control repositories.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 主要是一个声明式系统。开发人员编写的清单文件很容易包含秘密数据，特别是在测试时。开发人员应谨慎操作，确保在测试期间使用的秘密不会提交到源代码版本库中。
- en: Prefer Volumes Over Environment Variables
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更倾向于使用卷而不是环境变量
- en: The most common ways to access secrets provided by Kubernetes is to propagate
    the value into an environment variable or volumes. For most applications, volumes
    should be preferred. Environment variables can have a higher chance of being leaked
    through various means—for example, an echo command performed while testing or
    a framework automatically dumping environment variables on startup or during a
    crash. This doesn’t mean these concerns are inherently solved for with volumes!
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 Kubernetes 提供的秘密数据的最常见方法是将值传播到环境变量或卷中。对于大多数应用程序，应该更倾向于使用卷。环境变量通过各种方式泄漏的可能性较高，例如在测试期间执行的
    echo 命令，或者框架在启动或崩溃期间自动转储环境变量。这并不意味着卷能完全解决这些问题！
- en: Security aside, the key benefit to app developers is that when secrets change,
    volumes are automatically updated; this will enable hot-reloading of secrets such
    as tokens. For a secret change to take place with environment variables, Pods
    must be restarted.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安全性外，对于应用程序开发人员的关键好处在于，当密钥发生更改时，卷会自动更新；这将支持如令牌等秘密的热重载。要使环境变量发生密钥更改，必须重新启动
    Pod。
- en: Make Secret Store Providers Unknown to Your Application
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使秘密存储提供者对您的应用程序保持未知
- en: There are several approaches an application can take to retrieve and consume
    its required secrets. These can range from calling a secret store within business
    logic to expecting an environment variable to be set on startup. Following the
    philosophy of separation of concerns, we recommend implementing secret consumption
    in a way that whether Kubernetes, Vault, or other providers are managing the secret
    does not matter to the application. Achieving this makes your application portable
    and platform agnostic, and it reduces the complexity of your app’s interaction.
    Complexity is reduced because for an application to retrieve secrets from a provider
    it needs to both understand how to talk to the provider and be able to authenticate
    for communication with the provider.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以采取几种方法来检索和使用所需的机密信息。这些方法可以从在业务逻辑中调用密钥存储，到期望在启动时设置环境变量。遵循关注分离的哲学，我们建议以一种方式实现机密信息的消费，使得应用程序不必关心是
    Kubernetes、Vault 还是其他提供者在管理密钥。这样做可以使您的应用程序具备可移植性和平台无关性，并减少应用程序交互的复杂性。复杂性减少是因为应用程序要从提供者那里获取密钥，它需要理解如何与提供者通信，并能够进行身份验证以进行通信。
- en: To achieve this provider-agnostic implementation, applications should prefer
    loading secrets from environment variables or volumes. As we said earlier, volumes
    are the most ideal. In this model, an application will assume the presence of
    secrets in one or many volumes. Since volumes can be updated dynamically (without
    Pod restart) the application can watch the filesystem if a hot-reload of secrets
    is desired. By consuming from the container’s local filesystem, it does not matter
    whether the backing store is Kubernetes or otherwise.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种供应商无关的实现，应用程序应优先从环境变量或卷中加载密钥。正如我们之前所说，卷是最理想的选择。在这种模型中，应用程序将假定在一个或多个卷中存在密钥。由于卷可以动态更新（无需
    Pod 重启），如果需要密钥的热重载，应用程序可以监视文件系统。通过从容器的本地文件系统消费，无论后备存储是 Kubernetes 还是其他方式，都没有关系。
- en: Some application frameworks, such as Spring, include libraries to communicate
    directly to the API server and auto-inject secrets and configuration. While these
    utilities are convenient, consider the points just discussed to determine what
    approaches hold the most value to your application.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序框架（如 Spring）包括库，用于直接与 API 服务器通信并自动注入密钥和配置。尽管这些工具很方便，但考虑刚刚讨论的要点，以确定哪些方法对您的应用程序最有价值。
- en: Summary
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we’ve explored the Kubernetes Secret API, ways to interact with
    secrets, means of storing secrets, how to seal secrets, and some best practices.
    With this knowledge, it’s important we consider the amount of depth we’re interested
    in protecting, and with that, determining how to prioritize solving for each layer.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Kubernetes Secret API、与密钥交互的方式、存储密钥的方法、如何密封密钥以及一些最佳实践。有了这些知识，重要的是我们考虑我们有兴趣保护的深度，并据此确定如何优先解决每一层的问题。
