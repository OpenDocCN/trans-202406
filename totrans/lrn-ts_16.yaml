- en: Chapter 13\. Configuration Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compiler options:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Types and modules and oh my!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`tsc` your way.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: TypeScript is highly configurable and made to adapt to all common JavaScript
    usage patterns. It can work for projects ranging from legacy browser code to the
    most modern server environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much of TypeScript’s configurability comes from its cornucopia of over 100
    configuration options that can be provided via either:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line (CLI) flags passed to `tsc`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “TSConfig” TypeScript configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter is not intended as a full reference for all TypeScript configuration
    options. Instead, I’d suggest treating this chapter as a tour of the most common
    options you’ll find yourself using. I’ve included just the ones that tend to be
    more useful and widely used for most TypeScript project setups. See [aka.ms/tsc](https://aka.ms/tsc)
    for a full reference on each of these options and more.
  prefs: []
  type: TYPE_NORMAL
- en: tsc Options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in [Chapter 1, “From JavaScript to TypeScript”](ch01.xhtml#from_javascript_to_typescript),
    you used `tsc index.ts` to compile an *index.ts* file. The `tsc` command can take
    in most of TypeScript’s configuration options as `--` flags.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to run `tsc` on an *index.ts* file and skip emitting an *index.js*
    file (so, only run type checking), pass the `--noEmit` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You can run `tsc --help` to get a list of commonly used CLI flags. The full
    list of `tsc` configuration options from [aka.ms/tsc](https://aka.ms/tsc) is viewable
    with `tsc --all`.
  prefs: []
  type: TYPE_NORMAL
- en: Pretty Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `tsc` CLI has the ability to output in a “pretty” mode: stylized with colors
    and spacing to make them easier to read. It defaults to pretty mode if it detects
    that the output terminal supports colorful text.'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of what `tsc` looks like printing two type errors from a file
    ([Figure 13-1](#tsc_pretty_errors)).
  prefs: []
  type: TYPE_NORMAL
- en: '![tsc reporting two errors with blue file names, yellow line and column numbers,
    and red squigglies.](Images/lets_1301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. `tsc` reporting two errors with blue file names, yellow line and
    column numbers, and red squigglies
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’d prefer CLI output that is more condensed and/or doesn’t have different
    colors, you can explicitly provide `--pretty false` to tell TypeScript to use
    a more terse, uncolored format ([Figure 13-2](#tsc_pretty_false_errors)).
  prefs: []
  type: TYPE_NORMAL
- en: '![tsc reporting two errors in plain text.](Images/lets_1302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-2\. `tsc` reporting two errors in plain text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Watch Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My favorite way to use the `tsc` CLI is with its `-w`/`--watch` mode. Instead
    of exiting once completed, watch mode will keep TypeScript running indefinitely
    and continuously updates your terminal with a real-time list of all the errors
    it sees.
  prefs: []
  type: TYPE_NORMAL
- en: Running in watch mode on a file that contains two errors is shown in [Figure 13-3](#tsc_watch_errors).
  prefs: []
  type: TYPE_NORMAL
- en: '![tsc reporting two errors in watch mode.](Images/lets_1303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-3\. `tsc` reporting two errors in watch mode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 13-4](#tsc_watch_fixed) shows `tsc` updating console output to indicate
    that the file was changed in a way to fix all errors.'
  prefs: []
  type: TYPE_NORMAL
- en: '![tsc reporting no errors in watch mode.](Images/lets_1304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-4\. `tsc` reporting no errors in watch mode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Watch mode is particularly useful when you’re working on large changes such
    as refactors across many files. You can use TypeScript’s type errors as a checklist
    of sorts to see what still needs to be cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: TSConfig Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of always providing all file names and configuration options to `tsc`,
    most configuration options may be specified in a *tsconfig.json* (“TSConfig”)
    file in a directory.
  prefs: []
  type: TYPE_NORMAL
- en: The existence of a *tsconfig.json* indicates that the directory is the root
    of a TypeScript project. Running `tsc` in a directory will read in any configuration
    options in that *tsconfig.json* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass `-p`/`--project` to `tsc` with a path to a directory containing
    a *tsconfig.json* or any file to have `tsc` use that instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: TSConfig files are generally strongly recommended to be used for TypeScript
    projects whenever possible. IDEs such as VS Code will respect their configuration
    when giving you IntelliSense features.
  prefs: []
  type: TYPE_NORMAL
- en: See [aka.ms/tsconfig.json](https://aka.ms/tsconfig.json) for the full list of
    configuration options available in TSConfig files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you don’t set an option in your *tsconfig.json*, don’t worry that TypeScript’s
    default setting for it may change and interfere with your project’s compilation
    settings. This almost never happens and if it did, it would require a major version
    update to TypeScript and be called out in the release notes.
  prefs: []
  type: TYPE_NORMAL
- en: tsc --init
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tsc` command line includes an `--init` command to create a new *tsconfig.json*
    file. That newly created TSConfig file will contain a link to the configuration
    docs as well as most of the allowed TypeScript configuration options with one-line
    comments briefly describing their use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'will generate a fully commented *tsconfig.json* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I recommend using `tsc --init` to create your configuration file on your first
    few TypeScript projects. Its default values are applicable to most projects, and
    its documentation comments are helpful in understanding them.
  prefs: []
  type: TYPE_NORMAL
- en: CLI Versus Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looking through the TSConfig file created by `tsc --init`, you may notice that
    configuration options in that file are within a `"compilerOptions"` object. Most
    options available in both the CLI and in TSConfig files fall into one of two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiler
  prefs: []
  type: TYPE_NORMAL
- en: How each included file is compiled and/or type checked by TypeScript
  prefs: []
  type: TYPE_NORMAL
- en: File
  prefs: []
  type: TYPE_NORMAL
- en: Which files will or will not have TypeScript run on them
  prefs: []
  type: TYPE_NORMAL
- en: Other settings that we’ll talk about after those two categories, such as project
    references, generally are only available in TSConfig files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a setting is provided to the `tsc` CLI, such as a one-off change for a CI
    or production build, it will generally override any value specified in a TSConfig
    file. Because IDEs generally read from the *tsconfig.json* in a directory for
    TypeScript settings, it’s recommended to put most configuration options in a *tsconfig.json*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: File Inclusions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, `tsc` will run on all nonhidden *.ts* files (those whose names do
    not start with a `.`) in the current directory and any child directories, ignoring
    hidden directories and directories named *node_modules*. TypeScript configurations
    can change that list of files to run on.
  prefs: []
  type: TYPE_NORMAL
- en: include
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common way to include files is with a top-level `"include"` property
    in a *tsconfig.json*. It allows an array of strings that describes what directories
    and/or files to include in TypeScript compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this configuration file recursively includes all TypeScript source
    files in a *src/* directory relative to the *tsconfig.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Glob wildcards are allowed in `include` strings for more fine-grained control
    of files to include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*` matches zero or more characters (excluding directory separators).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?` matches any one character (excluding directory separators).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**/` matches any directory nested to any levels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This configuration file allows only *.d.ts* files nested in a *typings/* directory
    and *src/* files with at least two characters in their name before an extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For most projects, a simple `include` compiler option such as `["src"]` is generally
    sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: exclude
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `include` list of files for a project sometimes includes files not meant
    for compilation by TypeScript. TypeScript allows a TSConfig file to omit paths
    from `include` by specifying them in a top-level `"exclude"` property. Similar
    to `include`, it allows an array of strings that describes what directories and/or
    files to exclude from TypeScript compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following configuration includes all files in *src/* except for those within
    any nested *external/* directory and a *node_modules* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: By default, `exclude` contains `["node_modules", "bower_components", "jspm_packages"]`
    to avoid running the TypeScript compiler on compiled third-party library files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re writing your own `exclude` list, you typically won’t need to re-add
    `"bower_components"` or `"jspm_packages"`. Most JavaScript projects that install
    node modules to a folder within the project only install to `"node_modules"`.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind, `exclude` only acts to remove files from the starting list in
    `include`. TypeScript will run on any file imported by any included file, even
    if the imported file is explicitly listed in `exclude`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript is by default able to read in any file whose extension is *.ts*.
    However, some projects require being able to read in files with different extensions,
    such as JSON modules or JSX syntax for UI libraries such as React.
  prefs: []
  type: TYPE_NORMAL
- en: JSX Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX syntax like `<Component />` is often used in UI libraries such as Preact
    and React. JSX syntax is not technically JavaScript. Like TypeScript’s type definitions,
    it’s an extension to JavaScript syntax that compiles down to regular JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use JSX syntax in a file, you must do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable the `"jsx"` compiler option in your configuration options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name that file with a *.tsx* extension
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jsx
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The value used for the `"jsx"` compiler option determines how TypeScript emits
    JavaScript code for *.tsx* files. Projects generally use one of these three values
    ([Table 13-1](#jsx_compiler_option_inputs_and_outputs)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 13-1\. JSX compiler option inputs and outputs
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Input code | Output code | Output file extension |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| “preserve” | `<div />` | `<div />` | .jsx |'
  prefs: []
  type: TYPE_TB
- en: '| “react” | `<div />` | `React.createElement("div")` | .js |'
  prefs: []
  type: TYPE_TB
- en: '| “react-native” | `<div />` | `<div />` | .js |'
  prefs: []
  type: TYPE_TB
- en: Values for `jsx` may be provided to the `tsc` CLI and/or in a TSConfig file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you’re not directly using TypeScript’s built-in transpiler, which is the
    case when you’re transpiling code with a separate tool such as Babel, you most
    likely can use any of the allowed values for `"jsx"`. Most web apps built on modern
    frameworks such as Next.js or Remix handle React configuration and compiling syntax.
    If you’re using one of those frameworks you probably won’t have to directly configure
    TypeScript’s built-in transpiler.
  prefs: []
  type: TYPE_NORMAL
- en: Generic arrow functions in .tsx files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 10, “Generics”](ch10.xhtml#generics_chapter) mentioned that the syntax
    for generic arrow functions conflicts with JSX syntax. Attempting to write a type
    argument `<T>` for an arrow function in a *.tsx* file will give a syntax error
    for there not being a closing tag for that opening `T` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To work around this syntax ambiguity, you can add an `= unknown` constraint
    to the type argument. Type arguments default to the `unknown` type so this doesn’t
    change code behavior at all. It just indicates to TypeScript to read a type argument,
    not a JSX element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: resolveJsonModule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript will allow reading in *.json* files if the `resolveJsonModule` compiler
    option is set to `true`. When it is, *.json* files may be imported from as if
    they were *.ts* files exporting an object. TypeScript will infer the type of that
    object as if it were a `const` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For JSON files that contain an object, destructuring imports may be used. This
    pair of files defines an `"activist"` string in an *activist.json* file and imports
    it into a *usesActivist.ts* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Default imports may be used as well if the `esModuleInterop` compiler option—covered
    later in this chapter—is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For JSON files that contain other literal types, such as arrays or numbers,
    you’ll have to use the `* as` import syntax. This pair of files defines an array
    of strings in an *activists.json* file that is then imported into a *useActivists.ts*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Emit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the rise of dedicated compiler tools such as Babel has reduced TypeScript’s
    role in some projects to solely type checking, many other projects still rely
    on TypeScript for compiling TypeScript syntax to JavaScript. It’s quite useful
    for projects to be able to take in a single dependency on `typescript` and use
    its `tsc` command to output the equivalent JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: outDir
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, TypeScript places output files alongside their corresponding source
    files. For example, running `tsc` on a directory containing *fruits/apple.ts*
    and *vegetables/zucchini.ts* would result with output files *fruits/apple.js*
    and *vegetables/zucchini.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes it may be preferable to place output files in a different folder.
    Many Node projects, for example, put transformed outputs in a *dist* or *lib*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s `outDir` compiler option allows specifying a different root directory
    for outputs. Output files are kept in the same relative directory structure as
    input files.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, running `tsc --outDir dist` on the previous directory would place
    outputs within a *dist/* folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript calculates the root directory to place output files into by finding
    the longest common subpath of all input files (excluding *.d.ts* declaration files).
    That means that projects that place all input source files in a single directory
    will have that directory treated as the root.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the above example put all inputs in a *src/* directory and
    compiled with `--outDir lib`, *lib/fruits/apple.js* would be created instead of
    *lib/src/fruits/apple.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A `rootDir` compiler option does exist to explicitly specify that root directory,
    but it’s rarely necessary or used with values other than `.` or `src`.
  prefs: []
  type: TYPE_NORMAL
- en: target
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript is able to produce output JavaScript that can run in environments
    as old as ES3 (circa 1999!). Most environments are able to support syntax features
    from much newer versions of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript includes a `target` compiler option to specify how far back in syntax
    support JavaScript code needs to be transpiled. Although `target` defaults to
    `"es3"` for backward compatibility reasons when not specified and `tsc --init`
    defaults to specifying `"es2016"`, it’s generally advisable to use the newest
    JavaScript syntax possible per your target platform(s). Supporting newer JavaScript
    features in older environments necessitates creating more JavaScript code, which
    causes slightly larger file sizes and slightly worse runtime performance.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of 2022, all releases within the last year of browsers serving > 0.1% of
    worldwide users support at least all of ECMAScript 2019 and nearly all of ECMAScript
    2020–2021, while the LTS-supported versions of Node.js support all of ECMAScript
    2021. There’s very little reason not to have a `target` at least as high as `"es2019"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take this TypeScript source containing ES2015 `const`s and ES2020
    `??` nullish coalescing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With `tsc --target es2020` or newer, both `const` and `??` are supported syntax
    features, so TypeScript would only need to remove the `: string | undefined` from
    that snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'With `tsc --target es2015` through `es2019`, the `??` syntax sugar would be
    compiled down to its equivalent in older versions of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With `tsc --target es3` or `es5`, the `const` would additionally need to be
    converted to its equivalent `var`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the `target` compiler option to a value that matches the oldest environment
    your code runs will ensure code is emitted as modern, terse syntax that can still
    run without syntax errors.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting Declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 11, “Declaration Files”](ch11.xhtml#declaration_files) covered how
    *.d.ts* declaration files may be distributed in a package to indicate code types
    to consumers. Most packages use TypeScript’s `declaration` compiler option to
    emit *.d.ts* output files from source files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*.d.ts* output files are emitted under the same output rules as *.js* files,
    including respecting `outDir`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, running `tsc --declaration` on a directory containing *fruits/apple.ts*
    and *vegetables/zucchini.ts* would result in output declaration files *fruits/apple.d.ts*
    and *vegetables/zucchini.d.ts* alongside output *.js* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: emitDeclarationOnly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An `emitDeclarationOnly` compiler option exists, as a specialized addition
    to the `declaration` compiler option, that directs TypeScript to only emit declaration
    files: no *.js*/*.jsx* files at all. This is useful for projects that use an external
    tool to generate output JavaScript but still want to use TypeScript to generate
    output definition files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If `emitDeclarationOnly` is enabled, either `declaration` or the `composite`
    compiler option covered later in this chapter must be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, running `tsc --declaration --emitDeclarationOnly` on a directory
    containing *fruits/apple.ts* and *vegetables/zucchini.ts* would result with output
    declaration files *fruits/apple.d.ts* and *vegetables/zucchini.d.ts* without any
    output *.js* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Source Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source maps are descriptions of how the contents of output files match up to
    original source files. They allow developer tools such as debuggers to display
    original source code when navigating through the output file. They’re particularly
    useful for visual debuggers such as those used in browser developer tools and
    IDEs to let you see original source file contents while debugging. TypeScript
    includes the ability to output source maps alongside output files.
  prefs: []
  type: TYPE_NORMAL
- en: sourceMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript’s `sourceMap` compiler option enables outputting *.js.map* or *.jsx.map*
    sourcemaps alongside *.js* or *.jsx* output files. Sourcemap files are otherwise
    given the same name as their corresponding output JavaScript file and placed in
    the same directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, running `tsc --sourceMap` on a directory containing *fruits/apple.ts*
    and *vegetables/zucchini.ts* would result with output sourcemap files *fruits/apple.js.map*
    and *vegetables/zucchini.js.map* alongside output *.js* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: declarationMap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript is also able to generate source maps for *.d.ts* declaration files.
    Its `declarationMap` compiler option directs it to generate a *.d.ts.map* source
    map for each *.d.ts* that maps back to the original source file. Declaration maps
    enable IDEs such as VS Code to go to the original source file when using editor
    features such as Go to Definition.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`declarationMap` is particularly useful when working with project references,
    covered toward the end of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, running `tsc --declaration --declarationMap` on a directory containing
    *fruits/apple.ts* and *vegetables/zucchini.ts* would result in output declaration
    sourcemap files *fruits/apple.d.ts.map* and *vegetables/zucchini.d.ts.map* alongside
    output *.d.ts* and *.js* files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: noEmit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For projects that completely rely on other tools to compile source files to
    output JavaScript, TypeScript can be told to skip emitting files altogether. Enabling
    the `noEmit` compiler option directs TypeScript to act purely as a type checker.
  prefs: []
  type: TYPE_NORMAL
- en: Running `tsc --noEmit` on any of the previous examples would result in no new
    files created. TypeScript would only report any syntax or type errors it finds.
  prefs: []
  type: TYPE_NORMAL
- en: Type Checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of TypeScript’s configuration options control its type checker. You can
    configure it to be gentle and forgiving, only emitting type-checking complaints
    when it’s completely certain of an error, or harsh and strict, requiring nearly
    all code be well typed.
  prefs: []
  type: TYPE_NORMAL
- en: lib
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start, which global APIs TypeScript assumes to be present in the runtime
    environment is configurable with the `lib` compiler option. It takes in an array
    of strings that defaults to your `target` compiler option, as well as `dom` to
    indicate including browser types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, the only reason to customize `lib` would be to remove the
    `dom` inclusion for a project that doesn’t run in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternately, for a project that uses polyfills to support newer JavaScript
    APIs, `lib` can include `dom` and any ECMAScript version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Be wary of modifying `lib` without providing all the right runtime polyfills.
    A project with a `lib` set to `"es2021"` running on a platform that only supports
    up through ES2020 might have no type-checking errors but still experience runtime
    errors attempting to use APIs defined in ES2021 or later, such as `String.replaceAll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Think of the `lib` compiler option as indicating what built-in language APIs
    are available, whereas the `target` compiler option indicates what syntax features
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: skipLibCheck
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript provides a `skipLibCheck` compiler option that indicates to skip
    type checking in declaration files not explicitly included in your source code.
    This can be useful for applications that rely on many dependencies that may rely
    on different, conflicting definitions of shared libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`skipLibCheck` speeds up TypeScript performance by allowing it to skip some
    type checking. For this reason, it is generally a good idea to enable it on most
    projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Strict Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of TypeScript’s type-checking compiler options are grouped into what TypeScript
    refers to as *strict mode*. Each strictness compiler option defaults to `false`,
    and when enabled, directs the type checker to turn on some additional checks.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll cover the most commonly used strict options in alphabetical order later
    in this chapter. From those options, `noImplicitAny` and `strictNullChecks` are
    particularly useful and impactful in enforcing type-safe code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable all strict mode checks by enabling the `strict` compiler option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to enable all strict mode checks except for certain ones, you can
    both enable `strict` and explicitly disable certain checks. For example, this
    configuration enables all strict modes except for `noImplicitAny`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Future versions of TypeScript may introduce new strict type-checking compiler
    options under `strict`. Using `strict` may therefore cause new type-checking complaints
    when you update TypeScript versions. You can always opt out of specific settings
    in your TSConfig.
  prefs: []
  type: TYPE_NORMAL
- en: noImplicitAny
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If TypeScript cannot infer the type of a parameter or property, then it will
    fall back to assuming the `any` type. It is generally best practice to not allow
    these implicit `any` types in code as the `any` type is allowed to bypass much
    of TypeScript’s type checking.
  prefs: []
  type: TYPE_NORMAL
- en: The `noImplicitAny` compiler option directs TypeScript to issue a type-checking
    complaint when it has to fall back to an implicit `any`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, writing the following function parameter without a type declaration
    would cause a type error under `noImplicitAny`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the time, a `noImplicitAny` complaint can be resolved either by adding
    a type annotation on the complaining location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in the case of function parameters, putting the parent function in a location
    that indicates the type of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`noImplicitAny` is an excellent flag for ensuring type safety across a project.
    I highly recommend striving to turn it on in projects written completely in TypeScript.
    However, if a project is still transitioning from JavaScript to TypeScript, it
    may be easier to finish converting all files to TypeScript first.'
  prefs: []
  type: TYPE_NORMAL
- en: strictBindCallApply
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When TypeScript was first released, it didn’t have rich enough type system features
    to be able to represent the built-in `Function.apply`, `Function.bind`, or `Function.call`
    function utilities. Those functions by default had to take in `any` for their
    list of arguments. That’s not very type safe!
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, without `strictBindCallApply`, the following variations on `getLength`
    all include `any` in their types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Now that TypeScript’s type system features are powerful enough to represent
    those functions’ generic rest arguments, TypeScript allows opting in to using
    more restrictive types for the functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enabling `strictBindCallApply` enables much more precise types for the `getLength`
    variations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript best practice is to enable `strictBindCallApply`. Its improved type
    checking for built-in function utilities helps improve type safety for projects
    that utilize them.
  prefs: []
  type: TYPE_NORMAL
- en: strictFunctionTypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `strictFunctionTypes` compiler option causes function parameter types to
    be checked slightly more strictly. A function type is no longer considered assignable
    to another function type if its parameters are subtypes of that other type’s parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example, the `checkOnNumber` function here takes in a function
    that should be able to receive a `number | string`, but is provided with a `stringContainsA`
    function that expects to take in a parameter only of type `string`. TypeScript’s
    default type checking would allow it—and the program would crash from trying to
    call `.match()` on a `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Under `strictFunctionTypes`, `checkOnNumber(stringContainsA)` would cause a
    type-checking error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In technical terms, function parameters switch from being *bivariant* to *contravariant*.
    You can read more about the difference in the [TypeScript 2.6 release notes](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html).
  prefs: []
  type: TYPE_NORMAL
- en: strictNullChecks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Back in [Chapter 3, “Unions and Literals”](ch03.xhtml#unions_and_literals),
    I discussed the billion-dollar mistake of languages: allowing empty types such
    as `null` and `undefined` to be assignable to nonempty types. Disabling TypeScript’s
    `strictNullChecks` flag roughly adds `null | undefined` to every type in your
    code, thereby allowing any variable to receive `null` or `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code snippet would cause a type error for assigning `null` to a `string`
    typed value only when `strictNullChecks` is enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript best practice is to enable `strictNullChecks`. Doing so helps prevent
    crashes and eliminates the billion-dollar mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 3, “Unions and Literals”](ch03.xhtml#unions_and_literals)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: strictPropertyInitialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Back in [Chapter 8, “Classes”](ch08.xhtml#classes), I discussed strict initialization
    checking in classes: making sure that each property on a class is definitely assigned
    in the class constructor. TypeScript’s `strictPropertyInitialization` flag causes
    a type error to be issued on class properties that have no initializer and are
    not definitely assigned in the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript best practice is generally to enable `strictPropertyInitialization`.
    Doing so helps prevent crashes from mistakes in class initialization logic.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [Chapter 8, “Classes”](ch08.xhtml#classes) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: useUnknownInCatchVariables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Error handling in any language is an inherently unsafe concept. Any function
    can in theory throw any number of errors from edge cases such as reading properties
    on `undefined` or user-written `throw` statements. In fact, there’s no guarantee
    a thrown error is even an instance of the `Error` class: code can always `throw
    "something-else"`.'
  prefs: []
  type: TYPE_NORMAL
- en: As a result, TypeScript’s default behavior for errors is to give them type `any`,
    as they could be anything. That allows flexibility in error handling at the cost
    of relying on the not-very-type-safe `any` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet’s `error` is typed `any` because there’s no way for TypeScript
    to know what all the possible errors thrown by `someExternalFunction()` could
    be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As with most `any` uses, it would be more technically sound—at the cost of often
    necessitating explicit type assertions or narrowing—to treat errors as `unknown`
    instead. Catch clause errors are allowed to be annotated as the `any` or `unknown`
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet correction adds an explicit `: unknown` to `error` to switch it
    to the `unknown` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The strict area flag `useUnknownInCatchVariables` changes TypeScript’s default
    catch clause error type to `unknown`. With `useUnknownInCatchVariables` enabled,
    both snippets would have type of `error` set to be `unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript best practice is generally to enable `useUnknownInCatchVariables`,
    as it’s not always safe to assume errors will be any particular type.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript’s various systems for exporting and importing module contents—AMD,
    CommonJS, ECMAScript, and so on—are one of the most convoluted module systems
    in any modern programming language. JavaScript is relatively unusual in that the
    way files import each other’s contents is often driven by user-written frameworks
    such as Webpack. TypeScript does its best to provide configuration options that
    represent most reasonable user-land module configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most new TypeScript projects are written with the standardized ECMAScript modules
    syntax. To recap, here is how ECMAScript modules import a value (`value`) from
    another module `("my-example-lib")` and export their own value (`logValue`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript provides a `module` compiler option to direct which module system
    transpiled code will use. When writing source code with ECMAScript modules, TypeScript
    may transpile the `export` and `import` statements to a different module system
    based on the `module` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, directing that a project written in ECMAScript be output as CommonJS
    modules in either the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'or in a TSConfig:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code snippet would roughly be output as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: If your `target` compiler option is `"es3"` or `"es5"`, `module`’s default value
    will be `"commonjs"`. Otherwise, `module` will default to `"es2015"` to specify
    outputting ECMAScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: moduleResolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Module resolution* is the process by which the imported path in an import
    is mapped to a module. TypeScript provides a `moduleResolution` option that you
    can use to specify the logic for that process. You’ll typically want to provide
    it one of two logic strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node`: The behavior used by CommonJS resolvers such as traditional Node.js'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nodenext`: Aligning to the behavior specified for ECMAScript modules'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two strategies are similar. Most projects could use either of them and not
    notice a difference. You can read more on the intricacies behind the scenes of
    module resolution on [*https://www.typescriptlang.org/docs/handbook/module-resolution.html*](https://www.typescriptlang.org/docs/handbook/module-resolution.html).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`moduleResolution` does not change how TypeScript emits code at all. It’s only
    used to describe the runtime environment your code is meant to be run in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the following CLI snippet and JSON file snippet would work to specify
    the `moduleResolution` compiler option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For backward compatibility reasons, TypeScript keeps the default `moduleResolution`
    value to a `classic` value that was used for projects years ago. You almost certainly
    do not want the `classic` strategy in any modern project.
  prefs: []
  type: TYPE_NORMAL
- en: Interoperability with CommonJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with JavaScript modules, there is a difference between the “default”
    export of a module and its “namespace” output. The *default* export of a module
    is the `.default` property on its exported object. The *namespace* export of a
    module is the exported object itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 13-2](#CommonJs_ECMAScript) recaps the differences between default and
    namespace exports and imports.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 13-2\. CommonJS and ECMAScript module export and import forms
  prefs: []
  type: TYPE_NORMAL
- en: '| Area of syntax | CommonJS | ECMAScript modules |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Default export | `module.exports.default = value;` | `export default value;`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Default import | `const { default: value } = require("...");` | `import value
    from "...";` |'
  prefs: []
  type: TYPE_TB
- en: '| Namespace export | `module.exports = value;` | Not supported |'
  prefs: []
  type: TYPE_TB
- en: '| Namespace import | `const value = require("...");` | `import * as value from
    "...";` |'
  prefs: []
  type: TYPE_TB
- en: TypeScript’s type system builds its understanding of file imports and exports
    in terms of ECMAScript modules. If your project depends on npm packages as most
    do, however, it’s likely some of those dependencies are still published as CommonJS
    modules. Furthermore, although some packages that comply with ECMAScript modules
    rules avoid including a default export, many developers prefer the more succinct
    default-style imports over namespace-style imports. TypeScript includes a few
    compiler options that improve interoperability between module formats.
  prefs: []
  type: TYPE_NORMAL
- en: esModuleInterop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `esModuleInterop` configuration option adds a small amount of logic to JavaScript
    code emitted by TypeScript when `module` is not an ECMAScript module format such
    as `"es2015"` or `"esnext"`. That logic allows ECMAScript modules to import from
    modules even if they don’t happen to adhere to ECMAScript modules’ rules around
    default or namespace imports.
  prefs: []
  type: TYPE_NORMAL
- en: 'One common reason to enable `esModuleInterop` is for packages such as `"react"`
    that do not ship a default export. If a module attempts to use a default-style
    import from the `"react"` package, TypeScript would report a type error without
    `esModuleInterop` enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Note that `esModuleInterop` only directly changes how emitted JavaScript code
    works with imports. The following `allowSyntheticDefaultImports` configuration
    option is what informs the type system about import interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: allowSyntheticDefaultImports
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `allowSyntheticDefaultImports` compiler option informs the type system that
    ECMAScript modules may default import from files that are otherwise incompatible
    CommonJS namespace exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'It defaults to `true` only if either of the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`module` is `"system"` (an older, rarely used module format not covered in
    this book).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`esModuleInterop` is `true` and `module` is not an ECMAScript modules format
    such as `"es2015"` or `"esnext"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In other words, if `esModuleInterop` is `true` but `module` is `"esnext"`,
    TypeScript will assume output compiled JavaScript code is not using import interoperability
    helpers. It would report a type error for a default import from packages such
    as `"react"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: isolatedModules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'External transpilers such as Babel that only operate on one file at a time
    cannot use type system information to emit JavaScript. As a result, TypeScript
    syntax features that rely on type information to emit JavaScript aren’t generally
    supported in those transpilers. Enabling the `isolatedModules` compiler tells
    TypeScript to report an error on any instance of a syntax that is likely to cause
    issues in those transpilers:'
  prefs: []
  type: TYPE_NORMAL
- en: Const enums, covered in [Chapter 14, “Syntax Extensions”](ch14.xhtml#syntax_extensions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script (nonmodule) files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone type exports, covered in [Chapter 14, “Syntax Extensions”](ch14.xhtml#syntax_extensions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I generally recommend enabling `isolatedModules` if your project uses a tool
    other than TypeScript to transpile to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While TypeScript is lovely and I hope you want to always write code in it, you
    don’t have to write all your source files in TypeScript. Although TypeScript by
    default ignores files with a *.js* or *.jsx* extension, using its `allowJs` and/or
    `checkJs` compiler options will allow it to read from, compile, and even—in a
    limited capacity—type check JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A common strategy for converting an existing JavaScript project to TypeScript
    is to start off with only a few files initially converted to TypeScript. More
    files may be added over time until there are no more JavaScript files left. You
    don’t have to go all-in on TypeScript until you’re ready to!
  prefs: []
  type: TYPE_NORMAL
- en: allowJs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `allowJs` compiler option allows constructs declared in JavaScript files
    to factor into type checking TypeScript files When combined with the `jsx` compiler
    option, *.jsx* files are also allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, take this *index.ts* importing a `value` declared in a *values.js*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Without `allowJs` enabled, the `import` statement would not have a known type.
    It would be implicitly `any` by default or trigger a type error like “Could not
    find a declaration file for module `"./values"`.”
  prefs: []
  type: TYPE_NORMAL
- en: '`allowJs` also adds JavaScript files to the list of files compiled to the ECMAScript
    target and emitted as JavaScript. Source maps and declaration files will be produced
    as well if the options to do so are enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: With `allowJs` enabled, the imported `value` would be type `string`. No type
    errors would be reported.
  prefs: []
  type: TYPE_NORMAL
- en: checkJs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript can do more than just factor JavaScript files into type checking
    TypeScript files: it can type check JavaScript files too. The `checkJs` compiler
    option serves two purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Defaulting `allowJs` to `true` if it wasn’t already
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling the type checker on *.js* and *.jsx* files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enabling `checkJs` will make TypeScript treat JavaScript files as if they were
    TypeScript files that don’t have any TypeScript-specific syntax. Type mismatches,
    misspelled variable names, and so on will all cause type errors as they normally
    would in a TypeScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'With `checkJs` enabled, this JavaScript file would cause a type-checking complaint
    for an incorrect variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Without `checkJs` enabled, TypeScript would not have reported a type error for
    that likely bug.
  prefs: []
  type: TYPE_NORMAL
- en: '@ts-check'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Alternately, `checkJs` can be enabled on a file-by-file basis by including
    a `// @ts-check` comment on top of the file. Doing so enables the `checkJs` option
    for just that JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: JSDoc Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because JavaScript doesn’t have TypeScript’s rich type syntax, the types of
    values declared in JavaScript files are often not as precise as those declared
    in TypeScript files. For example, while TypeScript can infer the value of an object
    declared as a variable in a JavaScript file, there’s no native JavaScript way
    to declare in that file that the value adheres to any particular interface.
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned back in [Chapter 1, “From JavaScript to TypeScript”](ch01.xhtml#from_javascript_to_typescript)
    that the JSDoc community standard provides some ways to describe types using comments.
    When `allowJs` and/or `checkJs` are enabled, TypeScript will recognize any JSDoc
    definitions in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this snippet declares in JSDoc that the `sentenceCase` function
    takes in a `string`. TypeScript can then infer that it returns a `string`. With
    `checkJs` enabled, TypeScript would know to report a type error for passing it
    a `string[]` later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript’s JSDoc support is useful for incrementally adding type checking
    for projects that don’t have the time or developer familiarity to convert to TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The full list of supported JSDoc syntax is available on [*https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html*](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you write more and more TypeScript projects, you may find yourself writing
    the same project settings repeatedly. Although TypeScript doesn’t allow configuration
    files to be written in JavaScript and use `import` or `require`, it does offer
    a mechanism for a TSConfig file to opt into “extending,” or copying in configuration
    values, from another configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: extends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A TSConfig may extend from another TSConfig with the `extends` configuration
    option. `extends` takes in a path to another TSConfig file and indicates that
    all settings from that file should be copied over. It behaves similarly to the
    `extends` keyword on classes: any option declared on the derived, or child, configuration
    will override any option of the same name on the base, or parent, configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, many repositories that have multiple TSConfigs, such as monorepos
    containing multiple *packages/** directories, by convention create a *tsconfig.base.json*
    file for *tsconfig.json* files to extend from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Note that `compilerOptions` are factored in recursively. Each compiler option
    from a base TSConfig will copy over to a derived TSConfig unless the derived TSConfig
    overrides that specific option.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the previous example were to add a TSConfig that adds the `allowJs` option,
    that new derived TSConfig would still have `compilerOptions.strict` set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Extending modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `extends` property may point to either kind of JavaScript import:'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute
  prefs: []
  type: TYPE_NORMAL
- en: Starting with `@` or an alphabetical letter
  prefs: []
  type: TYPE_NORMAL
- en: Relative
  prefs: []
  type: TYPE_NORMAL
- en: A local file path starting with `.`
  prefs: []
  type: TYPE_NORMAL
- en: When an `extends` value is an absolute path, it indicates to extend the TSConfig
    from an npm module. TypeScript will use the normal Node module resolution system
    to find a package matching the name. If that package’s `package.json` contains
    a `"tsconfig"` field containing a relative path string, the TSConfig file at that
    path will be used. Otherwise, the package’s *tsconfig.json* file will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many organizations use npm packages to standardize TypeScript compiler options
    across repositories and/or within monorepos. The following TSConfig files are
    what you might set up for a monorepo in a `@my-org` organization. `packages/js`
    needs to specify the `allowJs` compiler option, while `packages/ts` does not change
    any compiler options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Configuration Bases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of creating your own configuration from scratch or the `--init` suggestions,
    you can start with a premade “base” TSConfig file tailored to a particular runtime
    environment. These premade configuration bases are available on the npm package
    registry under `@tsconfig/`, such as `@tsconfig/recommended` or `@tsconfig/node16`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to install the recommended TSConfig base for `deno`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a configuration base package is installed, it can be referenced like any
    other npm package configuration extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The full list of TSConfig bases is documented on [*https://github.com/tsconfig/bases*](https://github.com/tsconfig/bases).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is generally a good idea to know what TypeScript configuration options your
    file is using, even if you aren’t changing them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Project References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of the TypeScript configuration files I’ve shown so far have assumed they
    manage all the source files of a project. It can be useful in larger projects
    to use different configuration files for different areas of a project. TypeScript
    allows defining a system of “project references” where multiple projects can be
    built together. Setting up project references is a little more work than using
    a single TSConfig file but comes with several key benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: You can specify different compiler options for certain areas of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript will be able to cache build outputs for individual projects, often
    resulting in significantly faster build times for large projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project references enforce a “dependency tree” (only allowing certain projects
    to import files from certain other projects), which can help structure discrete
    areas of code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Project references are generally used in larger projects that have multiple
    distinct areas of code, such as monorepos and modular component systems. You probably
    don’t want to use them for small projects that don’t have dozens or more files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three sections show how to build up project settings to enable
    project references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`composite` mode on a TSConfig enforces that it works in ways suitable for
    multi-TSConfig build modes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`references` in a TSConfig indicate which composite TSConfigs it relies on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build mode uses composite TSConfig references to orchestrate building their
    files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: composite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript allows a project to opt into the `composite` configuration option
    to indicate that its file system inputs and outputs obey constraints that make
    it easier for build tools to determine whether its build outputs are up-to-date
    compared to its build inputs. When `composite` is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: The rootDir setting, if not already explicitly set, defaults to the directory
    containing the TSConfig file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All implementation files must be matched by an include pattern or listed in
    the `files` array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`declaration` must be turned on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This configuration snippet matches all conditions for enabling `composite`
    mode in a `core/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: These changes help TypeScript enforce that all input files to the project create
    a matching *.d.ts* file. `composite` is generally most useful in combination with
    the following `references` configuration option.
  prefs: []
  type: TYPE_NORMAL
- en: references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A TypeScript project can indicate it relies on the outputs generated by a composite
    TypeScript project with a `references` setting in its TSConfig. Importing modules
    from a referenced project will be seen in the type system as importing from its
    output *.d.ts* declaration file(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration snippet sets up a *shell/* directory to reference a *core/*
    directory as its inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `references` configuration option will not be copied from base TSConfigs
    to derived TSConfigs via `extends`.
  prefs: []
  type: TYPE_NORMAL
- en: '`references` is generally most useful in combination with the following build
    mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Build Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once an area of code has been set up to use project references, it will be possible
    to use `tsc` in its alternate “build” mode via the `-b`/`--b` CLI flag. Build
    mode enhances `tsc` into something of a project build coordinator. It lets `tsc`
    rebuild only the projects that have been changed since the last build, based on
    when their contents and their file outputs were last generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'More precisely, TypeScript’s build mode will do the following when given a
    TSConfig:'
  prefs: []
  type: TYPE_NORMAL
- en: Find that TSConfig’s referenced projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Detect if they are up-to-date.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build out-of-date projects in the correct order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the provided TSConfig if it or any of its dependencies have changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ability of TypeScript’s build mode to skip rebuilding up-to-date projects
    can significantly improve build performance.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinator configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A common handy pattern for setting up TypeScript project references in a repository
    is to set up a root-level `tsconfig.json` with an empty `files` array and references
    to all the project references in the repository. That root TSConfig won’t direct
    TypeScript to build any files itself. Instead it will act purely to tell TypeScript
    to build referenced projects as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `tsconfig.json` indicates to build the `packages/core` and `packages/shell`
    projects in a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'I personally like to standardize having a script in my `package.json` named
    `build` or `compile` that calls to `tsc -b` as a shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Build-mode options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Build mode supports a few build-specific CLI options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--clean`: deletes the outputs of the specified projects (may be combined with
    `--dry`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--dry`: shows what would be done but doesn’t actually build anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--force`: acts as if all projects are out of date'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-w`/`--watch`: similar to the typical TypeScript watch mode'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because build mode supports watch mode, running a command like `tsc -b -w` can
    be a fast way to get an up-to-date listing of all compiler errors in a large project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you went over many of the important configuration options
    provided by TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `tsc`, including its pretty and watch modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using TSConfig files, including creating one with `tsc --init`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing which files will be included by the TypeScript compiler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing JSX syntax in *.tsx* files and/or JSON syntax in *.json* files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the directory, ECMAScript version target, declaration file, and/or
    source map outputs with files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the built-in library types used in compilation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict mode and useful strict flags such as `noImplicitAny` and `strictNullChecks`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting different module systems and changing module resolution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing including JavaScript files, and opting into type checking those files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `extends` to share configuration options between files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using project references and build mode to orchestrate multi-TSConfig builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/configuration-options*](https://learningtypescript.com/configuration-options).
  prefs: []
  type: TYPE_NORMAL
- en: What is a disciplinarian’s favorite TypeScript compiler option?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`strict`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
