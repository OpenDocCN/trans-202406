<html><head></head><body><section data-pdf-bookmark="Chapter 4. Using Custom Resources" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_crds">&#13;
<h1><span class="label">Chapter 4. </span>Using Custom Resources</h1>&#13;
&#13;
&#13;
<p>In<a data-primary="custom API servers" data-secondary="CustomResourceDefinition" data-type="indexterm" id="CAScrd04"/><a data-primary="extension patterns" data-secondary="custom resource definitions (CRDs)" data-type="indexterm" id="EPcrd04"/><a data-primary="custom resources (CR)" data-see="custom resource definitions (CRDs)" data-type="indexterm" id="idm46336863894968"/> this chapter we introduce you to custom resources (CR), one of the central extension mechanisms used throughout the Kubernetes ecosystem.</p>&#13;
&#13;
<p>Custom resources<a data-primary="custom resource definitions (CRDs)" data-secondary="role of" data-type="indexterm" id="idm46336863893384"/> are used for small, in-house configuration objects without any corresponding controller logic—purely declaratively defined. But custom resources also play a central role for many serious development projects on top of Kubernetes that want to offer a Kubernetes-native API experience. Examples are service meshes such as Istio, Linkerd 2.0, and AWS App Mesh, all of which have custom resources at their heart.</p>&#13;
&#13;
<p>Remember “A Motivational Example” from <a data-type="xref" href="ch01.html#intro">Chapter 1</a>? At its core, it has a CR that looks like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">cnat.programming-kubernetes.info/v1alpha1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">At</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">example-at</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">schedule</code><code class="p">:</code> <code class="s">"2019-07-03T02:00:00Z"</code>&#13;
<code class="nt">status</code><code class="p">:</code>&#13;
  <code class="nt">phase</code><code class="p">:</code> <code class="s">"pending"</code></pre>&#13;
&#13;
<p>Custom<a data-primary="custom resource definitions (CRDs)" data-secondary="availability of" data-type="indexterm" id="idm46336863840152"/> resources are available in every Kubernetes cluster since version 1.7. They are stored in the same <code>etcd</code> instance as the main Kubernetes API resources and served by the same Kubernetes API server. As shown in <a data-type="xref" href="#apiextensions-apiserver">Figure 4-1</a>, requests fall back to the <code>apiextensions-apiserver</code>, which serves the resources<a data-primary="custom resource definitions (CRDs)" data-secondary="defining" data-type="indexterm" id="idm46336863837512"/> defined via CRDs, if they are neither of the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Handled by aggregated API servers (see <a data-type="xref" href="ch08.html#ch_custom-api-servers">Chapter 8</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Native Kubernetes resources.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="apiextensions-apiserver">&#13;
<img alt="API Extensions API server inside of the Kubernetes API server" src="assets/prku_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>The API Extensions API server inside the Kubernetes API server</h6>&#13;
</div></figure>&#13;
&#13;
<p>A CustomResourceDefinition (CRD) is a Kubernetes resource itself. It describes the available CRs in the cluster. For the preceding example CR, the corresponding CRD looks like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomResourceDefinition</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ats.cnat.programming-kubernetes.info</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">group</code><code class="p">:</code> <code class="l-Scalar-Plain">cnat.programming-kubernetes.info</code>&#13;
  <code class="nt">names</code><code class="p">:</code>&#13;
    <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">At</code>&#13;
    <code class="nt">listKind</code><code class="p">:</code> <code class="l-Scalar-Plain">AtList</code>&#13;
    <code class="nt">plural</code><code class="p">:</code> <code class="l-Scalar-Plain">ats</code>&#13;
    <code class="nt">singular</code><code class="p">:</code> <code class="l-Scalar-Plain">at</code>&#13;
  <code class="nt">scope</code><code class="p">:</code> <code class="l-Scalar-Plain">Namespaced</code>&#13;
  <code class="nt">subresources</code><code class="p">:</code>&#13;
    <code class="nt">status</code><code class="p">:</code> <code class="p-Indicator">{}</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1</code>&#13;
  <code class="nt">versions</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1</code>&#13;
    <code class="nt">served</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
    <code class="nt">storage</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code></pre>&#13;
&#13;
<p>The name of the CRD—in this case, <code>ats.cnat.programming-kubernetes.info</code>—must match the plural name followed by the group name. It defines the kind <code>At</code> CR in the API group <code>cnat.programming-kubernetes.info</code> as a namespaced resource called <code>ats</code>.</p>&#13;
&#13;
<p>If this CRD is created in a cluster, <code>kubectl</code> will automatically detect the resource, and the user can access it via:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get ats&#13;
NAME                                         CREATED AT&#13;
ats.cnat.programming-kubernetes.info         2019-04-01T14:03:33Z</pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discovery Information" data-type="sect1"><div class="sect1" id="discovery">&#13;
<h1>Discovery Information</h1>&#13;
&#13;
<p>Behind<a data-primary="custom resource definitions (CRDs)" data-secondary="discovery information" data-type="indexterm" id="idm46336863686072"/><a data-primary="discovery mechanism" data-type="indexterm" id="idm46336863685096"/><a data-primary="kubectl" data-type="indexterm" id="idm46336863684424"/> the scenes, <code>kubectl</code> uses discovery information from the API server to find out about the new resources. Let’s look a bit deeper into this discovery mechanism.</p>&#13;
&#13;
<p>After increasing the verbosity level of <code>kubectl</code>, we can actually see how it learns about the new resource type:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get ats -v<code class="o">=</code>7&#13;
... GET https://XXX.eks.amazonaws.com/apis/cnat.programming-kubernetes.info/&#13;
                                      v1alpha1/namespaces/cnat/ats?limit<code class="o">=</code>500&#13;
... Request Headers:&#13;
... Accept: application/json<code class="p">;</code><code class="nv">as</code><code class="o">=</code>Table<code class="p">;</code><code class="nv">v</code><code class="o">=</code>v1beta1<code class="p">;</code><code class="nv">g</code><code class="o">=</code>meta.k8s.io,application/json&#13;
      User-Agent: kubectl/v1.14.0 <code class="o">(</code>darwin/amd64<code class="o">)</code> kubernetes/641856d&#13;
... Response Status: <code class="m">200</code> OK in <code class="m">607</code> milliseconds&#13;
NAME         AGE&#13;
example-at   43s</pre>&#13;
&#13;
<p>The discovery steps in detail are:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Initially, <code>kubectl</code> does not know about <code>ats</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Hence, <code>kubectl</code> asks the API server about all existing API groups via the <em>/apis</em> discovery endpoint.</p>&#13;
</li>&#13;
<li>&#13;
<p>Next, <code>kubectl</code> asks the API server about resources in all existing API groups via the <em>/apis/<code>group version</code></em> group discovery endpoints.</p>&#13;
</li>&#13;
<li>&#13;
<p>Then, <code>kubectl</code> translates the given type, <code>ats</code>, to a triple of:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Group (here <code>cnat.programming-kubernetes.info</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Version (here <code>v1alpha1</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Resource (here <code>ats</code>).</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The discovery endpoints provide all the necessary information to do the translation in the last step:</p>&#13;
&#13;
<pre data-type="programlisting">$ http localhost:8080/apis/&#13;
{&#13;
  "groups": [{&#13;
    "name": "at.cnat.programming-kubernetes.info",&#13;
    "preferredVersion": {&#13;
      "groupVersion": "cnat.programming-kubernetes.info/v1",&#13;
      "version": "v1alpha1“&#13;
    },&#13;
    "versions": [{&#13;
      "groupVersion": "cnat.programming-kubernetes.info/v1alpha1",&#13;
      "version": "v1alpha1"&#13;
    }]&#13;
  }, ...]&#13;
}&#13;
&#13;
$ http localhost:8080/apis/cnat.programming-kubernetes.info/v1alpha1&#13;
{&#13;
  "apiVersion": "v1",&#13;
  "groupVersion": "cnat.programming-kubernetes.info/v1alpha1",&#13;
  "kind": "APIResourceList",&#13;
  "resources": [{&#13;
    "kind": "At",&#13;
    "name": "ats",&#13;
    "namespaced": true,&#13;
    "verbs": ["create", "delete", "deletecollection",&#13;
      "get", "list", "patch", "update", "watch"&#13;
    ]&#13;
  }, ...]&#13;
}</pre>&#13;
&#13;
<p>This is all implemented by the discovery <code>RESTMapper</code>. We also saw this very common type of <code>RESTMapper</code> in <a data-type="xref" href="ch03.html#RESTMapping">“REST Mapping”</a>.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The <code>kubectl</code> CLI also maintains a cache of resource types in <em>~/.kubectl</em> so that it does not have to re-retrieve the discovery information on every access. This cache is invalidated every 10 minutes. Hence, a change in the CRD might show up in the CLI of the respective user up to 10 minutes later.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type Definitions" data-type="sect1"><div class="sect1" id="crd-types">&#13;
<h1>Type Definitions</h1>&#13;
&#13;
<p>Now<a data-primary="custom resource definitions (CRDs)" data-secondary="type definitions" data-type="indexterm" id="idm46336863645160"/><a data-primary="type definitions" data-type="indexterm" id="idm46336863644184"/> let’s look at the CRD and the offered features in more detail: as in the <code>cnat</code> example, CRDs are Kubernetes resources in the <code>apiextensions.k8s.io/v1beta1</code> API group provided by the <code>apiextensions-apiserver</code> inside the Kubernetes API server process.</p>&#13;
&#13;
<p>The schema of CRDs looks like this:</p>&#13;
<pre data-code-language="yaml" data-type="program-listing">&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">CustomResourceDefinition</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">group</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">group</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code>  </code><code class="nt">version</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">version</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code>  </code><code class="nt">names</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">kind</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">uppercase</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code>    </code><code class="nt">plural</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">lowercase</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">plural</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code>    </code><code class="nt">singular</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">lowercase</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">singular</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">name</code></em><code> </code><code class="c1"># defaulted to be lowercase kind</code><code>&#13;
</code><code>    </code><code class="nt">shortNames</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">list</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">of</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">strings</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">as</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">short</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">names</code></em><code> </code><code class="c1"># optional</code><code>&#13;
</code><code>    </code><code class="nt">listKind</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">uppercase</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">list</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">kind</code></em><code> </code><code class="c1"># defaulted to be </code><em><code class="c1">kind</code></em><code class="c1">List</code><code>&#13;
</code><code>    </code><code class="nt">categories</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">list</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">of</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">category</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">membership</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">like</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">"all"</code></em><code> </code><code class="c1"># optional</code><code>&#13;
</code><code>  </code><code class="nt">validation</code><code class="p">:</code><code> </code><code class="c1"># optional</code><code>&#13;
</code><code>    </code><code class="nt">openAPIV3Schema</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">OpenAPI</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">schema</code></em><code> </code><code class="c1"># optional</code><code>&#13;
</code><code>  </code><code class="nt">subresources</code><code class="p">:</code><code> </code><code class="c1"># optional</code><code>&#13;
</code><code>    </code><code class="nt">status</code><code class="p">:</code><code> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code> </code><code class="c1"># to enable the status subresource (optional)</code><code>&#13;
</code><code>    </code><code class="nt">scale</code><code class="p">:</code><code> </code><code class="c1"># optional</code><code>&#13;
</code><code>      </code><code class="nt">specReplicasPath</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">JSON</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">path</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">for</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">replica</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">number</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">in</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">spec</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">of</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code>&#13;
</code><code>                        </code><code class="l-Scalar-Plain">custom</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">resource</code></em><code>&#13;
</code><code>      </code><code class="nt">statusReplicasPath</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">JSON</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">path</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">for</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">replica</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">number</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">in</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">status</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">of</code><code>&#13;
</code><code>                          </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">custom</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">resource</code></em><code>&#13;
</code><code>      </code><code class="nt">labelSelectorPath</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">JSON</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">path</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">of</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">Scale.Status.Selector</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">field</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">in</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code>&#13;
</code><code>                         </code><code class="l-Scalar-Plain">scale</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">resource</code></em><code>&#13;
</code><code>  </code><code class="nt">versions</code><code class="p">:</code><code> </code><code class="c1"># defaulted to the Spec.Version field</code><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">version</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code>    </code><code class="nt">served</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">boolean</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">whether</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">version</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">is</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">served</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">by</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">API</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">server</code></em><code> </code><code class="c1"># defaults to false</code><code>&#13;
</code><code>    </code><code class="nt">storage</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">boolean</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">whether</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">this</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">version</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">is</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">version</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">used</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">to</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">store</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">object</code></em><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">...</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Many of the fields are optional or are defaulted. We will explain the fields in more detail in the following sections.</p>&#13;
&#13;
<p>After<a data-primary="kube-apiserver" data-type="indexterm" id="idm46336863330568"/> creating a CRD object, the <code>apiextensions-apiserver</code> inside of <code>kube-apiserver</code> will check the names and determine whether they conflict with other resources or whether they are consistent in themselves. After a few moments it will report the result in the status of the CRD, for example:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomResourceDefinition</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ats.cnat.programming-kubernetes.info</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">group</code><code class="p">:</code> <code class="l-Scalar-Plain">cnat.programming-kubernetes.info</code>&#13;
  <code class="nt">names</code><code class="p">:</code>&#13;
    <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">At</code>&#13;
    <code class="nt">listKind</code><code class="p">:</code> <code class="l-Scalar-Plain">AtList</code>&#13;
    <code class="nt">plural</code><code class="p">:</code> <code class="l-Scalar-Plain">ats</code>&#13;
    <code class="nt">singular</code><code class="p">:</code> <code class="l-Scalar-Plain">at</code>&#13;
  <code class="nt">scope</code><code class="p">:</code> <code class="l-Scalar-Plain">Namespaced</code>&#13;
  <code class="nt">subresources</code><code class="p">:</code>&#13;
    <code class="nt">status</code><code class="p">:</code> <code class="p-Indicator">{}</code>&#13;
  <code class="nt">validation</code><code class="p">:</code>&#13;
    <code class="nt">openAPIV3Schema</code><code class="p">:</code>&#13;
      <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">object</code>&#13;
      <code class="nt">properties</code><code class="p">:</code>&#13;
        <code class="nt">apiVersion</code><code class="p">:</code>&#13;
          <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
        <code class="nt">kind</code><code class="p">:</code>&#13;
          <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
        <code class="nt">metadata</code><code class="p">:</code>&#13;
          <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">object</code>&#13;
        <code class="nt">spec</code><code class="p">:</code>&#13;
          <code class="nt">properties</code><code class="p">:</code>&#13;
            <code class="nt">schedule</code><code class="p">:</code>&#13;
              <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
          <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">object</code>&#13;
        <code class="nt">status</code><code class="p">:</code>&#13;
          <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">object</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1</code>&#13;
  <code class="nt">versions</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1</code>&#13;
    <code class="nt">served</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
    <code class="nt">storage</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
<code class="nt">status</code><code class="p">:</code>&#13;
    <code class="nt">acceptedNames</code><code class="p">:</code>&#13;
      <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">At</code>&#13;
      <code class="nt">listKind</code><code class="p">:</code> <code class="l-Scalar-Plain">AtList</code>&#13;
      <code class="nt">plural</code><code class="p">:</code> <code class="l-Scalar-Plain">ats</code>&#13;
      <code class="nt">singular</code><code class="p">:</code> <code class="l-Scalar-Plain">at</code>&#13;
    <code class="nt">conditions</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">lastTransitionTime</code><code class="p">:</code> <code class="s">"2019-03-17T09:44:21Z"</code>&#13;
      <code class="nt">message</code><code class="p">:</code> <code class="l-Scalar-Plain">no conflicts found</code>&#13;
      <code class="nt">reason</code><code class="p">:</code> <code class="l-Scalar-Plain">NoConflicts</code>&#13;
      <code class="nt">status</code><code class="p">:</code> <code class="s">"True"</code>&#13;
      <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">NamesAccepted</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">lastTransitionTime</code><code class="p">:</code> <code class="l-Scalar-Plain">null</code>&#13;
      <code class="nt">message</code><code class="p">:</code> <code class="l-Scalar-Plain">the initial names have been accepted</code>&#13;
      <code class="nt">reason</code><code class="p">:</code> <code class="l-Scalar-Plain">InitialNamesAccepted</code>&#13;
      <code class="nt">status</code><code class="p">:</code> <code class="s">"True"</code>&#13;
      <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Established</code>&#13;
    <code class="nt">storedVersions</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">v1alpha1</code></pre>&#13;
&#13;
<p>You can see that the missing name fields in the spec are defaulted and reflected in the status as accepted names. Moreover, the following conditions are set:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>NamesAccepted</code> describes whether the given names in the spec are consistent and free of conflicts.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Established</code> describes that the API server serves the given resource under the names in <code>status.acceptedNames</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Note that certain fields can be changed long after the CRD has been created. For example, you can add short names or columns. In this case, a CRD can be established—that is, served with the old names—although the spec names have conflicts. Hence the <code>NamesAccepted</code> condition would be false and the spec names and accepted names would differ.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Advanced Features of Custom Resources" data-type="sect1"><div class="sect1" id="crd-advanced">&#13;
<h1>Advanced Features of Custom Resources</h1>&#13;
&#13;
<p>In this section we discuss advanced features of custom resources, such as validation or <span class="keep-together">subresources</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Validating Custom Resources" data-type="sect2"><div class="sect2" id="crd-validation">&#13;
<h2>Validating Custom Resources</h2>&#13;
&#13;
<p>CRs<a data-primary="custom resource definitions (CRDs)" data-secondary="validating custom resources" data-type="indexterm" id="idm46336863087384"/> can be validated by the API server during creation and updates. This is done based on the <a href="http://bit.ly/2RqtN5i">OpenAPI v3 schema</a> specified in the <code>validation</code> fields in the CRD spec.</p>&#13;
&#13;
<p>When a request creates or mutates a CR, the JSON object in the spec is validated against this spec, and in case of errors the conflicting field is returned to the user in an HTTP code <code>400</code> response. <a data-type="xref" href="#apiextensions-apiserver-validation">Figure 4-2</a> shows where validation takes places in the request handler inside the <code>apiextensions-apiserver</code>.</p>&#13;
&#13;
<p>More complex validations can be implemented in validating admission webhooks—that is, in a Turing-complete programming language. <a data-type="xref" href="#apiextensions-apiserver-validation">Figure 4-2</a> shows that these webhooks are called directly after the OpenAPI-based validations described in this section. In <a data-type="xref" href="ch09.html#admission-webhooks">“Admission Webhooks”</a>, we will see how admission webhooks are implemented and deployed. There, we’ll look into validations that take other resources into account and therefore go far beyond OpenAPI v3 validation. Luckily, for many use cases OpenAPI v3 schemas are sufficient.</p>&#13;
&#13;
<figure><div class="figure" id="apiextensions-apiserver-validation">&#13;
<img alt="Validation step in the handler stack of the `apiextensions-apiserver`" src="assets/prku_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Validation step in the handler stack of the apiextensions-apiserver</h6>&#13;
</div></figure>&#13;
&#13;
<p>The<a data-primary="OpenAPI schema language" data-type="indexterm" id="idm46336863077672"/> OpenAPI schema language is based on the <a href="http://bit.ly/2J7aIT7">JSON Schema standard</a>, which uses JSON/YAML itself to express a schema. Here’s an example:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">object</code>&#13;
<code class="nt">properties</code><code class="p">:</code>&#13;
  <code class="nt">apiVersion</code><code class="p">:</code>&#13;
    <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
  <code class="nt">kind</code><code class="p">:</code>&#13;
    <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
  <code class="nt">metadata</code><code class="p">:</code>&#13;
    <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">object</code>&#13;
  <code class="nt">spec</code><code class="p">:</code>&#13;
    <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">object</code>&#13;
    <code class="nt">properties</code><code class="p">:</code>&#13;
      <code class="nt">schedule</code><code class="p">:</code>&#13;
        <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
        <code class="nt">pattern</code><code class="p">:</code> <code class="s">"^</code><code class="err">\</code><code class="s">d{4}-([0]</code><code class="err">\</code><code class="s">d|1[0-2])-([0-2]</code><code class="err">\</code><code class="s">d|3[01])..."</code>&#13;
      <code class="nt">command</code><code class="p">:</code>&#13;
        <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
    <code class="nt">required</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">schedule</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">command</code>&#13;
  <code class="nt">status</code><code class="p">:</code>&#13;
    <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">object</code>&#13;
    <code class="nt">properties</code><code class="p">:</code>&#13;
      <code class="nt">phase</code><code class="p">:</code>&#13;
        <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
<code class="nt">required</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="l-Scalar-Plain">metadata</code>&#13;
<code class="p-Indicator">-</code> <code class="l-Scalar-Plain">apiVersion</code>&#13;
<code class="p-Indicator">-</code> <code class="l-Scalar-Plain">kind</code>&#13;
<code class="p-Indicator">-</code> <code class="l-Scalar-Plain">spec</code></pre>&#13;
&#13;
<p>This schema specifies that the value is actually a JSON object;<sup><a data-type="noteref" href="ch04.html#idm46336863073336" id="idm46336863073336-marker">1</a></sup> that is, it is a string map and not a slice or a value like a number. Moreover, it has (aside from <code>metadata</code>, <code>kind</code>, and <code>apiVersion</code>, which are implicitly defined for custom resources) two additional properties: <code>spec</code> and <code>status</code>.</p>&#13;
&#13;
<p>Each is a JSON object as well. <code>spec</code> has the required fields <code>schedule</code> and <code>command</code>, both of which are strings. <code>schedule</code> has to match a pattern for an ISO date (sketched here with some regular expressions). The optional <code>status</code> property has a string field called <code>phase</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336863030808">&#13;
<h5>OpenAPI v3 Schemas, Completeness, and Their Future</h5>&#13;
<p>OpenAPI v3 schemas used to be optional in CRDs. Until Kubernetes 1.14, they were used only for server-side validation. For that purpose they could also be incomplete—in other words, they might not specify all the fields.</p>&#13;
&#13;
<p>Starting with Kubernetes 1.15, the CRD schemas will be published as part of the Kubernetes API server OpenAPI spec. This<a data-primary="kubectl" data-type="indexterm" id="idm46336863028216"/> is used especially by <code>kubectl</code> for client-side validation. Client-side validation complains about unknown fields. For example, when the user types <code>foo:bar</code> in an object and the OpenAPI schema does not specify <code>foo</code>, <code>kubectl</code> will reject the object. Hence, it is good practice to pass a complete OpenAPI schema.</p>&#13;
&#13;
<p>Finally, <a href="http://bit.ly/2WY8lKY">in the future custom resource instances will be pruned</a>. This means that—similarly to native Kubernetes resource–like pods—unknown (unspecified) fields will not be persisted. This is important not only for data consistency, but also for security. This is another reason why OpenAPI schemas for CRDs should be complete.</p>&#13;
&#13;
<p>For a complete reference, see the <a href="http://bit.ly/2RqtN5i">OpenAPI v3 schema documentation</a>.</p>&#13;
</div></aside>&#13;
&#13;
<p>Creating OpenAPI schemata manually can be tedious. Luckily, work is underway to make this much easier via code generation: the Kubebuilder project—see <a data-type="xref" href="ch06.html#kubebuilder">“Kubebuilder”</a>—has developed <a href="http://bit.ly/2J00kvi"><code>crd-gen</code> in <em>sig.k8s.io/controller-tools</em></a>, and this is being extended step by step so that it’s usable in other contexts. The generator <a href="http://bit.ly/31N0eQf"><code>crd-schema-gen</code></a> is a fork of <code>crd-gen</code> in this direction.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Short Names and Categories" data-type="sect2"><div class="sect2" id="idm46336863088728">&#13;
<h2>Short Names and Categories</h2>&#13;
&#13;
<p>Like<a data-primary="custom resource definitions (CRDs)" data-secondary="short names and categories" data-type="indexterm" id="idm46336863017512"/><a data-primary="short names" data-type="indexterm" id="idm46336863016424"/><a data-primary="kubectl get ds" data-type="indexterm" id="idm46336863015752"/> native resources, custom resources might have long resource names. They are great on the API level but tedious to type in the CLI. CRs can have short names as well, like the native resource <code>daemonsets</code>, which can be queried with <code>kubectl get ds</code>. These short names are also known as aliases, and each resource can have any number of them.</p>&#13;
&#13;
<p>To<a data-primary="kubectl api-resources" data-type="indexterm" id="idm46336863013416"/> view all of the available short names, use the <code>kubectl api-resources</code> command like so:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl api-resources&#13;
NAME                   SHORTNAMES  APIGROUP NAMESPACED  KIND&#13;
bindings                                    <code class="nb">true        </code>Binding&#13;
componentstatuses      cs                   <code class="nb">false       </code>ComponentStatus&#13;
configmaps             cm                   <code class="nb">true        </code>ConfigMap&#13;
endpoints              ep                   <code class="nb">true        </code>Endpoints&#13;
events                 ev                   <code class="nb">true        </code>Event&#13;
limitranges            limits               <code class="nb">true        </code>LimitRange&#13;
namespaces             ns                   <code class="nb">false       </code>Namespace&#13;
nodes                  no                   <code class="nb">false       </code>Node&#13;
persistentvolumeclaims pvc                  <code class="nb">true       </code>PersistentVolumeClaim&#13;
persistentvolumes      pv                   <code class="nb">false       </code>PersistentVolume&#13;
pods                   po                   <code class="nb">true        </code>Pod&#13;
statefulsets           sts         apps     <code class="nb">true        </code>StatefulSet&#13;
...</pre>&#13;
&#13;
<p>Again, <code>kubectl</code> learns about short names<a data-primary="discovery" data-type="indexterm" id="idm46336863001976"/> via discovery information (see <a data-type="xref" href="#discovery">“Discovery Information”</a>). Here is an example:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomResourceDefinition</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ats.cnat.programming-kubernetes.info</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="l-Scalar-Plain">...</code>&#13;
  <code class="l-Scalar-Plain">shortNames</code><code class="p-Indicator">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">at</code></pre>&#13;
&#13;
<p>After that, a <code>kubectl get at</code> will list all <code>cnat</code> CRs in the namespace.</p>&#13;
&#13;
<p>Further, CRs—as with any other resource—can be part of<a data-primary="categories" data-type="indexterm" id="idm46336862861560"/> categories. The most common use is the <code>all</code> category, as in <code>kubectl get all</code>. It lists all user-facing resources in a cluster, like pods and services.</p>&#13;
&#13;
<p>The CRs defined in the cluster can join a category or create their own category via the <code>categories</code> field:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomResourceDefinition</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ats.cnat.programming-kubernetes.info</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="l-Scalar-Plain">...</code>&#13;
  <code class="l-Scalar-Plain">categories</code><code class="p-Indicator">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">all</code></pre>&#13;
&#13;
<p>With this, <code>kubectl get all</code> will also list the <code>cnat</code> CR in the namespace.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Printer Columns" data-type="sect2"><div class="sect2" id="idm46336863018584">&#13;
<h2>Printer Columns</h2>&#13;
&#13;
<p>The <code>kubectl</code> CLI<a data-primary="custom resource definitions (CRDs)" data-secondary="printer columns" data-type="indexterm" id="idm46336862974376"/><a data-primary="printer columns" data-type="indexterm" id="idm46336862973400"/><a data-primary="server-side printing" data-type="indexterm" id="idm46336862972728"/> tool uses server-side printing to render the output of <code>kubectl get</code>. This means that it queries the API server for the columns to display and the values in each row.</p>&#13;
&#13;
<p>Custom resources support server-side printer columns as well, via <code>additionalPrinterColumns</code>. They are called “additional” because the first column is always the name of the object. These columns are defined like this:</p>&#13;
<pre data-code-language="yaml" data-type="program-listing">&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">CustomResourceDefinition</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ats.cnat.programming-kubernetes.info</code><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">additionalPrinterColumns</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">(optional)</code><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">kubectl</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">column</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">name</code></em><code>&#13;
</code><code>    </code><code class="nt">type</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">OpenAPI</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">type</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">for</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">column</code></em><code>&#13;
</code><code>    </code><code class="nt">format</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">OpenAPI</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">format</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">for</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">column</code></em><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">(optional)</code><code>&#13;
</code><code>    </code><code class="nt">description</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">human-readable</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">description</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">of</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">column</code></em><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">(optional)</code><code>&#13;
</code><code>    </code><code class="nt">priority</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">integer,</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">always</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">zero</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">supported</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">by</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">kubectl</code></em><code>&#13;
</code><code>    </code><code class="nt">JSONPath</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">JSON</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">path</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">inside</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">CR</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">for</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">the</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">displayed</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">value</code></em><code>&#13;
</code></pre>&#13;
&#13;
<p>The <code>name</code> field is the column name, the <code>type</code> is an OpenAPI type as defined in the <a href="http://bit.ly/2N0DSY4">data types</a> section of the specification, and the <code>format</code> (as defined in the same document) is optional and might be interpreted by <code>kubectl</code> or other clients.</p>&#13;
&#13;
<p>Further, <code>description</code> is an optional human-readable string, used for documentation purposes. The <code>priority</code> controls in which verbosity mode of <code>kubectl</code> the column is displayed. At the time of this writing (with Kubernetes 1.14), only zero is supported, and all columns with higher priority are hidden.</p>&#13;
&#13;
<p>Finally, <code>JSONPath</code> defines which values are to be displayed. It is a simple JSON path inside of the CR. Here, “simple” means that it supports object field syntax like <code>.spec.foo.bar</code>, but not more complex JSON paths that loop over arrays or <span class="keep-together">similar</span>.</p>&#13;
&#13;
<p>With this, the example CRD from the introduction could be extended with <code>additionalPrinterColumns</code> like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">additionalPrinterColumns</code><code class="p">:</code> <code class="c1">#(optional)</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">schedule</code>&#13;
  <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
  <code class="nt">JSONPath</code><code class="p">:</code> <code class="l-Scalar-Plain">.spec.schedule</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">command</code>&#13;
  <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
  <code class="nt">JSONPath</code><code class="p">:</code> <code class="l-Scalar-Plain">.spec.command</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">phase</code>&#13;
  <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">string</code>&#13;
  <code class="nt">JSONPath</code><code class="p">:</code> <code class="l-Scalar-Plain">.status.phase</code></pre>&#13;
&#13;
<p>Then <code>kubectl</code> would render a <code>cnat</code> resource as follows:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>kubectl get ats&#13;
NAME  SCHEDULER             COMMAND             PHASE&#13;
foo   2019-07-03T02:00:00Z  <code class="nb">echo</code> <code class="s2">"hello world"</code>  Pending</pre>&#13;
&#13;
<p>Next up, we have a look at subresources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Subresources" data-type="sect2"><div class="sect2" id="crd-subresources">&#13;
<h2>Subresources</h2>&#13;
&#13;
<p>We<a data-primary="custom resource definitions (CRDs)" data-secondary="subresources" data-type="indexterm" id="CSsub04"/><a data-primary="subresources" data-type="indexterm" id="subres4"/> briefly mentioned subresources in <a data-type="xref" href="ch03.html#client-go-subresource">“Status Subresources: UpdateStatus”</a>. Subresources are special HTTP endpoints, using a suffix appended to the HTTP path of the normal resource. For example, the pod standard HTTP path is <em>/api/v1/namespace/<code>namespace</code>/pods/<code>name</code></em>. Pods have a number of subresources, such as <em>/logs</em>, <em>/portforward</em>, <em>/exec</em>, and <em>/status</em>.&#13;
The corresponding subresource HTTP paths are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>/api/v1/namespace/</em><code>namespace</code><em>/pods/</em><code>name</code><em>/logs</em></p>&#13;
</li>&#13;
<li>&#13;
<p><em>/api/v1/namespace/</em><code>namespace</code><em>/pods/</em><code>name</code><em>/portforward</em></p>&#13;
</li>&#13;
<li>&#13;
<p><em>/api/v1/namespace/</em><code>namespace</code><em>/pods/</em><code>name</code><em>/exec</em></p>&#13;
</li>&#13;
<li>&#13;
<p><em>/api/v1/namespace/</em><code>namespace</code><em>/pods/</em><code>name</code><em>/status</em></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The subresource endpoints use a different protocol than the main resource endpoint.</p>&#13;
&#13;
<p>At the time of this writing, custom resources support two subresources: <em>/scale</em> and <span class="keep-together"><em>/status</em></span>. Both are opt-in—that is, they must be explicitly enabled in the CRD.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Status subresource" data-type="sect3"><div class="sect3" id="status-subresource">&#13;
<h3>Status subresource</h3>&#13;
&#13;
<p>The <em>/status</em> subresource<a data-primary="status subresources" data-type="indexterm" id="idm46336862582888"/> is used to split the user-provided specification of a CR instance from the controller-provided status. The main motivation for this is privilege separation:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The user usually should not write status fields.</p>&#13;
</li>&#13;
<li>&#13;
<p>The controller should not write specification fields.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The<a data-primary="role-based access control (RBAC)" data-type="indexterm" id="idm46336862579000"/><a data-primary="access control" data-secondary="role-based access control (RBAC)" data-type="indexterm" id="idm46336862578296"/> RBAC mechanism for access control does not allow rules at that level of detail. Those rules are always per resource. The <em>/status</em> subresource solves this by providing two endpoints that are resources on their own. Each can be controlled with RBAC rules independently. This is often called a <em>spec-status split</em>. Here’s an example of such a rule for the <code>ats</code> resource, which applies only to the <em>/status</em> subresource (while <code>"ats"</code> would match the main resource):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Role</code>&#13;
<code class="nt">metadata</code><code class="p">:</code> <code class="l-Scalar-Plain">...</code>&#13;
<code class="nt">rules</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">resources</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"ats/status"</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"update"</code><code class="p-Indicator">,</code> <code class="s">"patch"</code><code class="p-Indicator">]</code></pre>&#13;
&#13;
<p>Resources (including custom resources) that have a <em>/status</em> subresource have changed semantics, also for the main resource endpoint:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>They ignore changes to the status on the main HTTP endpoint during create (the status is just dropped during a create) and updates.</p>&#13;
</li>&#13;
<li>&#13;
<p>Likewise, the <em>/status</em> subresource endpoint ignores changes outside of the status of the payload. A create operation on the <em>/status</em> endpoint is not possible.</p>&#13;
</li>&#13;
<li>&#13;
<p>Whenever something outside of <code>metadata</code> and outside of <code>status</code> changes (this especially means changes in the spec), the main resource endpoint will increase the <code>metadata.generation</code> value. This can be used as a trigger for a controller indicating that the user desire has changed.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Note<a data-primary="spec and a status section" data-type="indexterm" id="idm46336862481752"/> that usually both <code>spec</code> and <code>status</code> are sent in update requests, but technically you could leave out the respective other part in a request payload.</p>&#13;
&#13;
<p>Also note that the <em>/status</em> endpoint will ignore everything outside of the status, including metadata changes like labels or annotations.</p>&#13;
&#13;
<p>The spec-status split of a custom resource is enabled as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomResourceDefinition</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">subresources</code><code class="p">:</code>&#13;
    <code class="nt">status</code><code class="p">:</code> <code class="p-Indicator">{}</code>&#13;
  <code class="l-Scalar-Plain">...</code></pre>&#13;
&#13;
<p>Note here that the <code>status</code> field in that YAML fragment is assigned the empty object. This is the way to set a field that has no other properties. Just writing</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">subresources</code><code class="p">:</code>&#13;
  <code class="nt">status</code><code class="p">:</code></pre>&#13;
&#13;
<p>will result in a validation error because in YAML the result is a <code>null</code> value for <span class="keep-together"><code>status</code></span>.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Enabling the spec-status split is a breaking change for an API. Old controllers will write to the main endpoint. They won’t notice that the status is always ignored from the point where the split is activated. Likewise, a new controller can’t write to the new <em>/status</em> endpoint until the split is activated.</p>&#13;
</div>&#13;
&#13;
<p>In Kubernetes 1.13 and later, subresources can be configured per version. This allows us to introduce the <em>/status</em> subresource without a breaking change:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomResourceDefinition</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="l-Scalar-Plain">...</code>&#13;
  <code class="l-Scalar-Plain">versions</code><code class="p-Indicator">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">v1alpha1</code>&#13;
    <code class="nt">served</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
    <code class="nt">storage</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">v1beta1</code>&#13;
    <code class="nt">served</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
    <code class="nt">subresources</code><code class="p">:</code>&#13;
      <code class="nt">status</code><code class="p">:</code> <code class="p-Indicator">{}</code></pre>&#13;
&#13;
<p>This enables the <em>/status</em> subresource for <code>v1beta1</code>, but not for <code>v1alpha1</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The optimistic concurrency semantics (see <a data-type="xref" href="ch01.html#optimistic-concurrency">“Optimistic Concurrency”</a>) are the same as for the main resource endpoints; that is, <code>status</code> and <code>spec</code> share the same resource version counter and <em>/status</em> updates can conflict due to writes to the main resource, and vice versa. In other words, there is no split of <code>spec</code> and <code>status</code> on the storage layer.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scale subresource" data-type="sect3"><div class="sect3" id="scale-subresource">&#13;
<h3>Scale subresource</h3>&#13;
&#13;
<p>The<a data-primary="scale subresource" data-type="indexterm" id="idm46336862333800"/> second subresource available for custom resources is <em>/scale</em>. The <em>/scale</em> subresource is a (projective)<sup><a data-type="noteref" href="ch04.html#idm46336862332104" id="idm46336862332104-marker">2</a></sup> view on the resource, allowing us to view and to modify replica values only. This<a data-primary="replica integer value" data-type="indexterm" id="idm46336862330872"/> subresource is well known for resources like deployments and replica sets in Kubernetes, which obviously can be scaled up and down.</p>&#13;
&#13;
<p>The <code>kubectl scale</code> command makes use of the <em>/scale</em> subresource; for example, the following will modify the specified replica value in the given instance:</p>&#13;
<pre data-code-language="bash" data-type="program-listing">&#13;
<code class="nv">$ </code><code>kubectl</code><code> </code><code>scale</code><code> </code><code>--replicas</code><code class="o">=</code><code class="m">3</code><code> </code><em><code>your-custom-resource</code></em><code> </code><code>-v</code><code class="o">=</code><code>7</code><code>&#13;
</code><code>I0429</code><code> </code><code>21:17:53.138353</code><code>   </code><code class="m">66743</code><code> </code><code>round_trippers.go:383</code><code class="o">]</code><code> </code><code>PUT</code><code>&#13;
</code><code>https://</code><em><code>host</code></em><code>/apis/</code><em><code>group</code></em><code>/v1/</code><em><code>your-custom-resource</code></em><code>/scale</code><code>&#13;
</code></pre>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomResourceDefinition</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">subresources</code><code class="p">:</code>&#13;
    <code class="nt">scale</code><code class="p">:</code>&#13;
      <code class="nt">specReplicasPath</code><code class="p">:</code> <code class="l-Scalar-Plain">.spec.replicas</code>&#13;
      <code class="nt">statusReplicasPath</code><code class="p">:</code> <code class="l-Scalar-Plain">.status.replicas</code>&#13;
      <code class="nt">labelSelectorPath</code><code class="p">:</code> <code class="l-Scalar-Plain">.status.labelSelector</code>&#13;
  <code class="l-Scalar-Plain">...</code></pre>&#13;
&#13;
<p>With this, an update of the replica value is written to <code>spec.replicas</code> and returned from there during a <code>GET</code>.</p>&#13;
&#13;
<p>The label selector cannot be changed through the <em>/status</em> subresource, only read. Its purpose is to give a controller the information to count the corresponding objects. For example, the <code>ReplicaSet</code> controller counts the corresponding pods that satisfy this selector.</p>&#13;
&#13;
<p>The label selector is optional. If your custom resource semantics do not fit label selectors, just don’t specify the JSON path for one.</p>&#13;
&#13;
<p>In<a data-primary="kubectl scale --replicas 3" data-type="indexterm" id="idm46336862247624"/> the previous example of <code>kubectl scale --replicas=3 ...</code> the value <code>3</code> is written to <code>spec.replicas</code>. Any other simple JSON path can be used, of course; for example, <code>spec.instances</code> or <code>spec.size</code> would be a sensible field name, depending on the <span class="keep-together">context</span>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336862243928">&#13;
<h5>The Replica Integer Value Versus the Controller That Creates and Deletes Replicas</h5>&#13;
<p>We only speak about reading and setting the replica integer value in the custom resource. The actual semantics behind that—for example, the creation and deletion of instances of the actual replicas—must be implemented by a custom controller (see <a data-type="xref" href="ch01.html#ch_controllers-operators">“Controllers and Operators”</a>).</p>&#13;
</div></aside>&#13;
&#13;
<p>The kind of the object read from or written to the endpoint is <code>Scale</code> from the <code>autoscaling/v1</code> API group. Here is what it looks like:</p>&#13;
&#13;
<pre class="small" data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">Scale</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">TypeMeta</code> <code class="s">`json:",inline"`</code>&#13;
    <code class="c1">// Standard object metadata; More info: https://git.k8s.io/</code>&#13;
    <code class="c1">// community/contributors/devel/api-conventions.md#metadata.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">ObjectMeta</code> <code class="s">`json:"metadata,omitempty"`</code>&#13;
&#13;
    <code class="c1">// defines the behavior of the scale. More info: https://git.k8s.io/community/</code>&#13;
    <code class="c1">// contributors/devel/api-conventions.md#spec-and-status.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">Spec</code> <code class="nx">ScaleSpec</code> <code class="s">`json:"spec,omitempty"`</code>&#13;
&#13;
    <code class="c1">// current status of the scale. More info: https://git.k8s.io/community/</code>&#13;
    <code class="c1">// contributors/devel/api-conventions.md#spec-and-status. Read-only.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">Status</code> <code class="nx">ScaleStatus</code> <code class="s">`json:"status,omitempty"`</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// ScaleSpec describes the attributes of a scale subresource.</code>&#13;
<code class="kd">type</code> <code class="nx">ScaleSpec</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// desired number of instances for the scaled object.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">Replicas</code> <code class="kt">int32</code> <code class="s">`json:"replicas,omitempty"`</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// ScaleStatus represents the current status of a scale subresource.</code>&#13;
<code class="kd">type</code> <code class="nx">ScaleStatus</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// actual number of observed instances of the scaled object.</code>&#13;
    <code class="nx">Replicas</code> <code class="kt">int32</code> <code class="s">`json:"replicas"`</code>&#13;
&#13;
    <code class="c1">// label query over pods that should match the replicas count. This is the</code>&#13;
    <code class="c1">// same as the label selector but in the string format to avoid</code>&#13;
    <code class="c1">// introspection by clients. The string will be in the same</code>&#13;
    <code class="c1">// format as the query-param syntax. More info about label selectors:</code>&#13;
    <code class="c1">// http://kubernetes.io/docs/user-guide/labels#label-selectors.</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">Selector</code> <code class="kt">string</code> <code class="s">`json:"selector,omitempty"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>An instance will look like this:</p>&#13;
<pre data-code-language="yaml" data-type="program-listing">&#13;
<code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">cr-name</code></em><code>&#13;
</code><code>  </code><code class="nt">namespace</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">cr-namespace</code></em><code>&#13;
</code><code>  </code><code class="nt">uid</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">cr-uid</code></em><code>&#13;
</code><code>  </code><code class="nt">resourceVersion</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">cr-resource-version</code></em><code>&#13;
</code><code>  </code><code class="nt">creationTimestamp</code><code class="p">:</code><code> </code><em><code class="l-Scalar-Plain">cr-creation-timestamp</code></em><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">replicas</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">3</code><code>&#13;
</code><code>  </code><code class="nt">status</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">replicas</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">2</code><code>&#13;
</code><code>    </code><code class="nt">selector</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">environment</code><code class="nv"> </code><code class="s">=</code><code class="nv"> </code><code class="s">production</code><code class="s">"</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Note that the optimistic concurrency semantics are the same for the main resource and for the <em>/scale</em> subresource. That is, main resource writes can conflict with <em>/scale</em> writes, and vice versa.<a data-primary="" data-startref="CSsub04" data-type="indexterm" id="idm46336862055560"/><a data-primary="" data-startref="subres4" data-type="indexterm" id="idm46336862067272"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Developer’s View on Custom Resources" data-type="sect1"><div class="sect1" id="crd-dev">&#13;
<h1>A Developer’s View on Custom Resources</h1>&#13;
&#13;
<p>Custom resources<a data-primary="custom resource definitions (CRDs)" data-secondary="accessing" data-type="indexterm" id="idm46336862064504"/> can be accessed from Golang using a number of clients. We will concentrate on:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Using the <code>client-go</code> dynamic client (see <a data-type="xref" href="#dynamic-client">“Dynamic Client”</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Using a typed client:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>As provided by <a href="http://bit.ly/2ZFtDKd">kubernetes-sigs/controller-runtime</a> and used by the Operator SDK and Kubebuilder (see <a data-type="xref" href="#controller-runtime">“controller-runtime Client of Operator SDK and Kubebuilder”</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p>As generated by <code>client-gen</code>, like that in <a href="http://bit.ly/2FnmGWA"><em>k8s.io/client-go/kubernetes</em></a> (see <a data-type="xref" href="#clientgen-client">“Typed client created via client-gen”</a>)</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The choice of which client to use depends mainly on the context of the code to be written, especially the complexity of implemented logic and the requirements (e.g., to be dynamic and to support GVKs unknown at compile time).</p>&#13;
&#13;
<p>The preceding list of clients:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Decreases in the flexibility to handle unknown GVKs.</p>&#13;
</li>&#13;
<li>&#13;
<p>Increases in type safety.</p>&#13;
</li>&#13;
<li>&#13;
<p>Increases in the completeness of features of the Kubernetes API they provide.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dynamic Client" data-type="sect2"><div class="sect2" id="dynamic-client">&#13;
<h2>Dynamic Client</h2>&#13;
&#13;
<p>The<a data-primary="client-go" data-secondary="custom resource access" data-type="indexterm" id="idm46336862009176"/><a data-primary="custom resource definitions (CRDs)" data-secondary="accessing with client-go dynamic client" data-type="indexterm" id="idm46336862008440"/><a data-primary="dynamic clients" data-type="indexterm" id="idm46336862007560"/><a data-primary="clients" data-secondary="dynamic clients" data-type="indexterm" id="idm46336862006888"/> dynamic client in <a href="http://bit.ly/2Y6eeSK"><em>k8s.io/client-go/dynamic</em></a> is totally agnostic to known GVKs. It does not even use any Go types other than <a href="http://bit.ly/2WYZ6oS"><em>unstructured.Unstructured</em></a>, which wraps just <code>json.Unmarshal</code> and its output.</p>&#13;
&#13;
<p>The dynamic client makes use of neither a scheme nor a RESTMapper. This means that the developer has to provide all the knowledge about types manually by providing a resource (see <a data-type="xref" href="ch03.html#resources">“Resources”</a>) in the form of a GVR:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersionResource</code><code class="p">{</code>&#13;
  <code class="nx">Group</code><code class="p">:</code> <code class="s">"apps"</code><code class="p">,</code>&#13;
  <code class="nx">Version</code><code class="p">:</code> <code class="s">"v1"</code><code class="p">,</code>&#13;
  <code class="nx">Resource</code><code class="p">:</code> <code class="s">"deployments"</code><code class="p">,</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If<a data-primary="REST config" data-type="indexterm" id="idm46336861990968"/> a REST client config is available (see <a data-type="xref" href="ch03.html#rest-client-config">“Creating and Using a Client”</a>), the dynamic client can be created in one line:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">client</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">cfg</code><code class="p">)</code></pre>&#13;
&#13;
<p>The REST access to a given GVR is just as simple:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">client</code><code class="p">.</code><code class="nx">Resource</code><code class="p">(</code><code class="nx">gvr</code><code class="p">).</code>&#13;
   <code class="nx">Namespace</code><code class="p">(</code><code class="nx">namespace</code><code class="p">).</code><code class="nx">Get</code><code class="p">(</code><code class="s">"foo"</code><code class="p">,</code> <code class="nx">metav1</code><code class="p">.</code><code class="nx">GetOptions</code><code class="p">{})</code></pre>&#13;
&#13;
<p>This gives you the deployment <code>foo</code> in the given namespace.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You must know the scope of the resource (i.e., whether it is namespaced or cluster-scoped). Cluster-scoped resources just leave out the <code>Namespace(namespace)</code> call.</p>&#13;
</div>&#13;
&#13;
<p>The input and output of the dynamic client is an <code>*unstructured.Unstructured</code>—that is, an object that contains the same data structure that <code>json.Unmarshal</code> would output on unmarshaling:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Objects are represented by <code>map[string]interface{}</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Arrays are represented by <code>[]interface{}</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Primitive types are <code>string</code>, <code>bool</code>, <code>float64</code>, or <code>int64</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The method <code>UnstructuredContent()</code> provides access to this data structure inside of an unstructured object (we can also just access <code>Unstructured.Object</code>). There are helpers in the same package to make retrieval of fields easy and manipulation of the object possible—for example:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">name</code><code class="p">,</code> <code class="nx">found</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">unstructured</code><code class="p">.</code><code class="nx">NestedString</code><code class="p">(</code><code class="nx">u</code><code class="p">.</code><code class="nx">Object</code><code class="p">,</code> <code class="s">"metadata"</code><code class="p">,</code> <code class="s">"name"</code><code class="p">)</code></pre>&#13;
&#13;
<p>which returns the name of the deployment—<code>"foo"</code> in this case. <code>found</code> is true if the field was actually found (not only empty, but actually existing). <code>err</code> reports if the type of an existing field is unexpected (i.e., not a string in this case). Other helpers are the generic ones, once with a deep copy of the result and once without:</p>&#13;
&#13;
<pre class="small" data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">NestedFieldCopy</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{},</code> <code class="nx">fields</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code>&#13;
  <code class="p">(</code><code class="kd">interface</code><code class="p">{},</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="kd">func</code> <code class="nx">NestedFieldNoCopy</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{},</code> <code class="nx">fields</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code>&#13;
  <code class="p">(</code><code class="kd">interface</code><code class="p">{},</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>There are other typed variants that do a type-cast and return an error if that fails:</p>&#13;
&#13;
<pre class="small" data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">NestedBool</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{},</code> <code class="nx">fields</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="kt">bool</code><code class="p">,</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="kd">func</code> <code class="nx">NestedFloat64</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{},</code> <code class="nx">fields</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code>&#13;
  <code class="p">(</code><code class="kt">float64</code><code class="p">,</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="kd">func</code> <code class="nx">NestedInt64</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{},</code> <code class="nx">fields</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code> <code class="p">(</code><code class="kt">int64</code><code class="p">,</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="kd">func</code> <code class="nx">NestedStringSlice</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{},</code> <code class="nx">fields</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code>&#13;
  <code class="p">([]</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="kd">func</code> <code class="nx">NestedSlice</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{},</code> <code class="nx">fields</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code>&#13;
  <code class="p">([]</code><code class="kd">interface</code><code class="p">{},</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
<code class="kd">func</code> <code class="nx">NestedStringMap</code><code class="p">(</code><code class="nx">obj</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kd">interface</code><code class="p">{},</code> <code class="nx">fields</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code>&#13;
  <code class="p">(</code><code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code><code class="p">,</code> <code class="kt">bool</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code></pre>&#13;
&#13;
<p>And finally a generic setter:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="nx">SetNestedField</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">path</code><code class="o">...</code><code class="p">)</code></pre>&#13;
&#13;
<p>The dynamic client is used in Kubernetes itself for controllers that are generic, like the garbage collection controller, which deletes objects whose parents have disappeared. The garbage collection controller works with any resource in the system and hence makes extensive use of the dynamic client.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Typed Clients" data-type="sect2"><div class="sect2" id="idm46336862010696">&#13;
<h2>Typed Clients</h2>&#13;
&#13;
<p>Typed clients<a data-primary="custom resource definitions (CRDs)" data-secondary="accessing with typed clients" data-type="indexterm" id="CRtypes04"/><a data-primary="typed clients" data-type="indexterm" id="types4"/><a data-primary="clients" data-secondary="typed clients" data-type="indexterm" id="CLtype04"/> do not use <code>map[string]interface{}</code>-like generic data structures but instead use real<a data-primary="Golang types" data-type="indexterm" id="idm46336861589832"/> Golang types, which are different and specific for each GVK. They are much easier to use, have considerably increased type safety, and make code much more concise and readable. On the downside, they are less flexible because the processed types have to be known at compile time, and those clients are generated, and this adds complexity.</p>&#13;
&#13;
<p>Before going into two implementations of typed clients, let’s look into the representation of kinds in the Golang type system (see <a data-type="xref" href="ch03.html#api-machinery-core">“API Machinery in Depth”</a> for the theory behind the Kubernetes type system).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Anatomy of a type" data-type="sect3"><div class="sect3" id="anatomy-of-CRD-types">&#13;
<h3>Anatomy of a type</h3>&#13;
&#13;
<p>Kinds<a data-primary="kinds" data-secondary="typed clients and" data-type="indexterm" id="idm46336861580440"/> are represented as Golang structs. Usually the struct is named as the kind (though technically it doesn’t have to be) and is placed in a package corresponding to the group and version of the GVK at hand. A common convention is to place the GVK <em><code>group</code></em>/<em><code>version</code></em>.<em><code>Kind</code></em> into a Go package:</p>&#13;
<pre data-type="program-listing">&#13;
pkg/apis/<em>group</em>/<em>version</em>&#13;
</pre>&#13;
&#13;
<p>and define a Golang struct <em><code>Kind</code></em> in the file <em>types.go</em>.</p>&#13;
&#13;
<p>Every Golang type corresponding to a GVK embeds the <code>TypeMeta</code> struct from the package <a href="http://bit.ly/2Y5HdWT"><em>k8s.io/apimachinery/pkg/apis/meta/v1</em></a>. <code>TypeMeta</code> just consists of the <code>Kind</code> and <code>ApiVersion</code> fields:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">TypeMeta</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">APIVersion</code> <code class="kt">string</code> <code class="s">`json:"apiVersion,omitempty" yaml:"apiVersion,omitempty"`</code>&#13;
    <code class="c1">// +optional</code>&#13;
    <code class="nx">Kind</code> <code class="kt">string</code> <code class="s">`json:"kind,omitempty" yaml:"kind,omitempty"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In addition, every top-level kind—that is, one that has its own endpoint and therefore one (or more) corresponding GVRs (see <a data-type="xref" href="ch03.html#RESTMapping">“REST Mapping”</a>)—has to store a name, a namespace for namespaced resources, and a pretty long number of further metalevel fields. All these are stored in a struct called <code>ObjectMeta</code> in the package <a href="http://bit.ly/2XSt8eo"><em>k8s.io/apimachinery/pkg/apis/meta/v1</em></a>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">ObjectMeta</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">Name</code> <code class="kt">string</code> <code class="s">`json:"name,omitempty"`</code>&#13;
    <code class="nx">Namespace</code> <code class="kt">string</code> <code class="s">`json:"namespace,omitempty"`</code>&#13;
    <code class="nx">UID</code> <code class="nx">types</code><code class="p">.</code><code class="nx">UID</code> <code class="s">`json:"uid,omitempty"`</code>&#13;
    <code class="nx">ResourceVersion</code> <code class="kt">string</code> <code class="s">`json:"resourceVersion,omitempty"`</code>&#13;
    <code class="nx">CreationTimestamp</code> <code class="nx">Time</code> <code class="s">`json:"creationTimestamp,omitempty"`</code>&#13;
    <code class="nx">DeletionTimestamp</code> <code class="o">*</code><code class="nx">Time</code> <code class="s">`json:"deletionTimestamp,omitempty"`</code>&#13;
    <code class="nx">Labels</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code> <code class="s">`json:"labels,omitempty"`</code>&#13;
    <code class="nx">Annotations</code> <code class="kd">map</code><code class="p">[</code><code class="kt">string</code><code class="p">]</code><code class="kt">string</code> <code class="s">`json:"annotations,omitempty"`</code>&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>There are a number of additional fields. We highly recommend you read through the <a href="http://bit.ly/2IutNyh">extensive inline documentation</a>, because it gives a good picture of the core functionality of Kubernetes objects.</p>&#13;
&#13;
<p>Kubernetes top-level types (i.e., those that have an embedded <code>TypeMeta</code>, and an embedded <code>ObjectMeta</code>, and—in this case—are persisted into <code>etcd</code>) look very similar to each other in the sense that they usually have a <code>spec</code> and a <code>status</code>. See this example of a deployment from <a href="http://bit.ly/2RroTFb"><em>k8s.io/kubernetes/apps/v1/types.go</em></a>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">Deployment</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">TypeMeta</code> <code class="s">`json:",inline"`</code>&#13;
    <code class="nx">metav1</code><code class="p">.</code><code class="nx">ObjectMeta</code> <code class="s">`json:"metadata,omitempty"`</code>&#13;
&#13;
    <code class="nx">Spec</code> <code class="nx">DeploymentSpec</code> <code class="s">`json:"spec,omitempty"`</code>&#13;
    <code class="nx">Status</code> <code class="nx">DeploymentStatus</code> <code class="s">`json:"status,omitempty"`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>While the actual content of the types for <code>spec</code> and <code>status</code> differs significantly between different types, this split into <code>spec</code> and <code>status</code> is a common theme or even a convention in Kubernetes, though it’s not technically required. Hence, it is good practice to follow this structure of CRDs as well. Some CRD features even require this structure; for example, the <em>/status</em> subresource for custom resources (see <a data-type="xref" href="#status-subresource">“Status subresource”</a>)—when enabled—always applies to the <code>status</code> substructure only of the custom resource instance. It cannot be renamed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Golang package structure" data-type="sect3"><div class="sect3" id="idm46336861581816">&#13;
<h3>Golang package structure</h3>&#13;
&#13;
<p>As<a data-primary="Golang package structure" data-type="indexterm" id="idm46336861365352"/> we have seen, the Golang types are traditionally placed in a file called <em>types.go</em> in the package <em>pkg/apis/<code>group</code>/<code>version</code></em>. In addition to that file, there are a couple more files we want to go through now. Some of them are manually written by the developer, while some are generated with code generators. See <a data-type="xref" href="ch05.html#ch_autocodegen">Chapter 5</a> for details.</p>&#13;
&#13;
<p>The <em>doc.go</em> file describes the API’s purpose and includes a number of package-global code generation tags:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Package v1alpha1 contains the cnat v1alpha1 API group</code>&#13;
<code class="c1">//</code>&#13;
<code class="c1">// +k8s:deepcopy-gen=package</code>&#13;
<code class="c1">// +groupName=cnat.programming-kubernetes.info</code>&#13;
<code class="kn">package</code> <code class="nx">v1alpha1</code></pre>&#13;
&#13;
<p>Next, <em>register.go</em> includes helpers to register the custom resource Golang types into a scheme (see <a data-type="xref" href="ch03.html#scheme">“Scheme”</a>):</p>&#13;
<pre data-code-language="go" data-type="programlisting">&#13;
<code class="kn">package</code><code> </code><em><code class="nx">version</code></em><code>&#13;
</code><code>&#13;
</code><code class="kn">import</code><code> </code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="nx">metav1</code><code> </code><code class="s">"k8s.io/apimachinery/pkg/apis/meta/v1"</code><code>&#13;
</code><code>    </code><code class="s">"k8s.io/apimachinery/pkg/runtime"</code><code>&#13;
</code><code>    </code><code class="s">"k8s.io/apimachinery/pkg/runtime/schema"</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="nx">group</code><code> </code><code class="s">"</code><em><code class="s">repo</code></em><code class="s">/pkg/apis/</code><em><code class="s">group</code></em><code class="s">"</code><code>&#13;
</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="c1">// SchemeGroupVersion is group version used to register these objects&#13;
</code><code class="kd">var</code><code> </code><code class="nx">SchemeGroupVersion</code><code> </code><code class="p">=</code><code> </code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupVersion</code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="nx">Group</code><code class="p">:</code><code> </code><code class="nx">group</code><code class="p">.</code><code class="nx">GroupName</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="nx">Version</code><code class="p">:</code><code> </code><code class="s">"</code><em><code class="s">version</code></em><code class="s">"</code><code class="p">,</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="c1">// Kind takes an unqualified kind and returns back a Group qualified GroupKind&#13;
</code><code class="kd">func</code><code> </code><code class="nx">Kind</code><code class="p">(</code><code class="nx">kind</code><code> </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupKind</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="nx">SchemeGroupVersion</code><code class="p">.</code><code class="nx">WithKind</code><code class="p">(</code><code class="nx">kind</code><code class="p">)</code><code class="p">.</code><code class="nx">GroupKind</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="c1">// Resource takes an unqualified resource and returns a Group&#13;
</code><code class="c1">// qualified GroupResource&#13;
</code><code class="kd">func</code><code> </code><code class="nx">Resource</code><code class="p">(</code><code class="nx">resource</code><code> </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="nx">schema</code><code class="p">.</code><code class="nx">GroupResource</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="nx">SchemeGroupVersion</code><code class="p">.</code><code class="nx">WithResource</code><code class="p">(</code><code class="nx">resource</code><code class="p">)</code><code class="p">.</code><code class="nx">GroupResource</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="kd">var</code><code> </code><code class="p">(</code><code>&#13;
</code><code>    </code><code class="nx">SchemeBuilder</code><code> </code><code class="p">=</code><code> </code><code class="nx">runtime</code><code class="p">.</code><code class="nx">NewSchemeBuilder</code><code class="p">(</code><code class="nx">addKnownTypes</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="nx">AddToScheme</code><code>   </code><code class="p">=</code><code> </code><code class="nx">SchemeBuilder</code><code class="p">.</code><code class="nx">AddToScheme</code><code>&#13;
</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code class="c1">// Adds the list of known types to Scheme.&#13;
</code><code class="kd">func</code><code> </code><code class="nx">addKnownTypes</code><code class="p">(</code><code class="nx">scheme</code><code> </code><code class="o">*</code><code class="nx">runtime</code><code class="p">.</code><code class="nx">Scheme</code><code class="p">)</code><code> </code><code class="kt">error</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="nx">scheme</code><code class="p">.</code><code class="nx">AddKnownTypes</code><code class="p">(</code><code class="nx">SchemeGroupVersion</code><code class="p">,</code><code>&#13;
</code><code>        </code><code class="o">&amp;</code><code class="nx">SomeKind</code><code class="p">{</code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code>        </code><code class="o">&amp;</code><code class="nx">SomeKindList</code><code class="p">{</code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="nx">metav1</code><code class="p">.</code><code class="nx">AddToGroupVersion</code><code class="p">(</code><code class="nx">scheme</code><code class="p">,</code><code> </code><code class="nx">SchemeGroupVersion</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="kc">nil</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Then, <em>zz_generated.deepcopy.go</em> defines<a data-primary="deep-copy" data-secondary="deep-copy methods" data-type="indexterm" id="idm46336861298328"/> deep-copy methods on the custom resource Golang top-level types (i.e., <code>SomeKind</code> and <code>SomeKindList</code> in the preceding example code). In addition, all substructs (like those for the <code>spec</code> and <code>status</code>) become deep-copyable as well.</p>&#13;
&#13;
<p>Because the example uses the tag <code>+k8s:deepcopy-gen=package</code> in <em>doc.go</em>, the deep-copy generation is on an opt-out basis; that is, <code>DeepCopy</code> methods are generated for every type in the package that does not opt out with <code>+k8s:deepcopy-gen=false</code>. See <a data-type="xref" href="ch05.html#ch_autocodegen">Chapter 5</a> and especially <a data-type="xref" href="ch05.html#deepcopy-tags">“deepcopy-gen Tags”</a> for more details.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Typed client created via client-gen" data-type="sect3"><div class="sect3" id="clientgen-client">&#13;
<h3>Typed client created via client-gen</h3>&#13;
&#13;
<p>With the API package <em>pkg/apis/<code>group</code>/<code>version</code></em> in place, the client generator <code>client-gen</code> creates a typed client (see <a data-type="xref" href="ch05.html#ch_autocodegen">Chapter 5</a> for details, especially <a data-type="xref" href="ch05.html#clientgen-tags">“client-gen Tags”</a>), in <em>pkg/generated/clientset/versioned</em> by default (pkg/client/clientset/versioned in old versions of the generator). More precisely, the generated top-level object is a client set. It subsumes a number of API groups, versions, and resources.</p>&#13;
&#13;
<p>The <a href="http://bit.ly/2GdcikH">top-level file</a> looks like the following:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// Code generated by client-gen. DO NOT EDIT.</code>&#13;
&#13;
<code class="kn">package</code> <code class="nx">versioned</code>&#13;
&#13;
<code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="nx">discovery</code> <code class="s">"k8s.io/client-go/discovery"</code>&#13;
    <code class="nx">rest</code> <code class="s">"k8s.io/client-go/rest"</code>&#13;
    <code class="nx">flowcontrol</code> <code class="s">"k8s.io/client-go/util/flowcontrol"</code>&#13;
&#13;
    <code class="nx">cnatv1alpha1</code> <code class="err">"</code><code class="o">.../</code><code class="nx">cnat</code><code class="o">/</code><code class="nx">cnat</code><code class="o">-</code><code class="nx">client</code><code class="o">-</code><code class="k">go</code><code class="o">/</code><code class="nx">pkg</code><code class="o">/</code><code class="nx">generated</code><code class="o">/</code><code class="nx">clientset</code><code class="o">/</code><code class="nx">versioned</code><code class="o">/</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="kd">type</code> <code class="nx">Interface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Discovery</code><code class="p">()</code> <code class="nx">discovery</code><code class="p">.</code><code class="nx">DiscoveryInterface</code>&#13;
    <code class="nx">CnatV1alpha1</code><code class="p">()</code> <code class="nx">cnatv1alpha1</code><code class="p">.</code><code class="nx">CnatV1alpha1Interface</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Clientset contains the clients for groups. Each group has exactly one</code>&#13;
<code class="c1">// version included in a Clientset.</code>&#13;
<code class="kd">type</code> <code class="nx">Clientset</code> <code class="kd">struct</code> <code class="p">{</code>&#13;
    <code class="o">*</code><code class="nx">discovery</code><code class="p">.</code><code class="nx">DiscoveryClient</code>&#13;
    <code class="nx">cnatV1alpha1</code> <code class="o">*</code><code class="nx">cnatv1alpha1</code><code class="p">.</code><code class="nx">CnatV1alpha1Client</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// CnatV1alpha1 retrieves the CnatV1alpha1Client</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">c</code> <code class="o">*</code><code class="nx">Clientset</code><code class="p">)</code> <code class="nx">CnatV1alpha1</code><code class="p">()</code> <code class="nx">cnatv1alpha1</code><code class="p">.</code><code class="nx">CnatV1alpha1Interface</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">c</code><code class="p">.</code><code class="nx">cnatV1alpha1</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Discovery retrieves the DiscoveryClient</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">c</code> <code class="o">*</code><code class="nx">Clientset</code><code class="p">)</code> <code class="nx">Discovery</code><code class="p">()</code> <code class="nx">discovery</code><code class="p">.</code><code class="nx">DiscoveryInterface</code> <code class="p">{</code>&#13;
   <code class="o">...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// NewForConfig creates a new Clientset for the given config.</code>&#13;
<code class="kd">func</code> <code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">c</code> <code class="o">*</code><code class="nx">rest</code><code class="p">.</code><code class="nx">Config</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">Clientset</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="o">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The client set is represented by the interface <code>Interface</code> and gives access to the API group client interface for each version—for example, <code>CnatV1alpha1Interface</code> in this sample code:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">type</code> <code class="nx">CnatV1alpha1Interface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">RESTClient</code><code class="p">()</code> <code class="nx">rest</code><code class="p">.</code><code class="nx">Interface</code>&#13;
    <code class="nx">AtsGetter</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// AtsGetter has a method to return a AtInterface.</code>&#13;
<code class="c1">// A group's client should implement this interface.</code>&#13;
<code class="kd">type</code> <code class="nx">AtsGetter</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Ats</code><code class="p">(</code><code class="nx">namespace</code> <code class="kt">string</code><code class="p">)</code> <code class="nx">AtInterface</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// AtInterface has methods to work with At resources.</code>&#13;
<code class="kd">type</code> <code class="nx">AtInterface</code> <code class="kd">interface</code> <code class="p">{</code>&#13;
    <code class="nx">Create</code><code class="p">(</code><code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">At</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">At</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Update</code><code class="p">(</code><code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">At</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">At</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">UpdateStatus</code><code class="p">(</code><code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">At</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">At</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Delete</code><code class="p">(</code><code class="nx">name</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">options</code> <code class="o">*</code><code class="nx">v1</code><code class="p">.</code><code class="nx">DeleteOptions</code><code class="p">)</code> <code class="kt">error</code>&#13;
    <code class="nx">DeleteCollection</code><code class="p">(</code><code class="nx">options</code> <code class="o">*</code><code class="nx">v1</code><code class="p">.</code><code class="nx">DeleteOptions</code><code class="p">,</code> <code class="nx">listOptions</code> <code class="nx">v1</code><code class="p">.</code><code class="nx">ListOptions</code><code class="p">)</code> <code class="kt">error</code>&#13;
    <code class="nx">Get</code><code class="p">(</code><code class="nx">name</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">options</code> <code class="nx">v1</code><code class="p">.</code><code class="nx">GetOptions</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">At</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">List</code><code class="p">(</code><code class="nx">opts</code> <code class="nx">v1</code><code class="p">.</code><code class="nx">ListOptions</code><code class="p">)</code> <code class="p">(</code><code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">AtList</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Watch</code><code class="p">(</code><code class="nx">opts</code> <code class="nx">v1</code><code class="p">.</code><code class="nx">ListOptions</code><code class="p">)</code> <code class="p">(</code><code class="nx">watch</code><code class="p">.</code><code class="nx">Interface</code><code class="p">,</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">Patch</code><code class="p">(</code><code class="nx">name</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">pt</code> <code class="nx">types</code><code class="p">.</code><code class="nx">PatchType</code><code class="p">,</code> <code class="nx">data</code> <code class="p">[]</code><code class="kt">byte</code><code class="p">,</code> <code class="nx">subresources</code> <code class="o">...</code><code class="kt">string</code><code class="p">)</code>&#13;
        <code class="p">(</code><code class="nx">result</code> <code class="o">*</code><code class="nx">v1alpha1</code><code class="p">.</code><code class="nx">At</code><code class="p">,</code> <code class="nx">err</code> <code class="kt">error</code><code class="p">)</code>&#13;
    <code class="nx">AtExpansion</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>An instance of a client set can be created with the <code>NewForConfig</code> helper function. This is analogous to the clients for core Kubernetes resources discussed in <a data-type="xref" href="ch03.html#rest-client-config">“Creating and Using a Client”</a>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="nx">metav1</code> <code class="s">"k8s.io/apimachinery/pkg/apis/meta/v1"</code>&#13;
    <code class="s">"k8s.io/client-go/tools/clientcmd"</code>&#13;
&#13;
    <code class="nx">client</code> <code class="s">"github.com/.../cnat/cnat-client-go/pkg/generated/clientset/versioned"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="nx">kubeconfig</code> <code class="p">=</code> <code class="nx">flag</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"kubeconfig"</code><code class="p">,</code> <code class="s">"~/.kube/config"</code><code class="p">,</code> <code class="s">"kubeconfig file"</code><code class="p">)</code>&#13;
<code class="nx">flag</code><code class="p">.</code><code class="nx">Parse</code><code class="p">()</code>&#13;
<code class="nx">config</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientcmd</code><code class="p">.</code><code class="nx">BuildConfigFromFlags</code><code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="o">*</code><code class="nx">kubeconfig</code><code class="p">)</code>&#13;
<code class="nx">clientset</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">client</code><code class="p">.</code><code class="nx">NewForConfig</code><code class="p">(</code><code class="nx">config</code><code class="p">)</code>&#13;
&#13;
<code class="nx">ats</code> <code class="o">:=</code> <code class="nx">clientset</code><code class="p">.</code><code class="nx">CnatV1alpha1Interface</code><code class="p">().</code><code class="nx">Ats</code><code class="p">(</code><code class="s">"default"</code><code class="p">)</code>&#13;
<code class="nx">book</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">ats</code><code class="p">.</code><code class="nx">Get</code><code class="p">(</code><code class="s">"kubernetes-programming"</code><code class="p">,</code> <code class="nx">metav1</code><code class="p">.</code><code class="nx">GetOptions</code><code class="p">{})</code></pre>&#13;
&#13;
<p>As you can see, the code generation machinery allows us to program logic for custom resources in the very same way as for core Kubernetes resources. Higher-level tools like informers are also available; see <code>informer-gen</code> in <a data-type="xref" href="ch05.html#ch_autocodegen">Chapter 5</a>.<a data-primary="" data-startref="CRtypes04" data-type="indexterm" id="idm46336860550488"/><a data-primary="" data-startref="types4" data-type="indexterm" id="idm46336860549512"/><a data-primary="" data-startref="CLtype04" data-type="indexterm" id="idm46336860548568"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="controller-runtime Client of Operator SDK and Kubebuilder" data-type="sect2"><div class="sect2" id="controller-runtime">&#13;
<h2>controller-runtime Client of Operator SDK and Kubebuilder</h2>&#13;
&#13;
<p>For<a data-primary="controller-runtime client" data-type="indexterm" id="idm46336860545464"/><a data-primary="clients" data-secondary="controller-runtime client" data-type="indexterm" id="idm46336860544760"/><a data-primary="custom resource definitions (CRDs)" data-secondary="accessing with controller-runtime client" data-type="indexterm" id="idm46336860543848"/><a data-primary="Operator SDK" data-secondary="controller-runtime client of" data-type="indexterm" id="idm46336860542968"/><a data-primary="Kubebuilder" data-secondary="controller-runtime client of" data-type="indexterm" id="idm46336860542008"/> the sake of completeness, we want to take a quick look at the third client, which is listed as the second option in <a data-type="xref" href="#crd-dev">“A Developer’s View on Custom Resources”</a>. The <code>controller-runtime</code> project provides the basis for the operator solutions Operator SDK and Kubebuilder presented in <a data-type="xref" href="ch06.html#ch_operator-solutions">Chapter 6</a>.&#13;
It includes a client that uses the Go types presented in <a data-type="xref" href="#anatomy-of-CRD-types">“Anatomy of a type”</a>.</p>&#13;
&#13;
<p>In contrast to the <code>client-gen</code>–generated client of the previous <a data-type="xref" href="#clientgen-client">“Typed client created via client-gen”</a>, and similarly to the <a data-type="xref" href="#dynamic-client">“Dynamic Client”</a>, this client is one instance, capable of handling any kind that is registered in a given scheme.</p>&#13;
&#13;
<p>It<a data-primary="discovery" data-type="indexterm" id="idm46336860534936"/> uses discovery information from the API server to map the kinds to HTTP paths. Note that <a data-type="xref" href="ch06.html#ch_operator-solutions">Chapter 6</a> will go into greater detail on how this client is used as part of those two operator solutions.</p>&#13;
&#13;
<p>Here is a quick example of how to use <code>controller-runtime</code>:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"flag"</code>&#13;
&#13;
    <code class="nx">corev1</code> <code class="s">"k8s.io/api/core/v1"</code>&#13;
    <code class="nx">metav1</code> <code class="s">"k8s.io/apimachinery/pkg/apis/meta/v1"</code>&#13;
    <code class="s">"k8s.io/client-go/kubernetes/scheme"</code>&#13;
    <code class="s">"k8s.io/client-go/tools/clientcmd"</code>&#13;
&#13;
    <code class="nx">runtimeclient</code> <code class="s">"sigs.k8s.io/controller-runtime/pkg/client"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="nx">kubeconfig</code> <code class="p">=</code> <code class="nx">flag</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"kubeconfig"</code><code class="p">,</code> <code class="s">"~/.kube/config"</code><code class="p">,</code> <code class="s">"kubeconfig file path"</code><code class="p">)</code>&#13;
<code class="nx">flag</code><code class="p">.</code><code class="nx">Parse</code><code class="p">()</code>&#13;
<code class="nx">config</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientcmd</code><code class="p">.</code><code class="nx">BuildConfigFromFlags</code><code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="o">*</code><code class="nx">kubeconfig</code><code class="p">)</code>&#13;
&#13;
<code class="nx">cl</code><code class="p">,</code> <code class="nx">_</code> <code class="o">:=</code> <code class="nx">runtimeclient</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="nx">config</code><code class="p">,</code> <code class="nx">client</code><code class="p">.</code><code class="nx">Options</code><code class="p">{</code>&#13;
    <code class="nx">Scheme</code><code class="p">:</code> <code class="nx">scheme</code><code class="p">.</code><code class="nx">Scheme</code><code class="p">,</code>&#13;
<code class="p">})</code>&#13;
<code class="nx">podList</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">corev1</code><code class="p">.</code><code class="nx">PodList</code><code class="p">{}</code>&#13;
<code class="nx">err</code> <code class="o">:=</code> <code class="nx">cl</code><code class="p">.</code><code class="nx">List</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">TODO</code><code class="p">(),</code> <code class="nx">client</code><code class="p">.</code><code class="nx">InNamespace</code><code class="p">(</code><code class="s">"default"</code><code class="p">),</code> <code class="nx">podList</code><code class="p">)</code></pre>&#13;
&#13;
<p>The client object’s <code>List()</code> method accepts any <code>runtime.Object</code> registered in the given scheme, which in this case is the one borrowed from <code>client-go</code> with all standard Kubernetes kinds being registered. Internally, the client uses the given scheme to map the Golang type <code>*corev1.PodList</code> to a GVK. In a second step, the <code>List()</code> method uses discovery information to get the GVR for pods, which is <code>schema.GroupVersionResource{"", "v1", "pods"}</code>, and therefore accesses <em>/api/v1/namespace/default/pods</em> to get the list of pods in the passed namespace.</p>&#13;
&#13;
<p>The same logic can be used with custom resources. The main difference is to use a custom scheme that contains the passed Go type:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">import</code> <code class="p">(</code>&#13;
    <code class="s">"flag"</code>&#13;
&#13;
    <code class="nx">corev1</code> <code class="s">"k8s.io/api/core/v1"</code>&#13;
    <code class="nx">metav1</code> <code class="s">"k8s.io/apimachinery/pkg/apis/meta/v1"</code>&#13;
    <code class="s">"k8s.io/client-go/kubernetes/scheme"</code>&#13;
    <code class="s">"k8s.io/client-go/tools/clientcmd"</code>&#13;
&#13;
    <code class="nx">runtimeclient</code> <code class="s">"sigs.k8s.io/controller-runtime/pkg/client"</code>&#13;
    <code class="nx">cnatv1alpha1</code> <code class="s">"github.com/.../cnat/cnat-kubebuilder/pkg/apis/cnat/v1alpha1"</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="nx">kubeconfig</code> <code class="p">=</code> <code class="nx">flag</code><code class="p">.</code><code class="nx">String</code><code class="p">(</code><code class="s">"kubeconfig"</code><code class="p">,</code> <code class="s">"~/.kube/config"</code><code class="p">,</code> <code class="s">"kubeconfig file"</code><code class="p">)</code>&#13;
<code class="nx">flag</code><code class="p">.</code><code class="nx">Parse</code><code class="p">()</code>&#13;
<code class="nx">config</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">clientcmd</code><code class="p">.</code><code class="nx">BuildConfigFromFlags</code><code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="o">*</code><code class="nx">kubeconfig</code><code class="p">)</code>&#13;
&#13;
<code class="nx">crScheme</code> <code class="o">:=</code> <code class="nx">runtime</code><code class="p">.</code><code class="nx">NewScheme</code><code class="p">()</code>&#13;
<code class="nx">cnatv1alpha1</code><code class="p">.</code><code class="nx">AddToScheme</code><code class="p">(</code><code class="nx">crScheme</code><code class="p">)</code>&#13;
&#13;
<code class="nx">cl</code><code class="p">,</code> <code class="nx">_</code> <code class="o">:=</code> <code class="nx">runtimeclient</code><code class="p">.</code><code class="nx">New</code><code class="p">(</code><code class="nx">config</code><code class="p">,</code> <code class="nx">client</code><code class="p">.</code><code class="nx">Options</code><code class="p">{</code>&#13;
    <code class="nx">Scheme</code><code class="p">:</code> <code class="nx">crScheme</code><code class="p">,</code>&#13;
<code class="p">})</code>&#13;
<code class="nx">list</code> <code class="o">:=</code> <code class="o">&amp;</code><code class="nx">cnatv1alpha1</code><code class="p">.</code><code class="nx">AtList</code><code class="p">{}</code>&#13;
<code class="nx">err</code> <code class="o">:=</code> <code class="nx">cl</code><code class="p">.</code><code class="nx">List</code><code class="p">(</code><code class="nx">context</code><code class="p">.</code><code class="nx">TODO</code><code class="p">(),</code> <code class="nx">client</code><code class="p">.</code><code class="nx">InNamespace</code><code class="p">(</code><code class="s">"default"</code><code class="p">),</code> <code class="nx">list</code><code class="p">)</code></pre>&#13;
&#13;
<p>Note how the invocation of the <code>List()</code> command does not change at all.</p>&#13;
&#13;
<p>Imagine you write an operator that accesses many different kinds using this client. With the typed client of <a data-type="xref" href="#clientgen-client">“Typed client created via client-gen”</a>, you would have to pass many different clients into the operator, making the plumbing code pretty complex. In contrast, the <code>controller-runtime</code> client presented here is just one object for all kinds, assuming all of them are in one scheme.</p>&#13;
&#13;
<p>All three types of clients have their uses, with advantages and disadvantages depending on the context in which they are used. In generic controllers that handle unknown objects, only the dynamic client can be used. In controllers where type safety helps a lot to enforce code correctness, the generated clients are a good fit. The Kubernetes project itself has so many contributors that stability of the code is very important, even when it is extended and rewritten by so many people. If convenience and high velocity with minimal plumbing is important, the <code>controller-runtime</code> client is a good fit.<a data-primary="" data-startref="EPcrd04" data-type="indexterm" id="idm46336860251208"/><a data-primary="" data-startref="CAScrd04" data-type="indexterm" id="idm46336860250200"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46336862066136">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We introduced you to custom resources, the central extension mechanisms used in the Kubernetes ecosystem, in this chapter. By now you should have a good understanding of their features and limitations as well as the available clients.</p>&#13;
&#13;
<p>Let’s now move on to code generation for managing said resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46336863073336"><sup><a href="ch04.html#idm46336863073336-marker">1</a></sup> Do not confuse Kubernetes and JSON objects here. The latter is just another term for a string map, used in the context of JSON and in OpenAPI.</p><p data-type="footnote" id="idm46336862332104"><sup><a href="ch04.html#idm46336862332104-marker">2</a></sup> “Projective” here means that the <code>scale</code> object is a projection of the main resource in the sense that it shows only certain fields and hides everything else.</p></div></div></section></body></html>