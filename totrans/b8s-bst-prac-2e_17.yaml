- en: Chapter 17\. Admission Control and Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Controlling access to the Kubernetes API is key to ensuring that your cluster
    is not only secured but also can be used as a means to impart policy and governance
    for all users, workloads, and components of your Kubernetes cluster. In this chapter,
    we share how you can use admission controllers and authorization modules to enable
    specific features and how you can customize them to suit your specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: Before we jump into admission control and authorization let’s review the API
    request flow through the API server. [Figure 17-1](#api_request_flow) provides
    insight on how and where admission control and authorization take place in that
    flow. It depicts the end-to-end request flow through the Kubernetes API server
    until the object, if accepted, is saved to storage. Follow the API request from
    left to right through the API server, paying specific attention to the ordering
    of admission control and authorization. We will be covering best practices for
    those in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Kubernetes API request flow](assets/kbp2_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. Kubernetes API request flow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Admission Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever wondered how namespaces are automatically created when you define
    a resource in a namespace that doesn’t already exist? Maybe you’ve wondered how
    a default storage class is selected? These changes are powered by a feature called
    *admission controllers*. In this section, we look at how you can use admission
    controllers to implement Kubernetes best practices server-side on behalf of the
    user and how you can utilize admission control to govern how a Kubernetes cluster
    is used.
  prefs: []
  type: TYPE_NORMAL
- en: What Are They?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Admission controllers sit in the path of the Kubernetes API server request flow
    and receive requests following the authentication and authorization phases. They
    are used to either validate or mutate (or both) the request object before saving
    it to storage. The difference between validating and mutating admission controllers
    is that mutating admission controllers can modify the request object they admit,
    whereas validating admission controllers cannot.
  prefs: []
  type: TYPE_NORMAL
- en: Why Are They Important?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given that admission controllers sit in the path of all API server requests,
    you can use them in a variety of different ways. Most commonly, admission controller
    usage can be grouped into the following three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Policy and governance
  prefs: []
  type: TYPE_NORMAL
- en: 'Admission controllers allow policy to be enforced to meet business requirements;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Only internal cloud load balancers can be used when in the `dev` namespace.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All containers in a pod must have resource limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add predefined standard labels or annotations to all resources to make them
    discoverable to existing tools.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All Ingress resources only use HTTPS. For more details on how to use admission
    webhooks in this context, see [Chapter 11](ch11.html#policy_and_governance_for_your_cluster).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs: []
  type: TYPE_NORMAL
- en: You can use admission controllers to enforce a consistent security posture across
    your cluster. A canonical example is the Pod Security Admission controller, which
    determines whether a pod should be admitted based on the configuration of security-sensitive
    fields defined in the pod specification. For instance, it can deny privileged
    containers or usage of specific paths from the host filesystem. You can enforce
    more granular or custom security rules using admission webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: Resource management
  prefs: []
  type: TYPE_NORMAL
- en: 'Admission controllers allow you to validate to provide best practices for your
    cluster users, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure all ingress fully qualified domain names (FQDN) fall within a specific
    suffix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure ingress FQDNs don’t overlap.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All containers in a pod must have resource limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Admission Controller Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two classes of admission controllers: *standard* and *dynamic*. Standard
    admission controllers are compiled into the API server and are shipped as plug-ins
    with each Kubernetes release; they need to be configured when the API server is
    started. Dynamic controllers, on the other hand, are configurable at runtime and
    are developed outside the core Kubernetes codebase. The only type of dynamic admission
    control is admission webhooks, which receive admission requests via HTTP callbacks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the recommended admission controllers are enabled. You may enable
    additional admission controllers using the following flag on the Kubernetes API
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the current version of Kubernetes, the following admission controllers are
    enabled by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can find the list of Kubernetes admission controllers and their functionality
    in the [Kubernetes documentation](https://oreil.ly/APrUE).
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have noticed the following from the list of recommended admission
    controllers to enable: “MutatingAdmissionWebhook,ValidatingAdmissionWebhook.”
    These standard admission controllers don’t implement any admission logic themselves;
    rather, they are used to configure a webhook endpoint running in-cluster to forward
    the admission request object.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Admission Webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As previously mentioned, one of the main advantages of admission webhooks is
    that they are dynamically configurable. It is important that you understand how
    to effectively configure admission webhooks because there are implications and
    trade-offs when it comes to consistency and failure modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The snippet that follows is a ValidatingWebhookConfiguration resource manifest.
    This manifest is used to define a validating admission webhook. The snippet provides
    detailed descriptions of the function of each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For completeness, let’s look at a MutatingWebhookConfiguration resource manifest.
    This manifest defines a mutating admission webhook. The snippet provides detailed
    descriptions on the function of each field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have noticed that both resources are identical, with the exception
    of the `kind` and the `reinvocationPolicy` fields. There is one difference on
    the backend, however: MutatingWebhookConfiguration allows the admission webhook
    to return a modified request object, whereas ValidatingWebhookConfiguration does
    not. Still, it is acceptable to define a MutatingWebhookConfiguration and simply
    validate; there are security considerations that come into play, and you should
    consider following the *least-privilege rule*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You have likely wondered, “What happens if I define a ValidatingWebhookConfiguration
    or MutatingWebhookConfiguration with the resource field under the rule object
    to be either ValidatingWebhookConfiguration or MutatingWebhookConfiguration?”
    The good news is that neither ValidatingAdmissionWebhooks or MutatingAdmissionWebhooks
    are ever called on admission requests for ValidatingWebhookConfiguration and MutatingWebhookConfiguration
    objects. This is for good reason: you don’t want to accidentally put the cluster
    in an unrecoverable state.'
  prefs: []
  type: TYPE_NORMAL
- en: Admission Control Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve covered the power of admission controllers, here are our best
    practices to help you make the most of using them.
  prefs: []
  type: TYPE_NORMAL
- en: Admission plug-in ordering doesn’t matter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In earlier versions of Kubernetes, the ordering of the admission plug-ins was
    specific to the processing order; hence it mattered. In current supported Kubernetes
    versions, the ordering of the admission plug-ins as specified as API server flags
    via `--enable-admission-plugins` no longer matters. Ordering does, however, play
    a small role when it comes to admission webhooks, so it’s important to understand
    the request flow in this case. Request admittance or rejection operates as a logical
    AND, meaning if any of the admission webhooks rejects a request, the entire request
    is rejected and an error is sent back to the user. It’s also important to note
    that mutating admission controllers are always run prior to running validating
    admission controllers. If you think about it, this makes good sense: you probably
    don’t want to validate objects that you are going to subsequently modify. [Figure 17-2](#api_request_flow_via_admission_webhooks)
    illustrates a request flow via admission webhooks; you will see that the mutating
    admission controller is run before the validating admission controller.'
  prefs: []
  type: TYPE_NORMAL
- en: '![An API request flow via admission webhooks](assets/kbp2_1702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-2\. An API request flow via admission webhooks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t mutate the same fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuring multiple mutating admission webhooks also presents challenges. There
    is no way to order the request flow through multiple mutating admission webhooks,
    so it’s important to not have mutating admission controllers modify the same fields,
    because this can result in inconsistent behavior. In the case where you have multiple
    mutating admission webhooks, we generally recommend configuring validating admission
    webhooks to confirm that the final resource manifest is what you expect post-mutation
    because it’s guaranteed to be run following mutating webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: Mutating admission webhooks must be idempotent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that they must be able to process and admit an object that has already
    been processed and may have already been modified.
  prefs: []
  type: TYPE_NORMAL
- en: Fail open/fail closed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might recall seeing the `failurePolicy` field as part of both the mutating
    and validating webhook configuration resources. This field defines how the API
    server should proceed in the case where the admission webhooks have access issues
    or encounter unrecognized errors. You can set this field to either `Ignore` or
    `Fail`. `Ignore` essentially fails to open, meaning that processing of the request
    will continue, whereas `Fail` denies the entire request. This might seem obvious,
    but the implications in both cases require consideration. Ignoring a critical
    admission webhook could result in policy that the business relies on not being
    applied to a resource without the user knowing.
  prefs: []
  type: TYPE_NORMAL
- en: One potential solution to protect against this would be to raise an alert when
    the API server logs that it cannot reach a given admission webhook. `Fail` can
    be even more devastating by denying all requests if the admission webhook is experiencing
    issues. To protect against this you can scope the rules to ensure that only specific
    resource requests are set to the admission webhook. As a tenet, you should never
    have any rules that apply to all resources in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Admission webhooks must respond quickly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have written your own admission webhook, it’s important to remember that
    user/system requests can be directly affected by the time it takes for your admission
    webhook to make a decision and respond. All admission webhook calls are configured
    with a 30-second timeout, after which time the `failurePolicy` takes effect. Even
    if it takes several seconds for your admission webhook to make an admit/deny decision,
    it can severely affect user experience when working with the cluster. Avoid having
    complex logic or relying on external systems such as databases to process the
    admit/deny logic.
  prefs: []
  type: TYPE_NORMAL
- en: Scoping admission webhooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An optional field allows you to scope the namespaces in which the admission
    webhooks operate on via the `NamespaceSelector` field. This field defaults to
    empty, which matches everything, but it can be used to match namespace labels
    via the use of the `matchLabels` field. We recommend that you always use this
    field because it allows for an explicit opt-in per namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Always deploy in a separate namespace using NamespaceSelector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When self-hosting a webhook admission controller, deploy the webhook admission
    controller to a separate namespace and use the `NamespaceSelector` field to exclude
    resources deployed to that namespace from being processed.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t touch the kube-system namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `kube-system` namespace is a reserved namespace that’s common across all
    Kubernetes clusters. It’s where all system-level services operate. We recommend
    never running admission webhooks against the resources in this namespace specifically,
    and you can achieve this by using the `NamespaceSelector` field and simply not
    matching the `kube-system` namespace. You should also consider doing this for
    any system-level namespaces that are required for cluster operation.
  prefs: []
  type: TYPE_NORMAL
- en: Lock down admission webhook configurations with RBAC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you know about all the fields in the admission webhook configuration,
    you have probably thought of a really simple way to break access to a cluster.
    It goes without saying that the creation of both a MutatingWebhookConfiguration
    and ValidatingWebhookConfiguration is a root-level operation on the cluster and
    must be locked down appropriately using RBAC. Failure to do so can result in a
    broken cluster or, even worse, an injection attack on your application workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t send sensitive data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Admission webhooks are essentially opaque boxes that accept AdmissionRequests
    and output AdmissionResponses. How they store and manipulate the request is opaque
    to the user. It’s important to think about what request payloads you are sending
    to the admission webhook. In the case of Kubernetes secrets or ConfigMaps, they
    might contain sensitive information and require strong guarantees about how that
    information is stored and shared. Sharing these resources with an admission webhook
    can leak sensitive information, which is why you should scope your resource rules
    to the minimum resource needed to validate and/or mutate.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We often think about authorization in the context of answering the following
    question: “Is this user able to perform these actions on these resources?” In
    Kubernetes, the authorization of each request is performed after authentication
    but before admission. In this section, we explore how you can configure different
    authorization modules and better understand how you can create the appropriate
    policy to serve the needs of your cluster. [Figure 17-3](#api_request_flow_via_authorization_modules)
    illustrates where authorization sits in the request flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '![API request flow via authorization modules](assets/kbp2_1703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-3\. API request flow via authorization modules
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Authorization Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Authorization modules are responsible for either granting or denying permission
    to access. They determine whether to grant access based on policy that must be
    explicitly defined; otherwise all requests will be implicitly denied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes ships with the following authorization modules out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-Based Access Control (ABAC)
  prefs: []
  type: TYPE_NORMAL
- en: Allows authorization policy to be configured via local files
  prefs: []
  type: TYPE_NORMAL
- en: RBAC
  prefs: []
  type: TYPE_NORMAL
- en: Allows authorization policy to be configured via the Kubernetes API (refer to
    [Chapter 4](ch04.html#configuration_secrets_and_rbac) for more detail)
  prefs: []
  type: TYPE_NORMAL
- en: Webhook
  prefs: []
  type: TYPE_NORMAL
- en: Allows the authorization of a request to be handled via a remote REST endpoint
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs: []
  type: TYPE_NORMAL
- en: Specialized authorization module that authorizes requests from kubelets
  prefs: []
  type: TYPE_NORMAL
- en: 'The modules are configured by the cluster administrator via the following flag
    on the API server: `--authorization-mode`. Multiple modules can be configured
    and are checked in order. Unlike admission controllers, if a single authorization
    module admits the request, the request can proceed. Only for the case in which
    all modules deny the request will an error be returned to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: ABAC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at a policy definition in the context of using the ABAC authorization
    module. The following grants user Mary read-only access to a pod in the `kube-system`
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If Mary were to make the following request, it would be denied because Mary
    doesn’t have access to get pods in the `demo-app` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This example introduced a new API group, `authorization.k8s.io`. This set of
    APIs exposes API server authorization to external services and has the following
    APIs, which are great for debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: SelfSubjectAccessReview
  prefs: []
  type: TYPE_NORMAL
- en: Access review for the current user
  prefs: []
  type: TYPE_NORMAL
- en: SubjectAccessReview
  prefs: []
  type: TYPE_NORMAL
- en: Like SelfSubjectAccessReview but for any user
  prefs: []
  type: TYPE_NORMAL
- en: LocalSubjectAccessReview
  prefs: []
  type: TYPE_NORMAL
- en: Like SubjectAccessReview but namespace specific
  prefs: []
  type: TYPE_NORMAL
- en: SelfSubjectRulesReview
  prefs: []
  type: TYPE_NORMAL
- en: Returns a list of actions a user can perform in a given namespace
  prefs: []
  type: TYPE_NORMAL
- en: 'The cool part is that you can query these APIs by creating resources as you
    typically would. Let’s take the previous example and test this using the SelfSubjectAccessReview.
    The status field in the output indicates that this request is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, Kubernetes ships with tooling built into `kubectl` to make this even
    easier. The `kubectl auth can-i` command operates by querying the same API as
    the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With administrator credentials, you can also run the same command to check
    actions as another user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: RBAC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Kubernetes role-based access control is covered in depth in [Chapter 4](ch04.html#configuration_secrets_and_rbac).
  prefs: []
  type: TYPE_NORMAL
- en: Webhook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the webhook authorization module allows a cluster administrator to configure
    an external REST endpoint to delegate the authorization process to. This would
    run off-cluster and be reachable via URL. The configuration of the REST endpoint
    is found in a file on the control plane host filesystem and configured on the
    API server via `--authorization-webhook-config-file=SOME_FILENAME`. After you’ve
    configured it, the API server will send SubjectAccessReview objects as part of
    the request body to the authorization webhook application, which processes and
    returns the object with the status field complete.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following best practices before making changes to the authorization
    modules configured on your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use ABAC on multiple control plane clusters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given that the ABAC policies need to be placed on the filesystem of each control
    plane host and kept synchronized, we generally recommend *against* using ABAC
    in multiple control plane clusters. The same can be said for the webhook module
    because the configuration is based on a file and a corresponding flag being present.
    Furthermore, changes to these policies in the files require a restart of the API
    server to take effect, which is effectively a control plane outage in a single
    control plane cluster or inconsistent configuration in a multiple control plane
    cluster. Given these details, we recommend using the RBAC module only for user
    authorization because the rules are configured and stored in Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t use webhook modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Webhook modules, although powerful, are potentially very dangerous. Given that
    every request is subject to the authorization process, a failure of a webhook
    service would be devastating for a cluster. Therefore, we generally recommend
    not using external authorization modules unless you completely vet and are comfortable
    with your cluster failure modes if the webhook service becomes unreachable or
    unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the foundational topics of admission and authorization
    and covered best practices. Put these skills to use by determining the best admission
    and authorization configuration that allows you to customize the controls and
    policies needed for the life of your cluster.
  prefs: []
  type: TYPE_NORMAL
