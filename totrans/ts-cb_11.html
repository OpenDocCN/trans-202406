<html><head></head><body><section data-pdf-bookmark="Chapter 10. TypeScript and React" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch10">&#13;
<h1><span class="label">Chapter 10. </span>TypeScript and React</h1>&#13;
&#13;
&#13;
<p><a data-primary="JSX" data-type="indexterm" id="ix_ch10-asciidoc0"/><a data-primary="React, TypeScript and" data-type="indexterm" id="ix_ch10-asciidoc1"/>React is arguably one of the most popular JavaScript libraries in recent years. Its simple approach to the composition of components has changed the way we write frontend (and, to an extent, backend) applications, allowing you to declaratively write UI code using a JavaScript syntax extension called JSX. Not only was this simple principle easy to pick up and understand, but it also influenced dozens of other libraries.</p>&#13;
&#13;
<p>JSX is undoubtedly a game changer in the JavaScript world, and with TypeScript’s goal to cater to all JavaScript developers, JSX found its way into TypeScript. In fact, TypeScript is a full-fledged JSX compiler. If you have no need for additional bundling or extra tooling, TypeScript is all you need to get your React app going. TypeScript is also immensely popular. At the time of writing, the React typings on NPM clocked 20 million downloads per week. The fantastic tooling with VS Code and the excellent types made TypeScript the first choice for React developers around the globe.</p>&#13;
&#13;
<p>While TypeScript’s popularity among React developers continues unabated, one circumstance makes the use of TypeScript with React a bit difficult: TypeScript isn’t the React team’s first choice. While other JSX-based libraries are now mostly written <em>in</em> TypeScript and therefore provide excellent types out of the box, the React team works with their own static type-checker called <a href="https://flow.org">Flow</a>, which is similar to, but ultimately incompatible with, TypeScript. This means the React types millions of developers rely on are made subsequently by a group of community contributors and published on Definitely Typed. While <code>@types/react</code> are considered to be excellent, they are still just the best effort to type a library as complex as React. This inevitably leads to gaps. For the places where those gaps become visible, this chapter will be your guide.</p>&#13;
&#13;
<p class="pagebreak-before">In this chapter, we look at situations where React is supposed to be easy, but TypeScript gives you a hard time by throwing complex error messages. We are going to figure out what those messages mean, how you can work around them, and what solutions help you in the long run. You will also learn about various development patterns and their benefits, and how to use TypeScript’s built-in JSX support.</p>&#13;
&#13;
<p>What you won’t get is a basic setup guide for React and TypeScript. The ecosystem is so vast and rich, many roads lead to Rome. Pick your framework’s documentation pages and look out for TypeScript. Also note that I assume some React experience up front. In this chapter, we deal mostly with typing React.</p>&#13;
&#13;
<p>While there is a strong inclination toward React in this chapter, you will be able to use certain learnings and apply them to other JSX-based frameworks and libraries as well.<a data-startref="ix_ch10-asciidoc1" data-type="indexterm" id="id865"/><a data-startref="ix_ch10-asciidoc0" data-type="indexterm" id="id866"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.1 Writing Proxy Components" data-type="sect1"><div class="sect1" id="ch10_proxy_components">&#13;
<h1>10.1 Writing Proxy Components</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id151">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="HTML components" data-type="indexterm" id="ix_10-01-asciidoc0"/><a data-primary="proxy components" data-secondary="writing" data-type="indexterm" id="ix_10-01-asciidoc1"/><a data-primary="React, TypeScript and" data-secondary="writing proxy components" data-type="indexterm" id="ix_10-01-asciidoc2"/>You write a lot of standard HTML components, but you don’t want to set all necessary properties all the time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id867">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create proxy components and apply a few patterns to make them usable for your &#13;
<span class="keep-together">scenario.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id152">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="buttons" data-type="indexterm" id="ix_10-01-asciidoc3"/>Most web applications use buttons. Buttons have a <code>type</code> property that defaults to &#13;
<span class="keep-together"><code>submit</code>.</span> This is a sensible default for forms where you perform an action over HTTP, where you POST the contents to a server-side API. But when you just want to have interactive elements on your site, the correct type for buttons is <code>button</code>. This is not only an aesthetic choice but also important for accessibility:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">button</code> <code class="na">type</code><code class="o">=</code><code class="s">"button"</code><code class="p">&gt;</code>Click me!<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>When you write React, chances are you rarely submit a form to a server with a &#13;
<span class="keep-together"><code>submit</code></span> type, but you interact with lots of <code>button</code>-type buttons. A good way to deal with situations like these is to write proxy components. They mimic HTML elements but preset a couple of properties:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Button</code><code class="p">(</code><code class="nx">props</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">button</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The idea is that <code>Button</code> takes the same properties as the HTML <code>button</code>, and the attributes are spread out to the HTML element. Spreading attributes to HTML elements is a nice feature where you can make sure that you are able to set all the HTML properties that an element has without knowing up front which you want to set. But how do we type them?</p>&#13;
&#13;
<p><a data-primary="JSX namespace" data-type="indexterm" id="id868"/><a data-primary="namespaces" data-secondary="JSX" data-type="indexterm" id="id869"/>All HTML elements that can be used in JSX are defined through intrinsic elements in the <code>JSX</code> namespace. When you load React, the <code>JSX</code> namespace appears as a global namespace in your file, and you can access all elements via index access. <a data-primary="intrinsic elements" data-type="indexterm" id="ix_10-01-asciidoc4"/><a data-primary="JSX.IntrinsicElements" data-type="indexterm" id="ix_10-01-asciidoc5"/>So the correct prop types for <code>Button</code> are defined in <code>JSX.IntrinsicElements</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>An alternative to <code>JSX.IntrinsicElements</code> is <code>React.ElementType</code>, a generic type within the React package, which also includes class and function components. For proxy components, <code>JSX⁠.Int⁠rin⁠sic​Ele⁠ments</code> is sufficient and comes with an extra benefit: your components stay compatible with other React-like frameworks like &#13;
<span class="keep-together">Preact.</span></p>&#13;
</div>&#13;
&#13;
<p><code>JSX.IntrinsicElements</code> is a type within the global <code>JSX</code> namespace. Once this namespace is in scope, TypeScript is able to pick up basic elements that are compatible with your JSX-based framework:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ButtonProps</code> <code class="o">=</code> <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"button"</code><code class="p">];</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Button</code><code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">ButtonProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">button</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This includes children: we spread them along! As you see, we set a button’s type to <code>button</code>. Since props are just JavaScript objects, it’s possible to override <code>type</code> by setting it as an attribute in props. If two keys with the same name are defined, the last one wins. This may be desired behavior, but you alternatively may want to prevent you and your colleagues from overriding <code>type</code>. With the <code>Omit&lt;T, K&gt;</code> helper type, you can take all properties from a JSX <code>button</code> but drop keys you don’t want to override:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ButtonProps</code> <code class="o">=</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"button"</code><code class="p">],</code> <code class="s2">"type"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Button</code><code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">ButtonProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">button</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">aButton</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nt">Button</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code><code class="o">&gt;</code><code class="nx">Hi</code><code class="o">&lt;/</code><code class="nt">Button</code><code class="o">&gt;;</code>&#13;
<code class="c1">//                      ^</code>&#13;
<code class="c1">// Type '{ children: string; type: string; }' is not</code>&#13;
<code class="c1">// assignable to type 'IntrinsicAttributes &amp; ButtonProps'.</code>&#13;
<code class="c1">// Property 'type' does not exist on type</code>&#13;
<code class="c1">// 'IntrinsicAttributes &amp; ButtonProps'.(2322)</code></pre>&#13;
&#13;
<p>If you need <code>type</code> to be <code>submit</code>, you can create another proxy component:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SubmitButtonProps</code> <code class="o">=</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"button"</code><code class="p">],</code> <code class="s2">"type"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">SubmitButton</code><code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">SubmitButtonProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">button</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"submit"</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can extend this idea of omitting properties if you want to preset even more properties. Perhaps you adhere to a design system and don’t want class names to be set arbitrarily:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">StyledButton</code> <code class="o">=</code> <code class="nx">Omit</code><code class="o">&lt;</code>&#13;
  <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"button"</code><code class="p">],</code>&#13;
  <code class="s2">"type"</code> <code class="o">|</code> <code class="s2">"className"</code> <code class="o">|</code> <code class="s2">"style"</code>&#13;
<code class="o">&gt;</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="kr">type</code><code class="o">:</code> <code class="s2">"primary"</code> <code class="o">|</code> <code class="s2">"secondary"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">StyledButton</code><code class="p">({</code> <code class="kr">type</code><code class="p">,</code> <code class="p">...</code><code class="nx">allProps</code> <code class="p">}</code><code class="o">:</code> <code class="nx">StyledButton</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">Button</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code> <code class="nx">className</code><code class="o">=</code><code class="p">{</code><code class="sb">`btn-</code><code class="si">${</code><code class="kr">type</code><code class="si">}</code><code class="sb">`</code><code class="p">}</code> <code class="p">{...</code><code class="nx">allProps</code><code class="p">}</code><code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This even allows you to reuse the <code>type</code> property name.<a data-startref="ix_10-01-asciidoc5" data-type="indexterm" id="id870"/></p>&#13;
&#13;
<p>We dropped some props from the type definition and preset them to sensible defaults. Now we want to make sure our users don’t forget to set some props, such as the <code>alt</code> attribute of an image or the <code>src</code> attribute.</p>&#13;
&#13;
<p>For that, we create a <code>MakeRequired</code> helper type that removes the optional flag:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">MakeRequired</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code> <code class="o">&amp;</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>And build our own props:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ImgProps</code>&#13;
  <code class="o">=</code> <code class="nx">MakeRequired</code><code class="o">&lt;</code>&#13;
    <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"img"</code><code class="p">],</code>&#13;
    <code class="s2">"alt"</code> <code class="o">|</code> <code class="s2">"src"</code>&#13;
  <code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">Img</code><code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">ImgProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">img</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">anImage</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nt">Img</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="c1">//               ^</code>&#13;
<code class="c1">// Type '{}' is missing the following properties from type</code>&#13;
<code class="c1">// 'Required&lt;Pick&lt;DetailedHTMLProps&lt;ImgHTMLAttributes&lt;HTMLImageElement&gt;,</code>&#13;
<code class="c1">//  HTMLImageElement&gt;, "alt" | "src"&gt;&gt;': alt, src (2739)</code></pre>&#13;
&#13;
<p>With just a few changes to the original intrinsic element’s type and a proxy component, we can ensure that our code becomes more robust, more accessible, and less error prone<a data-startref="ix_10-01-asciidoc4" data-type="indexterm" id="id871"/><a data-startref="ix_10-01-asciidoc3" data-type="indexterm" id="id872"/>.<a data-startref="ix_10-01-asciidoc2" data-type="indexterm" id="id873"/><a data-startref="ix_10-01-asciidoc1" data-type="indexterm" id="id874"/><a data-startref="ix_10-01-asciidoc0" data-type="indexterm" id="id875"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.2 Writing Controlled Components" data-type="sect1"><div class="sect1" id="ch10_controlled_components">&#13;
<h1>10.2 Writing Controlled Components</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id229">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="discriminated union types" data-secondary="controlled components and" data-type="indexterm" id="ix_10-08-asciidoc0"/><a data-primary="never type" data-secondary="controlled components and" data-type="indexterm" id="ix_10-08-asciidoc1a"/><a data-primary="optional never technique" data-secondary="controlled components and" data-type="indexterm" id="ix_10-08-asciidoc1"/><a data-primary="proxy components" data-secondary="controlled components and" data-type="indexterm" id="ix_10-08-asciidoc2"/><a data-primary="React, TypeScript and" data-secondary="writing controlled components" data-type="indexterm" id="ix_10-08-asciidoc3"/><a data-primary="state, managing" data-secondary="writing controlled components" data-type="indexterm" id="ix_10-08-asciidoc4"/>Form elements like inputs add another complexity as we need to decide where to manage state: in the browser or in React.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id876">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Write a proxy component that uses discriminated unions and the optional never technique to ensure you won’t switch from uncontrolled to controlled at runtime.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id153">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>React differentiates form elements between <em>controlled components</em> and <em>uncontrolled components</em>. When you use regular form elements like <code>input</code>, <code>textarea</code>, or <code>select</code>, you need to keep in mind that the underlying HTML elements control their own state. Whereas in React, the state of an element is also defined <em>through</em> React.</p>&#13;
&#13;
<p>If you set the <code>value</code> attribute, React assumes that the element’s value is also controlled by React’s state management, which means you are not able to modifiy this value unless you maintain the element’s state using <code>useState</code> and the associated setter &#13;
<span class="keep-together">function.</span></p>&#13;
&#13;
<p>There are two ways to deal with this. First, you can choose <code>defaultValue</code> as a property instead of <code>value</code>. This will set the <code>value</code> of the input only in the first rendering, and subsequently leaves everything in the hands of the browser:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Input</code><code class="p">({</code>&#13;
  <code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">,</code> <code class="p">...</code><code class="nx">allProps</code>&#13;
<code class="p">}</code><code class="o">:</code> <code class="nx">Props</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">input</code>&#13;
      <code class="nx">defaultValue</code><code class="o">=</code><code class="p">{</code><code class="nx">value</code><code class="p">}</code>&#13;
      <code class="p">{...</code><code class="nx">allProps</code><code class="p">}</code>&#13;
    <code class="o">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Or you manage <code>value</code> interally via React’s state management. Usually, it’s enough just to intersect the original input element’s props with our own type. We drop <code>value</code> from the intrinsic elements and add it as a required <code>string</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ControlledProps</code> <code class="o">=</code>&#13;
  <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"input"</code><code class="p">],</code> <code class="s2">"value"</code><code class="o">&gt;</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
    <code class="nx">value</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="p">};</code></pre>&#13;
&#13;
<p>Then, we wrap the <code>input</code> element in a proxy component. It is not best practice to keep state internally in a proxy component; rather, you should manage it from the outside with <code>useState</code>. We also forward the <code>onChange</code> handler we pass from the original input props:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Input</code><code class="p">({</code>&#13;
  <code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">,</code> <code class="nx">onChange</code><code class="p">,</code> <code class="p">...</code><code class="nx">allProps</code>&#13;
<code class="p">}</code><code class="o">:</code> <code class="nx">ControlledProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">input</code>&#13;
      <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">value</code><code class="p">}</code>&#13;
      <code class="p">{...</code><code class="nx">allProps</code><code class="p">}</code>&#13;
      <code class="nx">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">onChange</code><code class="p">}</code>&#13;
    <code class="o">/&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">AComponentUsingInput</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">val</code><code class="p">,</code> <code class="nx">setVal</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">Input</code>&#13;
    <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">val</code><code class="p">}</code>&#13;
    <code class="nx">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">setVal</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code>&#13;
    <code class="p">}}</code>&#13;
  <code class="o">/&gt;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p><a data-primary="uncontrolled components" data-type="indexterm" id="id877"/>React raises an interesting warning when dealing with a switch from uncontrolled to controlled at runtime:</p>&#13;
<blockquote>&#13;
<p>A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component.</p></blockquote>&#13;
&#13;
<p>We can prevent this warning by making sure at compile time that we either always provide a defined string <code>value</code> or provide a <code>defaultValue</code> instead, but not both. This can be solved by using a discriminated union type using the optional never technique (as seen in <a data-type="xref" href="ch03.html#ch03_item_optional_never">Recipe 3.8</a>), and using the <code>OnlyRequired</code> helper type from <a data-type="xref" href="ch08.html#ch08_one_optional">Recipe 8.1</a> to derive possible properties from <code>JSX.IntrinsicElements["input"]</code>:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// A helper type setting a few properties to be required</code>&#13;
<code class="kr">type</code> <code class="nx">OnlyRequired</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Required</code><code class="o">&lt;</code><code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code> <code class="o">&amp;</code>&#13;
  <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Branch 1: Make "value" and "onChange" required, drop `defaultValue`</code>&#13;
<code class="kr">type</code> <code class="nx">ControlledProps</code> <code class="o">=</code> <code class="nx">OnlyRequired</code><code class="o">&lt;</code>&#13;
  <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"input"</code><code class="p">],</code>&#13;
  <code class="s2">"value"</code> <code class="o">|</code> <code class="s2">"onChange"</code>&#13;
<code class="o">&gt;</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">defaultValue</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="c1">// Branch 2: Drop `value` and `onChange`, make `defaultValue` required</code>&#13;
<code class="kr">type</code> <code class="nx">UncontrolledProps</code> <code class="o">=</code> <code class="nx">Omit</code><code class="o">&lt;</code>&#13;
  <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"input"</code><code class="p">],</code>&#13;
  <code class="s2">"value"</code> <code class="o">|</code> <code class="s2">"onChange"</code>&#13;
<code class="o">&gt;</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">defaultValue</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">value</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
  <code class="nx">onChange</code><code class="o">?:</code> <code class="kr">never</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">InputProps</code> <code class="o">=</code> <code class="nx">ControlledProps</code> <code class="o">|</code> <code class="nx">UncontrolledProps</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Input</code><code class="p">({</code> <code class="p">...</code><code class="nx">allProps</code> <code class="p">}</code><code class="o">:</code> <code class="nx">InputProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">input</code> <code class="p">{...</code><code class="nx">allProps</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Controlled</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">val</code><code class="p">,</code> <code class="nx">setVal</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">Input</code> <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">val</code><code class="p">}</code> <code class="nx">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">setVal</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Uncontrolled</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">Input</code> <code class="nx">defaultValue</code><code class="o">=</code><code class="s2">"Hello"</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In all other cases, having an optional <code>value</code> or having a <code>defaultValue</code> and trying to control values will be prohibited by the type system.<a data-startref="ix_10-08-asciidoc4" data-type="indexterm" id="id878"/><a data-startref="ix_10-08-asciidoc3" data-type="indexterm" id="id879"/><a data-startref="ix_10-08-asciidoc2" data-type="indexterm" id="id880"/><a data-startref="ix_10-08-asciidoc1a" data-type="indexterm" id="id881"/><a data-startref="ix_10-08-asciidoc1" data-type="indexterm" id="id882"/><a data-startref="ix_10-08-asciidoc0" data-type="indexterm" id="id883"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.3 Typing Custom Hooks" data-type="sect1"><div class="sect1" id="ch10_custom_hooks">&#13;
<h1>10.3 Typing Custom Hooks</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id154">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="arrays" data-secondary="defining custom hooks" data-type="indexterm" id="ix_10-02-asciidoc0"/><a data-primary="custom hooks, defining" data-type="indexterm" id="ix_10-02-asciidoc1"/><a data-primary="React, TypeScript and" data-secondary="typing custom hooks" data-type="indexterm" id="ix_10-02-asciidoc2"/><a data-primary="tuple types" data-secondary="defining custom hooks" data-type="indexterm" id="ix_10-02-asciidoc3"/>You want to define custom hooks and get proper types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id884">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use tuple types or <em>const context</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id155">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Let’s create a custom hook in React and stick to the naming convention as regular React hooks do: returning an array (or tuple) that can be destructured. For example, <code>useState</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="p">[</code><code class="nx">state</code><code class="p">,</code> <code class="nx">setState</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code></pre>&#13;
&#13;
<p>Why do we even use arrays? Because the array’s fields have no name, and you can set names of your own:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="p">[</code><code class="nx">count</code><code class="p">,</code> <code class="nx">setCount</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">[</code><code class="nx">darkMode</code><code class="p">,</code> <code class="nx">setDarkMode</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code></pre>&#13;
&#13;
<p>So naturally, if you have a similar pattern, you also want to return an array. A custom toggle hook might look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">const</code> <code class="nx">useToggle</code> <code class="o">=</code> <code class="p">(</code><code class="nx">initialValue</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">value</code><code class="p">,</code> <code class="nx">setValue</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">initialValue</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">toggleValue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">setValue</code><code class="p">(</code><code class="o">!</code><code class="nx">value</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">[</code><code class="nx">value</code><code class="p">,</code> <code class="nx">toggleValue</code><code class="p">];</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Nothing out of the ordinary. The only types we have to set are the types of the input parameters. Let’s try it:</p>&#13;
<pre data-code-language="tsx" data-type="programlisting"><code class="kr">export</code> <code class="kr">const</code> <code class="nx">Body</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">isVisible</code><code class="p">,</code> <code class="nx">toggleVisible</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useToggle</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    &lt;&gt;&#13;
      <code class="p">&lt;</code><code class="nt">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">toggleVisible</code><code class="p">}</code><code class="p">&gt;</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
    <code class="p">{</code> <code class="cm">/* Error. See below */</code> <code class="p">}</code>&#13;
      <code class="p">{</code><code class="nx">isVisible</code> <code class="o">&amp;&amp;</code> <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>World<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;}&gt;}</code>&#13;
    &lt;/&gt;&#13;
  <code class="p">)</code>&#13;
<code class="p">}</code>&#13;
<code class="c1">// Error: Type 'boolean | (() =&gt; void)' is not assignable to</code>&#13;
<code class="c1">// type 'MouseEventHandler&lt;HTMLButtonElement&gt; | undefined'.</code>&#13;
<code class="c1">// Type 'boolean' is not assignable to type</code>&#13;
<code class="c1">// 'MouseEventHandler&lt;HTMLButtonElement&gt;'.(2322)</code></pre>&#13;
&#13;
<p>So why does this fail? The error message might be cryptic, but what we should look out for is the first type, which is declared incompatible: <code>boolean | (() =&gt; void)'</code>. This comes from returning an array: a list of any length that can hold as many elements as virtually possible. From the return value in <code>useToggle</code>, TypeScript infers an array type. Since the type of <code>value</code> is <code>boolean</code> (great!) and the type of <code>toggleValue</code> is <code>(() =&gt; void)</code> (a function expected to return nothing), TypeScript tells us that both types are possible in this array.</p>&#13;
&#13;
<p class="pagebreak-before">This is what breaks the compatibility with <code>onClick</code>. <code>onClick</code> expects a function. That’s fine, but <code>toggleValue</code> (or <code>toggleVisible</code>) is a function. According to TypeScript, however, it can also be a Boolean! TypeScript tells you to be explicit, or at least to do type-checks.</p>&#13;
&#13;
<p>But we shouldn’t need to do extra type-checks. Our code is very clear. It’s the types that are wrong. Because we’re not dealing with an array, let’s go for a different name: tuple. While an array is a list of values that can be of any length, we know exactly how many values we get in a tuple. Usually, we also know the type of each element in a tuple.</p>&#13;
&#13;
<p>So we shouldn’t return an array but a tuple at <code>useToggle</code>. The problem: in JavaScript an array and a tuple are indistinguishable. In TypeScript’s type system, we can distinguish them.</p>&#13;
&#13;
<p>First option: let’s be intentional with our return type. Since TypeScript—correctly!—infers an array, we have to tell TypeScript that we are expecting a tuple:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// add a return type here</code>&#13;
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">useToggle</code> <code class="o">=</code> <code class="p">(</code><code class="nx">initialValue</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">)</code><code class="o">:</code> <code class="p">[</code><code class="kr">boolean</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">]</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">value</code><code class="p">,</code> <code class="nx">setValue</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">initialValue</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">toggleValue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">setValue</code><code class="p">(</code><code class="o">!</code><code class="nx">value</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="p">[</code><code class="nx">value</code><code class="p">,</code> <code class="nx">toggleValue</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>With <code>[boolean, () =&gt; void]</code> as a return type, TypeScript checks that we are returning a tuple in this function. TypeScript does not infer, but rather makes sure that your intended return type is matched by the actual values. And voilà, your code doesn’t throw errors anymore.</p>&#13;
&#13;
<p><a data-primary="const context" data-secondary="defining custom hooks" data-type="indexterm" id="id885"/>Second option: use <em>const context</em>. With a tuple, we know how many elements we are expecting, and we know the type of these elements. This sounds like a job for freezing the type with a <code>const</code> assertion:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">const</code> <code class="nx">useToggle</code> <code class="o">=</code> <code class="p">(</code><code class="nx">initialValue</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">value</code><code class="p">,</code> <code class="nx">setValue</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">initialValue</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">toggleValue</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">setValue</code><code class="p">(</code><code class="o">!</code><code class="nx">value</code><code class="p">);</code>&#13;
  <code class="c1">// here, we freeze the array to a tuple</code>&#13;
  <code class="k">return</code> <code class="p">[</code><code class="nx">value</code><code class="p">,</code> <code class="nx">toggleValue</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The return type is now <code>readonly [boolean, () =&gt; void]</code>, because <code>as const</code> makes sure that your values are constant and not changeable. This type is a little bit different semantically, but in reality you wouldn’t be able to change the values you return outside of <code>useToggle</code>. So being <code>readonly</code> would be slightly more correct.<a data-startref="ix_10-02-asciidoc3" data-type="indexterm" id="id886"/><a data-startref="ix_10-02-asciidoc2" data-type="indexterm" id="id887"/><a data-startref="ix_10-02-asciidoc1" data-type="indexterm" id="id888"/><a data-startref="ix_10-02-asciidoc0" data-type="indexterm" id="id889"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.4 Typing Generic forwardRef Components" data-type="sect1"><div class="sect1" id="ch10_generic_forward_refs">&#13;
<h1>10.4 Typing Generic forwardRef Components</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id156">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="forwardRef components" data-type="indexterm" id="ix_10-03-asciidoc1"/><a data-primary="React, TypeScript and" data-secondary="typing generic forwardRef components" data-type="indexterm" id="ix_10-03-asciidoc5"/>You use <code>forwardRef</code> for your components, but you need them to be generic.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id890">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>There are several solutions to this problem.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id157">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>If you are creating component libraries and design systems in React, you might already have fowarded <code>ref</code>s to the DOM elements inside your components.</p>&#13;
&#13;
<p>This is especially useful if you wrap basic components or leaves in <em>proxy components</em> (see <a data-type="xref" href="#ch10_proxy_components">Recipe 10.1</a>), but want to use the <code>ref</code> property just like you’re used to:</p>&#13;
<pre data-code-language="tsx" data-type="programlisting"><code class="kr">const</code> <code class="nx">Button</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">forwardRef</code><code class="p">((</code><code class="nx">props</code><code class="p">,</code> <code class="nx">ref</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
  <code class="o">&lt;</code><code class="nt">button</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">ref</code><code class="p">}</code><code class="o">&gt;</code>&#13;
    <code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">children</code><code class="p">}</code>&#13;
  <code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code>&#13;
<code class="p">));</code>&#13;
&#13;
<code class="c1">// Usage: You can use your proxy just like you use</code>&#13;
<code class="c1">// a regular button!</code>&#13;
<code class="kr">const</code> <code class="nx">reference</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createRef</code><code class="p">();</code>&#13;
<code class="o">&lt;</code><code class="nt">Button</code> <code class="nx">className</code><code class="o">=</code><code class="s2">"primary"</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">reference</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Hello</code><code class="o">&lt;/</code><code class="nt">Button</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>Providing types for <code>React.forwardRef</code> is usually pretty straightforward. The types shipped by <code>@types/react</code> have generic type variables that you can set upon calling <code>React.forwardRef</code>. In that case, explicitly annotating your types is the way to go:</p>&#13;
<pre data-code-language="tsx" data-type="programlisting"><code class="kr">type</code> <code class="nx">ButtonProps</code> <code class="o">=</code> <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="s2">"button"</code><code class="p">];</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Button</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">forwardRef</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="p">,</code> <code class="nx">ButtonProps</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="p">(</code><code class="nx">props</code><code class="p">,</code> <code class="nx">ref</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">button</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">ref</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">children</code><code class="p">}</code>&#13;
    <code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="c1">// Usage</code>&#13;
<code class="kr">const</code> <code class="nx">reference</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createRef</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">();</code>&#13;
<code class="o">&lt;</code><code class="nt">Button</code> <code class="nx">className</code><code class="o">=</code><code class="s2">"primary"</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">reference</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Hello</code><code class="o">&lt;/</code><code class="nt">Button</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p class="pagebreak-before">So far, so good. But things get a bit hairy if you have a component that accepts generic properties. The following component produces a list of list items, where you can select each row with a <code>button</code> element:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">items</code><code class="o">:</code> <code class="nx">T</code><code class="p">[];</code>&#13;
  <code class="nx">onSelect</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">ClickableList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">ul</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code> <code class="nx">idx</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nt">li</code><code class="o">&gt;</code>&#13;
          <code class="o">&lt;</code><code class="nt">button</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">idx</code><code class="p">}</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">props</code><code class="p">.</code><code class="nx">onSelect</code><code class="p">(</code><code class="nx">item</code><code class="p">)}</code><code class="o">&gt;</code>&#13;
            <code class="nx">Choose</code>&#13;
          <code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code>&#13;
          <code class="p">{</code><code class="nx">item</code><code class="p">}</code>&#13;
        <code class="o">&lt;/</code><code class="nt">li</code><code class="o">&gt;</code>&#13;
      <code class="p">))}</code>&#13;
    <code class="o">&lt;/</code><code class="nt">ul</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Usage</code>&#13;
<code class="kr">const</code> <code class="nx">items</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">];</code>&#13;
<code class="o">&lt;</code><code class="nx">ClickableList</code> <code class="nx">items</code><code class="o">=</code><code class="p">{</code><code class="nx">items</code><code class="p">}</code>&#13;
  <code class="nx">onSelect</code><code class="o">=</code><code class="p">{(</code><code class="nx">item</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// item is of type number</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">item</code><code class="p">);</code>&#13;
  <code class="p">}</code> <code class="p">}</code> <code class="o">/&gt;</code></pre>&#13;
&#13;
<p>You want the extra type safety so you can work with a type-safe <code>item</code> in your <code>on​Sel⁠ect</code> callback. Say you want to create a <code>ref</code> to the inner <code>ul</code> element: how do you proceed? Let’s change the <code>ClickableList</code> component to an inner function component that takes a <code>ForwardRef</code> and use it as an argument in the <code>React.forwardRef</code> function:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// The original component extended with a `ref`</code>&#13;
<code class="kd">function</code> <code class="nx">ClickableListInner</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">ref</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ForwardedRef</code><code class="o">&lt;</code><code class="nx">HTMLUListElement</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">ul</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">ref</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nt">li</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code><code class="o">&gt;</code>&#13;
          <code class="o">&lt;</code><code class="nt">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{(</code><code class="nx">el</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">props</code><code class="p">.</code><code class="nx">onSelect</code><code class="p">(</code><code class="nx">item</code><code class="p">)}</code><code class="o">&gt;</code><code class="nx">Select</code><code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code>&#13;
          <code class="p">{</code><code class="nx">item</code><code class="p">}</code>&#13;
        <code class="o">&lt;/</code><code class="nt">li</code><code class="o">&gt;</code>&#13;
      <code class="p">))}</code>&#13;
    <code class="o">&lt;/</code><code class="nt">ul</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// As an argument in `React.forwardRef`</code>&#13;
<code class="kr">const</code> <code class="nx">ClickableList</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">forwardRef</code><code class="p">(</code><code class="nx">ClickableListInner</code><code class="p">)</code></pre>&#13;
&#13;
<p>This compiles but has one downside: we can’t assign a generic type variable for <code>Cl⁠ick⁠ab⁠le​Li⁠st⁠Prop⁠s</code>. It becomes <code>unknown</code> by default. This is good compared to <code>any</code> but also slightly annoying. When we use <code>ClickableList</code>, we know which items to pass along, and we want to have them typed accordingly! So how can we achieve this? The answer is tricky …​ and you have a couple of options.</p>&#13;
&#13;
<p>The first option is to do a type assertion that restores the original function signature:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">ClickableList</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">forwardRef</code><code class="p">(</code><code class="nx">ClickableListInner</code><code class="p">)</code> <code class="kr">as</code> <code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">ref</code><code class="o">?:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ForwardedRef</code><code class="o">&lt;</code><code class="nx">HTMLUListElement</code><code class="o">&gt;</code> <code class="p">}</code>&#13;
<code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ReturnType</code><code class="o">&lt;</code><code class="k">typeof</code> <code class="nx">ClickableListInner</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Type assertions work great if you happen to have only a few situations where you need generic <code>forwardRef</code> components, but they might be too clumsy when you work with lots of them. Also, you introduce an unsafe operator for something that should be default behavior.</p>&#13;
&#13;
<p>The second option is to create custom references with wrapper components. While <code>ref</code> is a reserved word for React components, you can use your own custom props to mimic a similar behavior. This works just as well:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">items</code><code class="o">:</code> <code class="nx">T</code><code class="p">[];</code>&#13;
  <code class="nx">onSelect</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="nx">mRef</code><code class="o">?:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Ref</code><code class="o">&lt;</code><code class="nx">HTMLUListElement</code><code class="o">&gt;</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">ClickableList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">ul</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">mRef</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nt">li</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code><code class="o">&gt;</code>&#13;
          <code class="o">&lt;</code><code class="nt">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{(</code><code class="nx">el</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">props</code><code class="p">.</code><code class="nx">onSelect</code><code class="p">(</code><code class="nx">item</code><code class="p">)}</code><code class="o">&gt;</code><code class="nx">Select</code><code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code>&#13;
          <code class="p">{</code><code class="nx">item</code><code class="p">}</code>&#13;
        <code class="o">&lt;/</code><code class="nt">li</code><code class="o">&gt;</code>&#13;
      <code class="p">))}</code>&#13;
    <code class="o">&lt;/</code><code class="nt">ul</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You introduce a new API, however. For the record, there is also the possibility of using a wrapper component that allows you to use <code>forwardRef</code> inside an <em>inner</em> component and expose a custom <code>ref</code> property to the outside:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">ClickableListInner</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">ref</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ForwardedRef</code><code class="o">&lt;</code><code class="nx">HTMLUListElement</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">ul</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">ref</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nt">li</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code><code class="o">&gt;</code>&#13;
          <code class="o">&lt;</code><code class="nt">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{(</code><code class="nx">el</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">props</code><code class="p">.</code><code class="nx">onSelect</code><code class="p">(</code><code class="nx">item</code><code class="p">)}</code><code class="o">&gt;</code><code class="nx">Select</code><code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code>&#13;
          <code class="p">{</code><code class="nx">item</code><code class="p">}</code>&#13;
        <code class="o">&lt;/</code><code class="nt">li</code><code class="o">&gt;</code>&#13;
      <code class="p">))}</code>&#13;
    <code class="o">&lt;/</code><code class="nt">ul</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">ClickableListWithRef</code> <code class="o">=</code> <code class="nx">forwardRef</code><code class="p">(</code><code class="nx">ClickableListInner</code><code class="p">);</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ClickableListWithRefProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">mRef</code><code class="o">?:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Ref</code><code class="o">&lt;</code><code class="nx">HTMLUListElement</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">ClickableList</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">({</code>&#13;
  <code class="nx">mRef</code><code class="p">,</code>&#13;
  <code class="p">...</code><code class="nx">props</code>&#13;
<code class="p">}</code><code class="o">:</code> <code class="nx">ClickableListWithRefProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">ClickableListWithRef</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">mRef</code><code class="p">}</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Both are valid solutions if the only thing you want to achieve is passing that ref. If you want to have a consistent API, you might look for something else.</p>&#13;
&#13;
<p>The third and final option is to augment <code>forwardRef</code> with your own type definitions. <a data-primary="higher-order functions" data-type="indexterm" id="id891"/>TypeScript has a feature called <a href="https://oreil.ly/rVsq9"><em>higher-order function type inference</em></a> that allows propagating free type parameters to the outer function.</p>&#13;
&#13;
<p>This sounds a lot like what we want with <code>forwardRef</code> to begin with, but it doesn’t work with our current typings. The reason is that higher-order function type inference works only on plain function types. The function declarations inside  &#13;
<span class="keep-together"><code>forwardRef</code></span> also add properties for <code>defaultProps</code> and so on. These are relics from the class component days, things you might not want to use anyway.</p>&#13;
&#13;
<p>So without the additional properties, it should be possible to use higher-order &#13;
<span class="keep-together">function</span> type inference!</p>&#13;
&#13;
<p>We are using TypeScript, so we have the ability to redeclare and redefine global &#13;
<span class="keep-together"><code>module</code></span>, <code>namespace</code>, and <code>interface</code> declarations on our own. Declaration merging is a powerful tool, and we’re going to use it:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Redecalare forwardRef</code>&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s2">"react"</code> <code class="p">{</code>&#13;
  <code class="kd">function</code> <code class="nx">forwardRef</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">P</code> <code class="o">=</code> <code class="p">{}</code><code class="o">&gt;</code><code class="p">(</code>&#13;
    <code class="nx">render</code><code class="o">:</code> <code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">P</code><code class="p">,</code> <code class="nx">ref</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Ref</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ReactElement</code> <code class="o">|</code> <code class="kc">null</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="p">(</code><code class="nx">props</code><code class="o">:</code> <code class="nx">P</code> <code class="o">&amp;</code> <code class="nx">React</code><code class="p">.</code><code class="nx">RefAttributes</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ReactElement</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
&#13;
<code class="c1">// Just write your components like you're used to!</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">items</code><code class="o">:</code> <code class="nx">T</code><code class="p">[];</code>&#13;
  <code class="nx">onSelect</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
<code class="kd">function</code> <code class="nx">ClickableListInner</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="nx">ClickableListProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">ref</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ForwardedRef</code><code class="o">&lt;</code><code class="nx">HTMLUListElement</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">ul</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">ref</code><code class="p">}</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code> <code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
        <code class="o">&lt;</code><code class="nt">li</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">i</code><code class="p">}</code><code class="o">&gt;</code>&#13;
          <code class="o">&lt;</code><code class="nt">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{(</code><code class="nx">el</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">props</code><code class="p">.</code><code class="nx">onSelect</code><code class="p">(</code><code class="nx">item</code><code class="p">)}</code><code class="o">&gt;</code><code class="nx">Select</code><code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code>&#13;
          <code class="p">{</code><code class="nx">item</code><code class="p">}</code>&#13;
        <code class="o">&lt;/</code><code class="nt">li</code><code class="o">&gt;</code>&#13;
      <code class="p">))}</code>&#13;
    <code class="o">&lt;/</code><code class="nt">ul</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">ClickableList</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">forwardRef</code><code class="p">(</code><code class="nx">ClickableListInner</code><code class="p">);</code></pre>&#13;
&#13;
<p>The nice thing about this solution is that you write regular JavaScript again and work exclusively on a type level. Also, redeclarations are module scoped: no interference with any <code>forwardRef</code> calls from other modules!<a data-startref="ix_10-03-asciidoc5" data-type="indexterm" id="id892"/><a data-startref="ix_10-03-asciidoc1" data-type="indexterm" id="id893"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.5 Providing Types for the Context API" data-type="sect1"><div class="sect1" id="ch10_context_api">&#13;
<h1>10.5 Providing Types for the Context API</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id158">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="context API, type definitions for" data-type="indexterm" id="ix_10-04-asciidoc0"/><a data-primary="globals, type definitions for context API" data-type="indexterm" id="ix_10-04-asciidoc2"/><a data-primary="React, TypeScript and" data-secondary="type definitions for context API" data-type="indexterm" id="ix_10-04-asciidoc4"/><a data-primary="type definitions" data-secondary="for context API" data-type="indexterm" id="ix_10-04-asciidoc6"/>You want to use the context API for globals in your app, but you don’t know the best way to deal with type definitions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id894">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Either set default properties for context and let the type be inferred or create a partial of your context’s properties and instantiate the generic type parameter explicitly. If you don’t want to provide default values, but want to make sure that all properties are provided, create a helper function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id159">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>React’s context API allows you to share data on a global level. To use it, you need two things:</p>&#13;
<dl>&#13;
<dt>Providers</dt>&#13;
<dd>&#13;
<p>Providers pass data to a subtree.</p>&#13;
</dd>&#13;
<dt>Consumers</dt>&#13;
<dd>&#13;
<p>Consumers are components that <em>consume</em> the passed data inside render props.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>With React’s typings, you can use context without doing anything else most of the time. Everything is done using type inference and generics.</p>&#13;
&#13;
<p>First, we create a context. Here, we want to store global application settings, like a theme and the app’s language, along with the global state. When creating a React context, we want to pass default properties:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">AppContext</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createContext</code><code class="p">({</code>&#13;
  <code class="nx">authenticated</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nx">lang</code><code class="o">:</code> <code class="s2">"en"</code><code class="p">,</code>&#13;
  <code class="nx">theme</code><code class="o">:</code> <code class="s2">"dark"</code><code class="p">,</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>And with that, everything you need to do in terms of types is done for you. We have three properties: <code>authenticated</code>, <code>lang</code>, and <code>theme</code>; they are of types <code>boolean</code> and <code>string</code>. React’s typings&#13;
take this information to provide you with the correct types when you use them.</p>&#13;
&#13;
<p>Next, a component high up in your component tree needs to provide context—for example, the application’s root component. This provider trickles down the values you’ve set to every consumer below:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">AppContext</code><code class="nt">.</code><code class="nt">Provider</code>&#13;
      <code class="nx">value</code><code class="o">=</code><code class="p">{{</code>&#13;
        <code class="nx">authenticated</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
        <code class="nx">lang</code><code class="o">:</code> <code class="s2">"de"</code><code class="p">,</code>&#13;
        <code class="nx">theme</code><code class="o">:</code> <code class="s2">"light"</code><code class="p">,</code>&#13;
      <code class="p">}}</code>&#13;
    <code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nt">Header</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;/</code><code class="nt">AppContext.Provider</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, every component inside this tree can consume this context. You already get type errors when you forget a&#13;
property or use the wrong type:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
<code class="c1">// Property 'theme' is missing in type '{ lang: string; }' but required</code>&#13;
<code class="c1">// in type '{ lang: string; theme: string; authenticated: boolean }'.(2741)</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">AppContext</code><code class="nt">.</code><code class="nt">Provider</code>&#13;
      <code class="nx">value</code><code class="o">=</code><code class="p">{{</code>&#13;
        <code class="nx">lang</code><code class="o">:</code> <code class="s2">"de"</code><code class="p">,</code>&#13;
      <code class="p">}}</code>&#13;
    <code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nt">Header</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;/</code><code class="nt">AppContext.Provider</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, let’s consume our global state. Consuming context can be done via render props. You can destructure your render props as deep as you like, to get only the props you want to deal with:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Header</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">AppContext</code><code class="nt">.</code><code class="nt">Consumer</code><code class="o">&gt;</code>&#13;
      <code class="p">{({</code> <code class="nx">authenticated</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="nx">authenticated</code><code class="p">)</code> <code class="p">{</code>&#13;
          <code class="k">return</code> <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nx">Logged</code> <code class="k">in!</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;;</code>&#13;
        <code class="p">}</code>&#13;
        <code class="k">return</code> <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nx">You</code> <code class="nx">need</code> <code class="nx">to</code> <code class="nx">sign</code> <code class="k">in</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;;</code>&#13;
      <code class="p">}}</code>&#13;
    <code class="o">&lt;/</code><code class="nt">AppContext.Consumer</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Another way of using context is via the respective <code>useContext</code> hook:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Header</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">authenticated</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">useContext</code><code class="p">(</code><code class="nx">AppContext</code><code class="p">);</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">authenticated</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nx">Logged</code> <code class="k">in!</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nx">You</code> <code class="nx">need</code> <code class="nx">to</code> <code class="nx">sign</code> <code class="k">in</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Because we defined our properties earlier with the right types, <code>authenticated</code> is of type boolean at this point. Again,&#13;
we didn’t have to do anything to get this extra &#13;
<span class="keep-together">type safety.</span></p>&#13;
&#13;
<p>The whole previous example works best if we have default properties and values. Sometimes you don’t have default values or&#13;
you need to be more flexible in which properties you want to set.</p>&#13;
&#13;
<p>Instead of inferring everything from default values, we annotate the generic type parameter explicitly, not with the full type, but with a <code>Partial</code>.</p>&#13;
&#13;
<p>We create a type for the context’s props:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ContextProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">authenticated</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
  <code class="nx">lang</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">theme</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>And initialize the new context:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">AppContext</code> <code class="o">=</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createContext</code><code class="o">&lt;</code><code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">ContextProps</code><code class="o">&gt;&gt;</code><code class="p">({});</code></pre>&#13;
&#13;
<p>Changing the semantics of the context’s default properties has some side effects on your components as well. Now you don’t need to provide every value; an empty context object can do the same! All your properties are optional:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">AppContext</code><code class="nt">.</code><code class="nt">Provider</code>&#13;
      <code class="nx">value</code><code class="o">=</code><code class="p">{{</code>&#13;
        <code class="nx">authenticated</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
      <code class="p">}}</code>&#13;
    <code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nt">Header </code><code class="o">/&gt;</code>&#13;
    <code class="o">&lt;/</code><code class="nt">AppContext.Provider</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This also means you need to check for every property if it’s defined. This doesn’t change the code where you rely on <code>boolean</code> values, but every other property needs to have another <code>undefined</code> check:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Header</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">authenticated</code><code class="p">,</code> <code class="nx">lang</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">useContext</code><code class="p">(</code><code class="nx">AppContext</code><code class="p">);</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">authenticated</code> <code class="o">&amp;&amp;</code> <code class="nx">lang</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nx">Logged</code> <code class="k">in!</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nt">p</code><code class="o">&gt;</code><code class="nx">Your</code> <code class="nx">language</code> <code class="nx">setting</code> <code class="nx">is</code> <code class="nx">set</code> <code class="nx">to</code> <code class="p">{</code><code class="nx">lang</code><code class="p">}</code><code class="o">&lt;/</code><code class="nt">p</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="o">/&gt;</code> <code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nx">You</code> <code class="nx">need</code> <code class="nx">to</code> <code class="nx">sign</code> <code class="k">in</code> <code class="p">(</code><code class="nx">or</code> <code class="nx">don</code><code class="err">'</code><code class="nx">t</code> <code class="nx">you</code> <code class="nx">have</code> <code class="nx">a</code> <code class="nx">language</code> <code class="nx">setting</code><code class="o">?</code><code class="p">)</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">If you can’t provide default values and want to make sure that all properties are provided by a context provider, you can help yourself with a helper function. Here, we want explicit generic instantiation to supply a type but give the right type guards so that when consuming context, all possibly undefined values are correctly set:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code><code> </code><code class="nx">createContext</code><code class="o">&lt;</code><code class="nx">Props</code><code> </code><code class="kr">extends</code><code> </code><code class="p">{</code><code class="p">}</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_typescript_and_react_CO1-1" id="co_typescript_and_react_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">ctx</code><code> </code><code class="o">=</code><code> </code><code class="nx">React</code><code class="p">.</code><code class="nx">createContext</code><code class="o">&lt;</code><code class="nx">Props</code><code> </code><code class="o">|</code><code> </code><code class="kc">undefined</code><code class="o">&gt;</code><code class="p">(</code><code class="kc">undefined</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_typescript_and_react_CO1-2" id="co_typescript_and_react_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="kd">function</code><code> </code><code class="nx">useInnerCtx</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_typescript_and_react_CO1-3" id="co_typescript_and_react_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="kr">const</code><code> </code><code class="nx">c</code><code> </code><code class="o">=</code><code> </code><code class="nx">useContext</code><code class="p">(</code><code class="nx">ctx</code><code class="p">)</code><code class="p">;</code><code>&#13;
    </code><code class="k">if</code><code> </code><code class="p">(</code><code class="nx">c</code><code> </code><code class="o">===</code><code> </code><code class="kc">undefined</code><code class="p">)</code><code> </code><a class="co" href="#callout_typescript_and_react_CO1-4" id="co_typescript_and_react_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
      </code><code class="k">throw</code><code> </code><code class="k">new</code><code> </code><code class="nb">Error</code><code class="p">(</code><code class="s2">"Context must be consumed within a Provider"</code><code class="p">)</code><code class="p">;</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="nx">c</code><code class="p">;</code><code> </code><a class="co" href="#callout_typescript_and_react_CO1-5" id="co_typescript_and_react_CO1-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="p">[</code><code class="nx">useInnerCtx</code><code class="p">,</code><code> </code><code class="nx">ctx</code><code class="p">.</code><code class="nx">Provider</code><code> </code><code class="kr">as</code><code> </code><code class="nx">React</code><code class="p">.</code><code class="nx">Provider</code><code class="o">&lt;</code><code class="nx">Props</code><code class="o">&gt;</code><code class="p">]</code><code> </code><code class="kr">as</code><code> </code><code class="kr">const</code><code class="p">;</code><code> </code><a class="co" href="#callout_typescript_and_react_CO1-6" id="co_typescript_and_react_CO1-6"><img alt="6" src="assets/6.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>What’s going on in <code>createContext</code>?</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_typescript_and_react_CO1-1" id="callout_typescript_and_react_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We create a function that has no function arguments but generic type parameters. Without the connection to function parameters, we can’t instantiate <code>Props</code> via inference. This means that for <code>createContext</code> to provide proper types, we need to explicitly instantiate it.</p></dd>&#13;
<dt><a class="co" href="#co_typescript_and_react_CO1-2" id="callout_typescript_and_react_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We create a context that allows for <code>Props</code> or <code>undefined</code>. With <code>undefined</code> added to the type, we can pass <code>undefined</code> as value. No default values!</p></dd>&#13;
<dt><a class="co" href="#co_typescript_and_react_CO1-3" id="callout_typescript_and_react_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Inside <code>createContext</code>, we create a custom hook. This hook wraps <code>useContext</code> using the newly created context <code>ctx</code>.</p></dd>&#13;
<dt><a class="co" href="#co_typescript_and_react_CO1-4" id="callout_typescript_and_react_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Then we do a type guard where we check if the returned <code>Props</code> includes &#13;
<span class="keep-together"><code>undefined</code>.</span> Remember, when calling <code>createContext</code>, we instantiate the generic type parameter with <code>Props | undefined</code>. This line removes <code>undefined</code> from the union type again.</p></dd>&#13;
<dt><a class="co" href="#co_typescript_and_react_CO1-5" id="callout_typescript_and_react_CO1-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Which means that here, <code>c</code> is <code>Props</code>.</p></dd>&#13;
<dt><a class="co" href="#co_typescript_and_react_CO1-6" id="callout_typescript_and_react_CO1-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>We assert that <code>ctx.Provider</code> doesn’t take <code>undefined</code> values. We call <code>as const</code> to return <code>[useInnerContext, ctx.Provider]</code> as a tuple type.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Use <code>createContext</code> similar to <code>React.createContext</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="p">[</code><code class="nx">useAppContext</code><code class="p">,</code> <code class="nx">AppContextProvider</code><code class="p">]</code> <code class="o">=</code> <code class="nx">createContext</code><code class="o">&lt;</code><code class="nx">ContextProps</code><code class="o">&gt;</code><code class="p">();</code></pre>&#13;
&#13;
<p>When using <code>AppContextProvider</code>, we need to provide all values:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nt">AppContextProvider</code>&#13;
      <code class="nx">value</code><code class="o">=</code><code class="p">{{</code> <code class="nx">lang</code><code class="o">:</code> <code class="s2">"en"</code><code class="p">,</code> <code class="nx">theme</code><code class="o">:</code> <code class="s2">"dark"</code><code class="p">,</code> <code class="nx">authenticated</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}}</code>&#13;
    <code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nt">Header</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;/</code><code class="nt">AppContextProvider</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Header</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="c1">// consuming Context doesn't change much</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">authenticated</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">useAppContext</code><code class="p">();</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">authenticated</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nx">Logged</code> <code class="k">in!</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">h1</code><code class="o">&gt;</code><code class="nx">You</code> <code class="nx">need</code> <code class="nx">to</code> <code class="nx">sign</code> <code class="k">in</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>Depending on your use case, you have exact types without too much overhead.<a data-startref="ix_10-04-asciidoc6" data-type="indexterm" id="id895"/><a data-startref="ix_10-04-asciidoc4" data-type="indexterm" id="id896"/><a data-startref="ix_10-04-asciidoc2" data-type="indexterm" id="id897"/><a data-startref="ix_10-04-asciidoc0" data-type="indexterm" id="id898"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.6 Typing Higher-Order Components" data-type="sect1"><div class="sect1" id="ch10_hoc">&#13;
<h1>10.6 Typing Higher-Order Components</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id160">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="higher order components" data-type="indexterm" id="ix_10-05-asciidoc0"/><a data-primary="React, TypeScript and" data-secondary="typing higher order components" data-type="indexterm" id="ix_10-05-asciidoc1"/><a data-primary="React.ComponentType&lt;P&gt;" data-type="indexterm" id="ix_10-05-asciidoc2"/>You are writing <em>higher-order components</em> to preset certain properties for other components but don’t know how to type them.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id899">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>React.ComponentType&lt;P&gt;</code> type from <code>@types/react</code> to define a component that extends your preset attributes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id161">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>React is influenced by functional programming, which we see in the way components are designed (via functions), assembled (via composition), and updated (stateless, unidirectional data flow). It didn’t take long for functional programming techniques and paradigms to find their way into React development. One such technique is higher-order components, which draw inspiration from <em>higher-order functions</em>.</p>&#13;
&#13;
<p><a data-primary="higher-order functions" data-type="indexterm" id="id900"/>Higher-order functions accept one or more parameters to return a new function. Sometimes those parameters are here to prefill certain other parameters, as we see, for example, in all currying recipes from <a data-type="xref" href="ch07.html#ch07">Chapter 7</a>. Higher-order components are similar: they take one or more components and return themselves another component. Usually, you create them to prefill certain properties where you want to make sure they won’t be changed later on.</p>&#13;
&#13;
<p>Think about a general-purpose <code>Card</code> component, which takes <code>title</code> and <code>content</code> &#13;
<span class="keep-together">as strings:</span></p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CardProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">title</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">content</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Card</code><code class="p">({</code> <code class="nx">title</code><code class="p">,</code> <code class="nx">content</code> <code class="p">}</code><code class="o">:</code> <code class="nx">CardProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nt">h2</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">title</code><code class="p">}</code><code class="o">&lt;/</code><code class="nt">h2</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nt">div</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">content</code><code class="p">}</code><code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;/</code><code class="o">&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You use this card to present certain events, like warnings, information bubbles, and error messages. The most basic information card has <code>"Info"</code> as its title:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="o">&lt;</code><code class="nt">Card</code> <code class="nx">title</code><code class="o">=</code><code class="s2">"Info"</code> <code class="nx">content</code><code class="o">=</code><code class="s2">"Your task has been processed"</code> <code class="o">/&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>You could subset the properties of <code>Card</code> to allow for only a certain subset of strings for <code>title</code>, but on the other hand, you want to be able to reuse <code>Card</code> as much as possible. So you create a new component that already sets <code>title</code> to <code>"Info"</code> and only allows for other properties to be set:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Info</code> <code class="o">=</code> <code class="nx">withInjectedProps</code><code class="p">({</code> <code class="nx">title</code><code class="o">:</code> <code class="s2">"Info"</code> <code class="p">},</code> <code class="nx">Card</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// This should work</code>&#13;
<code class="o">&lt;</code><code class="nt">Info</code> <code class="nx">content</code><code class="o">=</code><code class="s2">"Your task has been processed"</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// This should throw an error</code>&#13;
<code class="o">&lt;</code><code class="nt">Info</code> <code class="nx">content</code><code class="o">=</code><code class="s2">"Your task has been processed"</code> <code class="nx">title</code><code class="o">=</code><code class="s2">"Warning"</code> <code class="o">/&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>In other words, you <em>inject</em> a subset of properties and set the remaining ones with the newly created component. A function <code>withInjectedProps</code> is easily written:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">withInjectedProps</code><code class="p">(</code><code class="nx">injected</code><code class="p">,</code> <code class="nx">Component</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">props</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">newProps</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">injected</code><code class="p">,</code> <code class="p">...</code><code class="nx">props</code> <code class="p">};</code>&#13;
    <code class="k">return</code> <code class="o">&lt;</code><code class="nt">Component</code> <code class="p">{...</code><code class="nx">newProps</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It takes the <code>injected</code> props and a <code>Component</code> as parameters, returns a new function component that takes the remaining props as parameters, and instantiates the original component with merged properties.</p>&#13;
&#13;
<p>So how do we type <code>withInjectedProps</code>? Let’s look at the result and see what’s inside:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code><code> </code><code class="nx">withInjectedProps</code><code class="o">&lt;</code><code class="nx">T</code><code> </code><code class="kr">extends</code><code> </code><code class="p">{</code><code class="p">}</code><code class="p">,</code><code> </code><code class="nx">U</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code> </code><a class="co" href="#callout_typescript_and_react_CO2-1" id="co_typescript_and_react_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">injected</code><code class="o">:</code><code> </code><code class="nx">T</code><code class="p">,</code><code>&#13;
  </code><code class="nx">Component</code><code class="o">:</code><code> </code><code class="nx">React</code><code class="p">.</code><code class="nx">ComponentType</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_typescript_and_react_CO2-2" id="co_typescript_and_react_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="kd">function</code><code> </code><code class="p">(</code><code class="nx">props</code><code class="o">:</code><code> </code><code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code><code> </code><code class="kr">keyof</code><code> </code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_typescript_and_react_CO2-3" id="co_typescript_and_react_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="kr">const</code><code> </code><code class="nx">newProps</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">injected</code><code class="p">,</code><code> </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">props</code><code> </code><code class="p">}</code><code> </code><code class="kr">as</code><code> </code><code class="nx">U</code><code class="p">;</code><code> </code><a class="co" href="#callout_typescript_and_react_CO2-4" id="co_typescript_and_react_CO2-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><code class="k">return</code><code> </code><code class="o">&lt;</code><code class="nt">Component</code><code> </code><code class="p">{</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">newProps</code><code class="p">}</code><code> </code><code class="o">/</code><code class="o">&gt;</code><code class="p">;</code><code>&#13;
  </code><code class="p">}</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
&#13;
<p>Here is what’s going on:</p>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_typescript_and_react_CO2-1" id="callout_typescript_and_react_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We need to define two generic type parameters. <code>T</code> is for the props we already inject; it extends from <code>{}</code> to make sure we only pass objects. <code>U</code> is a generic type parameter for all props of <code>Component</code>. <code>U</code> <em>extends</em> <code>T</code>, which means that <code>U</code> is a subset of <code>T</code>. This says that <code>U</code> has more properties than <code>T</code> but needs to include what <code>T</code> already has defined.</p></dd>&#13;
<dt><a class="co" href="#co_typescript_and_react_CO2-2" id="callout_typescript_and_react_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We define <code>Component</code> to be of type <code>React.ComponentType&lt;U&gt;</code>. This includes class components as well as function components and says that props will be set to <code>U</code>. With the relationship of <code>T</code> and <code>U</code> and the way we defined the parameters of <code>withInjectedProps</code>, we ensure that everything that will be passed for <code>Component</code> defines a subset of properties for <code>Component</code> with <code>injected</code>. If we make a typo, we quickly get the first error message!</p></dd>&#13;
<dt><a class="co" href="#co_typescript_and_react_CO2-3" id="callout_typescript_and_react_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The function component that will be returned takes the remaining props. With <code>Omit&lt;U, keyof T&gt;</code> we make sure that we don’t allow prefilled attributes to be set again.</p></dd>&#13;
<dt><a class="co" href="#co_typescript_and_react_CO2-4" id="callout_typescript_and_react_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Merging <code>T</code> and <code>Omit&lt;U, keyof T&gt;</code> should result in <code>U</code> again, but since generic type parameters can be explicitly instantiated with something different, they might not fit <code>Component</code> again. A type assertion helps ensure that the props are actually what we want.</p></dd>&#13;
</dl>&#13;
&#13;
<p>And that’s it! With those new types, we get proper autocomplete and errors:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">Info</code> <code class="o">=</code> <code class="nx">withInjectedProps</code><code class="p">({</code> <code class="nx">title</code><code class="o">:</code> <code class="s2">"Info"</code> <code class="p">},</code> <code class="nx">Card</code><code class="p">);</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">Info</code> <code class="nx">content</code><code class="o">=</code><code class="s2">"Your task has been processed"</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="o">&lt;</code><code class="nt">Info</code> <code class="nx">content</code><code class="o">=</code><code class="s2">"Your task has been processed"</code> <code class="nx">title</code><code class="o">=</code><code class="s2">"Warning"</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="c1">//                                           ^</code>&#13;
<code class="c1">// Type '{ content: string; title: string; }' is not assignable</code>&#13;
<code class="c1">// to type 'IntrinsicAttributes &amp; Omit&lt;CardProps, "title"&gt;'.</code>&#13;
<code class="c1">// Property 'title' does not exist on type</code>&#13;
<code class="c1">// 'IntrinsicAttributes &amp; Omit&lt;CardProps, "title"&gt;'.(2322)</code></pre>&#13;
&#13;
<p><code>withInjectedProps</code> is so flexible that we can derive higher-order functions that create higher-order components for various situations, like <code>withTitle</code>, which is here to prefill <code>title</code> attributes of type <code>string</code>:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">withTitle</code><code class="o">&lt;</code><code class="nx">U</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">title</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">title</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">Component</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ComponentType</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">withInjectedProps</code><code class="p">({</code> <code class="nx">title</code> <code class="p">},</code> <code class="nx">Component</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Your functional programming goodness knows no limits.<a data-startref="ix_10-05-asciidoc2" data-type="indexterm" id="id901"/><a data-startref="ix_10-05-asciidoc1" data-type="indexterm" id="id902"/><a data-startref="ix_10-05-asciidoc0" data-type="indexterm" id="id903"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.7 Typing Callbacks in React’s Synthetic Event System" data-type="sect1"><div class="sect1" id="ch10_events">&#13;
<h1>10.7 Typing Callbacks in React’s Synthetic Event System</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id162">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="callbacks" data-secondary="typing in React's synthetic event system" data-type="indexterm" id="ix_10-06-asciidoc0"/><a data-primary="React, TypeScript and" data-secondary="typing callbacks in synthetic event system" data-type="indexterm" id="ix_10-06-asciidoc1"/><a data-primary="synthetic event system (React)" data-type="indexterm" id="ix_10-06-asciidoc2"/>You want to get the best possible typings for all browser events in React and use the type system to restrict your callbacks to compatible elements.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id904">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the event types of <code>@types/react</code> and specialize on components using generic type parameters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id163">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Web applications become alive through user interaction. Every user interaction triggers an event. Events are key, and TypeScript’s React typings have great support for events, but they require you not to use the native events from <em>lib.dom.d.ts</em>. If you do, React throws errors:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">WithChildren</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="p">{}</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">children</code><code class="o">?:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ReactNode</code> <code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ButtonProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">onClick</code><code class="o">:</code> <code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="nx">MouseEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="nx">WithChildren</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Button</code><code class="p">({</code> <code class="nx">onClick</code><code class="p">,</code> <code class="nx">children</code> <code class="p">}</code><code class="o">:</code> <code class="nx">ButtonProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">onClick</code><code class="p">}</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">children</code><code class="p">}</code><code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="c1">//               ^</code>&#13;
<code class="c1">// Type '(event: MouseEvent) =&gt; void' is not assignable to</code>&#13;
<code class="c1">// type 'MouseEventHandler&lt;HTMLButtonElement&gt;'.</code>&#13;
<code class="c1">// Types of parameters 'event' and 'event' are incompatible.</code>&#13;
<code class="c1">// Type 'MouseEvent&lt;HTMLButtonElement, MouseEvent&gt;' is missing the following</code>&#13;
<code class="c1">// properties from type 'MouseEvent': offsetX, offsetY, x, y,</code>&#13;
<code class="c1">// and 14 more.(2322)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>React uses its own event system, which we refer to as <em>synthetic events</em>. Synthetic events are cross-browser wrappers around the browser’s native event, with the same interface as its native counterpart but aligned for compatibility. A change to the type from <code>@types/react</code> makes your callbacks compatible again:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">WithChildren</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="p">{}</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">children</code><code class="o">?:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ReactNode</code> <code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">ButtonProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">onClick</code><code class="o">:</code> <code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">MouseEvent</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="nx">WithChildren</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Button</code><code class="p">({</code> <code class="nx">onClick</code><code class="p">,</code> <code class="nx">children</code> <code class="p">}</code><code class="o">:</code> <code class="nx">ButtonProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">onClick</code><code class="p">}</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">children</code><code class="p">}</code><code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The browser’s <code>MouseEvent</code> and <code>React.MouseEvent</code> are different enough for TypeScript’s <em>structural</em> type system, meaning that there are some missing properties in the synthetic counterparts. You can see in the preceding error message that the original <code>MouseEvent</code> has 18 properties more than <code>React.MouseEvent</code>, some of them arguably important, like coordinates and offsets, which come in handy if, for example, you want to draw on a canvas.</p>&#13;
&#13;
<p>If you want to access properties from the original event, you can use the <code>nativeEvent</code> property:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">handleClick</code><code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">MouseEvent</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">nativeEvent</code><code class="p">.</code><code class="nx">offsetX</code><code class="p">,</code> <code class="nx">event</code><code class="p">.</code><code class="nx">nativeEvent</code><code class="p">.</code><code class="nx">offsetY</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">btn</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nt">Button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">handleClick</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Hello</code><code class="o">&lt;/</code><code class="nt">Button</code><code class="o">&gt;</code><code class="p">}</code>;</pre>&#13;
&#13;
<p>Events supported are: <code>AnimationEvent</code>, <code>ChangeEvent</code>, <code>ClipboardEvent</code>, <code>Com⁠pos⁠iti⁠on​Ev⁠ent</code>, <code>DragEvent</code>, <code>FocusEvent</code>, <code>FormEvent</code>, <code>KeyboardEvent</code>, <code>MouseEvent</code>, <code>Poi⁠nt⁠er​Ev⁠ent</code>, <code>TouchEvent</code>, <code>TransitionEvent</code>, and <code>WheelEvent</code>, as well as <code>SyntheticEvent</code> for all other events.</p>&#13;
&#13;
<p>So far, we applied the correct types to make sure we don’t have any compiler errors. Easy enough. But we’re using TypeScript not only to fulfill the ceremony of applying types to keep the compiler from complaining but also to prevent situations that might be problematic.</p>&#13;
&#13;
<p>Let’s think about a button again. Or a link (the <code>a</code> element). Those elements are supposed to be clicked; that’s their purpose. But in the browser, click events can be received by every element. Nothing keeps you from adding <code>onClick</code> to a <code>div</code> element, the element that has the least semantic meaning of all elements, and no assistive technology will tell you that a <code>div</code> can receive a <code>MouseEvent</code> unless you add lots of attributes to it.</p>&#13;
&#13;
<p>Wouldn’t it be great if we could keep our colleagues (and ourselves) from using the defined event handlers on the <em>wrong</em> elements? <code>React.MouseEvent</code> is a generic type that takes compatible elements as its first type. This is set to <code>Element</code>, which is the base type for all elements in the browser. But you are able to define a smaller set of compatible elements by subtyping this generic parameter:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">WithChildren</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="p">{}</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">children</code><code class="o">?:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ReactNode</code> <code class="p">};</code>&#13;
&#13;
<code class="c1">// Button maps to an HTMLButtonElement</code>&#13;
<code class="kr">type</code> <code class="nx">ButtonProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">onClick</code><code class="o">:</code> <code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">MouseEvent</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="nx">WithChildren</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Button</code><code class="p">({</code> <code class="nx">onClick</code><code class="p">,</code> <code class="nx">children</code> <code class="p">}</code><code class="o">:</code> <code class="nx">ButtonProps</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">onClick</code><code class="p">}</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">children</code><code class="p">}</code><code class="o">&lt;/</code><code class="nt">button</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// handleClick accepts events from HTMLButtonElement or HTMLAnchorElement</code>&#13;
<code class="kd">function</code> <code class="nx">handleClick</code><code class="p">(</code>&#13;
  <code class="nx">event</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">MouseEvent</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code> <code class="o">|</code> <code class="nx">HTMLAnchorElement</code><code class="o">&gt;</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">currentTarget</code><code class="p">.</code><code class="nx">tagName</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">button</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nt">Button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">handleClick</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Works</code><code class="o">&lt;</code><code class="nt">/Button&gt;</code><code class="p">;</code>&#13;
<code class="kd">let</code> <code class="nx">link</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nt">a</code> <code class="nx">href</code><code class="o">=</code><code class="s2">"/"</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">handleClick</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Works</code><code class="o">&lt;/</code><code class="nt">a</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">broken</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nt">div</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">handleClick</code><code class="p">}</code><code class="o">&gt;</code><code class="nx">Does</code> <code class="nx">not</code> <code class="nx">work</code><code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="c1">//                ^</code>&#13;
<code class="c1">// Type '(event: MouseEvent&lt;HTMLButtonElement | HTMLAnchorElement,</code>&#13;
<code class="c1">// MouseEvent&gt;) =&gt; void' is not assignable to type</code>&#13;
<code class="c1">//'MouseEventHandler&lt;HTMLDivElement&gt;'.</code>&#13;
<code class="c1">// Types of parameters 'event' and 'event' are incompatible.</code>&#13;
<code class="c1">// Type 'MouseEvent&lt;HTMLDivElement, MouseEvent&gt;' is not assignable to</code>&#13;
<code class="c1">// type 'MouseEvent&lt;HTMLButtonElement | HTMLAnchorElement, MouseEvent&gt;'.</code>&#13;
<code class="c1">// Type 'HTMLDivElement' is not assignable to type #</code>&#13;
<code class="c1">// 'HTMLButtonElement | HTMLAnchorElement'.</code></pre>&#13;
&#13;
<p>Although React’s types give you more flexibility in some areas, it lacks features in others. For example, the browser native <code>InputEvent</code> is not supported in <code>@types/react</code>. The synthetic event system is meant to be a cross-browser solution, and some of React’s compatible browsers still lack implementation of <code>InputEvent</code>. Until they catch up, it’s safe for you to use the base event <code>SyntheticEvent</code>:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">onInput</code><code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">SyntheticEvent</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">event</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code>&#13;
  <code class="c1">// do something</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">inp</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nt">input</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"text"</code> <code class="nx">onInput</code><code class="o">=</code><code class="p">{</code><code class="nx">onInput</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Now you get at least <em>some</em> type safety.<a data-startref="ix_10-06-asciidoc2" data-type="indexterm" id="id905"/><a data-startref="ix_10-06-asciidoc1" data-type="indexterm" id="id906"/><a data-startref="ix_10-06-asciidoc0" data-type="indexterm" id="id907"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="10.8 Typing Polymorphic Components" data-type="sect1"><div class="sect1" id="ch10_polymorphic_props">&#13;
<h1>10.8 Typing Polymorphic Components</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id164">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="polymorphic components" data-type="indexterm" id="ix_10-07-asciidoc0"/><a data-primary="proxy components" data-secondary="typing polymorphic components in React" data-type="indexterm" id="ix_10-07-asciidoc1"/><a data-primary="React, TypeScript and" data-secondary="typing polymorphic components" data-type="indexterm" id="ix_10-07-asciidoc2"/><a data-primary="React.createElement factory" data-type="indexterm" id="ix_10-07-asciidoc3"/>You create a proxy component (see <a data-type="xref" href="#ch10_proxy_components">Recipe 10.1</a>) that needs to behave as one of many different HTML elements. It’s hard to get the right typings.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id908">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Assert forwarded properties as <code>any</code> or use the JSX factory <code>React.createElement</code> directly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id165">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="as components" data-seealso="polymorphic components" data-type="indexterm" id="id909"/>A common pattern in React is to define polymorphic (or <code>as</code>) components, which pre-define behavior but can act as different elements. Think of a call-to-action button, or CTA, which can be a link to a website or an actual HTML button. If you want to style them similarly, they should behave alike, but depending on the context they should have the right HTML element for the right action.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><a data-primary="buttons" data-type="indexterm" id="id910"/>Selecting the right element is an important accessibility factor. <code>a</code> and <code>button</code> elements represent something users can click, but the semantics of <code>a</code> are fundamentally different from the semantics of a <code>button</code>. <code>a</code> is short for anchor and needs to have a reference (<code>href</code>) to a destination. A <code>button</code> can be clicked, but the action is usually scripted via JavaScript. Both elements can look the same, but they act differently. Not only do they act differently, but they also are announced differently using assistive technologies, like screen readers. Think about your users and select the right element for the right purpose.</p>&#13;
</div>&#13;
&#13;
<p>The idea is that you have an <code>as</code> prop in your component that selects the element type. Depending on the element type of <code>as</code>, you can forward properties that fit the element type. Of course, you can combine this pattern with everything that you have seen in <a data-type="xref" href="#ch10_proxy_components">Recipe 10.1</a>:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="o">&lt;</code><code class="nt">Cta</code> <code class="kr">as</code><code class="o">=</code><code class="s2">"a"</code> <code class="nx">href</code><code class="o">=</code><code class="s2">"https://typescript-cookbook.com"</code><code class="o">&gt;</code>&#13;
  <code class="nx">Hey</code> <code class="nx">hey</code>&#13;
<code class="o">&lt;/</code><code class="nt">Cta</code><code class="o">&gt;</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">Cta</code> <code class="kr">as</code><code class="o">=</code><code class="s2">"button"</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* do something */</code> <code class="p">}}</code><code class="o">&gt;</code>&#13;
  <code class="nx">My</code> <code class="nx">my</code>&#13;
<code class="o">&lt;/</code><code class="nt">Cta</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>When throwing TypeScript into the mix, you want to make sure that you get autocomplete for the right props and errors for the wrong properties. If you add an <code>href</code> to a <code>button</code>, TypeScript should give you the correct squiggly lines:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Type '{ children: string; as: "button"; type: "button"; href: string; }'</code>&#13;
<code class="c1">// is not assignable to type 'IntrinsicAttributes &amp; { as: "button"; } &amp;</code>&#13;
<code class="c1">// ClassAttributes&lt;HTMLButtonElement&gt; &amp;</code>&#13;
<code class="c1">// ButtonHTMLAttributes&lt;HTMLButtonElement&gt; &amp; { ...; }'.</code>&#13;
<code class="c1">// Property 'href' does not exist on type ... (2322)</code>&#13;
<code class="c1">//                             v</code>&#13;
<code class="o">&lt;</code><code class="nt">Cta</code> <code class="kr">as</code><code class="o">=</code><code class="s2">"button"</code> <code class="kr">type</code><code class="o">=</code><code class="s2">"button"</code> <code class="nx">href</code><code class="o">=</code><code class="s2">""</code> <code class="nx">ref</code><code class="o">=</code><code class="p">{(</code><code class="nx">el</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">el</code><code class="o">?</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code><code class="o">&gt;</code>&#13;
  <code class="nx">My</code> <code class="nx">my</code>&#13;
<code class="o">&lt;/</code><code class="nt">Cta</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>Let’s try to type <code>Cta</code>. First, we develop the component without types at all. In JavaScript, things don’t look too complicated:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Cta</code><code class="p">({</code> <code class="kr">as</code><code class="o">:</code> <code class="nx">Component</code><code class="p">,</code> <code class="p">...</code><code class="nx">props</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">Component</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We extract the <code>as</code> prop and rename it as <code>Component</code>. This is a destructuring mechanism from JavaScript that is syntactically similar to a TypeScript annotation but works on destructured properties and not on the object itself (where you’d need a type annotation). We rename it to an uppercase component so we can instantiate it via JSX. The remaining props will be collected in <code>...props</code> and spread out when creating the component. Note that you can also spread out children with <code>...props</code>, a nice little side effect of JSX.</p>&#13;
&#13;
<p>When we want to type <code>Cta</code>, we create a <code>CtaProps</code> type that works on either <code>"a"</code> elements or <code>"button"</code> elements and takes the remaining props from <code>JS⁠X.I⁠ntr⁠ins⁠ic​Ele⁠me⁠nts</code>, similar to what we’ve seen in <a data-type="xref" href="#ch10_proxy_components">Recipe 10.1</a>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CtaElements</code> <code class="o">=</code> <code class="s2">"a"</code> <code class="o">|</code> <code class="s2">"button"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">CtaProps</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">CtaElements</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="kr">as</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="nx">T</code><code class="p">];</code></pre>&#13;
&#13;
<p>When we wire up our types to <code>Cta</code>, we see that the function signature works very well with just a few extra annotations. But when instantiating the component, we get quite an elaborate error that tells us how much is going wrong:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Cta</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">CtaElements</code><code class="o">&gt;</code><code class="p">({</code>&#13;
  <code class="kr">as</code><code class="o">:</code> <code class="nx">Component</code><code class="p">,</code>&#13;
  <code class="p">...</code><code class="nx">props</code>&#13;
<code class="p">}</code><code class="o">:</code> <code class="nx">CtaProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">Component</code> <code class="p">{...</code><code class="nx">props</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="c1">//        ^</code>&#13;
<code class="c1">// Type 'Omit&lt;CtaProps&lt;T&gt;, "as" | "children"&gt; &amp; { children: ReactNode; }'</code>&#13;
<code class="c1">// is not assignable to type 'IntrinsicAttributes &amp;</code>&#13;
<code class="c1">// LibraryManagedAttributes&lt;T, ClassAttributes&lt;HTMLAnchorElement&gt; &amp;</code>&#13;
<code class="c1">// AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; &amp; ClassAttributes&lt;...&gt; &amp;</code>&#13;
<code class="c1">// ButtonHTMLAttributes&lt;...&gt;&gt;'.</code>&#13;
<code class="c1">// Type 'Omit&lt;CtaProps&lt;T&gt;, "as" | "children"&gt; &amp; { children: ReactNode; }' is not</code>&#13;
<code class="c1">//  assignable to type</code>&#13;
<code class="c1">//  'LibraryManagedAttributes&lt;T, ClassAttributes&lt;HTMLAnchorElement&gt;</code>&#13;
<code class="c1">//  &amp; AnchorHTMLAttributes&lt;HTMLAnchorElement&gt; &amp; ClassAttributes&lt;...&gt;</code>&#13;
<code class="c1">//  &amp; ButtonHTMLAttributes&lt;...&gt;&gt;'.(2322)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So where does this message come from? For TypeScript to work correctly with JSX, we need to resort to type definitions in a global namespace called <code>JSX</code>. If this namespace is in scope, TypeScript knows which elements that aren’t components can be instantiated and which attributes they can accept. These are the <code>JS⁠X.I⁠ntr⁠ins⁠ic​Ele⁠men⁠ts</code> we use in this example and in <a data-type="xref" href="#ch10_proxy_components">Recipe 10.1</a>.</p>&#13;
&#13;
<p>One type that also needs to be defined is <code>LibraryManagedAttributes</code>. This type is used to provide attributes that are defined either by the framework itself (like <code>key</code>) or via means like <code>defaultProps</code>:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">export</code> <code class="kr">interface</code> <code class="nx">Props</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Greet</code><code class="p">({</code> <code class="nx">name</code> <code class="p">}</code><code class="o">:</code> <code class="nx">Props</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">div</code><code class="o">&gt;</code><code class="nx">Hello</code> <code class="p">{</code><code class="nx">name</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()}</code><code class="o">!&lt;/</code><code class="nt">div</code><code class="o">&gt;;</code>&#13;
<code class="p">}</code>&#13;
<code class="c1">// Goes into LibraryManagedAttributes</code>&#13;
<code class="nx">Greet</code><code class="p">.</code><code class="nx">defaultProps</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"world"</code> <code class="p">};</code>&#13;
&#13;
<code class="c1">// Type-checks! No type assertions needed!</code>&#13;
<code class="kd">let</code> <code class="nx">el</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nt">Greet</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="mi">1</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>React’s typings solve <code>LibraryManagedAttributes</code> by using a conditional type. And as we see in <a data-type="xref" href="ch12.html#ch12_overloads_vs_conditionals">Recipe 12.7</a>, conditional types won’t be expanded with all possible variants of a union type when being evaluated. This means that TypeScript won’t be able to check that your typings fit the components because it won’t be able to evaluate <code>Lib⁠rary​Man⁠age⁠dAt⁠trib⁠utes</code>.</p>&#13;
&#13;
<p><a data-primary="any type" data-secondary="typing polymorphic components with" data-type="indexterm" id="id911"/>One workaround for this is to assert props to <code>any</code>:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Cta</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">CtaElements</code><code class="o">&gt;</code><code class="p">({</code>&#13;
  <code class="kr">as</code><code class="o">:</code> <code class="nx">Component</code><code class="p">,</code>&#13;
  <code class="p">...</code><code class="nx">props</code>&#13;
<code class="p">}</code><code class="o">:</code> <code class="nx">CtaProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nt">Component</code> <code class="p">{...(</code><code class="nx">props</code> <code class="kr">as</code> <code class="kr">any</code><code class="p">)}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That works, but it is a sign of an <em>unsafe</em> operation that shouldn’t be unsafe. Another way is to not use JSX in this case but use the JSX factory <code>React.createElement</code>.</p>&#13;
&#13;
<p>Every JSX call is syntactic sugar to a JSX factory call:</p>&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="o">&lt;</code><code class="nt">h1</code> <code class="nx">className</code><code class="o">=</code><code class="s2">"headline"</code><code class="o">&gt;</code><code class="nx">Hello</code> <code class="nx">World</code><code class="o">&lt;/</code><code class="nt">h1</code><code class="o">&gt;</code>&#13;
&#13;
<code class="c1">// will be transformed to</code>&#13;
<code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"h1"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">className</code><code class="o">:</code> <code class="s2">"headline"</code> <code class="p">},</code> <code class="p">[</code><code class="s2">"Hello World"</code><code class="p">]);</code></pre>&#13;
&#13;
<p>If you use nested components, the third parameter of <code>createElement</code> will contain nested factory function calls. <code>React.createElement</code> is much easier to call than JSX, and TypeScript won’t resort to the global <code>JSX</code> namespace when creating new elements. Sounds like a perfect workaround for our needs.</p>&#13;
&#13;
<p><code>React.createElement</code> needs three arguments: the component, the props, and the children. Right now, we’ve smuggled all child components with <code>props</code>, but for <code>React.createElement</code> we need to be explicit. This also means that we need to explicitly define <code>children</code>.</p>&#13;
&#13;
<p>For that, we create a <code>WithChildren&lt;T&gt;</code> helper type. It takes an existing type and adds optional children in the form of <code>React.ReactNode</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">WithChildren</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="p">{}</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">children</code><code class="o">?:</code> <code class="nx">React</code><code class="p">.</code><code class="nx">ReactNode</code> <code class="p">};</code></pre>&#13;
&#13;
<p><code>WithChildren</code> is highly flexible. We can wrap the type of our props with it:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CtaProps</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">CtaElements</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">WithChildren</code><code class="o">&lt;</code><code class="p">{</code>&#13;
  <code class="kr">as</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="nx">T</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Or we can create a union:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CtaProps</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">CtaElements</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="kr">as</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">&amp;</code> <code class="nx">JSX</code><code class="p">.</code><code class="nx">IntrinsicElements</code><code class="p">[</code><code class="nx">T</code><code class="p">]</code> <code class="o">&amp;</code> <code class="nx">WithChildren</code><code class="p">;</code></pre>&#13;
&#13;
<p>Since <code>T</code> is set to <code>{}</code> by default, the type becomes universally usable. This makes it a lot easier for you to attach <code>children</code> whenever you need them. As a next step, we destructure <code>children</code> out of <code>props</code> and pass all arguments into <code>React.createElement</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Cta</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">CtaElements</code><code class="o">&gt;</code><code class="p">({</code>&#13;
  <code class="kr">as</code><code class="o">:</code> <code class="nx">Component</code><code class="p">,</code>&#13;
  <code class="nx">children</code><code class="p">,</code>&#13;
  <code class="p">...</code><code class="nx">props</code>&#13;
<code class="p">}</code><code class="o">:</code> <code class="nx">CtaProps</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="nx">Component</code><code class="p">,</code> <code class="nx">props</code><code class="p">,</code> <code class="nx">children</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And with that, your polymorphic component accepts the right parameters without any errors.<a data-startref="ix_10-07-asciidoc3" data-type="indexterm" id="id912"/><a data-startref="ix_10-07-asciidoc2" data-type="indexterm" id="id913"/><a data-startref="ix_10-07-asciidoc1" data-type="indexterm" id="id914"/><a data-startref="ix_10-07-asciidoc0" data-type="indexterm" id="id915"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>