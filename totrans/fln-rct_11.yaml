- en: Chapter 10\. React Alternatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered the emerging topic of React Server Components
    (RSCs) in depth. We explored how they work, when to use them, and why they require
    powerful tools such as next-generation bundlers, routers, and more. We further
    differentiated between server components and server rendering, and even implemented
    a bare-bones RSCs renderer from scratch in order to understand the underlying
    mechanism for ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: As we transition into exploring alternatives to React, this understanding of
    the role and function of frameworks and server components will provide valuable
    context. Each library we’ll discuss in this chapter also ships with its associated
    frameworks, and many of the principles and trade-offs we’ve covered in React will
    apply to these ecosystems as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we pivot our attention from React and its ecosystem, let’s delve into some
    popular alternatives in the frontend development ecosystem: Vue.js, Angular, Svelte,
    Solid, and Qwik. Each library and framework introduces its own reactivity model
    and ways of thinking about UI development. Understanding these different models
    can broaden our perspective and give us more tools to solve problems in our projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vue.js is a popular JavaScript framework for building user interfaces. Developed
    by Evan You, an ex-Google engineer who worked on AngularJS projects, Vue.js seeks
    to extract the good parts of Angular, but in a lighter, more maintainable, and
    less opinionated package.
  prefs: []
  type: TYPE_NORMAL
- en: One of Vue’s most distinctive features is the unobtrusive reactivity system.
    Component state consists of reactive JavaScript objects. When you modify them,
    the view updates. It makes state management simple and intuitive, but it’s also
    important to understand how it works to avoid some common gotchas.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Vue’s reactivity model, it intercepts the reading and writing of object
    properties. Vue 2 used getter/setters exclusively due to browser support limitations,
    but in Vue 3, proxies are used for reactive objects and getter/setters are used
    for refs. From the Vue docs, here’s some pseudocode that illustrates how they
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is somewhat oversimplified, but here we demonstrate a simplistic reactive
    system utilizing proxies. The `reactive` function takes an object and returns
    a proxy of that object, which intercepts `get` and `set` operations. On a `get`
    operation, it calls the `track` function and returns the requested property. On
    a `set` operation, it updates the value and calls the `trigger` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `ref` function, on the other hand, encapsulates a value within an object
    and provides reactive `get` and `set` operations for that value, similar to the
    proxy but with a different structure, ensuring that the `track` and `trigger`
    functions are called appropriately during access or modification.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very simple example of a reactive system, but it demonstrates the
    basic principles of Vue’s reactivity model. This reactivity model can even be
    used to update the DOM. We can implement simple “reactive rendering” like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In fact, this is pretty close to how a Vue component keeps the state and the
    DOM in sync—each component instance creates a reactive effect to render and update
    the DOM. Of course, Vue components use much more efficient ways to update the
    DOM than `innerHTML`, but this should be enough to give you a basic idea of how
    it works.
  prefs: []
  type: TYPE_NORMAL
- en: The `ref()`, `computed()`, and `watchEffect()` APIs are all part of Vue’s Composition
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite a few other frameworks have introduced reactivity primitives similar to
    `refs` from Vue’s Composition API, under the term “signals” that we’ll discuss
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fundamentally, signals are the same kind of reactivity primitive as Vue `refs`.
    It’s a value container that provides dependency tracking on access, and side-effect
    triggering on mutation. This reactivity-primitive-based paradigm isn’t a particularly
    new concept in the frontend world: it dates back to implementations like Knockout
    observables and Meteor Tracker from more than a decade ago. Vue Options API and
    the React state management library MobX are also based on the same principles
    but hide the primitives behind object properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Although not a necessary trait for something to qualify as signals, today the
    concept is often discussed alongside the rendering model where updates are performed
    through fine-grained subscriptions. Due to the use of virtual DOM, Vue currently
    relies on compilers to achieve similar optimizations. However, Vue is also exploring
    a new Solid-inspired compilation strategy (Vapor Mode) that does not rely on virtual
    DOM and takes more advantage of Vue’s built-in reactivity system.
  prefs: []
  type: TYPE_NORMAL
- en: Simplicity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vue’s biggest strength is its simplicity. It’s incredibly easy to get started
    with Vue: you can simply include the Vue library in your HTML file in a `<script>`
    tag and start writing Vue components. Vue also provides a CLI tool for scaffolding
    new projects, which can be a great way to get started with a more complex application.'
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve only scratched the surface of Vue.js here, it’s clear that Vue’s
    combination of a powerful reactivity system, a template-based syntax, and a well-structured
    component model make it a compelling option for many developers.
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular, developed and maintained by Google, is another well-known player in
    the world of JavaScript frameworks. Angular is a complete, opinionated framework,
    providing its own solutions for a wide range of frontend concerns, from rendering
    and state management to routing and form handling.
  prefs: []
  type: TYPE_NORMAL
- en: Angular introduces a different reactivity model than React. Instead of a virtual
    DOM diffing and reconciliation process, Angular uses a system known as change
    detection.
  prefs: []
  type: TYPE_NORMAL
- en: In Angular, every component gets a change detector responsible for checking
    the component’s view for changes using a library called Zone.js. Before we proceed,
    let’s talk about this in a little bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Change Detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Change detection is the process through which Angular checks to see whether
    your application state has changed, and if any DOM needs to be updated. At a high
    level, Angular walks your components from top to bottom, looking for changes.
    Angular runs its change detection mechanism periodically so that changes to the
    data model are reflected in an application’s view. Change detection can be triggered
    either manually or through an asynchronous event.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection is highly optimized and performant, but it can still cause
    slowdowns if the application runs it too frequently. This change detection system
    is a powerful and flexible tool, and Angular provides several strategies out of
    the box for fine-tuning its behavior to optimize performance for different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Angular also uses a template syntax, like Vue, but it provides even more powerful
    directives and constructs for manipulating the DOM, such as `*ngIf` for conditionally
    rendering elements and `*ngFor` for rendering lists. This is different from React,
    which uses JSX with in-place JavaScript expressions to render dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: Signals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular is undergoing some fundamental changes by foregoing dirty-checking
    and introducing its own implementation of a reactivity primitive. The Angular
    Signal API looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Compared to Vue refs, Angular’s getter-based API style provides some interesting
    trade-offs when used in Vue components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`()` is slightly less verbose than `.value`, but updating the value is more
    verbose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is no ref-unwrapping: accessing values always requires `()`. This makes
    value access consistent everywhere. This also means you can pass raw signals down
    as component props.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angular is something of a Swiss Army knife, providing a wide range of tools
    for building complex applications. Its opinionated nature can be both a strength,
    in terms of the consistency and structure it brings to a codebase, and a limitation,
    in terms of flexibility and the learning curve for developers new to the framework.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Svelte is a radical new approach to building user interfaces. Unlike traditional
    frameworks, Svelte is a compiler that transforms your declarative components into
    efficient imperative code that surgically updates the DOM. As a result, you’re
    able to write high-performance, reactive web applications with less code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Svelte’s reactivity model is incredibly simple, yet powerful. Reactive statements
    in Svelte are written with a simple syntax that’s reminiscent of spreadsheet formulas.
    Here’s a basic Svelte component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `{count}` syntax in the markup will automatically update
    whenever the `count` variable changes. This is similar to React’s JSX, but with
    one key difference: in Svelte, this reactivity is automatic. You don’t need to
    call a setter function or use any special API to update the DOM; you just assign
    to the variable, and Svelte takes care of the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Svelte also offers a reactive statement syntax that allows you to compute values
    based on your reactive data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `doubleCount` will automatically be updated whenever `count`
    changes. This is reminiscent of computed properties in Vue, but with an arguably
    simpler syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The compiler approach taken by Svelte has several advantages. It typically results
    in faster runtime performance because there’s no virtual DOM diffing and patching
    step. Instead, Svelte generates code that updates the DOM directly.
  prefs: []
  type: TYPE_NORMAL
- en: However, this approach also comes with trade-offs. The compiler-centric nature
    of Svelte means that some dynamic capabilities offered by virtual DOM-based frameworks,
    like dynamic component types, can be more cumbersome or verbose to express. Also,
    because the Svelte ecosystem is smaller and younger than those of React, Vue,
    and Angular, there may be fewer resources, libraries, and community solutions
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Runes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Runes are symbols that influence the Svelte compiler. Whereas Svelte today uses
    `let`, `=`, the `export` keyword, and the `$:` label to mean specific things,
    runes use *function syntax* to achieve the same things and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to declare a piece of reactive state, we can use the `$state`
    rune:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As applications grow in complexity, figuring out which values are reactive and
    which aren’t can get tricky. And the current heuristic only works for `let` declarations
    at the top level of a component, which can cause confusion. Having code behave
    one way inside *.svelte* files and another way inside *.js* can make it hard to
    refactor code, for example, if you need to turn something into a store so that
    you can use it in multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: 'With runes, reactivity extends beyond the boundaries of your *.svelte* files.
    Suppose we wanted to encapsulate our counter logic in a way that could be reused
    between components. Today, you would use a custom store in a *.js* or *.ts* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this implements the *store contract*—the returned value has a `subscribe`
    method—we can reference the store value by prefixing the store name with `$`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This works, but it’s pretty weird! The store API can get rather unwieldy when
    you start doing more complex things. With runes, things get much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that we’re using a `get` property in the returned object, so that `counter.count`
    always refers to the current value rather than the value at the time the function
    was called.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime reactivity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Today, Svelte uses *compile-time reactivity*. This means that if you have some
    code that uses the `$:` label to rerun automatically when dependencies change,
    those dependencies are determined when Svelte compiles your component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This works well…until it doesn’t. Suppose we refactored the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the `$: area = ...` declaration can only see `width`, it won’t be recalculated
    when `height` changes. As a result, code is hard to refactor, and understanding
    the intricacies of when Svelte chooses to update which values can become rather
    tricky beyond a certain level of complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Svelte 5 introduces the `$derived` and `$effect` runes, which instead determine
    the dependencies of their expressions when they are evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As with `$state`, `$derived` and `$effect` can also be used in your *.js* and
    *.ts* files.
  prefs: []
  type: TYPE_NORMAL
- en: Signal boost
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like every other framework, Svelte has come to the realization that Knockout
    was right all along.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte 5’s reactivity is powered by *signals*, which are essentially what Knockout
    was doing in 2010\. More recently, signals have been popularized by Solid (more
    on this later) and adopted by a multitude of other frameworks. In Svelte 5, signals
    are an under-the-hood implementation detail rather than something you interact
    with directly.
  prefs: []
  type: TYPE_NORMAL
- en: Solid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solid is a declarative JavaScript library for building user interfaces. It’s
    similar to React in that it provides a component model base, but Solid is based
    on reactive primitives. Instead of using a virtual DOM, Solid uses a fine-grained
    reactivity system to automatically track dependencies and update the DOM directly,
    which can result in more efficient updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a simple Solid component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `createSignal` creates a reactive primitive, similar to `useState`
    in React. The key difference is that `count` is a function that returns the current
    value and implicitly registers the dependency for the reactive context. When `setCount`
    is called, it triggers an update for any part of the UI that depends on `count`
    without reinvoking the function components.
  prefs: []
  type: TYPE_NORMAL
- en: To contrast this with React, in React the component, `Component` in this case,
    would be reinvoked, including all of the logic inside its block. Thus, the `count`
    value itself is not reactive. In Solid, the `Component` function is never reinvoked,
    but the `count` value itself is reactive and changes whenever `setCount` is called.
    This is called fine-grained reactivity, and it is directly opposite to React’s
    coarse-grained reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Solid’s fine-grained reactivity system means that it can minimize unnecessary
    updates and avoid the need for a diffing step, resulting in very high performance.
    However, because it’s a relatively new and less widely used library, it may not
    have as many resources and community solutions available as some of the more established
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Solid’s `createSignal()` API design emphasizes read/write segregation. Signals
    are exposed as a read-only getter and a separate setter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `count` signal can be passed down without the setter. This ensures
    that the state can never be mutated unless the setter is also explicitly exposed.
  prefs: []
  type: TYPE_NORMAL
- en: Solid reinvigorated the discussion around signals, and the concept has been
    adopted by many other frameworks and libraries as we’ve seen previously. Everything
    we’ve previously mentioned about signals comes from the work of Ryan Carniato,
    the author of Solid, who somehow single-handedly managed to change the entire
    frontend ecosystem by bringing back a concept from 2010.
  prefs: []
  type: TYPE_NORMAL
- en: Qwik
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Qwik is a unique framework designed to optimize the loading of web pages and
    prioritize user interaction and responsiveness. Unlike traditional frameworks,
    it views web pages as a collection of components that can be independently loaded
    over the network and interacted with on demand. This approach significantly reduces
    the initial load time of the page, enhancing the overall user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications and sites built with Qwik ship with exceedingly small and constant
    initial amounts of JavaScript (~1 kB). The amount of initial JavaScript loaded
    by a Qwik site is constant, as it is the Qwik loader. This is why Qwik is known
    in some circles as “the O(1) framework,” meaning it has a constant load time regardless
    of the size of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, Qwik loads a bare minimum amount of JavaScript, but then loads components
    and other behaviors as they are needed. This approach allows Qwik to prioritize
    the loading of the most important components first, resulting in a faster initial
    load time and a more responsive user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'An essential feature of Qwik is resumability. We covered resumability crudely
    in our chapter on server-side React ([Chapter 6](ch06.html#ch06)), but to recap:
    resumability is a process through which a server rendered snapshot of the initial
    state of the page is sent to the client. As the user opens the page, they interact
    with this static snapshot until they need more interactivity. Then, various behaviors
    load on demand as users continue. This mechanism provides an instant interaction
    opportunity for the user, a characteristic that is not prevalent in many other
    frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: Resumability is far superior to hydration (also covered in [Chapter 6](ch06.html#ch06))
    because it does not require rendering components twice. It also avoids the “uncanny
    valley” of user interfaces where a website is not interactive for a period of
    time after the initial server rendered markup has made it to the browser and before
    the JavaScript has loaded and hydrated the page. Qwik is instant on.
  prefs: []
  type: TYPE_NORMAL
- en: When comparing Qwik to other popular frameworks such as React, Vue, Svelte,
    or Solid, several differences emerge. While React and Vue also adopt a component-based
    approach, if we’re not careful and intentional about code splitting, we can send
    the entire JavaScript bundle for the application to the client up front, sometimes
    getting into the megabyte zone. This process can lead to longer initial load times,
    especially for large applications. On the other hand, Qwik only loads the components
    and event handlers as they are needed, resulting in faster initial load times
    and a more responsive user experience. Qwik is also clever about prefetching,
    and does so for lazy-loaded elements such that everything is prefetched on initial
    load but only parsed and executed on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Qwik, like Svelte and Solid, focuses on performance, but achieves this in different
    ways. Svelte compiles the components to highly efficient imperative code that
    manipulates the DOM directly, while Solid uses a reactive fine-grained reactivity
    model for its components. While also using reactive primitives, Qwik focuses on
    optimizing component loading and making sure the most important ones are available
    as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of developer experience, Qwik offers a simple and intuitive API that
    makes it easy to define and work with components. Qwik components are nearly identical
    to React components in terms of syntax and structure, since they are also expressed
    with JSX (or TSX). This similarity makes it easy for developers to get started
    with Qwik, especially if they’re already familiar with React.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, Qwik has interoperability with React, allowing developers to use React
    components in Qwik applications via a `qwikify` utility. This interoperability
    is a significant advantage for developers who want to use Qwik but also want to
    take advantage of the rich ecosystem of React libraries and tools.
  prefs: []
  type: TYPE_NORMAL
- en: Qwik presents a novel approach to modern web development with its component-based
    and event-driven architecture. Its focus on resumability and prioritized loading
    sets it apart from other frameworks like React, Vue, Svelte, and Solid. While
    each of these tools has its strengths and use cases, Qwik’s unique features make
    it an exciting addition to the landscape of web development frameworks. It could
    be the right choice for developers and teams looking for a performant, user-centric,
    and efficient way to build their web applications.
  prefs: []
  type: TYPE_NORMAL
- en: The only drawback of Qwik is that it is still fairly new and does not have quite
    as mature of an ecosystem as React, Vue, or Angular. However, it is gaining traction
    and has a growing community of developers and contributors. As Qwik continues
    to evolve, it will be interesting to see how it compares to other frameworks and
    how it can be used to build even more powerful applications.
  prefs: []
  type: TYPE_NORMAL
- en: Common Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of these technologies—React, Angular, Qwik, Solid, and Svelte—are solutions
    for creating rich, interactive user interfaces for the web. Though they vary in
    their philosophies, methodologies, and implementation details, they share several
    commonalities that reflect their shared purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Component-Based Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary commonalities among these frameworks and libraries is the
    adoption of a component-based architecture. In a component-based architecture,
    UIs are broken down into individual pieces, or components, each of which is responsible
    for a specific part of the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Components encapsulate their own state and logic, and they can be composed together
    to build complex UIs. This modularity promotes code reuse, separation of concerns,
    and improved maintainability. In each of these frameworks, components can be functional,
    and they can often be composed, extended, or decorated to create more complex
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative Syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React, Angular, Qwik, Solid, and Svelte all employ a declarative syntax for
    defining UIs. In a declarative approach, developers specify what the UI should
    look like for a given state, and the framework takes care of updating the UI to
    match that state. This abstracts away the imperative DOM manipulations that can
    make UI development tedious and error prone.
  prefs: []
  type: TYPE_NORMAL
- en: All these technologies provide their own flavor of a templating language for
    writing declarative UIs. React, Qwik, and Solid use JSX; Angular uses its own
    HTML-based template syntax; and Svelte has its HTML-inspired language.
  prefs: []
  type: TYPE_NORMAL
- en: Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All these libraries and frameworks provide a mechanism to respond to updates
    in the application state and alter the UI accordingly. React and Vue use a virtual
    DOM diffing algorithm to make these updates. Svelte, on the other hand, compiles
    components to imperative code that updates the DOM directly. Angular uses a change
    detection mechanism based on Zones and observables.
  prefs: []
  type: TYPE_NORMAL
- en: Soon, it’ll pretty much be React using vDOM and everyone else using some variety
    of signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the different methods, the goal is the same: to efficiently update
    the UI in response to state changes, abstracting away the complex DOM manipulation
    and allowing developers to focus on the application logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: React, Angular, Solid, and Svelte provide lifecycle methods or hooks, which
    are functions that get called at different stages in a component’s life, such
    as when it’s first created, when it’s updated, and when it’s about to be removed
    from the DOM. Developers can use these methods to run side effects, clean up resources,
    or make updates based on changes in props.
  prefs: []
  type: TYPE_NORMAL
- en: Ecosystem and Tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each of these frameworks and libraries is supported by a rich ecosystem of tools,
    libraries, and resources. They all have support for modern JavaScript features
    and tooling, including ES6 syntax, modules, and build tools like Webpack and Babel.
    They also have excellent TypeScript support, allowing developers to write type-safe
    code and take advantage of TypeScript’s powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: Most of these technologies also come with or have available sophisticated developer
    tools that can aid in debugging and application profiling. React’s and Angular’s
    developer tools extensions for popular browsers are excellent examples of such
    tooling.
  prefs: []
  type: TYPE_NORMAL
- en: 'While React, Angular, Qwik, Solid, and Svelte have their unique strengths and
    philosophies, they share these common goals: providing a component-based architecture,
    enabling the creation of declarative UIs, offering reactivity to state changes,
    simplifying event handling, providing lifecycle methods or similar concepts, and
    supporting a rich ecosystem and modern JavaScript tooling. This shared set of
    features and concepts is a testament to the evolution of web development toward
    more modular, declarative, and reactive paradigms.'
  prefs: []
  type: TYPE_NORMAL
- en: React Is Not Reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term “reactive” has been used to describe many things in the world of programming,
    but it’s often used to describe systems that automatically update in response
    to changes in data. The paradigm of reactive programming is fundamentally about
    building systems that respond to changes, and automatically propagating those
    changes through the system. This is why frameworks like Vue.js and Svelte are
    often described as being reactive. However, React does not follow the traditional
    model of reactivity, and its approach is distinctly different.
  prefs: []
  type: TYPE_NORMAL
- en: React was introduced as a library for building user interfaces in a declarative
    way—*declarative* meaning that those of us writing React merely describe *what*
    we want, and React deals with the *how*. It allows developers to describe the
    UI based on the current application state, and React takes care of updating the
    UI whenever the state changes. This description might sound like React is reactive,
    but when you delve deeper into the implementation details, it becomes apparent
    that React’s model is quite distinct from the traditional reactive programming
    model.
  prefs: []
  type: TYPE_NORMAL
- en: To understand why React isn’t reactive in the traditional sense, let’s first
    look at what traditional reactivity looks like in a system. In a traditional reactive
    system, dependencies between computations are automatically tracked as your code
    runs. When a reactive dependency changes, all computations that depend on it are
    automatically rerun to reflect this change. This is typically done using techniques
    such as data-binding, observables, or signals and slots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Signals for example, are a reactive primitive that can be used to create reactive
    values: on read, the reader of the signal subscribes to it, and on write, all
    subscribers are notified. This is reactivity 101.'
  prefs: []
  type: TYPE_NORMAL
- en: React uses a different approach to manage state and its updates. Instead of
    automatically tracking dependencies and propagating changes, React introduces
    a more explicit mechanism for updating the state—the `useState` hook. When state
    changes, instead of immediately rendering updates, React schedules a rerender,
    and during that rerender, the entire component function is run again with the
    new state.
  prefs: []
  type: TYPE_NORMAL
- en: 'What that means is in the case of this counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When `setCount` is called, the `Counter` function is reinvoked, including the
    `useState` hook. This is different from the traditional reactive model, where
    instead of reinvoking the entire function, only the reactive portions of the UI
    would be updated, in this case, the `{count}` inside of `<p>`. This is called
    coarse-grained reactivity, and it is directly opposed to the fine-grained reactivity
    model of signals.
  prefs: []
  type: TYPE_NORMAL
- en: 'React is often identified with the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the view is equal to a function of its state. This equation itself
    describes React’s nonreactive nature: the view is a function of the state, but
    it’s not automatically updated when the state changes. Instead, the view is updated
    when the function is re-executed with the new state.'
  prefs: []
  type: TYPE_NORMAL
- en: This is where React’s virtual DOM diffing and reconciliation process comes in.
    When a component’s state or props change, React rerenders the component, creating
    a new virtual DOM subtree. It then diffs this new subtree with the old one, computes
    the minimal set of actual DOM mutations needed, and applies those mutations to
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'This model of explicitly setting state and rerendering, as opposed to automatic
    reactive propagation of changes, allows for more predictability: React, if anthropomorphized,
    would say, “Tell me your state expectations and I’ll take care of it.” It enables
    features like batching of state updates and makes it easier to reason about the
    state of the application at any point in time because the state update and the
    resulting UI update are linked in a single, atomic operation.'
  prefs: []
  type: TYPE_NORMAL
- en: However, this also means that React components are less reactive in the traditional
    sense. They don’t automatically react to changes in data. Instead, they explicitly
    describe what the UI should look like for a given state, and it’s up to React
    to apply any necessary updates when the state changes through re-executing functions
    instead of the appropriate values just updating in place.
  prefs: []
  type: TYPE_NORMAL
- en: While React’s approach is not reactive in the sense of automatically tracking
    and propagating changes, it still provides a highly effective mechanism for building
    dynamic, interactive user interfaces. The use of state and props to control rendering
    provides a clear and predictable model for understanding how changes propagate
    through the application, and the virtual DOM system efficiently manages updates
    to the actual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, whether or not React’s approach is considered reactive comes down
    to semantics. If you define reactivity as the automatic propagation of changes
    through a system, then no, React is not reactive. But if you define reactivity
    as the ability of a system to respond to changes in state in a predictable and
    controlled manner, then yes, React can certainly be considered reactive.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at React and other frameworks/libraries, it’s clear that there isn’t
    a one-size-fits-all approach to managing state and reactivity in UI development.
    Each tool has its strengths and trade-offs and is suited to different use cases.
    Understanding these differences is crucial when choosing the right tool for the
    job and can also help in writing more effective and efficient code, regardless
    of the framework or library you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: React’s model of handling state and updates provides an excellent balance between
    control and convenience. The explicit state update mechanism allows developers
    to reason about their application state more easily, while the reconciliation
    and diffing algorithm efficiently applies updates to the DOM. Despite not being
    traditionally “reactive,” React’s approach has proven to be incredibly effective
    for building complex user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no denying that reactive programming models offer some compelling benefits,
    particularly when it comes to automatically managing dependencies and updates.
    But as we’ve seen, React’s approach offers its own set of advantages, providing
    a high degree of control and predictability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For completionists, we’ll now look at how the same counter would look in Solid,
    a framework that uses a reactive model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `count` is a reactive property of the component’s data. When
    we first read `count` by calling `count()` in place inside our `<p>` elements,
    we implicitly subscribe that portion of our JSX to the reactive value of `count`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when we call `increment()` later, which then calls `setCount`, `setCount`
    updates the value and notifies all subscribers that the value changed, prompting
    them to update. This is a bit analogous to the pub/sub pattern, where a subscriber
    subscribes to a publisher, and the publisher notifies all subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is fine-grained reactivity: that is, the function component itself,
    `Counter`, is never called more than once, but the fine-grained, small reactive
    values are.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example 2: Dependent Values'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a component that displays a list of items and the count of those items.
    In a reactive system like Svelte, the count would automatically update whenever
    the list changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `$: count = items.length;` declares a reactive statement. Whenever `items`
    changes, the `count` is automatically recalculated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, this looks a bit different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this React component, `count` is not a reactive value that automatically
    updates when `items` changes. Instead, it’s a value derived from the current state
    during the render phase. When `items` changes, we need to call `setItems` to update
    the state and cause a rerender, at which point `count` is recalculated not because
    `count` is reactive, but because the `ItemList` function component is reinvoked.
  prefs: []
  type: TYPE_NORMAL
- en: The Future of React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given the widespread adoption of reactive primitives like signals across the
    entire frontend ecosystem, some would presume that React would eventually adopt
    a similar approach. However, the React team has expressed that they are “not excited”
    about signals and opt for an alternative approach to arrive at similar performance
    benefits that signals provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this a little better, let’s recap some of the things we’ve learned
    about React through an example. Consider this component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this very, very contrived example, we have a component that contains state
    called `Counter` with some children:'
  prefs: []
  type: TYPE_NORMAL
- en: A `<p>` element that displays the current count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `<button>` element that increments the count
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `<ComponentWithExpensiveChildren>` component that renders some expensive children
    with a lot of computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s say we click the button to increment the count. What happens? The
    `Counter` function is called/reinvoked/rerendered along with all its children.
    This is React’s default behavior. This means that the `<ComponentWithExpensiveChildren>`
    component is rerendered even though it doesn’t need to be: its props or state
    hasn’t changed!'
  prefs: []
  type: TYPE_NORMAL
- en: 'This coarse-grained reactivity makes React less performant than it could be.
    However, this is quite an easy fix: we just include `memo` at the right time and
    in the right place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This works, as long as we remember to use `memo` everywhere we need to. Indeed,
    this provides the same fine-grained reactivity as signals. However, it’s not as
    convenient as signals, because we have to remember to use `memo` everywhere we
    need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of us at this point may be thinking that signals could easily solve this
    problem, but the React team at Meta believes that signals, like `memo`, may be
    an implementation detail that everyday developers who use React ought not have
    to think about. They hearken back to the initial value proposition of React: “declaratively
    describe your UI, let React do the rest.” The React team believes that the superior
    way is where developers don’t concern ourselves with signals, `memo`, or any details,
    but that React should be able to figure out the optimal way to render the UI.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To this end, the team is working on a new piece of software to do just that:
    React Forget.'
  prefs: []
  type: TYPE_NORMAL
- en: React Forget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Forget is a toolchain for React similar to a linter that has its `--fix` flag
    enabled: it enforces the rules of React and then automatically transforms React
    code to be optimal through intelligently memoizing values that will not change
    throughout the lifecycle of an application—like `ComponentWithExpensiveChildren`.'
  prefs: []
  type: TYPE_NORMAL
- en: Because of the rules of React, the Forget compiler can predict these values
    and memoize them for us. This is a similar approach to what Svelte does, but instead
    of compiling to imperative code, Forget compiles to more performant React code.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are these rules of React? Let’s recap:'
  prefs: []
  type: TYPE_NORMAL
- en: React components are expected to be pure functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some hooks and custom event handlers are not required to be pure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Forbidden actions within pure functions include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mutating variables/objects not newly created within the function
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading properties that may change
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowed actions include:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reading props or state
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Throwing errors
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutating newly created objects/bindings
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy initialization is an exception allowing mutation for the purpose of initialization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Objects or closures created during render should not be mutated after render
    completes, except mutable objects stored in state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of these rules, the Forget compiler can predict which values will not
    change throughout the lifecycle of an application and memoize them for us. The
    result? Highly optimized, highly performant React code that rivals the performance
    of other libraries that use signals.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Forget is in evaluation at Meta and exceeding expectations
    in use on Instagram and WhatsApp. It is not yet open source, but the React team
    is considering releasing it as open source software in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Forget versus signals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because Forget isn’t yet open source, it’s somewhat challenging to comment on
    its trade-offs with any amount of authority. However, we can posit that if Forget
    indeed memoizes everything that doesn’t change, fine-grained reactivity from signals
    may still be superior to coarse-grained reactivity with React Forget, because
    signals live in a parallel universe outside of the component hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when an update happens, React will still have to walk the entire component
    tree and compare the new and old values of each component’s props to determine
    which components need to be rerendered. This is not the case with signals, where
    only the reactive portions of the UI are updated without needing to walk a tree.
    This preliminary data does suggest that even with Forget, React may still be slower
    than libraries where signals are the default, but it is too early to tell.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter began with a recap of [Chapter 9](ch09.html#ch09), where we covered
    the use of RSCs in detail. We then delved into the vast landscape of JavaScript
    frameworks beyond React, including Angular, Vue, Svelte, Solid, and Qwik, aiming
    to understand the differences and similarities among these libraries and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: We started with a look at Vue.js, and explored how it uses a declarative approach
    for building UIs and promotes a strong separation of concerns through its component-based
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we took a dive into Angular, Svelte, Solid, and Qwik, exploring their
    unique features and philosophies. We looked at how they use reactive primitives
    to automatically update the UI in response to changes in data, and how they differ
    from React in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: After the individual examinations, we drew comparisons among these UI libraries,
    underlining their strengths, weaknesses, and overlaps. We looked at their reactivity
    models, architectural choices, development experience, and performance characteristics.
    Through code examples, we showed the unique qualities of each, helping us to understand
    their differences better.
  prefs: []
  type: TYPE_NORMAL
- en: We also examined the concept of reactivity and how it is implemented differently
    across various libraries. Interestingly, we discussed how React is not reactive
    in the traditional sense, as it follows a coarser approach where a change in state
    leads to a rerender, unlike the fine-grained reactivity model found in libraries
    like Vue or Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at the future of React and how it might evolve in the coming
    years. We discussed the React team’s approach to reactivity and how it differs
    from the traditional reactive programming model. We also looked at the Forget
    compiler, a toolchain for React that automatically optimizes React code by memoizing
    values that don’t change throughout the lifecycle of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finally land the plane.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a list of questions to help you track your understanding of the concepts
    covered in this chapter. If you can answer all of them confidently, great! That’s
    a sign you’re learning from this book. If you cannot, it might be worth rereading
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How does the reactivity model differ among React, Vue, Svelte, Solid, and Angular?
    What are the implications of these differences on the performance and development
    experience of these libraries/frameworks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Discuss the unique approach of Qwik in maximizing performance. How does this
    differ from the approach of other UI libraries/frameworks we’ve discussed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the core strengths and weaknesses of each UI library/framework discussed
    in this chapter? How might these strengths and weaknesses influence the choice
    of library/framework for a particular project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: React is not reactive in the traditional sense. Explain this statement in detail,
    comparing it with the “push-based” reactivity model found in libraries like Vue
    or Svelte.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s React Forget? How does it work? How does it compare to signals?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we draw closer to the conclusion of this comprehensive journey through the
    world of React and its ecosystem, we’re preparing to synthesize all that we’ve
    learned. In the next and final chapter, we’ll be stepping back and reflecting
    on the whole landscape.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be wrapping up this book and providing a holistic view of where we stand
    today and what we can anticipate tomorrow. In doing so, we’ll be drawing on all
    the technical knowledge and insights that we’ve gathered throughout the course
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: From understanding the inner workings of React’s reconciler and diving into
    asynchrony, to tackling server components and understanding various React frameworks,
    to comparing React with its peers—all this was done with a purpose. Now, we’re
    ready to connect the dots, to see the bigger picture, and to chart the path forward.
  prefs: []
  type: TYPE_NORMAL
- en: So, are you ready to take a leap into the future of React and frontend development?
    Stay tuned for the grand finale!
  prefs: []
  type: TYPE_NORMAL
