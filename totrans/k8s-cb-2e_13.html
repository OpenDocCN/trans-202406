<html><head></head><body><section data-pdf-bookmark="Chapter 13. Service Meshes" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_servicemesh">&#13;
<h1><span class="label">Chapter 13. </span>Service Meshes</h1>&#13;
&#13;
&#13;
<p>This chapter focuses on one of the building blocks that make<a data-primary="service meshes" data-type="indexterm" id="ix_srvmsh"/> it easier to develop distributed, microservices-based applications on Kubernetes: the service mesh. <a data-primary="Istio" data-type="indexterm" id="id1201"/><a data-primary="Linkerd" data-type="indexterm" id="id1202"/>Service meshes like Istio and Linkerd can perform duties such as monitoring, service discovery, traffic control, and security, to name a few. By offloading these responsibilities to the mesh, application developers can focus on delivering added value rather than reinventing the wheel by solving transversal infrastructure concerns.</p>&#13;
&#13;
<p>One of the major benefits of service meshes is that they can apply policies to services transparently, without the services (client and server) needing to know they are part of a service mesh.</p>&#13;
&#13;
<p>In this chapter, we’ll run through basic examples using both Istio and Linkerd. For each service mesh, we’ll show how you can quickly get up and running using Minikube and implement service-to-service communication inside the mesh while using simple but illustrative service mesh policies. In both examples, we’ll deploy a service based on NGINX, and our client invoking the service will be a <code>curl</code> pod. Both will be added to the mesh and the interactions between the services will be governed by the mesh.<a data-primary="curl utility" data-type="indexterm" id="id1203"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="13.1 Installing the Istio Service Mesh" data-type="sect1"><div class="sect1" id="install_istio">&#13;
<h1>13.1 Installing the Istio Service Mesh</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id256">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>Your organization is using or plans to use a <a data-primary="Istio" data-secondary="installing Istio service mesh" data-type="indexterm" id="ix_Istsrvmsh"/><a data-primary="service meshes" data-secondary="installing Istio service mesh" data-type="indexterm" id="ix_srvmshIst"/>microservices architecture, and you want to lighten the load on developers by offloading the need to build security, service discovery, telemetry, deployment strategies, and other nonfunctional concerns.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id126">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Install Istio on Minikube.<a data-primary="Minikube" data-secondary="installing Istio on" data-type="indexterm" id="id1204"/> Istio is the most widely adopted service mesh and can offload many responsibilities from microservice developers, while also providing operators with centralized governance over security and operations.</p>&#13;
&#13;
<p>First, you’ll need to start Minikube with enough resources to run Istio. The exact resource requirements depend on your platform, and you may need to adjust the resource allocations. We have gotten it to work with just under 8 GB of memory and four CPUs:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>minikube start --memory=7851 --cpus=4</strong>&#13;
</pre>&#13;
&#13;
<p>You can use a Minikube tunnel as a load balancer for Istio.<a data-primary="Minikube" data-secondary="using minikube tunnel as load balancer for Istio" data-type="indexterm" id="id1205"/> To start it, run this command in a new terminal (it will lock the terminal to show output information):</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>minikube tunnel</strong>&#13;
</pre>&#13;
&#13;
<p>Download and extract the latest version <a data-primary="Linux" data-secondary="downloading and extracting Istio" data-type="indexterm" id="id1206"/><a data-primary="macOS" data-secondary="downloading and extracting Istio" data-type="indexterm" id="id1207"/>of Istio with the following command (Linux and macOS):</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -L https://istio.io/downloadIstio | sh -</strong>&#13;
</pre>&#13;
&#13;
<p>For Windows, you can install with <code>choco</code> or just extract the <em>.exe</em> from the downloadable archive.<a data-primary="Windows" data-secondary="installing Istio on" data-type="indexterm" id="id1208"/> For more info on downloading Istio, head to Istio’s <a href="https://oreil.ly/5uFlk">Getting Started guide</a>.</p>&#13;
&#13;
<p>Change to the Istio directory. You may need to adapt the directory name depending on the version of Istio that you installed:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>cd istio-1.18.0</strong>&#13;
</pre>&#13;
&#13;
<p>The <code>istioctl</code> command-line tool is designed to help debug and diagnose your service mesh, and you’ll use it to check your Istio configuration in other recipes. <a data-primary="istioctl command-line tool" data-type="indexterm" id="id1209"/>It lives in the <em>bin</em> directory, so add it to your path like so:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>export PATH=$PWD/bin:$PATH</strong>&#13;
</pre>&#13;
&#13;
<p>Now you can install Istio. The following YAML file contains an example demo configuration. It intentionally deactivates the use of Istio as an ingress or egress gateway, as we won’t be using Istio for ingress here. Store this config in a file called <em>istio-demo-config.yaml</em>:</p>&#13;
<pre data-type="programlisting">&#13;
apiVersion: install.istio.io/v1alpha1&#13;
kind: IstioOperator&#13;
spec:&#13;
  profile: demo&#13;
  components:&#13;
    ingressGateways:&#13;
    - name: istio-ingressgateway&#13;
      enabled: false&#13;
    egressGateways:&#13;
    - name: istio-egressgateway&#13;
      enabled: false&#13;
</pre>&#13;
&#13;
<p>Now use <code>istioctl</code> to apply this<a data-primary="istioctl command-line tool" data-secondary="applying istio-demo-config.yaml to Minikube" data-type="indexterm" id="id1210"/> configuration to Minikube:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>istioctl install -f istio-demo-config.yaml -y</strong>&#13;
✔ Istio core installed&#13;
✔ Istiod installed&#13;
✔ Installation complete&#13;
</pre>&#13;
&#13;
<p>Finally, make sure Istio is configured to automatically inject Envoy sidecar proxies to services that you deploy. <a data-primary="sidecar proxies" data-secondary="Envoy, Istio configured to automatically inject into services" data-type="indexterm" id="id1211"/><a data-primary="Envoy sidecar proxies" data-secondary="Istio configured to automatically inject to services" data-type="indexterm" id="id1212"/>You can enable this for the default namespace with the following command:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl label namespace default istio-injection=enabled</strong>&#13;
namespace/default labeled&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id257">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>This guide makes use of default (which sometimes implies latest) versions of underlying projects like Kubernetes and Istio.<a data-primary="versions" data-secondary="Istio and Kubernetes, customizing to match production environment" data-type="indexterm" id="id1213"/></p>&#13;
&#13;
<p>You can customize these versions to match the versions of your current production environment, for instance. To set the version of Istio you want to use, use the <code>ISTIO_VERSION</code> and <code>TARGET_ARCH</code> parameters when downloading Istio. For example:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.18.0 \&#13;
    TARGET_ARCH=x86_64 sh -</strong>&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1214">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The official Istio <a href="https://oreil.ly/AKCYs">Getting Started guide</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="13.2 Deploying a Microservice with an Istio Sidecar" data-type="sect1"><div class="sect1" id="istio_deploy_sidecar">&#13;
<h1>13.2 Deploying a Microservice with an Istio Sidecar</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id258">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to deploy a new service into the service mesh, implying that a sidecar should be automatically injected into the service’s pod.<a data-primary="service meshes" data-secondary="installing Istio service mesh" data-startref="ix_srvmshIst" data-type="indexterm" id="id1215"/><a data-primary="Istio" data-secondary="installing Istio service mesh" data-startref="ix_Istsrvmsh" data-type="indexterm" id="id1216"/><a data-primary="deployments" data-secondary="deploying microservice with Istio sidecar" data-type="indexterm" id="ix_dplymcrser"/><a data-primary="microservices" data-secondary="deploying with Istio sidecar" data-type="indexterm" id="ix_mcrsrvdplIstio"/><a data-primary="Istio" data-secondary="deploying microservice with Istio sidecar" data-type="indexterm" id="ix_Istmcrsrvsdcar"/><a data-primary="service meshes" data-secondary="deploying microservice with Istio sidecar" data-type="indexterm" id="ix_srvmshdplymcrsrvIst"/><a data-primary="sidecar proxies" data-secondary="Istio sidecar, deploying microservice with" data-type="indexterm" id="ix_sidecrIst"/> The sidecar will intercept all of the service’s incoming and outgoing traffic and allow the implementation of routing, security, and monitoring policies (among others) without modifying the implementation of the service itself.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id259">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>We’ll use NGINX as a simple service to work with. Start by creating a deployment &#13;
<span class="keep-together">for NGINX:</span></p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create deployment nginx --image nginx:1.25.2</strong>&#13;
deployment.apps/nginx created&#13;
</pre>&#13;
&#13;
<p>Then expose <a data-primary="kubectl" data-secondary="exposing nginx deployment as Kubernetes service" data-type="indexterm" id="id1217"/>this as a Kubernetes service:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl expose deploy/nginx --port 80</strong>&#13;
service/nginx exposed&#13;
</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Istio does not create new DNS entries on Kubernetes but instead relies on existing services registered by Kubernetes or any other service registry you might be using. Later in the chapter, you’ll deploy a <code>curl</code> pod that invokes the <code>nginx</code> service and set the <code>curl</code> host to <code>nginx</code> for DNS resolution, but then Istio will work its magic by intercepting the request and allowing you to define additional traffic control policies.</p>&#13;
</div>&#13;
&#13;
<p>Now list the pods in the default namespace. You should have two containers in the service’s pod:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get po</strong>&#13;
NAME                          READY   STATUS    RESTARTS   AGE&#13;
nginx-77b4fdf86c-kzqvt        2/2     Running   0          27s&#13;
</pre>&#13;
&#13;
<p>If you investigate the details of this pod, you’ll find that the Istio sidecar container (based on the Envoy proxy) was injected into the pod:<a data-primary="pods" data-secondary="Istio sidecar container injected into" data-type="indexterm" id="id1218"/><a data-primary="Envoy sidecar proxies" data-secondary="Istio sidecar based on" data-type="indexterm" id="id1219"/></p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get pods -l app=nginx -o yaml</strong>&#13;
apiVersion: v1&#13;
items:&#13;
- apiVersion: v1&#13;
  kind: Pod&#13;
  metadata:&#13;
    labels:&#13;
      app: nginx&#13;
      ...&#13;
  spec:&#13;
    containers:&#13;
    - image: nginx:1.25.2&#13;
      imagePullPolicy: IfNotPresent&#13;
      name: nginx&#13;
      resources: {}&#13;
&#13;
    ...&#13;
kind: List&#13;
metadata:&#13;
  resourceVersion: ""&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id260">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>This recipe assumes you have enabled automatic sidecar injection in the namespace using the namespace labeling technique, as shown in <a data-type="xref" href="#install_istio">Recipe 13.1</a>. <a data-primary="namespaces" data-secondary="Istio sidecar injection in" data-type="indexterm" id="id1220"/>However, you might not necessarily want to inject sidecars into every single pod in the namespace. In that case, you can manually choose which pods should include the sidecar and thereby be added to the mesh. You can learn more about manual sidecar injection in the <a href="https://oreil.ly/VbHz_">official Istio documentation</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1221">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>More information about how to <a href="https://oreil.ly/E-omC">install and configure the sidecar</a></p>&#13;
</li>&#13;
<li>&#13;
<p>More information about the <a href="https://oreil.ly/TperP">role of sidecars in Istio</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="13.3 Routing Traffic Using an Istio Virtual Service" data-type="sect1"><div class="sect1" id="istio_route_traffic">&#13;
<h1>13.3 Routing Traffic Using an Istio Virtual Service</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id261">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to deploy another service onto the cluster <a data-primary="deployments" data-secondary="deploying microservice with Istio sidecar" data-startref="ix_dplymcrser" data-type="indexterm" id="id1222"/><a data-primary="sidecar proxies" data-secondary="Istio sidecar, deploying microservice with" data-startref="ix_sidecrIst" data-type="indexterm" id="id1223"/><a data-primary="service meshes" data-secondary="deploying microservice with Istio sidecar" data-startref="ix_srvmshdplymcrsrvIst" data-type="indexterm" id="id1224"/><a data-primary="Istio" data-secondary="deploying microservice with Istio sidecar" data-startref="ix_Istmcrsrvsdcar" data-type="indexterm" id="id1225"/><a data-primary="microservices" data-secondary="deploying with Istio sidecar" data-startref="ix_mcrsrvdplIstio" data-type="indexterm" id="id1226"/>that will invoke the <code>nginx</code> service you deployed earlier, but you don’t want to write any routing or security logic into the services themselves.<a data-primary="routing" data-secondary="using Istio virtual service" data-type="indexterm" id="ix_rtIst"/><a data-primary="Istio" data-secondary="routing traffic using Istio virtual service" data-type="indexterm" id="ix_Istrt"/><a data-primary="service meshes" data-secondary="routing traffic using Istio virtual service" data-type="indexterm" id="ix_srvmshrtIst"/> You also want to decouple the client and server as much as possible.<a data-primary="virtual services (Istio)" data-secondary="routing traffic with" data-type="indexterm" id="ix_virsrvIst"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id127">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>We’ll simulate interservice communication within the service mesh by deploying a <code>curl</code> pod that will be added to the mesh and invoke the <code>nginx</code> service.<a data-primary="interservice communication (in service mesh)" data-type="indexterm" id="id1227"/></p>&#13;
&#13;
<p>To decouple the <code>curl</code> pod from the specific pod running <code>nginx</code>, you’ll create an Istio virtual service. The <code>curl</code> pod only needs to know about the virtual service. Istio and its sidecars will intercept and route the traffic from the client to the service.</p>&#13;
&#13;
<p>Create the following virtual service specification in a file called <em>virtualservice.yaml</em>:</p>&#13;
<pre data-type="programlisting">&#13;
apiVersion: networking.istio.io/v1alpha3&#13;
kind: VirtualService&#13;
metadata:&#13;
  name: nginx-vs&#13;
spec:&#13;
  hosts:&#13;
  - nginx&#13;
  http:&#13;
  - route:&#13;
    - destination:&#13;
        host: nginx&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">Create the virtual service:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f virtualservice.yaml</strong>&#13;
</pre>&#13;
&#13;
<p>Then run a <code>curl</code> pod that you’ll use to invoke the service.<a data-primary="curl utility" data-secondary="running curl pod to invoke Istio virtual service" data-type="indexterm" id="id1228"/> Because you’ve deployed the <code>curl</code> pod in the <code>default</code> namespace and you’ve activated automatic sidecar injection in this namespace (<a data-type="xref" href="#install_istio">Recipe 13.1</a>), the <code>curl</code> pod will automatically get a sidecar and be added to the mesh:<a data-primary="sidecar proxies" data-secondary="curl pod in Istio" data-type="indexterm" id="id1229"/></p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl run mycurlpod --image=curlimages/curl -i --tty -- sh</strong>&#13;
</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you accidentally exit the <code>curl</code> pod’s shell, you can <a data-primary="kubectl" data-secondary="exec command" data-type="indexterm" id="id1230"/><a data-primary="exec command (kubectl)" data-type="indexterm" id="id1231"/>always enter the pod again with the <code>kubectl exec</code> command:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl exec -i --tty mycurlpod -- sh</strong>&#13;
</pre>&#13;
</div>&#13;
&#13;
<p>Now you can invoke the <code>nginx</code> virtual service from the <code>curl</code> pod:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -v nginx</strong>&#13;
*   Trying 10.152.183.90:80...&#13;
* Connected to nginx (10.152.183.90) port 80 (#0)&#13;
&gt; GET / HTTP/1.1&#13;
&gt; Host: nginx&#13;
&gt; User-Agent: curl/8.1.2&#13;
&gt; Accept: */*&#13;
&gt;&#13;
&gt; HTTP/1.1 200 OK&#13;
&gt; server: envoy&#13;
...&#13;
</pre>&#13;
&#13;
<p>You’ll see the response from the <code>nginx</code> service, but notice how the HTTP header <code>server: envoy</code> indicates that the response is actually coming from the Istio sidecar running in the <code>nginx</code> pod.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To reference virtual services from <code>curl</code>, we’re using short names that reference the names of the Kubernetes services (<code>nginx</code> in this example).<a data-primary="services" data-secondary="short names referencing Kubernetes services" data-type="indexterm" id="id1232"/> Under the hood, these names are translated into fully qualified domain names, like <code>nginx.default.svc.cluster.local</code>. As you can see, the fully qualified name includes a namespace name (<code>default</code> in this case). <a data-primary="fully qualified domain name (FQDN)" data-type="indexterm" id="id1233"/><a data-primary="namespaces" data-secondary="in Kubernetes service names" data-secondary-sortas="Kubernetes" data-type="indexterm" id="id1234"/>To be safe, for production use cases it is recommend you explicitly use fully qualified names to avoid misconfigurations.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id128">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>This recipe focused on interservice communication within a service mesh (also known as <em>east–west communication</em>), which is the sweet spot for this technology. <a data-primary="ingress" data-secondary="gateway duties performed by Istio and other service meshes" data-type="indexterm" id="id1235"/>However, Istio and other services meshes are also able to perform gateway duties (also known as <em>ingress</em> and <em>north–south communication</em>), such as interactions between clients running outside the mesh (or the Kubernetes cluster) and services running in the mesh.<a data-primary="north-south communication" data-type="indexterm" id="id1236"/></p>&#13;
&#13;
<p>At the time of writing, Istio’s gateway resource is being gradually phased out in favor of the new <a href="https://gateway-api.sigs.k8s.io">Kubernetes Gateway API</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1237">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Official reference documentation for <a href="https://oreil.ly/Lth6l">Istio virtual services</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Read more about how the Kubernetes Gateway API is expected to <a href="https://oreil.ly/6vHQv">replace Istio’s Gateway</a>.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="13.4 Rewriting a URL Using an Istio Virtual Service" data-type="sect1"><div class="sect1" id="istio_rewrite_url">&#13;
<h1>13.4 Rewriting a URL Using an Istio Virtual Service</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id262">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>A legacy client is using a URL and path for a service that is no longer valid.<a data-primary="virtual services (Istio)" data-secondary="routing traffic with" data-startref="ix_virsrvIst" data-type="indexterm" id="id1238"/><a data-primary="routing" data-secondary="using Istio virtual service" data-startref="ix_rtIst" data-type="indexterm" id="id1239"/><a data-primary="service meshes" data-secondary="routing traffic using Istio virtual service" data-startref="ix_srvmshrtIst" data-type="indexterm" id="id1240"/><a data-primary="Istio" data-secondary="routing traffic using Istio virtual service" data-startref="ix_Istrt" data-type="indexterm" id="id1241"/> You want to rewrite the path dynamically so that the service is correctly invoked, without having to make changes to the client.<a data-primary="service meshes" data-secondary="rewriting URL using Istio virtual service" data-type="indexterm" id="ix_srvmshIstrewURL"/><a data-primary="Istio" data-secondary="rewriting URL using Istio virtual service" data-type="indexterm" id="ix_IstrewURL"/><a data-primary="virtual services (Istio)" data-secondary="rewriting URL with" data-type="indexterm" id="ix_virsrvIstrew"/></p>&#13;
&#13;
<p>You can simulate this problem from your <code>curl</code> pod by invoking the path <em>/legacypath</em> like so, which produces a 404 Not Found response:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -v nginx/legacypath</strong>&#13;
*   Trying 10.152.183.90:80...&#13;
* Connected to nginx (10.152.183.90) port 80 (#0)&#13;
&gt; GET /legacypath HTTP/1.1&#13;
&gt; Host: nginx&#13;
&gt; User-Agent: curl/8.1.2&#13;
&gt; Accept: */*&#13;
&gt;&#13;
&lt; HTTP/1.1 404 Not Found&#13;
&lt; server: envoy&#13;
&lt; date: Mon, 26 Jun 2023 09:37:43 GMT&#13;
&lt; content-type: text/html&#13;
&lt; content-length: 153&#13;
&lt; x-envoy-upstream-service-time: 20&#13;
&lt;&#13;
&lt;html&gt;&#13;
&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;&#13;
&lt;body&gt;&#13;
&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;&#13;
&lt;hr&gt;&lt;center&gt;nginx/1.25.1&lt;/center&gt;&#13;
&lt;/body&gt;&#13;
&lt;/html&gt;&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1242">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use Istio to rewrite the legacy path so that it reaches a valid endpoint on the service, which in our example will be the root of the <code>nginx</code> service.</p>&#13;
&#13;
<p>Update the virtual service to include an HTTP rewrite:</p>&#13;
<pre data-type="programlisting">&#13;
apiVersion: networking.istio.io/v1alpha3&#13;
kind: VirtualService&#13;
metadata:&#13;
  name: nginx-vs&#13;
spec:&#13;
  hosts:&#13;
  - nginx&#13;
  http:&#13;
  - match:&#13;
    - uri:&#13;
        prefix: /legacypath&#13;
    rewrite:&#13;
      uri: /&#13;
    route:&#13;
    - destination:&#13;
        host: nginx&#13;
  - route:&#13;
    - destination:&#13;
        host: nginx&#13;
</pre>&#13;
&#13;
<p>And then apply the change:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f virtualservice.yaml</strong>&#13;
</pre>&#13;
&#13;
<p>The updated virtual service includes a <code>match</code> attribute, which will look for the legacy path and rewrite it to simply target the root endpoint.</p>&#13;
&#13;
<p>Now, calls to the legacy path from the <code>curl</code> pod will no longer produce a 404, but a 200 OK instead:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -v nginx/legacypath</strong>&#13;
*   Trying 10.152.183.90:80...&#13;
* Connected to nginx (10.152.183.90) port 80 (#0)&#13;
&gt; GET /legacypath HTTP/1.1&#13;
&gt; Host: nginx&#13;
&gt; User-Agent: curl/8.1.2&#13;
&gt; Accept: */*&#13;
&gt;&#13;
&lt; HTTP/1.1 200 OK&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id1243">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The role of virtual services is mainly to define the routing from clients to upstream services. For additional control over the requests to the upstream service, refer to the <a href="https://oreil.ly/Yu4xW">Istio documentation on destination rules</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1244">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/EGAFs">Istio <code>HTTPRewrite</code> documentation</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="13.5 Installing the Linkerd Service Mesh" data-type="sect1"><div class="sect1" id="install_linkerd">&#13;
<h1>13.5 Installing the Linkerd Service Mesh</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id263">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>Your project requires a small footprint and/or doesn’t need all the features provided by Istio, such as support for non-Kubernetes workloads or native support for egress.<a data-primary="virtual services (Istio)" data-secondary="rewriting URL with" data-startref="ix_virsrvIstrew" data-type="indexterm" id="id1245"/><a data-primary="service meshes" data-secondary="rewriting URL using Istio virtual service" data-startref="ix_srvmshIstrewURL" data-type="indexterm" id="id1246"/><a data-primary="Istio" data-secondary="rewriting URL using Istio virtual service" data-startref="ix_IstrewURL" data-type="indexterm" id="id1247"/><a data-primary="Linkerd" data-secondary="installing Linkerd service mesh" data-type="indexterm" id="ix_Lnkrsrvmsh"/><a data-primary="service meshes" data-secondary="installing Linkerd service mesh" data-type="indexterm" id="ix_srvmshLnk"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id264">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>You might be interested in trying Linkerd, which positions itself as a more lightweight alternative to Istio.</p>&#13;
&#13;
<p>First, if you’re directly following on from the Istio recipes, you can reset your environment by using a command like <code>kubectl delete all --all</code> (beware, this will remove <em>everything</em> from your cluster!).<a data-primary="kubectl" data-secondary="delete command" data-tertiary="delete all --all" data-type="indexterm" id="id1248"/></p>&#13;
&#13;
<p>You can then manually install Linkerd by executing the following command and following the instructions in the terminal:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl --proto '=https' --tlsv1.2 -sSfL https://run.linkerd.io/install | sh</strong>&#13;
</pre>&#13;
&#13;
<p>The output of the previous command will include additional steps, including updating your <code>PATH</code> as well as other checks and installation commands that are essential to completing the installation of Linkerd. The following snippet shows these instructions at time of writing:</p>&#13;
<pre data-type="programlisting">&#13;
...&#13;
Add the linkerd CLI to your path with:&#13;
&#13;
  export PATH=$PATH:/Users/jonathanmichaux/.linkerd2/bin&#13;
&#13;
Now run:&#13;
&#13;
  linkerd check --pre                     # validate that Linkerd can be inst...&#13;
  linkerd install --crds | kubectl apply -f - # install the Linkerd CRDs&#13;
  linkerd install | kubectl apply -f -    # install the control plane into the...&#13;
  linkerd check                           # validate everything worked!&#13;
...&#13;
</pre>&#13;
&#13;
<p>When you run the second of these <code>install</code> commands, you may get an error message recommending that you rerun that command with an additional parameter, as &#13;
<span class="keep-together">shown here:</span></p>&#13;
<pre data-type="programlisting">&#13;
linkerd install --set proxyInit.runAsRoot=true | kubectl apply -f -&#13;
</pre>&#13;
&#13;
<p>At the end of the installation, you’ll be asked to run a command that checks that everything is up and running correctly:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>linkerd check</strong>&#13;
...&#13;
linkerd-control-plane-proxy&#13;
---------------------------&#13;
√ control plane proxies are healthy&#13;
√ control plane proxies are up-to-date&#13;
√ control plane proxies and cli versions match&#13;
&#13;
Status check results are √&#13;
</pre>&#13;
&#13;
<p>You should also be able to see <a data-primary="pods" data-secondary="getting pods running in linkerd namespace" data-type="indexterm" id="id1249"/>the Linkerd pods running in the <code>linkerd</code> namespace:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get pods -n linkerd</strong>&#13;
NAME                                     READY   STATUS    RESTARTS   AGE&#13;
linkerd-destination-6b8c559b89-rx8f7     4/4     Running   0          9m23s&#13;
linkerd-identity-6dd765fb74-52plg        2/2     Running   0          9m23s&#13;
linkerd-proxy-injector-f54b7f688-lhjg6   2/2     Running   0          9m22s&#13;
</pre>&#13;
&#13;
<p>Make sure Linkerd is configured to automatically inject the Linkerd proxy to services that you deploy. <a data-primary="Linkerd" data-secondary="configuration to automatically inject Linkerd proxy to services" data-type="indexterm" id="id1250"/><a data-primary="annotations" data-secondary="Linkerd configured to automatically inject proxy to services" data-type="indexterm" id="id1251"/><a data-primary="kubectl" data-secondary="annotate command" data-type="indexterm" id="id1252"/>You can enable this for the default namespace with the following command:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl annotate namespace default linkerd.io/inject=enabled</strong>&#13;
namespace/default annotate&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id1253">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>William Morgan, the cofounder and CEO of Buoyant Inc., was the first to coin the term <em>service mesh</em> in 2016. Since then, the community behind Bouyant’s Linkerd has maintained its focus on providing a well-scoped, performant product.</p>&#13;
&#13;
<p>As mentioned in the problem statement, one of the main limitations of Linkerd to be aware of, at time of writing, is that it can only mesh services that are running on Kubernetes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1254">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The Linkerd official <a href="https://oreil.ly/zx-Wx">Getting Started guide</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="13.6 Deploying a Service into the Linkerd Mesh" data-type="sect1"><div class="sect1" id="deploy_to_linkerd">&#13;
<h1>13.6 Deploying a Service into the Linkerd Mesh</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id265">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to deploy a service into the Linkerd mesh and inject a sidecar into its pod.<a data-primary="service meshes" data-secondary="installing Linkerd service mesh" data-startref="ix_srvmshLnk" data-type="indexterm" id="id1255"/><a data-primary="Linkerd" data-secondary="installing Linkerd service mesh" data-startref="ix_Lnkrsrvmsh" data-type="indexterm" id="id1256"/><a data-primary="service meshes" data-secondary="deploying a service into Linkerd mesh" data-type="indexterm" id="ix_srvmshLnkdplser"/><a data-primary="Linkerd" data-secondary="deploying a service into Linkerd mesh" data-type="indexterm" id="ix_Lnkdplsrv"/><a data-primary="deployments" data-secondary="deploying a service into Linkerd service mesh" data-type="indexterm" id="ix_dplysrvLnkd"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1257">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Let’s deploy the same <code>nginx</code> service as we did with Istio, which responds to HTTP GET requests on its root endpoint, returns a 404 response on others.</p>&#13;
&#13;
<p>Start by creating a deployment for NGINX:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl create deployment nginx --image nginx:1.25.2</strong>&#13;
deployment.apps/nginx created&#13;
</pre>&#13;
&#13;
<p>Then expose this as a Kubernetes service:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl expose deploy/nginx --port 80</strong>&#13;
service/nginx exposed&#13;
</pre>&#13;
&#13;
<p>Now list the pods in the default namespace. You should have two containers in the <code>nginx</code> service’s pod:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl get po</strong>&#13;
NAME                     READY   STATUS    RESTARTS   AGE&#13;
nginx-748c667d99-fjjm4   2/2     Running   0          13s&#13;
</pre>&#13;
&#13;
<p>If you investigate the details of this pod, you’ll find that two Linkerd containers were injected into the pod. One is the init container, which plays a role in routing TCP traffic to and from the pod and which terminates before the other pods are started. The other container is the Linkerd proxy itself:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl describe pod -l app=nginx | grep Image:</strong>&#13;
    Image:          cr.l5d.io/linkerd/proxy-init:v2.2.1&#13;
    Image:          cr.l5d.io/linkerd/proxy:stable-2.13.5&#13;
    Image:          nginx&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id129">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Like Istio, Linkerd relies on a sidecar proxy, also known as an <a href="https://oreil.ly/ooN52">ambassador container</a>, that is injected into pods and provides additional functionality to the service running alongside it.<a data-primary="ambassador containers" data-type="indexterm" id="id1258"/><a data-primary="sidecar proxies" data-secondary="Linkerd" data-type="indexterm" id="id1259"/></p>&#13;
&#13;
<p>The Linkerd CLI provides the <code>linkerd inject</code> command as a useful alternative way to decide where and when to inject the Linkerd proxy container into the application pod, without manipulating labels yourself. You can read about it in the <a href="https://oreil.ly/KJfxJ">Linkerd documentation</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1260">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>More information on how to <a href="https://oreil.ly/TexFs">configure automatic sidecar injection</a></p>&#13;
</li>&#13;
<li>&#13;
<p>More information on the <a href="https://oreil.ly/nTiTn">architecture of Linkerd</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="13.7 Routing Traffic to a Service in Linkerd" data-type="sect1"><div class="sect1" id="linkerd_route_traffic">&#13;
<h1>13.7 Routing Traffic to a Service in Linkerd</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id266">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to deploy a service into the mesh that will invoke the <code>nginx</code> service you deployed in the previous recipe,<a data-primary="deployments" data-secondary="deploying a service into Linkerd mesh" data-startref="ix_dplysrvLnkd" data-type="indexterm" id="id1261"/><a data-primary="Linkerd" data-secondary="deploying a service into Linkerd mesh" data-startref="ix_Lnkdplsrv" data-type="indexterm" id="id1262"/><a data-primary="service meshes" data-secondary="deploying a service into Linkerd mesh" data-startref="ix_srvmshLnkdplser" data-type="indexterm" id="id1263"/><a data-primary="routing" data-secondary="routing traffic to service in Linkerd" data-type="indexterm" id="ix_rtLnkser"/><a data-primary="Linkerd" data-secondary="routing traffic to  service in" data-type="indexterm" id="ix_Lnkrt"/><a data-primary="service meshes" data-secondary="routing traffic to service in Linkerd" data-type="indexterm" id="ix_srvmshLnkrt"/> and verify that Linkerd and its sidecars are intercepting and routing the traffic.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id267">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>We’ll simulate interservice communication within the service mesh by deploying a <code>curl</code> pod that will be added to the mesh and invoke the <code>nginx</code> service.<a data-primary="curl utility" data-secondary="curl pod in Linkerd service mesh" data-type="indexterm" id="id1264"/> As you’ll see in this recipe, routing policies are defined differently in Linkerd.</p>&#13;
&#13;
<p>First, run a <code>curl</code> pod that you’ll use to invoke the service. Because you’re starting the <code>curl</code> pod in the default namespace and you’ve activated automatic sidecar injection in this namespace (<a data-type="xref" href="#install_linkerd">Recipe 13.5</a>), the <code>curl</code> pod will automatically get a sidecar and be added to the mesh:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl run mycurlpod --image=curlimages/curl -i --tty -- sh</strong>&#13;
Defaulted container "linkerd-proxy" out of: linkerd-proxy, mycurlpod,&#13;
linkerd-init (init)&#13;
error: Unable to use a TTY - container linkerd-proxy did not allocate one&#13;
If you don't see a command prompt, try pressing enter.&#13;
</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Because Linkerd modifies the default container ordering in a meshed pod, the previous <code>run</code> command will fail because it tries to tty into the Linkerd proxy, rather than our <code>curl</code> container.<a data-primary="containers" data-secondary="Linkerd modifying default ordering of in meshed pod" data-type="indexterm" id="id1265"/></p>&#13;
&#13;
<p>To bypass this issue, you can unblock the terminal with CTRL-C and then run a command to connect into the correct container by using the <code>-c</code> flag:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl attach mycurlpod -c mycurlpod -i -t</strong>&#13;
</pre>&#13;
</div>&#13;
&#13;
<p>Now you can invoke the <code>nginx</code> service from the <code>curl</code> pod:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -v nginx</strong>&#13;
*   Trying 10.111.17.127:80...&#13;
* Connected to nginx (10.111.17.127) port 80 (#0)&#13;
&gt; GET / HTTP/1.1&#13;
&gt; Host: nginx&#13;
&gt; User-Agent: curl/8.1.2&#13;
&gt; Accept: */*&#13;
&gt;&#13;
&lt; HTTP/1.1 200 OK&#13;
&lt; server: nginx/1.25.1&#13;
...&#13;
&lt;&#13;
&lt;!DOCTYPE html&gt;&#13;
&lt;html&gt;&#13;
&lt;head&gt;&#13;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;&#13;
...&#13;
</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You’ll see the response from the <code>nginx</code> service, but unlike with Istio, there aren’t yet any clear indicators that Linkerd has &#13;
<span class="keep-together">successfully</span> intercepted this request.</p>&#13;
</div>&#13;
&#13;
<p>To start adding a Linkerd routing policy to the <code>nginx</code> service, define a Linkerd <code>Server</code> resource in a file called <em>linkerd-server.yaml</em>, shown here:</p>&#13;
<pre data-type="programlisting">&#13;
apiVersion: policy.linkerd.io/v1beta1&#13;
kind: Server&#13;
metadata:&#13;
  name: nginx&#13;
  labels:&#13;
    app: nginx&#13;
spec:&#13;
  podSelector:&#13;
    matchLabels:&#13;
      app: nginx&#13;
  port: 80&#13;
</pre>&#13;
&#13;
<p>Then create the server:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f linkerd-server.yaml</strong>&#13;
server.policy.linkerd.io/nginx created&#13;
</pre>&#13;
&#13;
<p>Now if you invoke the service again from the <code>curl</code> pod, you’ll get confirmation that Linkerd is intercepting this request, because by default it will reject requests to servers that don’t have an associated authorization policy:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -v nginx</strong>&#13;
*   Trying 10.111.17.127:80...&#13;
* Connected to nginx (10.111.17.127) port 80 (#0)&#13;
&gt; GET / HTTP/1.1&#13;
&gt; Host: nginx&#13;
&gt; User-Agent: curl/8.1.2&#13;
&gt; Accept: */*&#13;
&gt;&#13;
&lt; HTTP/1.1 403 Forbidden&#13;
&lt; l5d-proxy-error: client 10.244.0.24:53274: server: 10.244.0.23:80:&#13;
unauthorized request on route&#13;
&lt; date: Wed, 05 Jul 2023 20:33:24 GMT&#13;
&lt; content-length: 0&#13;
&lt;&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id268">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>As you can see, Linkerd uses pod selector labels to determine which pods are governed by the policies of the mesh.<a data-primary="virtual services (Istio)" data-secondary="determining pods governed by routing policies of the mesh" data-type="indexterm" id="id1266"/> In comparison, Istio’s <code>VirtualService</code> resource references a service by name directly.<a data-primary="service meshes" data-secondary="routing traffic to service in Linkerd" data-startref="ix_srvmshLnkrt" data-type="indexterm" id="id1267"/><a data-primary="Linkerd" data-secondary="routing traffic to  service in" data-startref="ix_Lnkrt" data-type="indexterm" id="id1268"/><a data-primary="routing" data-secondary="routing traffic to service in Linkerd" data-startref="ix_rtLnkser" data-type="indexterm" id="id1269"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="13.8 Authorizing Traffic to the Server in Linkerd" data-type="sect1"><div class="sect1" id="linkerd_authorization">&#13;
<h1>13.8 Authorizing Traffic to the Server in Linkerd</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id269">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You’ve added a service like <code>nginx</code> to the mesh and declared it as a Linkerd server, but now you’re getting 403 Forbidden responses because the mesh requires authorization by default on all declared servers.<a data-primary="service meshes" data-secondary="authorizing traffic to server in Linkerd" data-type="indexterm" id="ix_srvmshLnkauthor"/><a data-primary="authorization" data-secondary="authorizing traffic to server in Linkerd" data-type="indexterm" id="ix_authorLnk"/><a data-primary="Linkerd" data-secondary="authorizing traffic to server in" data-type="indexterm" id="ix_Lnkauthor"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id1270">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Linkerd provides different policies to define which clients are allowed to contact which servers. In this example, we’ll use a Linkerd <code>AuthorizationPolicy</code> to specify which service accounts can call the <code>nginx</code> service.</p>&#13;
&#13;
<p>In your development environment, the <code>curl</code> pod is using the <code>default</code> service account, unless otherwise specified. In production, your services would have their own dedicated service accounts.</p>&#13;
&#13;
<p>Start by creating a file called <em>linkerd-auth-policy.yaml</em>, as shown here:</p>&#13;
<pre data-type="programlisting">&#13;
apiVersion: policy.linkerd.io/v1alpha1&#13;
kind: AuthorizationPolicy&#13;
metadata:&#13;
  name: nginx-policy&#13;
spec:&#13;
  targetRef:&#13;
    group: policy.linkerd.io&#13;
    kind: Server&#13;
    name: nginx&#13;
  requiredAuthenticationRefs:&#13;
    - name: default&#13;
      kind: ServiceAccount&#13;
</pre>&#13;
&#13;
<p>This policy declares that any client using the <code>default</code> service account will be able to access the Linkerd server called <code>nginx</code> that you created in the previous recipe.</p>&#13;
&#13;
<p>Apply the policy:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f linkerd-auth-policy.yaml</strong>&#13;
authorizationpolicy.policy.linkerd.io/nginx-policy created&#13;
</pre>&#13;
&#13;
<p class="pagebreak-before">Now you can invoke the <code>nginx</code> service from the <code>curl</code> pod and get a 200 OK:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl -v nginx</strong>&#13;
*   Trying 10.111.17.127:80...&#13;
* Connected to nginx (10.111.17.127) port 80 (#0)&#13;
&gt; GET / HTTP/1.1&#13;
&gt; Host: nginx&#13;
&gt; User-Agent: curl/8.1.2&#13;
&gt; Accept: */*&#13;
&gt;&#13;
&lt; HTTP/1.1 200 OK&#13;
...&#13;
&lt;!DOCTYPE html&gt;&#13;
&lt;html&gt;&#13;
&lt;head&gt;&#13;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id130">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Alternative ways to control access to servers include TLS identity-based policies, IP-based policies, specifically referencing clients by using pod selectors, and any combination of these.<a data-primary="access control" data-secondary="for servers" data-secondary-sortas="servers" data-type="indexterm" id="id1271"/></p>&#13;
&#13;
<p>Furthermore, <a href="https://oreil.ly/LwiQ_">default policies</a> can be applied that restrict access to services that aren’t formally referenced by a Linkerd <code>Server</code> resource.<a data-primary="service meshes" data-secondary="authorizing traffic to server in Linkerd" data-startref="ix_srvmshLnkauthor" data-type="indexterm" id="id1272"/><a data-primary="Linkerd" data-secondary="authorizing traffic to server in" data-startref="ix_Lnkauthor" data-type="indexterm" id="id1273"/><a data-primary="authorization" data-secondary="authorizing traffic to server in Linkerd" data-startref="ix_authorLnk" data-type="indexterm" id="id1274"/><a data-primary="service meshes" data-startref="ix_srvmsh" data-type="indexterm" id="id1275"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1276">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/FOtW1">Linkerd authorization policy documentation</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>