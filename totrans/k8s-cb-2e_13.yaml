- en: Chapter 13\. Service Meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter focuses on one of the building blocks that make it easier to develop
    distributed, microservices-based applications on Kubernetes: the service mesh.
    Service meshes like Istio and Linkerd can perform duties such as monitoring, service
    discovery, traffic control, and security, to name a few. By offloading these responsibilities
    to the mesh, application developers can focus on delivering added value rather
    than reinventing the wheel by solving transversal infrastructure concerns.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the major benefits of service meshes is that they can apply policies
    to services transparently, without the services (client and server) needing to
    know they are part of a service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll run through basic examples using both Istio and Linkerd.
    For each service mesh, we’ll show how you can quickly get up and running using
    Minikube and implement service-to-service communication inside the mesh while
    using simple but illustrative service mesh policies. In both examples, we’ll deploy
    a service based on NGINX, and our client invoking the service will be a `curl`
    pod. Both will be added to the mesh and the interactions between the services
    will be governed by the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Installing the Istio Service Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your organization is using or plans to use a microservices architecture, and
    you want to lighten the load on developers by offloading the need to build security,
    service discovery, telemetry, deployment strategies, and other nonfunctional concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install Istio on Minikube. Istio is the most widely adopted service mesh and
    can offload many responsibilities from microservice developers, while also providing
    operators with centralized governance over security and operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll need to start Minikube with enough resources to run Istio. The
    exact resource requirements depend on your platform, and you may need to adjust
    the resource allocations. We have gotten it to work with just under 8 GB of memory
    and four CPUs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a Minikube tunnel as a load balancer for Istio. To start it, run
    this command in a new terminal (it will lock the terminal to show output information):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Download and extract the latest version of Istio with the following command
    (Linux and macOS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: For Windows, you can install with `choco` or just extract the *.exe* from the
    downloadable archive. For more info on downloading Istio, head to Istio’s [Getting
    Started guide](https://oreil.ly/5uFlk).
  prefs: []
  type: TYPE_NORMAL
- en: 'Change to the Istio directory. You may need to adapt the directory name depending
    on the version of Istio that you installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `istioctl` command-line tool is designed to help debug and diagnose your
    service mesh, and you’ll use it to check your Istio configuration in other recipes.
    It lives in the *bin* directory, so add it to your path like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can install Istio. The following YAML file contains an example demo
    configuration. It intentionally deactivates the use of Istio as an ingress or
    egress gateway, as we won’t be using Istio for ingress here. Store this config
    in a file called *istio-demo-config.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use `istioctl` to apply this configuration to Minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, make sure Istio is configured to automatically inject Envoy sidecar
    proxies to services that you deploy. You can enable this for the default namespace
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide makes use of default (which sometimes implies latest) versions of
    underlying projects like Kubernetes and Istio.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize these versions to match the versions of your current production
    environment, for instance. To set the version of Istio you want to use, use the
    `ISTIO_VERSION` and `TARGET_ARCH` parameters when downloading Istio. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The official Istio [Getting Started guide](https://oreil.ly/AKCYs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.2 Deploying a Microservice with an Istio Sidecar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy a new service into the service mesh, implying that a sidecar
    should be automatically injected into the service’s pod. The sidecar will intercept
    all of the service’s incoming and outgoing traffic and allow the implementation
    of routing, security, and monitoring policies (among others) without modifying
    the implementation of the service itself.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll use NGINX as a simple service to work with. Start by creating a deployment
    for NGINX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then expose this as a Kubernetes service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Istio does not create new DNS entries on Kubernetes but instead relies on existing
    services registered by Kubernetes or any other service registry you might be using.
    Later in the chapter, you’ll deploy a `curl` pod that invokes the `nginx` service
    and set the `curl` host to `nginx` for DNS resolution, but then Istio will work
    its magic by intercepting the request and allowing you to define additional traffic
    control policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now list the pods in the default namespace. You should have two containers
    in the service’s pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you investigate the details of this pod, you’ll find that the Istio sidecar
    container (based on the Envoy proxy) was injected into the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe assumes you have enabled automatic sidecar injection in the namespace
    using the namespace labeling technique, as shown in [Recipe 13.1](#install_istio).
    However, you might not necessarily want to inject sidecars into every single pod
    in the namespace. In that case, you can manually choose which pods should include
    the sidecar and thereby be added to the mesh. You can learn more about manual
    sidecar injection in the [official Istio documentation](https://oreil.ly/VbHz_).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information about how to [install and configure the sidecar](https://oreil.ly/E-omC)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about the [role of sidecars in Istio](https://oreil.ly/TperP)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.3 Routing Traffic Using an Istio Virtual Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy another service onto the cluster that will invoke the `nginx`
    service you deployed earlier, but you don’t want to write any routing or security
    logic into the services themselves. You also want to decouple the client and server
    as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll simulate interservice communication within the service mesh by deploying
    a `curl` pod that will be added to the mesh and invoke the `nginx` service.
  prefs: []
  type: TYPE_NORMAL
- en: To decouple the `curl` pod from the specific pod running `nginx`, you’ll create
    an Istio virtual service. The `curl` pod only needs to know about the virtual
    service. Istio and its sidecars will intercept and route the traffic from the
    client to the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following virtual service specification in a file called *virtualservice.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the virtual service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run a `curl` pod that you’ll use to invoke the service. Because you’ve
    deployed the `curl` pod in the `default` namespace and you’ve activated automatic
    sidecar injection in this namespace ([Recipe 13.1](#install_istio)), the `curl`
    pod will automatically get a sidecar and be added to the mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you accidentally exit the `curl` pod’s shell, you can always enter the pod
    again with the `kubectl exec` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can invoke the `nginx` virtual service from the `curl` pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see the response from the `nginx` service, but notice how the HTTP header
    `server: envoy` indicates that the response is actually coming from the Istio
    sidecar running in the `nginx` pod.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To reference virtual services from `curl`, we’re using short names that reference
    the names of the Kubernetes services (`nginx` in this example). Under the hood,
    these names are translated into fully qualified domain names, like `nginx.default.svc.cluster.local`.
    As you can see, the fully qualified name includes a namespace name (`default`
    in this case). To be safe, for production use cases it is recommend you explicitly
    use fully qualified names to avoid misconfigurations.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe focused on interservice communication within a service mesh (also
    known as *east–west communication*), which is the sweet spot for this technology.
    However, Istio and other services meshes are also able to perform gateway duties
    (also known as *ingress* and *north–south communication*), such as interactions
    between clients running outside the mesh (or the Kubernetes cluster) and services
    running in the mesh.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, Istio’s gateway resource is being gradually phased out
    in favor of the new [Kubernetes Gateway API](https://gateway-api.sigs.k8s.io).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Official reference documentation for [Istio virtual services](https://oreil.ly/Lth6l).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read more about how the Kubernetes Gateway API is expected to [replace Istio’s
    Gateway](https://oreil.ly/6vHQv).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.4 Rewriting a URL Using an Istio Virtual Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A legacy client is using a URL and path for a service that is no longer valid.
    You want to rewrite the path dynamically so that the service is correctly invoked,
    without having to make changes to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can simulate this problem from your `curl` pod by invoking the path */legacypath*
    like so, which produces a 404 Not Found response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use Istio to rewrite the legacy path so that it reaches a valid endpoint on
    the service, which in our example will be the root of the `nginx` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the virtual service to include an HTTP rewrite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And then apply the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The updated virtual service includes a `match` attribute, which will look for
    the legacy path and rewrite it to simply target the root endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, calls to the legacy path from the `curl` pod will no longer produce a
    404, but a 200 OK instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The role of virtual services is mainly to define the routing from clients to
    upstream services. For additional control over the requests to the upstream service,
    refer to the [Istio documentation on destination rules](https://oreil.ly/Yu4xW).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Istio `HTTPRewrite` documentation](https://oreil.ly/EGAFs)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.5 Installing the Linkerd Service Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your project requires a small footprint and/or doesn’t need all the features
    provided by Istio, such as support for non-Kubernetes workloads or native support
    for egress.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be interested in trying Linkerd, which positions itself as a more
    lightweight alternative to Istio.
  prefs: []
  type: TYPE_NORMAL
- en: First, if you’re directly following on from the Istio recipes, you can reset
    your environment by using a command like `kubectl delete all --all` (beware, this
    will remove *everything* from your cluster!).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then manually install Linkerd by executing the following command and
    following the instructions in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the previous command will include additional steps, including
    updating your `PATH` as well as other checks and installation commands that are
    essential to completing the installation of Linkerd. The following snippet shows
    these instructions at time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the second of these `install` commands, you may get an error message
    recommending that you rerun that command with an additional parameter, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the installation, you’ll be asked to run a command that checks
    that everything is up and running correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also be able to see the Linkerd pods running in the `linkerd` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure Linkerd is configured to automatically inject the Linkerd proxy to
    services that you deploy. You can enable this for the default namespace with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: William Morgan, the cofounder and CEO of Buoyant Inc., was the first to coin
    the term *service mesh* in 2016\. Since then, the community behind Bouyant’s Linkerd
    has maintained its focus on providing a well-scoped, performant product.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the problem statement, one of the main limitations of Linkerd
    to be aware of, at time of writing, is that it can only mesh services that are
    running on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linkerd official [Getting Started guide](https://oreil.ly/zx-Wx)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.6 Deploying a Service into the Linkerd Mesh
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy a service into the Linkerd mesh and inject a sidecar into
    its pod.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s deploy the same `nginx` service as we did with Istio, which responds to
    HTTP GET requests on its root endpoint, returns a 404 response on others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a deployment for NGINX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then expose this as a Kubernetes service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now list the pods in the default namespace. You should have two containers
    in the `nginx` service’s pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If you investigate the details of this pod, you’ll find that two Linkerd containers
    were injected into the pod. One is the init container, which plays a role in routing
    TCP traffic to and from the pod and which terminates before the other pods are
    started. The other container is the Linkerd proxy itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like Istio, Linkerd relies on a sidecar proxy, also known as an [ambassador
    container](https://oreil.ly/ooN52), that is injected into pods and provides additional
    functionality to the service running alongside it.
  prefs: []
  type: TYPE_NORMAL
- en: The Linkerd CLI provides the `linkerd inject` command as a useful alternative
    way to decide where and when to inject the Linkerd proxy container into the application
    pod, without manipulating labels yourself. You can read about it in the [Linkerd
    documentation](https://oreil.ly/KJfxJ).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More information on how to [configure automatic sidecar injection](https://oreil.ly/TexFs)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on the [architecture of Linkerd](https://oreil.ly/nTiTn)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 13.7 Routing Traffic to a Service in Linkerd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy a service into the mesh that will invoke the `nginx` service
    you deployed in the previous recipe, and verify that Linkerd and its sidecars
    are intercepting and routing the traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll simulate interservice communication within the service mesh by deploying
    a `curl` pod that will be added to the mesh and invoke the `nginx` service. As
    you’ll see in this recipe, routing policies are defined differently in Linkerd.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run a `curl` pod that you’ll use to invoke the service. Because you’re
    starting the `curl` pod in the default namespace and you’ve activated automatic
    sidecar injection in this namespace ([Recipe 13.5](#install_linkerd)), the `curl`
    pod will automatically get a sidecar and be added to the mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because Linkerd modifies the default container ordering in a meshed pod, the
    previous `run` command will fail because it tries to tty into the Linkerd proxy,
    rather than our `curl` container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bypass this issue, you can unblock the terminal with CTRL-C and then run
    a command to connect into the correct container by using the `-c` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can invoke the `nginx` service from the `curl` pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ll see the response from the `nginx` service, but unlike with Istio, there
    aren’t yet any clear indicators that Linkerd has successfully intercepted this
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start adding a Linkerd routing policy to the `nginx` service, define a Linkerd
    `Server` resource in a file called *linkerd-server.yaml*, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if you invoke the service again from the `curl` pod, you’ll get confirmation
    that Linkerd is intercepting this request, because by default it will reject requests
    to servers that don’t have an associated authorization policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, Linkerd uses pod selector labels to determine which pods are
    governed by the policies of the mesh. In comparison, Istio’s `VirtualService`
    resource references a service by name directly.
  prefs: []
  type: TYPE_NORMAL
- en: 13.8 Authorizing Traffic to the Server in Linkerd
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve added a service like `nginx` to the mesh and declared it as a Linkerd
    server, but now you’re getting 403 Forbidden responses because the mesh requires
    authorization by default on all declared servers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linkerd provides different policies to define which clients are allowed to contact
    which servers. In this example, we’ll use a Linkerd `AuthorizationPolicy` to specify
    which service accounts can call the `nginx` service.
  prefs: []
  type: TYPE_NORMAL
- en: In your development environment, the `curl` pod is using the `default` service
    account, unless otherwise specified. In production, your services would have their
    own dedicated service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a file called *linkerd-auth-policy.yaml*, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This policy declares that any client using the `default` service account will
    be able to access the Linkerd server called `nginx` that you created in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can invoke the `nginx` service from the `curl` pod and get a 200 OK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Alternative ways to control access to servers include TLS identity-based policies,
    IP-based policies, specifically referencing clients by using pod selectors, and
    any combination of these.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, [default policies](https://oreil.ly/LwiQ_) can be applied that
    restrict access to services that aren’t formally referenced by a Linkerd `Server`
    resource.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Linkerd authorization policy documentation](https://oreil.ly/FOtW1)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
