- en: Chapter 2\. Indexes and Indexing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many factors determine MySQL performance, but indexes are special because performance
    cannot be achieved without them. You can remove other factors—queries, schemas,
    data, and so on—and still achieve performance, but removing indexes limits performance
    to brute force: relying on the speed and capacity of hardware. If this book were
    titled *Brute Force MySQL Performance*, the contents would be as long as the title:
    “Buy better, faster hardware.” You laugh, but just a few days ago I met with a
    team of developers who had been improving performance in the cloud by purchasing
    faster hardware until stratospheric costs compelled them to ask, “How else can
    we improve performance?”'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL leverages hardware, optimizations, and indexes to achieve performance
    when accessing data. Hardware is an obvious leverage because MySQL runs on hardware:
    the faster the hardware, the better the performance. Less obvious and perhaps
    more surprising is that hardware provides the *least* leverage. I explain why
    in a moment. *Optimizations* refer to the numerous techniques, algorithms, and
    data structures that enable MySQL to utilize hardware efficiently. Optimizations
    bring the power of hardware into focus. And focus is the difference between a
    light bulb and a laser. Consequently, optimizations provide more leverage than
    hardware. If databases were small, hardware and optimizations would be sufficient.
    But increasing data size *deleverages* the benefits of hardware and optimizations.
    Without indexes, performance is severely limited.'
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate these points, think of MySQL as a fulcrum that leverages hardware,
    optimizations, and indexes to figuratively lift data, as shown in [Figure 2-1](#no-indexes).
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0201](assets/emsp_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. MySQL performance without indexes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Without indexes (on the right side), MySQL achieves limited performance with
    relatively small data. But add indexes to the balance, as shown in [Figure 2-2](#good-indexes),
    and MySQL achieves high performance with large data.
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0202](assets/emsp_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. MySQL performance with indexes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Indexes provide the most *and the best* leverage. They are required for any
    nontrivial amount of data. MySQL performance requires proper indexes and indexing,
    both of which this chapter teaches in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Several years ago, I designed and implemented an application that stores a lot
    of data. Originally, I estimated the largest table not to exceed a million rows.
    But there was a bug in the data archiving code that allowed the table to reach
    one *billion* rows. For years, nobody noticed because response time was always
    great. Why? Good indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It’s commonly said that MySQL uses only one index per table, but that’s not
    entirely true. The index merge optimization, for example, can use two indexes.
    In this book, however, I focus on the normal case: one query, one table, one index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter teaches MySQL indexes and indexing. There are five major sections.
    The first argues why you should not be distracted by hardware or MySQL tuning.
    It’s a necessary digression in order to fully understand why hardware and MySQL
    tuning are not efficient solutions for improving MySQL performance. The second
    is a visual introduction to MySQL indexes: what they are and how they work. The
    third teaches indexing—applying indexes for maximum leverage—by thinking like
    MySQL. The fourth covers common reasons why indexes lose effectiveness (leverage).
    The fifth is a brief overview of MySQL table join algorithms because effective
    joins rely on effective indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: Red Herrings of Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Red herring* is an idiom that refers to a distraction from a goal. When tracking
    down solutions to improve MySQL performance, two red herrings commonly distract
    engineers: faster hardware and MySQL tuning.'
  prefs: []
  type: TYPE_NORMAL
- en: Better, Faster Hardware!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When MySQL performance isn’t acceptable, do *not* begin by scaling up (using
    better, faster hardware) to “see if that helps.” It probably will help if you
    scale up significantly, but you learn nothing because it only proves what you
    already know: computers run faster on faster hardware. Better, faster hardware
    is a red herring of performance because you miss learning the real causes of,
    and solutions to, slow performance.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two reasonable exceptions. First, if the hardware is blatantly insufficient,
    then scale up to reasonable hardware. For example, using 1 GB of memory with 500
    GB of data is blatantly insufficient. Upgrading to 32 GB or 64 GB of memory is
    reasonable. By contrast, upgrading to 384 GB of memory is sure to help but is
    unreasonable. Second, if the application is experiencing *hyper-growth* (a massive
    increase in users, usage, and data) and scaling up is a stopgap solution to keep
    the application running, then do it. Keeping the application running is always
    reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, scaling up to improve MySQL performance happens *last*. Experts
    agree: *first* optimize queries, data, access patterns, and the application. If
    all those optimizations do not yield sufficient performance, then scale up. Scaling
    up happens last for the following reasons.'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t learn anything by scaling up, you simply clobber the problem with
    faster hardware. Since you’re an engineer, not a cave-dwelling protohuman, you
    *solve* problems by learning and understanding—you don’t clobber them. Admittedly,
    learning and understanding is more difficult and time-consuming, but it’s far
    more effective and sustainable, which leads to the next reason.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling up is not a sustainable approach. Upgrading physical hardware is nontrivial.
    Some upgrades are relatively quick and easy, but it depends on many factors outside
    the scope of this book. Sufficient to say, however, that you will drive yourself
    or the hardware engineers crazy if you frequently change hardware. Crazy engineers
    are not sustainable. Moreover, companies often use the same hardware for several
    years because the purchasing process is long and complicated. As a result, easy
    hardware scalability is one allure of the cloud. In the cloud, you can scale up
    (or down) CPU cores, memory, and storage in a few minutes. But this ease is *significantly*
    more expensive than physical hardware. Cloud costs can increase exponentially.
    The cost of Amazon RDS, for example, doubles from one instance size to the next—double
    the hardware, double the price. Exponentially increasing costs are not sustainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, MySQL can fully utilize all the hardware that it’s given.
    (There are limits, which I address in [Chapter 4](ch04.html#ch04).) The real question
    is: can the application fully utilize MySQL? The presumptive answer is yes, but
    it’s not guaranteed. Faster hardware helps MySQL but it does not change how the
    application uses MySQL. For example, increasing memory might not improve performance
    if the application causes table scans. Scaling up is only effective at increasing
    performance when the application workload can scale up, too. Not all workloads
    can scale up.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Workload* is the combination of queries, data, and access patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But let’s imagine that you successfully scale up the workload to fully utilize
    MySQL on the fastest hardware available. What happens as the application continues
    to grow, and its workload continues to increase? This reminds me of a Zen proverb:
    “When you reach the top of the mountain, keep climbing.” While I do encourage
    you to meditate on that, it presents a less enlightening dilemma for your application.
    With nowhere else to go, the only option is doing what should have been done first:
    optimize queries, data, access patterns, and the application.'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Tuning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the television series *Star Trek*, engineers are able to modify the ship
    to increase power to engines, weapons, shields, sensors, transporters, tractor
    beams—everything. MySQL is more difficult to operate than a starship because no
    such modifications are possible. But that does not stop engineers from trying.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s clarify three terms.
  prefs: []
  type: TYPE_NORMAL
- en: Tuning
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuning is adjusting MySQL system variables for research and development (R&D).
    It’s laboratory work with specific goals and criteria. Benchmarking is common:
    adjusting system variables to measure the effect on performance. The blog post
    [“MySQL Challenge: 100k Connections”](https://oreil.ly/CGvrU) by renowned MySQL
    expert Vadim Tkachenko is an example of extreme tuning. Since tuning is R&D, the
    results are not expected to be generally applicable; rather, the goal is to expand
    our collective knowledge and understanding of MySQL, especially with respect to
    its current limits. Tuning influences future MySQL development and best practices.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring
  prefs: []
  type: TYPE_NORMAL
- en: Configuring is setting system variables to values that are appropriate for the
    hardware and environment. The goal is a reasonable configuration with respect
    to a few default values that need to be changed. Configuring MySQL is usually
    done when the MySQL instance is provisioned or when hardware changes. It’s also
    necessary to reconfigure when data size increases by an order of magnitude, for
    example from 10 GB to 100 GB. Configuring influences how MySQL runs in general.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing is improving MySQL performance by reducing the workload or making
    it more efficient—usually the latter since application usage tends to increase.
    The goal is faster response time and more capacity with the existing hardware.
    Optimizing influences MySQL and application performance.
  prefs: []
  type: TYPE_NORMAL
- en: You will undoubtedly encounter these terms in MySQL literature, videos, conferences,
    and so forth. The descriptions are more important than the terms. If, for example,
    you read a blog post that uses *optimizing* but describes what is defined here
    as *tuning*, then it’s tuning as defined here.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction of these terms is important because engineers do all three,
    but only optimizing (as defined here) is an efficient use of your time.^([1](ch02.html#idm45829114802704))
  prefs: []
  type: TYPE_NORMAL
- en: MySQL tuning is a red herring of performance for two reasons. First, it’s often
    not done as a controlled laboratory experiment, which makes the results dubious.
    In totality, MySQL performance is complex; experiments must be carefully controlled.
    Second, results are unlikely to have a significant effect on performance because
    MySQL is already highly optimized. Tuning MySQL is akin to squeezing blood from
    a turnip.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the first paragraph of this section, I realize that we all admire
    Lieutenant Commander Geordi La Forge, the Chief Engineer in *Star Trek: The Next
    Generation*. When the captain calls for more power, we feel obligated to make
    it so by applying arcane server parameters. Or, on Earth, when the application
    needs more power, we want to save the day by applying an ingenious reconfiguration
    of MySQL that boosts throughput and concurrency by 50%. Good work, La Forge! Unfortunately,
    MySQL 8.0 introduced automatic configuration by enabling [`innodb_dedicated_server`](https://oreil.ly/niPGL).
    Since MySQL 5.7 will be end-of-life (EOL) soon after this book is published, let’s
    keep looking to and building the future. Good work nevertheless, La Forge.'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing is all you need to do because tuning is a red herring and configuration
    is automatic as of MySQL 8.0\. This book is all about optimizing.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL Indexes: A Visual Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Indexes are the key to performance and, if you recall [“Direct Query Optimization”](ch01.html#direct-query-optimization),
    changes to queries and indexes solve *a lot* of performance problems. The journey
    of query optimization requires a solid understanding of MySQL indexes, and that’s
    what this section presents—in detail with copious illustrations.
  prefs: []
  type: TYPE_NORMAL
- en: Although this section is detailed and relatively long, I call it an *introduction*
    because there is more to learn. But this section is the key that unlocks the treasure
    chest of MySQL query optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: The following nine sections apply only to standard indexes on InnoDB tables—the
    type of index created by a simple `PRIMARY KEY` or `[UNIQUE] INDEX` table definition.
    MySQL supports other specialized index types, but I don’t cover them in this book
    because standard indexes are the basis of performance.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the details of MySQL indexes, I begin with a revelation
    about InnoDB tables that will change the way you see not only indexes but most
    of MySQL performance.
  prefs: []
  type: TYPE_NORMAL
- en: InnoDB Tables Are Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example 2-1](#elem) is the structure of table `elem` (short for *elements*)
    and the 10 rows that it contains. All examples in this chapter refer to table
    `elem`—with one clearly noted exception—so take a moment to study it.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Table `elem`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Table `elem` has two indexes: the primary key on column `id` and a nonunique
    secondary index on columns `a, b`. The value for column `id` is a monotonically
    increasing integer. The values for columns `a`, `b`, and `c` are atomic symbols
    corresponding to the column name letter: “Ag” (silver) for column `a`, “B” (boron)
    for column `b`, and so on. The row values are random and meaningless; it’s just
    a simple table used for examples.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-3](#idx-table) shows a typical view of table `elem`—just the first
    four rows for brevity.'
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0203](assets/emsp_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3\. Table `elem`: visual model'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Nothing special about table `elem`, right? It’s so simple, one might say it’s
    elementary. But what if I told you that it’s not really a table, it’s an index?
    Get the “F” (fluorine) out of here! [Figure 2-4](#idx-table-pk) shows the true
    structure of table `elem` as an InnoDB table.
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0204](assets/emsp_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4\. Table `elem`: InnoDB B-tree index'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: InnoDB tables are B-tree indexes organized by the primary key. Rows are index
    records stored in leaf nodes of the index structure. Each index record has metadata
    (denoted by “…”) used for row locking, transaction isolation, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-4](#idx-table-pk) is a highly simplified depiction of the B-tree
    index that is table `elem`. Four index records (at bottom) correspond to the first
    four rows. Primary key column values (`1`, `2`, `3`, and `4`) are shown at the
    top of each index record. Other column values (“Ag,” “B,” “C,” and so forth) are
    shown below the metadata for each index record.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to know the technical details of InnoDB B-tree indexes to understand
    or achieve remarkable MySQL performance. Only two points are important:'
  prefs: []
  type: TYPE_NORMAL
- en: Primary key lookups are extremely fast and efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The primary key is pivotal to MySQL performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first point is true because B-tree indexes are inherently fast and efficient,
    which is one reason why many database servers use them. The second point becomes
    increasingly clear in the coming sections—and chapters.
  prefs: []
  type: TYPE_NORMAL
- en: To learn about the fascinating world of database internals, including indexes,
    read [*Database Internals*](https://oreil.ly/TDsCc) by Alex Petrov (O’Reilly,
    2019). For a deep dive into InnoDB internals, including its B-tree implementation,
    cancel all your meetings and check out the website of renowned MySQL expert [Jeremy
    Cole](https://oreil.ly/9sH9m).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An InnoDB primary key is a clustered index. The MySQL manual occasionally refers
    to the primary key as *the clustered index*.
  prefs: []
  type: TYPE_NORMAL
- en: Indexes provide the most and the best leverage because the table *is* an index.
    The primary key is pivotal to performance. This is especially true because secondary
    indexes include primary key values. [Figure 2-5](#idx-secondary) shows the secondary
    index on columns `a, b`.
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0205](assets/emsp_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. Secondary index on columns a, b
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Secondary indexes are B-tree indexes, too, but leaf nodes store primary key
    values. When MySQL uses a secondary index to find a row, it does a second lookup
    on the primary key to read the full row. Let’s put the two together and walk through
    a secondary index lookup for query `SELECT * FROM elem WHERE a=''Au'' AND b=''Be''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0206](assets/emsp_0206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Secondary index lookup for value “Au, Be”
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 2-6](#idx-2nd-lookup-1) shows the secondary index (columns `a, b`)
    on top and the primary key (column `id`) on bottom. Six callouts (numbered circles)
    show the lookup for value “Au, Be” using the secondary index:'
  prefs: []
  type: TYPE_NORMAL
- en: Index lookups begin at the root node; branch right to an internal node for value
    “Au, Be.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At an internal node, branch right to the leaf node for value “Au, Be.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Leaf node for secondary index value “Au, Be” contains the corresponding primary
    key value: 2.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin primary key lookup at the root node; branch left to an internal node for
    value 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At an internal node, branch right to the leaf node for value 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leaf node for primary key value 2 contains the full row matching “Au, Be.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A table has only one primary key. All other indexes are secondary indexes.
  prefs: []
  type: TYPE_NORMAL
- en: This section is short but incredibly important because the correct model provides
    the foundation for understanding indexes *and more*. For example, if you think
    back to [“Lock time”](ch01.html#Lock-time), you might see it in a new light since
    rows are actually leaf nodes in the primary key. Knowing that an InnoDB table
    is its primary key is akin to knowing that heliocentrism, not geocentrism, is
    the correct model of the solar system. In the world of MySQL, everything revolves
    around the primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Table Access Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using an index to look up rows is one of three table access methods. Since
    tables are indexes, an *index lookup* is the best and most common access method.
    But sometimes, depending on the query, an index lookup is not possible and the
    only recourse is an *index scan* or a *table scan*—the other access methods. Knowing
    which access method MySQL uses for a query is imperative because performance requires
    an index lookup. Avoid index scans and table scans. [“EXPLAIN: Query Execution
    Plan”](#EXPLAIN) shows how to see the access method. But first, let’s clarify
    and visualize each one.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The MySQL manual uses the terms *access method*, *access type*, and *join type*.
    And `EXPLAIN` uses a field called `type` or `access_type` to refer to those terms.
    In MySQL, the terms are closely related but used equivocally.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, for precision and consistency I use only two terms: *access method*
    and *access type*. There are three access methods: index lookup, index scan, and
    table scan. For an index lookup, there are several access types: `ref`, `eq_ref`,
    `range,` and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: Index lookup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An index lookup finds specific rows—or ranges of rows—by leveraging the ordered
    structure and algorithmic access of an index. This is the fastest access method
    because it’s precisely what indexes are designed for: fast and efficient access
    to large amounts of data. Consequently, index lookups are essential for direct
    query optimization. Performance requires that practically every query uses an
    index lookup for every table. There are several access types for an index lookup
    that I cover in forthcoming sections such as [“WHERE”](#idx-where).'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-6](#idx-2nd-lookup-1) in the previous section shows an index lookup
    using a secondary index.'
  prefs: []
  type: TYPE_NORMAL
- en: Index scan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When an index lookup is not possible, MySQL must use brute force to find rows:
    read all rows and filter out non-matching ones. Before MySQL resorts to reading
    every row using the primary key, it tries to read rows using a secondary index.
    This is called an index scan.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two types of index scan. The first is a *full* index scan, meaning
    MySQL reads all rows in index order. Reading all rows is usually terrible for
    performance, but reading them in index order can avoid sorting rows when the index
    order matches the query `ORDER BY`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-7](#idx-index-scan) shows a full index scan for query `SELECT * FROM
    elem FORCE INDEX (a) ORDER BY a, b`. The `FORCE INDEX` clause is required because,
    since table `elem` is tiny, it’s more efficient for MySQL to scan the primary
    key and sort the rows rather than scan the secondary index and fetch the rows
    in order. (Sometimes bad queries make good examples.)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-7](#idx-index-scan) has eight callouts (numbered circles) that show
    the order of row access:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read first value of secondary index (SI): “Ag, B.”'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up corresponding row in primary key (PK).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read second value of SI: “Al, Br.”'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up corresponding row in PK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read third value of SI: “Ar, Br.”'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up corresponding row in PK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Read fourth value of SI: “Au, Be.”'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up corresponding row in PK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![emsp 0207](assets/emsp_0207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-7\. Full index scan on secondary index
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is a subtle but important detail in [Figure 2-7](#idx-index-scan): scanning
    the secondary index in order might be sequential reads, but the primary key lookups
    are almost certainly random reads. Accessing rows in index order does not guarantee
    sequential reads; more than likely, it incurs random reads.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sequential access (reads and writes) is faster than random access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second type of index scan is an *index-only scan*: MySQL reads column values
    (not full rows) from the index. This requires a covering index, which is covered
    later (pun intended) in [“Covering Indexes”](#idx-covering-index). It should be
    faster than a full index scan because it doesn’t require primary key lookups to
    read full rows; it only reads column values from the secondary index, which is
    why it requires a covering index.'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t optimize for an index scan unless the only alternative is a full table
    scan. Otherwise, avoid index scans.
  prefs: []
  type: TYPE_NORMAL
- en: Table scan
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A (full) table scan reads *all* rows in primary key order. When MySQL cannot
    do an index lookup or an index scan, a table scan is the only option. This is
    usually terrible for performance, but it’s also usually easy to fix because MySQL
    is adept at using indexes and has many index-based optimizations. Essentially
    every query with a `WHERE`, `GROUP BY`, or `ORDER BY` clause can use an index—even
    if just an index scan—because those clauses use columns and columns can be indexed.
    Consequently, there are nearly zero reasons for an unfixable table scan.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-8](#idx-full-table-scan) shows a full table scan: reading *all* rows
    in primary key order. It has four callouts that show the order of row access.
    Table `elem` is tiny and only four rows are shown here, but imagine MySQL slogging
    through thousands or millions of rows in a real table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The general advice and best practice is to avoid table scans. But for a complete
    and balanced discussion, there are two cases when a table scan might be acceptable
    or (surprisingly) better:'
  prefs: []
  type: TYPE_NORMAL
- en: When the table is tiny and infrequently accessed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the table selectivity is very low (see [“Extreme Selectivity”](#extreme-selectivity))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![emsp 0208](assets/emsp_0208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Full table scan
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'But don’t take any table scan for granted: they’re usually bad for performance.
    In very rare cases, MySQL can incorrectly choose a table scan when an index lookup
    is possible, as explained in [“It’s a Trap! (When MySQL Chooses Another Index)”](#its-a-trap).'
  prefs: []
  type: TYPE_NORMAL
- en: Leftmost Prefix Requirement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use an index, a query must use a *leftmost prefix* of the index: one or
    more index columns starting with the leftmost index column as specified by the
    index definition. A leftmost prefix is required because the underlying index structure
    is ordered by the index column order, and it can only be traversed (searched)
    in that order.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use [`SHOW CREATE TABLE`](https://oreil.ly/cwQZy) or [`SHOW INDEX`](https://oreil.ly/5wBhH)
    to see index definitions.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-9](#idx-lpr) shows an index on columns `a, b, c` and a `WHERE` clause
    using each leftmost prefix: column `a`; columns `a, b`; and columns `a, b, c`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0209](assets/emsp_0209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-9\. Leftmost prefixes of a three-column index
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The top `WHERE` clause in [Figure 2-9](#idx-lpr) uses column `a`, which is
    the leftmost column of the index. The middle `WHERE` clause uses columns `a` and
    `b` that, together, form a leftmost prefix of the index. And the bottom `WHERE`
    clause uses the entire index: all three columns. It’s ideal to use all columns
    of an index, but it’s not required; only a leftmost prefix is required. Index
    columns can be used in other SQL clauses, as illustrated by many examples in the
    following sections.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To use an index, a query must use a *leftmost prefix* of the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'The leftmost prefix requirement has two logical consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: Indexes `(a, b)` and `(b, a)` are different indexes. They index the same columns
    but in a different order, which results in different leftmost prefixes. However,
    a query that uses both columns (for example, `WHERE a = 'Au' AND b = 'Be'`) can
    use either index, but that does not mean the indexes are equivalent in terms of
    performance. MySQL will choose the better of the two by calculating many factors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: MySQL can most likely use index `(a, b, c)` in place of indexes `(a)` and `(a,
    b)` because the latter two are leftmost prefixes of the first. In this case, indexes
    `(a)` and `(a, b)` are duplicates and can be dropped. Use [pt-duplicate-key-checker](https://oreil.ly/EqtfV)
    to find and report duplicate indexes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lurking at the end (rightmost) of every secondary index is the primary key.
    For table `elem` ([Example 2-1](#elem)), the secondary index is effectively `(a,
    b, id)`, but the rightmost `id` is hidden. MySQL doesn’t show the primary key
    appended to secondary indexes; you have to imagine it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The primary key is appended to every secondary index: `(S, P)` where `S` are
    secondary index columns and `P` are primary key columns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In MySQL lingo we say, “The primary key is appended to secondary indexes” even
    though it’s not literally appended. (You can literally append it by creating index
    `(a, b, id)`, but don’t do that.) “Appended to” really means that secondary index
    leaf nodes contain primary key values, as shown earlier in [Figure 2-5](#idx-secondary).
    This is important because it increases the size of every secondary index: primary
    key values are duplicated in secondary indexes. Larger indexes require more memory,
    which means fewer indexes can fit in memory. Keep the size of the primary key
    small and the number of secondary indexes reasonable. Just the other day, my colleagues
    were helping a team whose database has 693 GB of secondary indexes on 397 GB of
    data (primary key).'
  prefs: []
  type: TYPE_NORMAL
- en: The leftmost prefix requirement is a blessing and a restriction. The restriction
    is relatively easy to work around with additional secondary indexes, but wait
    until you read [“Excessive, Duplicate, and Unused”](#idx-too-many). Joining tables
    is a particular challenge given the restriction, but I address it in [“Join Tables”](#idx-join-tables).
    I encourage you to see the leftmost prefix requirement as a blessing. Query optimization
    with respect to indexing is not trivial, but the leftmost prefix requirement is
    a simple and familiar starting point on the journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'EXPLAIN: Query Execution Plan'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The MySQL [`EXPLAIN`](https://oreil.ly/M99Gp) command shows a *query execution
    plan* (or, *EXPLAIN plan*) that describes how MySQL plans to execute the query:
    table join order, table access method, index usage, and other important details.'
  prefs: []
  type: TYPE_NORMAL
- en: '`EXPLAIN` output is vast and varied. Moreover, it’s completely dependent on
    the query. Changing a single character in a query can significantly change its
    EXPLAIN plan. For example, `WHERE id = 1` verses `WHERE id > 1` yields a significantly
    different EXPLAIN plan. And to complicate the matter further, `EXPLAIN` continues
    to evolve. [“EXPLAIN Output Format”](https://oreil.ly/IMCOJ) in the MySQL manual
    is required reading—even for experts. Fortunately for the sake of our sanity,
    the fundamentals have remained the same for decades.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate index usage, the next five sections explain queries for each
    case that MySQL can use an index:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Find matching rows: [“WHERE”](#idx-where)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Group rows: [“GROUP BY”](#idx-group-by)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sort rows: [“ORDER BY”](#idx-order-by)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid reading rows: [“Covering Indexes”](#idx-covering-index)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Join tables: [“Join Tables”](#idx-join-tables)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other specific cases like `MIN()` and `MAX()`, but these five cases
    are the bread and butter of index usage.
  prefs: []
  type: TYPE_NORMAL
- en: But first I need to set the stage by reviewing the meaning of the `EXPLAIN`
    output fields shown in [Example 2-2](#explain-output).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. `EXPLAIN` output (traditional format)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For this introduction, we ignore fields `id`, `select_type`, `partitions`,
    `key_len`, and `filtered`; but the examples include them to habituate you to the
    output. The remaining seven fields convey a wealth of information that constitutes
    the query execution plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table`'
  prefs: []
  type: TYPE_NORMAL
- en: The `table` field is the table name (or alias) or subquery reference. Tables
    are listed in the join order determined by MySQL, not the order they appear in
    the query. The top table is the first table, and the bottom table is the last
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '`type`'
  prefs: []
  type: TYPE_NORMAL
- en: They `type` field is the table access method or index lookup access type—see
    the first note in [“Table Access Methods”](#table-access-methods) for clarification.
    `ALL` means a full table scan (see [“Table scan”](#table-scan)). `index` means
    an index scan (see [“Index scan”](#index-scan)). Any other value—`const`, `ref`,
    `range`, and so on—is an access type for an index lookup (see [“Index lookup”](#index-lookup)).
  prefs: []
  type: TYPE_NORMAL
- en: '`possible_keys`'
  prefs: []
  type: TYPE_NORMAL
- en: The `possible_keys` field lists indexes that MySQL could use because the query
    uses a leftmost prefix. If an index is not listed in this field, then the leftmost
    prefix requirement is not met.
  prefs: []
  type: TYPE_NORMAL
- en: '`key`'
  prefs: []
  type: TYPE_NORMAL
- en: The `key` field is the name of the index that MySQL will use, or `NULL` if no
    index can be used. MySQL chooses the best index based on many factors, some of
    which are indicated in the `Extra` field. It’s a safe bet that MySQL will use
    this index when executing the query (`EXPLAIN` does not execute the query), but
    see [“It’s a Trap! (When MySQL Chooses Another Index)”](#its-a-trap).
  prefs: []
  type: TYPE_NORMAL
- en: '`ref`'
  prefs: []
  type: TYPE_NORMAL
- en: The `ref` field lists the source of values used to look up rows in the index
    (the `key` field).
  prefs: []
  type: TYPE_NORMAL
- en: For single-table queries or the first table in a join, `ref` is often `const`,
    which refers to a constant condition on one or more index columns. A *constant
    condition* is equality (`=` or `<=>` [NULL-safe equal]) to a literal value. For
    example, `a = 'Au'` is a constant condition that equals only one value.
  prefs: []
  type: TYPE_NORMAL
- en: For queries that join multiple tables, `ref` is a column reference from the
    preceding table in the join order. MySQL joins the current table (the `table`
    field) using the index to look up rows that match values from column `ref` in
    the preceding table. [“Join Tables”](#idx-join-tables) shows this in action.
  prefs: []
  type: TYPE_NORMAL
- en: '`rows`'
  prefs: []
  type: TYPE_NORMAL
- en: The `rows` field is the estimated number of rows that MySQL will examine to
    find matching rows. MySQL uses index statistics to estimate rows, so expect the
    real number—[“Rows examined”](ch01.html#Rows-examined)—to be close but different.
  prefs: []
  type: TYPE_NORMAL
- en: '`Extra`'
  prefs: []
  type: TYPE_NORMAL
- en: The `Extra` field provides additional information about the query execution
    plan. This field is important because it indicates query optimizations that MySQL
    can apply, if any.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'All `EXPLAIN` output in this book is *traditional format*: tabular output (`EXPLAIN
    query;`) or list output (`EXPLAIN query\G`). Other formats are *JSON* (`EXPLAIN
    FORMAT=JSON query`) and, as of MySQL 8.0.16, *tree* (`EXPLAIN FORMAT=TREE query`).
    JSON and tree formats are completely different than traditional format, but all
    formats convey the query execution plan.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t expect to glean much information from those fields without context: tables,
    indexes, data, and a query. In the following sections, all illustrations refer
    to table `elem` ([Example 2-1](#elem)), its two indexes, and its ten rows.'
  prefs: []
  type: TYPE_NORMAL
- en: WHERE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL can use an index to find rows that match table conditions in a `WHERE`
    clause. I’m careful to say that MySQL *can* use an index, not that MySQL *will*
    use an index, because index usage depends on several factors, primarily: table
    conditions, indexes, and the leftmost prefix requirement (see [“Leftmost Prefix
    Requirement”](#LPR)). (There are other factors, like index statistics and optimizer
    costs, but they’re beyond the scope of this book.)'
  prefs: []
  type: TYPE_NORMAL
- en: A *table condition* is a column and its value (if any) that matches, groups,
    aggregates, or orders rows. (For brevity, I use the term *condition* when it’s
    unambiguous.) In a `WHERE` clause, table conditions are also called *predicates*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-10](#idx-where-pk) shows the primary key on column `id` and a `WHERE`
    clause with a single condition: `id = 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0210](assets/emsp_0210.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-10\. `WHERE`: primary key lookup'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A solid box delineates a table condition and an index column (also called an
    *index part*) that MySQL can use because the former (table condition) is a leftmost
    prefix of the latter (index). An arrow points from the table condition to the
    index column that it uses. Later, we’ll see examples of table conditions and index
    columns that MySQL cannot use.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-10](#idx-where-pk), MySQL can find rows that match condition `id
    = 1` using primary key column `id`. [Example 2-3](#ex-idx-where-pk) is the EXPLAIN
    plan for the full query.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. EXPLAIN plan for primary key lookup
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Example 2-3](#ex-idx-where-pk), `key: PRIMARY` confirms that MySQL will
    use the primary key—an index lookup. Correspondingly, the access type (the `type`
    field) is not `ALL` (table scan) or `index` (index scan), which is expected given
    a simple primary key lookup. The secondary index is not listed in the `possible_keys`
    field because MySQL cannot use it for this query: column `id` is not a leftmost
    prefix of the secondary index on columns `a, b`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access type `const` is a special case that occurs only when there are constant
    conditions (`ref: const`) on all index columns of the primary key or a unique
    secondary index. The result is a *constant row*. This is a little too in-depth
    for an introduction, but since we’re here, let’s keep learning. Given the table
    data ([Example 2-1](#elem)) and the fact that column `id` is the primary key,
    the row identified by `id = 1` can be treated as constant because, when the query
    is executed, `id = 1` can match only one row (or no row). MySQL reads that one
    row and treats its values as constant, which is great for response time: `const`
    access is extremely fast.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Extra: NULL` is somewhat rare because real queries are more complex than these
    examples. But here, `Extra: NULL` means that MySQL does not need to match rows.
    Why? Because the constant row can match only one row (or no row). But matching
    rows is the norm, so let’s see a more realistic example by changing the table
    conditions to `id > 3 AND id < 6 AND c = ''Cd''`, as shown in [Figure 2-11](#idx-where-pk-range)
    and the corresponding EXPLAIN plan in [Example 2-4](#ex-idx-where-pk-5).'
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0211](assets/emsp_0211.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11\. `WHERE`: range access using primary key'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-4\. EXPLAIN plan for range access using primary key
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To highlight EXPLAIN plan changes, I prepend `>` characters to the pertinent
    fields that changed. These highlights are not part of `EXPLAIN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By changing the table conditions to `id > 3 AND id < 6 AND c = ''Cd''`, the
    EXPLAIN plan changes from [Example 2-3](#ex-idx-where-pk) to [Example 2-4](#ex-idx-where-pk-5),
    which is more realistic for a single-table query. The query still uses the primary
    key (`key: PRIMARY`), but the access type changes to a *range scan* (`type: range`):
    using an index to read rows between a range of values. In this case, MySQL uses
    the primary key to read rows where the value of column `id` is between 3 and 6.
    The `ref` field is `NULL` because the conditions on column `id` are not constant
    (and this is a single-table query, so there’s no preceding table to reference).
    The condition `c = ''Cd''` is constant, but it’s not used for the index lookup
    (the range scan), so `ref` does not apply. MySQL estimates that it will examine
    two rows in the range (`rows: 2`). That’s correct for this trivial example, but
    remember: `rows` is an estimate.'
  prefs: []
  type: TYPE_NORMAL
- en: '“Using where” in the `Extra` field is so common that it’s expected. It means
    that MySQL will find *matching rows* using the `WHERE` conditions: for each row
    read, a row matches if all `WHERE` conditions are true. Since the conditions on
    column `id` define the range, it’s really just the condition on column `c` that
    MySQL will use to match rows in the range. Glancing back at [Example 2-1](#elem),
    one row matches all the `WHERE` conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The row with `id = 5` is in the range, so MySQL examines the row, but its column
    `c` value (“Cd”) does not match the `WHERE` clause, so MySQL does not return the
    row.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate other query execution plans, let’s use both leftmost prefixes
    of the secondary index, as shown in [Figure 2-12](#idx-where-sec) and the corresponding
    EXPLAIN plans in [Example 2-5](#ex-idx-where-sec).
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0212](assets/emsp_0212.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12\. `WHERE`: secondary index lookups'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-5\. EXPLAIN plans for secondary index lookups
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For each EXPLAIN plan in [Example 2-5](#ex-idx-where-sec), `key: idx_a_b` confirms
    that MySQL uses the secondary index because the conditions meet the leftmost prefix
    requirement. The first `WHERE` clause uses only the first index part: column `a`.
    The second `WHERE` clause uses both index parts: columns `a` and `b`. Using only
    column `b` would not meet the leftmost prefix requirement—I show this in a moment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s new and important from previous EXPLAIN plans is the access type: `ref`.
    In simplest terms, the `ref` access type is an equality (`=` or `<=>`) lookup
    on a leftmost prefix of the index (the `key` field). Like any index lookup, `ref`
    access is very fast as long as the estimated number of rows to examine (the `rows`
    field) is reasonable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the conditions are constant, the `const` access type is not possible
    because the index (`key: idx_a_b`) is nonunique, so the lookup can match more
    than one row. And even though MySQL estimates that each `WHERE` clause will examine
    only one row (`rows: 1`), that could change when the query is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Extra: NULL` occurs again because MySQL can find matching rows using only
    the index since there are no conditions on non-indexed columns—so let’s add one.
    [Figure 2-13](#idx-where-sec-c) shows a `WHERE` clause with conditions on columns
    `a` and `c`, and [Example 2-6](#ex-idx-where-sec-c) is the corresponding EXPLAIN
    plan.'
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0213](assets/emsp_0213.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13\. `WHERE`: index lookup and non-indexed column'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-6\. EXPLAIN plan for index lookup and non-indexed column
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Figure 2-13](#idx-where-sec-c), there is no box around condition `c = ''Co''`
    because the index does not cover column `c`. MySQL still uses the secondary index
    (`key: idx_a_b`), but the condition on column `c` prevents MySQL from matching
    rows using only the index. Instead, MySQL uses the index to look up and read rows
    for the condition on column `a`, then it matches rows for the condition on column
    `c` (`Extra: Using where`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Glancing back at [Example 2-1](#elem) again, you’ll notice that zero rows match
    this `WHERE` clause, but `EXPLAIN` reports `rows: 3`. Why? The index lookup on
    column `a` matches three rows where `a = ''Al''` is true: row `id` values 3, 8,
    and 9\. But none of these rows also matches `c = ''Co''`. The query examines three
    rows but matches zero rows.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`EXPLAIN` output `rows` is an estimate of the number of rows that MySQL will
    examine when it executes the query, not the number of rows that will match all
    table conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: As a final example of indexes, `WHERE`, and `EXPLAIN`, let’s *not* meet the
    leftmost prefix requirement, as shown in [Figure 2-14](#idx-where-sec-b) and [Example 2-7](#ex-idx-where-sec-b).
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0214](assets/emsp_0214.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-14\. `WHERE` without leftmost prefix
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-7\. EXPLAIN plan for `WHERE` without leftmost prefix
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A dotted box outline (and lack of arrow) delineates a table condition and an
    index column that MySQL cannot use because they do not meet the leftmost prefix
    requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 2-14](#idx-where-sec-b), there is no condition on column `a`, therefore
    the index cannot be used for the condition on column `b`. The EXPLAIN plan ([Example 2-7](#ex-idx-where-sec-b))
    confirms this: possible_keys: NULL and `key: NULL`. Without an index, MySQL is
    forced to do a full table scan: `type: ALL`. Likewise, `rows: 10` reflects the
    total number of rows, and `Extra: Using where` reflects that MySQL reads and then
    filters rows not matching `b = ''Be''`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-7](#ex-idx-where-sec-b) is an example of the worst possible EXPLAIN
    plan. Whenever you see `type: ALL`, `possible_keys: NULL`, or `key: NULL`, stop
    what you’re doing and analyze the query.'
  prefs: []
  type: TYPE_NORMAL
- en: As simple as these examples have been, they represent the fundamentals of `EXPLAIN`
    with respect to indexes and `WHERE` clauses. Real queries have more indexes and
    `WHERE` conditions, but the fundamentals don’t change.
  prefs: []
  type: TYPE_NORMAL
- en: GROUP BY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL can use an index to optimize `GROUP BY` because values are implicitly
    grouped by index order. For the secondary index `idx_a_b` (on columns `a, b`),
    there are five distinct groups of column `a` values, as shown in [Example 2-8](#a-col-groups).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Distinct groups of column `a` values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I separated the groups in [Example 2-8](#a-col-groups) with blank lines and
    annotated the first row in each group. A query with `GROUP BY a` can use index
    `idx_a_b` because column `a` is a leftmost prefix and the index is implicitly
    grouped by column `a` values. [Example 2-9](#ex-idx-group-by-a) is a representative
    EXPLAIN plan for the simplest type of `GROUP BY` optimization.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. EXPLAIN plan for `GROUP BY a`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`key: idx_a_b` confirms that MySQL uses the index to optimize the `GROUP BY`.
    Since the index is ordered, MySQL is assured that each new value for column `a`
    is a new group. For example, after reading the last “Ag” value, the index order
    assures that no more “Ag” values will be read, so the “Ag” group is complete.'
  prefs: []
  type: TYPE_NORMAL
- en: “Using index” in the `Extra` field indicates that MySQL is reading column `a`
    values only from the index; it’s not reading full rows from the primary key. I
    cover this optimization in [“Covering Indexes”](#idx-covering-index).
  prefs: []
  type: TYPE_NORMAL
- en: 'This query uses an index, but not for an index lookup: `type: index` denotes
    an index scan (see [“Index scan”](#index-scan)). And since there’s no `WHERE`
    clause to filter rows, MySQL reads all rows. If you add a `WHERE` clause, MySQL
    can still use the index for the `GROUP BY`, but the leftmost prefix requirement
    still applies. In this case, the query is using the leftmost index part (column
    `a`), so the `WHERE` condition must be on column `a` or `b` to meet the leftmost
    prefix requirement. Let’s first add a `WHERE` condition on column `a`, as shown
    in [Figure 2-15](#idx-group-by-a-where) and [Example 2-10](#ex-idx-group-by-a-where).'
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0215](assets/emsp_0215.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-15\. `GROUP BY` and `WHERE` on same index column
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-10\. EXPLAIN plan for `GROUP BY` and `WHERE` on same index column
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '“Using where” in the `Extra` field refers to `WHERE a != ''Ar''`. The interesting
    change is `type: range`. The range access type works with the not-equal operator
    (`!=` or `<>`). You can think of it like `WHERE a < ''Ar'' AND a > ''Ar''`, as
    shown in [Figure 2-16](#idx-order-by-not-ar).'
  prefs: []
  type: TYPE_NORMAL
- en: A condition on column `b` in the `WHERE` clause can still use the index because
    the conditions, regardless of being in different SQL clauses, meet the leftmost
    prefix requirement. [Figure 2-17](#idx-group-by-a-where-b) shows this, and [Example 2-11](#ex-idx-group-by-a-where-b)
    shows the EXPLAIN plan.
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0216](assets/emsp_0216.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-16\. Range for not-equal
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![emsp 0217](assets/emsp_0217.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-17\. `GROUP BY` and `WHERE` on different index columns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-11\. EXPLAIN plan for `GROUP BY` and `WHERE` on different index columns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The query in [Example 2-11](#ex-idx-group-by-a-where-b) has two important details:
    an equality condition on column `b` in the `WHERE` clause, and selecting columns
    `a` and `b` in the `SELECT` clause. These details enable the special “Using index
    for group-by” optimization revealed in the `Extra` field. If, for example, the
    equality (`=`) is changed to not-equal (`!=`), the query optimization is lost.
    When it comes to query optimizations like this, details are critical. You must
    read the MySQL manual to learn and apply the details. [“GROUP BY Optimization”](https://oreil.ly/ZknLf)
    in the MySQL manual elaborates.'
  prefs: []
  type: TYPE_NORMAL
- en: The final `GROUP BY` example in [Figure 2-18](#idx-group-by-b) and [Example 2-12](#ex-idx-group-by-b)
    might surprise you.
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0218](assets/emsp_0218.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-18\. `GROUP BY` without leftmost prefix
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-12\. EXPLAIN plan for `GROUP BY` without leftmost prefix
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice `key: idx_a_b`: MySQL uses the index despite the query having no condition
    on column `a`. What happened to the leftmost prefix requirement? It’s being met
    because MySQL is scanning the index (`type: index`) on column `a`. You can imagine
    a condition on column `a` that’s always true, like `a = a`.'
  prefs: []
  type: TYPE_NORMAL
- en: Would MySQL still index scan on column `a` for `GROUP BY c`? No, it would not;
    it would do a full table scan. [Figure 2-18](#idx-group-by-b) works because the
    index has column `b` values; it does not have column `c` values.
  prefs: []
  type: TYPE_NORMAL
- en: “Using temporary” in the `Extra` field is a side effect of not having a strict
    set of leftmost prefix conditions. As MySQL reads column `a` values from the index,
    it collects column `b` values in a temporary table (in memory). After reading
    all column `a` values, it table scans the temporary table to group and aggregate
    for `COUNT(*)`.
  prefs: []
  type: TYPE_NORMAL
- en: There is a lot more to learn about `GROUP BY` with respect to indexes and query
    optimizations, but these examples are the fundamentals. Unlike `WHERE` clauses,
    `GROUP BY` clauses tend to be simpler. The challenge is creating an index to optimize
    `GROUP BY` plus other SQL clauses. MySQL has the same challenge when formulating
    the query execution plan, so it might not optimize `GROUP BY` even when possible.
    MySQL almost always chooses the best query execution plan, but if you want to
    experiment with different ones, read [“Index Hints”](https://oreil.ly/mbBof) in
    the MySQL manual.
  prefs: []
  type: TYPE_NORMAL
- en: ORDER BY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unsurprisingly, MySQL can use an ordered index to optimize `ORDER BY`. This
    optimization avoids sorting rows, which takes a little more time, by accessing
    rows in order. Without this optimization, MySQL reads all matching rows, sorts
    them, then returns the sorted result set. When MySQL sorts rows, it prints “Using
    filesort” in the `Extra` field of the EXPLAIN plan. *Filesort* means *sort rows*.
    It’s a historical (and now misleading) term but still the prevalent term in MySQL
    lingo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filesort is a consternation for engineers because it has a reputation for being
    slow. Sorting rows is extra work, so it does not improve response time, but it’s
    usually not the root cause of slow response time. At the end of this section,
    I use `EXPLAIN` `ANALYZE`, which is new as of MySQL 8.0.18, to measure the real-time
    penalty of filesort. (Spoiler: sorting rows is very fast.) But first, let’s examine
    how to use indexes to optimize `ORDER BY`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to use an index to optimize `ORDER BY`. The first and
    simplest way is using a leftmost prefix of an index for the `ORDER BY` clause.
    For table `elem`, that means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ORDER BY id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORDER BY a`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORDER BY a, b`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way is to hold a leftmost part of the index constant and order by
    the next index columns. For example, holding column `a` constant and ordering
    by column `b`, as shown in [Figure 2-19](#idx-order-by-b-where-a) with corresponding
    EXPLAIN plan in [Example 2-13](#ex-idx-order-by-b-where-a).
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0219](assets/emsp_0219.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-19\. `ORDER BY` and `WHERE` on different index columns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-13\. EXPLAIN plan for `ORDER BY` and `WHERE` on different index columns
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`WHERE a = ''Ar'' ORDER BY b` can use index `(a, b)` because the `WHERE` condition
    on the first index part (column `a`) is constant, so MySQL jumps to `a = ''Ar''`
    in the index and, from there, reads column `b` values in order. [Example 2-14](#res-idx-order-by-b-where-a)
    is the result set, and although it’s nothing fancy, it shows that column `a` is
    constant (value “Ar”) and column `b` is sorted.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14\. Result set of `WHERE a = 'Ar' ORDER BY b`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If table `elem` had an index on columns `a, b, c`, a query like `WHERE a = 'Au'
    AND b = 'Be' ORDER BY c` could use the index because the conditions on columns
    `a` and `b` hold the leftmost part of the index.
  prefs: []
  type: TYPE_NORMAL
- en: The third way is a special case of the second. Before showing the figure that
    explains it, see if you can determine why the query in [Example 2-15](#ex-idx-order-by-pk)
    does *not* cause a filesort (why “Using filesort” is not reported in the `Extra`
    field).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15\. EXPLAIN plan for `ORDER BY id`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It’s understandable that the query uses index `idx_a_b` because the `WHERE`
    conditions are a leftmost prefix, but shouldn’t `ORDER BY id` cause a filesort?
    [Figure 2-20](#idx-order-by-pk) reveals the answer.
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0220](assets/emsp_0220.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-20\. `ORDER BY` using primary key appended to secondary index
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[“Leftmost Prefix Requirement”](#LPR) has a paragraph that begins with, “Lurking
    at the end (rightmost) of every secondary index is the primary key.” That’s what’s
    happening in [Figure 2-20](#idx-order-by-pk): the dark box around index column
    `id` reveals the “hidden” primary key appended to the secondary index. This `ORDER
    BY` optimization might not seem useful with a little table like `elem`, but with
    real tables it can be very useful—worth remembering.'
  prefs: []
  type: TYPE_NORMAL
- en: To prove that the “hidden” primary key allows the `ORDER BY` to avoid a filesort,
    let’s remove the condition on column `b` to invalidate the optimization, as shown
    in [Figure 2-21](#idx-order-by-pk-not) and followed by the resulting EXPLAIN plan
    in [Example 2-16](#ex-idx-order-by-pk-not).
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0221](assets/emsp_0221.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-21\. `ORDER BY` without leftmost prefix
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 2-16\. EXPLAIN plan for `ORDER BY` without leftmost prefix
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: By removing the condition on column `b`, there’s no longer a leftmost prefix
    on the secondary index that allows MySQL to use the “hidden” primary key to optimize
    `ORDER BY`. Therefore, for this particular query, “Using filesort” appears in
    the `Extra` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new optimization is “Using index condition,” which is called index condition
    pushdown. *Index condition pushdown* means the storage engine uses an index to
    matches rows for `WHERE` conditions. Normally, storage engines only read and write
    rows, and MySQL handles the logic of matching rows. This is a clean separation
    of concerns (which is a virtue for software design), but it’s inefficient when
    rows don’t match: both MySQL and the storage engine waste time reading non-matching
    rows. For the query in [Example 2-16](#ex-idx-order-by-pk-not), index condition
    pushdown means the storage engine (InnoDB) uses index `idx_a_b` to match condition
    `a = ''Al''`. Index condition pushdown helps improve response time, but don’t
    exert yourself trying to optimize for it because MySQL uses it automatically when
    possible. To learn more, read [“Index Condition Pushdown Optimization”](https://oreil.ly/L3Nzm)
    in the MySQL manual.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an important detail that affects all `ORDER BY` optimizations: index
    order is ascending by default, and `ORDER BY col` implies ascending: `ORDER BY
    col ASC`. Optimizing `ORDER BY` works in only one direction for all columns: `ASC`
    (ascending) or `DESC` (descending). Consequently, `ORDER BY a, b DESC` does not
    work because column `a` is an implicit `ASC` sort, which is different than `b
    DESC`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: MySQL 8.0 supports [descending indexes](https://oreil.ly/FDTsN).
  prefs: []
  type: TYPE_NORMAL
- en: What is the real time penalty of filesort? Prior to MySQL 8.0.18, it was neither
    measured nor reported. But as of MySQL 8.0.18, [`EXPLAIN ANALYZE`](https://oreil.ly/DFPiF)
    measures and reports it. For only [Example 2-17](#ex-2-17), I must use a different
    table.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-17\. Sysbench table `sbtest`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s a standard [`sysbench` table](https://oreil.ly/XAYX2); I loaded it with
    one million rows. Let’s use a random, meaningless query with a large result set
    and `ORDER BY`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The query takes 1.15 seconds to sort and return a little over 68,000 rows.
    But it’s not a bad query; check out its EXPLAIN plan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The only new information in that EXPLAIN plan is “Using MRR” in the `Extra`
    field, which refers to the [“Multi-Range Read Optimization”](https://oreil.ly/QX1wJ).
    Otherwise, that EXPLAIN plan reports information already covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Does filesort make this query slow? `EXPLAIN ANALYZE` reveals the answer, albeit
    cryptically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The real output of `EXPLAIN ANALYZE` is wider, but I wrapped and numbered the
    lines for print legibility and reference. `EXPLAIN ANALYZE` output is dense and
    requires practice to grok; for now, let’s go straight to the point—or as straight
    as possible since the output does not read sequentially. On line 4, `1174.981`
    (milliseconds) means the index range scan (line 3) took 1.17 seconds (rounded).
    On line 2, `1221.170..1229.306` means the filesort (line 1) *started* after 1,221
    milliseconds and ended after 1,229 milliseconds, which means the filesort took
    8 milliseconds. Total execution time is 1.23 seconds: 95% reading rows and less
    than 1% sorting rows. The remaining 4%—roughly 49 milliseconds—is spent in other
    stages: preparing, statistics, logging, cleaning up, and so forth.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is no: filesort does *not* make this query slow. The problem is
    data access: 68,439 rows is not a small result set. Sorting 68,439 values is practically
    zero work for a CPU that does *billions* of operations per second. But reading
    68,439 rows is appreciable work for a relational database that must traverse indexes,
    manage transactions, etc. To optimize a query like this, focus on [“Data Access”](ch03.html#data-access).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One last question to address: why does filesort have a reputation for being
    slow? Because MySQL uses temporary files on disk when sorting data exceeds the
    [`sort_buffer_size`](https://oreil.ly/x5mbN), and hard drives are orders of magnitude
    slower than memory. This was especially true decades ago when spinning disks were
    the norm; but today, SSD is the norm, and storage in general is quite fast. Filesort
    might be an issue for a query at high throughput (QPS), but use `EXPLAIN ANALYZE`
    to measure and verify.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`EXPLAIN ANALYZE` executes the query. To be safe, use `EXPLAIN` `ANALYZE` on
    a read-only replica, not the source.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now back to table `elem` ([Example 2-1](#elem)) and the next case for which
    MySQL can use an index: covering indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: Covering Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *covering index* includes all columns referenced in a query. [Figure 2-22](#idx-covering)
    shows a covering index for a `SELECT` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0222](assets/emsp_0222.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-22\. Covering indexes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `WHERE` conditions on columns `a` and `b` point to the corresponding index
    columns as usual, but these index columns also point back to the corresponding
    columns in the `SELECT` clause to signify that the values for these columns are
    read from the index.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, MySQL reads full rows from the primary key (recall [“InnoDB Tables
    Are Indexes”](#tables-are-indexes)). But with a covering index, MySQL can read
    only column values from the index. This is most helpful with secondary indexes
    because it avoids the primary key lookup.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL uses the covering index optimization automtically, and `EXPLAIN` reports
    it as “Using index” in the `Extra` field. “Using index for group-by” is a similar
    optimization specific to `GROUP BY` and `DISTINCT`, as demonstrated in [“GROUP
    BY”](#idx-group-by). But “Using index condition” and “Using index for skip scan”
    are completely different and unrelated optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 'An index scan (`type: index`) plus a covering index (`Extra: Using index`)
    is an index-only scan (see [“Index scan”](#index-scan)). There are two examples
    in [“GROUP BY”](#idx-group-by): [Example 2-9](#ex-idx-group-by-a) and [Example 2-12](#ex-idx-group-by-b).'
  prefs: []
  type: TYPE_NORMAL
- en: Covering indexes are glamorous but rarely practical because realistic queries
    have too many columns, conditions, and clauses for one index to cover. Do not
    spend time trying to create covering indexes. When designing or analyzing simple
    queries that use very few columns, take a moment to see if a covering index might
    work. If it does, then congratulations. If not, that’s okay; no one expects covering
    indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Join Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL uses an index to join tables, and this usage is fundamentally the same
    as using an index for anything else. The main difference is the source of values
    used in join conditions for each table. This becomes more clear when visualized,
    but first we need a second table to join. [Example 2-18](#elem-names-table) shows
    the structure of table `elem_names` and the 14 rows that it contains.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-18\. Table `elem_names`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Table `elem_name` has one index: the primary key on column `symbol`. The values
    in column `symbol` match the values in table `elem` columns `a`, `b`, and `c`.
    Therefore, we can join tables `elem` and `elem_names` on these columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-23](#idx-join-1) shows a `SELECT` statement that joins tables `elem`
    and `elem_names`, and a visual representation of the conditions and indexes for
    each table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous figures, there’s only one index and SQL clause pair because there’s
    only one table. But [Figure 2-23](#idx-join-1) has two pairs—one for each table—delineated
    by large rightward-pointing chevrons with the table name commented in each: `/*
    elem */` and `/* elem_names */`. Like `EXPLAIN`, these figures list tables in
    join order: top to bottom. Table `elem` (at top) is the first table in the join
    order and table `elem_names` (at bottom) is the second table.'
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0223](assets/emsp_0223.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-23\. Join table on primary key lookup
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Index usage on table `elem` is nothing new or special: MySQL uses the index
    for the condition `a IN (`…`)`. So far, so good.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index usage on table `elem_names`, which is joined to the preceding table,
    is fundamentally the same with two minor differences. First, the `WHERE` clause
    is a rewrite of the `JOIN`…`ON` clause—more on this later. Second, values for
    the condition on column `symbol` come from the preceding table: `elem`. To represent
    this, an arrow points from the preceding table to a column reference in angle
    brackets: `<elem.a>`. On join, MySQL looks up rows in table `elem_names` using
    column `a` values from matching rows in table `elem` for the join condition on
    column `symbol`. In MySQL vernacular we’d say, “`symbol` is equal to column `a`
    from table `elem`.” Given a value from the preceding table, the primary key lookup
    on column `symbol` is nothing new or special: if a row matches, it’s returned
    and joined with the row from the preceding table.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-19](#ex-idx-join-1) shows the EXPLAIN plan for the `SELECT` statement
    in [Figure 2-23](#idx-join-1).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-19\. EXPLAIN plan for join table on primary key lookup
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'On a per-table basis, the EXPLAIN plan in [Example 2-19](#ex-idx-join-1) is
    nothing new, but the join reveals two new details in the second table, `elem_names`.
    The first is access type `eq_ref`: a single-row lookup using the primary key or
    a unique not-null secondary index. (In this context, *not-null* means all secondary
    index columns are defined as `NOT NULL`.) More on the `eq_ref` access type in
    the next paragraph. The second is `ref: test.elem.a`, which you can read as “reference
    column `elem.a`”. (The database name is `test`, hence the `test.` prefix.) To
    join table `elem_names`, values from reference column `elem.a` are used to look
    up rows by primary key (`key: PRIMARY`), which covers the join column: `symbol`.
    This corresponds to the `JOIN` condition: `ON (elem.a = elem_names.symbol)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: On a per-table basis, a join does not change how indexes are used. The main
    difference is that values for the join condition come from the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL can join a table using any access method (see [“Table Access Methods”](#table-access-methods)),
    but an index lookup using the `eq_ref` access type is the best and fastest because
    it matches only one row. The `eq_ref` access type has two requirements: a primary
    key or unique not-null secondary index *and* equality conditions on all index
    columns. Together, these requirements guarantee that an `eq_ref` lookup matches
    *at most* one row. If both requirements are not met, then MySQL will probably
    use a `ref` index lookup, which is essentially the same but matches any number
    of rows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to [Figure 2-23](#idx-join-1), how did I know to rewrite the `JOIN`…`ON`
    clause to a `WHERE` clause for table `elem_names`? If you `SHOW WARNINGS` immediately
    after `EXPLAIN`, MySQL prints how it rewrites the query. This is the abridged
    output of `SHOW` `WARNINGS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now you can see that `/* elem_names */ WHERE symbol = <elem.a>` in [Figure 2-23](#idx-join-1)
    is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, running `SHOW WARNINGS` immediately after `EXPLAIN` to see how MySQL
    rewrites a query is necessary to understand the table join order and indexes that
    MySQL chose.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Rewritten SQL statements shown by `SHOW WARNINGS` are not intended to be valid.
    They’re only intended to show how MySQL interprets and rewrites the SQL statement.
    Do not execute them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table join order is critical because MySQL joins tables in the best order possible,
    *not* the order tables are written in the query. You must use `EXPLAIN` to see
    the table join order. `EXPLAIN` prints tables in the join order from top (first
    table) to bottom (last table). The default join algorithm, *nested-loop join*,
    follows the join order. I outline join algorithms at the end of this chapter:
    [“Table Join Algorithms”](#table-join-algos).'
  prefs: []
  type: TYPE_NORMAL
- en: Never guess or presume the table join order because small changes to a query
    can yield a significantly different table join order or query execution plan.
    To demonstrate, the `SELECT` statement in [Figure 2-24](#idx-join-2) is nearly
    identically to the `SELECT` statement in [Figure 2-23](#idx-join-1) with one tiny
    difference—can you spot it?
  prefs: []
  type: TYPE_NORMAL
- en: '![emsp 0224](assets/emsp_0224.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-24\. Join table on secondary index lookup
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here’s a hint: *it’s neither gold nor silver*. The tiny difference yields a
    significantly different query execution plan, as shown in [Example 2-20](#ex-idx-join-2).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-20\. EXPLAIN plan for join table on secondary index lookup
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Syntactically, the `SELECT` statements in Figures [2-23](#idx-join-1) and [2-24](#idx-join-2)
    are identical, but the execution plans (Examples [2-19](#ex-idx-join-1) and [2-20](#ex-idx-join-2))
    are significantly different. What changed? In [Figure 2-24](#idx-join-2), a single
    value was removed from the `IN()` list: “At.” This is a great example of how a
    seemingly innocuous change can trigger something in the MySQL query execution
    planner and voilà: a totally new and different EXPLAIN plan. Let’s examine [Example 2-20](#ex-idx-join-2)
    table by table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first table is `elem_names`, which is different than how the query is written:
    `elem JOIN elem_names`. MySQL determines the table join order, not the `JOIN`
    clause.^([2](ch02.html#idm45829113186976)) The `type` and `key` fields indicate
    a range scan on the primary key, but where are the values coming from? The `ref`
    field is `NULL`, and there are no `WHERE` conditions on this table. MySQL must
    have rewritten the query; this is the abridged output of `SHOW WARNINGS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, there it is on the last line: MySQL rewrites the query to use the `IN()`
    list as the values for `elem_names.symbol`s instead of `elem.a` as originally
    written in the query. Now you can see (or imagine) that index usage on table `elem_names.symbol`s
    is a range scan to look up two values: “Ag” and “Au.” Using the primary key, that
    will be an extremely fast index lookup and match only two rows that MySQL will
    use to join the second table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second table is `elem`, and the EXPLAIN plan is familiar: using index `idx_a_b`
    to look up index values (not rows, because `Extra: Using index`) matching the
    condition on column `a`. The values for that condition come from matching rows
    in the preceding table, as indicated by `ref: test.elem_names.symbol`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: MySQL joins tables in the best order possible, *not* the order that tables are
    written in the query.
  prefs: []
  type: TYPE_NORMAL
- en: Although MySQL can change the join order and rewrite the query, index usage
    for a join is fundamentally the same—on a per-table basis—as everything previously
    demonstrated and explained in this chapter. Use `EXPLAIN` and `SHOW WARNINGS`,
    and consider the execution plan table by table, from top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL can join tables without an index. This is called a *full join* and it’s
    the single worst thing a query can do. A table scan on a single-table query is
    bad, but a full join is worse because the table scan on the joined table does
    not happen once, it happens for every matching row from the preceding table. [Example 2-21](#ex-idx-join-full)
    shows a full join on the second table.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-21\. EXPLAIN plan for full `JOIN`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, MySQL would not choose this query execution plan, which is why I
    had to force it with `STRAIGHT_JOIN` and `IGNORE INDEX (PRIMARY)`. An index-only
    scan on the first table (`elem`) yields all ten rows.^([3](ch02.html#idm45829113052112))
    For each row, MySQL joins the second table (`elem_names`) by doing a full table
    scan (`type: ALL`) to find matching rows. Since this is a joined table (not the
    first table in the join order), the table scan counts as a full join. A full join
    is the single worst thing a query can do because it happens *for each row* from
    the preceding table: ten full table scans on table `elem_names`. Whenever you
    see `type: ALL` for a joined table, stop everything you’re doing and fix it. There’s
    a query metric for full joins: [“Select full join”](ch01.html#Select-full-join).'
  prefs: []
  type: TYPE_NORMAL
- en: '“Using join buffer (hash join)” in the `Extra` field refers to the hash join
    algorithm, which is new as of MySQL 8.0.18. I outline it (and other join algorithms)
    at the end of this chapter: [“Table Join Algorithms”](#table-join-algos). Looking
    ahead, the one-line explanation is: hash join builds an in-memory hash table of
    values and uses that to lookup rows rather than doing repeated table scans. Hash
    join is a huge performance improvement. Regardless, avoiding full joins remains
    the best practice.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Prior to MySQL 8.0, the query in [Example 2-21](#ex-idx-join-full) reports
    “Using join buffer (Block Nested Loop)” in the `Extra` field because it uses a
    different join algorithm: block nested-loop. [“Table Join Algorithms”](#table-join-algos)
    outlines this join algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, joining tables appears to be a categorically different type
    of index usage, but it’s not. A join involves more tables and indexes, but on
    a per-table basis, index usage and requirements are the same. Even the leftmost
    prefix requirement is the same. The main difference is that, for joined tables,
    values for join conditions come from the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: It’s been a long read since the first example in [“WHERE”](#idx-where). Now
    you’ve seen many full-context examples of indexes, queries, and EXPLAIN plans
    that cover the technical details and mechanics of MySQL indexes. This information
    is the foundation of direct query optimization on which the next section builds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Indexing: How to Think Like MySQL'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Indexes and indexing are different topics. The previous section introduced
    indexes: standard B-tree indexes on InnoDB tables for `WHERE`, `GROUP BY`, `ORDER
    BY`, covering indexes, and table joins. This section introduces *indexing*: applying
    indexes for maximum leverage. You cannot simply index every column to effect amazing
    performance. If it were that easy, there would be no DBAs. For maximum leverage,
    you have to index the columns that allow MySQL to access the least number of rows
    when executing a query. To state it metaphorically: maximum leverage is an index
    that tells MySQL exactly where to find the needle in the haystack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In my experience, engineers struggle with indexing because they conflate how
    they think about a query with how MySQL “thinks” about a query. As engineers,
    we think about a query in the context of the application: what part of the application
    executes the query, why (the business logic), and the correct result set. But
    MySQL does not know or care about any of that. MySQL thinks about a much smaller,
    simpler context: indexes and table conditions. Under the hood, MySQL is considerably
    more complex, but part of its indeterminable charm is how well it hides that complexity.'
  prefs: []
  type: TYPE_NORMAL
- en: How do we know that MySQL thinks about indexes and table conditions? `EXPLAIN`.
    And what is the primary information that `EXPLAIN` reports? Tables (in join order),
    table access methods, indexes, and `Extra` information related to the access of
    those tables with those indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Thinking like MySQL make indexing easier because it’s a deterministic machine—algorithms
    and heuristics. Human thought is entangled with superfluous details. Clear your
    mind and get ready to think like a machine. The next four sections walk through
    a simple, four-step process.
  prefs: []
  type: TYPE_NORMAL
- en: Know the Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step toward thinking like MySQL is to know basic information about
    the query that you’re optimizing. Start by gathering the following metadata for
    each table:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SHOW CREATE TABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW TABLE STATUS`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW INDEXES`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the query is already running in production, then get its query report (see
    [“Query report”](ch01.html#query-report)) and familiarize yourself with the current
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Query
  prefs: []
  type: TYPE_NORMAL
- en: How many rows should the query access?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many rows should the query return?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which columns are selected (returned)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the `GROUP BY`, `ORDER BY,` and `LIMIT` clauses (if any)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there subqueries? (If yes, repeat the process for each.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table access (per-table)
  prefs: []
  type: TYPE_NORMAL
- en: What are the table conditions?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which index should the query use?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What other indexes could the query use?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the cardinality of each index?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How large is the table—data size and row count?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those questions help you mentally parse the query because that’s what MySQL
    does: parse the query. This is especially helpful for seeing complex queries in
    simpler terms: tables, table conditions, indexes, and SQL clauses.'
  prefs: []
  type: TYPE_NORMAL
- en: This information helps you piece together a puzzle that, once complete, reveals
    query response time. To improve response time, you’ll need to change some pieces.
    But before doing that, the next step is to assemble the current pieces with the
    help of `EXPLAIN`.
  prefs: []
  type: TYPE_NORMAL
- en: Understand with EXPLAIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The second step is to understand the current query execution plan reported
    by `EXPLAIN`. Consider each table and its conditions with respect to its indexes,
    starting with the index that MySQL chose: the `key` field in the `EXPLAIN` output.
    Look at the table conditions to see how they meet the leftmost prefix requirement
    for this index. If the `possible_keys` field lists other indexes, think about
    how MySQL would access rows using those indexes—always with the leftmost prefix
    requirement in mind. If the `Extra` field has information (it usually does), then
    refer to [“EXPLAIN Output”](https://oreil.ly/GDF0g) in the MySQL manual to learn
    what it means.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Always `EXPLAIN` the query. Make this a habit because direct query optimization
    is not possible without `EXPLAIN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The query and its response time are a puzzle, but you have all the pieces:
    execution plan, table conditions, table structures, table sizes, index cardinalities,
    and query metrics. Keep connecting the pieces until the puzzle is complete—until
    you can see the query working as MySQL explains it. There is always a reason for
    the query execution plan.^([4](ch02.html#idm45829112993152)) Sometimes MySQL is
    very clever and uses a nonobvious query optimization, usually mentioned in the
    `Extra` field. If you encounter one for a `SELECT` statement, [“Optimizing SELECT
    Statements”](https://oreil.ly/Bl4Ja) in the MySQL manual will elucidate it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get stuck, there are three increasing levels of support:'
  prefs: []
  type: TYPE_NORMAL
- en: As of MySQL 8.0.16, `EXPLAIN FORMAT=TREE` prints a more precise and descriptive
    query execution plan in tree-like output. It’s a completely different output than
    the traditional format, so you’ll need to learn how to interpret it, but it’s
    worth the effort.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use [optimizer tracing](https://oreil.ly/Ump3C) to report an extremely detailed
    query execution plan with costs, considerations, and reasons. This is a very advanced
    feature with a high learning curve, so if you’re pressed for time, you might prefer
    the third option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ask your DBA or hire an expert.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optimize the Query
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The third step is direct query optimization: change the query, its indexes,
    or both. This is where all the fun happens, and there’s no risk yet because these
    changes are made in development or staging, *not* production. Be certain that
    your development or staging environment has data that is representative of production
    because data size and distribution affect how MySQL chooses indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: At first, it might seem like the query cannot be modified because it fetches
    the correct rows, so the query is written correctly. A query “is what it is,”
    right? Not always; the same *result* can be achieved with different *methods*.
    A query has a result—literally, a result set—and a method of obtaining that result.
    These two are closely related but independent. Knowing that is tremendously helpful
    when considering how to modify a query. Start by clarifying the intended result
    of the query. A clear result allows you to explore new ways of writing the query
    that achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There can be multiple ways to write a query that execute differently but return
    the same result.
  prefs: []
  type: TYPE_NORMAL
- en: For example, some time ago I was helping an engineer optimize a slow query.
    His question to me was technical—something about `GROUP BY` and indexes—but I
    asked him, “What does the query *do*? What’s it supposed to return?” He said,
    “Oh! It returns the maximum value for a group.” After clarifying the intended
    result of the query, I realized that he didn’t need the maximum group value, he
    simply needed the maximum value. Consequently, the query was completely rewritten
    to use the `ORDER BY col DESC LIMIT 1` optimization.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a query is extremely simple, like `SELECT col FROM tbl WHERE id = 1`,
    there might truly be no way to rewrite it. But the simpler the query, the less
    likely it needs to be rewritten. If a simple query is slow, the solution is likely
    a change to indexes rather than the query. (And if index changes don’t solve the
    problem, then the journey continues: *indirect* query optimization, addressed
    in Chapters [3](ch03.html#ch03) and [4](ch04.html#ch04).)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding or modifying a index is a trade-off between access methods and query-specific
    optimizations. For example, do you trade an `ORDER BY` optimization for a range
    scan? Don’t get stuck trying to weigh the trade-offs; MySQL does that for you.^([5](ch02.html#idm45829112967856))
    Your job is simple: add or alter an index that you think will provide MySQL greater
    leverage, then use `EXPLAIN` to see if MySQL agrees by using the new index. Repeat
    until you and MySQL agree on the most optimized way to write, index, and execute
    the query.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Do not modify indexes in production until you have thoroughly verified the changes
    in staging.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy and Verify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last step is to deploy the changes and verify that they improve response
    time. But first: know how to roll back the deployment—and be ready to do so—in
    case the changes have unintended side effects. This happens for many reasons;
    two examples are: queries running in production that use the index but were not
    running in staging, or production data that is significantly different than staging
    data. It’s most likely going to be fine, but be prepared for *not fine*.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Always know how to—and be ready to—roll back a deployment to production.
  prefs: []
  type: TYPE_NORMAL
- en: After deploying, verify the changes with query metrics and MySQL server metrics.
    If the query optimization has significant impact, MySQL server metrics will reflect
    it. ([Chapter 6](ch06.html#ch06) elaborates on MySQL server metrics.) It’s awesome
    when this happens, but don’t be surprised or discouraged if it doesn’t because
    the most important change is query response time—recall [“North Star”](ch01.html#north-star).
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait five to ten minutes (preferably longer), then check response time in the
    query profile and query report. (See [“Query profile”](ch01.html#query-profile)
    and [“Query report”](ch01.html#query-report).) If response time improved, then
    congratulations: you are doing and accomplishing what MySQL experts do; with this
    skill, you can achieve remarkable MySQL performance. If response time did not
    improve, don’t worry and don’t give up: even MySQL experts encounter queries that
    require elbow grease. Repeat the process, and consider enlisting another engineer
    because some queries require heavy lifting. If you’re certain the query cannot
    be further optimized, then it’s time for the second part of the journey: indirect
    query optimization. [Chapter 3](ch03.html#ch03) addresses changes to data, and
    [Chapter 4](ch04.html#ch04) addresses changes to the application.'
  prefs: []
  type: TYPE_NORMAL
- en: It Was a Good Index Until…
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If *nothing* changes, a good index will stay a good index until the end of time.
    (But if truly nothing changes, would time ever end?) Realistically, something
    will change, render a good index bad, and decrease performance. Following are
    common causes of this regrettable (but avoidable and correctable) decline.
  prefs: []
  type: TYPE_NORMAL
- en: Queries Changed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When queries change—and they often do—the leftmost prefix requirement can be
    lost. The worst case is when there are no other indexes that MySQL can use, so
    it reverts to brute force: a full table scan. But tables often have many indexes,
    and MySQL is determined to use an index, so the more likely case is that query
    response time becomes noticeably poor because the other indexes aren’t as good
    as the original index. A query analysis and EXPLAIN plan quickly reveal this case.
    Presuming the query changes were necessary, which is a safe presumption, the solution
    is to re-index for the new variation of the query.'
  prefs: []
  type: TYPE_NORMAL
- en: Excessive, Duplicate, and Unused
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Indexes are necessary for performance, but sometimes engineers go overboard
    with them, which results in too many indexes, duplicate indexes (*dupes*), and
    unused indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'How many indexes is too many? One more than is necessary. An overabundance
    of indexes creates two problems. The first was mentioned in [“Leftmost Prefix
    Requirement”](#LPR): increased index size. More indexes use more RAM which, ironically,
    decreases the RAM available for each index. The second problem is a decrease in
    write performance because, when MySQL writes data, it must check, update, and
    potentially reorganize (the internal B-tree structure of) every index. An inordinate
    number of indexes can severely degrade write performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a duplicate index, the `ALTER` statement used to create it
    generates a warning, but you have to `SHOW WARNINGS` to see it. To find existing
    duplicate indexes, use [pt-duplicate-key-checker](https://oreil.ly/avm4L): it
    safely finds and reports duplicate indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unused indexes are even trickier to identify because, for example, what if
    the index is only used once a week by a long-running analytics query? That edge
    case aside, execute this query to list unused indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That query uses the [MySQL sys Schema](https://oreil.ly/xxsL3), which is a collection
    of ready-made views that return all sorts of information. The view `sys.schema_unused_indexes`
    queries Performance Schema and Information Schema tables to determine which indexes
    have not been used since MySQL started. (Execute `SHOW CREATE VIEW sys.schema_unused_indexes`
    to see how this view works.) The Performance Schema must be enabled; if it is
    not already enabled, talk with your DBA (or whoever manages MySQL) because enabling
    it requires restarting MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful when dropping an index. As of MySQL 8.0, use [invisible indexes](https://oreil.ly/Wx1xT)
    to verify that an index is not used or needed before dropping it: make the index
    invisible, wait and verify that performance is not affected, then drop the index.
    Invisible indexes are fantastic for this purpose because, when a mistake is made,
    making an index visible is nearly instantaneous, whereas re-adding an index can
    take minutes (or hours) on large tables, which feels like an eternity if the mistake
    causes an application outage. Before MySQL 8.0, caution is the only solution:
    talk with your team, search the application code, and use your knowledge of the
    application to carefully and thoroughly verify that the index is not used or needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be careful when dropping (removing) indexes. If a dropped index was used by
    a query and MySQL cannot use another index, the query will revert to a full table
    scan. If a dropped index affects several queries, which is not uncommon, it can
    cause a ripple effect of performance degradation that leads to an application
    outage.
  prefs: []
  type: TYPE_NORMAL
- en: Extreme Selectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Cardinality* is the number of unique values in an index. An index on values
    `a, a, b, b` has a cardinality of 2: `a` and `b` are the two unique values. Use
    [`SHOW INDEX`](https://oreil.ly/8hiGi) to see index cardinality.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Selectivity* is cardinality divided by the number of rows in the table. Using
    the same example, `a, a, b, b`, where each value is one row, the index selectivity
    is 2 / 4 = 0.5\. Selectivity ranges from 0 to 1, where 1 is a unique index: a
    value for every row. MySQL doesn’t show index selectivity; you have to calculate
    it manually using `SHOW INDEX` for cardinality and `SHOW TABLE STATUS` for the
    number of rows.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An index with extremely low selectivity provides little leverage because each
    unique value could match a large number of rows. A classic example is an index
    on a column with only two possible values: yes or no, true or false, coffee or
    tea, on so on. If the table has 100,000 rows, then selectivity is practically
    zero: 2 / 100,000 = 0.00002\. It’s an index, but not a good one because each value
    could match many rows. How many? Flip the division: 100,000 rows / 2 unique values
    = 50,000 rows per value. If MySQL were to use this index (which is unlikely),
    a single index lookup could match 50,000 rows. That presumes values are evenly
    distributed, but what if 99,999 rows have value `coffee` and only 1 row has value
    `tea`? Then the index works great for tea but terribly for coffee.'
  prefs: []
  type: TYPE_NORMAL
- en: If a query uses an index with extremely low selectivity, see if you can create
    a better, more selective index; or, consider rewriting the query to use a more
    selective index; or, think about altering the schema to organize the data better
    with respect to access patterns—more on this in [Chapter 4](ch04.html#ch04).
  prefs: []
  type: TYPE_NORMAL
- en: An index with extremely high selectivity might be over-leveraged. As the selectivity
    of a nonunique secondary index approaches 1, it begins to raise the question of
    whether or not the index should be unique or—even better—if the query can be rewritten
    to use the primary key. Such an index doesn’t hurt performance, but it’s worth
    exploring alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are many secondary indexes with extremely high selectivity, it likely
    indicates access patterns that view or search the whole table by different criteria
    or dimensions (presuming the indexes are used and not duplicates). For example:
    imagine a table with product inventory that the application searches by many different
    criteria, each requiring an index to meet the leftmost prefix requirement. In
    this case, [Elasticsearch](https://www.elastic.co) might serve the access patterns
    better than MySQL.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a Trap! (When MySQL Chooses Another Index)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In very rare cases, MySQL chooses the wrong index. This is rare enough that
    it should be your last suspicion if MySQL is using an index but query response
    time is inexplicably slow. There are several reasons this can occur. A common
    reason is that, when updating a large number of rows, the number is just shy of
    triggering an automatic update of the index “stats.” Since index statistics are
    one of many factors that influence which index MySQL chooses, index statistics
    that have diverged significantly from reality can cause MySQL to choose the wrong
    index. To be clear: the index itself is never inaccurate; it’s only the index
    *statistics* that are inaccurate.'
  prefs: []
  type: TYPE_NORMAL
- en: Index statistics are estimates about how values are distributed in the index.
    MySQL does random dives into the index to sample pages. (A *page* is a 16 KB unit
    of logical storage. Almost everything is stored in pages.) If index values are
    evenly distributed, then a few random dives accurately represent the whole index.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL updates index statistics for a table when:'
  prefs: []
  type: TYPE_NORMAL
- en: The table is first opened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ANALYZE TABLE` is run'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1/16th of the table has been modified since the last update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`innodb_stats_on_metadata` is enabled and one of the following occurs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SHOW INDEX` or `SHOW TABLE STATUS` is run'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFORMATION_SCHEMA.TABLES` or `INFORMATION_SCHEMA.STATISTICS` is queried'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running `ANALYZE TABLE` is safe and usually very fast, but be careful on a
    busy server: it requires a flush lock (except in Percona Server) that can block
    all queries accessing the table.'
  prefs: []
  type: TYPE_NORMAL
- en: Table Join Algorithms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A brief overview of MySQL table join algorithms helps you think about indexes
    and indexing when analyzing and optimizing `JOIN`. The default table join algorithm
    is called *nested-loop join* (NLJ), and it operates like nested `foreach` loops
    in code. For example, suppose that a query joins three tables with a `JOIN` clause
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: And suppose that `EXPLAIN` reports the join order as `t1`, `t2`, and `t3`. The
    nested-loop join algorithm works like the pseudocode in [Example 2-22](#NLJ).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-22\. NLJ algorithm
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the NLJ algorithm, MySQL begins by using `some_index` to find matching
    rows in the outermost table: `t1`. For each matching row in table `t1`, MySQL
    joins table `t2` by using an index on the join column, `index_on_B`, to lookup
    rows matching `t1.A`. For each matching row in table `t2`, MySQL joins table `t3`
    using the same process, but—just for fun—let’s say there’s no index on the join
    column, `t3.C`: the result is a full join. (Recall [“Select full join”](ch01.html#Select-full-join)
    and [Example 2-21](#ex-idx-join-full).)'
  prefs: []
  type: TYPE_NORMAL
- en: When no more rows in `t3` match the join column value from table `t2`, the next
    matching row from `t2` is used. When no more rows in `t2` match the join column
    value from table `t1`, the next matching row from `t1` is used. When no more rows
    in `t1` match, the query completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nested-loop join algorithm is simple and effective, but there’s one problem:
    the innermost table is accessed very frequently, and the full join makes that
    access very slow. In this example, table `t3` is accessed for every matching row
    in `t1` multiplied by every matching row in `t2`. If both `t1` and `t2` have 10
    matching rows, then `t3` is accessed 100 times. The *block nested-loop* join algorithm
    addresses this problem. Join column values from matching rows in `t1` and `t2`
    are saved in a *join buffer*. (The join buffer size is set by system variable
    [`join_buffer_size`](https://oreil.ly/r1NeH).) When the join buffer is full, MySQL
    scans `t3` and joins each `t3` row that matches join column values in the join
    buffer. Although the join buffer is accessed many times (for each `t3` row), it’s
    fast because it’s in memory—significantly faster than 100 table scans required
    for the NLJ algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: As of MySQL 8.0.20, the hash join algorithm replaces the block nested-loop join
    algorithm.^([6](ch02.html#idm45829112777456)) *Hash join* creates an in-memory
    hash table of join tables, like table `t3` in this example. MySQL uses the hash
    table to look up rows in the join table, which is extremely fast because a hash
    table lookup is a constant time operation. For details, read [“Hash Join Optimization”](https://oreil.ly/uS0s3)
    in the MySQL manual.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`EXPLAIN` indicates a hash join by printing “Using join buffer (hash join)”
    in the `Extra` field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are more details and nuances to MySQL joins, but this brief overview
    helps you to think about joins like MySQL: one table at a time and one index per
    table.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter taught indexes and indexing with MySQL. The key takeaway points
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: Indexes provide the most and the best leverage for MySQL performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not scale up hardware to improve performance until exhausting other options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning MySQL is not necessary to improve performance with a reasonable configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An InnoDB table is a B-tree index organized by the primary key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL accesses a table by index lookup, index scan, or full table scan—index
    lookup is the best access method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use an index, a query must use a leftmost prefix of the index—the *leftmost
    prefix requirement*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL uses an index to find rows matching `WHERE`, group rows for `GROUP BY`,
    sort rows for `ORDER BY`, avoid reading rows (covering index), and join tables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPLAIN` prints a *query execution plan* (or *EXPLAIN plan*) that details
    how MySQL executes a query.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Indexing requires thinking like MySQL to understand the query execution plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good indexes can lose effectiveness for a variety of reasons.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'MySQL uses three algorithms to join tables: NLJ, block nested-loop, and hash
    join.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next chapter begins to address indirect query optimization with respect
    to data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Practice: Find Duplicate Indexes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The goal of this practice is to identify duplicate indexes using [pt-duplicate-key-checker](https://oreil.ly/Oxvjr):
    a command-line tool that prints duplicate indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The practice is simple but useful: download and run `pt-duplicate-key-checker`.
    By default, it checks all tables and prints a report for each duplicate index,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'For each index and its duplicate, the report includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A reason: why one index duplicates the other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both index definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Column definitions that the indexes cover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `ALTER TABLE` statement to drop the duplicate index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pt-duplicate-key-checker is mature and well tested, but always think carefully
    before dropping an index—especially in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like [“Practice: Identify Slow Queries”](ch01.html#ch01-ai), this practice
    is simple—but you would be surprised how many engineers never check for duplicate
    indexes. Checking for and removing duplicate indexes is practicing MySQL performance
    like an expert.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch02.html#idm45829114802704-marker)) Unless you’re Vadim Tkachenko, in
    which case: please keep tuning.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.html#idm45829113186976-marker)) Unless `STRAIGHT_JOIN` is used, but
    don’t use this. Let the MySQL query optimizer choose the join order for the best
    query execution plan.
  prefs: []
  type: TYPE_NORMAL
- en: '^([3](ch02.html#idm45829113052112-marker)) Strictly speaking, the index-only
    scan on table `elem` yields ten values, not rows, because full rows are not needed:
    only column `a` values are needed.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.html#idm45829112993152-marker)) Extremely rare query optimizer bugs
    notwithstanding.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.html#idm45829112967856-marker)) Try to outsmart MySQL if you’re bored,
    but don’t expect to win. It has seen attack ships on fire off the shoulder of
    Orion. It watched C-beams glitter in the dark near the Tannhäuser Gate.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch02.html#idm45829112777456-marker)) Hash join exists as of MySQL 8.0.18
    but replaces block nested-loop as of MySQL 8.0.20.
  prefs: []
  type: TYPE_NORMAL
