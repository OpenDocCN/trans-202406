- en: Chapter 10\. Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A big selling point of Kubernetes is its scalability and replication. To support
    those features, Kubernetes offers the Deployment primitive. In this chapter we’ll
    show the creation of a Deployment scaled to multiple replicas, how to roll out
    a revision of your application, how to roll back to a previous revision, and how
    to use auto-scalers to handle scaling concerns automatically based on the current
    workload.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primitive for running an application in a container is the Pod. Using a
    single instance of a Pod to operate an application has its flaws—it represents
    a single point of failure because all traffic targeting the application is funneled
    to this Pod. This behavior is specifically problematic when the load increases
    due to higher demand (e.g., during peak shopping season for an e-commerce application
    or when an increasing number of microservices communicate with a centralized microservice
    functionality, e.g. an authentication provider).
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of running an application in a Pod is failure tolerance.
    The scheduler cluster component will not reschedule a Pod in the case of a node
    failure, which can lead to a system outage for end users. In this chapter, we’ll
    talk about the Kubernetes mechanics that support application scalability and failure
    tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: A *ReplicaSet* is a Kubernetes API resource that controls multiple, identical
    instances of a Pod running the application, so-called replicas. It has the capability
    of scaling the number of replicas up or down on demand. Moreover, it knows how
    to roll out a new version of the application across all replicas.
  prefs: []
  type: TYPE_NORMAL
- en: A *Deployment* abstracts the functionality of ReplicaSet and manages it internally.
    In practice, this means you do not have to create, modify, or delete ReplicaSet
    objects yourself. The Deployment keeps a history of application versions and can
    roll back to an older version to counteract a blocking or potentially costly production
    issue. Furthermore, it offers the capability of scaling the number of replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-1](#deployment_replicaset) illustrates the relationship between
    a Deployment, a ReplicaSet, and its controlled replicas.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1001](Images/ckd2_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Relationship between a Deployment and a ReplicaSet
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following sections explain how to manage Deployments, including scaling
    and rollout features.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can create a Deployment using the imperative command `create deployment`.
    The command offers a range of options, some of which are mandatory. At a minimum,
    you need to provide the name of the Deployment and the container image. The Deployment
    passes this information to the ReplicaSet, which uses it to manage the replicas.
    The default number of replicas created is 1; however, you can define a higher
    number of replicas using the option `--replicas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s observe the command in action. The following command creates the Deployment
    named `app-cache`, which runs the object cache [Memcached](https://memcached.org)
    inside the container on four replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The mapping between the Deployment and the replicas it controls happens through
    label selection. When you run the imperative command, `kubectl` sets up the mapping
    for you. [Example 10-1](#yaml_manifest_deployment) shows the label selection in
    the YAML manifest. This YAML manifest can be used to create a Deployment declaratively
    or by inspecting the live object created by the previous imperative command.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-1\. A YAML manifest for a Deployment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When created by the imperative command, `app` is the label key the Deployment
    uses by default. You can find this key in three different places in the YAML output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`metadata.labels`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spec.selector.matchLabels`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`spec.template.metadata.labels`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For label selection to work properly, the assignment of `spec.selector.matchLabels`
    and `spec.template.metadata` needs to match, as shown in [Figure 10-2](#deployment_label_selection).
  prefs: []
  type: TYPE_NORMAL
- en: 'The values of `metadata.labels` is irrelevant for mapping the Deployment to
    the Pod template. As you can see in the figure, the label assignment to `metadata.labels`
    has been changed deliberately to `deploy: app-cache` to underline that it is not
    important for the Deployment to Pod template selection.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1002](Images/ckd2_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Deployment label selection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Listing Deployments and Their Pods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can inspect a Deployment after its creation by using the `get deployments`
    command. The output of the command renders the important details of its replicas,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The column titles relevant to the replicas controlled by the Deployment are
    shown in [Table 10-1](#runtime_replica_information).
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1\. Runtime replica information when listing deployments
  prefs: []
  type: TYPE_NORMAL
- en: '| Column Title | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| READY | Lists the number of replicas available to end users in the format
    of <ready>/<desired>. The number of desired replicas corresponds to the value
    of `spec.replicas`. |'
  prefs: []
  type: TYPE_TB
- en: '| UP-TO-DATE | Lists the number of replicas that have been updated to achieve
    the desired state. |'
  prefs: []
  type: TYPE_TB
- en: '| AVAILABLE | Lists the number of replicas available to end users. |'
  prefs: []
  type: TYPE_TB
- en: 'You can identify the Pods controlled by the Deployment by their naming prefix.
    In the case of the previously created Deployment, the Pods’ names start with `app-cache-`.
    The hash following the prefix is autogenerated and appended to the name upon creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Rendering Deployment Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can render the details of a Deployment. Those details include the label
    selection criteria, which can be extremely valuable when troubleshooting a misconfigured
    Deployment. The following output provides the full gist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that the output contains a reference to a ReplicaSet.
    The purpose of a ReplicaSet is to *replicate* a set of identical Pods. You do
    not need to deeply understand the core functionality of a ReplicaSet for the exam.
    Just be aware that the Deployment automatically creates the ReplicaSet and uses
    the Deployment’s name as a prefix for the ReplicaSet, similar to the Pods it controls.
    In the case of the previous Deployment named `app-cache`, the name of the ReplicaSet
    is `app-⁠cache-596bc5586d`.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Deployment takes full charge of the creation and deletion of the objects
    it controls: Pods and ReplicaSets. When you delete a Deployment, the corresponding
    objects are deleted as well. Say you are dealing with the following set of objects
    shown in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the `delete deployment` command for a cascading deletion of its managed
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Performing Rolling Updates and Rollbacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Deployment fully abstracts rollout and rollback capabilities by delegating
    this responsibility to the ReplicaSet(s) it manages. Once a user changes the definition
    of the Pod template in a Deployment, it will create a new ReplicaSet that applies
    the changes to the replicas it controls and then shut down the previous ReplicaSet.
    In this section, we’ll talk about both scenarios: deploying a new version of an
    application and reverting to an old version of an application.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating a Deployment’s Pod Template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can choose from a range of options to update the definition of replicas
    controlled by a Deployment. Any of those options is valid, but they vary in ease
    of use and operational environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In real-world projects, you should check your manifest files into version control.
    Changes to the definition would then be made by directly editing the file. The
    `kubectl apply` can update a live object by pointing to the changed manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kubectl edit` command lets you change the Pod template interactively by
    modifying the live object’s manifest in an editor. To edit the Deployment live
    object named `web-server`, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The imperative `kubectl set image` command changes only the container image
    assigned to a Pod template by selecting the name of the container. For example,
    you could use his command to assign the image `nginx:1.25.2` to the container
    named `nginx` in the Deployment `web-server`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `kubectl replace` command lets you replace the existing Deployment with
    a new definition that contains your change to the manifest. The optional `--force`
    flag first deletes the existing object and then creates it from scratch. The following
    command assumes that you changed the container image assignment in `deployment.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The command `kubectl patch` requires you to provide the merges as a patch to
    update a Deployment. The following command shows the operation in action. Here,
    you are sending the changes to be made in the form of a JSON structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Rolling Out a New Revision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Deployments make it easy to roll out a new version of the application to all
    replicas it controls. Say you want to upgrade the version of Memcached from 1.6.8
    to 1.6.10 to benefit from the latest features and bug fixes. All you need to do
    is change the desired state of the object by updating the Pod template. The Deployment
    updates all replicas to the new version one by one. This process is called the
    *rolling update* strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command `set image` offers a quick, convenient way to change the image
    of a Deployment, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the current status of a rollout that’s in progress using the
    command `rollout status`. The output indicates the number of replicas that have
    already been updated since emitting the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubernetes keeps track of the changes you make to a Deployment over time in
    the rollout history. Every change is represented by a *revision*. When changing
    the Pod template of a Deployment—for example, by updating the image—the Deployment
    triggers the creation of a new ReplicaSet. The Deployment will gradually migrate
    the Pods from the old ReplicaSet to the new one. You can check the rollout history
    by running the following command. You will see two revisions listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first revision was recorded for the original state of the Deployment when
    you created the object. The second revision was added for changing the image tag.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, a Deployment persists for a maximum of 10 revisions in its history.
    You can change the limit by assigning a different value to `spec.revisionHistoryLimit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a more detailed view of the revision, run the following command. You
    can see that the image uses the value `memcached:1.6.10`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The rolling update strategy ensures that the application is always available
    to end users. This approach implies that two versions of the same application
    are available during the update process. As an application developer, you have
    to be aware that convenience doesn’t come without potential side effects. If you
    happen to introduce a breaking change to the public API of your application, you
    might temporarily break consumers, as they could hit revision 1 or 2 of the application.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the default update strategy of a Deployment by providing a different
    value to the attribute `spec.strategy.type`; however, consider the trade-offs.
    For example, the value `Recreate` kills all Pods first, then creates new Pods
    with the latest revision, causing potential downtime for consumers. See [Chapter 11](ch11.xhtml#deployment_strategies)
    for a more detailed description of common deployment strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Change Cause for a Revision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rollout history renders the column `CHANGE-CAUSE`. You can populate the
    information for a revision to document *why* you introduced a new change or *which*
    `kubectl` command you use to make the change.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, changing the Pod template does not automatically record a change
    cause. To add a change cause to the current revision, add an annotation with the
    reserved key `kubernetes.io/change-cause` to the Deployment object. The following
    imperative `annotate` command assigns the change cause “Image updated to 1.6.10”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The rollout history now renders the change cause value for the current revision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Rolling Back to a Previous Revision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Problems can arise in production that require swift action. For example, the
    container image you just rolled out contains a crucial bug. Kubernetes gives you
    the option to roll back to one of the previous revisions in the rollout history.
    You can achieve this by using the `rollout undo` command. To pick a specific revision,
    provide the command-line option `--to-revision`. The command rolls back to the
    previous revision if you do not provide the option. Here, we are rolling back
    to revision 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As a result, Kubernetes performs a rolling update to all replicas with the revision
    1.
  prefs: []
  type: TYPE_NORMAL
- en: Rollbacks and persistent data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `rollout undo` command does not restore any persistent data associated with
    applications. Rather, it simply restores to a new instance of the previous declared
    state of the ReplicaSet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rollout history now lists revision 3\. Given that we rolled back to revision
    1, there’s no more need to keep that entry as a duplicate. Kubernetes simply turns
    revision 1 into 3 and removes 1 from the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Scaling Workloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scalability is one of Kubernetes’ built-in capabilities. We’ll learn how to
    manually scale the number of replicas as a reaction to increased application load.
    Furthermore, we’ll talk about the API resource Horizontal Pod Autoscaler, which
    allows you to automatically scale the managed set of Pods based on resource thresholds
    such as CPU and memory.
  prefs: []
  type: TYPE_NORMAL
- en: Manually Scaling a Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scaling (up or down) the number of replicas controlled by a Deployment is a
    straightforward process. You can either manually edit the live object using the
    `edit deployment` command and change the value of the attribute `spec.replicas`,
    or you can use the imperative `scale deployment` command. In real-world production
    environments, you want to edit the Deployment YAML manifest, check it into version
    control, and apply the changes. The following command increases the number of
    replicas from four to six:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can observe the creation of replicas in real time using the `-w` command
    line flag. You’ll see a change of status for the newly created Pods turning from
    `ContainerCreat⁠ing` to `Running`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Manually scaling the number of replicas takes a bit of guesswork. You will still
    have to monitor the load on your system to see if your number of replicas is sufficient
    to handle the incoming traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling a Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to scale a Deployment is with the help of a Horizontal Pod Autoscaler
    (HPA). The HPA is an API primitive that defines rules for automatically scaling
    the number of replicas under certain conditions. Common scaling conditions include
    a target value, an average value, or an average utilization of a specific metric
    (e.g., for CPU and/or memory). Refer to the [MetricTarget API](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#metrictarget-v2-autoscaling)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say you want to define average CPU utilization of CPU as the scaling condition.
    At runtime, the HPA checks the metrics collected by the [metrics server](https://oreil.ly/Lmamb)
    to determine if the average maximum CPU or memory usage across all replicas of
    a Deployment is less than or greater than the defined threshold. Make sure that
    you have the metrics server installed in the cluster. Collecting metrics may take
    a couple of minutes initially after installing the component. See [“Inspecting
    Resource Metrics”](ch15.xhtml#metrics_server) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-3](#autoscaling_deployment) shows an overview architecture diagram
    involving an HPA.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1003](Images/ckd2_1003.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-3\. Autoscaling a Deployment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating Horizontal Pod Autoscalers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 10-4](#horizonal_pod_autoscaler) shows the use of an HPA that will
    scale up the number of replicas if an average of 80% CPU utilization is reached
    across all available Pods controlled by the Deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1004](Images/ckd2_1004.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-4\. Autoscaling a Deployment horizontally
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can use the `autoscale deployment` command to create an HPA for an existing
    Deployment. The option `--cpu-percent` defines the average maximum CPU usage threshold.
    At the time of writing, the imperative command doesn’t offer an option for defining
    the average maximum memory utilization threshold. The options `--min` and `--max`
    provide the minimum number of replicas to scale down to and the maximum number
    of replicas the HPA can create to handle the increased load, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command is a great shortcut for creating an HPA for a Deployment. The YAML
    manifest representation of the HPA object looks like [Example 10-2](#yaml_manifest_hpa).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2\. A YAML manifest for an HPA
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Listing Horizontal Pod Autoscalers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The short-form command for a Horizontal Pod Autoscaler is `hpa`. Listing all
    of the HPA objects transparently describes their current state: the CPU utilization
    and the number of replicas at this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If the Pod template of the Deployment does not define CPU resource requirements
    or if the CPU metrics cannot be retrieved from the metrics server, the left-side
    value of the column `TARGETS` says <unknown>. [Example 10-3](#cpu_resource_requirements_pod_template)
    sets the resource requirements for the Pod template so that the HPA can work properly.
    You can learn more about defining resource requirements in [“Working with Resource
    Requirements”](ch18.xhtml#container_resource_requirements).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3\. Setting CPU resource requirements for Pod template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once traffic hits the replicas, the current CPU usage is shown as a percentage.
    Here the average maximum CPU utilization is 15%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Rendering Horizontal Pod Autoscaler Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The event log of an HPA can provide additional insight into the rescaling activities.
    Rendering the HPA details can be a great tool for overseeing when the number of
    replicas was scaled up or down, as well as their scaling conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Defining Multiple Scaling Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can define more than a single resource type as a scaling metric. As you
    can see in [Example 10-4](#autoscaler_hpa), we are inspecting CPU and memory utilization
    to determine if the replicas of a Deployment need to be scaled up or down.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4\. A YAML manifest for a HPA with multiple metrics
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To ensure that the HPA determines the currently used resources, we’ll set the
    memory resource requirements for the Pod template as well, as shown in [Example 10-5](#memory_resource_requirements_pod_template).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-5\. Setting memory resource requirements for Pod template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing the HPA renders both metrics in the `TARGETS` column, as in the output
    of the `get` command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Deployment is an essential primitive for providing declarative updates and
    life cycle management of Pods. The ReplicaSet performs the heavy lifting of managing
    those Pods, commonly referred to as replicas. Application developers do not have
    to interact directly with the ReplicaSet; a Deployment manages the ReplicaSet
    under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Deployments can easily roll out and roll back revisions of the application represented
    by an image running in the container. In this chapter you learned about the commands
    for controlling the revision history and its operations. Scaling a Deployment
    manually requires deep insight into the requirements and the load of an application.
    A Horizontal Pod Autoscaler can automatically scale the number of replicas based
    on CPU and memory thresholds observed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Know the ins and outs of a Deployment
  prefs: []
  type: TYPE_NORMAL
- en: Given that a Deployment is such a central primitive in Kubernetes, you can expect
    that the exam will test you on it. Know how to create a Deployment and learn how
    to scale to multiple replicas. One of the superior features of a Deployment is
    its rollout functionality for new revisions. Practice how to roll out a new revision,
    inspect the rollout history, and roll back to a previous revision.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the implications of using a Horizontal Pod Autoscaler
  prefs: []
  type: TYPE_NORMAL
- en: The number of replicas controlled by a Deployment can be scaled up or down using
    the Horizontal Pod Autoscaler (HPA). An HPA defines thresholds for resources like
    CPU and memory that will tell the object that a scaling event needs to happen.
    It’s important to understand that the HPA functions properly only if you install
    the metrics server component and define resource requests and limits for containers.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_006.xhtml#appendix_a_deployments).
  prefs: []
  type: TYPE_NORMAL
- en: Create a Deployment named `nginx` with 3 replicas. The Pods should use the `nginx:1.23.0`
    image and the name `nginx`. The Deployment uses the label `tier=backend`. The
    Pod template should use the label `app=v1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the Deployment and ensure that the correct number of replicas is running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Update the image to `nginx:1.23.4`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Verify that the change has been rolled out to all replicas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assign the change cause “Pick up patch version” to the revision.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Scale the Deployment to 5 replicas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Have a look at the Deployment rollout history. Revert the Deployment to revision
    1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ensure that the Pods use the image `nginx:1.23.0`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Deployment named `nginx` with 1 replica. The Pod template of the Deployment
    should use container image `nginx:1.23.4`; set the CPU resource request to 0.5
    and the memory resource request/limit to 500Mi.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a HorizontalPodAutoscaler for the Deployment named `nginx-hpa` that scales
    to a minimum of 3 and a maximum of 8 replicas. Scaling should happen based on
    an average CPU utilization of 75% and an average memory utilization of 60%.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inspect the HorizontalPodAutoscaler object and identify the currently-utilized
    resources. How many replicas do you expect to exist?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
