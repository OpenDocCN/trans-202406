["```\n #include <vector>\nusing std::vector;\n//. . .\nvector <double> x;\t\t// Vector of real numbers\nvector <BondTrade> bond_trades;\t// Vector of user-defined BondTrade objects\n```", "```\nvector <double> v(3);\t// Will hold three elements\n```", "```\nv[0] = 10.6;\t\t// Set the first element (index 0) and assign to 10.6\nv[1] = 58.63;\t\t// Set the second element (index 1) and assign to 58.63\nv[2] = 0.874;\t\t// Set the first element (index 2) and assign to 0.874\n```", "```\nv[1] = 13.68;\n```", "```\nvector <double> w{9.8, 36.8, 91.3, 104.7}; // No assignment operator\nvector <int> q = {4, 12, 15};\t // With assignment operator \n```", "```\ndouble val = v.at(2);\t// val = 0.874\nw.at(1) = val;\t\t\t// 36.8 in w[1] is replaced with 0.874\n```", "```\n    double out_of_range = v.at(100);\t// 2 is the max index for v\n    ```", "```\n    w.at(-3) = 19.28;\n    ```", "```\nauto num_elems_w = w.size();\t// Returns 5\nauto num_elems_q = q.size();\t// Returns 3\n```", "```\nv.push_back(47.44);\n```", "```\nvector <double> x;\t\t// x.size() = 0\n```", "```\nx.push_back(3.08);\t// x.size() = 1\n```", "```\nx.push_back(5.12);\t// x.size() = 2\nx.push_back(7.32);\t// x.size() = 3\n//. . . etc\n```", "```\nints[0] = 2;\nints.at(2) = 4;\n```", "```\nenum OptionType\n{\n    European,     \t// default integer value = 0\n    American,     \t// default integer value = 1\n    Bermudan,     \t// default integer value = 2\n    Asian\t      \t// default integer value = 3\n};  \n```", "```\ncout << \" European = \" << European << endl;\ncout << \" American = \" << American << endl;\ncout << \" Bermudan = \" << Bermudan << endl;\ncout << \" Asian = \" << Asian << endl;\ncout << endl;\n```", "```\nEuropean\nAmerican\nBermudan\nAsian\n```", "```\nenum Baseball\n{\n\tPitcher,\t\t// 0\n\tCatcher,\t\t// 1\n\tFirst_Baseman,\t// 2\n\tSecond_Baseman,\t// 3\n\tThird_Baseman,\t// 4\n\tShortstop,\t\t// 5\n\tLeft_Field,    // 6\n\tCenter_Field,\t// 7\n\tRight_Field\t// 8\n};\n```", "```\nenum Football\n{\n\tDefensive_Tackle,\t// 0\n\tEdge_Rusher,\t\t// 1\n\tDefensive_End,\t\t// 2\n\tLinebacker,\t\t// 3\n\tCornerback,\t\t// 4\n\tStrong_Safety,\t\t// 5\n\tWeak_Safety\t\t// 6\n};\n```", "```\n\tif (Defensive_End == First_Baseman)\n\t{\n\t\tcout << \" Defensive_End == First_Baseman is true\" << endl;\n\t}\n\telse\n\t{\n\t\tcout << \" Defensive_End != First_Baseman is true\" << endl;\n\t}\n```", "```\nDefensive_End == First_Baseman is true\n```", "```\nenum Baseball\n{\n\tPitcher = 100,\t\n\tCatcher,\t\t// 101\n\tFirst_Baseman,\t// 102\n\t. . .\n};\n```", "```\nenum Football\n{\n\tDefensive_Tackle = 200,\n\tEdge_Rusher,\t\t// 201\n\tDefensive_End,\t\t// 202\n\t. . .\n};\n```", "```\nenum class Bond\n{\n\tGovernment,\n\tCorporate,\t\t      \n\tMunicipal,\n\tConvertible\n};\nenum class Futures_Contract\n{\n\tGold,\n\tSilver,\n\tOil,\n\tNatural_Gas,\n\tWheat,\n\tCorn\n\t};\nenum class Options_Contract\n{\n    European,     \t\n    American,     \t\n    Bermudan,     \n    Asian\t      \n};\n```", "```\nif(Bond::Corporate == Futures_Contract::Gold)\n{\n\t// . . .\n}\n```", "```\n// Simple if\nif (condition)\n{\n  // action\n}\n// if/else\nif (condition)\n{\n  // action\n}\nelse\n{\n  // default action\n}\n// if/else if.../else\nif (condition 1)\n{\n  // action 1\n}\nelse if (condition 2)\n{\n  // action 2\n}\n// ...\nelse if (condition n)\n{\n  // action n\n}\nelse\n{\n  // default action\n}\n```", "```\n\tint x = 1;\n\tint y = 2;\n\tint z = 3;\n\n\t// Simple if\n\tif (x > 0)\n\t{\n\t\tcout << x << \" > 0\" << endl;\n\t}\n\t// if/else\n\tif (x >= y)\n\t{\n\t\tcout << x << \" >= \" << y << endl;\n\t}\n\telse\n\t{\n\t\tcout << x << \" is less than \" << y << endl;\n\t}\n\t// if/else if.../else\n\tif (x == z)\n\t{\n\t\tcout << x << \" == \" << z << endl;\n\t}\n\telse if (x < z)\n\t{\n\t\tcout << x << \" > \" << z << endl;\n\t}\n\telse if (x > z)\n\t{\n\t\tcout << x << \" < \" << z << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Default condition\" << endl;\n\t}\n```", "```\n\t#include <cmath>\n\tusing std::abs;\n\tusing std::exp;\n\n\t// Simple if\n\tif (x > 0 || y < 1)\n\t{\n\t\tcout << x << \" > 0 OR \" << y << \" < 1 \" << endl;\n\t}\n\t// if/else if.../else\n\tif (x > 0 && y < 1)\n\t{\n\t\tcout << x << \" > 0 AND \" << y << \" < 1 \" << endl;\n\t}\n\telse if (x <= 0 || y >= 1)\n\t{\n\t\tcout << x << \" <= 0 OR \" << y << \" >= 1 \" << endl;\n\t}\n\telse if (z <= 0 || (abs(x) > z && exp(y) < z))\n\t{\n\t\tcout << z << \" <= 0 OR \" << endl;\n\t\tcout << abs(x) << \" > \" << z << \" AND \" \n\t\t\t      << exp(y) << \" < \" << z << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Default condition\" << endl;\n\t}\n```", "```\n\tbool cond1 = (x > 0 && y < 1);\n\tbool cond2 = (z <= 0 || (abs(x) > z && abs(y) < z));\n\tif (cond1)\n\t{\n\t\tcout << x << \" > 0 AND \" << y << \" < 1 \" << endl;\n\t}\n\telse if (!cond1)\n\t{\n\t\tcout << x << \" <= 0 OR \" << y << \" >= 1 \" << endl;\n\t}\n\telse if (cond2)\n\t{\n\t\tcout << z << \" <= 0 OR \" << endl;\n\t\tcout << abs(x) << \" > \" << z << \" AND \"\n\t\t\t<< abs(y) << \" < \" << z << endl;\n\t}\n\telse\n\t{\n\t\tcout << \"Default condition\" << endl;\n\t}\n```", "```\nusing std::sin;\nusing std::cos;\nint j = 10;\nint k = 20;\ndouble theta = 3.14;\ndouble result = j < k ? sin(theta) : cos(theta);\n```", "```\nvoid switch_statement(int x)\n{\n\tswitch (x)\n\t{\n\tcase 0:\n\t\tcout << \"European Option: Use Black-Scholes\" << endl;\n\t\tbreak;\n\tcase 1:    \n\t\tcout << \"American Option: Use a lattice model\" << endl;\n\t\tbreak;\n\tcase 2:\n\t\tcout << \"Bermudan Option: Use Longstaff-Schwartz Monte Carlo\" << endl;\n\t\tbreak;\n\tcase 3:\n\t\tcout << \"Asian Option: Calculate average of the spot time series\" << endl;\n\t\tbreak;\n\tdefault:\n\t\tcout << \"Option type unknown\" << endl;\n\t\tbreak;\n\t}\n}\n```", "```\nvoid switch_football(int x)\n{\n\tswitch (x)\n\t{\n\tcase 0:\t\t// Drive stalls\n\t\tcout << \"Punt\" << endl;\n\t\tbreak;\n\tcase 3:\t\t// Kick field goal\n\tcase 6:\t\t// Score touchdown; miss extra point(s)\n\tcase 7:\t\t// Kick extra point\n\tcase 8:\t\t// Score two-point conversion\n\t\tcout << \"Kick off\" << endl;\n\t\tbreak;\n\tdefault:\n\t\tcout << \"Are you at a tennis match?\" << endl;\n\t\tbreak;\n\t}\n}\n```", "```\nvoid switch_statement_enum(OptionType ot)\n{\n\tswitch (ot)\n\t{\n\tcase European:\t\t// = 0\n\t\tcout << \"European Option: Use Black-Scholes\" << endl;\n\t\tbreak;\n\tcase American:\t\t// = 1    \n\t\t. . .\n\tcase Bermudan:\t\t// = 2\n\t\t. . .\n\tcase Asian:\t\t// = 3\n\t\t. . .\n\tdefault:\n\t\tcout << \"Option type unknown\" << endl;\n\t\tbreak;\n\t}\n}\n```", "```\nvoid switch_enum_class_member(Options_Contract oc)\n{\n\tswitch (oc)\n\t{\n\tcase Options_Contract::European:\n\t\tcout << \"European Option: Use Black-Scholes\" << endl;\n\t\tbreak;\n\tcase Options_Contract::American:    \n\t\t. . .\n\tcase Options_Contract::Bermudan:\n\t\t. . .\n\tcase Options_Contract::Asian:\n\t\t. . .\n\tdefault:\n\t\tcout << \"Option type unknown\" << endl;\n\t\tbreak;\n\t}\n}\n```", "```\nint i = 0;\nint max = 10;\nwhile (i < max)\n{\n\tcout << i << \", \";\n\t++i;\n}\n```", "```\nint i = 0;\nint max = 10;\ndo \n{\n\tcout << i << \", \";\n\t++i;\n} while (i < max);\n```", "```\nfor(initial expression executed only once;\nexit condition executed at the beginning of every loop;\nloop expression executed at the end of every loop)\n{\nDoSomeStuff;\n}\n```", "```\nfor(a; b; c) \n```", "```\nint max = 10;\nfor(int i = 0; i < max; ++i)\n{\n\tcout << i << \", \";\t\t// we no longer need ++i in the body\n}   \n```", "```\nint max = 10;\nfor (int i = 0; i < 100; ++i)\n{\n\tcout << i << \", \";\n\tif (i > max)\n\t{\n\t    cout << \"Passed i = \" << max << \"; I'm tired, so let's go home.\" \n\t        << endl;\n\t    break;\n\t}\n}\n```", "```\nvector<double> v;\n// Populate the vector v and then use below:\nfor(unsigned i = 0; i < v.size(); ++i)\n{\n\t// Do something with v[i] or v.at(i). . .\n}\n```", "```\nfor(auto elem : v)\n{\n\t// Use elem, rather than v[i] or v.at(i)\n}\n```", "```\ndouble sum = 0.0;\nfor(auto elem : v)\n{\n\tsum += elem;\n}\n```", "```\nusing RealVector = vector<double>;\n```", "```\nRealVector v = {3.19, 2.58, 1.06};\nv.push_back(2.1);\nv.push_back(1.7);\n// etc...\n```", "```\ntypedef vector<double> RealVector;\n```", "```\nint original = 15;\nint& ref = original;\t// int& means \"reference to an int\"\n```", "```\noriginal = 12;\t\t\t// ref now = 12\t\nref = 4;\t\t\t\t// original also now = 4\n```", "```\nint& ozone;\n```", "```\n// This is OK\nusing IntVector = std::vector<int>;\nint sum_ints(const IntVector& v)\n{\n\tint sum = 0;\n\tfor (auto elem : v)\n\t{\n\t\tsum += elem;\n\t}\n\n\treturn sum;\n}\nint sum_of_twice_the_ints(const IntVector& v)\n{\n\t// Will not compile!  const prevents modification\n\t// of the elements in the vector v.\n\n\tint sum = 0;\n\tfor (auto elem : v)\n\t{\n\t\telem = 2 * elem;\n\t\tsum += elem;\n\t}\n\n\treturn sum;\n}\n```", "```\nint x = 42;\n```", "```\nint* xp;\n```", "```\nxp = &x;\n```", "```\nstd::cout << *xp << std::endl;\n```", "```\n*xp = 25;\n```", "```\nint y = 106;\nxp = &y;\n```", "```\nSomeClass sc;\nauto SomeClass* ptr_sc = &sc;\n```", "```\n(*ptr_sc).some_fcn();\n```", "```\nptr_sc->some_fcn();\n```", "```\n#include <vector> \n// . . .\ndouble sum(double x, double y)\n{\n\treturn x + y;\n}\n```", "```\nstd::vector<double> sum(const std::vector<double>& x, const std::vector<double>& y)\n{\n\t// NOTE TO SELF: Can we do this with range-based for loops(?!)\n\tstd::vector<double> vec_sum;\n\tif(x.size() == y.size())\n\t{\n\t\tfor (int i = 0; i < x.size(); ++i)\n\t\t{\n\t\t\tvec_sum.push_back(x.at(i) + y.at(i));\n\t\t}\t\n\t}\n\treturn vec_sum;\t\t// Empty if size of x and y do not match\n}\n```", "```\ndouble sum(double x, double y, double z)\n{\n\treturn x + y + z;\n}\n```", "```\nsum(5.31, 92.26);\nsum(4.19, 41.9, 419.0);\n```", "```\nstd::vector<double> operator + (const std::vector<double>& x, const std::vector<double>& y)\n{\n\tstd::vector<double> add_vec;\n\tif (x.size() == y.size())\n\t{\n\t\tfor (unsigned i = 0; i < x.size(); ++i)\n\t\t{\n\t\t\tadd_vec.push_back(x.at(i) + y.at(i));\n\t\t}\n\t}\n\treturn add_vec;\t\t// Empty vector if x & y sizes not identical\n}\n```", "```\ndouble operator * (const std::vector<double>& x, const std::vector<double>& y)\n{\n\tdouble dot_prod = 0.0;\n\tif (x.size() == y.size())\n\t{\n\t\tfor (int i = 0; i < x.size(); ++i)\n\t\t{\n\t\t\tdot_prod += (x[i] * y[i]);\n\t\t}\n\t}\n\treturn dot_prod;\t// Return 0.0 if size of x and y do not match\t\t\n}\n```", "```\nstd::vector<double> x = {1.1, 2.2, 3.3};\nstd::vector<double> y = {0.1, 0.2, 0.3};\n```", "```\nauto v_sum = x + y;\t\t// ans: {1.2, 2.4, 3.6}\nauto v_dot = x * y;\t\t// ans: 1.54\n```", "```\ndouble s = 1.1 + 0.1;\t// s = 1.2\ndouble p = 2.2 * 0.2;\t// p = 0.44\n```"]