<html><head></head><body><section data-pdf-bookmark="Chapter 7. Debugging Containers" data-type="chapter" epub:type="chapter"><div class="chapter" id="debug_docker">&#13;
<h1><span class="label">Chapter 7. </span>Debugging Containers</h1>&#13;
&#13;
&#13;
<p>Once you’ve shipped an application<a data-primary="debugging" data-secondary="containers" data-tertiary="about" data-type="indexterm" id="idm46803142445280"/> to production, there will come a day when it’s not working as expected. It’s always nice to know ahead of time what to expect when that day comes. It’s also important to have a good understanding of debugging containers before moving on to more complex deployments. Without debugging skills, it will be difficult to see where orchestration systems have gone wrong. So let’s take a look at debugging containers.</p>&#13;
&#13;
<p>In the end, debugging a containerized<a data-primary="processes" data-secondary="debugging containers" data-tertiary="about" data-type="indexterm" id="idm46803142443520"/><a data-primary="Linux" data-secondary="kernel" data-tertiary="container as just another process" data-type="indexterm" id="idm46803142442272"/> application is not all that different from debugging a normal process on a system except that the tools are somewhat different. Docker provides some pretty nice tooling to help you out! Some of these map to regular system tools, and some go further.</p>&#13;
&#13;
<p>It is also critical to understand that your application is not running in a separate system from the other Docker processes. They share a kernel, and depending on your container configuration, they may share other things like a storage subsystem and network interfaces. This means that you can get a lot of information about what your container is doing from the system.</p>&#13;
&#13;
<p>If you’re used to debugging applications in a VM environment, you might think you would need to enter the container to inspect an application’s memory or CPU use, or to debug its system calls. However, this is not so! Despite feeling in many ways like a virtualization layer, <a data-primary="processes" data-secondary="container processes as Linux host processes" data-type="indexterm" id="idm46803142439712"/><a data-primary="ps command" data-type="indexterm" id="idm46803142438640"/>processes in containers are just processes on the Linux host itself. If you want to see a process list across all of the Linux containers on a machine, you could log in to the server and run <code>ps</code> with your favorite command-line options. <a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="top for list of container processes" data-type="indexterm" id="idm46803142437456"/><a data-primary="processes" data-secondary="overview of containers" data-tertiary="docker container top" data-type="indexterm" id="idm46803142436192"/>However, you can use the <code>docker container top</code> command from anywhere to see the list of processes running in your container from the viewpoint of the underlying Linux kernel. Let’s take a more detailed look at some of the things that you can do when debugging a containerized application that do not require the use of either <code>docker container exec</code> or <code>nsenter</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Process Output" data-type="sect1"><div class="sect1" id="idm46803142433600">&#13;
<h1>Process Output</h1>&#13;
&#13;
<p>One of the first things you’ll want<a data-primary="debugging" data-secondary="containers" data-tertiary="process output" data-type="indexterm" id="ch07-po"/><a data-primary="processes" data-secondary="debugging containers" data-tertiary="process output" data-type="indexterm" id="ch07-po2"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="top for list of container processes" data-type="indexterm" id="idm46803142428560"/><a data-primary="processes" data-secondary="overview of containers" data-tertiary="docker container top" data-type="indexterm" id="idm46803142427280"/> to know when debugging a container is what is running inside it.&#13;
As we mentioned previously, Docker has a built-in command for doing just that: <code>docker container top</code>. This is not the only way to see what’s going on inside a container, but it is by far the easiest to use. Let’s see how that works:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>--name<code class="w"> </code>nginx-debug<code class="w"> </code>--rm<code class="w"> </code>nginx:latest<code class="w"/>&#13;
<code class="go">796b282bfed33a4ec864a32804ccf5cbbee688b5305f094c6fbaf20009ac2364</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>top<code class="w"> </code>nginx-debug<code class="w"/>&#13;
&#13;
<code class="go">UID   PID  PPID C STIME TTY TIME  CMD</code>&#13;
<code class="go">root  2027 2002 0 12:35 ?   00:00 nginx: master process nginx -g daemon off;</code>&#13;
<code class="go">uuidd 2085 2027 0 12:35 ?   00:00 nginx: worker process</code>&#13;
<code class="go">uuidd 2086 2027 0 12:35 ?   00:00 nginx: worker process</code>&#13;
<code class="go">uuidd 2087 2027 0 12:35 ?   00:00 nginx: worker process</code>&#13;
<code class="go">uuidd 2088 2027 0 12:35 ?   00:00 nginx: worker process</code>&#13;
<code class="go">uuidd 2089 2027 0 12:35 ?   00:00 nginx: worker process</code>&#13;
<code class="go">uuidd 2090 2027 0 12:35 ?   00:00 nginx: worker process</code>&#13;
<code class="go">uuidd 2091 2027 0 12:35 ?   00:00 nginx: worker process</code>&#13;
<code class="go">uuidd 2092 2027 0 12:35 ?   00:00 nginx: worker process</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>stop<code class="w"> </code>nginx-debug<code class="w"/></pre>&#13;
&#13;
<p>To run <code>docker container top</code>, we need to pass it the name or ID of our container, and then we receive a nice listing of what is running inside our container, ordered by PID just as we’d expect from Linux <code>ps</code> output.</p>&#13;
&#13;
<p>There are some oddities here, though. The primary one is the name-spacing of user IDs and filesystems.</p>&#13;
&#13;
<p>It is important to understand that<a data-primary="UID (user ID)" data-secondary="username differences for same UID" data-type="indexterm" id="idm46803142362752"/><a data-primary="namespaces" data-secondary="username not required for UID" data-type="indexterm" id="idm46803142396928"/><a data-primary="user ID" data-see="UID" data-type="indexterm" id="idm46803142396016"/> the username for a particular user ID (UID) can be completely different between each container and the host system. It is even possible that a specific UID has no named user in the container or host’s <em>/etc/passwd</em> file associated with it at all.&#13;
This is because Unix does not require a UID to have a named user associated with it, and Linux namespaces, which we discuss much more in <a data-type="xref" href="ch11.html#namespaces">“Namespaces”</a>, provide some isolation between the container’s concept of valid users and those on the underlying host.</p>&#13;
&#13;
<p>Let’s look at a more concrete example of this. Let’s consider a production Docker server running Ubuntu 22.04 and a container running on it that has an Ubuntu distribution inside. If you run the following commands on the Ubuntu host, you would see that UID 7 is named <code>lp</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>id<code class="w"> </code><code class="m">7</code><code class="w"/>&#13;
&#13;
<code class="go">uid=7(lp) gid=7(lp) groups=7(lp)</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There is nothing special about the UID number we are using here. You don’t need to take any particular note of it. It was chosen simply because it is used by default on both platforms but represents a different username.</p>&#13;
</div>&#13;
&#13;
<p>If we then enter the standard Fedora container on that Docker host, you will see that UID 7 is set to <code>halt</code> in <em>/etc/passwd</em>. By running the following commands, you can see that the container has a completely different perspective of who UID 7 is:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-it<code class="w"> </code>fedora:latest<code class="w"> </code>/bin/bash<code class="w"/>&#13;
&#13;
<code class="gp">root@c399cb807eb7:/# </code>id<code class="w"> </code><code class="m">7</code><code class="w"/>&#13;
<code class="go">uid=7(halt) gid=0(root) groups=0(root)</code>&#13;
&#13;
<code class="gp">root@c399cb807eb7:/# </code>grep<code class="w"> </code>x:7:<code class="w"> </code>/etc/passwd<code class="w"/>&#13;
<code class="go">halt:x:7:0:halt:/sbin:/sbin/halt</code>&#13;
&#13;
<code class="gp">root@409c2a8216b1:/# </code><code class="nb">exit</code><code class="w"/></pre>&#13;
&#13;
<p>If we then run <code>ps aux</code> on the <a data-primary="ps command" data-secondary="ps aux" data-type="indexterm" id="idm46803142280032"/>theoretical Ubuntu Docker server while that container is running as UID 7 (<code>-u 7</code>), we see that the Docker host shows the container process as being run by <code>lp</code> instead of <code>halt</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>-u<code class="w"> </code><code class="m">7</code><code class="w"> </code>fedora:latest<code class="w"> </code>sleep<code class="w"> </code><code class="m">120</code><code class="w"/>&#13;
&#13;
<code class="go">55…c6</code>&#13;
&#13;
<code class="gp">$ </code>ps<code class="w"> </code>aux<code class="w"> </code><code class="p">|</code><code class="w"> </code>grep<code class="w"> </code>sleep<code class="w"/>&#13;
&#13;
<code class="go">lp          2388  0.2  0.0   2204   784 ?     … 0:00 sleep 120</code>&#13;
<code class="go">vagrant     2419  0.0  0.0   5892  1980 pts/0 … 0:00 grep --color=auto sleep</code></pre>&#13;
&#13;
<p>This could be particularly confusing if a well-known user like <code>nagios</code> or <code>postgres</code> were configured on the host system but not in the container, yet the container ran its process with the same ID. This namespacing can make the <code>ps</code> output look quite strange. It might, for example, look like the <code>nagios</code> user on your Docker host is running the <code>postgresql</code> daemon that was launched inside a container, if you don’t pay close attention.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>One solution to this is to dedicate<a data-primary="UID (user ID)" data-secondary="“container” user as nonzero UID" data-secondary-sortas="container user" data-type="indexterm" id="idm46803142240688"/><a data-primary="ps command" data-secondary="“container” user as nonzero UID" data-secondary-sortas="container user" data-type="indexterm" id="idm46803142239088"/><a data-primary="UID (user ID)" data-secondary="“container” user as nonzero UID" data-secondary-sortas="container user" data-tertiary="all containers as same UID" data-type="indexterm" id="idm46803142237904"/> a nonzero UID to your containers. On your Docker servers, you can create a <code>container</code> user as UID 5000 and then create the same user in your base container images. If you then run all your containers as UID 5000 (<code>-u 5000</code>), not only will you improve the security of your system by not running container processes as UID 0, but you will also make the <code>ps</code> output on the Docker host easier to decipher by displaying the <code>container</code> user for all of your running container processes. Some systems use the <code>nobody</code> or <code>daemon</code> user for the same purpose, but we prefer <code>container</code> for clarity. There is a little more detail about how this works in <a data-type="xref" href="ch11.html#namespaces">“Namespaces”</a>.</p>&#13;
</div>&#13;
&#13;
<p>Likewise, because the process<a data-primary="ps command" data-secondary="filesystem paths relative to container" data-type="indexterm" id="idm46803142212560"/><a data-primary="filesystem layers of Linux containers" data-secondary="paths relative to container" data-type="indexterm" id="idm46803142211712"/><a data-primary="paths of files relative to container" data-type="indexterm" id="idm46803142210832"/><a data-primary="processes" data-secondary="debugging containers" data-tertiary="filesystem paths relative to container" data-type="indexterm" id="idm46803142210144"/><a data-primary="debugging" data-secondary="containers" data-tertiary="filesystem paths relative to container" data-type="indexterm" id="idm46803142208912"/> has a different view of the filesystem, paths that are shown in the <code>ps</code> output are relative to the container and not the host. In these cases, knowing it is in a container is a big win.</p>&#13;
&#13;
<p>So that’s how you use the Docker tooling to look at what’s running in a container. But that’s not the only way, and in a debugging situation, it might not be the best way. If you hop onto a Docker server and run a normal Linux <code>ps</code> to see what’s running, you get a full list of everything containerized and not containerized just as if they were all equivalent processes. There are some ways to look at the process output to make things a lot clearer. <a data-primary="ps command" data-secondary="output in tree form" data-type="indexterm" id="ch07-tree"/><a data-primary="processes" data-secondary="debugging containers" data-tertiary="ps output in tree form" data-type="indexterm" id="ch07-tree2"/><a data-primary="debugging" data-secondary="containers" data-tertiary="ps output in tree form" data-type="indexterm" id="ch07-tree3"/>For example, you can facilitate debugging by looking at the Linux <code>ps</code> output in tree form so that you can see all of the processes descended from Docker. Here’s what that might look like when you use the BSD command-line flags to look at a system that is currently running two containers; we’ll chop the output to just the part we care about.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Docker Desktop’s VM<a data-primary="Docker Desktop" data-primary-sortas="docker-a" data-secondary="Linux commands minimal" data-type="indexterm" id="idm46803142200464"/> contains minimal versions of most Linux tools, and some of these commands may not produce the same output that you will get if you use a standard Linux server as the Docker daemon host.</p>&#13;
</div>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>ps<code class="w"> </code>axlfww<code class="w"/>&#13;
&#13;
<code class="go">… /usr/bin/containerd</code>&#13;
<code class="go">…</code>&#13;
<code class="go">… /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</code>&#13;
<code class="go">… \_ /usr/bin/docker-proxy -proto tcp -host-ip 0.0.0.0 -host-port 8080 \</code>&#13;
<code class="go">       -container-ip 172.17.0.2 -container-port 8080</code>&#13;
<code class="go">… \_ /usr/bin/docker-proxy -proto tcp -host-ip :: -host-port 8080 \</code>&#13;
<code class="go">       -container-ip 172.17.0.2 -container-port 8080</code>&#13;
<code class="go">…</code>&#13;
<code class="go">… /usr/bin/containerd-shim-runc-v2 -namespace moby -id 97…3d -address /run/…</code>&#13;
<code class="go">… \_ sleep 120</code>&#13;
<code class="go">…</code>&#13;
<code class="go">… /usr/bin/containerd-shim-runc-v2 -namespace moby -id 69…7c -address /run/…</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Many of the <code>ps</code> commands in this example work only on Linux distributions with the full <code>ps</code> command. Some stripped-down versions of Linux, <a data-primary="Alpine Linux" data-secondary="ps support not complete" data-type="indexterm" id="idm46803142147264"/>like Alpine, run the BusyBox shell, which does not have full <code>ps</code> support and won’t show some of this output. We recommend running a full distribution on your host systems like Ubuntu or Fedora CoreOS.</p>&#13;
</div>&#13;
&#13;
<p>Here you can see that we’re running one instance of <code>containerd</code>, which is the main container runtime used by the Docker daemon. <code>dockerd</code> has two <code>docker-proxy</code> sub-processes running at the moment, which we will discuss in more detail in <a data-type="xref" href="#net_inspect">“Network Inspection”</a>.</p>&#13;
&#13;
<p>Each process that is using <code>containerd-shim-runc-v2</code> represents a single container and all of the processes that are running inside that container. In this example, we have two containers. They show up as <code>containerd-shim-runc-v2</code>, followed by some additional information about the process, including the container ID. In this case, we are running one instance of Google’s <code>cadvisor</code> and one instance of <code>sleep</code> in another container. Each container that has ports mapped will have at least one <code>docker-proxy</code> process that is used to map the required network ports between the container and the host Docker server. In this example, both <code>docker-proxy</code> processes are related to <code>cadvisor</code>. One is mapping the ports for IPv4 addresses, and the other is mapping ports for IPv6 addresses.</p>&#13;
&#13;
<p>Because of the tree output from <code>ps</code>, it’s pretty clear which processes are running in which containers. If you’re a bigger fan of Unix SysV command-line flags, you can get a similar, but not as nice-looking, tree output with <code>ps -ejH</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>ps<code class="w"> </code>-ejH<code class="w"/>&#13;
&#13;
<code class="go">… containerd</code>&#13;
<code class="go">…</code>&#13;
<code class="go">… dockerd</code>&#13;
<code class="go">…   docker-proxy</code>&#13;
<code class="go">…   docker-proxy</code>&#13;
<code class="go">…</code>&#13;
<code class="go">… containerd-shim</code>&#13;
<code class="go">…   cadvisor</code>&#13;
<code class="go">…</code>&#13;
<code class="go">… containerd-shim</code>&#13;
<code class="go">…   sleep</code></pre>&#13;
&#13;
<p class="pagebreak-before">You can get a more concise view<a data-primary="pstree command" data-type="indexterm" id="idm46803142102736"/> of the <code>docker</code> process tree by using the <code>pstree</code> command. Here, we’ll use <code>pidof</code> to scope it to the tree belonging to <code>docker</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>pstree<code class="w"> </code><code class="sb">`</code>pidof<code class="w"> </code>dockerd<code class="sb">`</code><code class="w"/>&#13;
&#13;
<code class="go">dockerd─┬─docker-proxy───7*[{docker-proxy}]</code>&#13;
<code class="go">        ├─docker-proxy───6*[{docker-proxy}]</code>&#13;
<code class="go">        └─10*[{dockerd}]</code></pre>&#13;
&#13;
<p>This doesn’t show us PIDs and therefore is useful only for getting a sense of how things are connected. But this is conceptually clear output when there are a lot of processes running on a host. It’s far more concise and provides a nice high-level map of how things connect. Here we can see the same containers that were shown in the previous <code>ps</code> output, but the tree is collapsed so we get multipliers like <code>7*</code> when there are seven duplicate processes.</p>&#13;
&#13;
<p>We can get a full tree with PIDs if we run <code>pstree</code>, as shown here:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>pstree<code class="w"> </code>-p<code class="w"> </code><code class="sb">`</code>pidof<code class="w"> </code>dockerd<code class="sb">`</code><code class="w"/>&#13;
&#13;
<code class="go">dockerd(866)─┬─docker-proxy(3050)─┬─{docker-proxy}(3051)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3052)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3053)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3054)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3056)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3057)</code>&#13;
<code class="go">             │                    └─{docker-proxy}(3058)</code>&#13;
<code class="go">             ├─docker-proxy(3055)─┬─{docker-proxy}(3059)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3060)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3061)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3062)</code>&#13;
<code class="go">             │                    ├─{docker-proxy}(3063)</code>&#13;
<code class="go">             │                    └─{docker-proxy}(3064)</code>&#13;
<code class="go">             ├─{dockerd}(904)</code>&#13;
<code class="go">             ├─{dockerd}(912)</code>&#13;
<code class="go">             ├─{dockerd}(913)</code>&#13;
<code class="go">             ├─{dockerd}(914)</code>&#13;
<code class="go">             ├─{dockerd}(990)</code>&#13;
<code class="go">             ├─{dockerd}(1014)</code>&#13;
<code class="go">             ├─{dockerd}(1066)</code>&#13;
<code class="go">             ├─{dockerd}(1605)</code>&#13;
<code class="go">             ├─{dockerd}(1611)</code>&#13;
<code class="go">             └─{dockerd}(2228)</code></pre>&#13;
&#13;
<p>This output provides us with a very good look at all the processes attached to Docker and what they are running.</p>&#13;
&#13;
<p>If you wanted to inspect a single container and its processes, you could determine the container’s main process ID and then use <code>pstree</code> to see all the related subprocesses:<a data-startref="ch07-po" data-type="indexterm" id="idm46803141991024"/><a data-startref="ch07-po2" data-type="indexterm" id="idm46803141990416"/><a data-startref="ch07-tree" data-type="indexterm" id="idm46803141989744"/><a data-startref="ch07-tree2" data-type="indexterm" id="idm46803141989072"/><a data-startref="ch07-tree3" data-type="indexterm" id="idm46803141988400"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>ps<code class="w"> </code>aux<code class="w"> </code><code class="p">|</code><code class="w"> </code>grep<code class="w"> </code>containerd-shim-runc-v2<code class="w"/>&#13;
<code class="go">root    3072  … /usr/bin/containerd-shim-runc-v2 -namespace moby -id 69…7c …</code>&#13;
<code class="go">root    4489  … /usr/bin/containerd-shim-runc-v2 -namespace moby -id f1…46 …</code>&#13;
<code class="go">vagrant 4651  … grep --color=auto shim</code>&#13;
&#13;
<code class="gp">$ </code>pstree<code class="w"> </code>-p<code class="w"> </code><code class="m">3072</code><code class="w"/>&#13;
<code class="go">containerd-shim(3072)─┬─cadvisor(3092)─┬─{cadvisor}(3123)</code>&#13;
<code class="go">                      │                ├─{cadvisor}(3124)</code>&#13;
<code class="go">                      │                ├─{cadvisor}(3125)</code>&#13;
<code class="go">                      │                ├─{cadvisor}(3126)</code>&#13;
<code class="go">                      │                ├─{cadvisor}(3127)</code>&#13;
<code class="go">                      │                ├─{cadvisor}(3128)</code>&#13;
<code class="go">                      │                ├─{cadvisor}(3180)</code>&#13;
<code class="go">                      │                ├─{cadvisor}(3181)</code>&#13;
<code class="go">                      │                └─{cadvisor}(3182)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3073)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3074)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3075)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3076)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3077)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3078)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3079)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3080)</code>&#13;
<code class="go">                      ├─{containerd-shim}(3121)</code>&#13;
<code class="go">                      └─{containerd-shim}(3267)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Process Inspection" data-type="sect1"><div class="sect1" id="idm46803141913104">&#13;
<h1>Process Inspection</h1>&#13;
&#13;
<p>If you’re logged in to the Docker server,<a data-primary="debugging" data-secondary="containers" data-tertiary="process inspection" data-type="indexterm" id="ch07-procinsp"/><a data-primary="processes" data-secondary="debugging containers" data-tertiary="process inspection" data-type="indexterm" id="ch07-procinsp2"/> you can inspect running processes using all of the standard debugging tools. Common debugging tools like <code>strace</code> work as expected. In the following code, we’ll inspect an <code>nginx</code> process running inside a container:<a data-primary="strace command" data-type="indexterm" id="idm46803141976944"/><a data-primary="Linux" data-secondary="systemd" data-tertiary="process inspection" data-type="indexterm" id="idm46803141976240"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>--name<code class="w"> </code>nginx-debug<code class="w"> </code>--rm<code class="w"> </code>nginx:latest<code class="w"/>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>top<code class="w"> </code>nginx-debug<code class="w"/>&#13;
&#13;
<code class="go">UID      PID   PPID  … CMD</code>&#13;
<code class="go">root     22983 22954 … nginx: master process nginx -g daemon off;</code>&#13;
<code class="go">systemd+ 23032 22983 … nginx: worker process</code>&#13;
<code class="go">systemd+ 23033 22983 … nginx: worker process</code>&#13;
&#13;
<code class="gp">$ </code>sudo<code class="w"> </code>strace<code class="w"> </code>-p<code class="w"> </code><code class="m">23032</code><code class="w"/>&#13;
&#13;
<code class="go">strace: Process 23032 attached</code>&#13;
<code class="go">epoll_pwait(10,</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>If you run <code>strace</code>, you will need to type Ctrl-C to exit the <code>strace</code> process.<a data-primary="exiting via Ctrl-C" data-secondary="strace process" data-type="indexterm" id="idm46803141881920"/></p>&#13;
</div>&#13;
&#13;
<p>You can see that we get the same output that we would from noncontainerized processes on the host. <a data-primary="lsof command" data-type="indexterm" id="idm46803141880288"/>Likewise, an <code>lsof</code> shows us that the files and sockets open in a process work as expected:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>sudo<code class="w"> </code>lsof<code class="w"> </code>-p<code class="w"> </code><code class="m">22983</code><code class="w"/>&#13;
<code class="go">COMMAND   PID USER … NAME</code>&#13;
<code class="go">nginx   22983 root … /</code>&#13;
<code class="go">nginx   22983 root … /</code>&#13;
<code class="go">nginx   22983 root … /usr/sbin/nginx</code>&#13;
<code class="go">nginx   22983 root … /usr/sbin/nginx (stat: No such file or directory)</code>&#13;
<code class="go">nginx   22983 root … /lib/aarch64-linux-gnu/libnss_files-2.31.so (stat: …</code>&#13;
<code class="go">nginx   22983 root … /lib/aarch64-linux-gnu/libc-2.31.so (stat: …</code>&#13;
<code class="go">nginx   22983 root … /lib/aarch64-linux-gnu/libz.so.1.2.11 (path inode=…)</code>&#13;
<code class="go">nginx   22983 root … /usr/lib/aarch64-linux-gnu/libcrypto.so.1.1 (stat: …</code>&#13;
<code class="go">nginx   22983 root … /usr/lib/aarch64-linux-gnu/libssl.so.1.1 (stat: …</code>&#13;
<code class="go">nginx   22983 root … /usr/lib/aarch64-linux-gnu/libpcre2-8.so.0.10.1 (stat: …</code>&#13;
<code class="go">nginx   22983 root … /lib/aarch64-linux-gnu/libcrypt.so.1.1.0 (path …</code>&#13;
<code class="go">nginx   22983 root … /lib/aarch64-linux-gnu/libpthread-2.31.so (stat: …</code>&#13;
<code class="go">nginx   22983 root … /lib/aarch64-linux-gnu/libdl-2.31.so (stat: …</code>&#13;
<code class="go">nginx   22983 root … /lib/aarch64-linux-gnu/ld-2.31.so (stat: …</code>&#13;
<code class="go">nginx   22983 root … /dev/zero</code>&#13;
<code class="go">nginx   22983 root … /dev/null</code>&#13;
<code class="go">nginx   22983 root … pipe</code>&#13;
<code class="go">nginx   22983 root … pipe</code>&#13;
<code class="go">nginx   22983 root … pipe</code>&#13;
<code class="go">nginx   22983 root … protocol: UNIX-STREAM</code>&#13;
<code class="go">nginx   22983 root … pipe</code>&#13;
<code class="go">nginx   22983 root … pipe</code>&#13;
<code class="go">nginx   22983 root … protocol: TCP</code>&#13;
<code class="go">nginx   22983 root … protocol: TCPv6</code>&#13;
<code class="go">nginx   22983 root … protocol: UNIX-STREAM</code>&#13;
<code class="go">nginx   22983 root … protocol: UNIX-STREAM</code>&#13;
<code class="go">nginx   22983 root … protocol: UNIX-STREAM</code></pre>&#13;
&#13;
<p>Note that the paths to the files<a data-primary="processes" data-secondary="debugging containers" data-tertiary="filesystem paths relative to container" data-type="indexterm" id="idm46803141835136"/><a data-primary="filesystem layers of Linux containers" data-secondary="paths relative to container" data-type="indexterm" id="idm46803141831184"/><a data-primary="debugging" data-secondary="containers" data-tertiary="filesystem paths relative to container" data-type="indexterm" id="idm46803141830240"/><a data-primary="paths of files relative to container" data-type="indexterm" id="idm46803141829008"/> are all relative to the container’s view of the backing filesystem, which is not the same as the host view. Due to this, if you are on the host system, you may not be able to easily find a specific file from one of your running containers. <a data-primary="paths of files relative to container" data-secondary="docker container exec for process view" data-type="indexterm" id="idm46803141828192"/><a data-primary="processes" data-secondary="debugging containers" data-tertiary="filesystem paths relative to processes" data-type="indexterm" id="idm46803141827216"/><a data-primary="filesystem layers of Linux containers" data-secondary="paths relative to container" data-tertiary="docker container exec for process view" data-type="indexterm" id="idm46803141825984"/><a data-primary="debugging" data-secondary="containers" data-tertiary="filesystem paths relative to processes" data-type="indexterm" id="idm46803141802608"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="exec" data-tertiary="filesystem paths relative to processes" data-type="indexterm" id="idm46803141801376"/>In most cases, it’s probably best to enter the container using <code>docker container exec</code> to look at the files with the same view that the processes inside it have.</p>&#13;
&#13;
<p>It’s possible to run the<a data-primary="GNU debugger (gdb)" data-type="indexterm" id="idm46803141799072"/><a data-primary="gdb (GNU debugger)" data-type="indexterm" id="idm46803141798368"/> GNU debugger (<code>gdb</code>) and other process inspection tools in the same manner as long as you’re <code>root</code> and have proper permissions to do so.</p>&#13;
&#13;
<p>It is worth mentioning here that<a data-primary="debugging" data-secondary="containers" data-tertiary="new debugging container seeing existing container processes" data-type="indexterm" id="idm46803141796096"/><a data-primary="processes" data-secondary="debugging containers" data-tertiary="new debugging container seeing existing container processes" data-type="indexterm" id="idm46803141848464"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="new debugging container seeing existing container processes" data-type="indexterm" id="idm46803141847280"/> it is also possible to run a new debugging container that can see the processes of an existing container and therefore provide additional tools to debug issues. We will discuss the underlying details of this command later, in <a data-type="xref" href="ch11.html#namespaces">“Namespaces”</a> and <a data-type="xref" href="ch11.html#security">“Security”</a>:<a data-primary="Linux" data-secondary="capabilities" data-tertiary="--cap-add" data-tertiary-sortas="cap-add" data-type="indexterm" id="idm46803141844064"/><a data-primary="Linux" data-secondary="capabilities" data-tertiary="SYS_PTRACE" data-type="indexterm" id="idm46803141842544"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="--cap-add" data-tertiary-sortas="cap-add" data-type="indexterm" id="idm46803141841328"/><a data-primary="security" data-secondary="Linux capabilities" data-tertiary="--cap-add" data-tertiary-sortas="cap-add" data-type="indexterm" id="idm46803141763568"/><a data-primary="security" data-secondary="Linux capabilities" data-tertiary="SYS_PTRACE" data-type="indexterm" id="idm46803141762320"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>-ti<code class="w"> </code>--rm<code class="w"> </code>--cap-add<code class="o">=</code>SYS_PTRACE<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>--pid<code class="o">=</code>container:nginx-debug<code class="w"> </code>spkane/train-os:latest<code class="w"> </code>bash<code class="w"/>&#13;
&#13;
<code class="gp">[root@e4b5d2f3a3a7 /]# </code>ps<code class="w"> </code>aux<code class="w"/>&#13;
<code class="go">USER PID %CPU %MEM … TIME COMMAND</code>&#13;
<code class="go">root   1  0.0  0.2 … 0:00 nginx: master process nginx -g daemon off;</code>&#13;
<code class="go">101   30  0.0  0.1 … 0:00 nginx: worker process</code>&#13;
<code class="go">101   31  0.0  0.1 … 0:00 nginx: worker process</code>&#13;
<code class="go">root 136  0.0  0.1 … 0:00 bash</code>&#13;
<code class="go">root 152  0.0  0.2 … 0:00 ps aux</code>&#13;
&#13;
<code class="gp">[root@e4b5d2f3a3a7 /]# </code>strace<code class="w"> </code>-p<code class="w"> </code><code class="m">1</code><code class="w"/>&#13;
<code class="go">strace: Process 1 attached</code>&#13;
<code class="go">rt_sigsuspend([], 8</code>&#13;
&#13;
<code class="go">[Control-C]</code>&#13;
<code class="go">strace: Process 1 detached</code>&#13;
<code class="go">&lt;detached …&gt;</code>&#13;
&#13;
<code class="gp">[root@e4b5d2f3a3a7 /]# </code><code class="nb">exit</code><code class="w"/>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>stop<code class="w"> </code>nginx-debug<code class="w"/></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>You will need to type Ctrl-C to exit the <code>strace</code> process.<a data-primary="exiting via Ctrl-C" data-secondary="strace process" data-type="indexterm" id="idm46803141716192"/><a data-startref="ch07-procinsp" data-type="indexterm" id="idm46803141715248"/><a data-startref="ch07-procinsp2" data-type="indexterm" id="idm46803141714576"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Controlling Processes" data-type="sect1"><div class="sect1" id="controlling_processes">&#13;
<h1>Controlling Processes</h1>&#13;
&#13;
<p>When you have a shell directly<a data-primary="debugging" data-secondary="containers" data-tertiary="controlling processes" data-type="indexterm" id="ch07-contproc"/><a data-primary="processes" data-secondary="debugging containers" data-tertiary="controlling processes" data-type="indexterm" id="ch07-contproc2"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="kill" data-tertiary="--signal" data-tertiary-sortas="signal" data-type="indexterm" id="idm46803141744128"/> on the Docker server, you can, in many ways, treat containerized processes just like any other process running on the system. If you’re remote, you might send signals with <code>docker container kill</code> because it’s expedient. <a data-primary="debugging" data-secondary="containers" data-tertiary="killing a process" data-type="indexterm" id="idm46803141741856"/><a data-primary="processes" data-secondary="debugging containers" data-tertiary="killing a process" data-type="indexterm" id="idm46803141740608"/><a data-primary="kill command" data-type="indexterm" id="idm46803141739392"/>But if you’re already logged in to a Docker server for a debugging session or because the Docker daemon is not responding, you can just <code>kill</code> the process like you would any other.</p>&#13;
&#13;
<p>Unless you kill the top-level process in the container (PID 1 inside the container), killing a process will not terminate the container itself. That <em>might</em> be desirable if you were killing a runaway process, but it might leave the container in an unexpected state. <a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="ls" data-tertiary="reflecting truth about processes" data-type="indexterm" id="idm46803141737376"/>Developers probably expect that all the processes are running if they can see their container in <code>docker container ls</code>. It could also confuse a scheduler like Mesos or Kubernetes or any other system that is health-checking your application. Keep in mind that containers are supposed like a single bundle to the outside world. If you need to kill off something inside the container, it’s best to replace the whole container. Containers offer an abstraction that tools interoperate with. They expect the internals of the container to be predictable and remain consistent.</p>&#13;
&#13;
<p>Terminating processes is not<a data-primary="kill command" data-secondary="passing Unix signals" data-type="indexterm" id="idm46803141734624"/><a data-primary="processes" data-secondary="passing Unix signals via Linux kill" data-type="indexterm" id="idm46803141733648"/> the only reason to send signals. And since containerized processes are just normal processes in many respects, they can be passed the whole array of Unix signals listed in the manpage for the Linux <code>kill</code> command. Many Unix programs will perform special actions when they receive certain predefined signals. <a data-primary="SIGUSR1 signal" data-type="indexterm" id="idm46803141732096"/><a data-primary="Unix signals" data-secondary="SIGUSR1" data-type="indexterm" id="idm46803141731392"/><a data-primary="Linux" data-secondary="Unix signals" data-see="Unix signals" data-type="indexterm" id="idm46803141730448"/>For example, <code>nginx</code> will reopen its logs when receiving a <code>SIGUSR1</code> signal. Using the Linux <code>kill</code> command, you can send any Unix signal to a container process on the local server.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46803141658560">&#13;
<h1>Process Control in Containers</h1>&#13;
<p>Unless you run an orchestrator like Kubernetes that can handle multiple containers in a larger abstraction like a pod, we consider<a data-primary="Linux containers" data-secondary="process control in production containers" data-type="indexterm" id="idm46803141657200"/><a data-primary="processes" data-secondary="process control in production containers" data-type="indexterm" id="idm46803141656352"/><a data-primary="production" data-secondary="process control in production containers" data-type="indexterm" id="idm46803141655408"/><a data-primary="tini" data-type="indexterm" id="idm46803141654432"/><a data-primary="upstart" data-type="indexterm" id="idm46803141653760"/><a data-primary="runit" data-type="indexterm" id="idm46803141653088"/><a data-primary="s6" data-type="indexterm" id="idm46803141652416"/> it a best practice to run some kind of process control in your production containers. Whether it be <a href="https://github.com/krallin/tini"><code>tini</code></a>, <a href="https://upstart.ubuntu.com"><code>upstart</code></a>, <a href="http://smarden.org/runit"><code>runit</code></a>, <a href="https://skarnet.org/software/s6"><code>s6</code></a>, or something else, this approach allows you to treat containers atomically even when they contain more than one process. You should, however, try very hard not to run more than one thing inside your container, to ensure that your container is scoped to handle one well-defined task and does not grow into a monolithic container.</p>&#13;
&#13;
<p>In either case, you will want <code>docker container ls</code> to <a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="ls" data-tertiary="reflecting truth about processes" data-type="indexterm" id="idm46803141647456"/>reflect the presence of the whole container so that you don’t need to worry about whether an individual process inside it has died. If you can assume that the presence of a container and absence of error logs means that things are working, you can treat <code>docker container ls</code> output as the truth about what’s happening on your Docker systems. It also means any orchestration system you use can do the same.</p>&#13;
&#13;
<p>It is also a good idea to ensure that you understand the complete behavior of your preferred process control service, including memory or disk utilization, Unix single handling, and so on, since this can impact your container’s performance and behavior. Generally, the lightest-weight systems are the best.</p>&#13;
</div></aside>&#13;
&#13;
<p>Because containers work just like any other process, it’s important to understand how they can interact with your application in less than helpful ways. <a data-primary="debugging" data-secondary="containers" data-tertiary="processes that spawn background children" data-type="indexterm" id="idm46803141644416"/><a data-primary="Jenkins build system" data-secondary="daemons forking into background" data-type="indexterm" id="idm46803141643136"/>There are some special needs in a container for processes that spawn background children—that is, anything that forks and daemonizes so the parent no longer manages the child process lifecycle. Jenkins build containers are one common example where people see this go wrong. <a data-primary="processes" data-secondary="PID 1" data-type="indexterm" id="idm46803141642048"/>When daemons fork into the background, they become children of PID 1 on Unix systems. Process 1 is special and is usually an <code>init</code> process of some kind.</p>&#13;
&#13;
<p>PID 1 is responsible for making sure that children are reaped. In your container, by default, your main process will be PID 1. Since you probably won’t be handling the reaping of children from your application, you can end up with zombie processes in your container. There are a few solutions to this problem. The first is to run an init system in the container of your own choosing—​one that is capable of handling PID 1 responsibilities. <code>s6</code>, <code>runit</code>, and others described in the preceding note can be easily used inside the container.</p>&#13;
&#13;
<p>But Docker itself provides an even simpler option that solves just this one case without taking on all the capabilities of a full init system. <a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="--init" data-tertiary-sortas="init" data-type="indexterm" id="idm46803141638352"/><a data-primary="Dockerfiles" data-primary-sortas="docker-a" data-secondary="CMD instruction" data-tertiary="--init flag of docker container run" data-type="indexterm" id="idm46803141636560"/>If you provide the <code>--init</code> flag to <code>docker container run</code>, Docker will launch a very small init process based on the <a href="https://github.com/krallin/tini"><code>tini</code> project</a> that will act as PID 1 inside the container on startup. Whatever you specify in your <em>Dockerfile</em> as the <code>CMD</code> is passed to <code>tini</code> and otherwise works in the same way you would expect. It does, however, replace anything you might have in the <code>ENTRYPOINT</code> section of your <em>Dockerfile</em>.</p>&#13;
&#13;
<p>When you launch a Linux container without the <code>--init</code> flag, you get something like this in your process list:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-it<code class="w"> </code>alpine:3.16<code class="w"> </code>sh<code class="w"/>&#13;
<code class="go">/ # ps -ef</code>&#13;
&#13;
<code class="go">PID   USER     TIME   COMMAND</code>&#13;
<code class="go">    1 root       0:00 sh</code>&#13;
<code class="go">    5 root       0:00 ps -ef</code>&#13;
&#13;
<code class="go">/ # exit</code></pre>&#13;
&#13;
<p>Notice that in this case, the <code>CMD</code> we launched is PID 1. That means it is responsible for child reaping. If we are launching a container where that is important, we can pass <code>--init</code> to make sure that when the parent process exits, children are reaped:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-it<code class="w"> </code>--init<code class="w"> </code>alpine:3.16<code class="w"> </code>sh<code class="w"/>&#13;
<code class="go">/ # ps -ef</code>&#13;
&#13;
<code class="go">PID   USER     TIME   COMMAND</code>&#13;
<code class="go">    1 root       0:00 /sbin/docker-init -- sh</code>&#13;
<code class="go">    5 root       0:00 sh</code>&#13;
<code class="go">    6 root       0:00 ps -ef</code>&#13;
&#13;
<code class="go">/ # exit</code></pre>&#13;
&#13;
<p>Here, you can see that the PID 1 process is <code>/sbin/docker-init</code>. That has in turn launched the shell binary for us as specified on the command line. Because we now have an init system inside the container, the PID 1 responsibilities fall to it rather than the command we used to invoke the container. In most cases, this is what you want. You may not need an init system, but it’s small enough that you should consider having at least <code>tini</code> inside your containers in production.</p>&#13;
&#13;
<p>In general, you probably only need an init process inside your container if you are running multiple parent processes or you have processes that do not respond to Unix signals properly.<a data-startref="ch07-contproc" data-type="indexterm" id="idm46803141561840"/><a data-startref="ch07-contproc2" data-type="indexterm" id="idm46803141561200"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Network Inspection" data-type="sect1"><div class="sect1" id="net_inspect">&#13;
<h1>Network Inspection</h1>&#13;
&#13;
<p>Compared to process inspection,<a data-primary="debugging" data-secondary="containers" data-tertiary="network inspection" data-type="indexterm" id="ch07-net"/><a data-primary="networking" data-secondary="debugging containers" data-type="indexterm" id="ch07-net2"/> debugging containerized applications at the network level can be more complicated. Unlike traditional processes running on the host, Linux containers can be connected to the network in multiple ways. If you are running the default setup, as the vast majority of people are, then your containers are all connected to the network via the default bridge network that Docker creates. This is a virtual network where the host is the gateway to the rest of the world. We can inspect these virtual networks with the tooling that ships with Docker. <a data-primary="docker network" data-primary-sortas="docker-z" data-secondary="ls" data-type="indexterm" id="idm46803141555696"/>You can get it to show you which networks exist by calling the <code>docker network ls</code> command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>network<code class="w"> </code>ls<code class="w"/>&#13;
&#13;
<code class="go">NETWORK ID     NAME      DRIVER    SCOPE</code>&#13;
<code class="go">f9685b50d57c   bridge    bridge    local</code>&#13;
<code class="go">8acae1680cbd   host      host      local</code>&#13;
<code class="go">fb70d67499d3   none      null      local</code></pre>&#13;
&#13;
<p>Here we can see the<a data-primary="networking" data-secondary="default bridge network" data-type="indexterm" id="idm46803141548016"/><a data-primary="networking" data-secondary="host network mode" data-type="indexterm" id="idm46803141547168"/> default bridge network, the host network, which is for any containers running in <code>host</code> network mode (see <a data-type="xref" href="ch11.html#host_networking">“Host networking”</a>), and the none network, which disables network access entirely for the container. If you use <code>docker compose</code> or other orchestration tools, they may create additional networks here with different names.</p>&#13;
&#13;
<p>But seeing which networks exist doesn’t make it any easier to see what’s on those networks. <a data-primary="docker network" data-primary-sortas="docker-z" data-secondary="inspect" data-type="indexterm" id="idm46803141525024"/>So, you can see which containers are attached to any particular named network with the <code>docker network inspect</code> command. This produces a fair amount of output. It shows you all of the containers that are attached to the specified network and a number of details about the network itself. Let’s take a look at the default bridge network:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>network<code class="w"> </code>inspect<code class="w"> </code>bridge<code class="w"/></pre>&#13;
&#13;
<pre class="nomargin" data-code-language="json" data-type="programlisting"><code class="p">[</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"bridge"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Driver"</code><code class="p">:</code><code class="w"> </code><code class="s2">"bridge"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"EnableIPv6"</code><code class="p">:</code><code class="w"> </code><code class="kc">false</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Containers"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"69e9…c87c"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">"Name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"cadvisor"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">"IPv4Address"</code><code class="p">:</code><code class="w"> </code><code class="s2">"172.17.0.2/16"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">"IPv6Address"</code><code class="p">:</code><code class="w"> </code><code class="s2">""</code><code class="w"/>&#13;
<code class="w">            </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"a2a8…e163"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">"Name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"nginx-debug"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">"IPv4Address"</code><code class="p">:</code><code class="w"> </code><code class="s2">"172.17.0.3/16"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">"IPv6Address"</code><code class="p">:</code><code class="w"> </code><code class="s2">""</code><code class="w"/>&#13;
<code class="w">            </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Options"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"com.docker.network.bridge.default_bridge"</code><code class="p">:</code><code class="w"> </code><code class="s2">"true"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"com.docker.network.bridge.host_binding_ipv4"</code><code class="p">:</code><code class="w"> </code><code class="s2">"0.0.0.0"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">"com.docker.network.bridge.name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"docker0"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Labels"</code><code class="p">:</code><code class="w"> </code><code class="p">{}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">]</code><code class="w"/></pre>&#13;
&#13;
<p>We’ve excluded some of the details here to shrink the output a bit. But what we can see is that there are two containers on the bridge network, and they are attached to the <code>docker0</code> bridge on the host. <a data-primary="IP addresses" data-secondary="docker network inspect command" data-type="indexterm" id="idm46803141425408"/>We can also see the IP addresses of each container (<code>IPv4Address</code> and <code>IPv6Address</code>) and the host network address they are bound to (<code>host_binding_ipv4</code>). This is useful when you are trying to understand the internal structure of the bridged network. If you have containers on different networks, they may not have connectivity to one another, depending on how the networks were configured.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>In general, we recommend leaving<a data-primary="networking" data-secondary="default approach recommended" data-type="indexterm" id="idm46803141303472"/> your containers on the default bridge network until you have a good reason not to or are running <code>docker compose</code> or a scheduler that manages container networks on its own. In addition, naming your containers in some identifiable way helps here because we can’t see the image information. The name and ID are the only references we have in this output that can tie us back to a <code>docker container ls</code> listing. Some schedulers don’t do a good job of naming containers, which is too bad because it can be really helpful for debugging.</p>&#13;
</div>&#13;
&#13;
<p>As we’ve seen, containers<a data-primary="IP addresses" data-secondary="containers normally have their own" data-type="indexterm" id="idm46803141300944"/> will normally have their own network stack and their own IP address, unless they are running in host networking mode, which we will discuss further in <a data-type="xref" href="ch11.html#docker_net">“Networking”</a>. But what about when we look at them from the host machine itself? <a data-primary="netstat command" data-secondary="-an" data-type="indexterm" id="idm46803141299072"/>Because containers have their own network and addresses, they won’t show up in all <code>netstat</code> output on the host. But we know that the ports you map to your containers are bound to the host.</p>&#13;
&#13;
<p class="pagebreak-before">Running <code>netstat -an</code> on the Docker server works as expected, as shown here:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>sudo<code class="w"> </code>netstat<code class="w"> </code>-an<code class="w"/>&#13;
&#13;
<code class="go">Active Internet connections (servers and established)</code>&#13;
<code class="go">Proto Recv-Q Send-Q Local Address           Foreign Address        State</code>&#13;
<code class="go">tcp        0      0 0.0.0.0:8080            0.0.0.0:*              LISTEN</code>&#13;
<code class="go">tcp        0      0 127.0.0.53:53           0.0.0.0:*              LISTEN</code>&#13;
<code class="go">tcp        0      0 0.0.0.0:22              0.0.0.0:*              LISTEN</code>&#13;
<code class="go">tcp        0      0 192.168.15.158:22       192.168.15.120:63920   ESTABLISHED</code>&#13;
<code class="go">tcp6       0      0 :::8080                 :::*                   LISTEN</code>&#13;
<code class="go">tcp6       0      0 :::22                   :::*                   LISTEN</code>&#13;
<code class="go">udp        0      0 127.0.0.53:53           0.0.0.0:*</code>&#13;
<code class="go">udp        0      0 192.168.15.158:68       0.0.0.0:*</code>&#13;
<code class="go">raw6       0      0 :::58                   :::*                   7</code>&#13;
<code class="go">…</code></pre>&#13;
&#13;
<p>Here we can see all of the interfaces that we’re listening on. Our container is bound to port <code>8080</code> on IP address <code>0.0.0.0</code>. That shows up. But what happens when we ask <code>netstat</code> to show us the process name that’s bound to the port?<a data-primary="netstat command" data-secondary="-anp" data-type="indexterm" id="idm46803141265408"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>sudo<code class="w"> </code>netstat<code class="w"> </code>-anp<code class="w"/>&#13;
&#13;
<code class="go">Active Internet connections (servers and established)</code>&#13;
<code class="go">Proto  … Local Address           Foreign Address      … PID/Program name</code>&#13;
<code class="go">tcp    … 0.0.0.0:8080            0.0.0.0:*            … 1516/docker-proxy</code>&#13;
<code class="go">tcp    … 127.0.0.53:53           0.0.0.0:*            … 692/systemd-resolve</code>&#13;
<code class="go">tcp    … 0.0.0.0:22              0.0.0.0:*            … 780/sshd: /usr/sbin</code>&#13;
<code class="go">tcp    … 192.168.15.158:22       192.168.15.120:63920 … 1348/sshd: vagrant</code>&#13;
<code class="go">tcp6   … :::8080                 :::*                 … 1522/docker-proxy</code>&#13;
<code class="go">tcp6   … :::22                   :::*                 … 780/sshd: /usr/sbin</code>&#13;
<code class="go">udp    … 127.0.0.53:53           0.0.0.0:*            … 692/systemd-resolve</code>&#13;
<code class="go">udp    … 192.168.15.158:68       0.0.0.0:*            … 690/systemd-network</code>&#13;
<code class="go">raw6   … :::58                   :::*                 … 690/systemd-network</code></pre>&#13;
&#13;
<p>We see the same output, but notice<a data-primary="ports for Docker networking" data-secondary="docker-proxy" data-type="indexterm" id="idm46803141283840"/> what is bound to the port: <code>docker-proxy</code>. That’s because, in its default configuration, Docker has a proxy written in Go that sits between all of the containers and the outside world. That means that when we look at this output, all containers running via Docker will be associated with <code>docker-proxy</code>. Notice that there is no clue here about which specific container <code>docker-proxy</code> is handling. Fortunately, <code>docker container ls</code> shows us which containers are bound to which ports, so this isn’t a big deal. But it’s not obvious, and you probably want to be aware of it before you’re debugging a production failure. Still, passing the <code>p</code> flag to <code>netstat</code> is helpful in identifying which ports are tied to containers.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’re using host networking in your container, then this layer is skipped. There is no <code>docker-proxy</code>, and the process in the container can bind to the port directly. It also shows up as a normal process in <code>netstat -anp</code> output.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Other network inspection commands<a data-primary="tcpdump command" data-type="indexterm" id="idm46803141195616"/> work largely as expected, including <code>tcpdump</code>, but it’s important to remember that <code>docker-proxy</code> is there, in between the host’s network interface and the container, and that the containers have their own network interfaces on a virtual network.<a data-startref="ch07-net" data-type="indexterm" id="idm46803141193824"/><a data-startref="ch07-net2" data-type="indexterm" id="idm46803141193120"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Image History" data-type="sect1"><div class="sect1" id="idm46803141559936">&#13;
<h1>Image History</h1>&#13;
&#13;
<p>When you’re building and deploying<a data-primary="debugging" data-secondary="containers" data-tertiary="image history" data-type="indexterm" id="idm46803141190912"/> a single container, it’s easy to keep track of where it came from and what images it’s sitting on top of. But this rapidly becomes unmanageable when you’re shipping many containers with images that are built and maintained by different teams. How can you tell what layers are actually underneath the one your container is running on? Your container’s image tag hopefully makes it clear which build of your application you’re running, but the image tag doesn’t reveal anything about the image layers that your application is built on.<a data-primary="docker image" data-primary-sortas="docker-z" data-secondary="history" data-tertiary="debugging containers" data-type="indexterm" id="idm46803141189536"/> <code>docker image history</code> does just that. You can see each layer that exists in the inspected image, the sizes of each layer, and the commands that were used to build it:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>image<code class="w"> </code><code class="nb">history</code><code class="w"> </code>redis:latest<code class="w"/>&#13;
&#13;
<code class="go">IMAGE        … CREATED BY                                      SIZE    COMMENT</code>&#13;
<code class="go">e800a8da9469 … /bin/sh -c #(nop)  CMD ["redis-server"]         0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop)  EXPOSE 6379                  0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop)  ENTRYPOINT ["docker-entry…   0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop) COPY file:e873a0e3c13001b5…   661B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop) WORKDIR /data                 0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop)  VOLUME [/data]               0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c mkdir /data &amp;&amp; chown redis:redis …   0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c set -eux;   savedAptMark="$(apt-m…   32.4MB</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop)  ENV REDIS_DOWNLOAD_SHA=f0…   0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop)  ENV REDIS_DOWNLOAD_URL=ht…   0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop)  ENV REDIS_VERSION=7.0.4      0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c set -eux;  savedAptMark="$(apt-ma…   4.06MB</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop)  ENV GOSU_VERSION=1.14        0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c groupadd -r -g 999 redis &amp;&amp; usera…   331kB</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop)  CMD ["bash"]                 0B</code>&#13;
<code class="go">&lt;missing&gt;    … /bin/sh -c #(nop) ADD file:6039adfbca55ed34a…   74.3MB</code></pre>&#13;
&#13;
<p>Using <code>docker image history</code> can be useful, for example, when you are trying to determine why the size of the final image is much larger than expected. The layers are listed in order, with the first one at the bottom of the list and the last one at the top.</p>&#13;
&#13;
<p>Here we can see that the command output has been truncated in a few cases. <a data-primary="docker image" data-primary-sortas="docker-z" data-secondary="history" data-tertiary="--no-trunc" data-tertiary-sortas="no-trunc" data-type="indexterm" id="idm46803141147152"/>For long commands, adding the <code>--no-trunc</code> option to the <code>docker image history</code> command will let you see the complete command that was used to build each layer. Just be aware that <code>--no-trunc</code> will make the output much larger and more difficult to visually scan in most cases.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inspecting a Container" data-type="sect1"><div class="sect1" id="idm46803141143808">&#13;
<h1>Inspecting a Container</h1>&#13;
&#13;
<p>In <a data-type="xref" href="ch04.html#docker_images">Chapter 4</a>, we showed<a data-primary="debugging" data-secondary="containers" data-tertiary="inspecting a container" data-type="indexterm" id="idm46803141141152"/><a data-primary="Linux containers" data-secondary="inspecting a container" data-tertiary="debugging containers" data-type="indexterm" id="idm46803141139904"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="inspect" data-tertiary="debugging containers" data-type="indexterm" id="idm46803141137296"/><a data-primary="hashes" data-secondary="container ID hash" data-tertiary="displaying via docker container inspect" data-type="indexterm" id="idm46803141135808"/><a data-primary="hashes" data-secondary="container ID hash" data-tertiary="displaying via docker container ls" data-type="indexterm" id="idm46803141134624"/><a data-primary="hashes" data-secondary="container ID hash" data-tertiary="long form" data-type="indexterm" id="idm46803141133440"/><a data-primary="hashes" data-secondary="container ID hash" data-tertiary="short form" data-type="indexterm" id="idm46803141132224"/> you how to read the <code>docker container inspect</code> output to see how a container is configured. But underneath that is a directory on the host’s disk that is dedicated to the container. Usually this is <em>/var/lib/docker/containers</em>. If you look at that directory, it contains very long SHA hashes, as shown here:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>sudo<code class="w"> </code>ls<code class="w"> </code>/var/lib/docker/containers<code class="w"/>&#13;
&#13;
<code class="go">106ead0d55af55bd803334090664e4bc821c76dadf231e1aab7798d1baa19121</code>&#13;
<code class="go">28970c706db0f69716af43527ed926acbd82581e1cef5e4e6ff152fce1b79972</code>&#13;
<code class="go">3c4f916619a5dfc420396d823b42e8bd30a2f94ab5b0f42f052357a68a67309b</code>&#13;
<code class="go">589f2ad301381b7704c9cade7da6b34046ef69ebe3d6929b9bc24785d7488287</code>&#13;
<code class="go">959db1611d632dc27a86efcb66f1c6268d948d6f22e81e2a22a57610b5070b4d</code>&#13;
<code class="go">a1e15f197ea0996d31f69c332f2b14e18b727e53735133a230d54657ac6aa5dd</code>&#13;
<code class="go">bad35aac3f503121abf0e543e697fcade78f0d30124778915764d85fb10303a7</code>&#13;
<code class="go">bc8c72c965ebca7db9a2b816188773a5864aa381b81c3073b9d3e52e977c55ba</code>&#13;
<code class="go">daa75fb108a33793a3f8fcef7ba65589e124af66bc52c4a070f645fffbbc498e</code>&#13;
<code class="go">e2ac800b58c4c72e240b90068402b7d4734a7dd03402ee2bce3248cc6f44d676</code>&#13;
<code class="go">e8085ebc102b5f51c13cc5c257acb2274e7f8d1645af7baad0cb6fe8eef36e24</code>&#13;
<code class="go">f8e46faa3303d93fc424e289d09b4ffba1fc7782b9878456e0fe11f1f6814e4b</code></pre>&#13;
&#13;
<p>That’s a bit daunting. But those are just the container IDs in long form. If you want to look at the configuration for a particular container, you just need to use <code>docker container ls</code> to find its short ID, and then find the directory that matches:<a data-primary="filesystem layers of Linux containers" data-secondary="directory corresponding to a container" data-type="indexterm" id="idm46803141124000"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>ls<code class="w"/>&#13;
&#13;
<code class="go">CONTAINER ID   IMAGE                                   COMMAND              …</code>&#13;
<code class="go">c58bfeffb9e6   gcr.io/cadvisor/cadvisor:v0.44.1-test   "/usr/bin/cadvisor…" …</code></pre>&#13;
&#13;
<p>You can view the short ID from <code>docker container ls</code>, then match it to the <code>ls /var/lib/docker/containers</code> output to see that you want the directory beginning with <code>c58bfeffb9e6</code>. Command-line tab completion is helpful here. If you need exact matching, you can do a <code>docker container inspect c58bfeffb9e6</code> and grab the long ID from the output. This directory contains some pretty interesting files related to the container:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code><code class="nb">cd</code><code class="w"> </code>/var/lib/docker/containers/<code class="se">\</code>&#13;
c58bfeffb9e6e607f3aacb4a06ca473535bf9588450f08be46baa230ab43f1d6<code class="w"/>&#13;
&#13;
<code class="gp">$ </code>ls<code class="w"> </code>-la<code class="w"/>&#13;
&#13;
<code class="go">total 48</code>&#13;
<code class="go">drwx--x---  4 root root 4096 Aug 20 10:38 .</code>&#13;
<code class="go">drwx--x--- 30 root root 4096 Aug 20 10:25 ..</code>&#13;
<code class="go">-rw-r-----  1 root root  635 Aug 20 10:34 c58bf…f1d6-json.log</code>&#13;
<code class="go">drwx------  2 root root 4096 Aug 20 10:24 checkpoints</code>&#13;
<code class="go">-rw-------  1 root root 4897 Aug 20 10:38 config.v2.json</code>&#13;
<code class="go">-rw-r--r--  1 root root 1498 Aug 20 10:38 hostconfig.json</code>&#13;
<code class="go">-rw-r--r--  1 root root   13 Aug 20 10:24 hostname</code>&#13;
<code class="go">-rw-r--r--  1 root root  174 Aug 20 10:24 hosts</code>&#13;
<code class="go">drwx--x---  2 root root 4096 Aug 20 10:24 mounts</code>&#13;
<code class="go">-rw-r--r--  1 root root  882 Aug 20 10:24 resolv.conf</code>&#13;
<code class="go">-rw-r--r--  1 root root   71 Aug 20 10:24 resolv.conf.hash</code></pre>&#13;
&#13;
<p>As we discussed in <a data-type="xref" href="ch05.html#docker_containers">Chapter 5</a>, this directory contains some files that are bind-mounted directly into your container, like <em>hosts</em>, <em>resolv.conf</em>, and <em>hostname</em>. <a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="logs" data-tertiary="directory containing" data-type="indexterm" id="idm46803140960880"/>If you are running the default logging mechanism, then this directory is also where Docker stores the JSON file containing the log that is shown with the <code>docker container logs</code> command, the JSON configuration that backs the <code>docker container inspect</code> output (<em>config.v2.json</em>), and the networking configuration for the container (<em>hostconfig.json</em>). The <em>resolv.conf.hash</em> file is used by Docker to determine when the container’s file has diverged from the current one on the host so it can be updated.</p>&#13;
&#13;
<p>This directory can also be really helpful in the event of severe failure. Even if we’re not able to enter the container, or if <code>docker</code> is not responding, we can look at how the container was configured. It’s also pretty useful to understand where those files are mounted from inside the container. Keep in mind that it’s not a good idea to modify these files. Docker expects them to contain reality, and if you alter that reality, you’re asking for trouble. But it’s another avenue for information on what’s happening in your container.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Filesystem Inspection" data-type="sect1"><div class="sect1" id="idm46803140993584">&#13;
<h1>Filesystem Inspection</h1>&#13;
&#13;
<p>Docker, regardless of the backend<a data-primary="debugging" data-secondary="containers" data-tertiary="filesystem inspection" data-type="indexterm" id="idm46803140992176"/><a data-primary="filesystem layers of Linux containers" data-secondary="debugging containers" data-type="indexterm" id="idm46803140990928"/> actually in use, has a layered filesystem that allows it to track the changes in any given container. This is how the images are assembled when you do a build, but it is also useful when you’re trying to figure out if a Linux container has changed anything and, if so, what. A common problem with containerized applications is that they may continue to write things into the container’s filesystem. Normally, you don’t want your containers to do that, to the extent possible, and it can help debugging to figure out if your processes have been writing into the container. Sometimes this is helpful in turning up stray logfiles that exist in the container as well. As with most of the core tools, this kind of inspection is built into the <code>docker</code> command-line tooling and is also exposed via the API. Let’s take a look at what this shows us. Let’s launch a quick container and use its name to explore this:<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="diff for filesystem inspection" data-type="indexterm" id="idm46803140989504"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>--name<code class="w"> </code>nginx-fs<code class="w"> </code>nginx:latest<code class="w"/>&#13;
<code class="go">1272b950202db25ee030703515f482e9ed576f8e64c926e4e535ba11f7536cc4</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>diff<code class="w"> </code>nginx-fs<code class="w"/>&#13;
<code class="go">C /run</code>&#13;
<code class="go">A /run/nginx.pid</code>&#13;
<code class="go">C /var</code>&#13;
<code class="go">C /var/cache</code>&#13;
<code class="go">C /var/cache/nginx</code>&#13;
<code class="go">A /var/cache/nginx/scgi_temp</code>&#13;
<code class="go">A /var/cache/nginx/uwsgi_temp</code>&#13;
<code class="go">A /var/cache/nginx/client_temp</code>&#13;
<code class="go">A /var/cache/nginx/fastcgi_temp</code>&#13;
<code class="go">A /var/cache/nginx/proxy_temp</code>&#13;
<code class="go">C /etc</code>&#13;
<code class="go">C /etc/nginx</code>&#13;
<code class="go">C /etc/nginx/conf.d</code>&#13;
<code class="go">C /etc/nginx/conf.d/default.conf</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>stop<code class="w"> </code>nginx-fs<code class="w"/>&#13;
<code class="go">nginx-fs</code></pre>&#13;
&#13;
<p>Each line begins with either <code>A</code> or <code>C</code>, which is shorthand for <em>added</em> or <em>changed</em>, respectively. We can see that this container is running <code>nginx</code>, that the <code>nginx</code> configuration file has been written to, and that some temporary files have been created in a new directory named <code>/var/cache/nginx</code>. Being able to find out how the container filesystem is being used can be very useful when you are trying to optimize and harden your container’s filesystem usage.</p>&#13;
&#13;
<p>Further detailed inspection requires exploring the container with <code>docker container export</code>, <code>docker container exec</code>, or <code>nsenter</code> and the like, to see exactly what is in the filesystem. But <code>docker container diff</code> gives you a good place to start.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Wrap-Up" data-type="sect1"><div class="sect1" id="idm46803140908576">&#13;
<h1>Wrap-Up</h1>&#13;
&#13;
<p>At this point, you should have a good idea of how to deploy and debug individual containers in development and production, but how do you start to scale this for larger application ecosystems? In the next chapter, we’ll take a look at one of the simpler Docker orchestration tools: Docker Compose. This tool is a nice bridge between a single Linux container and a production orchestration system. It delivers a lot of value in development environments and throughout the DevOps pipeline.</p>&#13;
</div></section>&#13;
</div></section></body></html>