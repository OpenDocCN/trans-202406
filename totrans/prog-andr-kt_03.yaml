- en: Chapter 3\. Android Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. Android基础知识
- en: 'The first two chapters of this book were a whirlwind review of the Kotlin language.
    This chapter will review the environment in which we will use Kotlin: Android.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的前两章是对Kotlin语言的快速回顾。本章将审视我们将使用Kotlin的环境：Android。
- en: Android is an operating system, like Windows and MacOS. Unlike those two systems,
    Android is a Linux-based OS, like Ubuntu and Red Hat. Unlike Ubuntu and Red Hat,
    though, Android has been very heavily optimized for mobile devices—battery-powered
    mobile devices, in particular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android是一个像Windows和MacOS一样的操作系统。但与这两个系统不同的是，Android是基于Linux的操作系统，就像Ubuntu和Red
    Hat一样。不过，与Ubuntu和Red Hat不同的是，Android已经针对移动设备进行了非常大量的优化，特别是针对使用电池供电的移动设备。
- en: The most significant of these optimizations concerns what it means to be an
    application. In particular, as we will see, Android apps have much more in common
    with web applications than they do with familiar desktop applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优化中最重要的一项是什么意味着成为一个应用程序。特别是正如我们将看到的那样，Android应用程序与传统的桌面应用程序相比，与Web应用程序有更多的共同点。
- en: But we’ll get to that in a moment. First, let’s look in a little more detail
    at the Android environment. We’ll look at the operating system as a stack—kind
    of a layer cake.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们稍后会详细讨论这个问题。首先，让我们更详细地看一下Android环境。我们将操作系统视为一个堆栈——一种层层叠加的结构。
- en: The Android Stack
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android堆栈
- en: 'Figure 3-1 shows one way of looking at Android: as a stack of components. Each
    layer in the stack has a specific task and provides specific services; each uses
    the features of the layers beneath it.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-1展示了看待Android的一种方式：作为一堆组件的堆栈。堆栈中的每一层都有特定的任务并提供特定的服务；每一层都利用了其下层的功能。
- en: 'Walking up from the bottom, the layers are:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从底部向上走，层次是：
- en: Hardware
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件
- en: Kernel
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核
- en: System services
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统服务
- en: Android Runtime Environment
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android运行时环境
- en: Applications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: '![pawk 0301](assets/pawk_0301.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![pawk 0301](assets/pawk_0301.png)'
- en: Figure 3-1\. The Android stack.
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1. Android堆栈。
- en: Hardware
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 硬件
- en: 'Beneath the Android stack, of course, is hardware: a piece of warm silicon.
    While the hardware is not part of the Android stack, it is important to recognize
    that the hardware for which Android was designed imposes some fairly tough constraints
    on the system. By far, the most significant of these constraints is power. Most
    common operating systems just assume an infinite power supply. The Android systems
    cannot.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Android堆栈下面是硬件：一块温暖的硅片。虽然硬件不是Android堆栈的一部分，但重要的是要认识到Android设计的硬件对系统施加了一些相当严格的限制。其中最重要的限制是电力。大多数常见的操作系统假定有无限的电源供应，而Android系统不能这样假定。
- en: Kernel
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内核
- en: 'The Android operating system depends on the Linux kernel. A kernel is responsible
    for providing the basic services that developers expect: a filesystem, threads
    and processes, network access, interfaces to hardware devices, and so on. Linux
    is free and open source and, thus, a popular choice for hardware and device manufacturers.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统依赖于Linux内核。内核负责提供开发人员所期望的基本服务：文件系统、线程和进程、网络访问、与硬件设备的接口等。Linux是自由开源的，因此是硬件和设备制造商的热门选择。
- en: 'Because it is based on Linux, Android bears some similarity to the common Linux
    distributions: Debian, Centos, etc. In the layers above the kernel, however, the
    similarity diminishes. While most common Linux distributions are based heavily
    on the GNU family of system software (and should, properly, be called GNU/Linux),
    Android’s system software is quite a bit different. It is, in general, not possible
    to run common Linux applications directly on an Android system.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它基于Linux，Android与常见的Linux发行版（如Debian、Centos等）有些相似。然而，在内核以上的层次，相似性减弱了。尽管大多数常见的Linux发行版都严重依赖GNU家族的系统软件（并且应该适当地称为GNU/Linux），但Android的系统软件却有很大不同。一般来说，不可能直接在Android系统上运行常见的Linux应用程序。
- en: System Services
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统服务
- en: The system services layer is big and complex. It includes a wide variety of
    utilities, from code that runs as part of the kernel (drivers or kernel modules),
    and long-running applications that manage various housekeeping tasks (daemons),
    to libraries that implement standard functions like cryptography and media presentation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 系统服务层非常庞大且复杂。它包括各种实用程序，从作为内核的一部分运行的代码（驱动程序或内核模块），到长时间运行的管理各种日常任务的应用程序（守护程序），再到实现标准功能如加密和媒体呈现的库。
- en: This layer includes several system services that are unique to Android. Among
    them are Binder, Android’s essential interprocess communication system; ART, which
    has replaced Dalvik as Android’s analog of the Java VM; and Zygote, Android’s
    application container.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层包括几个 Android 特有的系统服务。其中包括 Binder，Android 的基本进程间通信系统；ART，作为 Android 的 Java
    虚拟机的类比已取代 Dalvik；以及 Zygote，Android 的应用程序容器。
- en: Android Runtime Environment
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android 运行时环境
- en: 'The layer above the system services is the implementation of the *Android Runtime
    Environment*. The Android Runtime Environment is the collection of libraries that
    you use from your application by including them with `import` statements: *android.view*,
    *android.os*, and so on. They are the services provided by the layers below, made
    available to your application. They are interesting because they are implemented
    using two languages: usually Java and C or C++.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 系统服务上面的一层是 *Android 运行时环境* 的实现。Android 运行时环境是你通过 `import` 语句包含在应用程序中的库集合：*android.view*、*android.os*
    等等。它们是底层提供的服务，供应用程序使用。这些库的有趣之处在于它们通常是用两种语言实现的：Java 和 C 或 C++。
- en: The part of the implementation that your application imports is likely to be
    written in Java. The Java code, however, uses the *Java Native Interface* (JNI)
    to invoke native code, usually written in C or C++. It is the native code that
    actually interacts with the system services.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序导入的实现部分可能是用 Java 编写的。然而，Java 代码使用 *Java Native Interface* (JNI) 调用本地代码，通常是用
    C 或 C++ 编写的。实际上是本地代码与系统服务进行交互。
- en: Applications
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序
- en: Finally, at the top of the stack are Android applications. Applications, in
    the Android universe, are actually part of the stack. They are made up of individually
    addressable components that other applications can “call.” The Dialer, Camera,
    and Contacts programs are all examples of Android applications that are used as
    services by other applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在堆栈顶部是 Android 应用程序。在 Android 世界中，应用程序实际上是堆栈的一部分。它们由各个可寻址的组件组成，其他应用程序可以“调用”这些组件。拨号器、相机和联系人程序都是其他应用程序使用的
    Android 应用程序示例。
- en: This is the environment in which an Android application executes. So let’s get
    back to looking at the anatomy of an application itself.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Android 应用程序执行的环境。让我们重新审视应用程序本身的解剖。
- en: The Android Application Environment
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 应用环境
- en: Android applications are programs translated from a source language (Java or
    Kotlin) into a transportable intermediate language, DEX. The DEX code is installed
    on a device and interpreted by the ART VM, when the application is run.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用程序是从源语言（Java 或 Kotlin）翻译成可传输的中间语言 DEX 的程序。当应用程序运行时，DEX 代码安装在设备上，并由
    ART 虚拟机解释。
- en: Nearly every developer is familiar with the standard application environment.
    The operating system creates a “process”—a sort of virtual computer that appears
    to belong entirely to the application. The system runs the application code in
    the process, where it appears to have its own memory, its own processors, and
    so on, completely independent of other applications that might be running on the
    same device. The application runs until it, itself, decides to stop.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个开发者都熟悉标准的应用程序环境。操作系统创建一个“进程”——一种虚拟计算机，似乎完全属于该应用程序。系统在进程中运行应用程序代码，它看起来拥有自己的内存、处理器等等，完全独立于可能在同一设备上运行的其他应用程序。应用程序运行，直到它自己决定停止。
- en: 'That’s not how Android works. Android doesn’t really think in terms of applications.
    For instance, Android apps don’t contain the equivalent of Java’s `public static
    void main` method, the method used to start typical Java applications. Instead,
    Android apps are libraries of components. The Android runtime, Zygote, manages
    processes, lifecycles, and so on. It calls an application’s components only when
    it needs them. This makes Android apps, as hinted earlier, very similar to web
    applications: they are an assemblage of components deployed into a container.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Android 并不是按照应用程序的概念工作的。例如，Android 应用程序没有类似于 Java 的 `public static void main`
    方法，用于启动典型的 Java 应用程序。相反，Android 应用程序是组件的库。Zygote 运行时管理进程、生命周期等等。只有在需要时，它才调用应用程序的组件。这使得
    Android 应用程序非常类似于 Web 应用程序：它们是部署到容器中的组件的集合。
- en: The other end of the lifecycle, terminating an application, is perhaps even
    more interesting. On other operating systems, abruptly stopping an application
    (`kill -9` or “Force Quit”) is something that happens rarely and only when the
    application misbehaves. On Android, it is the most common way for an application
    to be terminated. Nearly every running app will eventually be terminated abruptly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期的另一端，即终止应用程序，可能更加有趣。在其他操作系统上，突然停止应用程序（`kill -9`或“强制退出”）很少发生，只有在应用程序行为不当时才会发生。在Android上，这是终止应用程序的最常见方式。几乎每个正在运行的应用程序最终都会突然终止。
- en: As with most web app frameworks, components are implemented as subclasses of
    template base classes. Component subclasses override the methods that are called
    by the framework in order to provide application-specific behavior. Often, the
    superclass has important work to do when one of these template methods is called.
    In those cases, the overriding method in the subclass must call the superclass
    method that it overrides.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数Web应用程序框架一样，组件实现为模板基类的子类。组件子类覆盖了框架调用的方法，以提供特定于应用程序的行为。通常情况下，当这些模板方法之一被调用时，超类有重要的工作要做。在这些情况下，子类中覆盖的方法必须调用其覆盖的超类方法。
- en: 'Android supports four types of components:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持四种类型的组件：
- en: Activity
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动
- en: Service
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Broadcast receiver
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播接收器
- en: Content provider
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容提供者
- en: 'Just as in a web app, the implementations of these components must be registered
    in a manifest: an XML file. Android’s manifest file is called, perhaps unsurprisingly,
    *AndroidManifest.xml*. The Android container parses this file as part of loading
    an application. The application components (not some overarching application)
    are the basic units of the Android app. They are individually addressable and
    may be published individually for use by other applications.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Web应用程序中一样，这些组件的实现必须在清单中注册：一个XML文件。Android的清单文件通常称为*AndroidManifest.xml*。Android容器在加载应用程序时解析此文件。应用程序组件（而不是某个总体的应用程序）是Android应用程序的基本单元。它们是可单独寻址的，并且可以单独发布以供其他应用程序使用。
- en: So, how does an application target an Android component? With an `Intent`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，应用程序如何定位Android组件的目标？通过一个`Intent`。
- en: Intents and Intent Filters
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意图和意图过滤器
- en: 'In Android, components are started with `Intent`s. An `Intent` is a small packet
    that names the component that it targets. It has some extra room in which it can
    indicate a specific action that it would like the receiving component to take
    and a few parameters to the request. One can think of an intent as a function
    call: the name of the class, the name of a particular function within that class,
    and the parameters to the call. The intent is delivered by the system to the target
    component. It is up to the component to perform the requested service.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，组件是通过`Intent`启动的。`Intent`是一个小包，命名了它所针对的组件。它有一些额外的空间，可以指示接收组件执行的特定操作以及请求的一些参数。可以将意图视为函数调用：类的名称、类内的特定函数名称以及调用的参数。系统将意图传递给目标组件。由组件来执行请求的服务。
- en: It is interesting to note that, in keeping with its component-oriented architecture,
    Android doesn’t actually have any way of starting an application. Instead, clients
    start a component, perhaps the `Activity` that is registered as main for an application
    whose icon a user just tapped on the Launcher page. If the application that owns
    the activity is not already running, it will be started as a side effect.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，与其组件导向的架构一致，Android 实际上没有任何启动应用程序的方式。相反，客户端启动一个组件，可能是用户刚在启动器页面上点击其图标的应用程序的主`Activity`。如果拥有该活动的应用程序尚未运行，则会作为副作用启动它。
- en: 'An intent can name its target explicitly, as shown here:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一个意图可以显式地命名其目标，如此处所示：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This code fires an `Intent` at the `Activity` `MembersListActivity`. Note that
    the call, `startActivity` here, must agree with the type of the component being
    started: an `Activity` in this case. There are other, similar methods for firing
    intents at other kinds of components (`startService` for a `Service`, and so on).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码向`Activity` `MembersListActivity`发出一个`Intent`。请注意，这里的调用`startActivity`必须与被启动的组件的类型相匹配：在这种情况下是一个`Activity`。还有其他类似的方法用于向其他类型的组件发送意图（例如`startService`用于`Service`等）。
- en: The `Intent` fired by this line of code is called an *explicit intent* because
    it names a specific, unique class, in a unique application (identified by a `Context`,
    discussed in a moment), to which the `Intent` is to be delivered.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码行触发的`Intent`称为*显式意图*，因为它指定了一个特定的、唯一的类，在一个唯一的应用程序中（由稍后讨论的`Context`标识），该`Intent`将被传递到该类。
- en: Because they identify a unique, specific target, explicit intents are faster
    and more secure than implicit ones. There are places that the Android system,
    for reasons related to security, requires the use of explicit intents. Even when
    they are not required, explicit intents should be preferred whenever possible.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们标识了一个独特、具体的目标，显式意图比隐式意图更快速且更安全。出于安全原因，Android 系统的某些地方要求使用显式意图。即使不是必需的，尽可能也应优先选择显式意图。
- en: Within an application, a component can always be reached with an explicit intent.
    A component from another application that is publicly visible can also always
    be reached explicitly. So why ever use an implicit intent? Because implicit intents
    allow dynamic resolution of a request.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序内部，可以始终使用显式意图访问组件。对于公开可见的来自其他应用程序的组件，也可以始终显式访问。那么，为什么还要使用隐式意图呢？因为隐式意图允许动态解析请求。
- en: 'Imagine that the email application you’ve had on your phone for years allows
    editing messages with an external editor. We now can guess that it does this by
    firing an intent that might look something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您多年来在手机上使用的电子邮件应用程序允许使用外部编辑器编辑消息。我们现在可以猜测它是通过触发类似以下内容的意图来实现的：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The target specified in this intention is *not* explicit. The `Intent` specifies
    neither a `Context` nor the fully qualified name of a component within a context.
    The intent is *implicit* and Android will allow any component at all to register
    to handle it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此意图中指定的目标*并非*显式。`Intent`既未指定`Context`，也未指定上下文内的组件的完全限定名。此意图是*隐式*的，Android 允许任何组件注册以处理它。
- en: 'Components register for implicit intents using an `IntentFilter`. In fact,
    the “Awesome Code Editor” that you happen to have installed just 15 minutes ago
    registers for exactly the intent shown in the preceding code, by including an
    `IntentFilter` like this in its manifest:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 组件通过`IntentFilter`注册隐式意图。事实上，您刚刚安装的“出色代码编辑器”在其清单中包含如下`IntentFilter`，完全匹配了前述代码中显示的意图：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the intent filter matches the intent that the email application
    fires.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，意图过滤器与电子邮件应用程序触发的意图匹配。
- en: When Android installs the Awesome Code Editor application it parses the application
    manifest and notices that the `EditorActivity` claims to be able to handle an
    `EDIT` action for the category `android.intent.category.TEXT` (see more in the
    [Android Developers documentation](https://oreil.ly/oJNkY)). It remembers that
    fact.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Android 安装出色的代码编辑器应用程序时，它解析应用程序清单并注意到`EditorActivity`声称能够处理类别为`android.intent.category.TEXT`的`EDIT`操作（在[Android
    开发者文档](https://oreil.ly/oJNkY)中有更多信息）。它会记住这一事实。
- en: The next time your email program requests an editor, Android will include Awesome
    Code Editor in the list of editors it offers for your use. You have just upgraded
    your email program simply by installing another application. Talk about awesome!
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下次您的电子邮件程序请求编辑器时，Android 将在提供的编辑器列表中包含出色的代码编辑器供您使用。您只需安装另一个应用程序，就简单地升级了您的电子邮件程序。这可真是太棒了！
- en: Note
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Android gradually increased restrictions on the use of implicit intents in recent
    releases. Because they can be intercepted by any randomly installed application,
    despite their power, implicit intents are not secure. Recent versions of Android
    have imposed strict new constraints on their use. In particular, as of v30, it
    is not possible to register for many implicit intents in the manifest.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Android 在最近的几个版本中逐渐增加了对隐式意图使用的限制。尽管它们非常强大，但由于可以被任意安装的应用拦截，隐式意图并不安全。从 v30 版本开始，Android
    强加了对其使用的严格新限制。特别是，现在不可能在清单中注册许多隐式意图。
- en: Context
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文
- en: 'Because Android components are just subsystems run in a larger container, they
    need some way of referring to the container so that they can request services
    from it. From within a component, the container is visible as a `Context`. `Context`s
    come in a couple of flavors: component and application. Let’s have a look at each
    of them.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Android 组件只是在更大容器中运行的子系统，它们需要一种方式来引用容器，以便从中请求服务。从组件内部来看，容器显示为`Context`。`Context`有几种不同的类型：组件和应用程序。让我们分别看看它们。
- en: Component context
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件上下文
- en: 'We’ve already seen a call like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了像这样的调用：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This call uses a `Context` twice. First, starting an `Activity` is a function
    that a component requests from the framework, the `Context`. In this case, it
    called the `Context` method `startActivity`. Next, in order to make the intent
    explicit, the component must identify the unique package that contains the component
    it wants to start. The `Intent`’s constructor uses the `context` passed as its
    first argument to get a unique name for the application to which the `context`
    belongs: this call starts an `Activity` that belongs to this application.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此调用两次使用了`Context`。首先，启动`Activity`是组件从框架请求的一个功能，即`Context`。在这种情况下，它调用了`Context`方法`startActivity`。接下来，为了使意图明确，组件必须确定包含其想要启动的组件的唯一包。`Intent`的构造函数使用传递的`context`作为其第一个参数来获取`context`所属应用程序的唯一名称：此调用启动了属于此应用程序的`Activity`。
- en: 'The `Context` is an abstract class that provides access to various resources,
    including:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context`是一个抽象类，提供对各种资源的访问，包括：'
- en: Starting other components
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动其他组件
- en: Accessing system services
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问系统服务
- en: Accessing `SharedPreferences`, resources, and files
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问`SharedPreferences`、资源和文件
- en: Two of the Android components, `Activity` and `Service`, are themselves `Context`s.
    In addition to being `Context`s, they are also components that the Android container
    expects to manage. This can lead to problems, all of which are variations on the
    code shown in [Example 3-1](#activity_leak).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Android的两个组件`Activity`和`Service`本身就是`Context`。除了是`Context`之外，它们还是Android容器期望管理的组件。这可能导致问题，所有这些问题都是在[示例 3-1](#activity_leak)中显示的代码变体。
- en: Example 3-1\. Do NOT do this!
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1\. 千万别这样做！
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our developer has decided that it would be really handy to be able to say things
    like `MainActivity.context.startActivity(...)` anywhere in their application.
    In order to do that, they’ve stored a reference to an `Activity` in a global variable,
    where it will be accessible for the entire life of the application. What could
    go wrong?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开发人员已经决定，在他们的应用程序中随时说出像`MainActivity.context.startActivity(...)`这样的事情会非常方便。为了做到这一点，他们在全局变量中存储了对`Activity`的引用，在应用程序的整个生命周期中都可以访问它。会出什么问题呢？
- en: There are two things that could go wrong, one bad and the other horrible. Bad
    is when the Android framework knows that the `Activity` is no longer needed, and
    would like to free it up for garbage collection, but it cannot do so. The reference
    in that companion object will prevent the `Activity` from being released, for
    the entire lifetime of the application. The `Activity` has been leaked. `Activity`s
    are large objects and leaking their memory is no small matter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有两件事可能会出错，一件是糟糕的，另一件是可怕的。糟糕的是当Android框架知道不再需要`Activity`并希望释放其内存以进行垃圾回收时，但由于伴随对象中的引用，它无法这样做。这个伴随对象中的引用将阻止`Activity`的释放，整个应用程序的生命周期内都是如此。`Activity`已经泄漏了。`Activity`是大对象，泄露其内存绝非小事。
- en: The second (far worse) thing, that could go wrong is that a call to a method
    on the cached `Activity` could fail catastrophically. As we will explain shortly,
    once the framework decides that an `Activity` is no longer being used, it discards
    it. It is done with it and will never use it again. As a result, the object may
    be put into an inconsistent state. Calling methods on it may lead to failures
    that are both difficult to diagnose and reproduce.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件（更糟糕）可能出错的事情是对缓存的`Activity`调用方法可能会导致灾难性失败。很快我们将解释，一旦框架决定不再使用`Activity`，它就会丢弃它。它已经完成了并且将永远不会再次使用它。因此，对象可能会处于不一致的状态。调用其上的方法可能导致难以诊断和重现的失败。
- en: 'While the problem in that bit of code is pretty easy to see, there are variants
    that are much more subtle. The following code may have a similar problem:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码中的问题很容易看出来，但还有一些更微妙的变体。以下代码可能存在类似的问题：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is harder to see, but the callback `this::update` is a reference to a method
    on `this`, the `Activity` that contains this `onCreate` method. Once `onCreate`
    completes, the `NetController` holds a reference to this `Activity` that does
    not honor its lifecycle and can incur either of the problems described earlier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更难看出的是，回调`this::update`是对`Activity`中包含此`onCreate`方法的`this`方法的引用。一旦`onCreate`完成，`NetController`会保留对此`Activity`的引用，不遵守其生命周期，并可能引起前面描述的任何问题。
- en: Application context
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序上下文
- en: 'There is another kind of context. When Android starts an application, it usually
    creates a singleton instance of the `Application` class. That instance is a `Context`
    and, though it has a lifecycle, that lifecycle is essentially congruent with the
    lifecycle of the application. Because it is long-lived, it is quite safe to hold
    references to it in other long-lived places. This code, similar to the dangerous
    code shown earlier, is fairly safe because the `context` to which it stores a
    reference is the `ApplicationContext`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种上下文类型。 当Android启动应用程序时，通常会创建`Application`类的单例实例。 该实例是一个`Context`，虽然它有一个生命周期，但该生命周期基本上与应用程序的生命周期一致。
    由于它的寿命很长，因此在其他长期存在的位置中保存对它的引用是非常安全的。 这段代码与之前显示的危险代码类似，因为它存储引用的`context`是`ApplicationContext`：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Be sure to remember that, in order for the Android system to use the custom
    subclass of `Application` instead of its default, the `SafeApp` class must be
    registered in the manifest, like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必记住，为了Android系统使用自定义的`Application`子类而不是其默认值，必须像这样在清单中注册`SafeApp`类：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, when the framework creates the `ApplicationContext` it will be an instance
    of `SafeApp` instead of the instance of `Application` that it would have used
    otherwise.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当框架创建`ApplicationContext`时，它将是`SafeApp`的一个实例，而不是它本来会使用的`Application`的实例。
- en: 'There is another way to get the `ApplicationContext` as well. Calling the method
    `Context.getApplicationContext()` on any context at all, including the `ApplicationContext`
    itself, will always return the long-lived application context. But here’s the
    bad news: the `ApplicationContext` is not a magic bullet. An `ApplicationContext`
    is not an `Activity`. Its implementations of `Context` methods behave differently
    from those of `Activity`. For instance, and probably most annoying, you cannot
    launch `Activity` from an `ApplicationContext`. There is a `startActivity` method
    on `ApplicationContext`, but it simply generates an error message in all but a
    very limited set of circumstances.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种获取`ApplicationContext`的方法。 在任何上下文中调用方法`Context.getApplicationContext()`，包括`ApplicationContext`本身，在任何情况下都将返回长期存在的应用程序上下文。
    但是，这里有个坏消息：`ApplicationContext`并非万能药。 `ApplicationContext`不是`Activity`。 它的`Context`方法的实现与`Activity`的不同。
    例如，可能最令人讨厌的是，您无法从`ApplicationContext`启动`Activity`。 `ApplicationContext`上有一个`startActivity`方法，但在除了非常有限的情况下，它只会生成错误消息。
- en: 'Android Application Components: The Building Blocks'
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android应用程序组件：构建模块
- en: Finally, we can narrow our focus to the components themselves, the essence of
    an application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以把焦点放在组件本身上，这是应用程序的本质。
- en: The lifecycles of Android application components are managed by the Android
    framework, which creates and destroys them according to its needs. Note that this
    absolutely includes instantiation! Application code must *never* create a new
    instance of a component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序组件的生命周期由Android框架管理，根据其需要创建和销毁它们。 请注意，这绝对包括实例化！ 应用程序代码绝对不应创建组件的新实例。
- en: 'Recall that there are four types of components:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，有四种类型的组件：
- en: Activity
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动
- en: Service
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Broadcast receiver
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广播接收器
- en: Content provider
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容提供者
- en: Remember, also, that the following descriptions are nothing more than brief
    overviews, perhaps calling attention to potential pitfalls or features of interest.
    The [Android Developers documentation](https://oreil.ly/PJABc) is extensive, complete,
    and authoritative.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，以下描述仅仅是简要概述，可能会引起注意潜在陷阱或有趣的特性。 [Android开发者文档](https://oreil.ly/PJABc)是全面、完整且权威的。
- en: The Activity and Its Friends
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动及其友好
- en: An `Activity` component manages a single page of an application’s UI. It is
    Android’s analog of a web application servlet. It uses Android’s rich library
    of “widgets” to draw a single, interactive page. Widgets (buttons, text boxes,
    and the like) are the basic UI elements, and they combine a screen representation
    with the input collection that gives the widgets behavior. We’ll discuss them
    in detail shortly.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`组件管理应用程序UI的单个页面。 它是Android中的Web应用程序servlet的类比。 它使用Android丰富的“小部件”库来绘制单个交互页面。
    小部件（按钮、文本框等）是基本的UI元素，它们将屏幕表示与提供小部件行为的输入组合在一起。 我们将很快详细讨论它们。'
- en: As mentioned previously, it is important to understand that an `Activity` is
    not an application! Activities are ephemeral and guaranteed to exist only while
    the page that they manage is visible. When that page becomes invisible, either
    because the application presents a different page or because the user, for instance,
    takes a phone call, there is no guarantee that Android will preserve either the
    `Activity` instance or any of the state that it represents.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，理解`Activity`不是一个应用程序非常重要！`Activity`是短暂存在的，仅在它管理的页面可见时才保证存在。当页面变得不可见时，无论是因为应用程序显示了不同的页面，还是因为用户例如接听电话，都不能保证Android会保留`Activity`实例或其代表的任何状态。
- en: '[Figure 3-2](#activity_lifecycle) shows the state machine that controls the
    lifecycle of an `Activity`. The methods—shown as state transitions—come in pairs
    and are the bookends of the four states that an `Activity` may assume: *destroyed*,
    *created*, *started*, and *running*. The methods are called strictly in order.
    After a call to `onStart`, for instance, Android will make only one of two possible
    calls: `onResume`, to enter the next state, or `onStop`, to revert to the previous
    state.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-2](#activity_lifecycle)显示了控制`Activity`生命周期的状态机。这些方法显示为状态转换，成对出现，是`Activity`可能处于的四种状态的书封：*destroyed*，*created*，*started*和*running*。方法严格按顺序调用。例如，在调用`onStart`之后，Android仅会执行两种可能的调用之一：`onResume`，以进入下一个状态，或`onStop`，以返回到上一个状态。'
- en: '![pawk 0302](assets/pawk_0302.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![pawk 0302](assets/pawk_0302.png)'
- en: Figure 3-2\. The `Activity` lifecycle.
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2\. `Activity`生命周期。
- en: The first pair of bookends are `onCreate` and `onDestroy`. Between them, an
    `Activity` is said to be *created*. When Android instantiates a new `Activity`,
    it calls its `onCreate` method nearly immediately. Until it does so, the `Activity`
    is in an inconsistent state and most of its functions will not work. Note, in
    particular, that most of an `Activity`’s functionality is, inconveniently, not
    available from its constructor.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一对书封是`onCreate`和`onDestroy`。在它们之间，`Activity`被称为*created*。当Android实例化一个新的`Activity`时，几乎立即调用其`onCreate`方法。在此之前，`Activity`处于不一致状态，并且其大多数功能将不起作用。特别要注意的是，大部分`Activity`的功能不便地在其构造函数中是不可用的。
- en: The `onCreate` method is the ideal place to do any initialization that an `Activity`
    needs to do only once. This almost always includes setting up the view hierarchy
    (usually by inflating an XML layout), installing view controllers or presenters,
    and wiring up text and touch listeners.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreate`方法是执行`Activity`只需一次初始化的理想位置。这几乎总是包括设置视图层次结构（通常通过膨胀XML布局），安装视图控制器或呈现器，并连接文本和触摸监听器。'
- en: '`Activity`s, similarly, should not be used after the call to their `onDestroy`
    method. The `Activity` is, again, in an inconsistent state and the Android framework
    will make no further use of it. (It will not, for instance, call `onCreate` to
    revivify it.) Beware, though: the `onDestroy` method is not necessarily the best
    place to perform essential finalization! Android calls `onDestroy` only on a best-effort
    basis. It is entirely possible that an application will be terminated before all
    of an `Activity`s’. `onDestroy` methods have completed.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`s，同样，在调用它们的`onDestroy`方法后不应再使用。再次强调，`Activity`处于不一致状态，并且Android框架将不再使用它。（例如，不会调用`onCreate`来重新启动它。）但要注意：`onDestroy`方法未必是执行重要的最终处理的最佳位置！Android仅在尽力的基础上调用`onDestroy`。完全可能在所有`Activity`的`onDestroy`方法完成之前，应用程序就会被终止。'
- en: An `Activity` can be destroyed from within its own program by calling its `finish()`
    method.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`可以通过调用其`finish()`方法从其自身程序中销毁。'
- en: The next pair of methods are `onStart` and `onStop`. The former, `onStart`,
    will only ever be called on an `Activity` that is in the created state. It moves
    the `Activity` to its on-deck state, called *started*. A started `Activity` may
    be partially visible behind a dialog or another app that only incompletely fills
    the screen. In started state, an `Activity` should be completely painted but should
    not expect user input. A well-written `Activity` will not run animations or other
    resource-hogging tasks while it is in the started state.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 下一对方法是`onStart`和`onStop`。前者`onStart`仅在`Activity`处于已创建状态时才会调用。它将`Activity`移动到其待命状态，称为*started*。处于started状态的`Activity`可能部分可见，位于对话框或其他未完全填充屏幕的应用后面。在started状态下，`Activity`应该已完全绘制，但不应期望用户输入。良好编写的`Activity`在处于started状态时不会运行动画或其他占用资源的任务。
- en: The `onStop` method will only be called on a started `Activity`. It returns
    it to the created state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`onStop` 方法仅在已启动的 `Activity` 上调用。它将其返回到已创建状态。'
- en: The final pair of methods are `onResume` and `onPause`. Between them, an `Activity`’s
    page is in focus on the device and the target of user input. It is said to be
    *running*. Again, these methods will only be called on an `Activity` that is in
    the started or running state, respectively.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一对方法是 `onResume` 和 `onPause`。它们之间，`Activity` 的页面处于设备上的焦点，并接收用户输入。它被称为 *running*。同样，这些方法只会在已启动或运行状态的
    `Activity` 上调用。
- en: Along with `onCreate`, `onResume` and `onPause` are the most important in the
    lifecycle of an `Activity`. They are where the page comes to life, starting, say,
    data updates, animations, and all of the other things that make a UI feel responsive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `onCreate` 一起，`onResume` 和 `onPause` 是 `Activity` 生命周期中最重要的部分。它们是页面开始运行、数据更新、动画等使
    UI 反应灵敏的关键部分。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'It is a good practice to respect the pairing of these methods: a beginning
    method and an end method. If you start something running in the beginning method
    of the pair, stop it in the end method of the same pair. Trying to start, say,
    network polling in `onResume` and stop it in `onStop` is a recipe for hard-to-find
    bugs.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尊重这些方法的配对是一个好习惯：在一对中的开始方法中启动某些操作，在相同一对的结束方法中停止它们。例如，在 `onResume` 中尝试启动网络轮询，在
    `onStop` 中停止，这样做可能导致难以调试的错误。
- en: Fragments
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fragments
- en: '`Fragment`s are an afterthought added to Android’s stable of component-like
    features only at version 3 (Honeycomb, 2011). They can feel a bit “bolted on.”
    They were introduced as a way of making it possible to share UI implementations
    across screens with shapes and sizes so different that it affects navigation:
    in particular, phones and tablets.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fragment` 只是 Android 版本 3（蜂巢，2011 年）中稳定组件功能的一个事后补充。它们可能会感觉有些“附加”。它们被引入是为了使得可以跨屏幕共享
    UI 实现，这些屏幕的形状和大小差异如此之大，以至于影响了导航，尤其是手机和平板电脑。'
- en: '`Fragment`s are not `Context`s. Though they hold a reference to an underlying
    `Activity` for most of their lifecycle, `Fragment`s are not registered in the
    manifest. They are instantiated in application code and cannot be started with
    `Intent`s. They are also quite complex. Compare [Figure 3-3](#fragment_view_lifecycle),
    the state diagram for a `Fragment`, to that of an `Activity`!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fragment` 不是 `Context`。虽然它们在大部分生命周期中持有对底层 `Activity` 的引用，但 `Fragment` 并未在清单中注册。它们是在应用程序代码中实例化的，不能使用
    `Intent` 启动。它们也非常复杂。比较 `Fragment` 的状态图表（参见 [图 3-3](#fragment_view_lifecycle)）与
    `Activity` 的区别！'
- en: 'A thorough discussion of how (or, for that matter, even whether) to use `Fragment`s
    is well outside the scope of this book. Briefly, however, one might think of a
    `Fragment` as something like an *iframe* on a web page: almost an `Activity` embedded
    in an `Activity`. They are complete, logical UI units that can be assembled in
    different ways to form a page.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 详细讨论如何（或者说是否）使用 `Fragment` 是本书讨论的范围之外。简单来说，可以将 `Fragment` 想象成网页中的 *iframe*：几乎是嵌入在
    `Activity` 中的 `Activity`。它们是完整的、逻辑上的 UI 单元，可以以不同的方式组合成页面。
- en: 'As shown, `Fragment`s have lifecycles that are similar to (though more complex
    than) those of an `Activity`. However, a `Fragment` is only useful when it is
    attached to an `Activity`. This is the main reason that a `Fragment` lifecycle
    is more complex: its state can be affected by changes in the state of the `Activity`
    to which it is attached.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如图所示，`Fragment` 的生命周期与 `Activity` 类似（尽管更复杂）。然而，`Fragment` 只有在附加到 `Activity`
    时才有用。这就是 `Fragment` 生命周期更复杂的主要原因：它的状态可能会受到所附加的 `Activity` 状态变化的影响。
- en: Also, just as an `Activity` is programmatically accessible in the inconsistent
    state before its `onCreate` method is called, so a `Fragment` is programmatically
    accessible before it is attached to an `Activity`. `Fragment`s must be used with
    great care before their `onAttach` and `onCreateView` methods have been called.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 `Activity` 在其 `onCreate` 方法调用之前以不一致的状态可编程访问一样，`Fragment` 在其附加到 `Activity`
    之前也可以通过编程访问。在 `onAttach` 和 `onCreateView` 方法调用之前，必须非常小心地使用 `Fragment`。
- en: '![The Back Store store Activities FILO.](assets/pawk_0303.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![Back Store store Activities FILO.](assets/pawk_0303.png)'
- en: Figure 3-3\. `Fragment` lifecycle.
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. `Fragment` 生命周期。
- en: The back stack
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回栈
- en: 'Android supports a navigation paradigm sometimes called *card-deck* navigation.
    Navigating to a new page stacks that page on top of the previous page. When a
    user presses a back button the current page is popped from the stack to reveal
    the one that previously held the screen. This paradigm is fairly intuitive for
    most human users: push new cards on top; pop them off to get back to where you
    were.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持一种称为*卡片堆栈*导航的导航范式。导航到新页面将该页面堆叠在前一个页面之上。当用户按下返回按钮时，当前页面从堆栈中弹出，以显示之前占据屏幕的页面。这种范式对大多数人类用户来说相当直观：推送新卡片到顶部；弹出卡片以返回到之前的页面。
- en: In [Figure 3-4](#back_stack_activities), the current `Activity` is the one named
    SecondActivity. Pushing the back button will cause the `Activity` named MainActivity
    to take the screen.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Figure 3-4](#back_stack_activities)中，当前的`Activity`是一个名为SecondActivity的活动。按下返回按钮将导致名为MainActivity的`Activity`占据屏幕。
- en: Note that, unlike a web browser, Android does not support *forward* navigation.
    Once the user pushes the back button, there is no simple navigational device that
    will allow them to return to the popped page. Android uses this fact to infer
    that it can destroy SecondActivity (in this case), should it need the resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与Web浏览器不同，Android不支持*前进*导航。一旦用户按下返回按钮，就没有简单的导航设备让他们返回到弹出的页面。Android利用这一点推断，如果需要资源，可以销毁SecondActivity（在这种情况下）。
- en: '![pawk 0304](assets/pawk_0304.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![pawk 0304](assets/pawk_0304.png)'
- en: Figure 3-4\. The back stack stores an `Activity`’s pages in last in, first out
    (LIFO) order.
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 3-4\. 返回栈以后进先出（LIFO）顺序存储`Activity`的页面。
- en: '`Fragment`s can also go on the back stack as part of a fragment transaction,
    as shown in [Figure 3-5](#back_stack_fragments).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Fragment`也可以作为片段事务的一部分放入返回栈中，如[Figure 3-5](#back_stack_fragments)所示。'
- en: '![pawk 0305](assets/pawk_0305.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![pawk 0305](assets/pawk_0305.png)'
- en: Figure 3-5\. A `Fragment` transaction, on the back stack, will be reverted before
    the `Activity` that contains it is popped.
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 3-5\. 一个`Fragment`事务，在返回栈中，将在包含它的`Activity`被弹出之前被还原。
- en: 'Adding a fragment to the back stack can be particularly useful when combined
    with tagging, as shown in the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个Fragment添加到返回栈中在与标记结合时可能特别有用，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code creates a new instance of `SomeFragment` and adds it to the back
    stack, tagged with the identifier `FRAGMENT_TAG` (a string constant). As shown
    in the following code, you can use `supportFragmentManager` to pop *everything*
    off the back stack, all the way to the tag:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建`SomeFragment`的一个新实例，并将其添加到返回栈中，并用标识符`FRAGMENT_TAG`（一个字符串常量）标记。如下面的代码所示，您可以使用`supportFragmentManager`弹出*所有*返回栈的内容，直到标记：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the back stack is empty, pushing the back button returns the user to the
    Launcher.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回栈为空时，按下返回按钮将用户返回到启动器。
- en: Services
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: A `Service` is an Android component that is, almost exactly, an `Activity` with
    no UI. That may sound a bit odd, given that an `Activity`’s sole reason for existence
    is that it manages the UI!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`Service`是一个几乎完全没有UI的Android组件，几乎与`Activity`一样。这听起来有点奇怪，因为`Activity`的唯一存在理由是它管理UI！
- en: Android was designed for hardware that is much different from that which is
    common now. The first Android phone, the HTC Dream, was announced in September
    of 2008\. It had very little physical memory (192 MB) and did not support virtual
    memory at all. It could run no more than a handful of applications simultaneously.
    Android’s designers needed a way to know when an application was not doing useful
    work so that they could reclaim its memory for other uses.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Android设计时硬件与现在通常不同得多。第一部Android手机，HTC Dream，于2008年9月宣布发布。它的物理内存非常少（192 MB），根本不支持虚拟内存。它最多只能同时运行几个应用程序。Android的设计者需要一种方式来知道应用程序何时不执行有用工作，以便可以回收其内存用于其他用途。
- en: 'It’s easy to figure out when an `Activity` is not doing useful work. It has
    only one job: to manage a visible page. If applications were composed only of
    `Activity`s, it would be easy to tell when one was no longer useful and could
    be terminated. When none of an application’s `Activity`s are visible, the application
    is not doing anything useful and can be reclaimed. It’s that simple.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易判断一个`Activity`何时不执行有用工作。它只有一个任务：管理一个可见页面。如果应用程序仅由`Activity`组成，则很容易判断何时不再需要其中一个并且可以终止它。当应用程序的所有`Activity`都不可见时，应用程序不执行任何有用工作并且可以被回收。就是这么简单。
- en: 'The problem comes when an application needs to perform long-running tasks that
    are not attached to any UI: monitoring location, synchronizing a dataset over
    the network, and so on. While Android is definitely prejudiced toward “if the
    user can’t see it, why do it?” it grudgingly acknowledges the existence of long-running
    tasks and invented `Service`s to handle them.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用需要执行长时间运行的任务，而这些任务与任何 UI 都没有关联时就会出现问题：比如监控位置、在网络上同步数据集等等。尽管 Android 明确偏向于“如果用户看不到它，为什么要做它？”的态度，但它也不情愿地承认长时间运行的任务的存在，并发明了
    `Service` 来处理它们。
- en: While `Service`s still have their uses, much of the work that they were designed
    to do, back on earlier versions of Android with its more limited hardware, can
    now be done using other techniques. Android’s `WorkManager` is a terrific way
    to manage repeating tasks. There are also other, simpler and more maintainable
    ways of running tasks in the background, on a worker thread. Something as simple
    as a singleton class may be sufficient.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Service` 仍然有它们的用处，但是它们被设计用来做的大部分工作，早期版本的 Android 上因其硬件限制而现在可以通过其他技术完成。Android
    的 `WorkManager` 是管理重复任务的绝佳方式。还有其他更简单、更可维护的方法在后台运行任务，比如在工作线程上运行。一个简单的单例类可能已经足够了。
- en: Service components still exist, though, and still have important roles to play.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Service 组件仍然存在，并且仍然扮演着重要角色。
- en: 'There are, actually, two different kinds of `Service`: *bound* and *started*.
    Despite the fact that the `Service` base class is, confusingly, the template for
    both, the two types are completely orthogonal. A single `Service` can be either
    or both.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有两种不同类型的 `Service`：*bound* 和 *started*。尽管 `Service` 基类混淆地是两者的模板，但这两种类型完全正交。一个单一的
    `Service` 可以是两者之一或两者兼而有之。
- en: Both types of `Service` have `onCreate` and `onDestroy` methods that behave
    exactly as they do for an `Activity`. Since a `Service` has no UI, it does not
    need any of an `Activity`’s other templated methods.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 两种类型的 `Service` 都有 `onCreate` 和 `onDestroy` 方法，它们的行为与 `Activity` 中的完全相同。由于 `Service`
    没有 UI，它不需要 `Activity` 的其他模板方法。
- en: Services do have other templated methods, though. Which of them a specific `Service`
    implements depends on whether it is started or bound.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `Service` 还有其他的模板方法。一个具体的 `Service` 实现哪些方法取决于它是 started 还是 bound。
- en: Started Services
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Started Services
- en: 'A *started* `Service` is initiated by sending it an `Intent`. While it is possible
    to create a started service that returns a value, doing so is inelegantly complex
    and probably indicative of a design that could be improved. For the most part,
    started services are fire-and-forget: something like “put this in the database”
    or “send this out to the net.”'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*Started* `Service` 是通过发送 `Intent` 启动的。虽然可以创建一个返回值的 started service，但这样做可能会显得不够优雅复杂，并且可能表明设计可以改进。大部分情况下，started
    services 是一次性的：比如“把这个放到数据库里”或者“发送到网络上去”。'
- en: To start a service, send it an intent. The intent must name the service, probably
    explicitly by passing the current context and the service class. If the service
    provides multiple functions, of course, the intent may also indicate which of
    them it is intended to invoke. It might also supply parameters appropriate for
    the call.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个服务，发送一个意图。意图必须指明服务的名称，可能需要明确传递当前上下文和服务类。如果服务提供多个功能，则意图还可以指示打算调用的功能。它可能还会提供适合调用的参数。
- en: The service receives the intent as the argument to a call from the Android framework,
    to the method `Service.onStart`. Note that this is not done in the “background”!
    The `onStart` method runs on the main/UI thread. The `onStart` method parses the
    `Intent` content and processes the contained request appropriately.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 服务将意图作为 Android 框架调用的参数接收，传递给 `Service.onStart` 方法。请注意，这不是在“后台”完成的！`onStart`
    方法在主/UI 线程上运行。`onStart` 方法解析 `Intent` 内容，并适当地处理其中的请求。
- en: 'A well-behaved started `Service` will call `Service.stopSelf()` whenever it
    completes its work. This call is similar to `Activity.finish()`: it lets the framework
    know that the `Service` instance is no longer performing useful work and can be
    reclaimed. Modern versions of Android actually pay very little attention to whether
    a service has stopped itself or not. `Service`s are suspended and, possibly even
    terminated, using less voluntary criteria (see the [Android Developers documentation](https://oreil.ly/yGloh)).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个行为良好的启动 `Service` 在完成工作后会调用 `Service.stopSelf()`。这个调用类似于 `Activity.finish()`：它告诉框架
    `Service` 实例不再执行有用的工作，可以被回收。现代版本的 Android 实际上很少关注服务是否已经停止自己。`Service` 可能会被暂停甚至终止，使用的标准不那么自愿（参见
    [Android 开发者文档](https://oreil.ly/yGloh)）。
- en: Bound Services
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定服务
- en: 'A *bound* `Service` is Android’s IPC mechanism. Bound services provide a communication
    channel between a client and a server that is process agnostic: the two ends may
    or may not be part of the same application. Bound services—or at least the communication
    channels they provide—are at the very heart of Android. They are the mechanism
    through which applications send tasks to system services.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*绑定* `Service` 是 Android 的 IPC 机制。绑定服务提供了一个客户端和服务器之间的通信通道，是进程不可知的：两端可能属于同一个应用程序，也可能不是。绑定服务，至少是它们提供的通信通道，是
    Android 的核心所在。它们是应用程序将任务发送到系统服务的机制。'
- en: A bound service, itself, actually does very little. It is just the factory for
    a `Binder`, a half-duplex IPC channel. While a complete description of the Binder
    IPC channels and their use is beyond the scope of this book, their structure will
    be familiar to users of any of the other common IPC mechanisms. [Figure 3-6](#interprocess_communication)
    illustrates the system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个绑定的服务本身实际上并没有做太多事情。它只是 `Binder` 的工厂，一个半双工 IPC 通道。虽然本书不详细描述 Binder IPC 通道及其使用，但其结构对于使用任何其他常见
    IPC 机制的用户来说都很熟悉。[图 3-6](#interprocess_communication) 展示了这个系统。
- en: 'Typically, a service provides a *proxy* that looks like a simple function call.
    The proxy *marshals* an identifier for the requested service (essentially, the
    function name) and its parameters, by converting them to data that can be transmitted
    over the connection: usually aggregates of very simple data types like integers
    and strings. The marshaled data is communicated, in this case via the Binder kernel
    module, to a *stub* provided by the bound service that is the target of the connection.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，服务提供一个 *代理*，看起来像一个简单的函数调用。代理 *打包* 请求服务的标识符（本质上是函数名）及其参数，将它们转换为可以通过连接传输的数据：通常是整数和字符串等非常简单的数据类型的聚合体。打包的数据通过
    Binder 内核模块传输到绑定服务提供的 *存根*，这是连接目标。
- en: '![pawk 0306](assets/pawk_0306.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![pawk 0306](assets/pawk_0306.png)'
- en: Figure 3-6\. Binder IPC.
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-6\. Binder IPC。
- en: 'The stub *unmarshals* the data, converting it back into a function call to
    the service implementation. Notice that the proxy function and the service implementation
    function have the same signature: they implement the same interface (IService,
    as shown in [Figure 3-6](#interprocess_communication)).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 存根 *解组* 数据，将其转换回到对服务实现的函数调用。请注意，代理函数和服务实现函数具有相同的签名：它们实现了相同的接口（如 [图 3-6](#interprocess_communication)
    所示的 IService）。
- en: Android makes *extensive* use of this mechanism in the implementation of system
    services. Functions that are actually calls to remote processes are a fundamental
    part of Android.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Android 在实现系统服务时 *广泛* 使用了这种机制。实际上是远程进程调用的函数是 Android 的一个基本部分。
- en: 'An instance of the class `ServiceConnection` represents a connection to a bound
    service. The following code demonstrates its use:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceConnection` 类的一个实例表示到绑定服务的连接。以下代码演示了它的使用：'
- en: '[PRE10]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A subclass of `BoundService` provides the type of the service that will be bound,
    and an `Intent` that targets it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`BoundService` 的子类提供了将要绑定的服务的类型，以及一个定位到它的 `Intent`。'
- en: The client side initiates a connection using the `bind` call. In response, the
    framework initiates a connection to the remote bound service object. The remote
    framework calls the bound service’s `onBind` method with the intent. The bound
    service creates and returns an implementation of `IBinder` that is also an implementation
    of the interface the client requested. Note that this is often a reference to
    the bound service itself. In other words, the `Service` is often not only the
    factory but also the implementation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过`bind`调用发起连接。作为响应，框架会启动到远程绑定服务对象的连接。远程框架调用绑定服务的`onBind`方法，并带有意图。绑定服务创建并返回一个`IBinder`的实现，同时也是客户端请求的接口的实现。请注意，这通常是对绑定服务本身的引用。换句话说，`Service`通常不仅是工厂，还是实现。
- en: The service side uses the implementation provided by the bound service to create
    the remote-side stub. It then notifies the client side that it’s ready. The client-side
    framework creates the proxy and then finally calls the `ServiceConnection`’s `onServiceConnected`
    method. The client now holds a live connection to the remote service. Profit!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 服务端使用绑定服务提供的实现来创建远程侧存根。然后通知客户端，表明准备就绪。客户端框架创建代理，然后最终调用`ServiceConnection`的`onServiceConnected`方法。客户端现在持有与远程服务的活动连接。利润！
- en: As one might guess from the presence of an `onServiceDisconnected` method, a
    client can lose the connection to a bound service at any time. Though the notification
    is usually immediate, it is definitely possible for a client call to a service
    to fail even before it receives a disconnect notification.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如从`onServiceDisconnected`方法的存在可以猜到的那样，客户端随时可能会丢失与绑定服务的连接。尽管通知通常是即时的，但客户端在收到断开连接通知之前调用服务的调用可能会失败。
- en: Like a started service, bound service code does not run in the background. Unless
    explicitly made to do otherwise, bound service code runs on the application’s
    main thread. This can be confusing, though, because a bound service might run
    on the main thread of a *different* application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与启动服务类似，绑定服务代码不会在后台运行。除非明确要求，否则绑定服务代码将在应用程序的主线程上运行。这可能会令人困惑，因为绑定服务可能会在*不同*应用程序的主线程上运行。
- en: If the code in a service implementation must run on a background thread, it
    is the service implementation that is responsible for arranging that. Client calls
    to a bound service, while asynchronous, cannot control the thread on which the
    service itself runs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务实现中的代码必须在后台线程上运行，则服务实现负责安排。尽管绑定服务的客户端调用是异步的，但不能控制服务本身运行的线程。
- en: 'Services, like every other component, must be registered in the application
    manifest:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他所有组件一样，服务必须在应用程序清单中注册：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Content Providers
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容提供者
- en: A `ContentProvider` is a REST-like interface to data held by an application.
    Because it is an API, not simply direct access to data, a `ContentProvider` can
    exercise very fine-grained control over what it publishes and to whom it publishes
    it. External applications get access to a `ContentProvider` using a Binder IPC
    interface, through which the `ContentProvider` can obtain information about the
    querying process, the permissions it holds, and the type of access it requests.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentProvider`是应用程序中保存数据的类似REST的接口。因为它是一个API，而不仅仅是对数据的直接访问，所以`ContentProvider`可以对其发布的内容及发布对象行使非常精细的控制。外部应用程序通过Binder
    IPC接口访问`ContentProvider`，通过该接口`ContentProvider`可以获取关于查询过程、其所持有的权限以及请求的访问类型的信息。'
- en: Early Android applications often shared data simply by putting it into publicly
    accessible files. Even then, Android encouraged the use of `ContentProvider`s
    instead. More recent versions of Android, in the interests of security, have made
    it difficult to share files directly, making `ContentProvider`s more relevant.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 早期的Android应用程序通常通过将数据放入可公开访问的文件中来共享数据。即便如此，Android也鼓励使用`ContentProvider`代替。在安全性方面，更近期的Android版本已经使直接共享文件变得困难，从而使`ContentProvider`变得更加相关。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While `ContentProvider`s provide access to stored data, you must have some kind
    of data store from which to read and write the data. Android Jetpack offers the
    Room persistence library as an option. As described in its official documentation,
    Room provides “an abstraction layer to allow for more robust access while harnessing
    the full power of SQLite.”
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ContentProvider`提供了对存储数据的访问，但您必须拥有某种数据存储以读取和写入数据。Android Jetpack提供了Room持久化库作为选择。正如其官方文档所述，Room提供了“一个抽象层，允许更强大的访问，并充分利用SQLite的全部功能。”
- en: For more information on how to save data in a local database using Room, check
    out the [Android Developers documentation](https://oreil.ly/9OwGH).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解如何使用Room在本地数据库中保存数据的更多信息，请查看[Android开发者文档](https://oreil.ly/9OwGH)。
- en: One particularly interesting capability of a `ContentProvider` is that it can
    pass an open file to another program. The requesting program need not have any
    way to access the file directly using a file path. The `ContentProvider` can construct
    the file it passes in any way that it wants. By passing an open file, though,
    the `ContentProvider` moves itself out of the loop. It gives the requesting program
    direct access to the data. Neither the `ContentProvider` nor any other IPC mechanism
    remains between the client and the data. The client simply reads the file just
    as if it had opened that file itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别有趣的`ContentProvider`的能力是可以将一个打开的文件传递给另一个程序。请求的程序不需要使用文件路径直接访问文件。`ContentProvider`可以以任何方式构造它传递的文件。通过传递一个打开的文件，`ContentProvider`移出了自身的循环。它直接给请求的程序访问数据的权限。在客户端和数据之间，既没有`ContentProvider`也没有其他IPC机制。客户端就像打开了文件一样简单地读取文件。
- en: 'An application publishes a `ContentProvider`, as usual, by declaring it in
    the application manifest:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序像往常一样通过在应用程序清单中声明来发布`ContentProvider`：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This XML element says that the application contains the class named `com.oreilly.kotlin.example.MemberProvider`,
    which has to be a subclass of `android.content.ContentProvider`. The element declares
    that `MemberProvider` is the authority for any requests for data from the URL
    *content://com.oreilly.kotlin​​.exam⁠⁠ple.members*. Finally, the declaration mandates
    that requesting applications must hold the permission “com.oreilly.kotlin.example.members.READ”
    in order to get any access at all and that even then they will get only read access.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个XML元素表示应用程序包含名为`com.oreilly.kotlin.example.MemberProvider`的类，它必须是`android.content.ContentProvider`的子类。该元素声明`MemberProvider`是URL
    *content://com.oreilly.kotlin​​.exam⁠⁠ple.members* 的数据请求的权限。最后，声明要求请求的应用程序必须持有权限“com.oreilly.kotlin.example.members.READ”，以获取任何访问权限，即使如此，它们也仅能获取读取权限。
- en: '`ContentProvider`s have exactly the API one would expect from a REST interface:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentProvider`确实具有REST接口应有的API：'
- en: '`query()`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`query()`'
- en: This fetches data from a particular table.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从特定表中获取数据。
- en: '`insert()`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`'
- en: This inserts a new row within a content provider and returns the content URI.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在内容提供者中插入新行并返回内容URI。
- en: '`update()`'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`'
- en: This updates the fields of an existing row and returns the number of rows updated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这更新现有行的字段并返回更新的行数。
- en: '`delete()`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete()`'
- en: This deletes existing rows and returns the number of rows deleted.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这删除现有行并返回删除的行数。
- en: '`getType()`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`getType()`'
- en: This returns the MIME data type for the given Content URI.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回给定Content URI的MIME数据类型。
- en: The `ContentProvider` for `MemberProvider` would probably implement only the
    first of these methods, because it is read-only.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemberProvider`的`ContentProvider`可能只实现这些方法中的第一个，因为它是只读的。'
- en: Broadcast Receivers
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播接收器
- en: The original concept for a `BroadcastReceiver` was as a kind of data bus. Listeners
    could subscribe in order to get notification of events that were of interest.
    As the system has come of age, however, `BroadcastReceiver`s have proved to be
    too expensive and too prone to security problems to be used pervasively. They
    remain mostly a tool used by the system to signal applications of important events.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最初`BroadcastReceiver`的概念是作为一种数据总线。监听器可以订阅以获取感兴趣的事件通知。然而，随着系统的发展，`BroadcastReceiver`已被证明过于昂贵和容易遭受安全问题，无法广泛使用。它们仍然主要是系统用来向应用程序发出重要事件信号的工具。
- en: Perhaps the most common use of a `BroadcastReceiver` is as a way of starting
    an application, even if there has been no user request to do so.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`BroadcastReceiver`最常见的用途也许是作为启动应用程序的一种方式，即使没有用户的请求。'
- en: 'The `Intent` `android.intent.action.BOOT_COMPLETED` is broadcast by the Android
    system once the OS is stable, after a system restart. An application could register
    to receive this broadcast, like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent` `android.intent.action.BOOT_COMPLETED` 是在Android系统稳定后，系统重新启动后由Android系统广播的。应用程序可以注册以接收此广播，例如：'
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If an application does this, its `StartupReceiver` will be started, to receive
    the `BOOT_COMPLETED` `Intent` broadcast when the OS is rebooted. As noted earlier,
    a side effect of starting the `StartupReceiver` is that the application that contains
    the receiver is also started.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用这样做，它的`StartupReceiver`将会启动，以接收操作系统重新启动时的`BOOT_COMPLETED` `Intent`广播。正如前面所述，启动`StartupReceiver`的副作用是启动包含接收器的应用程序。
- en: 'Applications have used this as a way of creating a *daemon*: an app that is
    always running. While a hack and fragile (even in early Android, behavior changed
    from version to version), this trick worked well enough that many, many applications
    used it. Even as Android version 26 introduced some fairly radical changes in
    background process management (`BroadcastReceiver`s cannot be registered for implicit
    broadcasts in their manifests; they must instead register them dynamically using
    `Context.registerReceiver`), developers continue to find ways to use it.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序利用这种方式创建*守护程序*，即始终运行的应用程序。尽管这种方法不成熟且易碎（即使在早期的Android中，行为也随版本变化而变化），但这个技巧足够好，以至于许多应用程序都在使用它。即使Android
    26版本在后台进程管理方面引入了一些非常激进的变化（`BroadcastReceiver`不能在其清单中为隐式广播注册；必须使用`Context.registerReceiver`动态注册它们），开发者仍在继续寻找使用它的方法。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There are exceptions to the Android 26 implicit intent rule. Receiving SMS messaging,
    changing locale, detecting USB devices, and a few other intents are *permitted*,
    and applications may register for them, in their manifests. `ACTION_USB_ACCESSORY_ATTACHED`,
    `ACTION_CONNECTION_STATE_CHANGED`, and our dear old friend `ACTION_BOOT_COMPLETED`
    are among the permitted intents. For more, check out the [Android Developers documentation](https://oreil.ly/PMNhM).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Android 26的隐式Intent规则有例外。接收短信、更改语言环境、检测USB设备和其他一些Intent是*允许*的，应用程序可以在其清单中注册它们。`ACTION_USB_ACCESSORY_ATTACHED`、`ACTION_CONNECTION_STATE_CHANGED`和我们亲爱的旧朋友`ACTION_BOOT_COMPLETED`都属于允许的Intent之列。有关更多信息，请查看[Android开发者文档](https://oreil.ly/PMNhM)。
- en: '`Activity`, `Service`, `ContentProvider`, and `BroadcastReceiver` are the four
    components that are the essential building blocks of an Android application. As
    Android has grown and improved, it has introduced new abstractions that obscure
    these basic mechanisms. A modern Android application may use only one or two of
    these building blocks directly, and many developers will never code a `ContentProvider`
    or a `BroadcastReceiver`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`、`Service`、`ContentProvider`和`BroadcastReceiver`是构成Android应用程序的四个基本构件。随着Android的发展和改进，它引入了新的抽象化，使这些基本机制变得模糊。现代Android应用程序可能只直接使用其中一两个构件，许多开发者将永远不会编写`ContentProvider`或`BroadcastReceiver`。'
- en: 'The essential lesson here, which bears repeating, is that an Android app is
    not an “application” in the traditional sense. It is more like a web application:
    a collection of components that provide services to a framework when requested
    to do so.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本教训是值得重复的，即Android应用程序不是传统意义上的“应用程序”。它更像是一个Web应用程序：一组在请求时为框架提供服务的组件。
- en: Android Application Architectures
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android应用架构
- en: So far, in this chapter we’ve discussed the Android system architecture. While
    understanding that architecture is essential for any serious Android developer,
    it is not sufficient for understanding how to write resilient, bug-free Android
    programs. As evidence of this, one need only look at the many tools and abstractions
    that have been tried and abandoned over the years of Android’s existence. Time
    and experience, though, have honed the Android playbook and made the path to a
    robust, maintainable application much easier to follow.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中我们已经讨论了Android系统架构。虽然理解该架构对于任何严肃的Android开发者来说都是必不可少的，但这并不足以理解如何编写健壮、无bug的Android程序。作为证据，只需看看多年来Android存在的许多尝试和放弃的工具和抽象化。然而，时间和经验磨练了Android的游戏规则，并使得编写一个稳健、易于维护的应用程序的路径变得更加容易。
- en: 'MVC: The Foundation'
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC：基础
- en: The original pattern for applications with a UI was called Model–View–Controller
    (MVC). The innovation that the pattern introduced was a guarantee that the view—what
    was rendered on the screen—was always consistent. It did this by insisting on
    a unidirectional cycle for data flow.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有用户界面的应用程序的原始模式称为模型-视图-控制器（MVC）。该模式引入的创新是保证视图——即屏幕上呈现的内容——始终保持一致。它通过坚持数据流的单向循环来实现这一点。
- en: 'It all starts with the user. They see something on the screen (the *View*:
    I told you it was a cycle!) and, in response to what they see, take some action.
    They touch the screen, type something, speak, whatever. They do something that
    will change the state of the application.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于用户。他们在屏幕上看到某些东西（*视图*：我告诉过你这是一个循环！），作为对所看到的反应，采取一些行动。他们触摸屏幕，输入文字，说话，或者其他。他们做一些改变应用程序状态的事情。
- en: Their input is fielded by the *Controller*. The Controller has two responsibilities.
    First, it orders the user’s input. For any given user event—say, tapping the “stop”
    button—all other user events happen either before that tap or after it. No two
    events are ever processed at the same time.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的输入由*控制器*处理。控制器有两个责任。首先，它命令用户的输入。对于任何给定的用户事件，比如点击“停止”按钮，所有其他用户事件要么在该点击之前发生，要么在之后发生。从不会同时处理两个事件。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The implication that the Controller is single-threaded is one of the most important
    aspects of the original MVC pattern. Prior multithreaded strategies (including
    Java’s Abstract Window Toolkit [AWT]) often produced a nightmare of deadlocks
    as messages traveling in opposite directions—from the user and to the user—tried
    to seize the same locks in different orders.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是单线程的暗示是原始MVC模式中最重要的一个方面之一。先前的多线程策略（包括Java的抽象窗口工具包[AWT]）通常会产生死锁的噩梦，因为来自用户和发送给用户的消息会试图以不同的顺序获取相同的锁。
- en: The Controller’s second responsibility is to translate user input into operations
    on a *Model*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器的第二个责任是将用户输入转化为对*模型*的操作。
- en: The Model is the business logic of an application. It probably combines some
    kind of persistent data store and perhaps a network connection with rules for
    combining and interpreting the input from the Controller. In the ideal MVC architecture,
    it is the only component that holds the current state of the application.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是应用程序的业务逻辑。它可能将某种持久数据存储与可能的网络连接结合起来，同时还有从控制器接收和解释输入的规则。在理想的MVC架构中，它是唯一保存应用程序当前状态的组件。
- en: 'The Model, again, ideally is allowed to send only one message to the View:
    “things have changed.” When the View receives such a message it does its job.
    It requests the application state from the Model, interprets it, and renders it
    on the screen. What it renders is always a consistent snapshot of the Model. At
    this point, the user can see the new state and take new actions in response. The
    cycle continues.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 模型再次理想地只允许向视图发送一条消息：“事情已经改变了”。当视图收到这样的消息时，它完成了自己的工作。它从模型请求应用程序状态，解释它，并在屏幕上呈现它。它呈现的始终是模型的一致快照。在这一点上，用户可以看到新状态并采取新的响应动作。这个循环继续。
- en: While the MVC pattern was fairly revolutionary when it was introduced, there
    is room for improvement.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管当MVC模式被引入时相当革命性，但仍有改进的空间。
- en: Widgets
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件
- en: As we mentioned earlier in the context of the `Activity` component, a widget
    is a single class that combines a View component with a Controller component.
    After the preceding discussion of the MVC pattern and its emphasis on separating
    the two, it may seem odd to find classes like `Button`, `TextBox`, and `RadioButton`
    that clearly combine the two.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前在`Activity`组件的上下文中提到的，小部件是一个将视图组件和控制器组件结合在一起的单一类。在前面讨论了MVC模式及其强调分离这两者之后，发现像`Button`、`TextBox`和`RadioButton`这样明显将两者结合起来的类可能会感到奇怪。
- en: Widgets do not break MVC architecture. There is still, in each widget, distinct
    View and Controller code. The Controller portion of a widget never talks directly
    to the View, and the View does not receive events from the Controller. The sections
    are independent; they are just bundled together into a single handy container.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件不会破坏MVC架构。在每个小部件中仍然有明确的视图和控制器代码。小部件的控制器部分从不直接与视图交谈，视图也不会接收来自控制器的事件。这些部分是独立的；它们只是捆绑在一个方便的容器中。
- en: Combining the two functions just seems fairly obvious. What is the use of the
    image of a button, that can be placed anywhere on the screen, if it doesn’t respond
    to clicks? It just makes sense that the renderer for the UI components, and the
    mechanism that handles input for it, be part of the same component.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两个功能结合起来似乎显而易见。如果一个按钮的图像可以放置在屏幕的任何地方，而不响应点击，那有什么用呢？对于UI组件的渲染器以及处理其输入的机制，成为同一组件的一部分就是有意义的。
- en: The Local Model
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地模型
- en: With the advent of the Web, browsers, and the long delay required for an entire
    MVC cycle, developers began to see the need for keeping the state of the screen
    as a separate, UI-Local Model. Developers have, over time, referred to this component
    using several names, depending on other features of the design pattern in which
    it is being used. To avoid confusion, we will refer to it, for the rest of this
    chapter, as the *Local Model*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Web、浏览器的出现以及整个 MVC 循环所需的长时间延迟，开发人员开始意识到需要将屏幕状态作为单独的 UI-Local Model。随着时间的推移，开发人员根据设计模式的其他特性，给这个组件起了几个名字。为了避免混淆，在本章的其余部分，我们将称其为*Local
    Model*。
- en: 'The use of a Local Model gives rise to a new pattern that is sort of a two-layer
    MVC—it has even been referred to as the “Figure Eight” pattern. When the user
    takes an action, the Controller updates the Local Model instead of the Model,
    because a Model update may be a network connection away. The Local Model is not
    business logic. It represents, as simply as possible, the state of the View: which
    buttons are on, which are off, what text is in which box, and the color and length
    of the bars in the graph.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Local Model 引出了一个新的模式，可以说是一个两层 MVC——甚至被称为“八字模式”。当用户执行操作时，Controller 更新 Local
    Model 而不是 Model，因为 Model 更新可能需要进行网络连接。Local Model 并不是业务逻辑。它尽可能简单地表示 View 的状态：哪些按钮是开启的，哪些是关闭的，哪个框中有什么文本，以及图表中的颜色和长度。
- en: The Local Model does two things in response to an action. First it notifies
    the View that things have changed so that the View can rerender the screen from
    the new Local Model state. In addition, though, with code that is analogous to
    the simple MVC’s Controller, the Local Model forwards the state changes to the
    Model. In response, the Model eventually notifies—this time the Local Model—that
    there has been an update and that the Local Model should sync itself. This probably
    results in a second request that the View update itself.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Local Model 在响应操作时有两个作用。首先，它通知 View 事物已经改变，以便 View 可以从新的 Local Model 状态重新渲染屏幕。此外，类似于简单
    MVC 的 Controller，Local Model 通过代码将状态变化转发给 Model。作为回应，Model 最终会通知——这次是 Local Model——已经有更新，Local
    Model 应该同步自己。这可能导致第二个请求，要求 View 更新自己。
- en: Android Patterns
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android 模式
- en: 'In Android, regardless of the pattern, an `Activity` object—or possibly its
    cousin, a `Fragment`—takes the role of the View. This is more or less mandated
    by the structure of the `Activity` object: it is the thing that owns the screen
    and it is the thing that has access to the widgets that comprise the view. Over
    time, though, as is appropriate for an MVC-based UI, `Activity` objects have gotten
    simpler and simpler. In a modern Android application, it is likely that an `Activity`
    will do little more than inflate the view, delegate events inbound from the user
    to the Local Model, and observe Local Model state that is of interest, redrawing
    itself in response to updates.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，不论采用何种模式，Activity 对象——或者可能是其近亲 Fragment——扮演 View 的角色。这基本上是由于 Activity
    对象的结构：它拥有屏幕并且可以访问组成视图的部件。然而，随着时间的推移，正如适用于基于 MVC 的 UI，Activity 对象变得越来越简单。在现代 Android
    应用程序中，一个 Activity 可能只会做很少的事情：填充视图、将用户的入站事件委托给 Local Model，并观察感兴趣的 Local Model
    状态，以响应更新重新绘制自身。
- en: Model–View–Intent
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Model–View–Intent
- en: One of the oldest versions of MVC adopted by the Android community was called
    Model–View–Intent. The pattern decouples the `Activity` from a Model by using
    `Intent`s and their payloads. While this structure produces excellent component
    isolation, it can be quite slow and the code for constructing the `Intents` quite
    bulky. Although it is still used successfully, newer patterns have largely supplanted
    it.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Android 社区采用的最古老版本的 MVC 之一被称为 Model–View–Intent。该模式通过使用 Intent 和它们的载荷，将 Activity
    与 Model 解耦。虽然这种结构能够产生出色的组件隔离，但可能会相当慢，而且构建 Intents 的代码相当庞大。尽管它仍然成功使用，但较新的模式已大部分取代了它。
- en: Model–View–Presenter
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Model–View–Presenter
- en: A goal for all of these MVC-based patterns is to loosen the coupling among the
    three components and to make information flow unidirectionally. In a naive implementation,
    though, the View and the Local Model each hold a reference to the other. Perhaps
    the View gets an instance of the Local Model from some sort of factory and then
    registers with it. Though subtle—and regardless of the apparent direction in which
    information flows—holding a reference to an object of a specific type is coupling.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 所有基于MVC的模式的目标都是减少三个组件之间的耦合，并使信息流单向传递。然而，在一个简单的实现中，视图和本地模型各自持有对另一个的引用。也许视图从某种工厂获取本地模型的实例，然后注册它。尽管微妙——并且不管信息流的明显方向如何——持有对特定类型对象的引用都是耦合的表现。
- en: Over the past few years, there have been several refinements to the MVC pattern
    in an attempt to reduce this coupling. While these refinements have often resulted
    in better code, the distinctions among them, and the very names used to identify
    them, have not always been clear.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，有几次对MVC模式进行了改进，试图减少耦合。虽然这些改进通常会导致更好的代码，但它们之间的区别，以及用来标识它们的名称，并不总是清晰明了。
- en: 'One of the earliest refinements replaces the View and Local Model references
    to each other with references to interfaces. The pattern is often called Model–View–Presenter
    (MVP). In implementations of this pattern, the Local Model holds a reference,
    not to the View `Activity`, but simply to the implementation of some interface.
    The interface describes the minimal set of operations that the Local Model can
    expect from its peer. It has, essentially, no knowledge that the View is a View:
    it sees only operations for updating information.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最早的一种改进方法是，用接口代替视图和本地模型相互引用。该模式通常称为Model–View–Presenter（MVP）。在这种模式的实现中，本地模型持有的不是视图`Activity`的引用，而仅仅是某个接口的实现。这个接口描述了本地模型可以从其对等体期望的最小操作集。它基本上并不知道视图是一个视图：它只看到用于更新信息的操作。
- en: The View proxies user input events to its Presenter. The Presenter, as described
    earlier, responds to the events, updating Local Model and Model state as necessary.
    It then notifies the View that it needs to redraw itself. Because the Presenter
    knows exactly what changes have taken place, it may be able to request that the
    View update only affected sections, instead of forcing a redraw of the entire
    screen.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 视图代理用户输入事件给其Presenter。正如前面所述，Presenter响应事件，根据需要更新本地模型和模型状态。然后通知视图需要重新绘制自己。因为Presenter准确知道发生了哪些变化，它可以请求视图仅更新受影响的部分，而不是强制整个屏幕重绘。
- en: The most important attribute of this architecture, however, is that the Presenter
    (this architecture’s name for the Local Model) can be unit tested. Tests need
    only mock the the interface that the View provides to the Presenter to completely
    isolate it from the View. Extremely thin views and testable Presenters lead to
    much more robust applications.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构的最重要特性是，Presenter（本架构称为本地模型）可以进行单元测试。测试只需模拟视图提供给Presenter的接口，就可以完全隔离它与视图的联系。极其简洁的视图和可测试的Presenter可以极大增强应用的健壮性。
- en: But it is possible to do even better than this. The Local Model might hold no
    references to the View at all!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可能会比这做得更好。本地模型可能根本不持有对视图的引用！
- en: Model–View–ViewModel
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Model–View–ViewModel
- en: Google, with its introduction of Jetpack, supports an architecture called Model–View–ViewModel
    (MVVM). Because it’s supported, internally, by the modern Android framework, it
    is the most common and most discussed pattern for modern Android apps.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌通过引入Jetpack，支持了一种称为Model–View–ViewModel（MVVM）的架构。因为它在现代Android框架内部得到支持，所以它是现代Android应用程序中最常见和最讨论的模式。
- en: In the MVVM pattern, as usual, either an `Activity` or a `Fragment` takes the
    role of the View. The View code will be as simple as it is possible to make it,
    often contained entirely within the `Activity` or `Fragment` subclass. Perhaps
    some complex views will need separate classes for image rendering or a `RecyclerView`.
    Even these, though, will be instantiated and installed in the view, directly by
    the `Activity` or `Fragment`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM模式中，通常使用`Activity`或`Fragment`充当视图。视图代码尽可能简单，通常完全包含在`Activity`或`Fragment`子类中。也许一些复杂的视图需要单独的类来进行图像渲染或`RecyclerView`。尽管如此，这些视图也会由`Activity`或`Fragment`直接实例化和安装。
- en: The ViewModel is responsible for wiring together the commands necessary to update
    the View and the backend Model. The novel feature of this pattern is that a single
    interface, `Observable`, is used to transmit changes in the state of the Local
    Model to the View.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ViewModel 负责将更新视图和后端模型的命令连接在一起。这种模式的新特性是使用单一接口`Observable`传输本地模型状态的更改到视图。
- en: Instead of the multiple Presenter interfaces used in the MVP pattern, the ViewModel
    represents viewable data as a collection of `Observable`s. The View simply registers
    as an observer for these observables and reacts to notifications of changes in
    the data they contain.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 模式中，ViewModel 代表可视化数据作为一组`Observable`，而不是 MVP 模式中使用的多个 Presenter 接口。视图只需将自己注册为这些可观察对象的观察者，并对其中数据变化的通知做出反应。
- en: The Jetpack library calls these `Observable`s `LiveData`. A `LiveData` object
    is an observable data holder class with a single generified interface that notifies
    subscribers of changes in the underlying data.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack 库将这些`Observable`称为`LiveData`。`LiveData`对象是一个可观察的数据持有者类，具有单个泛型接口，用于通知订阅者数据底层的更改。
- en: Like MVP, MVVM makes mocking and unit testing easy. The important new feature
    that MVVM introduces is lifecycle awareness.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与 MVP 类似，MVVM 让模拟和单元测试变得容易。MVVM 引入的重要新特性是生命周期感知。
- en: 'The keen reader will have noticed that the version of the MVP pattern described
    earlier does *exactly* the thing we warned against in [Example 3-1](#activity_leak):
    it stores the reference to an `Activity`, an object with an Android-controlled
    lifecycle, in a long-lived object! Applications are left to their own devices
    to make sure the reference doesn’t outlive the target object.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 注意的读者会发现，在之前描述的 MVP 模式版本中，确实*完全*做了我们在 [示例 3-1](#activity_leak) 中警告的事情：它在一个长期存在的对象中存储了对`Activity`的引用，而`Activity`是一个具有由
    Android 控制的生命周期的对象！应用程序必须自行确保引用不会超出目标对象的生命周期。
- en: The Jetpack-supported implementation of the MVVM pattern dramatically reduces
    this problem. In its implementation, the only references to the View are the subscriptions
    to the `LiveData` observables. The `LiveData` objects identify `Fragment` and
    `Activity` observers, and unregister them, automatically when their lifecycle
    ends.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack 支持的 MVVM 模式实现大大减少了这个问题。在其实现中，对视图的唯一引用是对`LiveData`可观察对象的订阅。`LiveData`对象在它们的生命周期结束时自动识别`Fragment`和`Activity`的观察者，并注销它们。
- en: Applications built with JetPack’s version of MVVM can be quite elegant. For
    a broad variety of applications, the View will contain a single, simple, declarative
    method that draws the screen. It will register that method as an observer for
    ViewModel observables. The ViewModel translates user input into calls to the backend
    Model and updates its observables in response to notifications from the Model.
    It’s that simple.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JetPack 实现的 MVVM 模式构建的应用程序可以非常优雅。对于各种应用程序，视图将包含一个简单的声明性方法来绘制屏幕。它将将这个方法注册为观察者以观察
    ViewModel 的可观察对象。ViewModel 将用户输入转换为对后端模型的调用，并根据模型通知更新其可观察对象。就是这么简单。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations, you’ve successfully covered an intimidating amount of information
    in a very short chapter!
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 祝贺你，在这一小节里，你成功地涵盖了大量信息！
- en: Remember that much of this material is foundational. It is not important that
    you master all of the information presented here. In fact, it’s quite possible
    that you will never touch, for instance, a `ContentProvider` or a `BroadcastReceiver`.
    Use what is practical for you, and approach mastering items only as they become
    useful.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这些材料中的大部分都是基础知识。重要的不是你掌握这里呈现的所有信息。事实上，你可能永远都不会接触到像`ContentProvider`或`BroadcastReceiver`这样的东西。只使用对你有实际意义的内容，并在它们变得有用时逐步掌握它们。
- en: 'Here are some key points to take with you:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些要记住的关键点：
- en: 'An Android app is not an “application” in the traditional sense. It is more
    like a web application: a collection of components that provide services to a
    framework, when requested to do so.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 应用程序不是传统意义上的“应用程序”。它更像是一个 Web 应用程序：一组组件，它们在请求时为框架提供服务。
- en: The Android OS is a very specialized Linux distribution. Each application is
    treated as an individual “user” and has its own private file storage.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android 操作系统是一个非常专业化的 Linux 发行版。每个应用程序都被视为一个单独的“用户”，并拥有自己的私有文件存储空间。
- en: 'Android has four kinds of components. They are: `Activity`s, `Service`s, `ContentProvider`s,
    and `BroadcastReceiver`. `Activity`s, `Service`s, and the `ContentProvider`s must
    be registered and possibly given permission within the Android manifest:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android有四种组件。它们是：`Activity`（活动），`Service`（服务），`ContentProvider`（内容提供者）和`BroadcastReceiver`（广播接收器）。`Activity`、`Service`和`ContentProvider`必须在Android清单文件中注册，并可能需要权限：
- en: '`Activity`s are the UI of an Android application. They start their lifecycle
    at `onCreate`, are live to user interaction after `onResume`, and may be interrupted
    (`onPause`) at any time.'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity`是Android应用程序的用户界面。它们在`onCreate`时开始其生命周期，在`onResume`后可以与用户进行交互，并且可能随时被中断（`onPause`）。'
- en: '`Fragment`s are complex beasts with lifecycles all their own. They can be used
    to organize independent UI containers, within a UI page.'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fragment`是具有独立生命周期的复杂实体。它们可用于在UI页面中组织独立的UI容器。'
- en: '`Service`s can be started services and/or bound. API 26 started introducing
    restrictions for background use of services, so the general rule is that if the
    user interacts with a task in any way, a service ought to be made into a foreground
    service.'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Service`可以是启动服务和/或绑定服务。从API 26开始，服务的后台使用引入了限制，因此通常规则是，如果用户以任何方式与任务进行交互，则应将服务转换为前台服务。'
- en: Unless a `BroadcastReceiver` is using implicit intent that is explicitly allowed
    by the system with the action, it is probably necessary to register the broadcast
    receiver dynamically from application code.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非`BroadcastReceiver`使用了系统明确允许的隐式意图和操作，否则可能需要从应用程序代码动态注册广播接收器。
- en: Use the `Activity Context` carefully. Activities have a lifecycle that is not
    under the control of your application. A reference to an `Activity` *must* respect
    the actual lifecycle of the Activity.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谨慎使用`Activity Context`。活动具有不受您应用程序控制的生命周期。对`Activity`的引用*必须*遵守活动的实际生命周期。
- en: General software architectures in Android, like MVI, MVP, and MVVM, are designed
    to keep `Fragment`s and `Activity`s lean and encourage better separation of concern
    and testing and while being “lifecycle-aware.”
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android中的一般软件架构，如MVI、MVP和MVVM，旨在使`Fragment`和`Activity`保持简洁，并鼓励更好地分离关注点和测试，同时具备“生命周期感知”。
- en: Now that we’ve reviewed the ground rules and explored the playing field, our
    journey to achieving structured coroutines in Kotlin officially starts. In the
    following chapter, we begin to apply this foundation to examining memory and threading
    in Android. Understanding the details of Android’s organization will reveal the
    issues that the coming chapters set out to solve.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经复习了基本规则并探索了领域，我们正式开始在Kotlin中实现结构化协程的旅程。在接下来的章节中，我们将开始将此基础应用于研究Android中的内存和线程。了解Android的组织细节将揭示即将解决的问题。
