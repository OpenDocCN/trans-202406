- en: Chapter 8\. Observability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。可观测性
- en: You need visibility into what’s going on across the stack—from the kernel to
    user-facing parts. Often, you get that visibility by knowing the right tool for
    the task.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要了解整个堆栈的运行情况——从内核到面向用户的部分。通常，您可以通过知道任务的正确工具来获得这种可见性。
- en: 'This chapter is all about gathering and using different signals that Linux
    and its applications generate so that you can make informed decisions. For example,
    you’ll see how you can do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论收集和利用Linux及其应用程序生成的不同信号，以便您能够做出明智的决策。例如，您将看到如何执行以下操作：
- en: Figure out how much memory a process consumes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弄清楚进程消耗了多少内存
- en: Understand how soon you will run out of disk space
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解磁盘空间将会在多快的时间内耗尽
- en: Get an alert on custom events for security reasons
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取安全事件的自定义事件警报
- en: To establish a common vocabulary, we’ll first review different signal types
    you might come across, such as system or application logs, metrics, and process
    traces. We’ll also have a look at how to go about troubleshooting and measuring
    performance. Next, we’ll focus on logs specifically, reviewing different options
    and semantics. Then, we’ll cover monitoring for different resource types, such
    as CPU cycles, memory, or I/O traffic. We’ll review different tools that you can
    use and show certain end-to-end setup you may wish to adopt.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立共同的词汇表，我们首先将回顾您可能遇到的不同信号类型，例如系统或应用程序日志、指标和进程跟踪。我们还将探讨如何进行故障排除和性能测量。接下来，我们将重点介绍日志，回顾不同的选项和语义。然后，我们将涵盖不同资源类型的监控，例如CPU周期、内存或I/O流量。我们将审视您可以使用的不同工具，并展示您可能希望采用的特定端到端设置。
- en: You’ll learn that observability is often reactionary. That is, something crashes
    or runs slowly, and you start looking at processes and their CPU or memory usage,
    or dig into the logs. But there are also times when observability has more of
    an investigative nature—for example, when you want to figure out how long certain
    algorithms take. Last but not least, you can use predictive (rather than reactive)
    observability. For example, you can be alerted on a condition in the future, extrapolating
    the current behavior (disk usage for a predictable load is a good example where
    that might work well).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您将了解到可观测性通常是一种反应性的。也就是说，某些情况下会出现崩溃或运行缓慢，然后您开始查看进程及其CPU或内存使用情况，或者深入查看日志。但有时可观测性更具调查性质——例如，当您想要弄清楚某些算法需要多长时间时。最后但同样重要的是，您可以使用预测性（而不是反应性）的可观测性。例如，您可以在将来的某种条件下收到警报，推测当前行为（对于可预测负载的磁盘使用情况就是一个很好的例子）。
- en: Likely the best visual overview on observability comes from performance maestro
    Brendan Gregg. [Figure 8-1](#fig-linux-o11y), taken from his [Linux Performance
    site](https://oreil.ly/KlzQP), gives you a feeling for the wealth of moving parts
    and tooling available.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可观测性的最佳视觉概述可能来自性能专家Brendan Gregg。从他的[Linux Performance站点](https://oreil.ly/KlzQP)获取的[图8-1](#fig-linux-o11y)让您感受到可用的各种移动部件和工具的丰富性。
- en: '![lmlx 0801](Images/lmlx_0801.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![lmlx 0801](Images/lmlx_0801.png)'
- en: 'Figure 8-1\. Linux observability overview. *Credit*: Brendan Gregg (shared
    under CC BY-SA 4.0 license)'
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-1\. Linux可观测性概述。*来源*：Brendan Gregg（在CC BY-SA 4.0许可下共享）
- en: Observability is an exciting topic with many use cases and lots of (open source)
    tooling available, so let’s first establish a strategy and look at some common
    terms used.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测性是一个涵盖许多用例和大量（开源）工具的令人兴奋的主题，因此让我们首先建立一个策略，并查看一些常用术语。
- en: Basics
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: Before we get into the observability terminology, let’s step back a bit and
    look at how you turn the information provided into actionable insights and use
    it to fix an issue or optimize an app in a structured manner.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论可观测性术语之前，让我们退后一步，看看如何将提供的信息转化为可操作的洞察力，并以结构化方式修复问题或优化应用程序。
- en: Observability Strategy
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观测性策略
- en: One widely established strategy in the observability context is the [OODA loop
    (observe–orient–decide–act)](https://oreil.ly/zLLET). It offers a structured way
    to test a hypothesis based on observed data and act upon it—that is, a way to
    get actionable insights from signals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在可观测性背景下广泛使用的一种策略是[OODA循环（观察-定向-决策-行动）](https://oreil.ly/zLLET)。它提供了一种基于观察数据进行假设测试并采取行动的结构化方法——即从信号中获取可操作的洞察力。
- en: For example, let’s say an application is slow. Let’s further assume there are
    multiple possible reasons for this (not enough memory, too few CPU cycles, network
    I/O insufficient, etc.). First, you want to be able to measure each resource consumption.
    Then you would change each resource allocation individually (keeping the others
    unchanged) and measure the outcome.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设一个应用程序运行缓慢。我们进一步假设有多种可能的原因（内存不足、CPU周期太少、网络I/O不足等）。首先，您需要能够测量每个资源的消耗情况。然后，您将分别更改每个资源的分配（保持其他资源不变）并测量结果。
- en: Does the performance improve after you provided more RAM to the app? If so,
    you may have found the reason. If not, you continue with a different resource,
    always measuring the consumption and trying to relate to the observed impact on
    the situation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您为应用程序提供更多的RAM后性能有所改善吗？如果是这样，您可能已经找到了原因。如果没有，您将继续尝试其他资源，始终测量消耗并尝试将其与观察到的情况影响联系起来。
- en: Terminology
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语
- en: 'There are a range of terms in the observability space,^([1](ch08.xhtml#idm45805428798080))
    and not all have formal definitions. In addition, the meanings might slightly
    differ if you’re looking at a single machine or are in a networked (distributed)
    setup:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在可观测性领域存在一系列术语，^([1](ch08.xhtml#idm45805428798080))并非所有术语都有正式的定义。此外，如果您观察单个机器或处于网络化（分布式）设置中，其含义可能会略有不同：
- en: Observability
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察性
- en: Assessing the internal state of a system (such as Linux) by measuring external
    information, usually with the goal of acting upon it. For example, if you notice
    that your system reacts sluggishly, and measure how much main memory is available,
    you might find that a particular app hogs all the memory, and you may decide to
    terminate it to remedy the situation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测量外部信息来评估系统（例如Linux）的内部状态，通常的目的是对其进行响应。例如，如果您注意到系统反应迟钝，并且测量可用主存储器的数量，您可能会发现某个特定的应用程序占用了所有的内存，于是您可能决定终止它以解决问题。
- en: Signal types
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 信号类型
- en: Different ways to represent and emit information about the state of a system,
    either via symbolic means (payload is text, such as the case with logs) or numerical
    values (as with metrics) or combinations thereof. See also [“Signal Types”](#o11y-signals).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表示和发出关于系统状态的信息的不同方式，可以通过符号方式（负载为文本，例如日志的情况）或数值方式（如指标的情况），或者它们的组合。另请参见[“信号类型”](#o11y-signals)。
- en: Source
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 源
- en: Generates signals, potentially of different types. Sources can be the Linux
    operating system or an application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 生成信号，可能是不同类型的信号。源可以是Linux操作系统或应用程序。
- en: Destination
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目的地
- en: Where you consume, store, and further process signals. We call a destination
    that exposes a user interface (GUI, TUI, or CLI) a *frontend*. For example, a
    log viewer or a dashboard plotting time series is a frontend, whereas an S3 bucket
    is not (but can still act as a destination for, say, logs).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 消费、存储和进一步处理信号的地方称为**目的地**。我们将暴露用户界面（GUI、TUI或CLI）的目的地称为*前端*。例如，日志查看器或绘制时间序列的仪表板就是前端，而S3存储桶则不是（但仍可作为日志等信息的目的地）。
- en: Telemetry
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 遥测
- en: The process of extracting signals from sources and transporting (or routing,
    shipping) the signals to destinations, often employing agents that collect and/or
    preprocess signals (for example, filter or downsample).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从源中提取信号并将信号传输（或路由、发送）到目的地的过程，通常使用代理收集和/或预处理信号（例如过滤或下采样）。
- en: Signal Types
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号类型
- en: '*Signals* are how we communicate the state of a system for further processing
    or interpretation. By and large we distinguish between text payload (which is
    most suited for a human to search and interpret) and numerical payload (good for
    both machines and, in processed form, for humans). The three basic and common
    signal types relevant to our discussion in this chapter are: logs, metrics, and
    traces.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*信号*是我们用来传达系统状态以供进一步处理或解释的方式。总体而言，我们区分文本负载（最适合人类搜索和解释）和数值负载（对于机器和处理后的人类都很好）。在本章讨论中，与我们讨论相关的三种基本且常见的信号类型是：日志、指标和跟踪。'
- en: Logs
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志
- en: '*Logs* are a fundamental signal type that every system, to some extent, generates.
    Logs are discrete events with a textual payload, meant for human consumption.
    Typically, these events are timestamped. Ideally, the logs are structured so that
    there is a clear meaning defined for each part of the log message. This meaning
    is potentially expressed through a formal schema so that validation can be automatically
    performed.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, while every log has some structure (even if it’s not well defined
    and parsing is hard, potentially due to delimiter or edge cases), you will often
    hear the term *structured logging*. When people say that, they actually mean that
    the log is structured using JSON.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: While automating log content is hard (given its textual nature), logs are still
    very useful for humans, and thus they will likely stay the dominating signal type
    for some time. We’ll dig deeper into handling logs in [“Logging”](#logging). Logs
    are the most important signal type (for our considerations), and that’s why we’ll
    spend most of the time in this chapter dealing with them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Metrics* are (usually regularly) sampled numerical data points, forming a
    time series. The individual data points can have additional context in the form
    of dimensions or identifying metadata. Normally, you don’t directly consume the
    raw metrics; instead, you use some sort of aggregation or graphical representation,
    or you get notified if a certain condition is met. Metrics can be useful both
    for operational tasks and for troubleshooting to answer questions like how many
    transactions an app completed or how long a certain operation took (in the past
    X minutes).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'We distinguish between different types of metrics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Counter
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The value of a counter can only ever go up (besides resetting a counter to zero).
    An example of a counter metric is the total number of requests handled by a service
    or the bytes sent via an interface over a time period.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Gauges
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: A gauge value can go up or down. For example, you gauge the currently available
    overall main memory or the number of processes running.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Histograms
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: A sophisticated way to build a distribution of values. Using buckets, histograms
    allow you to assess how the data overall is structured. They also enable you to
    make flexible statements (such as 50% or 90% of the values fall into a certain
    range).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In [“Monitoring”](#monitoring), we have a look at a range of tools that you
    can use for simple use cases, and in [“Prometheus and Grafana”](#prometheus-grafana),
    you see an advanced example setup for metrics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Traces
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Traces* are a dynamic collection of runtime information (for example, information
    about what syscalls a process uses, or the sequence of events in the kernel, for
    a given cause). Traces are often used not only for debugging but also for performance
    assessments. We have a look at this advanced topic in [“Tracing and Profiling”](#tracing).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, logs are (a collection of) discrete events with a textual
    payload, optimized for human consumption. Let’s decompose this statement to understand
    it better:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，日志是（一组）文本有效负载的离散事件，优化供人类消费。让我们分解这个陈述以更好地理解它：
- en: Discrete events
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 离散事件
- en: Think of a discrete event in the context of the codebase. You want to share
    information about what is going on in the code using an (atomic) log item. For
    example, you emit a log line that a database connection has been established successfully.
    Another log item might be to flag an error because a file is missing. Keep the
    scope of the log message small and specific, so it’s easier for someone consuming
    the message to find the respective location in the code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码库的上下文中，想象一个离散事件。您希望使用（原子性）日志项共享关于代码中正在进行的情况的信息。例如，您发出一个日志行，指示数据库连接已成功建立。另一个日志项可能是因为文件丢失而标记错误。保持日志消息的范围小而具体，这样消费消息的人更容易找到代码中相应的位置。
- en: Textual payload
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 文本有效负载
- en: The payload of a log message is of textual nature. The default consumers are
    humans. In other words, no matter if you’re using a log viewer on the command
    line, or a fancy log-processing system with visual UI, a human reads and interprets
    the content of the log message and decides on an action based on it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 日志消息的有效负载是文本性质的。默认的消费者是人类。换句话说，无论您是在命令行上使用日志查看器还是在具有可视化用户界面的高级日志处理系统中，人类读取和解释日志消息的内容，并根据此内容决定采取行动。
- en: 'From a structural perspective, overall, a log comprises the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从结构上看，总体而言，日志包括以下内容：
- en: A collection of log items, messages, or lines
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一组日志项、消息或行
- en: Captures information about a discrete event.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获关于离散事件的信息。
- en: Metadata or context
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据或上下文
- en: Can be present on a per-message basis as well as on a global scope (the entire
    log file, for example).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以每条消息的方式出现，也可以在全局范围（例如整个日志文件）上出现。
- en: A format for how an individual log message is to be interpreted
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于解释单个日志消息的格式
- en: Defines the log’s parts and meanings. Examples are line-oriented, space-separated
    messages or a JSON schema.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 定义日志的部分和含义。例如，面向行的、空格分隔的消息或JSON模式。
- en: In [Table 8-1](#tab-log-formats), you can see some common log formats. There
    are many (more-specific, narrower-scoped) formats and frameworks—for example,
    for database or programming languages.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[表8-1](#tab-log-formats)中，您可以看到一些常见的日志格式。例如，用于数据库或编程语言的（更具体、范围更窄的）格式和框架有许多。
- en: Table 8-1\. Common log formats
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 表8-1. 常见日志格式
- en: '| Format | Note |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 格式 | 注意 |'
- en: '| --- | --- |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Common event format](https://oreil.ly/rHBWs) | Developed by ArcSight; used
    for devices, security use cases |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| [常见事件格式](https://oreil.ly/rHBWs) | 由ArcSight开发；用于设备、安全用例 |'
- en: '| [Common log format](https://oreil.ly/Da7uC) | For web servers; see also extended
    log format |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| [常见日志格式](https://oreil.ly/Da7uC) | 用于Web服务器；另见扩展日志格式 |'
- en: '| [Graylog extended log format](https://oreil.ly/6MBHm) | Developed by Graylog;
    improves Syslog |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| [Graylog扩展日志格式](https://oreil.ly/6MBHm) | 由Graylog开发；改进Syslog |'
- en: '| Syslog | For operating systems, apps, devices; see [“Syslog”](#syslog) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| Syslog | 用于操作系统、应用程序、设备；参见[“Syslog”](#syslog) |'
- en: '| [Embedded metric format](https://oreil.ly/LeXhe) | Developed by Amazon (both
    logs and metrics) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| [嵌入式度量格式](https://oreil.ly/LeXhe) | 由亚马逊开发（既有日志又有度量） |'
- en: As a good practice, you want to avoid overhead with logs (enabling fast lookups
    and a small footprint—that is, not taking up too much disk space). In this context,
    log rotation, for example, via [`logrotate`](https://oreil.ly/jX6Jy), is used.
    An advanced concept called *data temperature* may also be useful, moving older
    log files to cheaper and slower storage (attached disk, S3 bucket, Glacier).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，您希望避免日志的开销（启用快速查找和小的占地面积——即不占用太多磁盘空间）。在这种情况下，例如通过[`logrotate`](https://oreil.ly/jX6Jy)进行日志轮换是常用的。一个称为*数据温度*的高级概念也可能很有用，将较旧的日志文件移动到更便宜和更慢的存储（附加磁盘、S3存储桶、Glacier）中。
- en: Warning
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: There’s one case where you need to be careful about logging information, especially
    in production environments. Whenever you decide to emit a log line in your app,
    ask yourself if you could potentially leak sensitive information. This sensitive
    information could be a password, an API key, or even simply user-identifying information
    (email, account ID).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个情况需要特别注意日志信息，特别是在生产环境中。每当您决定在应用程序中发出一条日志行时，请问自己是否可能泄露敏感信息。这些敏感信息可能是密码、API密钥，甚至只是用户识别信息（电子邮件、帐户ID）。
- en: The problem is that the logs are usually stored in a persistent form (say, on
    local disk or even in an S3 bucket). This means that even long after the process
    has terminated, someone could get access to the sensitive information and use
    it for an attack.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: To signal the importance or intended target consumer of a log item, logs often
    define levels (for example `DEBUG` for development, `INFO` for normal status,
    or `ERROR` for unexpected situations that may require human intervention).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to get our hands dirty: let’s start with something simple and,
    as an overview, have a look at Linux’s central log directory (output shortened
    for readability):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_observability_CO1-1)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Logs of the `apt` package manager
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO1-2)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Logs of all login attempts (successful and failed) and authentication processes
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO1-3)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Failed login attempts
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO1-4)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Printing related logs
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_observability_CO1-5)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Logs of the `dpkg` package manager
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_observability_CO1-6)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Device driver logs; use `dmesg` to inspect
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_observability_CO1-7)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: System install logs (when the Linux distro was originally installed)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_observability_CO1-8)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The `journalctl` location; see [“journalctl”](#journalctl) for details
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](#co_observability_CO1-9)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The kernel logs
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](Images/10.png)](#co_observability_CO1-10)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: All last logins of all users; use `lastlog` to inspect
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](Images/11.png)](#co_observability_CO1-11)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: NTP-related logs (see also [“Network Time Protocol”](ch07.xhtml#ntp))
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](Images/12.png)](#co_observability_CO1-12)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: The `syslogd` location; see [“Syslog”](#syslog) for details
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'One common pattern for consuming logs live (that is, as it happens) is to *follow
    logs*; that is, you watch the end of the log as new log lines are added (edited
    to fit):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](Images/1.png)](#co_observability_CO2-1)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Follow the logs of the `syslogd` process with the `-f` option.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO2-2)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: An example log line; see [“Syslog”](#syslog) for the format.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to see the log output of a process and at the same time store it
    in a file, you can use the [`tee` command](https://oreil.ly/X1Gqo):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now you’d see the output of `someprocess` in your terminal, and the output would
    at the same time be stored in *some.log*. Note that we’re using the `-a` option
    to append to the log file, otherwise it would be truncated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now have a look at the two most commonly used Linux logging systems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Syslog
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syslog is a logging standard for a range of sources, from the kernel to daemons
    to user space. It has its roots in networked environments, and today the protocol
    comprises a textual format defined in [RFC 5424](https://oreil.ly/1Qqng), along
    with deployment scenarios and security considerations. [Figure 8-2](#fig-syslog-format)
    shows the high-level format of Syslog, but be aware that there are many seldom-used
    optional fields.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0802](Images/lmlx_0802.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Syslog format as per RFC 5424
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The Syslog format as defined in RFC 5424 has the following header fields (with
    `TS` and `HN` the most often used):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '`PRI`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The message facility/severity
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`VER`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: The Syslog protocol number (usually left out since it can only be 1)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '`TS`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Contains the time when the message was generated using ISO 8601 format
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '`HN`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the machine that sent the message
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '`APP`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the application (or a device) that sent the message
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`PID`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the process that sent the message
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`MID`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: An optional message ID
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The format also includes *structured data*, which is the payload in a structured
    (key/value-based) list where each element is bounded by `[ ]`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, one would use the [`syslogd` binary](https://oreil.ly/su6IX) to take
    care of the log management. Over time, other options have become available that
    you should be aware of:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[`syslog-ng`](https://oreil.ly/qETe9)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: An enhanced log daemon that you can use as a drop-in replacement for `syslogd`
    and that in addition supports TLS, content-based filtering, and logging into databases
    such as PostgreSQL and MongoDB. Available since late 1990.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[`rsyslog`](https://oreil.ly/QDPmv)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Extends the Syslog protocol and can also be used with `systemd`. Available since
    2004.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite its age, the Syslog family of protocols and tools is still around and
    widely available. With `systemd` becoming the de facto standard of init systems,
    used in every major Linux distro, there is, however, a new way to go about logging:
    meet the `systemd` journal.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: journalctl
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [“systemd”](ch06.xhtml#systemd), we briefly touched upon a component that
    is part of the `systemd` ecosystem, responsible for log management: [`journalctl`](https://oreil.ly/M4sbo).
    In contrast to Syslog and the other systems we’ve used so far, `journalctl` uses
    a binary format to store the log items. This allows faster access and better storage
    footprints.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The binary storage format did attract some criticism when it was introduced
    since people are not able to continue to use the familiar `tail`, `cat`, and `grep`
    commands to view and search logs. Having said that, while one has to learn a new
    way to interact with logs when using `journalctl`, the learning curve is not too
    bad.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at some common tasks. If you launch `journalctl` without parameters,
    it will present itself as an interactive pager (you can use the arrow keys or
    space bar to scroll through it and exit with `q`) for all the logs.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'To restrict the time range, you can, for example, use the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](Images/1.png)](#co_observability_CO3-1)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_observability_CO3-1)'
- en: Restrict the time range to what happened in the past three hours.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 限制时间范围到过去三小时发生的事情。
- en: '[![2](Images/2.png)](#co_observability_CO3-2)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_observability_CO3-2)'
- en: Another way to restrict the time range, with explicit start and stop times.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种限制时间范围的方式，带有明确的开始和结束时间。
- en: 'You can limit the output to specific `systemd` units like so (assuming there
    is a service called `abc.service`):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以限制输出到特定的`systemd`单元，例如（假设有一个名为`abc.service`的服务）：
- en: '[PRE4]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The `journalctl` tool has a powerful way to format the output of the log items.
    Using the `--output` (or `-o` for short) parameter, you can optimize the output
    for a certain use case. Important values are the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`journalctl`工具具有强大的日志项输出格式化方式。使用`--output`（或简写为`-o`）参数，您可以优化输出以适应特定的用例。重要的值如下：'
- en: '`cat`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`'
- en: Short form, without time stamp or source
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 简短形式，没有时间戳或来源
- en: '`short`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`short`'
- en: The default, emulating Syslog output
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模拟Syslog输出
- en: '`json`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`json`'
- en: One JSON-formatted entry per line (for automation)
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每行一个JSON格式的条目（用于自动化）
- en: 'You can have the same experience to follow the logs as you’d have with `tail
    -f` using the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方式跟随日志，就像使用`tail -f`一样：
- en: '[PRE5]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let’s put all the preceding information together into a concrete example. Assume
    you want to relaunch a security component of the Linux distro, managed by `systemd`:
    [AppArmor](https://www.apparmor.net). That is, in one terminal we restart the
    service using `systemctl restart apparmor`, and in another we execute the following
    command (output edited; the actual output is one log item per line):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将前面的所有信息放在一起，形成一个具体的示例。假设您希望重新启动由`systemd`管理的Linux发行版的安全组件：[AppArmor](https://www.apparmor.net)。也就是说，在一个终端中我们使用`systemctl
    restart apparmor`重新启动服务，在另一个终端中我们执行以下命令（输出经过编辑；实际输出是每行一个日志项）：
- en: '[PRE6]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](Images/1.png)](#co_observability_CO4-1)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_observability_CO4-1)'
- en: Follow the logs of the AppArmor service.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随AppArmor服务的日志。
- en: '[![2](Images/2.png)](#co_observability_CO4-2)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_observability_CO4-2)'
- en: After `systemd` has stopped the service, here it comes back up again.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在`systemd`停止服务后，它会再次启动。
- en: With that we are at the end of the logging section and move on to numerical
    values with metrics and the wider topic of monitoring.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就到了日志部分的结尾，然后转向数值值和更广泛的监控主题。
- en: Monitoring
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: '*Monitoring* is the capturing of system and application metrics for a variety
    of reasons. For example, you may be interested in how long something takes or
    how many resources a process consumes (performance monitoring), or you may be
    troubleshooting an unhealthy system. The two types of activities you’ll carry
    out most often in the context of monitoring are as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*监控*是为了各种原因捕获系统和应用程序指标。例如，您可能对某个操作花费的时间或进程消耗的资源（性能监控）感兴趣，或者您可能正在排除一个不健康的系统。在监控的上下文中，您最常执行的两种活动如下：'
- en: Tracking one or more metrics (over time)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪一个或多个指标（随时间变化）
- en: Alerting on a condition
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在条件上发出警报
- en: In this section, we first focus on some foundations and tools you should be
    aware of, and as we move further into the section, we get into more advanced techniques
    that may be relevant only in certain situations.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先关注您应该了解的一些基础知识和工具，随着我们深入到更多只在特定情况下相关的高级技术。
- en: 'Let’s look at a simple example that displays some basic metrics, such as how
    long a system is running, memory usage, and more, using the [`uptime` command](https://oreil.ly/smiz6):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子，显示一些基本的指标，比如系统运行时间，内存使用情况等，使用[`uptime`命令](https://oreil.ly/smiz6)：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](Images/1.png)](#co_observability_CO5-1)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_observability_CO5-1)'
- en: Use the `uptime` command to display some basic system metrics.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`uptime`命令显示一些基本的系统指标。
- en: '[![2](Images/2.png)](#co_observability_CO5-2)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_observability_CO5-2)'
- en: 'Separated by commas, the output tells us how long the system is running, the
    number of users logged in, and then (in the `load average` section) three gauges:
    the 1-minute, 5-minute, and 15-minute average. These averages are the number of
    jobs in the run queue or waiting for disk I/O; the numbers are normalized and
    indicate how busy the CPUs are. For example, here the load average for the past
    5 minutes was 0.2 (which in isolation doesn’t tell you much, so you have to compare
    it with the other values and track it over time).'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s monitor some basic memory utilization, using the `free` command
    (output compressed to fit):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](Images/1.png)](#co_observability_CO6-1)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Show memory usage using a human-friendly output.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO6-2)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory stats: total/used/free/shared memory, memory used in buffers and
    used for caching (use `-w` if you don’t want the combined value), and the available
    memory.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO6-3)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: The total/used/free amount of swap space—that is, physical memory moved out
    to a swap disk space.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'A more sophisticated way to look at memory usage is using the [`vmstat` (short
    for virtual memory stats) command](https://oreil.ly/x8wrI). The following example
    uses `vmstat` in a self-updating manner (output edited to fit):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](Images/1.png)](#co_observability_CO7-1)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Show memory stats. The argument `1` means to print a new summary line every
    second.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO7-2)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important column headers: `r` is for the number of processes running or
    waiting for CPU (should be less than or equal to the number of CPUs you have),
    `free` is the free main memory in KB, `in` is the number of interrupts per second,
    `cs` is the number of context switches per second, and `us` to `st` are percentages
    of total CPU time across user space, kernel, idle, and the like.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how long a certain operation takes, you can use the `time` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](Images/1.png)](#co_observability_CO8-1)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Measure how long recursively listing all */etc* subdirectories takes (we throw
    away all output, including errors, with `2&> /dev/null`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO8-2)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The total (wall clock) time it took (not really useful other than for performance).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO8-3)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: How long `ls` itself spent on-CPU (user space).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO8-4)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: How long `ls` was waiting for Linux to do something (kernel space).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, if you’re interested in how long an operation took,
    taking the sum of `user` and `sys` is a good approximation, and the ratio of the
    two gives you a good idea where it spends most of the execution time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we focus on some more specific topics: network interfaces and block devices.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Device I/O and Network Interfaces
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With [`iostat`](https://oreil.ly/L4Pbu) you can monitor I/O devices (output
    edited):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](Images/1.png)](#co_observability_CO9-1)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Use `iostat` to show I/O device metrics. With `-z`, we tell it to show only
    devices where there was some activity, and the `--human` makes the output nicer
    (units are in human-readable form).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO9-2)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 'Example row: `tps` is the number of transfers (I/O requests) per second for
    that device, `read` is data volume, and `wrtn` is written data.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up: network interfaces with the [`ss` command](https://oreil.ly/BAIiv)
    that can dump socket statistics (see also [“Sockets”](ch07.xhtml#sockets)). The
    following command lists both TCP and UDP sockets along with process IDs (output
    edited to fit):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](Images/1.png)](#co_observability_CO10-1)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ss` with the following options: with `-a`, we select all (that is, both
    listening and nonlistening sockets); the `-t` and `-u` select TCP and UDP, respectively;
    and `-p` shows the processes using the sockets.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO10-2)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'An example socket in use. It’s an established TCP connection between local
    IPv4 address `192.168.178.40` and remote `74.125.193.188` that seems idle: both
    data queued for receive (`Recv-Q`) and transmit (`Send-Q`) report zero.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-217
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An outdated way to gather and display interface stats is using [`netstat`](https://oreil.ly/UBqge).
    For example, if you want to have a continuously updated view on TCP and UDP, including
    process ID and using IP addresses rather than FQDNs, you could use `netstat -ctulpn`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[`lsof`](https://oreil.ly/qDT67) stands for “list open files” and is a versatile
    tool with many use cases. The following example shows `lsof` used in the context
    of network connections (output edited to fit):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](Images/1.png)](#co_observability_CO11-1)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: List privileged TCP ports (needs `root` privileges).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Another usage example for `lsof` is a process-centric view: if you know the
    PID of a process (here, Chrome), you can use `lsof` to track file descriptors,
    I/O, etc. (output edited to fit):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: There are many more tools for (performance) monitoring available—for example,
    [`sar`](https://oreil.ly/dYWwR) (covering a range of counters, nice for scripts)
    and [`perf`](https://oreil.ly/TJ4gP)—some of which we will discuss in [“Advanced
    Observability”](#advanced-o11y).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a handle on individual tools, let’s move on to integrated
    tools that allow you to interactively monitor Linux.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Performance Monitors
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the tooling we discussed in the previous section, such as `lsof` or `vmstat`,
    is a good starting point and also useful in scripts. For more convenient monitoring,
    you may prefer integrated solutions. These typically come with a textual user
    interface (TUI), sometimes in color, and offer the following features:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Support for multiple resource types (CPU, RAM, I/O)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive sorting and filtering (by process, user, resource)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live updates and drill-down into details such as a process group or even cgroups
    and namespaces
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the widely available [`top`](https://oreil.ly/NqKO2) provides
    an overview in the header—akin to what we saw in the `uptime` output—and then
    a tabular rendering of CPU and memory details, followed by a list of processes
    you can track (output edited):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](Images/1.png)](#co_observability_CO12-1)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: Summary of system (compare with `uptime` output)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO12-2)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Task statistics
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO12-3)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: CPU usage statistics (user, kernel, etc.; similar to `vmstat` output)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO12-4)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic process list, including details on a per-process level; comparable
    to `ps aux` output
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the most important keys to remember in `top`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '`?`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: To list the help (including key mappings)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '`V`'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: To toggle to and from process tree view
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '`m`'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: To sort by memory usage
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '`P`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: To sort by CPU consumption
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`k`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: To send a signal (like to `kill`)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '`q`'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: To quit
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'While `top` is available in virtually any environment, there are a number of
    alternatives available, including the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[`htop`](https://oreil.ly/P9elE) ([Figure 8-3](#fig-htop))'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: An incremental `top` improvement that is faster than `top` and has a nicer user
    interface.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[`atop`](https://oreil.ly/luRoU) ([Figure 8-4](#fig-atop))'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: A powerful alternative to `top`. In addition to CPU and memory, it covers resources
    such as I/O and network stats in great detail.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[`below`](https://oreil.ly/XdOHB)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: A relatively new tool that is notable especially because it is cgroups v2–aware
    (see [“Linux cgroups”](ch06.xhtml#cgroups)). Other tools do not understand cgroups
    and hence provide only a global resource view.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0803](Images/lmlx_0803.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. A screenshot of the `htop` tool
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![lmlx 0804](Images/lmlx_0804.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. A screenshot of the `atop` tool
  id: totrans-266
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are a number of other integrated monitoring tools available that go beyond
    the basic sources or that specialize in certain use cases. These include but are
    not limited to the following:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[glances](https://oreil.ly/zOC9e)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: A powerful hybrid that covers devices in addition to the usual resources
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[guider](https://oreil.ly/uqBH1)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: An integrated performance analyzer that allows you to display and graph a range
    of metrics
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[neoss](https://oreil.ly/O4BHS)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: For network traffic monitoring; an `ss` replacement that offers a nice TUI
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[mtr](https://oreil.ly/uL38A)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: For network traffic monitoring; a more powerful alternative to `traceroute`
    (see [“Routing”](ch07.xhtml#routing) for details on `traceroute`)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a broad understanding of the tooling to consume system metrics,
    let’s see how you can expose those from your own code.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Instrumentation
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve focused on signals coming from the kernel or existing applications
    (that is, code that you don’t own). Now we move to the topic of how you can, similar
    to logs, equip your code to emit metrics.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of inserting code to emit signals, especially metrics, is mainly
    relevant if you’re developing software. This process is usually referred to as
    *instrumentation*, and there are two common instrumentation strategies: *autoinstrumentation*
    (no additional effort for you as a developer) and *custom instrumentation*, where
    you manually insert code snippets to, for example, emit a metric at a certain
    point in your code base.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码插入以发出信号（特别是指标）的过程，如果您是开发软件，这个过程通常是相关的。这个过程通常称为*仪器化*，并且有两种常见的仪器化策略：*自动仪器化*（作为开发者，您无需额外的工作）和*自定义仪器化*，在其中您手动插入代码片段，例如在代码库的某个点发出一个指标。
- en: You can use [StatsD](https://oreil.ly/XOYFE), with client-side libraries available
    for a number of programming languages, such as [Ruby](https://oreil.ly/VfE4D),
    [Node.js](https://oreil.ly/G9Jt3), [Python](https://oreil.ly/hQBMf), and [Go](https://oreil.ly/whpZV).
    StatsD is nice, but it has a few limitations, especially in dynamic environments
    such as Kubernetes or IoT. In those environments, a different approach—sometimes
    called *pull-based* or *scraping*—is usually a better choice. With scraping, applications
    expose metrics (usually via an HTTP endpoint), and an agent then calls this endpoint
    to retrieve metrics, rather than configuring the app with where to send the metrics
    to. We’ll return to this topic in [“Prometheus and Grafana”](#prometheus-grafana).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用[StatsD](https://oreil.ly/XOYFE)，针对多种编程语言提供了客户端库，例如[ Ruby](https://oreil.ly/VfE4D)，[
    Node.js](https://oreil.ly/G9Jt3)，[ Python](https://oreil.ly/hQBMf) 和 [ Go](https://oreil.ly/whpZV)。StatsD
    很好用，但在 Kubernetes 或 IoT 等动态环境中存在一些限制。在这些环境中，通常更好的选择是一种称为*拉取式*或*抓取*的不同方法。使用抓取，应用程序公开指标（通常通过
    HTTP 端点），然后代理调用此端点以检索指标，而不是配置应用程序发送指标的位置。我们将在[“Prometheus 和 Grafana”](#prometheus-grafana)中返回该主题。
- en: Advanced Observability
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级可观测性
- en: Now that you know the basics of Linux observability, let’s have a look at some
    more advanced topics in this space.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了 Linux 可观测性的基础知识，让我们来看看这个领域中的一些更高级的主题。
- en: Tracing and Profiling
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪和分析
- en: 'The term *tracing* is overloaded: in the context of Linux, on a single machine,
    tracing means capturing the process execution (function calls in user space, syscalls,
    etc.) over time.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '*跟踪*这个术语有多重含义：在 Linux 的上下文中，在单台机器上，跟踪意味着随时间捕获进程执行（用户空间的函数调用，系统调用等）。'
- en: Note
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In a distributed setup like containerized microservices in Kubernetes or a bunch
    of Lambda functions that are part of a serverless app, we sometimes shorten [*distributed
    tracing*](https://oreil.ly/tTjY9) (for example, with OpenTelemetry and Jaeger)
    to *tracing*. This type of tracing is out of scope for this book.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在分布式设置中，例如在 Kubernetes 中容器化的微服务或一堆 Lambda 函数作为无服务器应用的一部分，我们有时会将[*分布式跟踪*](https://oreil.ly/tTjY9)（例如使用
    OpenTelemetry 和 Jaeger）缩写为*跟踪*。这种类型的跟踪不在本书的讨论范围之内。
- en: 'There are a number of data sources in the context of a single Linux machine.
    You can use the following as sources for tracing:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在单台 Linux 机器的上下文中，有许多数据源。您可以使用以下内容作为跟踪的数据源：
- en: The Linux kernel
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 内核
- en: Traces can come from functions in the kernel or be triggered by syscalls. Examples
    include [kernel probes](https://oreil.ly/lAolL) (kprobes) or [kernel tracepoints](https://oreil.ly/wZcXE).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪可以来自内核中的函数或者由系统调用触发。例如包括[内核探测器](https://oreil.ly/lAolL) (kprobes) 或者[内核跟踪点](https://oreil.ly/wZcXE)。
- en: User space
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间
- en: Application function calls, for example via [user space probes (uprobes)](https://oreil.ly/I8ICY),
    can act as a source for traces.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序功能调用，例如通过[用户空间探测器 (uprobes)](https://oreil.ly/I8ICY)，可以作为跟踪的数据源。
- en: 'Use cases for tracing include the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪的用例包括以下内容：
- en: Debugging a program using, for example, the [`strace`](https://strace.io) tracing
    tool
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用例如[`strace`](https://strace.io)跟踪工具来调试程序。
- en: Performance analysis with a frontend, using [`perf`](https://oreil.ly/izMpR)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前端进行性能分析，使用[`perf`](https://oreil.ly/izMpR)工具。
- en: Warning
  id: totrans-295
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: You may be tempted to use `strace` everywhere; however, you should be aware
    of the overhead it causes. This is particularly relevant for production environments.
    Read [“strace Wow Much Syscall”](https://oreil.ly/eSLOT) by Brendan Gregg to understand
    the background.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会倾向于在所有地方使用`strace`；然而，您应该意识到它所带来的开销。这在生产环境中尤为重要。阅读Brendan Gregg的[“strace
    Wow Much Syscall”](https://oreil.ly/eSLOT)以了解其背景。
- en: See [Figure 8-5](#fig-perf) for an example output of `sudo perf top`, which
    generates a summary by process.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[图 8-5](#fig-perf)作为`sudo perf top`的示例输出，它生成一个按进程汇总的摘要。
- en: '![lmlx 0805](Images/lmlx_0805.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![lmlx 0805](Images/lmlx_0805.png)'
- en: Figure 8-5\. A screenshot of the `perf` tracing tool
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Going forward, it seems that eBPF (see [“A Modern Way to Extend the Kernel:
    eBPF”](ch02.xhtml#ebpf)) will become the de facto standard to implement tracing,
    especially for custom cases. It has a rich ecosystem and growing vendor support,
    so if you’re looking for a future-proof tracing method, make sure it’s using eBPF.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: One particular use case for tracing is *profiling*—that is, to identify frequently
    called code sections. Some relevant low-level tooling for profiling include [`pprof`](https://oreil.ly/tETfk),
    [Valgrind](https://oreil.ly/p9HQJ), and [flame graph visualizations](https://oreil.ly/bCgbJ).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: There are many options to consume `perf` output interactively and visualize
    traces; for example, see Mark Hansen’s blog post [“Linux perf Profiler UIs”](https://oreil.ly/dGH1S).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '*Continuous profiling* is an advanced variant of profiling, which captures
    traces (kernel and user space) over time. Once these timestamped traces are collected,
    you can plot and compare them and drill down into interesting segments. One very
    promising example is the eBPF-based open source project [parca](https://www.parca.dev),
    shown in [Figure 8-6](#fig-parca).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0806](Images/lmlx_0806.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. A screenshot of parca, a continuous profiling tool
  id: totrans-305
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prometheus and Grafana
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re dealing with metrics over time (time series data), using the [Prometheus](https://prometheus.io)
    and [Grafana](https://grafana.com) combo is something you may want to consider
    for advanced observability.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show you a simple, single-machine setup that you can use to dashboard and
    even alert on things going on in your Linux machine.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the [node exporter](https://oreil.ly/0L4KJ) to expose a range of system
    metrics, from CPU to memory and network. We’ll then use Prometheus to scrape the
    node exporter. Scraping means that Prometheus calls an HTTP endpoint that the
    node exporter offers via the URL path */metrics*, returning the metrics in [OpenMetrics
    format](https://openmetrics.io). For that to happen, we need to configure Prometheus
    with the URL of the node exporter’s HTTP endpoint. The final step in our setup
    is using Prometheus as a datasource in Grafana, where you can see the time series
    data (metrics over time) in dashboards and can even alert on certain conditions,
    such as low disk space or CPUs overloading.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as a first step, download and untar the node exporter, and have it run
    the binary with `./node_exporter &` in the background. You can check if it’s running
    properly with the following (output edited):'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have the signal data source set up, we run both Prometheus and Grafana
    as containers. For the following, you’ll need Docker (see [“Docker”](ch06.xhtml#docker))
    installed and configured.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Prometheus configuration file called *prometheus.yml* with the following
    content:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_observability_CO13-1)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus itself exposes metrics, so we include this (self-monitoring).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO13-2)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_observability_CO13-2)'
- en: That’s our node exporter. Since we’re running Prometheus in Docker, we can’t
    use `localhost` but rather use the IP address Docker uses by default.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的节点导出器。由于我们在 Docker 中运行 Prometheus，不能使用`localhost`，而是要使用 Docker 默认使用的 IP
    地址。
- en: 'We use the Prometheus configuration file we created in the previous step and
    mount it into the container via a volume, like so:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用之前创建的 Prometheus 配置文件，并通过卷将其挂载到容器中，操作如下：
- en: '[PRE18]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#custom_co_observability_CO14-1)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#custom_co_observability_CO14-1)'
- en: The parameters here make Docker remove the container on exit (`--rm`), run as
    a daemon (`-d`), and expose the port 9090 (`-p`) so we can use it from our machine.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的参数使 Docker 在退出时删除容器（`--rm`），作为守护进程运行（`-d`），并公开端口 9090（`-p`），这样我们可以从本地使用它。
- en: '[![2](Images/2.png)](#custom_co_observability_CO14-2)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#custom_co_observability_CO14-2)'
- en: Mapping our config file as a volume into the container. Note that here you will
    have to replace */home/mh9/lml/o11y/* with the path where you stored it. Also,
    this has to be an absolute path. So, if you want to keep this flexible, you could
    use `$PWD` in bash or `(pwd)` in Fish rather than the hardcoded path.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的配置文件作为卷映射到容器中。请注意，在此处，你需要用存储路径替换*/home/mh9/lml/o11y/*。此外，这必须是绝对路径。因此，如果你希望保持灵活性，可以在
    bash 中使用`$PWD`，或者在 Fish 中使用`(pwd)`，而不是硬编码的路径。
- en: After you’ve executed the previous command, open *localhost:9000* in your browser,
    then click Targets in the Status dropdown menu at the top. You should, after a
    few seconds, see something like the screen shown in [Figure 8-7](#fig-prometheus),
    confirming that Prometheus has successfully scraped metrics from itself and the
    node exporter.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了上述命令后，在浏览器中打开*localhost:9000*，然后在顶部的状态下拉菜单中点击 Targets。几秒钟后，你应该会看到类似图 8-7
    中显示的屏幕，证明 Prometheus 已成功从自身和节点导出器中抓取了指标。
- en: '![lmlx 0807](Images/lmlx_0807.png)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![lmlx 0807](Images/lmlx_0807.png)'
- en: Figure 8-7\. A screenshot of Prometheus targets in the Web UI
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-7\. Prometheus Web UI 中的目标截图
- en: 'Next, we launch Grafana:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动 Grafana：
- en: '[PRE19]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After you’ve executed the preceding command, open *localhost:3000* in your
    browser and use `admin` for both the username and password. Next, we need to do
    two things:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 执行了上述命令后，在浏览器中打开*localhost:3000*，并使用`admin`作为用户名和密码。接下来，我们需要做两件事：
- en: Add [Prometheus as a datasource](https://oreil.ly/9Efhy) in Grafana, using `172.17.0.1:9100`
    as the URL
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Grafana 中添加[Prometheus 作为数据源](https://oreil.ly/9Efhy)，使用`172.17.0.1:9100`作为
    URL
- en: Import the [Node Exporter Full dashboard](https://oreil.ly/RpCDe)
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入[Node Exporter Full 仪表板](https://oreil.ly/RpCDe)
- en: Once you’ve done this, you should see something akin to [Figure 8-8](#fig-grafana).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，你应该会看到类似图 8-8 的内容。
- en: '![lmlx 0808](Images/lmlx_0808.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![lmlx 0808](Images/lmlx_0808.png)'
- en: Figure 8-8\. A screenshot of the Grafana UI with the Node Exporter Full dashboard
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-8\. Node Exporter Full 仪表板的 Grafana UI 截图
- en: That was some exciting advanced observability for Linux, using modern tooling.
    Given that the Prometheus/Grafana setup is more elaborate and has a number of
    moving parts, you’ll likely not use it for a trivial task. In other words, the
    Linux native tooling we discussed in this section should go a long way; however,
    there are more advanced use cases—for example, home automation or a media server—where
    you want to have a more complete solution, in which case Prometheus/Grafana makes
    a lot of sense.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于 Linux 的一些令人兴奋的高级可观察性，使用现代工具。考虑到 Prometheus/Grafana 的设置更为复杂，涉及多个组件，你可能不会用它来完成一个简单的任务。换句话说，在本节讨论的
    Linux 本地工具中，应该能够解决大部分问题；然而，在更高级的用例中，例如家庭自动化或媒体服务器，你可能需要更完整的解决方案，这时 Prometheus/Grafana
    就显得非常合适。
- en: Conclusion
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we looked at making sure you’re not flying blind when you’re
    running into issues with your Linux system. The main signal types you’d typically
    use for diagnostics are logs (textual) and metrics (numerical). For advanced cases,
    you can apply profiling techniques, rendering resource usage of processes along
    with the execution context (source file and lines of the source code that is being
    executed).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们确保在遇到 Linux 系统问题时不会盲目操作。你通常用于诊断的主要信号类型是日志（文本）和指标（数值）。对于高级情况，你可以应用分析技术，显示进程的资源使用情况以及执行上下文（正在执行的源文件和行）。
- en: 'If you want to learn more and dive deeper into this topic, have a look at these
    resources:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步了解并深入探讨这个主题，请查看以下资源：
- en: Basics
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 基础知识
- en: '[*Systems Performance: Enterprise and the Cloud*, second edition](https://oreil.ly/sxtPd),
    by Brendan Gregg (Addison-Wesley)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*系统性能：企业与云* 第二版](https://oreil.ly/sxtPd)，作者 Brendan Gregg（Addison-Wesley）'
- en: '[“Linux Performance Analysis in 60,000 Milliseconds”](https://oreil.ly/YVxJt)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“在 60,000 毫秒内分析 Linux 性能”](https://oreil.ly/YVxJt)'
- en: Logging
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 日志
- en: '[“Linux Logging Complete Guide”](https://oreil.ly/fMNT7)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Linux 日志完全指南”](https://oreil.ly/fMNT7)'
- en: '[“Unix/Linux—System Logging”](https://oreil.ly/hnMGz)'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Unix/Linux—系统日志”](https://oreil.ly/hnMGz)'
- en: '[“syslog-ng” on ArchWiki](https://oreil.ly/wzRqG)'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[ArchWiki 上的 “syslog-ng”](https://oreil.ly/wzRqG)'
- en: '[fluentd website](https://oreil.ly/hJ3nr)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[fluentd 网站](https://oreil.ly/hJ3nr)'
- en: Monitoring
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 监控
- en: '[“80+ Linux Monitoring Tools for SysAdmins”](https://oreil.ly/C4ZJX)'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“80+ 适用于系统管理员的 Linux 监控工具”](https://oreil.ly/C4ZJX)'
- en: '[“Monitoring StatsD: Metric Types, Format and Code Examples”](https://oreil.ly/JaUEK)'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“监控 StatsD：度量类型、格式和代码示例”](https://oreil.ly/JaUEK)'
- en: Advanced
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 高级
- en: '[“Linux Performance”](https://oreil.ly/EIPYd)'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Linux 性能”](https://oreil.ly/EIPYd)'
- en: '[“Linux Tracing Systems & How They Fit Together”](https://oreil.ly/SuGPM)'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Linux 追踪系统及其相关组件”](https://oreil.ly/SuGPM)'
- en: '[“Profilerpedia: A Map of the Software Profiling Ecosystem”](https://oreil.ly/Sk0zL)'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“Profilerpedia：软件性能分析生态系统地图”](https://oreil.ly/Sk0zL)'
- en: '[“On the State of Continuous Profiling”](https://oreil.ly/wHLqr)'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“持续性能分析现状”](https://oreil.ly/wHLqr)'
- en: '[eBPF website](https://oreil.ly/DFYMN)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[eBPF 网站](https://oreil.ly/DFYMN)'
- en: '[“Monitoring Linux Host Metrics with the Node Exporter”](https://oreil.ly/5fA6z)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[“使用 Node Exporter 监控 Linux 主机指标”](https://oreil.ly/5fA6z)'
- en: Having completed this chapter and those that preceded it, you now know the basics
    of Linux, from kernel to shell to filesystems and networking. The last chapter
    of this book is a collection of advanced topics that didn’t quite fit in other
    chapters. You may find them interesting and useful, depending on your goals, but
    for most day-to-day tasks, you now know everything you need to get by.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章和之前的章节，您现在了解了从内核到Shell再到文件系统和网络的Linux基础知识。本书的最后一章包含了一些高级主题，这些主题在其他章节中并不适合。根据您的目标，您可能会发现它们有趣且有用，但对于大多数日常任务而言，您现在已经掌握了所需的一切。
- en: ^([1](ch08.xhtml#idm45805428798080-marker)) *Observability* is also sometimes
    referred to with the numeronym *o11y*, as there are 11 letters between the *o*
    and the *y*.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.xhtml#idm45805428798080-marker)) *可观测性*有时也被称为数字术语 *o11y*，因为在 *o*
    和 *y* 之间有11个字母。
