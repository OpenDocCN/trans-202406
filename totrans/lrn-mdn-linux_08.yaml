- en: Chapter 8\. Observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You need visibility into what’s going on across the stack—from the kernel to
    user-facing parts. Often, you get that visibility by knowing the right tool for
    the task.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is all about gathering and using different signals that Linux
    and its applications generate so that you can make informed decisions. For example,
    you’ll see how you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Figure out how much memory a process consumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how soon you will run out of disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get an alert on custom events for security reasons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To establish a common vocabulary, we’ll first review different signal types
    you might come across, such as system or application logs, metrics, and process
    traces. We’ll also have a look at how to go about troubleshooting and measuring
    performance. Next, we’ll focus on logs specifically, reviewing different options
    and semantics. Then, we’ll cover monitoring for different resource types, such
    as CPU cycles, memory, or I/O traffic. We’ll review different tools that you can
    use and show certain end-to-end setup you may wish to adopt.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn that observability is often reactionary. That is, something crashes
    or runs slowly, and you start looking at processes and their CPU or memory usage,
    or dig into the logs. But there are also times when observability has more of
    an investigative nature—for example, when you want to figure out how long certain
    algorithms take. Last but not least, you can use predictive (rather than reactive)
    observability. For example, you can be alerted on a condition in the future, extrapolating
    the current behavior (disk usage for a predictable load is a good example where
    that might work well).
  prefs: []
  type: TYPE_NORMAL
- en: Likely the best visual overview on observability comes from performance maestro
    Brendan Gregg. [Figure 8-1](#fig-linux-o11y), taken from his [Linux Performance
    site](https://oreil.ly/KlzQP), gives you a feeling for the wealth of moving parts
    and tooling available.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0801](Images/lmlx_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-1\. Linux observability overview. *Credit*: Brendan Gregg (shared
    under CC BY-SA 4.0 license)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Observability is an exciting topic with many use cases and lots of (open source)
    tooling available, so let’s first establish a strategy and look at some common
    terms used.
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the observability terminology, let’s step back a bit and
    look at how you turn the information provided into actionable insights and use
    it to fix an issue or optimize an app in a structured manner.
  prefs: []
  type: TYPE_NORMAL
- en: Observability Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One widely established strategy in the observability context is the [OODA loop
    (observe–orient–decide–act)](https://oreil.ly/zLLET). It offers a structured way
    to test a hypothesis based on observed data and act upon it—that is, a way to
    get actionable insights from signals.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say an application is slow. Let’s further assume there are
    multiple possible reasons for this (not enough memory, too few CPU cycles, network
    I/O insufficient, etc.). First, you want to be able to measure each resource consumption.
    Then you would change each resource allocation individually (keeping the others
    unchanged) and measure the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: Does the performance improve after you provided more RAM to the app? If so,
    you may have found the reason. If not, you continue with a different resource,
    always measuring the consumption and trying to relate to the observed impact on
    the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a range of terms in the observability space,^([1](ch08.xhtml#idm45805428798080))
    and not all have formal definitions. In addition, the meanings might slightly
    differ if you’re looking at a single machine or are in a networked (distributed)
    setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Observability
  prefs: []
  type: TYPE_NORMAL
- en: Assessing the internal state of a system (such as Linux) by measuring external
    information, usually with the goal of acting upon it. For example, if you notice
    that your system reacts sluggishly, and measure how much main memory is available,
    you might find that a particular app hogs all the memory, and you may decide to
    terminate it to remedy the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Signal types
  prefs: []
  type: TYPE_NORMAL
- en: Different ways to represent and emit information about the state of a system,
    either via symbolic means (payload is text, such as the case with logs) or numerical
    values (as with metrics) or combinations thereof. See also [“Signal Types”](#o11y-signals).
  prefs: []
  type: TYPE_NORMAL
- en: Source
  prefs: []
  type: TYPE_NORMAL
- en: Generates signals, potentially of different types. Sources can be the Linux
    operating system or an application.
  prefs: []
  type: TYPE_NORMAL
- en: Destination
  prefs: []
  type: TYPE_NORMAL
- en: Where you consume, store, and further process signals. We call a destination
    that exposes a user interface (GUI, TUI, or CLI) a *frontend*. For example, a
    log viewer or a dashboard plotting time series is a frontend, whereas an S3 bucket
    is not (but can still act as a destination for, say, logs).
  prefs: []
  type: TYPE_NORMAL
- en: Telemetry
  prefs: []
  type: TYPE_NORMAL
- en: The process of extracting signals from sources and transporting (or routing,
    shipping) the signals to destinations, often employing agents that collect and/or
    preprocess signals (for example, filter or downsample).
  prefs: []
  type: TYPE_NORMAL
- en: Signal Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Signals* are how we communicate the state of a system for further processing
    or interpretation. By and large we distinguish between text payload (which is
    most suited for a human to search and interpret) and numerical payload (good for
    both machines and, in processed form, for humans). The three basic and common
    signal types relevant to our discussion in this chapter are: logs, metrics, and
    traces.'
  prefs: []
  type: TYPE_NORMAL
- en: Logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Logs* are a fundamental signal type that every system, to some extent, generates.
    Logs are discrete events with a textual payload, meant for human consumption.
    Typically, these events are timestamped. Ideally, the logs are structured so that
    there is a clear meaning defined for each part of the log message. This meaning
    is potentially expressed through a formal schema so that validation can be automatically
    performed.'
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, while every log has some structure (even if it’s not well defined
    and parsing is hard, potentially due to delimiter or edge cases), you will often
    hear the term *structured logging*. When people say that, they actually mean that
    the log is structured using JSON.
  prefs: []
  type: TYPE_NORMAL
- en: While automating log content is hard (given its textual nature), logs are still
    very useful for humans, and thus they will likely stay the dominating signal type
    for some time. We’ll dig deeper into handling logs in [“Logging”](#logging). Logs
    are the most important signal type (for our considerations), and that’s why we’ll
    spend most of the time in this chapter dealing with them.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Metrics* are (usually regularly) sampled numerical data points, forming a
    time series. The individual data points can have additional context in the form
    of dimensions or identifying metadata. Normally, you don’t directly consume the
    raw metrics; instead, you use some sort of aggregation or graphical representation,
    or you get notified if a certain condition is met. Metrics can be useful both
    for operational tasks and for troubleshooting to answer questions like how many
    transactions an app completed or how long a certain operation took (in the past
    X minutes).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We distinguish between different types of metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: Counter
  prefs: []
  type: TYPE_NORMAL
- en: The value of a counter can only ever go up (besides resetting a counter to zero).
    An example of a counter metric is the total number of requests handled by a service
    or the bytes sent via an interface over a time period.
  prefs: []
  type: TYPE_NORMAL
- en: Gauges
  prefs: []
  type: TYPE_NORMAL
- en: A gauge value can go up or down. For example, you gauge the currently available
    overall main memory or the number of processes running.
  prefs: []
  type: TYPE_NORMAL
- en: Histograms
  prefs: []
  type: TYPE_NORMAL
- en: A sophisticated way to build a distribution of values. Using buckets, histograms
    allow you to assess how the data overall is structured. They also enable you to
    make flexible statements (such as 50% or 90% of the values fall into a certain
    range).
  prefs: []
  type: TYPE_NORMAL
- en: In [“Monitoring”](#monitoring), we have a look at a range of tools that you
    can use for simple use cases, and in [“Prometheus and Grafana”](#prometheus-grafana),
    you see an advanced example setup for metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Traces
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Traces* are a dynamic collection of runtime information (for example, information
    about what syscalls a process uses, or the sequence of events in the kernel, for
    a given cause). Traces are often used not only for debugging but also for performance
    assessments. We have a look at this advanced topic in [“Tracing and Profiling”](#tracing).'
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned before, logs are (a collection of) discrete events with a textual
    payload, optimized for human consumption. Let’s decompose this statement to understand
    it better:'
  prefs: []
  type: TYPE_NORMAL
- en: Discrete events
  prefs: []
  type: TYPE_NORMAL
- en: Think of a discrete event in the context of the codebase. You want to share
    information about what is going on in the code using an (atomic) log item. For
    example, you emit a log line that a database connection has been established successfully.
    Another log item might be to flag an error because a file is missing. Keep the
    scope of the log message small and specific, so it’s easier for someone consuming
    the message to find the respective location in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Textual payload
  prefs: []
  type: TYPE_NORMAL
- en: The payload of a log message is of textual nature. The default consumers are
    humans. In other words, no matter if you’re using a log viewer on the command
    line, or a fancy log-processing system with visual UI, a human reads and interprets
    the content of the log message and decides on an action based on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a structural perspective, overall, a log comprises the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of log items, messages, or lines
  prefs: []
  type: TYPE_NORMAL
- en: Captures information about a discrete event.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata or context
  prefs: []
  type: TYPE_NORMAL
- en: Can be present on a per-message basis as well as on a global scope (the entire
    log file, for example).
  prefs: []
  type: TYPE_NORMAL
- en: A format for how an individual log message is to be interpreted
  prefs: []
  type: TYPE_NORMAL
- en: Defines the log’s parts and meanings. Examples are line-oriented, space-separated
    messages or a JSON schema.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 8-1](#tab-log-formats), you can see some common log formats. There
    are many (more-specific, narrower-scoped) formats and frameworks—for example,
    for database or programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Common log formats
  prefs: []
  type: TYPE_NORMAL
- en: '| Format | Note |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Common event format](https://oreil.ly/rHBWs) | Developed by ArcSight; used
    for devices, security use cases |'
  prefs: []
  type: TYPE_TB
- en: '| [Common log format](https://oreil.ly/Da7uC) | For web servers; see also extended
    log format |'
  prefs: []
  type: TYPE_TB
- en: '| [Graylog extended log format](https://oreil.ly/6MBHm) | Developed by Graylog;
    improves Syslog |'
  prefs: []
  type: TYPE_TB
- en: '| Syslog | For operating systems, apps, devices; see [“Syslog”](#syslog) |'
  prefs: []
  type: TYPE_TB
- en: '| [Embedded metric format](https://oreil.ly/LeXhe) | Developed by Amazon (both
    logs and metrics) |'
  prefs: []
  type: TYPE_TB
- en: As a good practice, you want to avoid overhead with logs (enabling fast lookups
    and a small footprint—that is, not taking up too much disk space). In this context,
    log rotation, for example, via [`logrotate`](https://oreil.ly/jX6Jy), is used.
    An advanced concept called *data temperature* may also be useful, moving older
    log files to cheaper and slower storage (attached disk, S3 bucket, Glacier).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s one case where you need to be careful about logging information, especially
    in production environments. Whenever you decide to emit a log line in your app,
    ask yourself if you could potentially leak sensitive information. This sensitive
    information could be a password, an API key, or even simply user-identifying information
    (email, account ID).
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the logs are usually stored in a persistent form (say, on
    local disk or even in an S3 bucket). This means that even long after the process
    has terminated, someone could get access to the sensitive information and use
    it for an attack.
  prefs: []
  type: TYPE_NORMAL
- en: To signal the importance or intended target consumer of a log item, logs often
    define levels (for example `DEBUG` for development, `INFO` for normal status,
    or `ERROR` for unexpected situations that may require human intervention).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it’s time to get our hands dirty: let’s start with something simple and,
    as an overview, have a look at Linux’s central log directory (output shortened
    for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Logs of the `apt` package manager
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Logs of all login attempts (successful and failed) and authentication processes
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Failed login attempts
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Printing related logs
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_observability_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Logs of the `dpkg` package manager
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_observability_CO1-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Device driver logs; use `dmesg` to inspect
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_observability_CO1-7)'
  prefs: []
  type: TYPE_NORMAL
- en: System install logs (when the Linux distro was originally installed)
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_observability_CO1-8)'
  prefs: []
  type: TYPE_NORMAL
- en: The `journalctl` location; see [“journalctl”](#journalctl) for details
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](#co_observability_CO1-9)'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel logs
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](Images/10.png)](#co_observability_CO1-10)'
  prefs: []
  type: TYPE_NORMAL
- en: All last logins of all users; use `lastlog` to inspect
  prefs: []
  type: TYPE_NORMAL
- en: '[![11](Images/11.png)](#co_observability_CO1-11)'
  prefs: []
  type: TYPE_NORMAL
- en: NTP-related logs (see also [“Network Time Protocol”](ch07.xhtml#ntp))
  prefs: []
  type: TYPE_NORMAL
- en: '[![12](Images/12.png)](#co_observability_CO1-12)'
  prefs: []
  type: TYPE_NORMAL
- en: The `syslogd` location; see [“Syslog”](#syslog) for details
  prefs: []
  type: TYPE_NORMAL
- en: 'One common pattern for consuming logs live (that is, as it happens) is to *follow
    logs*; that is, you watch the end of the log as new log lines are added (edited
    to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the logs of the `syslogd` process with the `-f` option.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: An example log line; see [“Syslog”](#syslog) for the format.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to see the log output of a process and at the same time store it
    in a file, you can use the [`tee` command](https://oreil.ly/X1Gqo):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now you’d see the output of `someprocess` in your terminal, and the output would
    at the same time be stored in *some.log*. Note that we’re using the `-a` option
    to append to the log file, otherwise it would be truncated.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now have a look at the two most commonly used Linux logging systems.
  prefs: []
  type: TYPE_NORMAL
- en: Syslog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syslog is a logging standard for a range of sources, from the kernel to daemons
    to user space. It has its roots in networked environments, and today the protocol
    comprises a textual format defined in [RFC 5424](https://oreil.ly/1Qqng), along
    with deployment scenarios and security considerations. [Figure 8-2](#fig-syslog-format)
    shows the high-level format of Syslog, but be aware that there are many seldom-used
    optional fields.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0802](Images/lmlx_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Syslog format as per RFC 5424
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The Syslog format as defined in RFC 5424 has the following header fields (with
    `TS` and `HN` the most often used):'
  prefs: []
  type: TYPE_NORMAL
- en: '`PRI`'
  prefs: []
  type: TYPE_NORMAL
- en: The message facility/severity
  prefs: []
  type: TYPE_NORMAL
- en: '`VER`'
  prefs: []
  type: TYPE_NORMAL
- en: The Syslog protocol number (usually left out since it can only be 1)
  prefs: []
  type: TYPE_NORMAL
- en: '`TS`'
  prefs: []
  type: TYPE_NORMAL
- en: Contains the time when the message was generated using ISO 8601 format
  prefs: []
  type: TYPE_NORMAL
- en: '`HN`'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the machine that sent the message
  prefs: []
  type: TYPE_NORMAL
- en: '`APP`'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the application (or a device) that sent the message
  prefs: []
  type: TYPE_NORMAL
- en: '`PID`'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the process that sent the message
  prefs: []
  type: TYPE_NORMAL
- en: '`MID`'
  prefs: []
  type: TYPE_NORMAL
- en: An optional message ID
  prefs: []
  type: TYPE_NORMAL
- en: The format also includes *structured data*, which is the payload in a structured
    (key/value-based) list where each element is bounded by `[ ]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, one would use the [`syslogd` binary](https://oreil.ly/su6IX) to take
    care of the log management. Over time, other options have become available that
    you should be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`syslog-ng`](https://oreil.ly/qETe9)'
  prefs: []
  type: TYPE_NORMAL
- en: An enhanced log daemon that you can use as a drop-in replacement for `syslogd`
    and that in addition supports TLS, content-based filtering, and logging into databases
    such as PostgreSQL and MongoDB. Available since late 1990.
  prefs: []
  type: TYPE_NORMAL
- en: '[`rsyslog`](https://oreil.ly/QDPmv)'
  prefs: []
  type: TYPE_NORMAL
- en: Extends the Syslog protocol and can also be used with `systemd`. Available since
    2004.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite its age, the Syslog family of protocols and tools is still around and
    widely available. With `systemd` becoming the de facto standard of init systems,
    used in every major Linux distro, there is, however, a new way to go about logging:
    meet the `systemd` journal.'
  prefs: []
  type: TYPE_NORMAL
- en: journalctl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [“systemd”](ch06.xhtml#systemd), we briefly touched upon a component that
    is part of the `systemd` ecosystem, responsible for log management: [`journalctl`](https://oreil.ly/M4sbo).
    In contrast to Syslog and the other systems we’ve used so far, `journalctl` uses
    a binary format to store the log items. This allows faster access and better storage
    footprints.'
  prefs: []
  type: TYPE_NORMAL
- en: The binary storage format did attract some criticism when it was introduced
    since people are not able to continue to use the familiar `tail`, `cat`, and `grep`
    commands to view and search logs. Having said that, while one has to learn a new
    way to interact with logs when using `journalctl`, the learning curve is not too
    bad.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at some common tasks. If you launch `journalctl` without parameters,
    it will present itself as an interactive pager (you can use the arrow keys or
    space bar to scroll through it and exit with `q`) for all the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To restrict the time range, you can, for example, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Restrict the time range to what happened in the past three hours.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Another way to restrict the time range, with explicit start and stop times.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can limit the output to specific `systemd` units like so (assuming there
    is a service called `abc.service`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `journalctl` tool has a powerful way to format the output of the log items.
    Using the `--output` (or `-o` for short) parameter, you can optimize the output
    for a certain use case. Important values are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cat`'
  prefs: []
  type: TYPE_NORMAL
- en: Short form, without time stamp or source
  prefs: []
  type: TYPE_NORMAL
- en: '`short`'
  prefs: []
  type: TYPE_NORMAL
- en: The default, emulating Syslog output
  prefs: []
  type: TYPE_NORMAL
- en: '`json`'
  prefs: []
  type: TYPE_NORMAL
- en: One JSON-formatted entry per line (for automation)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have the same experience to follow the logs as you’d have with `tail
    -f` using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s put all the preceding information together into a concrete example. Assume
    you want to relaunch a security component of the Linux distro, managed by `systemd`:
    [AppArmor](https://www.apparmor.net). That is, in one terminal we restart the
    service using `systemctl restart apparmor`, and in another we execute the following
    command (output edited; the actual output is one log item per line):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Follow the logs of the AppArmor service.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: After `systemd` has stopped the service, here it comes back up again.
  prefs: []
  type: TYPE_NORMAL
- en: With that we are at the end of the logging section and move on to numerical
    values with metrics and the wider topic of monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Monitoring* is the capturing of system and application metrics for a variety
    of reasons. For example, you may be interested in how long something takes or
    how many resources a process consumes (performance monitoring), or you may be
    troubleshooting an unhealthy system. The two types of activities you’ll carry
    out most often in the context of monitoring are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking one or more metrics (over time)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alerting on a condition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we first focus on some foundations and tools you should be
    aware of, and as we move further into the section, we get into more advanced techniques
    that may be relevant only in certain situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a simple example that displays some basic metrics, such as how
    long a system is running, memory usage, and more, using the [`uptime` command](https://oreil.ly/smiz6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `uptime` command to display some basic system metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Separated by commas, the output tells us how long the system is running, the
    number of users logged in, and then (in the `load average` section) three gauges:
    the 1-minute, 5-minute, and 15-minute average. These averages are the number of
    jobs in the run queue or waiting for disk I/O; the numbers are normalized and
    indicate how busy the CPUs are. For example, here the load average for the past
    5 minutes was 0.2 (which in isolation doesn’t tell you much, so you have to compare
    it with the other values and track it over time).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s monitor some basic memory utilization, using the `free` command
    (output compressed to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Show memory usage using a human-friendly output.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The memory stats: total/used/free/shared memory, memory used in buffers and
    used for caching (use `-w` if you don’t want the combined value), and the available
    memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The total/used/free amount of swap space—that is, physical memory moved out
    to a swap disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more sophisticated way to look at memory usage is using the [`vmstat` (short
    for virtual memory stats) command](https://oreil.ly/x8wrI). The following example
    uses `vmstat` in a self-updating manner (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Show memory stats. The argument `1` means to print a new summary line every
    second.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some important column headers: `r` is for the number of processes running or
    waiting for CPU (should be less than or equal to the number of CPUs you have),
    `free` is the free main memory in KB, `in` is the number of interrupts per second,
    `cs` is the number of context switches per second, and `us` to `st` are percentages
    of total CPU time across user space, kernel, idle, and the like.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how long a certain operation takes, you can use the `time` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Measure how long recursively listing all */etc* subdirectories takes (we throw
    away all output, including errors, with `2&> /dev/null`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The total (wall clock) time it took (not really useful other than for performance).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: How long `ls` itself spent on-CPU (user space).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: How long `ls` was waiting for Linux to do something (kernel space).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, if you’re interested in how long an operation took,
    taking the sum of `user` and `sys` is a good approximation, and the ratio of the
    two gives you a good idea where it spends most of the execution time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we focus on some more specific topics: network interfaces and block devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Device I/O and Network Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With [`iostat`](https://oreil.ly/L4Pbu) you can monitor I/O devices (output
    edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use `iostat` to show I/O device metrics. With `-z`, we tell it to show only
    devices where there was some activity, and the `--human` makes the output nicer
    (units are in human-readable form).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Example row: `tps` is the number of transfers (I/O requests) per second for
    that device, `read` is data volume, and `wrtn` is written data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up: network interfaces with the [`ss` command](https://oreil.ly/BAIiv)
    that can dump socket statistics (see also [“Sockets”](ch07.xhtml#sockets)). The
    following command lists both TCP and UDP sockets along with process IDs (output
    edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `ss` with the following options: with `-a`, we select all (that is, both
    listening and nonlistening sockets); the `-t` and `-u` select TCP and UDP, respectively;
    and `-p` shows the processes using the sockets.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'An example socket in use. It’s an established TCP connection between local
    IPv4 address `192.168.178.40` and remote `74.125.193.188` that seems idle: both
    data queued for receive (`Recv-Q`) and transmit (`Send-Q`) report zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An outdated way to gather and display interface stats is using [`netstat`](https://oreil.ly/UBqge).
    For example, if you want to have a continuously updated view on TCP and UDP, including
    process ID and using IP addresses rather than FQDNs, you could use `netstat -ctulpn`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`lsof`](https://oreil.ly/qDT67) stands for “list open files” and is a versatile
    tool with many use cases. The following example shows `lsof` used in the context
    of network connections (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List privileged TCP ports (needs `root` privileges).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another usage example for `lsof` is a process-centric view: if you know the
    PID of a process (here, Chrome), you can use `lsof` to track file descriptors,
    I/O, etc. (output edited to fit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are many more tools for (performance) monitoring available—for example,
    [`sar`](https://oreil.ly/dYWwR) (covering a range of counters, nice for scripts)
    and [`perf`](https://oreil.ly/TJ4gP)—some of which we will discuss in [“Advanced
    Observability”](#advanced-o11y).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a handle on individual tools, let’s move on to integrated
    tools that allow you to interactively monitor Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Integrated Performance Monitors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the tooling we discussed in the previous section, such as `lsof` or `vmstat`,
    is a good starting point and also useful in scripts. For more convenient monitoring,
    you may prefer integrated solutions. These typically come with a textual user
    interface (TUI), sometimes in color, and offer the following features:'
  prefs: []
  type: TYPE_NORMAL
- en: Support for multiple resource types (CPU, RAM, I/O)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive sorting and filtering (by process, user, resource)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live updates and drill-down into details such as a process group or even cgroups
    and namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, the widely available [`top`](https://oreil.ly/NqKO2) provides
    an overview in the header—akin to what we saw in the `uptime` output—and then
    a tabular rendering of CPU and memory details, followed by a list of processes
    you can track (output edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of system (compare with `uptime` output)
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Task statistics
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_observability_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: CPU usage statistics (user, kernel, etc.; similar to `vmstat` output)
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_observability_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic process list, including details on a per-process level; comparable
    to `ps aux` output
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following are the most important keys to remember in `top`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`?`'
  prefs: []
  type: TYPE_NORMAL
- en: To list the help (including key mappings)
  prefs: []
  type: TYPE_NORMAL
- en: '`V`'
  prefs: []
  type: TYPE_NORMAL
- en: To toggle to and from process tree view
  prefs: []
  type: TYPE_NORMAL
- en: '`m`'
  prefs: []
  type: TYPE_NORMAL
- en: To sort by memory usage
  prefs: []
  type: TYPE_NORMAL
- en: '`P`'
  prefs: []
  type: TYPE_NORMAL
- en: To sort by CPU consumption
  prefs: []
  type: TYPE_NORMAL
- en: '`k`'
  prefs: []
  type: TYPE_NORMAL
- en: To send a signal (like to `kill`)
  prefs: []
  type: TYPE_NORMAL
- en: '`q`'
  prefs: []
  type: TYPE_NORMAL
- en: To quit
  prefs: []
  type: TYPE_NORMAL
- en: 'While `top` is available in virtually any environment, there are a number of
    alternatives available, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`htop`](https://oreil.ly/P9elE) ([Figure 8-3](#fig-htop))'
  prefs: []
  type: TYPE_NORMAL
- en: An incremental `top` improvement that is faster than `top` and has a nicer user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[`atop`](https://oreil.ly/luRoU) ([Figure 8-4](#fig-atop))'
  prefs: []
  type: TYPE_NORMAL
- en: A powerful alternative to `top`. In addition to CPU and memory, it covers resources
    such as I/O and network stats in great detail.
  prefs: []
  type: TYPE_NORMAL
- en: '[`below`](https://oreil.ly/XdOHB)'
  prefs: []
  type: TYPE_NORMAL
- en: A relatively new tool that is notable especially because it is cgroups v2–aware
    (see [“Linux cgroups”](ch06.xhtml#cgroups)). Other tools do not understand cgroups
    and hence provide only a global resource view.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0803](Images/lmlx_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. A screenshot of the `htop` tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![lmlx 0804](Images/lmlx_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. A screenshot of the `atop` tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are a number of other integrated monitoring tools available that go beyond
    the basic sources or that specialize in certain use cases. These include but are
    not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[glances](https://oreil.ly/zOC9e)'
  prefs: []
  type: TYPE_NORMAL
- en: A powerful hybrid that covers devices in addition to the usual resources
  prefs: []
  type: TYPE_NORMAL
- en: '[guider](https://oreil.ly/uqBH1)'
  prefs: []
  type: TYPE_NORMAL
- en: An integrated performance analyzer that allows you to display and graph a range
    of metrics
  prefs: []
  type: TYPE_NORMAL
- en: '[neoss](https://oreil.ly/O4BHS)'
  prefs: []
  type: TYPE_NORMAL
- en: For network traffic monitoring; an `ss` replacement that offers a nice TUI
  prefs: []
  type: TYPE_NORMAL
- en: '[mtr](https://oreil.ly/uL38A)'
  prefs: []
  type: TYPE_NORMAL
- en: For network traffic monitoring; a more powerful alternative to `traceroute`
    (see [“Routing”](ch07.xhtml#routing) for details on `traceroute`)
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a broad understanding of the tooling to consume system metrics,
    let’s see how you can expose those from your own code.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve focused on signals coming from the kernel or existing applications
    (that is, code that you don’t own). Now we move to the topic of how you can, similar
    to logs, equip your code to emit metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of inserting code to emit signals, especially metrics, is mainly
    relevant if you’re developing software. This process is usually referred to as
    *instrumentation*, and there are two common instrumentation strategies: *autoinstrumentation*
    (no additional effort for you as a developer) and *custom instrumentation*, where
    you manually insert code snippets to, for example, emit a metric at a certain
    point in your code base.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use [StatsD](https://oreil.ly/XOYFE), with client-side libraries available
    for a number of programming languages, such as [Ruby](https://oreil.ly/VfE4D),
    [Node.js](https://oreil.ly/G9Jt3), [Python](https://oreil.ly/hQBMf), and [Go](https://oreil.ly/whpZV).
    StatsD is nice, but it has a few limitations, especially in dynamic environments
    such as Kubernetes or IoT. In those environments, a different approach—sometimes
    called *pull-based* or *scraping*—is usually a better choice. With scraping, applications
    expose metrics (usually via an HTTP endpoint), and an agent then calls this endpoint
    to retrieve metrics, rather than configuring the app with where to send the metrics
    to. We’ll return to this topic in [“Prometheus and Grafana”](#prometheus-grafana).
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Observability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know the basics of Linux observability, let’s have a look at some
    more advanced topics in this space.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing and Profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The term *tracing* is overloaded: in the context of Linux, on a single machine,
    tracing means capturing the process execution (function calls in user space, syscalls,
    etc.) over time.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In a distributed setup like containerized microservices in Kubernetes or a bunch
    of Lambda functions that are part of a serverless app, we sometimes shorten [*distributed
    tracing*](https://oreil.ly/tTjY9) (for example, with OpenTelemetry and Jaeger)
    to *tracing*. This type of tracing is out of scope for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of data sources in the context of a single Linux machine.
    You can use the following as sources for tracing:'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux kernel
  prefs: []
  type: TYPE_NORMAL
- en: Traces can come from functions in the kernel or be triggered by syscalls. Examples
    include [kernel probes](https://oreil.ly/lAolL) (kprobes) or [kernel tracepoints](https://oreil.ly/wZcXE).
  prefs: []
  type: TYPE_NORMAL
- en: User space
  prefs: []
  type: TYPE_NORMAL
- en: Application function calls, for example via [user space probes (uprobes)](https://oreil.ly/I8ICY),
    can act as a source for traces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use cases for tracing include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a program using, for example, the [`strace`](https://strace.io) tracing
    tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance analysis with a frontend, using [`perf`](https://oreil.ly/izMpR)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may be tempted to use `strace` everywhere; however, you should be aware
    of the overhead it causes. This is particularly relevant for production environments.
    Read [“strace Wow Much Syscall”](https://oreil.ly/eSLOT) by Brendan Gregg to understand
    the background.
  prefs: []
  type: TYPE_NORMAL
- en: See [Figure 8-5](#fig-perf) for an example output of `sudo perf top`, which
    generates a summary by process.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0805](Images/lmlx_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. A screenshot of the `perf` tracing tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Going forward, it seems that eBPF (see [“A Modern Way to Extend the Kernel:
    eBPF”](ch02.xhtml#ebpf)) will become the de facto standard to implement tracing,
    especially for custom cases. It has a rich ecosystem and growing vendor support,
    so if you’re looking for a future-proof tracing method, make sure it’s using eBPF.'
  prefs: []
  type: TYPE_NORMAL
- en: One particular use case for tracing is *profiling*—that is, to identify frequently
    called code sections. Some relevant low-level tooling for profiling include [`pprof`](https://oreil.ly/tETfk),
    [Valgrind](https://oreil.ly/p9HQJ), and [flame graph visualizations](https://oreil.ly/bCgbJ).
  prefs: []
  type: TYPE_NORMAL
- en: There are many options to consume `perf` output interactively and visualize
    traces; for example, see Mark Hansen’s blog post [“Linux perf Profiler UIs”](https://oreil.ly/dGH1S).
  prefs: []
  type: TYPE_NORMAL
- en: '*Continuous profiling* is an advanced variant of profiling, which captures
    traces (kernel and user space) over time. Once these timestamped traces are collected,
    you can plot and compare them and drill down into interesting segments. One very
    promising example is the eBPF-based open source project [parca](https://www.parca.dev),
    shown in [Figure 8-6](#fig-parca).'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0806](Images/lmlx_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. A screenshot of parca, a continuous profiling tool
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Prometheus and Grafana
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re dealing with metrics over time (time series data), using the [Prometheus](https://prometheus.io)
    and [Grafana](https://grafana.com) combo is something you may want to consider
    for advanced observability.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll show you a simple, single-machine setup that you can use to dashboard and
    even alert on things going on in your Linux machine.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the [node exporter](https://oreil.ly/0L4KJ) to expose a range of system
    metrics, from CPU to memory and network. We’ll then use Prometheus to scrape the
    node exporter. Scraping means that Prometheus calls an HTTP endpoint that the
    node exporter offers via the URL path */metrics*, returning the metrics in [OpenMetrics
    format](https://openmetrics.io). For that to happen, we need to configure Prometheus
    with the URL of the node exporter’s HTTP endpoint. The final step in our setup
    is using Prometheus as a datasource in Grafana, where you can see the time series
    data (metrics over time) in dashboards and can even alert on certain conditions,
    such as low disk space or CPUs overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as a first step, download and untar the node exporter, and have it run
    the binary with `./node_exporter &` in the background. You can check if it’s running
    properly with the following (output edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the signal data source set up, we run both Prometheus and Grafana
    as containers. For the following, you’ll need Docker (see [“Docker”](ch06.xhtml#docker))
    installed and configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Prometheus configuration file called *prometheus.yml* with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_observability_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus itself exposes metrics, so we include this (self-monitoring).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_observability_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: That’s our node exporter. Since we’re running Prometheus in Docker, we can’t
    use `localhost` but rather use the IP address Docker uses by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the Prometheus configuration file we created in the previous step and
    mount it into the container via a volume, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#custom_co_observability_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters here make Docker remove the container on exit (`--rm`), run as
    a daemon (`-d`), and expose the port 9090 (`-p`) so we can use it from our machine.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#custom_co_observability_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Mapping our config file as a volume into the container. Note that here you will
    have to replace */home/mh9/lml/o11y/* with the path where you stored it. Also,
    this has to be an absolute path. So, if you want to keep this flexible, you could
    use `$PWD` in bash or `(pwd)` in Fish rather than the hardcoded path.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve executed the previous command, open *localhost:9000* in your browser,
    then click Targets in the Status dropdown menu at the top. You should, after a
    few seconds, see something like the screen shown in [Figure 8-7](#fig-prometheus),
    confirming that Prometheus has successfully scraped metrics from itself and the
    node exporter.
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0807](Images/lmlx_0807.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7\. A screenshot of Prometheus targets in the Web UI
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we launch Grafana:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve executed the preceding command, open *localhost:3000* in your
    browser and use `admin` for both the username and password. Next, we need to do
    two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Add [Prometheus as a datasource](https://oreil.ly/9Efhy) in Grafana, using `172.17.0.1:9100`
    as the URL
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the [Node Exporter Full dashboard](https://oreil.ly/RpCDe)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve done this, you should see something akin to [Figure 8-8](#fig-grafana).
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0808](Images/lmlx_0808.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8\. A screenshot of the Grafana UI with the Node Exporter Full dashboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: That was some exciting advanced observability for Linux, using modern tooling.
    Given that the Prometheus/Grafana setup is more elaborate and has a number of
    moving parts, you’ll likely not use it for a trivial task. In other words, the
    Linux native tooling we discussed in this section should go a long way; however,
    there are more advanced use cases—for example, home automation or a media server—where
    you want to have a more complete solution, in which case Prometheus/Grafana makes
    a lot of sense.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at making sure you’re not flying blind when you’re
    running into issues with your Linux system. The main signal types you’d typically
    use for diagnostics are logs (textual) and metrics (numerical). For advanced cases,
    you can apply profiling techniques, rendering resource usage of processes along
    with the execution context (source file and lines of the source code that is being
    executed).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more and dive deeper into this topic, have a look at these
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs: []
  type: TYPE_NORMAL
- en: '[*Systems Performance: Enterprise and the Cloud*, second edition](https://oreil.ly/sxtPd),
    by Brendan Gregg (Addison-Wesley)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Linux Performance Analysis in 60,000 Milliseconds”](https://oreil.ly/YVxJt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs: []
  type: TYPE_NORMAL
- en: '[“Linux Logging Complete Guide”](https://oreil.ly/fMNT7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Unix/Linux—System Logging”](https://oreil.ly/hnMGz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“syslog-ng” on ArchWiki](https://oreil.ly/wzRqG)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[fluentd website](https://oreil.ly/hJ3nr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring
  prefs: []
  type: TYPE_NORMAL
- en: '[“80+ Linux Monitoring Tools for SysAdmins”](https://oreil.ly/C4ZJX)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Monitoring StatsD: Metric Types, Format and Code Examples”](https://oreil.ly/JaUEK)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced
  prefs: []
  type: TYPE_NORMAL
- en: '[“Linux Performance”](https://oreil.ly/EIPYd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Linux Tracing Systems & How They Fit Together”](https://oreil.ly/SuGPM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Profilerpedia: A Map of the Software Profiling Ecosystem”](https://oreil.ly/Sk0zL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“On the State of Continuous Profiling”](https://oreil.ly/wHLqr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[eBPF website](https://oreil.ly/DFYMN)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Monitoring Linux Host Metrics with the Node Exporter”](https://oreil.ly/5fA6z)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having completed this chapter and those that preceded it, you now know the basics
    of Linux, from kernel to shell to filesystems and networking. The last chapter
    of this book is a collection of advanced topics that didn’t quite fit in other
    chapters. You may find them interesting and useful, depending on your goals, but
    for most day-to-day tasks, you now know everything you need to get by.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.xhtml#idm45805428798080-marker)) *Observability* is also sometimes
    referred to with the numeronym *o11y*, as there are 11 letters between the *o*
    and the *y*.
  prefs: []
  type: TYPE_NORMAL
