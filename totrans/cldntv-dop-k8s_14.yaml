- en: Chapter 12\. Deploying Kubernetes Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I lay on my back, surprised at how calm and focused I felt, strapped to four
    and a half million pounds of explosives.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Ron Garan, astronaut
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll deal with the question of how to turn your manifest
    files into running applications. We’ll learn how to build Helm charts for your
    applications, and look at some alternative tools for manifest management: Tanka,
    kustomize, Kapitan, and kompose.'
  prefs: []
  type: TYPE_NORMAL
- en: Building Manifests with Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in [Chapter 2](ch02.html#firststeps) how to deploy and manage applications
    with Kubernetes resources created from YAML manifests. There’s nothing stopping
    you from managing all your Kubernetes applications using just the raw YAML files
    in this way, but it’s not ideal. Not only is it difficult to maintain these files,
    but there is also a problem of distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you want to make your application available to other people to run in
    their own clusters. You can distribute the manifest files to them, but they will
    inevitably need to customize some of the settings for their own environment.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, they will have to make their own copy of the Kubernetes configs,
    find where the various settings are defined (perhaps duplicated in several places),
    and edit them.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, they will need to maintain their own copies of the files, and when
    you make updates available, they will have to pull and reconcile them manually
    with their local changes.
  prefs: []
  type: TYPE_NORMAL
- en: This eventually starts to become painful. What we want is the ability to separate
    the raw manifest files from the particular settings and variables that you or
    any user of the application might need to adjust. Ideally we could then make these
    available in a standard format, which anyone can download and install to a Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have this, then each application can expose not only configuration values,
    but also any dependencies it has on other apps or services. An intelligent package
    management tool could then install and run an application, along with all its
    dependencies, in a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [“Helm: A Kubernetes Package Manager”](ch04.html#helm-intro), we introduced
    the Helm tool and showed you how to use it to install public charts. Let’s look
    at Helm charts in a little more detail now, and see how to create our own.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s Inside a Helm Chart?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the demo repo, open up the *hello-helm3/k8s* directory to see what’s inside
    our Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every Helm chart has a standard structure. First, the chart is contained in
    a directory with the same name as the chart (`demo` in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Chart.yaml file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, it contains a file named *Chart.yaml*, which specifies the chart name
    and version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are lots of optional fields you can supply in *Chart.yaml*, including
    a link to the project source code, as here, but the only required information
    is the name and version.
  prefs: []
  type: TYPE_NORMAL
- en: The values.yaml file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is also a file named *values.yaml*, which contains user-modifiable settings
    that the chart author has exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks a bit like a Kubernetes YAML manifest, but there’s an important
    difference. The *values.yaml* file is completely free-form YAML, with no predefined
    schema: it’s up to you to choose what variables are defined, their names, and
    their values.'
  prefs: []
  type: TYPE_NORMAL
- en: There don’t have to be any variables at all in your Helm chart, but if there
    are, you can put them in *values.yaml* and then refer to them elsewhere in the
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the *production-values.yaml* and *staging-values.yaml* files for the
    moment; we’ll explain what they’re for shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Helm Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So where are these variables referenced? If you look in the *templates* subdirectory,
    you’ll see a couple of familiar-looking files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These are just the same as the Deployment and Service manifest files from the
    previous example, except that now they are *templates*: instead of referring to
    things like the container name directly, they contain a placeholder that Helm
    will replace with the actual value from *values.yaml*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the template Deployment looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The curly braces indicate a place where Helm should substitute the value of
    a variable, but they’re actually part of *Go template syntax*.
  prefs: []
  type: TYPE_NORMAL
- en: (Yes, Go is everywhere. Kubernetes and Helm themselves are written in Go, so
    it’s no surprise that Helm charts use Go templates.)
  prefs: []
  type: TYPE_NORMAL
- en: Interpolating Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several variables referenced in this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This whole section of text, including the curly braces, will be *interpolated*
    (that is, replaced) with the values of `container.name` and `environment`, taken
    from *values.yaml*. The generated result will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is powerful, because values like `container.name` are referenced more
    than once in the template. Naturally, it’s referenced in the Service template,
    too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see how many times `.Values.container.name` is referenced, for example.
    Even in a simple chart like this, you need to repeat the same bits of information
    many times. Using Helm variables eliminates this duplication. All you need to
    do to change the container name, for example, is to edit *values.yaml* and reinstall
    the chart, and the change will be propagated throughout all the templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go template format is very powerful, and you can use it to do much more
    than simple variable substitutions: it supports loops, expressions, conditionals,
    and even calling functions. Helm charts can use these features to generate fairly
    complex configuration from input values, unlike the simple substitutions in our
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about how to write Helm templates in the Helm [documentation](https://oreil.ly/4u06b).
  prefs: []
  type: TYPE_NORMAL
- en: Quoting Values in Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the `quote` function in Helm to automatically quote values in your
    templates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Only string values should be quoted—don’t use the `quote` function with numeric
    values like port numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if your chart relies on other charts? For example, if your app uses Redis,
    the Helm chart for your app might need to specify the `redis` chart as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this using the `dependencies` section in the `Chart.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now run the `helm dependency update` command, and Helm will download those charts,
    ready to install along with your own application. These dependencies can be local
    charts, or hosted remotely in public Helm repositories.
  prefs: []
  type: TYPE_NORMAL
- en: You can also overwrite any of the default values of any charts that you pull
    in as dependencies (often referred to as subcharts). See the [Helm docs on subchart
    values](https://oreil.ly/rF4rq) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The `~` symbol in the version tells Helm that you would be willing to automatically
    upgrade to a newer version of the chart up to the next minor release version.
    For example, `~15.4.1` means that Helm will install the newest `15.4.x` version,
    stopping before `15.5.x`. Helm, like many other package managers, also uses a
    *.lock* file, so after updating you should see a *Chart.lock* file generated that
    tracks the exact versions used at the time.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Helm Charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look at what’s involved in actually using a Helm chart to deploy an application.
    One of the most valuable features of Helm is the ability to specify, change, update,
    and override configuration settings. In this section, we’ll see how that works.
    This example is in the directory of the [cloudnativedevops GitHub demo repo](https://oreil.ly/xeLdl)
    if you wish to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve seen that the author of a Helm chart can put all the user-modifiable settings
    in `values.yaml`, along with the default values for those settings. So how does
    the *user* of a chart change or override those settings to suit their local site
    or environment? The `helm install` and `helm upgrade` commands let you specify
    additional values files on the command line, which will override any defaults
    in *values.yaml*. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an environment variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Suppose you want to deploy a version of the application in a staging environment.
    For the purposes of our example, it doesn’t really matter what that means in practice,
    but let’s say the application knows whether it’s in staging or production based
    on the value of an environment variable named `ENVIRONMENT`, and changes its behavior
    accordingly. How does that environment variable get created?
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking again at the *deployment.yaml* template, this environment variable
    is supplied to the container using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The value of `environment` comes from *values.yaml*, as you’d expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So installing the chart with the default values will result in the container’s
    `ENVIRONMENT` variable containing `development`. Suppose you want to change that
    to `staging`. You could edit the *values.yaml* file, as we’ve seen, but a better
    way is to create an additional YAML file containing a value for just that one
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You’ll find this value in the file *k8s/demo/staging-values.yaml*, which isn’t
    part of the Helm chart—we’ve just supplied it to save you a little typing.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Values in a Helm Release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To specify an extra values file with the `helm upgrade` command, use the `--values`
    flag, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that in these examples we are using `helm upgrade --install` instead of
    `helm install`. Doing it this way means you can use the same command whether your
    helm release has already been installed or not. If you prefer to use just `helm
    install` first and `helm upgrade` on following deploys, that will also work.
  prefs: []
  type: TYPE_NORMAL
- en: This will create a new release, with a new name (`demo-staging`), and the running
    container’s `ENVIRONMENT` variable will be set to `staging` instead of `development`.
    The variables listed in the extra values file we specified with `--values` are
    combined with those in the default values file (*values.yaml*). In this case,
    there’s only one variable (`environment`) and the value from *staging-values.yaml*
    overrides that from the default values file.
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify values directly on the command line, using the `--set`
    flag. This can be useful for things like changing an image tag version or testing
    a quick change. Typically you should instead create a separate YAML file containing
    whatever value overrides are needed for a particular envrionment, like the *staging-values.yaml*
    file in the example, track that file in your source control repository, and apply
    it using the `--values` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you’ll naturally want to set configuration values this way for installing
    your own Helm charts, you can do it with public charts too. To see the list of
    values a chart makes available for you to set, run `helm get values` with a chart
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Updating an App with Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve learned how to install a Helm chart with the default values, and with
    a custom values file, but what about changing some values for an application that’s
    already running?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helm upgrade` command will do this for you. Suppose you want to change
    the number of replicas (the number of copies of the Pod that Kubernetes should
    run) for the demo application. By default it’s 1, as you can see from the *values.yaml*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You know how to override this using a custom values file, so edit the *staging-values.yaml*
    file to add a suitable setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the same command as before to apply your changes to the *existing* `demo-staging`
    Deployment, rather than creating a new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can run `helm upgrade` as many times as you like to update a running Deployment,
    and Helm will cheerfully oblige.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling Back to Previous Versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you decide you don’t like the version you’ve just deployed, or there turns
    out to be a problem, it’s easy to roll back to a previous version, using the `helm
    rollback` command, and specifying the number of a previous release (as shown in
    `helm history` output):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In fact, the rollback doesn’t have to be to a previous release; let’s say you
    roll back to revision 1, and then decide you want to roll *forward* to revision
    2\. If you run `helm rollback demo-staging 2`, that’s exactly what will happen.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic rollback with helm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can have Helm automatically roll back an unsuccessful deployment. If you
    add the `--atomic` flag to the `helm upgrade` command then Helm will wait for
    your deployment to succeed. If it goes into a `FAILED` state, it will automatically
    roll back to the last successful release. You would want to make sure that you
    have an alert in place for this situation by checking for a failed deploy so that
    you can go debug what happened, otherwise you may not notice that your deploy
    didn’t actually succeed!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Helm Chart Repo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve used Helm to install charts from a local directory. You don’t need
    your own chart repo to use Helm, as it’s common to store an application’s Helm
    chart in the application’s own repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you do want to maintain your own Helm chart repo, it’s very straightforward.
    The charts need to be available over HTTP, and there’s a variety of ways you can
    do this: put them in a cloud storage bucket, host your own [ChartMuseum server](https://chartmuseum.com),
    use Artifactory, use GitHub Pages, or use an existing web server if you have one.'
  prefs: []
  type: TYPE_NORMAL
- en: Once all your charts are collected together under a single directory, run `helm
    repo index` to create the *index.yaml* file that contains the repo metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Your chart repo is ready to use! See the Helm [documentation](https://oreil.ly/glEyY)
    for more details on managing chart repos.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install charts from your repo, you’ll first of all need to add the repo
    to Helm’s list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Managing Helm Chart Secrets with Sops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw in [“Kubernetes Secrets”](ch10.html#secrets) how to store secret data
    in Kubernetes, and how to pass it to applications via environment variables or
    mounted files. If you have more than one or two secrets to manage, you may find
    it easier to create a single file containing all the secrets, rather than individual
    files each containing one secret. And if you’re using Helm to deploy your app,
    you can make that file a values file, and encrypt it with Sops (see [“Encrypting
    Secrets with Sops”](ch10.html#sops)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve built an example for you to try in the demo repo, in the *hello-sops*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is a similar Helm chart layout to our earlier example (see [“What’s Inside
    a Helm Chart?”](#helmcharts)). Here, we’ve defined a `Deployment` and a `Secret`.
    But in this example, we have added a twist to make it easier to manage multiple
    secrets for different environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see the secrets our application will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here we have used Sops to encrypt the values of multiple secrets for our application
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at the Kubernetes *secrets.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: On the last two lines, we’ve added some Go templating into the Helm chart to
    read secrets from either the *production-secrets.yaml* or the *staging-secrets.yaml*
    files, depending on which `environment` is set in the *values.yaml* file.
  prefs: []
  type: TYPE_NORMAL
- en: The end result will be a single Kubernetes `Secret` named *demo-secrets*, containing
    all of the key-value pairs defined in either secret file. This `Secret` will get
    mounted in the Deployment as a single file named *secrets.yaml* for the application
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also added `...| b64enc` to the end of the last line. This is another
    handy shortcut using Helm’s Go templating to automatically convert the secret
    data from plain text to `base64`, which, by default, is what Kubernetes expects
    secrets to be (see [“base64”](ch10.html#base64)).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to first temporarily decrypt the files using Sops, and then apply the
    changes to a Kubernetes cluster. Here is a command pipeline to deploy a staging
    version of the demo application, with its staging secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: Sops decrypts the *staging-secrets* file and writes the decrypted output to
    *temp-staging-secrets*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Helm installs the `demo` chart using values from *staging-values* and *temp-staging-secrets*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *temp-staging-secrets* file is deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because all this happens in one step, we don’t leave a file containing plain-text
    secrets lying around for the wrong people to find. This is very similar to how
    the [`helm-secrets`](https://oreil.ly/BX6uf) plugin works, so if this workflow
    appeals to you for managing secrets, it would be worth looking at this project.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Multiple Charts with Helmfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we introduced Helm in [“Helm: A Kubernetes Package Manager”](ch04.html#helm-intro),
    we showed you how to deploy the demo application Helm chart to a Kubernetes cluster.
    As useful as Helm is, it only operates on one chart at a time. How do you know
    what applications should be running in your cluster, together with the custom
    settings you applied when you installed them with Helm?'
  prefs: []
  type: TYPE_NORMAL
- en: There’s a neat tool called [Helmfile](https://oreil.ly/pptjH) that can help
    you do this. Much as Helm makes it possible for you to deploy a single application
    using templating and variables, Helmfile enables you to deploy everything that
    should be installed on your cluster, with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: What’s in a Helmfile?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s an example of how to use Helmfile in the `demo` repository. In the
    *hello-helmfile* folder, you’ll find *helmfile.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `repositories` section defines the Helm chart repositories we are going
    to reference. In this case, the only repository is `prometheus-community`, the
    official Prometheus helm repository. If you’re using your own Helm chart repo
    (see [“Creating a Helm Chart Repo”](#chartrepo)), add it here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define a set of `releases`: applications we would like to deploy to
    the cluster. Each release specifies some of the following metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` of the Helm chart to deploy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`namespace` to deploy it to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chart` is the URL or path to the chart itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values` gives the path to a *values.yaml* file to use with the Deployment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set` sets any extra values in addition to those in the values file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ve defined three releases here: the demo app, plus Prometheus (see [“Prometheus”](ch16.html#prometheus))
    and `kube-state-metrics` (see [“Kubernetes Metrics”](ch16.html#k8smetrics)).'
  prefs: []
  type: TYPE_NORMAL
- en: Chart Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that we’ve specified a relative path to the `demo` chart and values files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: So your charts don’t need to be in a chart repository for Helmfile to manage
    them; you could keep them all in the same source code repo, for example.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `prometheus` chart, we’ve specified `prometheus-community/prometheus`.
    Since this isn’t a filesystem path, Helmfile knows to look for the chart at the
    URL for the repo, which we defined earlier in the `repositories` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: All charts have various default values set in their respective *values.yaml*
    files. In the `set:` sections of Helmfile, you can specify any values that you
    would like to overwrite when installing the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, for the `prometheus` release, we wanted to ensure that the
    value for `rbac.create` is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Applying the Helmfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *helmfile.yaml*, then, specifies everything that should be running in the
    cluster (or at least, a subset of it) in a declarative way, just like Kubernetes
    manifests. When you apply this declarative manifest, Helmfile will bring the cluster
    into line with your specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: It’s just as though you had run `helm install`/`helm upgrade` in turn for each
    of the Helm charts you’ve defined.
  prefs: []
  type: TYPE_NORMAL
- en: You might like to run `helm sync` automatically as part of your continuous deployment
    pipeline, for example (see [Chapter 14](ch14.html#continuous)). Instead of manually
    running `helm install` to add a new application to the cluster, you could just
    edit your Helmfile, check it into source control, and wait for the automation
    to roll out your changes. In [“GitOps”](ch14.html#gitops), we will also introduce
    another way to manage multiple helm releases using a centralized tool.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use a single source of truth. Don’t mix deploying individual charts manually
    with Helm, and declaratively managing all your charts across the cluster with
    Helmfile or a GitOps tool. If you apply a Helmfile, and then also use Helm to
    deploy or modify applications out of band, you will no longer have a single source
    of truth for your cluster. This is bound to lead to problems, so pick a process
    for how you will manage your deployments and be consistent in how you use it.
  prefs: []
  type: TYPE_NORMAL
- en: If Helmfile isn’t quite to your liking, [Helmsman](https://oreil.ly/DizPj) is
    a similar tool that does more or less the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: As with any new tool, we recommend reading through the docs, comparing the various
    options, trying them out, and then deciding which suits you.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Manifest Management Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Helm is a great tool, and widely used, it does have a few limitations.
    Writing and editing Helm templates isn’t a lot of fun. Kubernetes YAML files are
    complicated, verbose, and repetitive. Therefore, so are Helm templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several new tools are under development that try to address these problems,
    and make it easier to work with Kubernetes manifests: either by describing them
    in a more powerful language than YAML, such as [Jsonnet](https://jsonnet.org),
    or by grouping the YAML files into basic patterns and customizing them with overlay
    files.'
  prefs: []
  type: TYPE_NORMAL
- en: kustomize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[kustomize](https://oreil.ly/nc9B6) is probably the other most popular manifest
    management tool alongside Helm. In fact, as of Kubernetes version 1.14, kustomize
    was included inside the `kubectl` CLI tool. You can also use it separately by
    installing the `kustomize` binary following their [instructions](https://oreil.ly/ePdt1).
    Instead of templating, kustomize uses plain YAML files with overrides to allow
    for substitution and reuse. You start with the *base* YAML manifests, and use
    *overlays* to patch the manifests for different environments or configurations.
    kustomize will generate the final manifests from the base files plus the overlays.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a working example in the *hello-kustomize* directory of the [cloudnativedevops
    GitHub demo repo](https://oreil.ly/LAI8f):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, kustomize reads our *kustomization.yaml* file, sets `commonLabels`
    on both the Deployment and Service for `app` and `org`, and displays the final
    rendered output of the updated manifests. What makes this different from Helm
    is that the original *deployment.yaml* and *service.yaml* files here are perfectly
    valid and usable YAML as-is, yet we still can add some flexibility like adding
    multiple common labels across our manifests using kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `patchesStrategicMerge` kustomize setting allows us to override a field,
    such as changing the replica count per environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Again, you should see the final result of the rendered Deployment and Service
    manifests, but notice how we were able to change the `replicas` field for production
    environment to `3` based on the *replicas.yaml* file in the *overlays/production*
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful modification we applied here is the `namePrefix` setting. Our
    new Deployment is now named `name: prod-demo` instead of the default `name: demo`
    defined in the *base* directory, and our Service is renamed to `prod-demo-service`.
    Kustomize comes with other similar helpers for making tweaks to your manifests
    for different situations, all while keeping the original YAML manifests in a usable,
    valid state.'
  prefs: []
  type: TYPE_NORMAL
- en: To apply your kustomize-customized manifests, you can use `kubectl apply -k`
    (instead of the `kubectl apply -f`), and `kubectl` will use kustomize to read
    the YAML files, render any overlays or modifications, and then apply the final
    result into the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: If templating YAML files does not appeal to you, then kustomize is worth checking
    out. You may encounter community projects that offer you the option to install
    their applications using either their Helm chart or with kustomize, so it is worthwhile
    to become familiar with how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Tanka
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes declarative YAML isn’t enough, especially for large and complex deployments
    where you need to be able to use computation and logic. For example, you might
    want to set the number of replicas dynamically based on the size of the cluster.
    For this, you need a real programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tanka](https://oreil.ly/MBVrB) lets you author Kubernetes manifests using
    a language called Jsonnet, which is an extended version of JSON (which is a declarative
    data format equivalent to YAML, and Kubernetes can understand JSON format manifests
    too). Jsonnet adds important capabilities to JSON—variables, loops, arithmetic,
    conditional statements, error handling, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Kapitan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kapitan](https://oreil.ly/ekar1) is another manifest management tool, focused
    on sharing configuration values across multiple applications or even clusters.
    It can also be used for other types of tooling, such as terraform code, Dockerfiles,
    and Jinja2 template docs. Kapitan has a hierarchical database of config values
    (called the *inventory*) that lets you reuse manifest patterns by plugging in
    different values, depending on the environment or application, and they are generated
    using either the Jsonnet or Python-based Kadet backend engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: kompose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’ve been running production services in Docker containers, but not using
    Kubernetes, you may be familiar with Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compose lets you define and deploy sets of containers that work together: for
    example, a web server, a backend application, and a database such as Redis. A
    single *docker-compose.yml* file could be used to define how these containers
    talk to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '[kompose](https://oreil.ly/vh2AU) is a tool to convert *docker-compose.yml*
    files into Kubernetes manifests, to help you migrate from Docker Compose to Kubernetes,
    without having to write your own Kubernetes manifests or Helm charts from scratch.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may already be familiar with Ansible, a popular infrastructure automation
    tool. It’s not Kubernetes-specific, but it can manage many different kinds of
    resources, using extension modules, much like Puppet (see [“Puppet Kubernetes
    Module”](ch03.html#puppet)).
  prefs: []
  type: TYPE_NORMAL
- en: As well as installing and configuring Kubernetes clusters, Ansible can manage
    Kubernetes resources like Deployments and Services directly, using the [`k8s`
    module](https://oreil.ly/dJTLA).
  prefs: []
  type: TYPE_NORMAL
- en: Like Helm, Ansible can template Kubernetes manifests using its standard templating
    language (Jinja), and it has a more sophisticated notion of variable lookup, using
    a hierarchical system. For example, you can set common values for a group of applications,
    or a deployment environment such as `staging`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re already using Ansible in your organization, it’s definitely worth
    evaluating whether you should use it for managing Kubernetes resources too. If
    your infrastructure is based solely on Kubernetes, then Ansible may be more power
    than you need, but for mixed infrastructures it can be very helpful to use just
    one tool to manage everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: kubeval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike the other tools we’ve discussed in this section, [`kubeval`](https://oreil.ly/87Nh5)
    isn’t for generating or templating Kubernetes manifests, but for validating them.
  prefs: []
  type: TYPE_NORMAL
- en: Each version of Kubernetes has a different schema for its YAML or JSON manifests,
    and it’s important to be able to check automatically that your manifests match
    the schema. For example, `kubeval` will check that you’ve specified all the required
    fields for a particular object, and that the values are of the right type.
  prefs: []
  type: TYPE_NORMAL
- en: '`kubectl` also validates manifests when they’re applied, and will give you
    an error when you try to apply an invalid manifest. But it’s also very useful
    to be able to validate them beforehand. `kubeval` doesn’t need access to a cluster,
    and it can also validate against any version of Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good idea to add `kubeval` to your continuous deployment pipeline so
    that manifests are automatically validated whenever you make changes to them.
    You can also use `kubeval` to test, for example, whether your manifests need any
    adjustments to work on the latest version of Kubernetes before you actually upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can deploy applications to Kubernetes using just raw YAML manifests,
    it’s inconvenient. Helm is a powerful tool that can help with this, provided you
    understand how to get the best out of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lots of different tools that will make Kubernetes manifest management
    much easier in the future. It’s important to be familiar with the basics of using
    Helm because many popular tools are offered to you as Helm charts for installing
    in your clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: A chart is a Helm package specification, including metadata about the package,
    some configuration values for it, and template Kubernetes objects that reference
    those values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing a chart creates a Helm release. Each time you install an instance
    of a chart, a new release is created. When you update a release with different
    config values, Helm increments the release revision number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To customize a Helm chart for your own requirements, create a custom values
    file overriding just the settings you care about, and add it to the `helm install`
    or `helm upgrade` command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use a variable (`environment`, for example) to select different sets
    of values or secrets depending on the deployment environment: staging, production,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With Helmfile, you can declaratively specify a set of Helm charts and values
    to be applied to your cluster, and install or update all of them with a single
    command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm can be used along with Sops for handling secret configuration in your charts.
    It can also use a function to automatically base64-encode your secrets, which
    Kubernetes expects them to be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm is not the only available tool for managing Kubernetes manifests. Kustomize
    is another powerful tool and is even built into `kubectl`. Kustomize takes a different
    approach than Helm and rather than interpolating variables, it just uses YAML
    overlays to tweak manifests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tanka and Kapitan are alternative manifest management tools that use Jsonnet,
    a different templating language.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick way to test and validate manifests is to use `kubeval`, which will check
    for valid syntax and common errors in manifests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
