["```\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n\n// Test the Person class by creating an object\n// The constructor is invoked when you use the new keyword with the class\nconst newPerson = new Person('Luke', 'Takei');\nconsole.log(newPerson.firstName);  // 'Luke'\n```", "```\nclass Person {\n  constructor(firstName, lastName, dateOfBirth) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.dateOfBirth = dateOfBirth;\n  }\n\n  // This is a method\n  swapNames() {\n    // Use a handy shortcut (destructuring assignment) to assign both\n    // properties at once\n    [this.firstName, this.lastName] = [this.lastName, this.firstName];\n  }\n}\n\n// Test the Person class\nconst newPerson = new Person('Luke', 'Takei', new Date(1990, 5, 22));\nnewPerson.swapNames();\nconsole.log(newPerson.firstName);   // 'Takei'\n```", "```\nconst personExpression = class Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n\n// This won't work, because there is no Person class to be found in scope\nconst newPerson = new Person('Luke', 'Takei');\n\n// This works because you can create a new instance of the variable that holds\n// the class expression\nconst newPerson = new personExpression('Luke', 'Takei');\n```", "```\nconst noDatePerson = new Person('Luke', 'Takei');\nconst firstNamePerson = new Person('Luke');\nconst noDataPerson = new Person();\n```", "```\nconst partialInfoPerson1 = new Person({\n  lastName: \"Takei\",\n  birthDate: new Date(1990, 04, 23)\n});\nconst partialInfoPerson2 = new Person({firstName: 'Luke', lastName: 'Takei'});\n```", "```\n// The Person class will look for a firstName property in this object literal\n// It will quietly ignore the firstname property\nconst partialInfoPerson2 = new Person({firstname: 'Luke'});\n```", "```\nclass Person {\n  constructor(firstName, lastName, dateOfBirth) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.dateOfBirth = dateOfBirth;\n  }\n\n  // This is a getter for the age property\n  get age() {\n    if (this.dateOfBirth instanceof Date) {\n      // Calculate the difference in years\n      const today = new Date();\n      let age = today.getFullYear() - this.dateOfBirth.getFullYear();\n\n      // Adjust if the bithday hasn't happened yet this year\n      const monthDiff = today.getMonth() - this.dateOfBirth.getMonth();\n      if (monthDiff < 0 ||\n         (monthDiff === 0 && today.getDate() < this.dateOfBirth.getDate())) {\n        age -= 1;\n      }\n\n      return age;\n    }\n  }\n}\n\n// Test the Person class\nconst newPerson = new Person('Luke', 'Takei', new Date(1990, 5, 22));\nconsole.log(newPerson.age);\n```", "```\nclass Person {\n  constructor(firstName, lastName, date) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n\n    // Set the date using the property setter so a Person\n    // can't be created in an invalid state\n    this.dateOfBirth = date;\n  }\n\n  // Just return the date with no extra processing\n  get dateOfBirth() {\n    return this._dateOfBirth;\n  }\n\n  // Don't allow dates in the future\n  set dateOfBirth(value) {\n    if (value instanceof Date && value < Date.now()) {\n      // This is a valid date\n      this._dateOfBirth = value;\n    }\n    else {\n      throw new TypeError('Birthdate needs to be a valid date in the past');\n    }\n  }\n}\n\n// Test the date restrictions\nconst newPerson = new Person('Luke', 'Takei', new Date(1990, 5, 22));\nconsole.log(newPerson.dateOfBirth);\n\n// This change is allowed\nnewPerson.dateOfBirth = new Date(2010, 10, 10);\nconsole.log(newPerson.dateOfBirth);\n\n// This change causes an error\nnewPerson.dateOfBirth = new Date(2035, 10, 10);\n```", "```\nthis.dateOfBirth = date;\n```", "```\nset dateOfBirth(value) {\nif (value instanceof Date && value < Date.now()) {\n  // This is a valid date\n  this._dateOfBirth = value;\n}\nelse {\n  throw new TypeError('Birthdate needs to be a valid date in the past');\n}\n```", "```\nclass Person {\n  constructor(firstName, lastName, date) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.setDateOfBirth(date);\n  }\n\n  getDateOfBirth() {\n    return this._dateOfBirth;\n  }\n\n  setDateOfBirth(value) {\n    if (value instanceof Date && value < Date.now()) {\n      // This is a valid date\n      this._dateOfBirth = value;\n    }\n    else {\n      throw new TypeError('Birthdate cannot be in the future');\n    }\n  }\n}\n\nconst newPerson = new Person('Luke', 'Takei', new Date(1990, 5, 22));\nconsole.log(newPerson.getDateOfBirth());\n\n// This change is allowed\nnewPerson.setDateOfBirth (new Date(2010, 10, 10));\nconsole.log(newPerson.getDateOfBirth());\n\n// This change causes an error\nnewPerson.setDateOfBirth (new Date(2035, 10, 10));\n```", "```\n// This isn't the property you want (that's dateOfBirth) but JavaScript\n//  creates it anyway, and you won't notice the mistake\nperson.DateOfBirth = new Date(2035, 10, 10);\n\n// You can't call a function that doesn't exist, so this typo\n// (\"Data\" instead of \"Date\") always fails and won't be ignored\nperson.setDataOfBirth(new Date(2035, 10, 10));\n```", "```\n// A likely implementation of private field syntax in the near future\nclass Person {\n  #firstName;\n  #lastName;\n\n  constructor(firstName, lastName) {\n    this.#firstName = firstName;\n    this.#lastName = lastName;\n  }\n\n  // Wrap the fields in properties\n\tget firstName() {\n    return this.#firstName;\n  }\n  set firstName(name) {\n    this.#firstName = name;\n  }\n\n  get lastName() {\n    return this.#lastName;\n  }\n  set lastName(name) {\n    this.#lastName = name;\n  }\n}\n```", "```\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n\n  toString() {\n    return `${this.lastName}, ${this.firstName}`;\n  }\n}\n\nconst newPerson = new Person('Luke', 'Takei');\nconsole.log(newPerson.toString());   // 'Takei, Luke'\n```", "```\nconst newPerson = new Person('Luke', 'Takei');\nconst message = 'The name is ' + newPerson;\n\n// Now message = 'The name is Takei, Luke'\n// which is much better than 'The name is [object Object]'\n```", "```\nconst newPerson = new Person('Luke', 'Takei');\n\nconsole.log(newPerson);       // 'Person {firstName: \"Luke\", lastName: \"Takei\"}'\nconsole.log(`${newPerson}`);  // 'Takei, Luke'\nconsole.log(newPerson+'');    // 'Takei, Luke'\n```", "```\nfunction Person(firstName, lastName) {\n  // Store public data using 'this'\n  this.firstName = firstName;\n  this.lastName = lastName;\n\n  // Add a nested function to represent a method\n  this.swapNames = function() {\n    [this.firstName, this.lastName] = [this.lastName, this.firstName];\n  }\n}\n\n// Create a Person object\nconst newPerson = new Person('Luke', 'Takei');\nconsole.log(newPerson.firstName);  // 'Luke'\n\nnewPerson.swapNames();\nconsole.log(newPerson.firstName);  // 'Takei'\n```", "```\nfunction Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\n// Add function to the Person prototype to represent a method\nPerson.prototype.swapNames = function() {\n  [this.firstName, this.lastName] = [this.lastName, this.firstName];\n}\n\nconst newPerson = new Person('Luke', 'Takei');\nnewPerson.swapNames();\nconsole.log(newPerson.firstName);  // 'Takei'\n```", "```\nclass Book {\n  constructor(title, author, price, publishedDate) {\n    this.title = title;\n    this.author = author;\n    this.price = price;\n    this.publishedDate = publishedDate;\n  }\n\n  raisePrice(percent) {\n    const increase = this.price*percent;\n    this.price += Math.round(increase)/100;\n    return this;\n  }\n\n  releaseNewEdition() {\n    // Set the pulishedDate to today\n    this.publishedDate = new Date();\n    return this;\n  }\n}\n\nconst book = new Book('I Love Mathematics', 'Adam Up', 15.99,\n new Date(2010, 2, 2));\n\n// Raise the price 15% and then change the edition, using method chaining\nconsole.log(book.raisePrice(15).releaseNewEdition());\n```", "```\nconst safePieceOfHtml =\n originalPieceOfHtml.replaceAll('<', '&lt;').replaceAll('>', '&gt;');\n```", "```\nconst evens = [2, 4, 6, 8];\nconst odds = [1, 3, 5, 7, 9];\n\nconst evensAndOdds = evens.concat(odds).sort();\nconsole.log(evensAndOdds);  // [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```", "```\nclass Book {\n  constructor(title, author, price, publishedDate) {\n    this.title = title;\n    this.author = author;\n    this.price = price;\n    this.publishedDate = publishedDate;\n  }\n\n  getRaisedPriceBook(percent) {\n    const increase = this.price*percent;\n    return new Book(this.title, this.author, Math.round(increase)/100,\n     this.publishedDate);\n  }\n\n  getNewEdition() {\n    return new Book(this.title, this.author, this.price, new Date());\n  }\n}\n```", "```\nclass Book {\n  constructor(isbn, title, author, publishedDate) {\n    this.isbn = isbn;\n    this.title = title;\n    this.author = author;\n    this.publishedDate = publishedDate;\n  }\n\n  static isEqual(book, otherBook) {\n    if (book instanceof Book && otherBook instanceof Book) {\n      // Books are deemed equal if their ISBNs match,\n      // irrespective of dashes\n      return (book.isbn.replaceAll('-','') === otherBook.isbn.replaceAll('-',''));\n    }\n    else {\n      return false;\n    }\n  }\n}\n```", "```\nconst firstPrinting = new Book('978-3-16-148410-0', 'A.I. Is Not a Threat',\n 'Anne Droid', new Date(2019, 2, 2));\nconst secondPrinting = new Book('978-3-16-148410-0', 'A.I. Is Not a Threat',\n 'A. Droid', new Date(2021, 2, 10));\n\n// Compare the books with the static method\nconst sameBook = Book.isEqual(firstPrinting, secondPrinting);\n// sameBook = true\n\n// This doesn't work, because isEqual isn't available in Book instances\nsameBook = firstPrinting.isEqual(firstPrinting, secondPrinting);\n```", "```\nclass Book {\n  constructor(isbn, title, author, publishedDate) {\n    this.isbn = isbn;\n    this.title = title;\n    this.author = author;\n    this.publishedDate = publishedDate;\n  }\n\n  // Create a static, read-only Books.isnbnPrefix property\n  static get isbnPrefix() {\n    return '978-1';\n  }\n}\n```", "```\nclass Book {\n  // Create a static Book.isbnPrefix property\n  static isbnPrefix = '978-1';\n\n  constructor(isbn, title, author, publishedDate) {\n    this.isbn = isbn;\n    this.title = title;\n    this.author = author;\n    this.publishedDate = publishedDate;\n  }\n}\n```", "```\nclass Book {\n  constructor(title, firstName, lastName) {\n    this.title = title;\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n\n  static createSequel(prevBook, title) {\n    return new Book(title, prevBook.firstName, prevBook.lastName);\n  }\n}\n```", "```\n// Create a Book with the usual constructor\nconst book = new Book('Good Design', 'Polly', 'Morfissim');\n\n// Create a sequel with the static method\nconst sequel = Book.createSequel(book, 'Even Gooder Design');\nconsole.log(sequel);\n```", "```\nclass Author {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n\nclass Book {\n  constructor(title, author) {\n    this.title = title;\n    this.author = author;\n  }\n\n  static createSequel(prevBook, title) {\n    return new Book(title, prevBook.author);\n  }\n\n  static createTrilogy(author, title1, title2, title3) {\n    return [new Book(title1, author),\n      new Book(title2, author),\n      new Book(title3, author)];\n  }\n}\n\n// Create a trilogy of three books with a factory method\nconst author = new Author('Koh','Der');\nconst books = Book.createTrilogy(author, 'A Sea of Fire', 'A Sea of Ice',\n 'A Sea of Water');\nconsole.log(books);\n```", "```\npublic class SomeChild extends SomeParent {\n\n}\n```", "```\n// This is the parent class\nclass Shape {\n  getArea() {\n    return null;\n  }\n}\n\n// This is a child class\nclass Triangle extends Shape {\n  constructor(base, height) {\n    // Call the base class constructor\n    super();\n\n    this.base = base;\n    this.height = height;\n  }\n\n  getArea() {\n    return this.base * this.height/2;\n  }\n}\n```", "```\nclass Circle extends Shape {\n  constructor(radius) {\n    super();\n    this.radius = radius;\n  }\n\n  getArea() {\n    return Math.PI * this.radius**2;\n  }\n}\n\nclass Square extends Shape {\n  constructor(length) {\n    super();\n    this.length = length;\n  }\n\n  getArea() {\n    return this.length**2;\n  }\n}\n```", "```\n// Create an array of different shapes\nconst shapes = [new Triangle(15, 8), new Circle(8), new Square(7)];\n\n// Sort them by area from smallest to largest\nshapes.sort( (a,b) => a.getArea()-b.getArea() );\n\nconsole.log(shapes);\n// New order: Square, Triangle, Circle\n```", "```\nconst triangle = new Triangle(15, 8);\n\nif (triangle instanceof Shape) {\n  // We end up here, because triangle is a Triangle which is a Shape\n}\n```", "```\nconstructor(length) {\n  super();\n}\n```", "```\nclass Book {\n  constructor(title, author, publishedDate) {\n    this.title = title;\n    this.author = author;\n    this.publishedDate = publishedDate;\n  }\n}\n\nclass EBook extends Book {\n  constructor(title, author, publishedDate, format) {\n    super(title, author, publishedDate);\n    this.format = format;\n  }\n}\n```", "```\nclass Person {\n  constructor(firstName, lastName) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n  }\n}\n\nclass Employee {\n  constructor(person, department, hireDate) {\n    // person is a full-fledged Person object\n    this.person = person;\n\n    // These properties hold the extra, nonperson information\n    this.department = department;\n    this.hireDate = hireDate;\n  }\n}\n\n// Create an Employee object that's composed of a Person object\n// and some extra details\nconst employee = new Employee(new Person('Mike', 'Scott'), 'Sales', new Date());\n```", "```\n// This will be the parent class\nfunction Person(firstName, lastName) {\n  this.firstName = firstName;\n  this.lastName = lastName;\n}\n\n// Add the methods you want to the Person class\nPerson.prototype.greet = function() {\n  console.log('I am ' + this.firstName + ' ' + this.lastName);\n}\n\n// This will be the child class\nfunction Employee(firstName, lastName, department) {\n  // The Object.call() method allows you to chain constructor functions\n  // It binds the Person constructor to this object's context\n  Person.call(this, firstName, lastName);\n\n  // Add extra details\n  this.department = department;\n}\n\n// Link the Person prototype to the Employee function\n// This establishes the inheritance relationship\nEmployee.prototype = Object.create(Person.prototype);\nEmployee.prototype.constructor = Employee;\n\n// Now add the methods you want to the Employee class\nEmployee.prototype.introduceJob = function() {\n  console.log('I work in ' + this.department);\n}\n\n// When you create an instance of the Employee function, its prototype\n// is chained back to the Person prototype\nconst newEmployee = new Employee('Luke', 'Takei', 'Tech Support');\n\n// You can call Person methods and Employee methods\nnewEmployee.greet();          // 'I am Luke Takei'\nnewEmployee.introduceJob();   // 'I work in Tech Support'\n```", "```\nconst Units = {\n  Meters: 100,\n  Centimeters: 1,\n  Kilometers: 100000,\n  Yards: 91.44,\n  Feet: 30.48,\n  Miles: 160934,\n  Furlongs: 20116.8,\n  Elephants: 625,\n  Boeing747s: 7100\n};\n\nclass InvisibleLogger {\n  static log() {\n    console.log('Greetings from the invisible logger');\n  }\n}\n\nclass LengthConverter {\n  static Convert(value, fromUnit, toUnit) {\n    InvisibleLogger.log();\n    return value*fromUnit/toUnit;\n  }\n}\n\nexport {Units, LengthConverter}\n```", "```\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" />\n    <title>Module Test</title>\n  </head>\n  <body>\n    <h1>Module Test</h1>\n    <button id=\"convertButton\">Do Sample Conversion</button>\n\n<script type=\"module\">\n  import {Units, LengthConverter} from './lengthConverterModule.js';\n\n  function doSampleConversion() {\n    const lengthInMiles = 495;\n\n    // This works because you have access to LengthConverter and Units\n    const lengthInElephants =\n     LengthConverter.Convert(lengthInMiles, Units.Feet, Units.Yards);\n    alert(lengthInElephants);\n\n    // This wouldn't work, because you don't have access to InvisibleLogger\n    //InvisibleLogger.log();\n  }\n\n  // Connect the button\n  document.getElementById('convertButton').addEventListener('click',\n   doSampleConversion);\n</script>\n\n  </body>\n</html>\n```", "```\n<script type=\"module\">\n```", "```\nimport {Units, LengthConverter} from './lengthConverterModule.js';\n```", "```\nimport * as LConvert from './lengthConverterModule.js';\n\n// Now you can access LengthConverter as LConvert.LengthConverter\n```", "```\nexport default LengthConverter\n```", "```\nimport LConvert from './lengthConverterModule.js';\n```"]