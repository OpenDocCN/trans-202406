<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Objects"><div class="chapter" id="objects">
<h1><span class="label">Chapter 4. </span>Objects</h1>

<blockquote>
<p>Object literals</p>

<p>A set of keys and values</p>

<p>Each with their own type</p></blockquote>

<p><a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.xhtml#unions_and_literals">Chapter 3, “Unions and Literals”</a> fleshed out union and literal types: working with primitives such as <code>boolean</code> and literal values of them such as <code>true</code>.
Those primitives only scratch the surface of the complex object shapes JavaScript code commonly uses.
TypeScript would be pretty unusable if it weren’t able to represent those objects.
This chapter will cover how to describe complex object shapes and how TypeScript checks their assignability.</p>






<section data-type="sect1" data-pdf-bookmark="Object Types"><div class="sect1" id="idm45584691202720">
<h1>Object Types</h1>

<p>When<a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="described" id="type-object-describe"/><a data-type="indexterm" data-primary="objects" data-secondary="described" id="object-describe"/> you create an object literal with <code>{...}</code> syntax, TypeScript will consider it to be a new object type, or type shape, based on its properties.
That object type will have the same property names and primitive types as the object’s values.
Accessing properties of the value can be done with either <code>value.member</code> or the equivalent <code>value['member']</code> syntax.</p>

<p>TypeScript understands that the following <code>poet</code> variable’s type is that of an object with two properties: <code>born</code>, of type <code>number</code>, and <code>name</code>, of type <code>string</code>.
Accessing those members would be allowed, but attempting to access any other member name would cause a type error for that name not existing:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">const</code> <code class="nx">poet</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">born</code>: <code class="nx">1935</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Mary Oliver"</code><code class="p">,</code>
<code class="p">};</code>

<code class="nx">poet</code><code class="p">[</code><code class="s1">'born'</code><code class="p">];</code> <code class="c1">// Type: number</code>
<code class="nx">poet</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code> <code class="c1">// Type: string</code>

<code class="nx">poet</code><code class="p">.</code><code class="nx">end</code><code class="p">;</code>
<code class="c1">//   ~~~</code>
<code class="c1">// Error: Property 'end' does not exist on</code>
<code class="c1">// type '{ name: string; start: number; }'.</code></pre>

<p>Object types are a core concept for how TypeScript understands JavaScript code.
Every value other than <code>null</code> and <code>undefined</code> has a set of members in its backing type shape, and so TypeScript must understand the object type for every value in order to type check <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="described" data-startref="type-object-describe" id="idm45584691170368"/><a data-type="indexterm" data-primary="objects" data-secondary="described" data-startref="object-describe" id="idm45584691168944"/>it.</p>








<section data-type="sect2" data-pdf-bookmark="Declaring Object Types"><div class="sect2" id="idm45584691167472">
<h2>Declaring Object Types</h2>

<p>Inferring types <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="declaring" id="idm45584691165904"/><a data-type="indexterm" data-primary="objects" data-secondary="declaring" id="idm45584691164624"/><a data-type="indexterm" data-primary="declaring" data-secondary="objects" id="idm45584691163680"/>directly from existing objects is all fine and good, but eventually you’ll want to be able to declare the type of an object explicitly.
You’ll need a way to describe an object shape separately from objects that satisfy it.</p>

<p>Object types may be described using a syntax that looks similar to object literals but with types instead of values for fields.
It’s the same syntax that TypeScript shows in error messages about type assignability.</p>

<p>This <code>poetLater</code> variable is the same type from before with <code>name: string</code> and <code>born: number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">poetLater</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">born</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// Ok</code>
<code class="nx">poetLater</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">born</code>: <code class="nx">1935</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Mary Oliver"</code><code class="p">,</code>
<code class="p">};</code>

<code class="nx">poetLater</code> <code class="o">=</code> <code class="s2">"Sappho"</code><code class="p">;</code>
<code class="c1">// Error: Type 'string' is not assignable to</code>
<code class="c1">// type '{ born: number; name: string; }'</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Aliased Object Types"><div class="sect2" id="idm45584691106416">
<h2>Aliased Object Types</h2>

<p>Constantly <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="type aliases for" id="type-object-typealias"/><a data-type="indexterm" data-primary="objects" data-secondary="type aliases for" id="object-typealias"/><a data-type="indexterm" data-primary="type aliases" data-secondary="for objects" data-secondary-sortas="objects" id="type-alias-object"/>writing out object types like <code>{ born: number; name: string; }</code> would get tiresome rather quickly.
It’s more common to use type aliases to assign each type shape a name.</p>

<p>The previous code snippet could be rewritten with a <code>type Poet</code>, which comes with the added benefit of making TypeScript’s assignability error message a little more direct and readable:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Poet</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">born</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">poetLater</code>: <code class="nx">Poet</code><code class="p">;</code>

<code class="c1">// Ok</code>
<code class="nx">poetLater</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">born</code>: <code class="nx">1935</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Sara Teasdale"</code><code class="p">,</code>
<code class="p">};</code>

<code class="nx">poetLater</code> <code class="o">=</code> <code class="s2">"Emily Dickinson"</code><code class="p">;</code>
<code class="c1">// Error: Type 'string' is not assignable to 'Poet'.</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Most TypeScript <a data-type="indexterm" data-primary="interface keyword" id="idm45584690995984"/>projects prefer using the <code>interface</code> keyword to describe object types, which is a feature I won’t cover until <a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.xhtml#interfaces">Chapter 7, “Interfaces”</a>.
Aliased object types and interfaces are 
<span class="keep-together">almost identical:</span> everything in this chapter applies to interfaces as well.</p>
</div>

<p>I bring these object types up now because understanding how TypeScript interprets object literals is an important part of learning about TypeScript’s type system.
These concepts will continue to be important once we switch over to features in the next section of this book.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Structural Typing"><div class="sect1" id="idm45584691029616">
<h1>Structural Typing</h1>

<p>TypeScript’s <a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="described" id="type-structural-describe"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="described" id="object-structural-describe"/><a data-type="indexterm" data-primary="structural typing" data-secondary="described" id="structural-describe"/>type system is <em>structurally typed</em>: meaning any value that happens to satisfy a type is allowed to be used as a value of that type.
In other words, when you declare that a parameter or variable is of a particular object type, you’re telling TypeScript that whatever object(s) you use, they need to have those properties.</p>

<p class="less_space pagebreak-before">The following <code>WithFirstName</code> and <code>WithLastName</code> aliased object types both only declare a single member of type <code>string</code>.
The <code>hasBoth</code> variable just so happens to have both of them—even though it wasn’t declared as such explicitly—so it can be provided to variables that are declared as either of the two aliased object types:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">WithFirstName</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">firstName</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">WithLastName</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">lastName</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">hasBoth</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">firstName</code><code class="o">:</code> <code class="s2">"Lucille"</code><code class="p">,</code>
  <code class="nx">lastName</code><code class="o">:</code> <code class="s2">"Clifton"</code><code class="p">,</code>
<code class="p">};</code>

<code class="c1">// Ok: `hasBoth` contains a `firstName` property of type `string`</code>
<code class="kd">let</code> <code class="nx">withFirstName</code>: <code class="nx">WithFirstName</code> <code class="o">=</code> <code class="nx">hasBoth</code><code class="p">;</code>

<code class="c1">// Ok: `hasBoth` contains a `lastName` property of type `string`</code>
<code class="kd">let</code> <code class="nx">withLastName</code>: <code class="nx">WithLastName</code> <code class="o">=</code> <code class="nx">hasBoth</code><code class="p">;</code></pre>

<p>Structural typing not the same<a data-type="indexterm" data-primary="duck typing" id="idm45584690958288"/><a data-type="indexterm" data-primary="types" data-secondary="duck typing" id="idm45584690900640"/> as <em>duck typing</em>, which comes from the phrase “If it looks like a duck and quacks like a duck, it’s probably a duck.”</p>

<ul>
<li>
<p>Structural typing is when there is a static system checking the type—in TypeScript’s case, the type checker.</p>
</li>
<li>
<p>Duck typing is when nothing checks object types until they’re used at runtime.</p>
</li>
</ul>

<p>In <a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="described" data-startref="type-structural-describe" id="idm45584690896144"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="described" data-startref="object-structural-describe" id="idm45584690894624"/><a data-type="indexterm" data-primary="structural typing" data-secondary="described" data-startref="structural-describe" id="idm45584690890960"/>summary: <em>JavaScript</em> is <em>duck typed</em> whereas <em>TypeScript</em> is <em>structurally typed</em>.</p>








<section data-type="sect2" data-pdf-bookmark="Usage Checking"><div class="sect2" id="idm45584690888208">
<h2>Usage Checking</h2>

<p>When <a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="usage checking" id="idm45584690886704"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="usage checking" id="idm45584690885424"/><a data-type="indexterm" data-primary="structural typing" data-secondary="usage checking" id="idm45584690884208"/><a data-type="indexterm" data-primary="usage checking in structural typing" id="idm45584690883264"/>providing a value to a location annotated with an object type, TypeScript will check that the value is assignable to that object type.
To start, the value must have the object type’s required properties.
If any member required on the object type is missing in the object, TypeScript will issue a type error.</p>

<p>The following <code>FirstAndLastNames</code> aliased object type requires that both the <code>first</code> and <code>last</code> properties exist.
An object containing both of those is allowed to be used in a variable declared to be of type <code>FirstAndLastNames</code>, but an object without them is not:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">FirstAndLastNames</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">first</code>: <code class="nx">string</code><code class="p">;</code>
  <code class="nx">last</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// Ok</code>
<code class="kr">const</code> <code class="nx">hasBoth</code>: <code class="nx">FirstAndLastNames</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">first</code><code class="o">:</code> <code class="s2">"Sarojini"</code><code class="p">,</code>
  <code class="nx">last</code><code class="o">:</code> <code class="s2">"Naidu"</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">hasOnlyOne</code>: <code class="nx">FirstAndLastNames</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">first</code><code class="o">:</code> <code class="s2">"Sappho"</code>
<code class="p">};</code>
<code class="c1">// Property 'last' is missing in type '{ first: string; }'</code>
<code class="c1">// but required in type 'FirstAndLastNames'.</code></pre>

<p>Mismatched types between the two are not allowed either.
Object types specify both the names of required properties and the types those properties are expected to be.
If an object’s property doesn’t match, TypeScript will report a type error.</p>

<p>The following <code>TimeRange</code> type expects the <code>start</code> member to be of type <code>Date</code>.
The <code>hasStartString</code> object is causing a type error because its <code>start</code> is type <code>string</code> instead:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">TimeRange</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">start</code>: <code class="nx">Date</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">hasStartString</code>: <code class="nx">TimeRange</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">start</code><code class="o">:</code> <code class="s2">"1879-02-13"</code><code class="p">,</code>
  <code class="c1">// Error: Type 'string' is not assignable to type 'Date'.</code>
<code class="p">};</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Excess Property Checking"><div class="sect2" id="idm45584690841120">
<h2>Excess Property Checking</h2>

<p>Typescript<a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="excess property checking" id="type-structural-excess"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="excess property checking" id="object-structural-excess"/><a data-type="indexterm" data-primary="structural typing" data-secondary="excess property checking" id="structural-excess"/><a data-type="indexterm" data-primary="excess property checking in structural typing" id="excess-structural"/><a data-type="indexterm" data-primary="properties" data-secondary="excess property checking" id="property-excess"/> will report a type error if a variable is declared with an object type and its initial value has more fields than its type describes.
Therefore, declaring a variable to be of an object type is a way of getting the type checker to make sure it has only the expected fields on that type.</p>

<p>The following <code>poetMatch</code> variable has exactly the fields described in the object type aliased by <code>Poet</code>, while <code>extraProperty</code> causes a type error for having an extra 
<span class="keep-together">property:</span></p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Poet</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">born</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Ok: all fields match what's expected in Poet</code>
<code class="kr">const</code> <code class="nx">poetMatch</code>: <code class="nx">Poet</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">born</code>: <code class="nx">1928</code><code class="p">,</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Maya Angelou"</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">extraProperty</code>: <code class="nx">Poet</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">activity</code><code class="o">:</code> <code class="s2">"walking"</code><code class="p">,</code>
    <code class="nx">born</code>: <code class="nx">1935</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Mary Oliver"</code><code class="p">,</code>
<code class="p">};</code>
<code class="c1">// Error: Type '{ activity: string; born: number; name: string; }'</code>
<code class="c1">// is not assignable to type 'Poet'.</code>
<code class="c1">//   Object literal may only specify known properties,</code>
<code class="c1">//   and 'activity' does not exist in type 'Poet'.</code></pre>

<p>Note that excess property checks only trigger for object literals being created in locations that are declared to be an object type.
Providing an existing object literal bypasses excess property checks.</p>

<p>This <code>extraPropertyButOk</code> variable does not trigger a type error with the previous example’s <code>Poet</code> type because its initial value happens to structurally match <code>Poet</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">existingObject</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">activity</code><code class="o">:</code> <code class="s2">"walking"</code><code class="p">,</code>
    <code class="nx">born</code>: <code class="nx">1935</code><code class="p">,</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Mary Oliver"</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">extraPropertyButOk</code>: <code class="nx">Poet</code> <code class="o">=</code> <code class="nx">existingObject</code><code class="p">;</code> <code class="c1">// Ok</code></pre>

<p>Excess property checks will trigger anywhere a new object is being created in a location that expects it to match an object type—which as you’ll see in later chapters includes array members, class fields, and function parameters.
Banning excess properties is another way TypeScript helps make sure your code is clean and does what you expect.
Excess properties not declared in their object types are often either mistyped property names or <a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="excess property checking" data-startref="type-structural-excess" id="idm45584690608592"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="excess property checking" data-startref="object-structural-excess" id="idm45584690607264"/><a data-type="indexterm" data-primary="structural typing" data-secondary="excess property checking" data-startref="structural-excess" id="idm45584690640448"/><a data-type="indexterm" data-primary="excess property checking in structural typing" data-startref="excess-structural" id="idm45584690639264"/><a data-type="indexterm" data-primary="properties" data-secondary="excess property checking" data-startref="property-excess" id="idm45584690638352"/>unused code.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Nested Object Types"><div class="sect2" id="idm45584690636912">
<h2>Nested Object Types</h2>

<p>As <a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="nested objects" id="type-structural-nest"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="nested objects" id="object-structural-nest"/><a data-type="indexterm" data-primary="structural typing" data-secondary="nested objects" id="structural-nest"/><a data-type="indexterm" data-primary="nested objects" id="nest-object"/>JavaScript objects can be nested as members of other objects, TypeScript’s object types must be able to represent nested object types in the type system.
The syntax to do so is the same as before but with a <code>{ ... }</code> object type instead of a primitive name.</p>

<p><code>Poem</code> type is declared to be an object whose <code>author</code> property has <code>firstName: string</code> and <code>lastName: string</code>. The <code>poemMatch</code> variable is assignable to  <code>Poem</code> because it matches that structure, while <code>poemMismatch</code> is not because its <code>author</code> property includes  <code>name</code> instead of <code>firstName</code> and <code>lastName</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Poem</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">firstName</code>: <code class="nx">string</code><code class="p">;</code>
        <code class="nx">lastName</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="p">};</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// Ok</code>
<code class="kr">const</code> <code class="nx">poemMatch</code>: <code class="nx">Poem</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">firstName</code><code class="o">:</code> <code class="s2">"Sylvia"</code><code class="p">,</code>
        <code class="nx">lastName</code><code class="o">:</code> <code class="s2">"Plath"</code><code class="p">,</code>
    <code class="p">},</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Lady Lazarus"</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">poemMismatch</code>: <code class="nx">Poem</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">name</code><code class="o">:</code> <code class="s2">"Sylvia Plath"</code><code class="p">,</code>
    <code class="p">},</code>
    <code class="c1">// Error: Type '{ name: string; }' is not assignable</code>
    <code class="c1">// to type '{ firstName: string; lastName: string; }'.</code>
    <code class="c1">//   Object literal may only specify known properties, and 'name'</code>
    <code class="c1">//   does not exist in type '{ firstName: string; lastName: string; }'.</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Tulips"</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>Another way of writing the <code>type Poem</code> would be to extract out the <code>author</code> property’s shape into its own aliased object type, <code>Author</code>.
Extracting out nested types into their own type aliases also helps TypeScript give more informative type error messages.
In this case, it can say <code>'Author'</code> instead of <code>'{ firstName: string; lastName: string; }'</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Author</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">firstName</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">lastName</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">Poem</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code>: <code class="nx">Author</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">poemMismatch</code>: <code class="nx">Poem</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">name</code><code class="o">:</code> <code class="s2">"Sylvia Plath"</code><code class="p">,</code>
    <code class="p">},</code>
    <code class="c1">// Error: Type '{ name: string; }' is not assignable to type 'Author'.</code>
    <code class="c1">//     Object literal may only specify known properties,</code>
    <code class="c1">//     and 'name' does not exist in type 'Author'.</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Tulips"</code><code class="p">,</code>
<code class="p">};</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>It is generally a good idea to move nested object types into their own type name like this, both for more readable code and for more readable TypeScript error messages.</p>
</div>

<p>You’ll see in later chapters how object type members can be other types such as arrays and <a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="nested objects" data-startref="type-structural-nest" id="idm45584690440208"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="nested objects" data-startref="object-structural-nest" id="idm45584690438752"/><a data-type="indexterm" data-primary="structural typing" data-secondary="nested objects" data-startref="structural-nest" id="idm45584690437264"/><a data-type="indexterm" data-primary="nested objects" data-startref="nest-object" id="idm45584690436048"/>functions.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Optional Properties"><div class="sect2" id="idm45584690434848">
<h2>Optional Properties</h2>

<p>Object type <a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="optional properties" id="type-structural-optional"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="optional properties" id="object-structural-optional"/><a data-type="indexterm" data-primary="structural typing" data-secondary="optional properties" id="structural-optional"/><a data-type="indexterm" data-primary="optional properties" data-secondary="of objects" data-secondary-sortas="objects" id="optional-property-object"/><a data-type="indexterm" data-primary="properties" data-secondary="of objects, optional" data-secondary-sortas="objects" id="property-object-optional"/><a data-type="indexterm" data-primary="? (question mark)" data-secondary="optional properties" id="question-sym-optional"/><a data-type="indexterm" data-primary="question mark (?)" data-secondary="optional properties" id="question-optional"/>properties don’t all have to be required in the object.
You can include a <code>?</code> before the <code>:</code> in a type property’s type annotation to indicate that it’s an optional property.</p>

<p>This <code>Book</code> type requires only a <code>pages</code> property and optionally allows an <code>author</code>.
Objects adhering to it may provide <code>author</code> or leave it out as long as they provide <code>pages</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Book</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">author?</code>: <code class="nx">string</code><code class="p">;</code>
  <code class="nx">pages</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// Ok</code>
<code class="kr">const</code> <code class="nx">ok</code>: <code class="nx">Book</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="s2">"Rita Dove"</code><code class="p">,</code>
    <code class="nx">pages</code>: <code class="nx">80</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">missing</code>: <code class="nx">Book</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="s2">"Rita Dove"</code><code class="p">,</code>
<code class="p">};</code>
<code class="c1">// Error: Property 'pages' is missing in type</code>
<code class="c1">// '{ author: string; }' but required in type 'Book'.</code></pre>

<p>Keep in mind there is <a data-type="indexterm" data-primary="undefined primitive" data-secondary="optional properties vs." id="idm45584690325104"/>a difference between optional properties and properties whose type happens to include <code>undefined</code> in a type union.
A property declared as optional with <code>?</code> is allowed to not exist.
A property declared as required and <code>| undefined</code> must exist, even if the value is <code>undefined</code>.</p>

<p>The <code>editor</code> property in the following <code>Writers</code> type may be skipped in declaring variables because it has a <code>?</code> in its declaration.
The <code>author</code> property does not have a <code>?</code>, so it must exist, even if its value is just <code>undefined</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Writers</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">author</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>
  <code class="nx">editor?</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// Ok: author is provided as undefined</code>
<code class="kr">const</code> <code class="nx">hasRequired</code>: <code class="nx">Writers</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">author</code>: <code class="nx">undefined</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">missingRequired</code>: <code class="nx">Writers</code> <code class="o">=</code> <code class="p">{};</code>
<code class="c1">//    ~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Property 'author' is missing in type</code>
<code class="c1">// '{}' but required in type 'Writers'.</code></pre>

<p><a data-type="xref" data-xrefstyle="chap-num-title" href="ch07.xhtml#interfaces">Chapter 7, “Interfaces”</a> will cover more on other kinds of properties, while <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a> will describe TypeScript’s strictness settings around <a data-type="indexterm" data-primary="types" data-secondary="structural typing" data-tertiary="optional properties" data-startref="type-structural-optional" id="idm45584690239776"/><a data-type="indexterm" data-primary="objects" data-secondary="structural typing" data-tertiary="optional properties" data-startref="object-structural-optional" id="idm45584690238288"/><a data-type="indexterm" data-primary="structural typing" data-secondary="optional properties" data-startref="structural-optional" id="idm45584690236832"/><a data-type="indexterm" data-primary="optional properties" data-secondary="of objects" data-secondary-sortas="objects" data-startref="optional-property-object" id="idm45584690235616"/><a data-type="indexterm" data-primary="properties" data-secondary="of objects, optional" data-secondary-sortas="objects" data-startref="property-object-optional" id="idm45584690224576"/><a data-type="indexterm" data-primary="? (question mark)" data-secondary="optional properties" data-startref="question-sym-optional" id="idm45584690223184"/><a data-type="indexterm" data-primary="question mark (?)" data-secondary="optional properties" data-startref="question-optional" id="idm45584690221968"/>optional properties.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Unions of Object Types"><div class="sect1" id="idm45584691028992">
<h1>Unions of Object Types</h1>

<p>It is reasonable in TypeScript code to want to be able to describe a type that can be one or more different object types that have slightly different properties.
Furthermore, your code might want to be able to type narrow between those object types based on the value of a property.</p>








<section data-type="sect2" data-pdf-bookmark="Inferred Object-Type Unions"><div class="sect2" id="idm45584690219184">
<h2>Inferred Object-Type Unions</h2>

<p>If a <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="inferred unions" id="idm45584690217888"/><a data-type="indexterm" data-primary="unions" data-secondary="of objects" data-tertiary="inferred unions" data-secondary-sortas="objects" id="idm45584690216608"/><a data-type="indexterm" data-primary="objects" data-secondary="unions of" data-tertiary="inferred unions" id="idm45584690215120"/><a data-type="indexterm" data-primary="inferred unions of objects" id="idm45584690213904"/>variable is given an initial value that could be one of multiple object types, TypeScript will infer its type to be a union of object types.
That union type will have a constituent for each of the possible object shapes.
Each of the possible properties on the type will be present in each of those constituents, though they’ll be <code>?</code> optional types on any type that doesn’t have an initial value for them.</p>

<p>This <code>poem</code> value always has a <code>name</code> property of type <code>string</code>, and may or may not have <code>pages</code> and <code>rhymes</code> properties:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">poem</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
  <code class="o">?</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"The Double Image"</code><code class="p">,</code> <code class="nx">pages</code>: <code class="nx">7</code> <code class="p">}</code>
  <code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Her Kind"</code><code class="p">,</code> <code class="nx">rhymes</code>: <code class="nx">true</code> <code class="p">};</code>
<code class="c1">// Type:</code>
<code class="c1">// {</code>
<code class="c1">//   name: string;</code>
<code class="c1">//   pages: number;</code>
<code class="c1">//   rhymes?: undefined;</code>
<code class="c1">// }</code>
<code class="c1">// |</code>
<code class="c1">// {</code>
<code class="c1">//   name: string;</code>
<code class="c1">//   pages?: undefined;</code>
<code class="c1">//   rhymes: boolean;</code>
<code class="c1">// }</code>

<code class="nx">poem</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code> <code class="c1">// string</code>
<code class="nx">poem</code><code class="p">.</code><code class="nx">pages</code><code class="p">;</code> <code class="c1">// number | undefined</code>
<code class="nx">poem</code><code class="p">.</code><code class="nx">rhymes</code><code class="p">;</code> <code class="c1">// booleans | undefined</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Explicit Object-Type Unions"><div class="sect2" id="idm45584690186544">
<h2>Explicit Object-Type Unions</h2>

<p>Alternately, <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="explicit unions" id="type-object-explicit"/><a data-type="indexterm" data-primary="unions" data-secondary="of objects" data-tertiary="explicit unions" data-secondary-sortas="objects" id="union-object-explicit"/><a data-type="indexterm" data-primary="objects" data-secondary="unions of" data-tertiary="explicit unions" id="object-union-explicit"/><a data-type="indexterm" data-primary="explicit unions of objects" id="explicit-union-object"/>you can be more explicit about your object types by being explicit with your own union of object types.
Doing so requires writing a bit more code but comes with the advantage of giving you more control over your object types.
Most notably, if a value’s type is a union of object types, TypeScript’s type system will only allow access to properties that exist on all of those union types.</p>

<p>This version of the previous <code>poem</code> variable is explicitly typed to be a union type that always has the <code>always</code> property along with either <code>pages</code> or <code>rhymes</code>.
Accessing <code>names</code> is allowed because it always exists, but <code>pages</code> and <code>rhymes</code> aren’t guaranteed to exist:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">PoemWithPages</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">pages</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">PoemWithRhymes</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">rhymes</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">Poem</code> <code class="o">=</code> <code class="nx">PoemWithPages</code> <code class="o">|</code> <code class="nx">PoemWithRhymes</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">poem</code>: <code class="nx">Poem</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
  <code class="o">?</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"The Double Image"</code><code class="p">,</code> <code class="nx">pages</code>: <code class="nx">7</code> <code class="p">}</code>
  <code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Her Kind"</code><code class="p">,</code> <code class="nx">rhymes</code>: <code class="nx">true</code> <code class="p">};</code>

<code class="nx">poem</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">poem</code><code class="p">.</code><code class="nx">pages</code><code class="p">;</code>
<code class="c1">//   ~~~~~</code>
<code class="c1">// Property 'pages' does not exist on type 'Poem'.</code>
<code class="c1">//   Property 'pages' does not exist on type 'PoemWithRhymes'.</code>

<code class="nx">poem</code><code class="p">.</code><code class="nx">rhymes</code><code class="p">;</code>
<code class="c1">//   ~~~~~~</code>
<code class="c1">// Property 'rhymes' does not exist on type 'Poem'.</code>
<code class="c1">//   Property 'rhymes' does not exist on type 'PoemWithPages'.</code></pre>

<p>Restricting access to potentially nonexistent members of objects can be a good thing for code safety.
If a value might be one of multiple types, properties that don’t exist on all of those types aren’t guaranteed to exist on the object.</p>

<p class="less_space pagebreak-before">Just as how unions of literal and/or primitive types must be type narrowed to access properties that don’t exist on all type constituents, you’ll need to narrow those object type <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="explicit unions" data-startref="type-object-explicit" id="idm45584690005952"/><a data-type="indexterm" data-primary="unions" data-secondary="of objects" data-tertiary="explicit unions" data-secondary-sortas="objects" data-startref="union-object-explicit" id="idm45584690049008"/><a data-type="indexterm" data-primary="objects" data-secondary="unions of" data-tertiary="explicit unions" data-startref="object-union-explicit" id="idm45584689974032"/><a data-type="indexterm" data-primary="explicit unions of objects" data-startref="explicit-union-object" id="idm45584689972672"/>unions.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Narrowing Object Types"><div class="sect2" id="idm45584689971504">
<h2>Narrowing Object Types</h2>

<p>If the<a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="narrowing" id="idm45584689970000"/><a data-type="indexterm" data-primary="unions" data-secondary="of objects" data-tertiary="narrowing" data-secondary-sortas="objects" id="idm45584689968720"/><a data-type="indexterm" data-primary="objects" data-secondary="unions of" data-tertiary="narrowing" id="idm45584689967232"/><a data-type="indexterm" data-primary="narrowing" data-secondary="objects" id="idm45584689966016"/> type checker sees that an area of code can only be run if a union typed value contains a certain property, it will narrow the value’s type to only the constituents that contain that property.
In other words, TypeScript’s type narrowing will apply to objects if you check their shape in code.</p>

<p>Continuing the explicitly typed <code>poem</code> example, check whether <code>"pages" in poem</code> acts as a type guard for TypeScript to indicate that it is a <code>PoemWithPages</code>.
If <code>poem</code> is not a <code>PoemWithPages</code>, then it must be a <code>PoemWithRhymes</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="k">if</code> <code class="p">(</code><code class="s2">"pages"</code> <code class="k">in</code> <code class="nx">poem</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">poem</code><code class="p">.</code><code class="nx">pages</code><code class="p">;</code> <code class="c1">// Ok: poem is narrowed to PoemWithPages</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="nx">poem</code><code class="p">.</code><code class="nx">rhymes</code><code class="p">;</code> <code class="c1">// Ok: poem is narrowed to PoemWithRhymes</code>
<code class="p">}</code></pre>

<p>Note that TypeScript won’t allow truthiness existence checks like <code>if (poem.pages)</code>.
Attempting to access a property of an object that might not exist is considered a type error, even if used in a way that seems to behave like a type guard:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="k">if</code> <code class="p">(</code><code class="nx">poem</code><code class="p">.</code><code class="nx">pages</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>
<code class="c1">//       ~~~~~</code>
<code class="c1">// Property 'pages' does not exist on type 'PoemWithPages | PoemWithRhymes'.</code>
<code class="c1">//   Property 'pages' does not exist on type 'PoemWithRhymes'.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Discriminated Unions"><div class="sect2" id="idm45584689867888">
<h2>Discriminated Unions</h2>

<p>Another <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="discriminated unions" id="type-object-discriminate"/><a data-type="indexterm" data-primary="unions" data-secondary="discriminated unions" id="union-object-discriminate"/><a data-type="indexterm" data-primary="objects" data-secondary="unions of" data-tertiary="discriminated unions" id="object-union-discriminate"/><a data-type="indexterm" data-primary="discriminated unions" data-secondary="described" id="discriminate-union"/>popular form of union typed objects in JavaScript and TypeScript is to have a property on the object indicate what shape the object is.
This kind of type shape is called a <em>discriminated union</em>, and the property whose value indicates the object’s type is<a data-type="indexterm" data-primary="discriminants" id="idm45584689930240"/> a <em>discriminant</em>.
TypeScript is able to perform type narrowing for code that type guards on discriminant properties.</p>

<p>For example, this <code>Poem</code> type describes an object that can be either a new 
<span class="keep-together"><code>PoemWithPages</code></span> type or a new <code>PoemWithRhymes</code> type, and the <code>type</code> property indicates which one.
If <code>poem.type</code> is <code>"pages"</code>, then TypeScript is able to infer that the type of <code>poem</code> must be <code>PoemWithPages</code>.
Without that type narrowing, neither property is guaranteed to exist on the value:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">type</code> <code class="nx">PoemWithPages</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">pages</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="nx">type</code>: <code class="s1">'pages'</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">PoemWithRhymes</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">rhymes</code>: <code class="nx">boolean</code><code class="p">;</code>
    <code class="nx">type</code>: <code class="s1">'rhymes'</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">Poem</code> <code class="o">=</code> <code class="nx">PoemWithPages</code> <code class="o">|</code> <code class="nx">PoemWithRhymes</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">poem</code>: <code class="nx">Poem</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
  <code class="o">?</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"The Double Image"</code><code class="p">,</code> <code class="nx">pages</code>: <code class="nx">7</code><code class="p">,</code> <code class="nx">type</code>: <code class="s2">"pages"</code> <code class="p">}</code>
  <code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Her Kind"</code><code class="p">,</code> <code class="nx">rhymes</code>: <code class="nx">true</code><code class="p">,</code> <code class="nx">type</code>: <code class="s2">"rhymes"</code> <code class="p">};</code>

<code class="k">if</code> <code class="p">(</code><code class="nx">poem</code><code class="p">.</code><code class="nx">type</code> <code class="o">===</code> <code class="s2">"pages"</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`It's got pages: </code><code class="si">${</code><code class="nx">poem</code><code class="p">.</code><code class="nx">pages</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code> <code class="c1">// Ok</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`It rhymes: </code><code class="si">${</code><code class="nx">poem</code><code class="p">.</code><code class="nx">rhymes</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">poem</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code> <code class="c1">// Type: 'pages' | 'rhymes'</code>

<code class="nx">poem</code><code class="p">.</code><code class="nx">pages</code><code class="p">;</code>
<code class="c1">//   ~~~~~</code>
<code class="c1">// Error: Property 'pages' does not exist on type 'Poem'.</code>
<code class="c1">//   Property 'pages' does not exist on type 'PoemWithRhymes'.</code></pre>

<p>Discriminated unions are my favorite feature in TypeScript because they beautifully combine a common elegant JavaScript pattern with TypeScript’s type narrowing.
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch10.xhtml#generics_chapter">Chapter 10, “Generics”</a> and its associated projects will show more around using discriminated unions for generic data <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="discriminated unions" data-startref="type-object-discriminate" id="idm45584689861568"/><a data-type="indexterm" data-primary="unions" data-secondary="discriminated unions" data-startref="union-object-discriminate" id="idm45584689680368"/><a data-type="indexterm" data-primary="objects" data-secondary="unions of" data-tertiary="discriminated unions" data-startref="object-union-discriminate" id="idm45584689679184"/><a data-type="indexterm" data-primary="discriminated unions" data-secondary="described" data-startref="discriminate-union" id="idm45584689677728"/>operations.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Intersection Types"><div class="sect1" id="idm45584689676128">
<h1>Intersection Types</h1>

<p>TypeScript’s <code>|</code> union types <a data-type="indexterm" data-primary="types" data-secondary="intersections" data-tertiary="described" id="idm45584689673952"/><a data-type="indexterm" data-primary="intersection types" data-secondary="described" id="idm45584689672672"/><a data-type="indexterm" data-primary="&amp; (ampersand), intersection types" id="idm45584689671728"/><a data-type="indexterm" data-primary="ampersand (&amp;), intersection types" id="idm45584689671088"/>represent the type of a value that could be one of two or more different types.
Just as JavaScript’s runtime <code>|</code> operator acts as a counterpart to its <code>&amp;</code> operator, TypeScript allows representing a type that is multiple types at the same time: an <code>&amp;</code> <em>intersection type</em>.
Intersection types are typically used with aliased object types to create a new type that combines multiple existing object types.</p>

<p>The following <code>Artwork</code> and <code>Writing</code> types are used to form a combined <code>WrittenArt</code> type that has the properties <code>genre</code>, <code>name</code>, and <code>pages</code>:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">type</code> <code class="nx">Artwork</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">genre</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">Writing</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">pages</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code>

<code class="kr">type</code> <code class="nx">WrittenArt</code> <code class="o">=</code> <code class="nx">Artwork</code> <code class="o">&amp;</code> <code class="nx">Writing</code><code class="p">;</code>
<code class="c1">// Equivalent to:</code>
<code class="c1">// {</code>
<code class="c1">//   genre: string;</code>
<code class="c1">//   name: string;</code>
<code class="c1">//   pages: number;</code>
<code class="c1">// }</code></pre>

<p>Intersection types <a data-type="indexterm" data-primary="types" data-secondary="unions" data-tertiary="combined with intersections" id="idm45584689645264"/><a data-type="indexterm" data-primary="unions" data-secondary="combined with intersections" id="idm45584689626608"/>can be combined with union types, which is sometimes useful to describe discriminated unions in one type.</p>

<p>This <code>ShortPoem</code> type always has an <code>author</code> property, then is also a discriminated union on a <code>type</code> property:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">ShortPoem</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">author</code>: <code class="nx">string</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="p">(</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">kigo</code>: <code class="nx">string</code><code class="p">;</code> <code class="nx">type</code>: <code class="s2">"haiku"</code><code class="p">;</code> <code class="p">}</code>
    <code class="o">|</code> <code class="p">{</code> <code class="nx">meter</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">type</code>: <code class="s2">"villanelle"</code><code class="p">;</code> <code class="p">}</code>
<code class="p">);</code>

<code class="c1">// Ok</code>
<code class="kr">const</code> <code class="nx">morningGlory</code>: <code class="nx">ShortPoem</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="s2">"Fukuda Chiyo-ni"</code><code class="p">,</code>
    <code class="nx">kigo</code><code class="o">:</code> <code class="s2">"Morning Glory"</code><code class="p">,</code>
    <code class="nx">type</code>: <code class="s2">"haiku"</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">oneArt</code>: <code class="nx">ShortPoem</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="s2">"Elizabeth Bishop"</code><code class="p">,</code>
    <code class="nx">type</code>: <code class="s2">"villanelle"</code><code class="p">,</code>
<code class="p">};</code>
<code class="c1">// Error: Type '{ author: string; type: "villanelle"; }'</code>
<code class="c1">// is not assignable to type 'ShortPoem'.</code>
<code class="c1">//   Type '{ author: string; type: "villanelle"; }' is not assignable to</code>
<code class="c1">//   type '{ author: string; } &amp; { meter: number; type: "villanelle"; }'.</code>
<code class="c1">//     Property 'meter' is missing in type '{ author: string; type: "villanelle"; }'</code>
<code class="c1">//     but required in type '{ meter: number; type: "villanelle"; }'.</code></pre>








<section data-type="sect2" data-pdf-bookmark="Dangers of Intersection Types"><div class="sect2" id="idm45584689516640">
<h2>Dangers of Intersection Types</h2>

<p>Intersection <a data-type="indexterm" data-primary="types" data-secondary="intersections" data-tertiary="dangers of" id="type-intersection-danger"/><a data-type="indexterm" data-primary="intersection types" data-secondary="dangers of" id="intersection-danger"/>types are a useful concept, but it’s easy to use them in ways that confuse either yourself or the TypeScript compiler.
I recommend trying to keep code as simple as possible when using them.</p>










<section data-type="sect3" data-pdf-bookmark="Long assignability errors"><div class="sect3" id="idm45584689536592">
<h3>Long assignability errors</h3>

<p>Assignability <a data-type="indexterm" data-primary="errors" data-secondary="assignability errors" data-tertiary="for intersection types" data-tertiary-sortas="intersection types" id="idm45584689535328"/><a data-type="indexterm" data-primary="assignability" data-secondary="errors" data-tertiary="for intersection types" data-tertiary-sortas="intersection types" id="idm45584689469568"/>error messages from TypeScript get much harder to read when you create complex intersection types, such as one combined with a union type.
This will be a common theme with TypeScript’s type system (and typed programming languages in general): the more complex you get, the harder it will be to understand messages from the type checker.</p>

<p>In the case of the previous code snippet’s <code>ShortPoem</code>, it would be much more readable to split the type into a series of aliased object types to allow TypeScript to print those names:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">ShortPoemBase</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">author</code>: <code class="nx">string</code> <code class="p">};</code>
<code class="kr">type</code> <code class="nx">Haiku</code> <code class="o">=</code> <code class="nx">ShortPoemBase</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">kigo</code>: <code class="nx">string</code><code class="p">;</code> <code class="nx">type</code>: <code class="s2">"haiku"</code> <code class="p">};</code>
<code class="kr">type</code> <code class="nx">Villanelle</code> <code class="o">=</code> <code class="nx">ShortPoemBase</code> <code class="o">&amp;</code> <code class="p">{</code> <code class="nx">meter</code>: <code class="nx">number</code><code class="p">;</code> <code class="nx">type</code>: <code class="s2">"villanelle"</code> <code class="p">};</code>
<code class="kr">type</code> <code class="nx">ShortPoem</code> <code class="o">=</code> <code class="nx">Haiku</code> <code class="o">|</code> <code class="nx">Villanelle</code><code class="p">;</code>

<code class="kr">const</code> <code class="nx">oneArt</code>: <code class="nx">ShortPoem</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="s2">"Elizabeth Bishop"</code><code class="p">,</code>
    <code class="nx">type</code>: <code class="s2">"villanelle"</code><code class="p">,</code>
<code class="p">};</code>
<code class="c1">// Type '{ author: string; type: "villanelle"; }'</code>
<code class="c1">// is not assignable to type 'ShortPoem'.</code>
<code class="c1">//   Type '{ author: string; type: "villanelle"; }'</code>
<code class="c1">//   is not assignable to type 'Villanelle'.</code>
<code class="c1">//     Property 'meter' is missing in type</code>
<code class="c1">//     '{ author: string; type: "villanelle"; }'</code>
<code class="c1">//     but required in type '{ meter: number; type: "villanelle"; }'.</code></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="never"><div class="sect3" id="idm45584689441104">
<h3>never</h3>

<p>Intersection types<a data-type="indexterm" data-primary="never type" id="idm45584689405376"/><a data-type="indexterm" data-primary="primitives" data-secondary="never type" id="idm45584689404640"/> are also easy to misuse and create an impossible type with.
Primitive types cannot be joined together as constituents in an intersection type because it’s impossible for a value to be multiple primitives at the same time.
Trying to <code>&amp;</code> two primitive types together will result in the <em>never</em> type, represented by the keyword <code>never</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">NotPossible</code> <code class="o">=</code> <code class="kt">number</code> <code class="o">&amp;</code> <code class="kt">string</code><code class="p">;</code>
<code class="c1">// Type: never</code></pre>

<p>The <code>never</code> keyword and type is what programming languages refer to <a data-type="indexterm" data-primary="bottom types" id="idm45584689351696"/><a data-type="indexterm" data-primary="types" data-secondary="bottom types" id="idm45584689351088"/>as a <em>bottom type</em>, or empty type.
A bottom type is one that can have no possible values and can’t be reached.
No types can be provided to a location whose type is a bottom type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">notNumber</code>: <code class="nx">NotPossible</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="c1">//  ~~~~~~~~~</code>
<code class="c1">// Error: Type 'number' is not assignable to type 'never'.</code>

<code class="kd">let</code> <code class="nx">notString</code>: <code class="nx">never</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
<code class="c1">//  ~~~~~~~~~</code>
<code class="c1">// Error: Type 'string' is not assignable to type 'never'.</code></pre>

<p>Most TypeScript projects rarely—if ever—use the <code>never</code> type.
It comes up once in a while to represent impossible states in code.
Most of the time, though, it’s likely to be a mistake from misusing intersection types.
I’ll cover it more<a data-type="indexterm" data-primary="types" data-secondary="intersections" data-tertiary="dangers of" data-startref="type-intersection-danger" id="idm45584689301552"/><a data-type="indexterm" data-primary="intersection types" data-secondary="dangers of" data-startref="intersection-danger" id="idm45584689300192"/> in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch15.xhtml#type_operations">Chapter 15, “Type Operations”</a>.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584689297232">
<h1>Summary</h1>

<p>In this chapter, you expanded your grasp of the TypeScript type system to be able to work with objects:</p>

<ul>
<li>
<p>How TypeScript interprets types from object type literals</p>
</li>
<li>
<p>Describing object literal types, including nested and optional properties</p>
</li>
<li>
<p>Declaring, inferring, and type narrowing with unions of object literal types</p>
</li>
<li>
<p>Discriminated unions and discriminants</p>
</li>
<li>
<p>Combining object types together with intersection types</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/objects"><em class="hyperlink">https://learningtypescript.com/objects</em></a>.</p>
</div>
<blockquote class="joke">
<p>How does a lawyer declare their TypeScript type?</p>

<p>“I object!”</p></blockquote>
</div></section>







</div></section></div></body></html>