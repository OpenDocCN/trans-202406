- en: Chapter 1\. Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this introductory chapter, we set the scene for the rest of the book by explaining
    a few of the core Kubernetes concepts used for designing and implementing cloud
    native applications. Understanding these new abstractions, and the related principles
    and patterns from this book, is key to building distributed applications that
    can be automatable by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is not a prerequisite for understanding the patterns described
    later. Readers familiar with Kubernetes concepts can skip it and jump straight
    into the pattern category of interest.
  prefs: []
  type: TYPE_NORMAL
- en: The Path to Cloud Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices is among the most popular architectural styles for creating cloud
    native applications. They tackle software complexity through modularization of
    business capabilities and trading development complexity for operational complexity.
    That is why a key prerequisite for becoming successful with microservices is to
    create applications that can be operated at scale through Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the microservices movement, there is a tremendous amount of theory,
    techniques, and supplemental tools for creating microservices from scratch or
    for splitting monoliths into microservices. Most of these practices are based
    on [*Domain-Driven Design*](https://oreil.ly/UoON5) by Eric Evans (Addison-Wesley)
    and the concepts of bounded contexts and aggregates. *Bounded contexts* deal with
    large models by dividing them into different components, and *aggregates* help
    to further group bounded contexts into modules with defined transaction boundaries.
    However, in addition to these business domain considerations, for each distributed
    system—whether it is based on microservices or not—there are also technical concerns
    around its external structure, and runtime coupling. Containers and container
    orchestrators such as Kubernetes bring in new primitives and abstractions to address
    the concerns of distributed applications, and here we discuss the various options
    to consider when putting a distributed system into Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we look at container and platform interactions by treating
    the containers as black boxes. However, we created this section to emphasize the
    importance of what goes into containers. Containers and cloud native platforms
    bring tremendous benefits to your distributed applications, but if all you put
    into containers is rubbish, you will get distributed rubbish at scale. [Figure 1-1](#img-path-cloud-native)
    shows the mixture of the skills required for creating good cloud native applications
    and where Kubernetes patterns fit in.
  prefs: []
  type: TYPE_NORMAL
- en: '![The path to cloud native](assets/kup2_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. The path to cloud native
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At a high level, creating good cloud native applications requires familiarity
    with multiple design techniques:'
  prefs: []
  type: TYPE_NORMAL
- en: At the lowest *code level*, every variable you define, every method you create,
    and every class you decide to instantiate plays a role in the long-term maintenance
    of the application. No matter what container technology and orchestration platform
    you use, the development team and the artifacts they create will have the most
    impact. It is important to grow developers who strive to write clean code, have
    the right number of automated tests, constantly refactor to improve code quality,
    and are guided by Software Craftsmanship principles at heart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-driven design* is about approaching software design from a business
    perspective with the intention of keeping the architecture as close to the real
    world as possible. This approach works best for object-oriented programming languages,
    but there are also other good ways to model and design software for real-world
    problems. A model with the right business and transaction boundaries, easy-to-consume
    interfaces, and rich APIs is the foundation for successful containerization and
    automation later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *hexagonal architecture* and its variations, such as Onion and Clean architectures,
    improve the flexibility and maintainability of applications by decoupling the
    application components and providing standardized interfaces for interacting with
    them. By decoupling the core business logic of a system from the surrounding infrastructure,
    hexagonal architecture makes it easier to port the system to different environments
    or platforms. These architectures complement domain-driven design and help arrange
    application code with distinct boundaries and externalized infrastructure dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *microservices architectural style* and the [twelve-factor app](https://12factor.net)
    methodology very quickly evolved to become the norm for creating distributed applications
    and they provide valuable principles and practices for designing changing distributed
    applications. Applying these principles lets you create implementations that are
    optimized for scale, resiliency, and pace of change, which are common requirements
    for any modern software today.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Containers* were very quickly adopted as the standard way of packaging and
    running distributed applications, whether these are microservices or functions.
    Creating modular, reusable containers that are good cloud native citizens is another
    fundamental prerequisite. *Cloud native* is a term used to describe principles,
    patterns, and tools to automate containerized applications at scale. We use *cloud
    native* interchangeably with *Kubernetes*, which is the most popular open source
    cloud native platform available today.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this book, we are not covering clean code, domain-driven design, hexagonal
    architecture, or microservices. We are focusing only on the patterns and practices
    addressing the concerns of the container orchestration. But for these patterns
    to be effective, your application needs to be designed well from the inside by
    using clean code practices, domain-driven design, hexagonal architecture-like
    isolation of external dependencies, microservices principles, and other relevant
    design techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed Primitives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explain what we mean by new abstractions and primitives, here we compare
    them with the well-known object-oriented programming (OOP), and Java specifically.
    In the OOP universe, we have concepts such as class, object, package, inheritance,
    encapsulation, and polymorphism. Then the Java runtime provides specific features
    and guarantees on how it manages the lifecycle of our objects and the application
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: The Java language and the Java Virtual Machine (JVM) provide local, in-process
    building blocks for creating applications. Kubernetes adds an entirely new dimension
    to this well-known mindset by offering a new set of distributed primitives and
    runtime for building distributed systems that spread across multiple nodes and
    processes. With Kubernetes at hand, we don’t rely only on the local primitives
    to implement the whole application behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We still need to use the object-oriented building blocks to create the components
    of the distributed application, but we can also use Kubernetes primitives for
    some of the application behaviors. [Table 1-1](#table-jvm_k8s) shows how various
    development concepts are realized differently with local and distributed primitives
    in the JVM and Kubernetes, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-1\. Local and distributed primitives
  prefs: []
  type: TYPE_NORMAL
- en: '| Concept | Local primitive | Distributed primitive |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Behavior encapsulation | Class | Container image |'
  prefs: []
  type: TYPE_TB
- en: '| Behavior instance | Object | Container |'
  prefs: []
  type: TYPE_TB
- en: '| Unit of reuse | *.jar* | Container image |'
  prefs: []
  type: TYPE_TB
- en: '| Composition | Class A contains Class B | Sidecar pattern |'
  prefs: []
  type: TYPE_TB
- en: '| Inheritance | Class A extends Class B | A container’s `FROM` parent image
    |'
  prefs: []
  type: TYPE_TB
- en: '| Deployment unit | *.jar*/*.war*/*.ear* | Pod |'
  prefs: []
  type: TYPE_TB
- en: '| Buildtime/Runtime isolation | Module, package, class | Namespace, Pod, container
    |'
  prefs: []
  type: TYPE_TB
- en: '| Initialization preconditions | Constructor | Init container |'
  prefs: []
  type: TYPE_TB
- en: '| Postinitialization trigger | Init-method | `postStart` |'
  prefs: []
  type: TYPE_TB
- en: '| Predestroy trigger | Destroy-method | `preStop` |'
  prefs: []
  type: TYPE_TB
- en: '| Cleanup procedure | `finalize()`, shutdown hook | - |'
  prefs: []
  type: TYPE_TB
- en: '| Asynchronous and parallel execution | `ThreadPoolExecutor`, `ForkJoinPool`
    | Job |'
  prefs: []
  type: TYPE_TB
- en: '| Periodic task | `Timer`, `ScheduledExecutorService` | CronJob |'
  prefs: []
  type: TYPE_TB
- en: '| Background task | Daemon thread | DaemonSet |'
  prefs: []
  type: TYPE_TB
- en: '| Configuration management | `System.getenv()`, `Properties` | ConfigMap, Secret
    |'
  prefs: []
  type: TYPE_TB
- en: The in-process primitives and the distributed primitives have commonalities,
    but they are not directly comparable and replaceable. They operate at different
    abstraction levels and have different preconditions and guarantees. Some primitives
    are supposed to be used together. For example, we still have to use classes to
    create objects and put them into container images. However, some other primitives
    such as CronJob in Kubernetes can completely replace the `ExecutorService` behavior
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see a few distributed abstractions and primitives from Kubernetes
    that are especially interesting for application developers.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Containers* are the building blocks for Kubernetes-based cloud native applications.
    If we make a comparison with OOP and Java, container images are like classes,
    and containers are like objects. The same way we can extend classes to reuse and
    alter behavior, we can have container images that extend other container images
    to reuse and alter behavior. The same way we can do object composition and use
    functionality, we can do container compositions by putting containers into a Pod
    and using collaborating containers.'
  prefs: []
  type: TYPE_NORMAL
- en: If we continue the comparison, Kubernetes would be like the JVM but spread over
    multiple hosts, and it would be responsible for running and managing the containers.
    Init containers would be something like object constructors; DaemonSets would
    be similar to daemon threads that run in the background (like the Java Garbage
    Collector, for example). A Pod would be something similar to an Inversion of Control
    (IoC) context (Spring Framework, for example), where multiple running objects
    share a managed lifecycle and can access one another directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parallel doesn’t go much further, but the point is that containers play
    a fundamental role in Kubernetes, and creating modularized, reusable, single-purpose
    container images is fundamental to the long-term success of any project and even
    the containers’ ecosystem as a whole. Apart from the technical characteristics
    of a container image that provide packaging and isolation, what does a container
    represent, and what is its purpose in the context of a distributed application?
    Here are a few suggestions on how to look at containers:'
  prefs: []
  type: TYPE_NORMAL
- en: A container image is the unit of functionality that addresses a single concern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container image is owned by one team and has its own release cycle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container image is self-contained and defines and carries its runtime dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container image is immutable, and once it is built, it does not change; it
    is configured.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container image defines its resource requirements and external dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container image has well-defined APIs to expose its functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container typically runs as a single Unix process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A container is disposable and safe to scale up or down at any moment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to all these characteristics, a proper container image is modular.
    It is parameterized and created for reuse in the different environments in which
    it is going to run. Having small, modular, and reusable container images leads
    to the creation of more specialized and stable container images in the long term,
    similar to a great reusable library in the programming language world.
  prefs: []
  type: TYPE_NORMAL
- en: Pods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Looking at the characteristics of containers, we can see that they are a perfect
    match for implementing the microservices principles. A container image provides
    a single unit of functionality, belongs to a single team, has an independent release
    cycle, and provides deployment and runtime isolation. Most of the time, one microservice
    corresponds to one container image.
  prefs: []
  type: TYPE_NORMAL
- en: However, most cloud native platforms offer another primitive for managing the
    lifecycle of a group of containers—in Kubernetes, it is called a Pod. A *Pod*
    is an atomic unit of scheduling, deployment, and runtime isolation for a group
    of containers. All containers in a Pod are always scheduled to the same host,
    are deployed and scaled together, and can also share filesystem, networking, and
    process namespaces. This joint lifecycle allows the containers in a Pod to interact
    with one another over the filesystem or through networking via localhost or host
    interprocess communication mechanisms if desired (for performance reasons, for
    example). A Pod also represents a security boundary for an application. While
    it is possible to have containers with varying security parameters in the same
    Pod, typically all containers would have the same access level, network segmentation,
    and identity.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 1-2](#img-pod), at development and build time, a microservice
    corresponds to a container image that one team develops and releases. But at runtime,
    a microservice is represented by a Pod, which is the unit of deployment, placement,
    and scaling. The only way to run a container—whether for scale or migration—is
    through the Pod abstraction. Sometimes a Pod contains more than one container.
    In one such example, a containerized microservice uses a helper container at runtime,
    as [Chapter 16, “Sidecar”](ch16.html#Sidecar), demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Pod as the deployment and management unit](assets/kup2_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. A Pod as the deployment and management unit
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Containers, Pods, and their unique characteristics offer a new set of patterns
    and principles for designing microservices-based applications. We saw some of
    the characteristics of well-designed containers; now let’s look at some characteristics
    of a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: A Pod is the atomic unit of scheduling. That means the scheduler tries to find
    a host that satisfies the requirements of all containers that belong to the Pod
    (we cover some specifics around init containers in [Chapter 15, “Init Container”](ch15.html#InitContainer)).
    If you create a Pod with many containers, the scheduler needs to find a host that
    has enough resources to satisfy all container demands combined. This scheduling
    process is described in [Chapter 6, “Automated Placement”](ch06.html#AutomatedPlacement).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pod ensures colocation of containers. Thanks to the colocation, containers
    in the same Pod have additional means to interact with one another. The most common
    ways of communicating include using a shared local filesystem for exchanging data,
    using the localhost network interface, or using some host interprocess communication
    (IPC) mechanism for high-performance interactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pod has an IP address, name, and port range that are shared by all containers
    belonging to it. That means containers in the same Pod have to be carefully configured
    to avoid port clashes, in the same way that parallel, running Unix processes have
    to take care when sharing the networking space on a host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pod is the atom of Kubernetes where your application lives, but you don’t
    access Pods directly—that is where Services enter the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pods are ephemeral. They come and go at any time for all sorts of reasons (e.g.,
    scaling up and down, failing container health checks, node migrations). A Pod
    IP address is known only after it is scheduled and started on a node. A Pod can
    be rescheduled to a different node if the existing node it is running on is no
    longer healthy. This means the Pod’s network address may change over the life
    of an application, and there is a need for another primitive for discovery and
    load balancing.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where the Kubernetes Services come into play. The Service is another
    simple but powerful Kubernetes abstraction that binds the Service name to an IP
    address and port number permanently. So a Service represents a named entry point
    for accessing an application. In the most common scenario, the Service serves
    as the entry point for a set of Pods, but that might not always be the case. The
    Service is a generic primitive, and it may also point to functionality provided
    outside the Kubernetes cluster. As such, the Service primitive can be used for
    Service discovery and load balancing, and it allows altering implementations and
    scaling without affecting Service consumers. We explain Services in detail in
    [Chapter 13, “Service Discovery”](ch13.html#ServiceDiscovery).
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen that a microservice is a container image at build time but is
    represented by a Pod at runtime. So what is an application that consists of multiple
    microservices? Here, Kubernetes offers two more primitives that can help you define
    the concept of an application: labels and namespaces.'
  prefs: []
  type: TYPE_NORMAL
- en: Before microservices, an application corresponded to a single deployment unit
    with a single versioning scheme and release cycle. There was a single file for
    an application in a *.war*, *.ear*, or some other packaging format. But then,
    applications were split into microservices, which are independently developed,
    released, run, restarted, or scaled. With microservices, the notion of an application
    diminishes, and there are no key artifacts or activities that we have to perform
    at the application level. But if you still need a way to indicate that some independent
    services belong to an application, *labels* can be used. Let’s imagine that we
    have split one monolithic application into three microservices and another one
    into two microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We now have five Pod definitions (and maybe many more Pod instances) that are
    independent of the development and runtime points of view. However, we may still
    need to indicate that the first three Pods represent an application and the other
    two Pods represent another application. Even the Pods may be independent, to provide
    a business value, but they may depend on one another. For example, one Pod may
    contain the containers responsible for the frontend, and the other two Pods are
    responsible for providing the backend functionality. If either of these Pods is
    down, the application is useless from a business point of view. Using label selectors
    gives us the ability to query and identify a set of Pods and manage it as one
    logical unit. [Figure 1-3](#img-label) shows how you can use labels to group the
    parts of a distributed application into specific subsystems.
  prefs: []
  type: TYPE_NORMAL
- en: '![Labels used as an application identity for Pods](assets/kup2_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3\. Labels used as an application identity for Pods
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here are a few examples where labels can be useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Labels are used by ReplicaSets to keep some instances of a specific Pod running.
    That means every Pod definition needs to have a unique combination of labels used
    for scheduling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels are also heavily used by the scheduler. The scheduler uses labels for
    colocating or spreading Pods to the nodes that satisfy the Pods’ requirements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A label can indicate a logical grouping of a set of Pods and give an application
    identity to them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the preceding typical use cases, labels can be used to store
    metadata. It may be difficult to predict what a label could be used for, but it
    is best to have enough labels to describe all important aspects of the Pods. For
    example, having labels to indicate the logical group of an application, the business
    characteristics and criticality, the specific runtime platform dependencies such
    as hardware architecture, or location preferences are all useful.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, these labels can be used by the scheduler for more fine-grained scheduling,
    or the same labels can be used from the command line for managing the matching
    Pods at scale. However, you should not go overboard and add too many labels in
    advance. You can always add them later if needed. Removing labels is much riskier
    as there is no straightforward way of finding out what a label is used for and
    what unintended effect such an action may cause.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another primitive that can also help manage a group of resources is the Kubernetes
    *namespace*. As we have described, a namespace may seem similar to a label, but
    in reality, it is a very different primitive with different characteristics and
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes namespaces allow you to divide a Kubernetes cluster (which is usually
    spread across multiple hosts) into a logical pool of resources. Namespaces provide
    scopes for Kubernetes resources and a mechanism to apply authorizations and other
    policies to a subsection of the cluster. The most common use case of namespaces
    is representing different software environments such as development, testing,
    integration testing, or production. Namespaces can also be used to achieve multitenancy
    and provide isolation for team workspaces, projects, and even specific applications.
    But ultimately, for a greater isolation of certain environments, namespaces are
    not enough, and having separate clusters is common. Typically, there is one nonproduction
    Kubernetes cluster used for some environments (development, testing, and integration
    testing) and another production Kubernetes cluster to represent performance testing
    and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some of the characteristics of namespaces and how they can help
    us in different scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: A namespace is managed as a Kubernetes resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A namespace provides scope for resources such as containers, Pods, Services,
    or ReplicaSets. The names of resources need to be unique within a namespace but
    not across them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, namespaces provide scope for resources, but nothing isolates those
    resources and prevents access from one resource to another. For example, a Pod
    from a development namespace can access another Pod from a production namespace
    as long as the Pod IP address is known. “Network isolation across namespaces for
    creating a lightweight multitenancy solution is described in [Chapter 24, “Network
    Segmentation”](ch24.html#NetworkSegmentation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some other resources, such as namespaces, nodes, and PersistentVolumes, do not
    belong to namespaces and should have unique cluster-wide names.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each Kubernetes Service belongs to a namespace and gets a corresponding Domain
    Name Service (DNS) record that has the namespace in the form of `<service-name>.<namespace-name>.svc.cluster.local`.
    So the namespace name is in the URL of every Service belonging to the given namespace.
    That’s one reason it is vital to name namespaces wisely.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ResourceQuotas provide constraints that limit the aggregated resource consumption
    per namespace. With ResourceQuotas, a cluster administrator can control the number
    of objects per type that are allowed in a namespace. For example, a developer
    namespace may allow only five ConfigMaps, five Secrets, five Services, five ReplicaSets,
    five PersistentVolumeClaims, and ten Pods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ResourceQuotas can also limit the total sum of computing resources we can request
    in a given namespace. For example, in a cluster with a capacity of 32 GB RAM and
    16 cores, it is possible to allocate 16 GB RAM and 8 cores for the production
    namespace, 8 GB RAM and 4 cores for the staging environment, 4 GB RAM and 2 cores
    for development, and the same amount for testing namespaces. The ability to impose
    resource constraints decoupled from the shape and the limits of the underlying
    infrastructure is invaluable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve only briefly covered a few of the main Kubernetes concepts we use in this
    book. However, there are more primitives used by developers on a day-by-day basis.
    For example, if you create a containerized service, there are plenty of Kubernetes
    abstractions you can use to reap all the benefits of Kubernetes. Keep in mind,
    these are only a few of the objects used by application developers to integrate
    a containerized service into Kubernetes. There are plenty of other concepts used
    primarily by cluster administrators for managing Kubernetes. [Figure 1-4](#img-k8s_objects)
    gives an overview of the main Kubernetes resources that are useful for developers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Kubernetes concepts for developers](assets/kup2_0104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-4\. Kubernetes concepts for developers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With time, these new primitives give birth to new ways of solving problems,
    and some of these repetitive solutions become patterns. Throughout this book,
    rather than describing each Kubernetes resource in detail, we will focus on concepts
    that are proven as patterns.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[The Twelve-Factor App](https://oreil.ly/ad0al)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CNCF Cloud Native Definition v1.0](https://oreil.ly/NUiXM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Hexagonal Architecture](https://oreil.ly/rvcDB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Domain-Driven Design: Tackling Complexity in the Heart of Software*](https://oreil.ly/8IHI4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Best Practices for Writing Dockerfiles](https://oreil.ly/Be0g6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Principles of Container-Based Application Design](https://oreil.ly/-x16l)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[General Container Image Guidelines](https://oreil.ly/yyItc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
