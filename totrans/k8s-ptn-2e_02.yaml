- en: Chapter 1\. Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 介绍
- en: In this introductory chapter, we set the scene for the rest of the book by explaining
    a few of the core Kubernetes concepts used for designing and implementing cloud
    native applications. Understanding these new abstractions, and the related principles
    and patterns from this book, is key to building distributed applications that
    can be automatable by Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一介绍性章节中，我们通过解释用于设计和实现云原生应用的一些核心 Kubernetes 概念，为接下来的内容设定了背景。理解这些新的抽象以及来自本书的相关原则和模式对于构建可以由
    Kubernetes 自动化操作的分布式应用至关重要。
- en: This chapter is not a prerequisite for understanding the patterns described
    later. Readers familiar with Kubernetes concepts can skip it and jump straight
    into the pattern category of interest.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不是理解后续描述的模式的先决条件。熟悉 Kubernetes 概念的读者可以跳过本章，直接进入感兴趣的模式类别。
- en: The Path to Cloud Native
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通往云原生的路径
- en: Microservices is among the most popular architectural styles for creating cloud
    native applications. They tackle software complexity through modularization of
    business capabilities and trading development complexity for operational complexity.
    That is why a key prerequisite for becoming successful with microservices is to
    create applications that can be operated at scale through Kubernetes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是创建云原生应用程序的最流行的架构风格之一。它们通过业务能力的模块化来解决软件复杂性，并通过操作复杂性交换开发复杂性。这就是为什么成功使用微服务的关键先决条件是创建可以通过
    Kubernetes 进行规模化操作的应用程序。
- en: As part of the microservices movement, there is a tremendous amount of theory,
    techniques, and supplemental tools for creating microservices from scratch or
    for splitting monoliths into microservices. Most of these practices are based
    on [*Domain-Driven Design*](https://oreil.ly/UoON5) by Eric Evans (Addison-Wesley)
    and the concepts of bounded contexts and aggregates. *Bounded contexts* deal with
    large models by dividing them into different components, and *aggregates* help
    to further group bounded contexts into modules with defined transaction boundaries.
    However, in addition to these business domain considerations, for each distributed
    system—whether it is based on microservices or not—there are also technical concerns
    around its external structure, and runtime coupling. Containers and container
    orchestrators such as Kubernetes bring in new primitives and abstractions to address
    the concerns of distributed applications, and here we discuss the various options
    to consider when putting a distributed system into Kubernetes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 作为微服务运动的一部分，有大量关于从头开始创建微服务或将单体应用拆分为微服务的理论、技术和补充工具。这些实践大多基于[*领域驱动设计*](https://oreil.ly/UoON5)（Eric
    Evans 著，Addison-Wesley 出版）以及有界上下文和聚合的概念。*有界上下文*通过将大型模型划分为不同组件来处理大模型，而*聚合*则有助于将有界上下文进一步分组为具有定义事务边界的模块。然而，除了这些业务域考虑因素外，对于每个分布式系统——无论它是否基于微服务——还存在其外部结构和运行时耦合的技术考虑。容器和容器编排器（如
    Kubernetes）引入了新的原语和抽象，以解决分布式应用的关注点，在此我们讨论了在将分布式系统部署到 Kubernetes 中时需要考虑的各种选项。
- en: Throughout this book, we look at container and platform interactions by treating
    the containers as black boxes. However, we created this section to emphasize the
    importance of what goes into containers. Containers and cloud native platforms
    bring tremendous benefits to your distributed applications, but if all you put
    into containers is rubbish, you will get distributed rubbish at scale. [Figure 1-1](#img-path-cloud-native)
    shows the mixture of the skills required for creating good cloud native applications
    and where Kubernetes patterns fit in.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们通过将容器视为黑盒子来审视容器和平台的交互。然而，我们创建了这一节来强调放入容器的内容的重要性。容器和云原生平台为您的分布式应用程序带来了巨大的好处，但如果您将垃圾放入容器中，您将会在规模上获得分布式垃圾。[图 1-1](#img-path-cloud-native)
    展示了创建优秀云原生应用所需的技能组合及 Kubernetes 模式的适用位置。
- en: '![The path to cloud native](assets/kup2_0101.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![通往云原生的路径](assets/kup2_0101.png)'
- en: Figure 1-1\. The path to cloud native
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 通往云原生的路径
- en: 'At a high level, creating good cloud native applications requires familiarity
    with multiple design techniques:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次上看，创建优秀的云原生应用程序需要熟悉多种设计技术：
- en: At the lowest *code level*, every variable you define, every method you create,
    and every class you decide to instantiate plays a role in the long-term maintenance
    of the application. No matter what container technology and orchestration platform
    you use, the development team and the artifacts they create will have the most
    impact. It is important to grow developers who strive to write clean code, have
    the right number of automated tests, constantly refactor to improve code quality,
    and are guided by Software Craftsmanship principles at heart.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在最低的*代码层面*，你定义的每个变量、创建的每个方法以及决定实例化的每个类，在长期维护应用程序中都起着作用。无论你使用何种容器技术和编排平台，开发团队及其创建的工件将产生最大的影响。培养努力编写清晰代码、具备适量自动化测试、持续重构以提高代码质量，并以软件工艺精神为指导原则的开发人员非常重要。
- en: '*Domain-driven design* is about approaching software design from a business
    perspective with the intention of keeping the architecture as close to the real
    world as possible. This approach works best for object-oriented programming languages,
    but there are also other good ways to model and design software for real-world
    problems. A model with the right business and transaction boundaries, easy-to-consume
    interfaces, and rich APIs is the foundation for successful containerization and
    automation later.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*领域驱动设计*是从业务角度来看待软件设计的方法，旨在尽可能保持架构与现实世界的接近。这种方法最适合面向对象的编程语言，但也有其他良好的方式来为实际问题建模和设计软件。一个具有正确业务和交易边界、易于消费的接口和丰富API的模型，是未来成功容器化和自动化的基础。'
- en: The *hexagonal architecture* and its variations, such as Onion and Clean architectures,
    improve the flexibility and maintainability of applications by decoupling the
    application components and providing standardized interfaces for interacting with
    them. By decoupling the core business logic of a system from the surrounding infrastructure,
    hexagonal architecture makes it easier to port the system to different environments
    or platforms. These architectures complement domain-driven design and help arrange
    application code with distinct boundaries and externalized infrastructure dependencies.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*六边形架构*及其变体，如洋葱和清洁架构，通过解耦应用程序组件并为其交互提供标准化接口，提高了应用程序的灵活性和可维护性。通过将系统的核心业务逻辑与周围基础设施解耦，六边形架构使得将系统移植到不同环境或平台更加容易。这些架构与领域驱动设计相辅相成，并帮助将应用程序代码组织成具有明确边界和外部化基础设施依赖的结构。'
- en: The *microservices architectural style* and the [twelve-factor app](https://12factor.net)
    methodology very quickly evolved to become the norm for creating distributed applications
    and they provide valuable principles and practices for designing changing distributed
    applications. Applying these principles lets you create implementations that are
    optimized for scale, resiliency, and pace of change, which are common requirements
    for any modern software today.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*微服务架构风格*和[十二要素应用](https://12factor.net)方法迅速发展成为创建分布式应用程序的标准，并提供了有价值的设计原则和实践。应用这些原则可以创建出针对规模、弹性和变化速度优化的实现，这些是今天任何现代软件的常见要求。'
- en: '*Containers* were very quickly adopted as the standard way of packaging and
    running distributed applications, whether these are microservices or functions.
    Creating modular, reusable containers that are good cloud native citizens is another
    fundamental prerequisite. *Cloud native* is a term used to describe principles,
    patterns, and tools to automate containerized applications at scale. We use *cloud
    native* interchangeably with *Kubernetes*, which is the most popular open source
    cloud native platform available today.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*容器*迅速成为打包和运行分布式应用程序的标准方式，无论是微服务还是函数。创建模块化、可重用的容器，这些容器在云原生环境中表现良好，是另一个基本前提。*云原生*是一个术语，用于描述自动化容器化应用程序的原则、模式和工具。我们将*云原生*与*Kubernetes*交替使用，后者是当今最流行的开源云原生平台。'
- en: In this book, we are not covering clean code, domain-driven design, hexagonal
    architecture, or microservices. We are focusing only on the patterns and practices
    addressing the concerns of the container orchestration. But for these patterns
    to be effective, your application needs to be designed well from the inside by
    using clean code practices, domain-driven design, hexagonal architecture-like
    isolation of external dependencies, microservices principles, and other relevant
    design techniques.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们不涵盖干净的代码、领域驱动设计、六边形架构或微服务。我们仅专注于解决容器编排关注的模式和实践。但是，为了这些模式能够有效，你的应用程序需要从内部使用干净的代码实践、领域驱动设计、六边形架构等方法，像隔离外部依赖和微服务原则等其他相关设计技术。
- en: Distributed Primitives
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式原语
- en: To explain what we mean by new abstractions and primitives, here we compare
    them with the well-known object-oriented programming (OOP), and Java specifically.
    In the OOP universe, we have concepts such as class, object, package, inheritance,
    encapsulation, and polymorphism. Then the Java runtime provides specific features
    and guarantees on how it manages the lifecycle of our objects and the application
    as a whole.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释我们所说的新抽象和原语，我们在这里将它们与众所周知的面向对象编程（OOP），特别是Java进行比较。在OOP的宇宙中，我们有诸如类、对象、包、继承、封装和多态等概念。然后Java运行时提供了特定的功能和保证，来管理我们的对象及整个应用的生命周期。
- en: The Java language and the Java Virtual Machine (JVM) provide local, in-process
    building blocks for creating applications. Kubernetes adds an entirely new dimension
    to this well-known mindset by offering a new set of distributed primitives and
    runtime for building distributed systems that spread across multiple nodes and
    processes. With Kubernetes at hand, we don’t rely only on the local primitives
    to implement the whole application behavior.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言和Java虚拟机（JVM）提供了本地、进程内的构建块来创建应用程序。Kubernetes通过提供一套新的分布式原语和运行时，为跨多个节点和进程扩展的分布式系统建设增添了全新的维度。有了Kubernetes的支持，我们不仅依赖于本地原语来实现整个应用行为。
- en: We still need to use the object-oriented building blocks to create the components
    of the distributed application, but we can also use Kubernetes primitives for
    some of the application behaviors. [Table 1-1](#table-jvm_k8s) shows how various
    development concepts are realized differently with local and distributed primitives
    in the JVM and Kubernetes, respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要使用面向对象的构建模块来创建分布式应用的组件，但我们也可以使用Kubernetes原语来处理某些应用行为。[Table 1-1](#table-jvm_k8s)
    显示了在JVM和Kubernetes中，本地和分布式原语如何以不同方式实现各种开发概念。
- en: Table 1-1\. Local and distributed primitives
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1-1\. 本地和分布式原语
- en: '| Concept | Local primitive | Distributed primitive |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 本地原语 | 分布式原语 |'
- en: '| --- | --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Behavior encapsulation | Class | Container image |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 行为封装 | 类 | 容器镜像 |'
- en: '| Behavior instance | Object | Container |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 行为实例 | 对象 | 容器 |'
- en: '| Unit of reuse | *.jar* | Container image |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 可重用单元 | *.jar* | 容器镜像 |'
- en: '| Composition | Class A contains Class B | Sidecar pattern |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 组合 | 类 A 包含类 B | Sidecar 模式 |'
- en: '| Inheritance | Class A extends Class B | A container’s `FROM` parent image
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 继承 | 类 A 继承自类 B | 容器的 `FROM` 父镜像 |'
- en: '| Deployment unit | *.jar*/*.war*/*.ear* | Pod |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 部署单元 | *.jar*/*.war*/*.ear* | Pod |'
- en: '| Buildtime/Runtime isolation | Module, package, class | Namespace, Pod, container
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 构建时/运行时隔离 | 模块，包，类 | 命名空间，Pod，容器 |'
- en: '| Initialization preconditions | Constructor | Init container |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 初始化前提条件 | 构造函数 | Init 容器 |'
- en: '| Postinitialization trigger | Init-method | `postStart` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 后初始化触发器 | Init-method | `postStart` |'
- en: '| Predestroy trigger | Destroy-method | `preStop` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 预销毁触发器 | Destroy-method | `preStop` |'
- en: '| Cleanup procedure | `finalize()`, shutdown hook | - |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 清理过程 | `finalize()`, shutdown hook | - |'
- en: '| Asynchronous and parallel execution | `ThreadPoolExecutor`, `ForkJoinPool`
    | Job |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 异步和并行执行 | `ThreadPoolExecutor`, `ForkJoinPool` | Job |'
- en: '| Periodic task | `Timer`, `ScheduledExecutorService` | CronJob |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 定期任务 | `Timer`, `ScheduledExecutorService` | CronJob |'
- en: '| Background task | Daemon thread | DaemonSet |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 后台任务 | 守护线程 | DaemonSet |'
- en: '| Configuration management | `System.getenv()`, `Properties` | ConfigMap, Secret
    |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 配置管理 | `System.getenv()`, `Properties` | ConfigMap, Secret |'
- en: The in-process primitives and the distributed primitives have commonalities,
    but they are not directly comparable and replaceable. They operate at different
    abstraction levels and have different preconditions and guarantees. Some primitives
    are supposed to be used together. For example, we still have to use classes to
    create objects and put them into container images. However, some other primitives
    such as CronJob in Kubernetes can completely replace the `ExecutorService` behavior
    in Java.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 进程内原语和分布式原语有共同点，但不能直接比较和替换。它们在不同的抽象级别上运行，并具有不同的前提条件和保证。有些原语应该一起使用。例如，我们仍然必须使用类来创建对象并将它们放入容器镜像中。但是，一些其他原语如
    Kubernetes 中的 CronJob 可以完全替代 Java 中的`ExecutorService`行为。
- en: Next, let’s see a few distributed abstractions and primitives from Kubernetes
    that are especially interesting for application developers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些 Kubernetes 中特别适合应用开发者的分布式抽象和原语。
- en: Containers
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器
- en: '*Containers* are the building blocks for Kubernetes-based cloud native applications.
    If we make a comparison with OOP and Java, container images are like classes,
    and containers are like objects. The same way we can extend classes to reuse and
    alter behavior, we can have container images that extend other container images
    to reuse and alter behavior. The same way we can do object composition and use
    functionality, we can do container compositions by putting containers into a Pod
    and using collaborating containers.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器*是基于 Kubernetes 的云原生应用的构建模块。如果我们将其与 OOP 和 Java 进行比较，容器镜像就像类，而容器则像对象。就像我们可以扩展类以重用和改变行为一样，我们可以有扩展其他容器镜像以重用和改变行为的容器镜像。同样，我们可以进行对象组合并使用功能，我们可以通过将容器放入
    Pod 并使用协作容器来进行容器组合。'
- en: If we continue the comparison, Kubernetes would be like the JVM but spread over
    multiple hosts, and it would be responsible for running and managing the containers.
    Init containers would be something like object constructors; DaemonSets would
    be similar to daemon threads that run in the background (like the Java Garbage
    Collector, for example). A Pod would be something similar to an Inversion of Control
    (IoC) context (Spring Framework, for example), where multiple running objects
    share a managed lifecycle and can access one another directly.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们继续比较，Kubernetes 就像是分布在多个主机上的 JVM，并且负责运行和管理容器。Init 容器有点类似于对象构造函数；DaemonSet
    则类似于在后台运行的守护线程（例如 Java 垃圾收集器）。一个 Pod 类似于一个控制反转（IoC）上下文（例如 Spring 框架），在这里多个运行中的对象共享管理的生命周期并可以直接访问彼此。
- en: 'The parallel doesn’t go much further, but the point is that containers play
    a fundamental role in Kubernetes, and creating modularized, reusable, single-purpose
    container images is fundamental to the long-term success of any project and even
    the containers’ ecosystem as a whole. Apart from the technical characteristics
    of a container image that provide packaging and isolation, what does a container
    represent, and what is its purpose in the context of a distributed application?
    Here are a few suggestions on how to look at containers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类比不能太深入，但关键是容器在 Kubernetes 中扮演着基础角色，创建模块化、可重用、单一目的的容器镜像对于任何项目的长期成功，甚至容器生态系统作为整体都是至关重要的。除了提供打包和隔离的技术特性外，容器镜像在分布式应用程序中代表什么，以及其在其中的作用是什么？以下是如何看待容器的几点建议：
- en: A container image is the unit of functionality that addresses a single concern.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是解决单一关注点的功能单元。
- en: A container image is owned by one team and has its own release cycle.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像由一个团队拥有并有其自己的发布周期。
- en: A container image is self-contained and defines and carries its runtime dependencies.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是自包含的，定义并携带其运行时依赖项。
- en: A container image is immutable, and once it is built, it does not change; it
    is configured.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是不可变的，一旦构建完成，就不会更改；它是经过配置的。
- en: A container image defines its resource requirements and external dependencies.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像定义其资源需求和外部依赖项。
- en: A container image has well-defined APIs to expose its functionality.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像具有明确定义的 API 以公开其功能。
- en: A container typically runs as a single Unix process.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个容器通常作为单个 Unix 进程运行。
- en: A container is disposable and safe to scale up or down at any moment.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是可丢弃的，可以随时进行扩展或缩减。
- en: In addition to all these characteristics, a proper container image is modular.
    It is parameterized and created for reuse in the different environments in which
    it is going to run. Having small, modular, and reusable container images leads
    to the creation of more specialized and stable container images in the long term,
    similar to a great reusable library in the programming language world.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有这些特性之外，一个合适的容器镜像是模块化的。它是参数化的，并且为在不同环境中运行而重用而创建。拥有小型、模块化和可重用的容器镜像会在长期内创建更专业化和稳定的容器镜像，类似于编程语言世界中优秀的可重用库。
- en: Pods
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod
- en: Looking at the characteristics of containers, we can see that they are a perfect
    match for implementing the microservices principles. A container image provides
    a single unit of functionality, belongs to a single team, has an independent release
    cycle, and provides deployment and runtime isolation. Most of the time, one microservice
    corresponds to one container image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 观察容器的特性，我们可以看到它们非常适合实现微服务原则。一个容器镜像提供了一个功能单元，归属于一个团队，有独立的发布周期，并提供部署和运行时隔离。大多数情况下，一个微服务对应一个容器镜像。
- en: However, most cloud native platforms offer another primitive for managing the
    lifecycle of a group of containers—in Kubernetes, it is called a Pod. A *Pod*
    is an atomic unit of scheduling, deployment, and runtime isolation for a group
    of containers. All containers in a Pod are always scheduled to the same host,
    are deployed and scaled together, and can also share filesystem, networking, and
    process namespaces. This joint lifecycle allows the containers in a Pod to interact
    with one another over the filesystem or through networking via localhost or host
    interprocess communication mechanisms if desired (for performance reasons, for
    example). A Pod also represents a security boundary for an application. While
    it is possible to have containers with varying security parameters in the same
    Pod, typically all containers would have the same access level, network segmentation,
    and identity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数云原生平台提供了另一种原语来管理一组容器的生命周期——在 Kubernetes 中称为 Pod。*Pod* 是一组容器的调度、部署和运行时隔离的原子单位。Pod
    中的所有容器总是被调度到同一台主机上，一起部署和扩展，并且还可以共享文件系统、网络和进程命名空间。这种联合生命周期允许 Pod 中的容器通过文件系统或通过本地主机或宿主机进程通信机制（如果需要，例如出于性能原因）相互交互。对于一个应用程序来说，Pod
    也代表了一个安全边界。虽然可能在同一个 Pod 中有具有不同安全参数的容器，但通常所有容器都具有相同的访问级别、网络分割和身份。
- en: As you can see in [Figure 1-2](#img-pod), at development and build time, a microservice
    corresponds to a container image that one team develops and releases. But at runtime,
    a microservice is represented by a Pod, which is the unit of deployment, placement,
    and scaling. The only way to run a container—whether for scale or migration—is
    through the Pod abstraction. Sometimes a Pod contains more than one container.
    In one such example, a containerized microservice uses a helper container at runtime,
    as [Chapter 16, “Sidecar”](ch16.html#Sidecar), demonstrates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 [图 1-2](#img-pod) 中看到的，在开发和构建时，一个微服务对应于一个团队开发和发布的容器镜像。但在运行时，一个微服务由 Pod
    表示，它是部署、放置和扩展的单位。运行容器的唯一方式——无论是为了扩展还是迁移——都是通过 Pod 抽象。有时一个 Pod 包含多个容器。在这样的例子中，一个容器化的微服务在运行时使用辅助容器，正如
    [第 16 章，“Sidecar”](ch16.html#Sidecar) 中所示。
- en: '![Pod as the deployment and management unit](assets/kup2_0102.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Pod 作为部署和管理单元](assets/kup2_0102.png)'
- en: Figure 1-2\. A Pod as the deployment and management unit
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. Pod 作为部署和管理单元
- en: 'Containers, Pods, and their unique characteristics offer a new set of patterns
    and principles for designing microservices-based applications. We saw some of
    the characteristics of well-designed containers; now let’s look at some characteristics
    of a Pod:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 容器、Pod 及其独特特性为设计基于微服务的应用程序提供了一组新的模式和原则。我们看到了设计良好的容器的一些特性；现在让我们来看看 Pod 的一些特性：
- en: A Pod is the atomic unit of scheduling. That means the scheduler tries to find
    a host that satisfies the requirements of all containers that belong to the Pod
    (we cover some specifics around init containers in [Chapter 15, “Init Container”](ch15.html#InitContainer)).
    If you create a Pod with many containers, the scheduler needs to find a host that
    has enough resources to satisfy all container demands combined. This scheduling
    process is described in [Chapter 6, “Automated Placement”](ch06.html#AutomatedPlacement).
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod 是调度的原子单位。这意味着调度器试图找到一个满足 Pod 所有容器需求的主机（我们在[第 15 章，“初始化容器”](ch15.html#InitContainer)中详细讨论了一些关于初始化容器的具体内容）。如果创建一个具有多个容器的
    Pod，调度器需要找到一个具有足够资源来满足所有容器需求的主机。这个调度过程在[第 6 章，“自动化部署”](ch06.html#AutomatedPlacement)中描述。
- en: A Pod ensures colocation of containers. Thanks to the colocation, containers
    in the same Pod have additional means to interact with one another. The most common
    ways of communicating include using a shared local filesystem for exchanging data,
    using the localhost network interface, or using some host interprocess communication
    (IPC) mechanism for high-performance interactions.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Pod 确保容器的共存。由于共存，同一 Pod 中的容器有额外的方式进行互操作。最常见的通信方式包括使用共享的本地文件系统交换数据，使用本地主机网络接口，或使用一些主机进程间通信（IPC）机制进行高性能互动。
- en: A Pod has an IP address, name, and port range that are shared by all containers
    belonging to it. That means containers in the same Pod have to be carefully configured
    to avoid port clashes, in the same way that parallel, running Unix processes have
    to take care when sharing the networking space on a host.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Pod 具有 IP 地址、名称和端口范围，所有属于它的容器共享这些信息。这意味着同一 Pod 中的容器必须仔细配置，以避免端口冲突，就像并行运行的
    Unix 进程在共享主机的网络空间时需要小心一样。
- en: A Pod is the atom of Kubernetes where your application lives, but you don’t
    access Pods directly—that is where Services enter the scene.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是 Kubernetes 的原子单位，您的应用程序驻留在其中，但您不直接访问 Pod —— 这就是服务进入场景的地方。
- en: Services
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: Pods are ephemeral. They come and go at any time for all sorts of reasons (e.g.,
    scaling up and down, failing container health checks, node migrations). A Pod
    IP address is known only after it is scheduled and started on a node. A Pod can
    be rescheduled to a different node if the existing node it is running on is no
    longer healthy. This means the Pod’s network address may change over the life
    of an application, and there is a need for another primitive for discovery and
    load balancing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是短暂的。它们会因各种原因随时出现和消失（例如，扩展和缩减，失败的容器健康检查，节点迁移）。只有在调度和在节点上启动后，Pod 的 IP 地址才能被知晓。如果运行
    Pod 的节点不再健康，Pod 可以被重新调度到另一个节点。这意味着应用程序的生命周期中可能会改变 Pod 的网络地址，需要另一个基元进行发现和负载均衡。
- en: That’s where the Kubernetes Services come into play. The Service is another
    simple but powerful Kubernetes abstraction that binds the Service name to an IP
    address and port number permanently. So a Service represents a named entry point
    for accessing an application. In the most common scenario, the Service serves
    as the entry point for a set of Pods, but that might not always be the case. The
    Service is a generic primitive, and it may also point to functionality provided
    outside the Kubernetes cluster. As such, the Service primitive can be used for
    Service discovery and load balancing, and it allows altering implementations and
    scaling without affecting Service consumers. We explain Services in detail in
    [Chapter 13, “Service Discovery”](ch13.html#ServiceDiscovery).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Kubernetes 服务发挥作用的地方。服务是 Kubernetes 的另一个简单但强大的抽象，将服务名称永久绑定到 IP 地址和端口号。因此，服务表示访问应用程序的命名入口点。在最常见的情况下，服务作为一组
    Pod 的入口点，但并非总是如此。服务是一个通用的基元，也可以指向 Kubernetes 集群外提供的功能。因此，服务基元可用于服务发现和负载均衡，允许在不影响服务使用者的情况下更改实现和扩展。我们在[第
    13 章，“服务发现”](ch13.html#ServiceDiscovery)中详细解释了服务。
- en: Labels
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: 'We have seen that a microservice is a container image at build time but is
    represented by a Pod at runtime. So what is an application that consists of multiple
    microservices? Here, Kubernetes offers two more primitives that can help you define
    the concept of an application: labels and namespaces.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，微服务是一个在构建时是容器镜像，但在运行时由 Pod 表示的概念。那么由多个微服务组成的应用程序是什么呢？在这里，Kubernetes 提供了另外两个基元，可以帮助您定义应用程序的概念：标签和命名空间。
- en: Before microservices, an application corresponded to a single deployment unit
    with a single versioning scheme and release cycle. There was a single file for
    an application in a *.war*, *.ear*, or some other packaging format. But then,
    applications were split into microservices, which are independently developed,
    released, run, restarted, or scaled. With microservices, the notion of an application
    diminishes, and there are no key artifacts or activities that we have to perform
    at the application level. But if you still need a way to indicate that some independent
    services belong to an application, *labels* can be used. Let’s imagine that we
    have split one monolithic application into three microservices and another one
    into two microservices.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务出现之前，一个应用程序对应于一个单一的部署单元，有一个单一的版本控制方案和发布周期。应用程序在 *.war*、*.ear* 或其他某种打包格式中有一个单一的文件。但后来，应用程序被拆分为微服务，这些微服务可以独立开发、发布、运行、重启或扩展。在微服务中，应用程序的概念减弱了，没有关键的工件或在应用程序级别执行的活动。但是，如果你仍然需要一种方法来指示一些独立服务属于一个应用程序，*标签*
    可以被使用。让我们想象一下，我们已经将一个单体应用程序拆分为三个微服务，另一个拆分为两个微服务。
- en: We now have five Pod definitions (and maybe many more Pod instances) that are
    independent of the development and runtime points of view. However, we may still
    need to indicate that the first three Pods represent an application and the other
    two Pods represent another application. Even the Pods may be independent, to provide
    a business value, but they may depend on one another. For example, one Pod may
    contain the containers responsible for the frontend, and the other two Pods are
    responsible for providing the backend functionality. If either of these Pods is
    down, the application is useless from a business point of view. Using label selectors
    gives us the ability to query and identify a set of Pods and manage it as one
    logical unit. [Figure 1-3](#img-label) shows how you can use labels to group the
    parts of a distributed application into specific subsystems.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有五个 Pod 定义（可能还有许多 Pod 实例），从开发和运行时的角度来看是独立的。然而，我们可能仍然需要指示前三个 Pod 代表一个应用程序，而另外两个
    Pod 代表另一个应用程序。即使 Pod 可能是独立的，为了提供业务价值，它们可能彼此依赖。例如，一个 Pod 可能包含负责前端的容器，另外两个 Pod 则负责提供后端功能。如果其中任何一个
    Pod 停止运行，从业务角度来看，应用程序就变得无用了。使用标签选择器使我们能够查询和识别一组 Pod，并将其作为一个逻辑单元进行管理。[图 1-3](#img-label)
    展示了如何使用标签将分布式应用程序的各部分分组成特定的子系统。
- en: '![Labels used as an application identity for Pods](assets/kup2_0103.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![作为 Pod 应用标识的标签](assets/kup2_0103.png)'
- en: Figure 1-3\. Labels used as an application identity for Pods
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. 作为 Pod 应用标识的标签
- en: 'Here are a few examples where labels can be useful:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是标签可能有用的几个示例：
- en: Labels are used by ReplicaSets to keep some instances of a specific Pod running.
    That means every Pod definition needs to have a unique combination of labels used
    for scheduling.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReplicaSets 使用标签来保持特定 Pod 的一些实例在运行。这意味着每个 Pod 定义都需要一组唯一的标签组合用于调度。
- en: Labels are also heavily used by the scheduler. The scheduler uses labels for
    colocating or spreading Pods to the nodes that satisfy the Pods’ requirements.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签也被调度器广泛使用。调度器使用标签来将 Pod 放置在满足 Pod 要求的节点上，以实现共存或扩展。
- en: A label can indicate a logical grouping of a set of Pods and give an application
    identity to them.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标签可以指示一组 Pod 的逻辑分组，并为它们提供一个应用程序标识。
- en: In addition to the preceding typical use cases, labels can be used to store
    metadata. It may be difficult to predict what a label could be used for, but it
    is best to have enough labels to describe all important aspects of the Pods. For
    example, having labels to indicate the logical group of an application, the business
    characteristics and criticality, the specific runtime platform dependencies such
    as hardware architecture, or location preferences are all useful.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了上述典型用例外，标签还可用于存储元数据。很难预测标签可能用于什么，但最好有足够的标签来描述 Pod 的所有重要方面。例如，有标签用于指示应用程序的逻辑组、业务特性和关键性，特定的运行时平台依赖如硬件架构或位置偏好都是有用的。
- en: Later, these labels can be used by the scheduler for more fine-grained scheduling,
    or the same labels can be used from the command line for managing the matching
    Pods at scale. However, you should not go overboard and add too many labels in
    advance. You can always add them later if needed. Removing labels is much riskier
    as there is no straightforward way of finding out what a label is used for and
    what unintended effect such an action may cause.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，这些标签可以由调度程序用于更精细的调度，或者可以从命令行使用相同的标签来管理规模化的匹配Pod。但是，不要过度添加太多标签。如果需要，您可以随时稍后添加它们。删除标签更为风险，因为没有直接的方法来找出标签用于何处，以及这样的操作可能会导致什么意外效果。
- en: Namespaces
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: Another primitive that can also help manage a group of resources is the Kubernetes
    *namespace*. As we have described, a namespace may seem similar to a label, but
    in reality, it is a very different primitive with different characteristics and
    purposes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以帮助管理一组资源的原始Kubernetes*命名空间*。正如我们所描述的，命名空间可能看起来类似于标签，但实际上，它是一个具有不同特性和目的的非常不同的原语。
- en: Kubernetes namespaces allow you to divide a Kubernetes cluster (which is usually
    spread across multiple hosts) into a logical pool of resources. Namespaces provide
    scopes for Kubernetes resources and a mechanism to apply authorizations and other
    policies to a subsection of the cluster. The most common use case of namespaces
    is representing different software environments such as development, testing,
    integration testing, or production. Namespaces can also be used to achieve multitenancy
    and provide isolation for team workspaces, projects, and even specific applications.
    But ultimately, for a greater isolation of certain environments, namespaces are
    not enough, and having separate clusters is common. Typically, there is one nonproduction
    Kubernetes cluster used for some environments (development, testing, and integration
    testing) and another production Kubernetes cluster to represent performance testing
    and production environments.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes命名空间允许您将一个Kubernetes集群（通常跨多个主机）分成资源的逻辑池。命名空间为Kubernetes资源提供作用域，并提供了在集群子集中应用授权和其他策略的机制。命名空间最常见的用例是表示不同的软件环境，如开发、测试、集成测试或生产环境。命名空间还可以用于实现多租户，并为团队工作空间、项目甚至特定应用程序提供隔离。但是，对于某些环境的更大隔离，命名空间是不够的，通常会使用单独的集群。通常情况下，有一个非生产Kubernetes集群用于某些环境（开发、测试和集成测试），另一个生产Kubernetes集群用于性能测试和生产环境。
- en: 'Let’s look at some of the characteristics of namespaces and how they can help
    us in different scenarios:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看命名空间的一些特性以及它们如何在不同场景中帮助我们：
- en: A namespace is managed as a Kubernetes resource.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间作为一个Kubernetes资源进行管理。
- en: A namespace provides scope for resources such as containers, Pods, Services,
    or ReplicaSets. The names of resources need to be unique within a namespace but
    not across them.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间为诸如容器、Pod、服务或副本集等资源提供作用域。资源的名称在命名空间内必须是唯一的，但在命名空间之间不必如此。
- en: By default, namespaces provide scope for resources, but nothing isolates those
    resources and prevents access from one resource to another. For example, a Pod
    from a development namespace can access another Pod from a production namespace
    as long as the Pod IP address is known. “Network isolation across namespaces for
    creating a lightweight multitenancy solution is described in [Chapter 24, “Network
    Segmentation”](ch24.html#NetworkSegmentation).
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，命名空间为资源提供作用域，但没有任何机制来隔离这些资源，防止一个资源访问另一个资源。例如，来自开发命名空间的Pod可以访问生产命名空间的另一个Pod，只要知道Pod的IP地址。“通过创建轻量级多租户解决方案的命名空间跨命名空间的网络隔离在[第24章，“网络分段”](ch24.html#NetworkSegmentation)中有描述。
- en: Some other resources, such as namespaces, nodes, and PersistentVolumes, do not
    belong to namespaces and should have unique cluster-wide names.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他一些资源，如命名空间、节点和持久卷，不属于命名空间，应具有唯一的整个集群范围名称。
- en: Each Kubernetes Service belongs to a namespace and gets a corresponding Domain
    Name Service (DNS) record that has the namespace in the form of `<service-name>.<namespace-name>.svc.cluster.local`.
    So the namespace name is in the URL of every Service belonging to the given namespace.
    That’s one reason it is vital to name namespaces wisely.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个Kubernetes服务都属于一个命名空间，并且会获得相应的域名服务（DNS）记录，其中命名空间以`<service-name>.<namespace-name>.svc.cluster.local`的形式存在于每个属于给定命名空间的服务的URL中。这就是命名空间在每个服务的URL中至关重要的原因。
- en: ResourceQuotas provide constraints that limit the aggregated resource consumption
    per namespace. With ResourceQuotas, a cluster administrator can control the number
    of objects per type that are allowed in a namespace. For example, a developer
    namespace may allow only five ConfigMaps, five Secrets, five Services, five ReplicaSets,
    five PersistentVolumeClaims, and ten Pods.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ResourceQuotas 提供了限制每个命名空间的聚合资源消耗的约束。通过 ResourceQuotas，集群管理员可以控制命名空间中允许的每种类型对象的数量。例如，开发者命名空间可能只允许五个
    ConfigMaps、五个 Secrets、五个 Services、五个 ReplicaSets、五个 PersistentVolumeClaims 和十个
    Pods。
- en: ResourceQuotas can also limit the total sum of computing resources we can request
    in a given namespace. For example, in a cluster with a capacity of 32 GB RAM and
    16 cores, it is possible to allocate 16 GB RAM and 8 cores for the production
    namespace, 8 GB RAM and 4 cores for the staging environment, 4 GB RAM and 2 cores
    for development, and the same amount for testing namespaces. The ability to impose
    resource constraints decoupled from the shape and the limits of the underlying
    infrastructure is invaluable.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ResourceQuotas 还可以限制我们在给定命名空间中可以请求的计算资源总和。例如，在容量为 32 GB RAM 和 16 个核心的集群中，可以为生产命名空间分配
    16 GB RAM 和 8 个核心，为暂存环境分配 8 GB RAM 和 4 个核心，为开发分配 4 GB RAM 和 2 个核心，测试命名空间也是相同。脱离底层基础设施的形状和限制施加资源约束的能力是无价的。
- en: Discussion
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论
- en: We’ve only briefly covered a few of the main Kubernetes concepts we use in this
    book. However, there are more primitives used by developers on a day-by-day basis.
    For example, if you create a containerized service, there are plenty of Kubernetes
    abstractions you can use to reap all the benefits of Kubernetes. Keep in mind,
    these are only a few of the objects used by application developers to integrate
    a containerized service into Kubernetes. There are plenty of other concepts used
    primarily by cluster administrators for managing Kubernetes. [Figure 1-4](#img-k8s_objects)
    gives an overview of the main Kubernetes resources that are useful for developers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只简要介绍了本书中使用的一些主要 Kubernetes 概念。然而，开发人员日常使用的基元还有更多。例如，如果您创建一个容器化服务，可以使用大量 Kubernetes
    抽象来获取 Kubernetes 的所有优势。请记住，这些只是应用开发人员用于将容器化服务集成到 Kubernetes 中的少数对象。还有许多其他概念，主要由集群管理员用于管理
    Kubernetes。[图 1-4](#img-k8s_objects) 概述了对开发者有用的主要 Kubernetes 资源。
- en: '![Kubernetes concepts for developers](assets/kup2_0104.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![开发者的 Kubernetes 概念](assets/kup2_0104.png)'
- en: Figure 1-4\. Kubernetes concepts for developers
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. 开发者的 Kubernetes 概念
- en: With time, these new primitives give birth to new ways of solving problems,
    and some of these repetitive solutions become patterns. Throughout this book,
    rather than describing each Kubernetes resource in detail, we will focus on concepts
    that are proven as patterns.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，这些新的基元产生了解决问题的新方法，其中一些重复的解决方案变成了模式。在本书中，我们不会详细描述每个 Kubernetes 资源，而是专注于作为模式证明的概念。
- en: More Information
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息
- en: '[The Twelve-Factor App](https://oreil.ly/ad0al)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[十二因素应用](https://oreil.ly/ad0al)'
- en: '[CNCF Cloud Native Definition v1.0](https://oreil.ly/NUiXM)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CNCF 云原生定义 v1.0](https://oreil.ly/NUiXM)'
- en: '[Hexagonal Architecture](https://oreil.ly/rvcDB)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[六边形架构](https://oreil.ly/rvcDB)'
- en: '[*Domain-Driven Design: Tackling Complexity in the Heart of Software*](https://oreil.ly/8IHI4)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*领域驱动设计：软件核心复杂性的挑战*](https://oreil.ly/8IHI4)'
- en: '[Best Practices for Writing Dockerfiles](https://oreil.ly/Be0g6)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[编写 Dockerfile 的最佳实践](https://oreil.ly/Be0g6)'
- en: '[Principles of Container-Based Application Design](https://oreil.ly/-x16l)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[基于容器的应用设计原则](https://oreil.ly/-x16l)'
- en: '[General Container Image Guidelines](https://oreil.ly/yyItc)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通用容器镜像指南](https://oreil.ly/yyItc)'
