["```\nSEC(\"xdp\")   \nint hello(struct xdp_md *ctx) {   \n    bool drop;\n\n    drop = <examine packet and decide whether to drop it>;\n\n    if (drop) \n        return XDP_DROP;\n    else\n        return XDP_PASS;\n}\n```", "```\nstruct `xdp_md` {\n    `__u32` data;\n    `__u32` `data_end`;\n    `__u32` `data_meta`;\n    /* Below access go through struct xdp_rxq_info */\n    `__u32` `ingress_ifindex`; /* rxq->dev->ifindex */\n    `__u32` `rx_queue_index`;  /* rxq->queue_index  */\n\n    `__u32` `egress_ifindex`;  /* txq->dev->ifindex */\n};\n```", "```\nSEC(\"xdp\")\nint ping(struct xdp_md *ctx) {\n   long protocol = lookup_protocol(ctx);\n   if (protocol == 1) // ICMP\n   {\n       bpf_printk(\"Hello ping\");\n   }\n   return XDP_PASS;\n}\n```", "```\nping-26622   [000] d.s11 276880.862408: bpf_trace_printk: Hello ping\nping-26622   [000] d.s11 276880.862459: bpf_trace_printk: Hello ping\nping-26622   [000] d.s11 276881.889575: bpf_trace_printk: Hello ping\nping-26622   [000] d.s11 276881.889676: bpf_trace_printk: Hello ping\nping-26622   [000] d.s11 276882.910777: bpf_trace_printk: Hello ping\nping-26622   [000] d.s11 276882.910930: bpf_trace_printk: Hello ping\n```", "```\nif (protocol == 1) // ICMP\n{\n  bpf_printk(\"Hello ping\");\n  return XDP_DROP;\n}\nreturn XDP_PASS;\n```", "```\nping-26639   [002] d.s11 277050.589356: bpf_trace_printk: Hello ping\nping-26639   [002] d.s11 277051.615329: bpf_trace_printk: Hello ping\nping-26639   [002] d.s11 277052.637708: bpf_trace_printk: Hello ping\n```", "```\nunsigned char lookup_protocol(struct xdp_md *ctx)\n{\n   unsigned char protocol = 0;\n\n   void *data = (void *)(long)ctx->data;                                    ![1](assets/1.png)\n   void *data_end = (void *)(long)ctx->data_end;\n   struct ethhdr *eth = data;                                               ![2](assets/2.png)\n   if (data + sizeof(struct ethhdr) > data_end)                             ![3](assets/3.png)\n       return 0;\n\n   // Check that it's an IP packet\n   if (bpf_ntohs(eth->h_proto) == ETH_P_IP)                                 ![4](assets/4.png)\n   {\n       // Return the protocol of this packet\n       // 1 = ICMP\n       // 6 = TCP\n       // 17 = UDP       \n       struct iphdr *iph = data + sizeof(struct ethhdr);                    ![5](assets/5.png) \n       if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) <= data_end) ![6](assets/6.png)\n           protocol = iph->protocol;                                        ![7](assets/7.png)\n   }\n   return protocol;\n}\n```", "```\nSEC(\"xdp_lb\")\nint xdp_load_balancer(struct xdp_md *ctx)\n{\n    void *data = (void *)(long)ctx->data;           ![1](assets/1.png)\n    void *data_end = (void *)(long)ctx->data_end;\n\n    struct ethhdr *eth = data;\n    if (data + sizeof(struct ethhdr) > data_end)\n        return XDP_ABORTED;\n\n    if (bpf_ntohs(eth->h_proto) != ETH_P_IP)\n        return XDP_PASS;\n\n    struct iphdr *iph = data + sizeof(struct ethhdr);\n    if (data + sizeof(struct ethhdr) + sizeof(struct iphdr) > data_end)\n        return XDP_ABORTED;\n\n    if (iph->protocol != IPPROTO_TCP)               ![2](assets/2.png)\n        return XDP_PASS;\n\n    if (iph->saddr == IP_ADDRESS(CLIENT))           ![3](assets/3.png)\n    {\n        char be = BACKEND_A;                        ![4](assets/4.png)\n        if (bpf_get_prandom_u32() % 2)                \n            be = BACKEND_B;\n\n        iph->daddr = IP_ADDRESS(be);                ![5](assets/5.png)\n        eth->h_dest[5] = be;\n    }\n    else\n    {\n        iph->daddr = IP_ADDRESS(CLIENT);            ![6](assets/6.png)\n        eth->h_dest[5] = CLIENT;\n    }\n    iph->saddr = IP_ADDRESS(LB);                    ![7](assets/7.png)\n    eth->h_source[5] = LB;\n\n    iph->check = iph_csum(iph);                     ![8](assets/8.png)\n\n    return XDP_TX;\n}\n```", "```\nxdp: $(BPF_OBJ)\n   bpftool net detach xdpgeneric dev eth0\n   rm -f /sys/fs/bpf/$(TARGET)\n   bpftool prog load $(BPF_OBJ) /sys/fs/bpf/$(TARGET)\n   bpftool net attach xdpgeneric pinned /sys/fs/bpf/$(TARGET) dev eth0\n```", "```\nint tc_drop(struct __sk_buff *skb) {\n  bpf_trace_printk(\"[tc] dropping packet\\n\");\n  return TC_ACT_SHOT;\n}\n```", "```\nint tc(struct __sk_buff *skb) {\n  void *data = (void *)(long)skb->data;\n  void *data_end = (void *)(long)skb->data_end;\n\n  if (is_icmp_ping_request(data, data_end)) {\n    struct iphdr *iph = data + sizeof(struct ethhdr);\n    struct icmphdr *icmp = data + sizeof(struct ethhdr) + sizeof(struct iphdr);\n    bpf_trace_printk(\"[tc] ICMP request for %x type %x\\n\", iph->daddr,\n                     icmp->type);\n    return TC_ACT_SHOT;\n  }\n  return TC_ACT_OK;\n}\n```", "```\nint tc_pingpong(struct __sk_buff *skb) {\n  void *data = (void *)(long)skb->data;\n  void *data_end = (void *)(long)skb->data_end;\n\n  if (!is_icmp_ping_request(data, data_end)) {      ![1](assets/1.png)\n    return TC_ACT_OK;\n  }\n\n  struct iphdr *iph = data + sizeof(struct ethhdr);\n  struct icmphdr *icmp = data + sizeof(struct ethhdr) + sizeof(struct iphdr);\n\n  swap_mac_addresses(skb);                          ![2](assets/2.png)\n  swap_ip_addresses(skb);\n\n  // Change the type of the ICMP packet to 0 (ICMP Echo Reply) \n  // (was 8 for ICMP Echo request)\n  update_icmp_type(skb, 8, 0);                      ![3](assets/3.png)\n\n  // Redirecting a clone of the modified skb back to the interface \n  // it arrived on\n  bpf_clone_redirect(skb, skb->ifindex, 0);         ![4](assets/4.png)\n\n  return TC_ACT_SHOT;                               ![5](assets/5.png)\n}\n```", "```\nstatic int process_SSL_data(struct pt_regs* ctx, uint64_t id, enum  \nssl_data_event_type type, const char* buf) {\n ...\n  bpf_probe_read(event->data, event->data_len, buf);\n  tls_events.perf_submit(ctx, event, sizeof(struct ssl_data_event_t));\n\n  return 0;\n}\n```", "```\n// Function signature being probed: // int SSL_read(SSL *s, void *buf, int num) int probe_entry_SSL_read(struct pt_regs* ctx) {\n  uint64_t current_pid_tgid = bpf_get_current_pid_tgid(); \n  ...\n\n  const char* buf = (const char*)PT_REGS_PARM2(ctx);         ![1](assets/1.png)\n\n  active_ssl_read_args_map.update(&current_pid_tgid, &buf);  ![2](assets/2.png)\n  return 0;\n}\n```", "```\nint probe_ret_SSL_read(struct pt_regs* ctx) {\n  uint64_t current_pid_tgid = bpf_get_current_pid_tgid();\n\n  ...\n  const char** buf = active_ssl_read_args_map.lookup(&current_pid_tgid);   ![1](assets/1.png)\n  if (buf != NULL) {\n    process_SSL_data(ctx, current_pid_tgid, kSSLRead, *buf);               ![2](assets/2.png)\n  }\n\n  active_ssl_read_args_map.delete(&current_pid_tgid);                      ![3](assets/3.png)\n  return 0;\n}\n```"]