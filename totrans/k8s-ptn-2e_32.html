<html><head></head><body><section data-pdf-bookmark="Chapter 26. Access Control" data-type="chapter" epub:type="chapter"><div class="chapter" id="AccessControl">&#13;
<h1><span class="label">Chapter 26. </span>Access Control</h1>&#13;
&#13;
&#13;
<p>As<a data-primary="Access Control" data-type="indexterm" id="acccont26"/> the world becomes increasingly reliant on cloud infrastructure and containerization, the importance of security can never be understated.&#13;
In 2022, security researchers made a troubling discovery: nearly one million Kubernetes instances were left exposed on the internet due to misconfigurations.<sup><a data-type="noteref" href="ch26.html#idm45902085697664" id="idm45902085697664-marker">1</a></sup>&#13;
Using specialized security scanners, researchers were able to easily access these vulnerable nodes, highlighting the need for stringent access-control measures to protect the Kubernetes control plane.&#13;
But while developers often focus on application-level authorization, they sometimes also need to extend Kubernetes capabilities using the <em>Operator</em> pattern from &#13;
<span class="keep-together"><a data-type="xref" href="ch28.html#Operator">Chapter 28</a></span>.&#13;
In these cases, access control on the Kubernetes platform becomes critical. In this chapter, we delve into the <em>Access Control</em> pattern and explore the concepts of Kubernetes authorization. With the potential risks and consequences at stake, it’s never been more important to ensure the security of your Kubernetes deployment.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902085694064">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>Security<a data-primary="problems" data-secondary="authentication and authorization" data-type="indexterm" id="idm45902085692624"/> is a crucial concern when it comes to operating applications. At the core of security are two essential concepts: authentication and authorization.</p>&#13;
&#13;
<p><em>Authentication</em> focuses on identifying the subject, or <em>who</em>, of an operation and preventing access by unauthorized actors. <em>Authorization</em>, on the other hand, involves determining the permissions for <em>what</em> actions are allowed on resources.</p>&#13;
&#13;
<p>In this chapter, we will discuss authentication briefly, as it is primarily an administrative concern that involves integrating various identity-management techniques with Kubernetes. On the other hand, developers are typically more concerned with authorization, such as who can perform which operations in the cluster and access specific parts of an application.</p>&#13;
&#13;
<p>To secure access to their applications running on top of Kubernetes, developers must consider a range of security strategies, from simple web-based authentication to sophisticated single-sign-on scenarios involving external providers for identity and access management. At the same time, access control to the Kubernetes API server is also an essential concern for applications running on Kubernetes.</p>&#13;
&#13;
<p>Misconfigured access can lead to privilege escalation and deployment failures. High-privilege deployments can access or modify configuration and resources for other deployments, increasing the risk of a cluster compromise.<sup><a data-type="noteref" href="ch26.html#idm45902085687920" id="idm45902085687920-marker">2</a></sup>&#13;
It is important for developers to understand the authorization rules set up by administrators and consider security when making configuration changes and deploying new workloads to meet the organization-wide policies in the Kubernetes cluster.</p>&#13;
&#13;
<p>Furthermore, as more and more Kubernetes-native applications extend the Kubernetes API and offer their services via CustomResourceDefinitions (CRDs) to users, as described in <a data-type="xref" href="ch28.html#operator-classification">“Controller and Operator Classification”</a>, access control becomes even more critical. Kubernetes patterns like <a data-type="xref" data-xrefstyle="chap-num-title" href="ch27.html#Controller">Chapter 27, “Controller”</a>, and <a data-type="xref" data-xrefstyle="chap-num-title" href="ch28.html#Operator">Chapter 28, “Operator”</a>, require high privileges to observe the state of cluster-wide resources, making it crucial to have fine-grained access management and restrictions in place to limit the impact of any potential security breaches.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902085682480">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>Every request to the Kubernetes API server has to pass through three stages—Authentication, Authorization, and Admission Control, as shown in <a data-type="xref" href="#img-accesscontrol-auth-acc-ad">Figure 26-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-accesscontrol-auth-acc-ad">&#13;
<img alt="Stages that need to be passed by a request to the Kubernetes API server" src="assets/kup2_2601.png"/>&#13;
<h6><span class="label">Figure 26-1. </span>A request to the Kubernetes API server must pass through these stages</h6>&#13;
</div></figure>&#13;
&#13;
<p>Once a request passes the Authentication and Authorization stages described in the following sections, a final check is done by Admission controllers before the request is eventually processed. Let’s look at these stages separately.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authentication" data-type="sect2"><div class="sect2" id="accesscontrol-authentication">&#13;
<h2>Authentication</h2>&#13;
&#13;
<p>As<a data-primary="authentication policies" data-type="indexterm" id="idm45902085675568"/> mentioned, we won’t go into too much detail about authentication because it is mainly an administration concern.&#13;
But it’s good to know which options are available, so let’s have a look at the pluggable authentication strategies Kubernetes has to offer that an administrator can configure:</p>&#13;
<dl>&#13;
<dt>Bearer Tokens (OpenID Connect) with OIDC Authenticators</dt>&#13;
<dd>&#13;
<p>OpenID Connect (OIDC) Bearer Tokens can authenticate clients and grant access to the API Server. OIDC is a standard protocol that allows clients to authenticate with an OAuth2 provider that supports OIDC. The client sends the OIDC token in the Authorization header of their request, and the API Server validates the token to allow access. For the entire flow, see the Kubernetes documentation at <a href="https://oreil.ly/ZWXVD">OpenID Connect Tokens</a>.</p>&#13;
</dd>&#13;
<dt>Client certificates (X.509)</dt>&#13;
<dd>&#13;
<p>By using client certificates, the client presents a TLS certificate to the API Server, which is then validated and used to grant access.</p>&#13;
</dd>&#13;
<dt>Authenticating Proxy</dt>&#13;
<dd>&#13;
<p>This configuration option refers to using a custom authenticating proxy to verify the client’s identity before granting access to the API Server. The proxy acts as an intermediary between the client and the API Server and performs authentication and authorization checks before allowing access.</p>&#13;
</dd>&#13;
<dt>Static Token files</dt>&#13;
<dd>&#13;
<p>Tokens can also be stored in standard files and used for authentication. In this approach, the client presents a token to the API Server, which is then used to look up the token file and search for a match.</p>&#13;
</dd>&#13;
<dt>Webhook Token Authentication</dt>&#13;
<dd>&#13;
<p>A webhook can authenticate clients and grant access to the API Server. In this approach, the client sends a token in the Authorization header of their request, and the API Server forwards the token to a configured webhook for validation. The client is granted access to the API Server if the webhook returns a valid response. This technique is similar to the Bearer Token option, except that you can use an external custom service for performing the token validation.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Kubernetes allows you to use multiple authentication plugins simultaneously, such as Bearer Tokens and Client certificates.&#13;
If the Bearer Token strategy authenticates a request, Kubernetes won’t check the Client certificates, and vice versa. Unfortunately, the order in which these strategies are evaluated is not fixed, so it’s impossible to know which one will be checked first.&#13;
When evaluating the strategies, the process will stop after one is successful, and Kubernetes will forward the request to the next stage.</p>&#13;
&#13;
<p>After authentication, the authorization process will begin.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authorization" data-type="sect2"><div class="sect2" id="accesscontrol-authorization">&#13;
<h2>Authorization</h2>&#13;
&#13;
<p>Kubernetes<a data-primary="authorization" data-type="indexterm" id="idm45902085663200"/> provides RBAC as a standard way to manage access to the system. RBAC allows developers to control and execute actions in a fine-grained manner. The authorization plugin in Kubernetes also provides easy pluggability, allowing users to switch between the default RBAC and other models, such as attribute-based access control (ABAC), webhooks, or delegation to a custom authority.</p>&#13;
&#13;
<p>The <a href="https://oreil.ly/xNBK8">ABAC-based approach</a> requires a file containing policies in a JSON per-line format. However, this approach requires the server to be reloaded for any changes, which can be a disadvantage.&#13;
This static nature is one of the reasons ABAC-based authorization is used only in some cases.</p>&#13;
&#13;
<p>Instead, nearly every Kubernetes cluster uses the default RBAC-based access control, which we describe in great detail in <a data-type="xref" href="#accesscontrol-rbac">“Role-Based Access Control”</a>.</p>&#13;
&#13;
<p>Before we focus on authorization in the rest of this chapter, let’s quickly look at the last stage performed by admission controllers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission Controllers" data-type="sect2"><div class="sect2" id="idm45902085658880">&#13;
<h2>Admission Controllers</h2>&#13;
&#13;
<p>Admission controllers<a data-primary="Admission controller plugins" data-type="indexterm" id="idm45902085657376"/> are a feature of the Kubernetes API server that allows you to intercept requests to the API server and take additional actions based on those requests. For example, you can use them to enforce policies, perform validations, and modify incoming resources.</p>&#13;
&#13;
<p>Kubernetes uses Admission controller plugins for implementing various functions. The functionality ranges from setting default values on specific resources (like the default storage class on persistent volumes), to validations (like the allowed resource limits for Pods), by calling external web hooks.</p>&#13;
&#13;
<p>These external webhooks can be configured with dedicated resources and are used for validation (ValidatingWebhookConfiguration) and updating (MutatingWebhookConfiguration) API resources.&#13;
The details of configuring such webhooks are explained in detail in the Kubernetes documentation <a href="https://oreil.ly/JEBu6">“Dynamic Admission Control”</a>.</p>&#13;
&#13;
<p>We won’t go into more detail here as Admission controllers are mostly an administrative concept, and many other good resources describe Admission controllers in particular (see <a data-type="xref" href="#accesscontrol-more-information">“More Information”</a> for some references).</p>&#13;
&#13;
<p>Instead, for the remainder of the chapter, we will focus on the authorization aspect and how we can configure a fine-grained permission model for securing access to the Kubernetes API server.</p>&#13;
&#13;
<p>As mentioned, authentication has two fundamental parts and authorization: the <em>who</em>, represented by a subject that can be either a human person or a workload identity, and the <em>what</em>, representing the actions those subjects can trigger at the Kubernetes API server. In the next section, we discuss the who before diving into the details of the <em>what</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Subject" data-type="sect2"><div class="sect2" id="accesscontrol-subject">&#13;
<h2>Subject</h2>&#13;
&#13;
<p><a data-primary="subjects" data-type="indexterm" id="idm45902085649280"/>A <em>subject</em> is all about the <em>who</em>, the identity associated with a request to the Kubernetes API server.&#13;
In Kubernetes, there are two kinds of subjects, as shown in <a data-type="xref" href="#img-accesscontrol-subject">Figure 26-2</a>: human<a data-primary="users" data-type="indexterm" id="idm45902085646560"/> <em>users</em> and <em>service accounts</em> that represent the workload identity of Pods.</p>&#13;
&#13;
<figure><div class="figure" id="img-accesscontrol-subject">&#13;
<img alt="Subject requests to API Server" src="assets/kup2_2602.png"/>&#13;
<h6><span class="label">Figure 26-2. </span>Subject (user or service account) requests to API Server</h6>&#13;
</div></figure>&#13;
&#13;
<p>Human users and ServiceAccounts can be separately grouped in <em>user groups</em> and <em>service account groups</em>, respectively.&#13;
Those groups can act as a single subject in which all members of the group share the same permission model.&#13;
We will talk about groups later in this chapter, but first, let’s look closely at how human users are represented in the Kubernetes API.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Users" data-type="sect3"><div class="sect3" id="accesscontrol-users">&#13;
<h3>Users</h3>&#13;
&#13;
<p>Unlike many other entities in Kubernetes, human users are not defined as explicit resources in the Kubernetes API.&#13;
This design decision implies that you can’t manage users via an API call. The authentication and mapping to a user subject happens outside the usual Kubernetes API machinery by external user management.</p>&#13;
&#13;
<p>As we have seen, Kubernetes supports many ways of authenticating an external user.&#13;
Each component knows how to extract the subject information after successful authentication.&#13;
Although this mechanism is different for each authentication &#13;
<span class="keep-together">component,</span> they will eventually create the same user representation and add it to the actual API request to verify by later stages, as shown in <a data-type="xref" href="#ex-access-control-uid">Example 26-1</a>.</p>&#13;
<div data-type="example" id="ex-access-control-uid">&#13;
<h5><span class="label">Example 26-1. </span>Representation of an external user after successful authentication</h5>&#13;
&#13;
<pre data-type="programlisting">alice,4bc01e30-406b-4514,"system:authenticated,developers","scopes:openid"</pre></div>&#13;
&#13;
<p>This comma-separated list is a representation of the user and contains the following parts:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The username (<code>alice</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>A unique user id (UID) (<code>4bc01e30-406b-4514</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>A list of groups that this user belongs to (<code>system:authenticated,developers</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Additional information as comma-separated key-value pairs (<code>scopes:openid</code>)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This information is evaluated by the Authorization plugin against the authorization rules associated with the user or via its membership to a user group.&#13;
In <a data-type="xref" href="#ex-access-control-uid">Example 26-1</a>, a user with the username <code>alice</code> has the default access associated with the group <code>system:authenticated</code> and the group <code>developers</code>. The extra information <code>scope:openid</code> indicates OIDC is being used to verify the user’s identity.</p>&#13;
&#13;
<p>Certain usernames are reserved for internal Kubernetes use and are distinguished by the special prefix <code>system:</code>. For example, the username <code>system:anonymous</code> represents anonymous requests to the Kubernetes API server. It is recommended to avoid creating your own users or groups with the <code>system:</code> prefix to avoid conflicts. <a data-type="xref" href="#table-accesscontrol-default-users">Table 26-1</a> lists the default usernames in Kubernetes that are used when internal Kubernetes components communicate to one another.</p>&#13;
<table id="table-accesscontrol-default-users" style="width: 100%">&#13;
<caption><span class="label">Table 26-1. </span>Default usernames in Kubernetes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Username</th>&#13;
<th>Purpose</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>system:anonymous</code></p></td>&#13;
<td><p>Represents anonymous requests to the Kubernetes API server</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>system:apiserver</code></p></td>&#13;
<td><p>Represents the API server itself</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>system:kube-proxy</code></p></td>&#13;
<td><p>Represents process identity of the kube-proxy service</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>system:kube-controller-manager</code></p></td>&#13;
<td><p>Represents the user agent of the controller manager</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>system:kube-scheduler</code></p></td>&#13;
<td><p>Represents the user of the scheduler</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>While the management and authentication of external users can vary depending on the specific setup of a Kubernetes cluster, the management of workload identities for Pods is a standardized part of the Kubernetes API and is consistent across all clusters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Service accounts" data-type="sect3"><div class="sect3" id="accesscontrol-service-accounts">&#13;
<h3>Service accounts</h3>&#13;
&#13;
<p>Service accounts<a data-primary="service accounts" data-type="indexterm" id="idm45902085607376"/> in Kubernetes represent nonhuman actors within the cluster and are used as workload identities.&#13;
They are associated with Pods and allow running processes inside a Pod to communicate with the Kubernetes API Server.&#13;
In contrast to the many ways that Kubernetes can authenticate human users, service accounts always use an <a href="https://oreil.ly/0fhR8">OpenID Connect handshake</a> and JSON Web Tokens to prove their identity.</p>&#13;
&#13;
<p>Service accounts in Kubernetes are authenticated by the API server using a username in the following format: <code>system:serviceaccount:&lt;namespace&gt;:&lt;name&gt;</code>. For example, if you have a service account, <code>random-sa</code>, in the <code>default</code> namespace, the service account’s username would be <code>system:serviceaccount:default:random-sa</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="accesscontrol-token">&#13;
<h1>JSON Web Tokens in Kubernetes</h1>&#13;
<p><em>JSON Web Tokens</em> (JWTs)<a data-primary="JSON Web Tokens (JWTs)" data-type="indexterm" id="idm45902085601168"/> are digitally signed tokens that carry a payload. They consist of a header, payload, and signature and are represented as a sequence of Base64 URL-encoded parts separated by periods. Tools like <a href="https://jwt.io">jwt.io</a> can decode, validate, and inspect JWTs.</p>&#13;
&#13;
<p>In the context of Kubernetes, JWTs are used as<a data-primary="Bearer Tokens" data-type="indexterm" id="idm45902085599104"/> Bearer Tokens in the <code>Authorization</code> HTTP header of API requests to specify the identity of the workload making the request and additional information, such as the expiration time or issuer. The Kubernetes API server verifies the signature of the JWT by comparing it with a public key published in a JSON Web Key Set (JWKS). This process is governed by the JSON Web Key (JWK) specification, which defines the cryptographic algorithms used in the verification process in <a href="https://oreil.ly/jz0Aj">RFC 7517</a>.</p>&#13;
&#13;
<p>The tokens issued by Kubernetes contain helpful information in the payload of the JWT, such as the issuer of the token, its expiration time, all the user information described in <a data-type="xref" href="#ex-access-control-uid">Example 26-1</a>, and the associated service accounts (if any).</p>&#13;
</div></aside>&#13;
&#13;
<p>A ServiceAccount is a standard Kubernetes resource, as shown in <a data-type="xref" href="#ex-accesscontrol-yaml-sa">Example 26-2</a>.</p>&#13;
<div data-type="example" id="ex-accesscontrol-yaml-sa">&#13;
<h5><span class="label">Example 26-2. </span>ServiceAccount definition</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-sa</code><code class="w">                   </code><a class="co" href="#callout_access_control_CO1-1" id="co_access_control_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w">&#13;
</code><code class="nt">automountServiceAccountToken</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"> </code><a class="co" href="#callout_access_control_CO1-2" id="co_access_control_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="p">...</code></pre>&#13;
<dl class="calloutlist less_space pagebreak-before">&#13;
<dt><a class="co" href="#co_access_control_CO1-1" id="callout_access_control_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Name of the service account.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO1-2" id="callout_access_control_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Flag indicating whether the service account token should be mounted&#13;
by default into a Pod. The default is set to <code>true</code>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>A ServiceAccount has a simple structure and serves all identity-related information needed for a Pod when talking with the Kubernetes API server.&#13;
Every namespace has a default ServiceAccount with the name <code>default</code> used to identify any Pod that does not define an associated ServiceAccount.</p>&#13;
&#13;
<p>Each ServiceAccount has a JWT associated with it that is fully managed by the Kubernetes backend.&#13;
A Pod’s associated ServiceAccount’s token is automatically mounted into the filesystem of each Pod.&#13;
<a data-type="xref" href="#ex-accesscontrol-pod-spec">Example 26-3</a> shows the relevant part of a Pod specification that Kubernetes has automatically added for every Pod created.</p>&#13;
<div data-type="example" id="ex-accesscontrol-pod-spec">&#13;
<h5><span class="label">Example 26-3. </span>ServiceAccount token mounted as a file for a Pod</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w">      </code><a class="co" href="#callout_access_control_CO2-1" id="co_access_control_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/run/secrets/kubernetes.io/serviceaccount</code><code class="w"> </code><a class="co" href="#callout_access_control_CO2-2" id="co_access_control_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kube-api-access-vzfp7</code><code class="w">  </code><a class="co" href="#callout_access_control_CO2-3" id="co_access_control_CO2-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">&#13;
</code><code class="w">  </code><code class="p">...</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kube-api-access-vzfp7</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">projected</code><code class="p">:</code><code class="w">                     </code><a class="co" href="#callout_access_control_CO2-4" id="co_access_control_CO2-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">defaultMode</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">420</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">sources</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">serviceAccountToken</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">expirationSeconds</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3600</code><code class="w">  </code><a class="co" href="#callout_access_control_CO2-5" id="co_access_control_CO2-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">token</code><code class="w">              </code><a class="co" href="#callout_access_control_CO2-6" id="co_access_control_CO2-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p">...</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_access_control_CO2-1" id="callout_access_control_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>serviceAccountName</code> to set the name of the service account&#13;
(<code>serviceAccount</code> is a deprecated alias for <code>serviceAccountName</code>).</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO2-2" id="callout_access_control_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><em>/var/run/secrets/kubernetes.io/serviceaccount</em> is the directory under which the service account token is mounted.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO2-3" id="callout_access_control_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Kubernetes assigns a random Pod-unique name to the auto-generated volume.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO2-4" id="callout_access_control_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>A projected volume injects the ServiceAccount token directly into the filesystem.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO2-5" id="callout_access_control_CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Expiration time of the token in seconds. After this time, the token expires, and the mounted token file is updated with a new token.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO2-6" id="callout_access_control_CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>The name of the file that will contain the token.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>To view the mounted token, we can execute a <code>cat</code> on the mounted file in the running Pod, as shown in <a data-type="xref" href="#ex-accesscontrol-cat-token">Example 26-4</a>.</p>&#13;
<div data-type="example" id="ex-accesscontrol-cat-token">&#13;
<h5><span class="label">Example 26-4. </span>Print out the service account JWT (output is shortened)</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">$<code class="w"> </code>kubectl<code class="w"> </code><code class="nb">exec</code><code class="w"> </code>random<code class="w"> </code>--<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">     </code>cat<code class="w"> </code>/var/run/secrets/kubernetes.io/serviceaccount/token<code class="w"/>&#13;
eyJhbGciOiJSUzI1NiIsImtpZCI6InVHYV9NZEVYOEZteUNUZFl...<code class="w"/></pre></div>&#13;
&#13;
<p>In <a data-type="xref" href="#ex-accesscontrol-pod-spec">Example 26-3</a>, the token is mounted into the Pod as a projected volume.&#13;
Projected volumes allow you to merge multiple volume sources, such as Secret and ConfigMap volumes (described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#ConfigurationResource">Chapter 20, “Configuration Resource”</a>), into a single directory.&#13;
With this volume type, the ServiceAccount token can also be directly mapped into the Pod’s filesystem using a <code>serviceAccountToken</code> subtype.&#13;
This method has several benefits, including reducing the attack surface by eliminating the need for an intermediate representation of the token and by providing the ability to set an expiration time for the token, which the Kubernetes token controller will rotate after it expires.&#13;
Furthermore, the token injected into the Pod will be valid only for the duration of the Pod’s existence, further reducing the risk of unauthorized inspection of the service account’s token.</p>&#13;
&#13;
<p>Before Kubernetes 1.24, Secrets were used to represent these tokens and were mounted directly with a <code>secret</code> volume type, which had the disadvantage of long lifetimes and lack of rotation.&#13;
Thanks to the new projected volume type, the token is available only to the Pod and is not exposed as an additional resource, which reduces the attack surface.&#13;
You can still create a Secret manually to contain a ServiceAccount’s token, as demonstrated in <a data-type="xref" href="#ex-accesscontrol-token-secret">Example 26-5</a>.</p>&#13;
<div data-type="example" id="ex-accesscontrol-token-secret">&#13;
<h5><span class="label">Example 26-5. </span>Create a Secret for ServiceAccount <code>random-sa</code></h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Secret</code><code class="w">&#13;
</code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kubernetes.io/service-account-token</code><code class="w">           </code><a class="co" href="#callout_access_control_CO3-1" id="co_access_control_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-sa</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">kubernetes.io/service-account.name</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">random-sa</code><code class="s">"</code><code class="w"> </code><a class="co" href="#callout_access_control_CO3-2" id="co_access_control_CO3-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_access_control_CO3-1" id="callout_access_control_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Special type to indicate that this Secret is about holding a ServiceAccount.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO3-2" id="callout_access_control_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Reference to ServiceAccount, whose token should be added.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Kubernetes will fill in the token and the public key for validation into the secret.&#13;
Also, the lifecycle of this Secret is now bound to the ServiceAccount itself.&#13;
If you delete the ServiceAccount, Kubernetes will also delete this secret.</p>&#13;
&#13;
<p>The ServiceAccount resource has two additional fields for specifying credentials for pulling container images and defining the secrets allowed to be mounted:</p>&#13;
<dl>&#13;
<dt>Image pull secrets</dt>&#13;
<dd>&#13;
<p>Image pull secrets<a data-primary="image pull secrets" data-type="indexterm" id="idm45902085251120"/> allow a workload to authenticate with a private registry when pulling images.&#13;
Typically, you would need to manually specify the pull secrets as part of the Pod specification in the fields <code>.spec.imagePullSecrets</code>.&#13;
However, Kubernetes provides a shortcut by allowing you to attach a pull secret directly to a ServiceAccount in the top-level field <code>imagePullSecrets</code>.&#13;
Every Pod associated with the ServiceAccount will automatically have the pull secrets injected into its specification when it is created.&#13;
This automation eliminates the need to manually include the image pull secrets in the Pod specification every time a new Pod is created in the namespace, reducing the manual effort required.</p>&#13;
</dd>&#13;
<dt>Mountable secrets</dt>&#13;
<dd>&#13;
<p>The<a data-primary="mountable secrets" data-type="indexterm" id="idm45902085215856"/> <code>secrets</code> field in the ServiceAccount resource allows you to specify which secrets a Pod associated with the ServiceAccount can mount. You can enable this restriction by adding the <code>kubernetes.io/enforce-mountable-secrets</code> annotation to the ServiceAccount.&#13;
If this annotation is set to <code>true</code>, only the Secrets listed will be allowed to be mounted by Pods associated with the ServiceAccount.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Groups" data-type="sect3"><div class="sect3" id="accesscontrol-groups">&#13;
<h3>Groups</h3>&#13;
&#13;
<p>Both user and service accounts<a data-primary="groups" data-type="indexterm" id="idm45902085211520"/> in Kubernetes can belong to one or more groups. Groups are attached to requests by the authentication system and are used to grant permissions to all group members. As seen in <a data-type="xref" href="#ex-access-control-uid">Example 26-1</a>, group names are plain strings that represent the group name.</p>&#13;
&#13;
<p>As mentioned earlier, groups can be freely defined and managed by the identity provider to create groups of subjects with the same permission model. A set of predefined groups in Kubernetes are also implicitly defined and have a <code>system:</code> prefix in their name. These predefined groups are listed in <a data-type="xref" href="#table-accesscontrol-default-groups">Table 26-2</a>.</p>&#13;
&#13;
<p>We will see how group names can be used in a RoleBinding to grant permissions to all group members in <a data-type="xref" href="#accesscontrol-rolebinding">“RoleBinding”</a>.</p>&#13;
<table id="table-accesscontrol-default-groups">&#13;
<caption><span class="label">Table 26-2. </span>System groups in Kubernetes</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Group</th>&#13;
<th>Purpose</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>system:unauthenticated</code></p></td>&#13;
<td><p>Group assigned to every unauthenticated request</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>system:authenticated</code></p></td>&#13;
<td><p>Group assigned to an authenticated user</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>system:masters</code></p></td>&#13;
<td><p>Group whose members have unrestricted access to the Kubernetes API server</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>system:serviceaccounts</code></p></td>&#13;
<td><p>Group with all ServiceAccounts of the cluster</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>system:serviceaccounts:&lt;namespace&gt;</code></p></td>&#13;
<td><p>Group with all ServiceAccounts of this namespace</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Now that you have a clear understanding of users, ServiceAccounts, and groups, let’s examine how these subjects can be associated with Roles that define the actions they are allowed to perform against the Kubernetes API server.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Role-Based Access Control" data-type="sect2"><div class="sect2" id="accesscontrol-rbac">&#13;
<h2>Role-Based Access Control</h2>&#13;
&#13;
<p>In Kubernetes, Roles<a data-primary="RBAC (role-based access control)" data-type="indexterm" id="RBAC26"/><a data-primary="role-based access control (RBAC)" data-type="indexterm" id="rolebased26"/> define the specific actions that a subject can perform on particular resources.&#13;
You can then assign these Roles to subjects, such as users or service accounts, as described in <a data-type="xref" href="#accesscontrol-subject">“Subject”</a>, through the use of RoleBindings.&#13;
Roles and RoleBindings are Kubernetes resources that can be created and managed like any other resource. They are tied to a specific namespace and apply to its resources.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-accesscontrol-rbac">Figure 26-3</a> illustrates the relationship between subjects, Roles, and RoleBindings.</p>&#13;
&#13;
<figure><div class="figure" id="img-accesscontrol-rbac">&#13;
<img alt="Relationship between Role, Rolebinding and subjects" src="assets/kup2_2603.png"/>&#13;
<h6><span class="label">Figure 26-3. </span>Relationship between Role, RoleBinding, and subjects</h6>&#13;
</div></figure>&#13;
&#13;
<p>In Kubernetes RBAC, it is important to understand that there is a many-to-many relationship between subjects and Roles.&#13;
This means that a single subject can have multiple Roles, and a single Role can be applied to multiple subjects.&#13;
The relationship between a subject and a Role is established using a RoleBinding, which contains references to a list of subjects and a specific Role.</p>&#13;
&#13;
<p>The RBAC concepts are best explained with a concrete example. <a data-type="xref" href="#ex-accesscontrol-role">Example 26-6</a> shows the definition of a Role in Kubernetes.</p>&#13;
<div data-type="example" id="ex-accesscontrol-role">&#13;
<h5><span class="label">Example 26-6. </span>Role for allowing access to core resources</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Role</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">developer-ro</code><code class="w"> </code><a class="co" href="#callout_access_control_CO4-1" id="co_access_control_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"> </code><a class="co" href="#callout_access_control_CO4-2" id="co_access_control_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="nt">rules</code><code class="p">:</code><code class="w">&#13;
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">"</code><code class="w">               </code><a class="co" href="#callout_access_control_CO4-3" id="co_access_control_CO4-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w">         </code><a class="co" href="#callout_access_control_CO4-4" id="co_access_control_CO4-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">pods</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">services</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w">             </code><a class="co" href="#callout_access_control_CO4-5" id="co_access_control_CO4-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">get</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">list</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">watch</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_access_control_CO4-1" id="callout_access_control_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The name of the Role, which is used to reference it.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO4-2" id="callout_access_control_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Namespace to which this Role applies. Roles are always connected to a &#13;
<span class="keep-together">namespace.</span></p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO4-3" id="callout_access_control_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>An empty string indicates the core API group.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO4-4" id="callout_access_control_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>List of Kubernetes core resources to which the rule applies.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO4-5" id="callout_access_control_CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>API actions are represented by verbs allowed by subjects associated with this Role.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The Role defined in <a data-type="xref" href="#ex-accesscontrol-role">Example 26-6</a> specifies that any user or service account associated with this Role can perform read-only operations on Pods and Services.</p>&#13;
&#13;
<p>This Role can then be referenced in the RoleBinding shown in <a data-type="xref" href="#ex-accesscontrol-rolebinding">Example 26-7</a>  to grant access to both the user, <code>alice</code>, and the ServiceAccount, <code>contractor</code>.</p>&#13;
<div data-type="example" id="ex-accesscontrol-rolebinding">&#13;
<h5><span class="label">Example 26-7. </span>RoleBinding specification</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RoleBinding</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">dev-rolebinding</code><code class="w">&#13;
</code><code class="nt">subjects</code><code class="p">:</code><code class="w">               </code><a class="co" href="#callout_access_control_CO5-1" id="co_access_control_CO5-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">User</code><code class="w">            </code><a class="co" href="#callout_access_control_CO5-2" id="co_access_control_CO5-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">alice</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">rbac.authorization.k8s.io</code><code class="s">"</code><code class="w">&#13;
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w">  </code><a class="co" href="#callout_access_control_CO5-3" id="co_access_control_CO5-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">contractor</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">"</code><code class="w">&#13;
</code><code class="nt">roleRef</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Role</code><code class="w">            </code><a class="co" href="#callout_access_control_CO5-4" id="co_access_control_CO5-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">developer-ro</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_access_control_CO5-1" id="callout_access_control_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>List of subjects to connect to a Role.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO5-2" id="callout_access_control_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Human user reference for a user named <code>alice</code>.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO5-3" id="callout_access_control_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Service account with name <code>contractor</code>.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO5-4" id="callout_access_control_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Reference to the Role with the name <code>developer-ro</code> that has been defined in <a data-type="xref" href="#ex-accesscontrol-role">Example 26-6</a>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Now that you have a basic understanding of the relationship between subjects, Roles, and RoleBindings, let’s delve deeper into the specifics of Roles and RoleBindings.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Role" data-type="sect3"><div class="sect3" id="accesscontrol-role">&#13;
<h3>Role</h3>&#13;
&#13;
<p>Roles in Kubernetes allow you to define a set of permitted actions for a group of Kubernetes resources or subresources. Typical activities on&#13;
Kubernetes resources include the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Getting Pods</p>&#13;
</li>&#13;
<li>&#13;
<p>Deleting Secrets</p>&#13;
</li>&#13;
<li>&#13;
<p>Updating ConfigMaps</p>&#13;
</li>&#13;
<li>&#13;
<p>Creating ServiceAccounts</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You have already seen a Role in <a data-type="xref" href="#ex-accesscontrol-role">Example 26-6</a>. Besides metadata, such as names and namespaces, a Role definition consists of a list of rules that describe which resources can be accessed.</p>&#13;
&#13;
<p>Only one rule must match a request to grant access to this Role. Three fields describe each <code>rule</code>:</p>&#13;
<dl>&#13;
<dt>apiGroups</dt>&#13;
<dd>&#13;
<p>This list is used rather than a single value because wildcards can specify all resources of multiple API groups. For example, an empty string (<code>""</code>) is used for the core API group, which contains primary Kubernetes resources such as Pods and Services. A wildcard character (*) can match all available API groups the cluster is aware of.</p>&#13;
</dd>&#13;
<dt>resources</dt>&#13;
<dd>&#13;
<p>This list specifies the resources that Kubernetes should grant access to. Each entry should belong to at least one of the configured <code>apiGroups</code>. A single <code>*</code> wildcard entry means all resources from all configured <code>apiGroups</code> are allowed.</p>&#13;
</dd>&#13;
<dt>verbs</dt>&#13;
<dd>&#13;
<p>Allowed actions in a system are defined using verbs that are similar to HTTP methods. These verbs include CRUD operations on resources (CRUD stands for <em>Create-Read-Update-Delete</em> and describes the usual read-write operations that you can perform on persistent entities), and separate actions for operations on collections, such as <code>list</code> and <code>deletecollection</code>. Additionally, a <code>watch</code> verb allows access to resource change events and is separate from directly reading the resource with <code>get</code>. This <code>watch</code> verb is crucial for operators to receive notifications about the current status of resources they are managing. <a data-type="xref" data-xrefstyle="chap-num-title" href="ch27.html#Controller">Chapter 27, “Controller”</a>, and <a data-type="xref" data-xrefstyle="chap-num-title" href="ch28.html#Operator">Chapter 28, “Operator”</a>, has more on this topic. <a data-type="xref" href="#table-accesscontrol-verbs">Table 26-3</a> lists the most common verbs.&#13;
Using the <code>*</code> wildcard character is also possible to allow all operations on the configured resources for a given rule.</p>&#13;
</dd>&#13;
</dl>&#13;
<table id="table-accesscontrol-verbs">&#13;
<caption><span class="label">Table 26-3. </span>Kubernetes verb mapping to HTTP request methods for CRUD operations</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Verbs</th>&#13;
<th>HTTP request methods</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>get, watch, list</p></td>&#13;
<td><p>GET</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>create</p></td>&#13;
<td><p>POST</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>patch</p></td>&#13;
<td><p>PATCH</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>update</p></td>&#13;
<td><p>PUT</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>delete, delete collection</p></td>&#13;
<td><p>DELETE</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Wildcard permissions make it easier to define all operations without&#13;
listing each option individually.&#13;
All of the properties of a Role’s <code>rule</code> element allow for an <code>*</code> wildcard, which matches everything.&#13;
<a data-type="xref" href="#table-accesscontrol-wildcards">Example 26-8</a> allows for all operations on all resources in the core and <code>networking.k8s.io</code> API group.&#13;
If a wildcard is used, this list should have only this wildcard as its single entry.</p>&#13;
<div data-type="example" id="table-accesscontrol-wildcards">&#13;
<h5><span class="label">Example 26-8. </span>Wildcard permission for resources and permitted operations</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">rules</code><code class="p">:</code><code class="w">&#13;
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">networking.k8s.io</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">*</code><code class="s">"</code><code class="w">  </code><a class="co" href="#callout_access_control_CO6-1" id="co_access_control_CO6-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">*</code><code class="s">"</code><code class="w">  </code><a class="co" href="#callout_access_control_CO6-2" id="co_access_control_CO6-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_access_control_CO6-1" id="callout_access_control_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>All Resources in the listed API groups, core, and <code>networking.k8s.io.</code></p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO6-2" id="callout_access_control_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>All actions are allowed on those resources.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Wildcards help developers to configure rules quickly.&#13;
But they come with the security risk of privilege escalation.&#13;
Such broader privileges can cause security gaps and allow users to perform any operations that can compromise the Kubernetes cluster or cause unwanted changes.</p>&#13;
&#13;
<p>Now that we have looked into the <em>what</em> (Roles) and <em>who</em> (subjects) of the Kubernetes RBAC model, let’s have a closer look at how we can combine both concepts with RoleBindings.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RoleBinding" data-type="sect3"><div class="sect3" id="accesscontrol-rolebinding">&#13;
<h3>RoleBinding</h3>&#13;
&#13;
<p>In <a data-type="xref" href="#ex-accesscontrol-rolebinding">Example 26-7</a>, we saw how RoleBindings link one or more subjects to a given Role.</p>&#13;
&#13;
<p>Each RoleBinding can connect a list of subjects to a Role. The <code>subjects</code> list field takes resource references as elements.&#13;
Those resource references have a <code>name</code> field plus  <code>kind</code> and <code>apiGroup</code> fields for defining the resource type to reference.</p>&#13;
&#13;
<p>A subject in a RoleBinding can be one of the following types:</p>&#13;
<dl>&#13;
<dt>User</dt>&#13;
<dd>&#13;
<p>A user is a human or system authenticated by the API server, as described in <a data-type="xref" href="#accesscontrol-users">“Users”</a>. User entries have a fixed <code>apiGroup</code> value of <code>rbac.authorization.k8s.io</code>.</p>&#13;
</dd>&#13;
<dt>Group</dt>&#13;
<dd>&#13;
<p>A group is a collection of users, as explained in <a data-type="xref" href="#accesscontrol-groups">“Groups”</a>. As for users, the group entries carry a <code>rbac.authorization.k8s.io</code> as <code>apiGroup</code>.</p>&#13;
</dd>&#13;
<dt>ServiceAccount</dt>&#13;
<dd>&#13;
<p>We discussed ServiceAccount in depth in <a data-type="xref" href="#accesscontrol-service-accounts">“Service accounts”</a>. ServiceAccounts belong to the core API Group that is represented by an empty string (<code>""</code>). One unique aspect of ServiceAccounts is that it is the only subject type that can also carry a <code>namespace</code> field. This allows you to grant access to Pods from other namespaces.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#table-accesscontrol-rb-subjects">Table 26-4</a> summarizes the possible field values for entries in a RoleBinding’s <code>subject</code> list.</p>&#13;
<table class="less_space pagebreak-before" id="table-accesscontrol-rb-subjects">&#13;
<caption><span class="label">Table 26-4. </span>Possible types for an element <code>subjects</code> list in a RoleBinding</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Kind</th>&#13;
<th>API Group</th>&#13;
<th>Namespace</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>User</p></td>&#13;
<td><p>rbac.authorization.k8s.io</p></td>&#13;
<td><p>N/A</p></td>&#13;
<td><p><code>name</code> is a reference to a user.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Group</p></td>&#13;
<td><p>rbac.authorization.k8s.io</p></td>&#13;
<td><p>N/A</p></td>&#13;
<td><p><code>name</code> is a reference to a group of users.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ServiceAccount</p></td>&#13;
<td><p>“”</p></td>&#13;
<td><p>Optional</p></td>&#13;
<td><p><code>name</code> is a reference to a ServiceAccount resource in the configured namespace.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The other end of a RoleBinding points to a single Role.&#13;
This Role can either be a Role resource within the same namespace as the RoleBinding or a ClusterRole resource shared across multiple bindings in the cluster.&#13;
ClusterRoles are described in detail in <a data-type="xref" href="#accesscontrol-clusterrole">“ClusterRole”</a>.</p>&#13;
&#13;
<p>Similar to the subjects list, Role references are specified by <code>name</code>, <code>kind</code>, and <code>apiGroup</code>.&#13;
<a data-type="xref" href="#table-accesscontrol-rb-roleref">Table 26-5</a> shows the possible values for the <code>roleRef</code> field.</p>&#13;
<table id="table-accesscontrol-rb-roleref">&#13;
<caption><span class="label">Table 26-5. </span>Possible types for a <code>roleRef</code> field in a RoleBinding</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Kind</th>&#13;
<th>API Group</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Role</p></td>&#13;
<td><p>rbac.authorization.k8s.io</p></td>&#13;
<td><p><code>name</code> is a reference to a Role in the same namespace.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>ClusterRole</p></td>&#13;
<td><p>rbac.authorization.k8s.io</p></td>&#13;
<td><p><code>name</code> is a reference to cluster-wide ClusterRole.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902084744944">&#13;
<h1>Privilege-Escalation Prevention</h1>&#13;
<p>The<a data-primary="privilege-escalation prevention" data-type="indexterm" id="idm45902084743648"/> RBAC subsystem is responsible for managing Roles and RoleBindings (as well as ClusterRoles and ClusterRoleBindings). To prevent privilege escalation, in which users with permissions to control the RBAC resource elevate their permissions, the following restrictions apply:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Users can update a Role only if they already have all the permissions in that Role or if they have permission to use the <code>escalate</code> verb on all resources in the <code>rbac.authorization.k8s</code> API group.</p>&#13;
</li>&#13;
<li>&#13;
<p>For RoleBindings, a similar restriction applies: users must have all the permissions granted in the referenced Role, or they must have the <code>bind</code> verb allowance on the RBAC resources.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>More information about these restrictions and how they help prevent privilege escalation can be found in the Kubernetes documentation <a href="https://oreil.ly/Wua_7">“Privilege Escalation Prevention and Bootstrapping”</a>.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="ClusterRole" data-type="sect3"><div class="sect3" id="accesscontrol-clusterrole">&#13;
<h3>ClusterRole</h3>&#13;
&#13;
<p>ClusterRoles in Kubernetes are similar to regular Roles but are applied cluster-wide rather than to a specific namespace. They have two primary uses:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Securing cluster-wide resources such as CustomResourceDefinitions or StorageClasses. These resources are typically managed at the<a data-primary="cluster-admin" data-secondary="role-based access control" data-type="indexterm" id="idm45902084734064"/> cluster-admin level and require additional access control. For example, developers may have read access to these resources but need help writing to them. ClusterRoleBindings are used to grant subjects access to cluster-wide resources.</p>&#13;
</li>&#13;
<li>&#13;
<p>Defining typical Roles that are shared across namespaces. As we saw in <a data-type="xref" href="#accesscontrol-rolebinding">“RoleBinding”</a>, RoleBindings can refer only to Roles defined in the same namespace. ClusterRoles allow you to define general-access control Roles (e.g., “view” for read-only access to all resources) that can be used in multiple RoleBindings.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#ex-accesscontrol-clusterole">Example 26-9</a> shows a ClusterRole that can be reused in multiple RoleBindings. It has the same schema as a Role except that it ignores any <code>.meta.namespace</code> field.</p>&#13;
<div data-type="example" id="ex-accesscontrol-clusterole">&#13;
<h5><span class="label">Example 26-9. </span>ClusterRole</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">view-pod</code><code class="w"> </code><a class="co" href="#callout_access_control_CO7-1" id="co_access_control_CO7-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">rules</code><code class="p">:</code><code class="w">&#13;
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w">     </code><a class="co" href="#callout_access_control_CO7-2" id="co_access_control_CO7-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">pods</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">get</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">list</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_access_control_CO7-1" id="callout_access_control_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Name of the ClusterRole but no namespace declaration.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO7-2" id="callout_access_control_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Rule that allows reading operations on all Pods.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p><a data-type="xref" href="#img-accesscontrol-clusterrole">Figure 26-4</a> shows how a single ClusterRole can be shared across multiple RoleBindings in different namespaces. In this example, the ClusterRole allows the reading of Pods in the <code>dev-1</code> and <code>dev-2</code> namespaces by a ServiceAccount in the <code>test</code> namespace.</p>&#13;
&#13;
<figure><div class="figure" id="img-accesscontrol-clusterrole">&#13;
<img alt="Sharing ClusterRole in multiple namespaces" src="assets/kup2_2604.png"/>&#13;
<h6><span class="label">Figure 26-4. </span>Sharing a ClusterRole in multiple namespaces</h6>&#13;
</div></figure>&#13;
&#13;
<p>Using a single ClusterRole in multiple RoleBindings allows you to create typical access-control schemes that can be easily reused. For example, <a data-type="xref" href="#table-accesscontrol-clusterrole-default">Table 26-6</a> includes a selection of useful user-facing ClusterRoles that Kubernetes provides out of the box. You can view the complete list of ClusterRoles available in a Kubernetes cluster using the<a data-primary="kubectl" data-secondary="role-based access control" data-type="indexterm" id="idm45902084629216"/> <code>kubectl get clusterroles</code> command, or refer to the <a href="https://oreil.ly/QklvQ">Kubernetes documentation</a> for a list of default ClusterRoles.</p>&#13;
<table id="table-accesscontrol-clusterrole-default">&#13;
<caption><span class="label">Table 26-6. </span>Standard user-facing ClusterRoles</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>ClusterRole</th>&#13;
<th>Purpose</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>view</code></p></td>&#13;
<td><p>Allows reading for most resources in a namespace, except Role, RoleBinding, and Secret</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>edit</code></p></td>&#13;
<td><p>Allows reading and modifying most resources in a namespace, except Role and RoleBinding</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>admin</code></p></td>&#13;
<td><p>Grants full control of all resources in a namespace, including Role and RoleBinding</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>cluster-admin</code></p></td>&#13;
<td><p>Grants<a data-primary="cluster-admin" data-secondary="purpose of" data-type="indexterm" id="idm45902084616736"/> full control of all namespace resources, including cluster-wide resources</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Sometimes you may need to combine the permissions defined in two ClusterRoles. One way to do this is to create multiple RoleBindings that refer to both ClusterRoles. However, there is a more elegant way to achieve this using aggregation.</p>&#13;
&#13;
<p>To use aggregation, you can define a ClusterRole with an empty <code>rules</code> field and a populated <code>aggregationRule</code> field containing a list of label selectors. Then, the rules defined by every other ClusterRole that has labels matching these selectors will be combined and used to populate the <code>rules</code> field of the aggregated ClusterRole.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>When you set the <code>aggregationRule</code> field, you are handing ownership of the <code>rules</code> field over to Kubernetes, which will fully manage it. Therefore, any manual changes to the rules field will be constantly overwritten with the aggregated rules from the selected ClusterRoles in the <code>aggregationRule</code>.</p>&#13;
</div>&#13;
&#13;
<p>This aggregation technique allows you to dynamically and elegantly build up large rule sets by combining smaller, more focused ClusterRoles.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-accesscontrol-clusterrole-aggregation">Example 26-10</a> shows how the default <code>view</code> role uses aggregation to pick up more specific ClusterRoles labeled with <code>rbac.authorization.k8s.io/aggregate-to-view</code>. The <code>view</code> role itself also has the label <code>rbac.authorization.k8s.io/aggregate-to-edit</code>, which is used by the <code>edit</code> role to include the aggregated rules from the <code>view</code> ClusterRole.</p>&#13;
<div data-type="example" id="ex-accesscontrol-clusterrole-aggregation">&#13;
<h5><span class="label">Example 26-10. </span>Aggregated ClusterRole</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">view</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">rbac.authorization.k8s.io/aggregate-to-edit</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">true</code><code class="s">"</code><code class="w">   </code><a class="co" href="#callout_access_control_CO8-1" id="co_access_control_CO8-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">aggregationRule</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">clusterRoleSelectors</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">rbac.authorization.k8s.io/aggregate-to-view</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">true</code><code class="s">"</code><code class="w"> </code><a class="co" href="#callout_access_control_CO8-2" id="co_access_control_CO8-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="nt">rules</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="p-Indicator">]</code><code class="w">  </code><a class="co" href="#callout_access_control_CO8-3" id="co_access_control_CO8-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_access_control_CO8-1" id="callout_access_control_CO8-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This label exposes the ClusterRole as eligible for inclusion in the <code>edit</code> role.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO8-2" id="callout_access_control_CO8-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>All ClusterRoles that match this selector will be picked up for the <code>view</code> ClusterRole. Note that this ClusterRole declaration does not need to be changed if you want to add additional permissions to the <code>view</code> ClusterRole—you can create a new ClusterRole with the appropriate label.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO8-3" id="callout_access_control_CO8-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>rules</code> field will be managed by Kubernetes and populated with the aggregated rules.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This technique allows you to quickly compose more specialized ClusterRoles by aggregating a set of basic ClusterRoles. <a data-type="xref" href="#ex-accesscontrol-clusterrole-aggregation">Example 26-10</a> also demonstrates how aggregation can be nested to build an inheritance chain of permission rule sets.</p>&#13;
&#13;
<p>Since all of the user-facing default ClusterRoles use this aggregation technique, you can quickly hook into the permission model of custom resources (as described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch28.html#Operator">Chapter 28, “Operator”</a>) by simply adding the aggregation-triggering labels of the standard ClusterRoles (e.g., <code>view</code>, <code>edit</code>, and <code>admin</code>).</p>&#13;
&#13;
<p>Now that we’ve covered the creation of a flexible and reusable permission model using ClusterRoles and RoleBindings, the final piece of the puzzle is establishing cluster-wide access rules with ClusterRoleBindings.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ClusterRoleBinding" data-type="sect3"><div class="sect3" id="idm45902084737056">&#13;
<h3>ClusterRoleBinding</h3>&#13;
&#13;
<p>The schema for a ClusterRoleBinding is similar to that of a RoleBinding, except that it ignores the <code>namespace</code> field. The rules defined in a ClusterRoleBinding apply to all namespaces in the cluster.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-accesscontrol-clusterrolebinding-all-namespaces">Example 26-11</a> shows a ClusterRoleBinding that connects a ServiceAccount <code>test-sa</code> with the ClusterRole <code>view-pod</code> defined in <a data-type="xref" href="#ex-accesscontrol-clusterole">Example 26-9</a>.</p>&#13;
<div data-type="example" id="ex-accesscontrol-clusterrolebinding-all-namespaces">&#13;
<h5><span class="label">Example 26-11. </span>ClusterRoleBinding</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRoleBinding</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">test-sa-crb</code><code class="w">&#13;
</code><code class="nt">subjects</code><code class="p">:</code><code class="w">             </code><a class="co" href="#callout_access_control_CO9-1" id="co_access_control_CO9-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">test-sa</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">test</code><code class="w">&#13;
</code><code class="nt">roleRef</code><code class="p">:</code><code class="w">              </code><a class="co" href="#callout_access_control_CO9-2" id="co_access_control_CO9-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">view-pod</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_access_control_CO9-1" id="callout_access_control_CO9-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Connects ServiceAccount <code>test-sa</code> from the <code>test</code> namespace.</p></dd>&#13;
<dt><a class="co" href="#co_access_control_CO9-2" id="callout_access_control_CO9-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Allows the rules from the ClusterRole <code>view-pod</code> for every namespace.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The rules defined in the ClusterRole <code>view-pod</code> apply to all namespaces in the cluster so that any Pod associated with the ServiceAccount <code>test-sa</code> can read all Pods in every namespace, which is illustrated in <a data-type="xref" href="#img-accesscontrol-clusterrolebinding">Figure 26-5</a>. However, it is crucial to use ClusterRoleBindings with caution, as they grant wide-ranging permissions across the entire cluster. Therefore, it is recommended that you carefully consider whether using a ClusterRoleBinding is necessary.</p>&#13;
&#13;
<p>Using a ClusterRoleBinding may be convenient as it automatically grants permissions to newly created namespaces. However, using individual RoleBindings per namespace is generally better for more granular control over permissions. This extra effort allows you to omit specific namespaces, such as <code>kube-system</code>, from unauthorized access.</p>&#13;
&#13;
<figure><div class="figure" id="img-accesscontrol-clusterrolebinding">&#13;
<img alt="ClusterRoleBinding for reading all Pods" src="assets/kup2_2605.png"/>&#13;
<h6><span class="label">Figure 26-5. </span>ClusterRoleBinding for reading all Pods</h6>&#13;
</div></figure>&#13;
&#13;
<p>ClusterRoleBindings should be used only for administrative tasks, such as managing cluster-wide resources like Nodes, Namespaces, CustomResourceDefinitions, or even ClusterRoleBindings.</p>&#13;
&#13;
<p>These final warnings conclude our tour through the world of Kubernetes RBAC.&#13;
This machinery is mighty, but it’s also complex to understand and sometimes even more complicated to debug.&#13;
The following sidebar gives you some tips for better understanding a given RBAC setup.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar-subject-access-review">&#13;
<h1>Debugging RBAC Rules</h1>&#13;
<p>In a Kubernetes cluster, many RBAC objects define the overall security model for accessing the API server.&#13;
Understanding the authorization decisions made by the Kubernetes API server can be challenging, but the Access Review API can help by allowing you to query the authorization subsystem for permissions.</p>&#13;
&#13;
<p>One way to use this API is through the<a data-primary="kubectl" data-secondary="debugging RBAC rules" data-type="indexterm" id="idm45902084378864"/> <code>kubectl auth can-i</code> command. For example, you can use it to check whether a ServiceAccount named <code>test-sa</code> in the <code>test</code> namespace has permission to list all pods in the <code>dev-1</code> namespace. The command would look like <a data-type="xref" href="#ex-accesscontrol-auth-can-i">Example 26-12</a>.&#13;
This command will return a simple “yes” or “no” indicating whether the ServiceAccount has the specified permission.</p>&#13;
<div data-type="example" id="ex-accesscontrol-auth-can-i">&#13;
<h5><span class="label">Example 26-12. </span>Check access permissions with <code>kubectl</code></h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">kubectl<code class="w"> </code>auth<code class="w"> </code>can-i<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>list<code class="w"> </code>pods<code class="w"> </code>--namespace<code class="w"> </code>dev-1<code class="w"> </code>--as<code class="w"> </code>system:serviceaccount:test:test-sa<code class="w"/></pre></div>&#13;
&#13;
<p>Behind the scenes, a resource of the type SubjectAccessReview is created, and the Kubernetes authorization controller updates the <code>status</code> section of this resource with the result of the authorization check. You can read more about this API in the <a href="https://oreil.ly/ZyONK">Kubernetes RBAC documentation</a>.</p>&#13;
&#13;
<p>While <code>kubectl auth can-i</code> helps check specific permissions, it can be tedious and does not provide a comprehensive overview of a subject’s permissions across the cluster. To better understand what actions a subject can perform on all resources, tools like  <a href="https://oreil.ly/Km5D3">rakkess</a> can be helpful. Rakkess is available as a <code>kubectl</code> plugin and can be run with the command <code>kubectl access-matrix</code>. It provides a matrix view of the actions a subject can perform on specific resources.</p>&#13;
&#13;
<p>Another tool to help visualize and verify the application of fine-grained permissions is <a href="https://oreil.ly/zL5a9">KubiScan</a>, which allows you to scan a Kubernetes cluster for risky permissions in the RBAC configuration.</p>&#13;
</div></aside>&#13;
&#13;
<p>The final section will discuss some general tips for properly using Kubernetes RBAC.<a data-primary="" data-startref="rolebased26" data-type="indexterm" id="idm45902084350304"/><a data-primary="" data-startref="RBAC26" data-type="indexterm" id="idm45902084349328"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902085193280">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>Kubernetes RBAC is a powerful tool for controlling access to API resources. However, it can be challenging to understand which definition objects to use and how to combine them to fit a particular security setup. Here are some guidelines to help you navigate these decisions:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If you want to secure resources in a specific namespace, use a Role with a RoleBinding that connects to a user or ServiceAccount. The ServiceAccount does not have to be in the same namespace, allowing you to grant access to Pods from other namespaces.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you want to reuse the same access rules in multiple namespaces, use a RoleBinding with a ClusterRole that defines these shared-access rules.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you want to extend one or more existing predefined ClusterRoles, create a new ClusterRole with an <code>aggregationRule</code> field that refers to the ClusterRoles you wish to extend, and add your permissions to the <code>rules</code> field.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you want to grant a user or ServiceAccount access to all resources of a specific kind in all namespaces, use a ClusterRole and a ClusterRoleBinding.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you want to manage access to a cluster-wide resource like a CustomResourceDefinition, use a ClusterRole and a ClusterRoleBinding.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We have seen how RBAC allows us to define fine-grained permissions and&#13;
manage them. It can reduce risk by ensuring the&#13;
applied permission does not leave gaps for the escalation path. On the other hand, defining&#13;
any broad open permissions can lead to security escalations. Let’s close&#13;
this chapter with a summary of some general RBAC advice:</p>&#13;
<dl>&#13;
<dt>Avoid wildcard permissions</dt>&#13;
<dd>&#13;
<p>We recommend following the principle of least privilege when composing the fine-grained access control in the Kubernetes cluster. To avoid unintentional operations, avoid wildcard permissions when defining the Role and ClusterRoles. For rare occasions, it might make sense to use wildcards (i.e., to secure all resources of an API group), but it is a good practice to establish a general “no wildcard” policy that could be relaxed for well-reasoned exceptions.</p>&#13;
</dd>&#13;
<dt>Avoid <code>cluster-admin</code> ClusterRole</dt>&#13;
<dd>&#13;
<p>ServiceAccounts<a data-primary="cluster-admin" data-secondary="avoiding ClusterRole Pod assignment" data-type="indexterm" id="idm45902084336560"/> with high privileges can allow you to perform actions over any resources, like modifying permissions or viewing secrets in any namespace, which can lead to severe security implications. Therefore, never assign the <code>cluster-admin</code> ClusterRole to a Pod. Never.</p>&#13;
</dd>&#13;
<dt>Don’t automount ServiceAccount tokens</dt>&#13;
<dd>&#13;
<p>By default, tokens of ServiceAccounts are mounted within a container’s filesystem at <em>/var/run/secrets/kubernetes.io/serviceaccount/token</em>. If such a Pod gets compromised, any attacker can talk with the API server with the permissions of the Pod’s associated ServiceAccount. However, many applications don’t need that token for business operations. For such a use case, avoid the token mount by setting the ServiceAccount’s field <code>automountServiceAccountToken</code> to <code>false</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Kubernetes RBAC is a flexible and powerful method for controlling access to the Kubernetes API. Therefore, even if your application is not directly interacting with the API Server to install your application and connect it to other Kubernetes servers, <em>Access Control</em> is a valuable pattern to secure the operation of your application.<a data-primary="" data-startref="acccont26" data-type="indexterm" id="idm45902084313264"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="accesscontrol-more-information">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/GyIlq">Access Control Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/HHT3G">Escalation Paths</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/BtTB9">Controlling Access to the Kubernetes API</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/XgzNL">Auditing</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/QSqW8">Admission Controllers Reference</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/7oCSg">Dynamic Admission Control</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/hSISq">Kubernetes: Authentication Strategies</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/h7XHg">RBAC Good Practices</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/uC307">Workload Creation</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/bJVhD">Bound Service Account Tokens</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/T22fJ">BIG Change in K8s 1.24 About ServiceAccounts and Their Secrets</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/RdlPi">Efficient Detection of Changes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/jVXQN">Add ImagePullSecrets to a Service Account</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://rbac.dev">RBAC Dev</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/fE1I_">Rakkess</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/nAFu2">How the Basics of Kubernetes Auth Scale for Organizations</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/BC6aO">Kubernetes CVE-2020-8559 Proof of Concept PoC Exploit</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/UVz7Y">OAuth Is Not Authentication</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45902085697664"><sup><a href="ch26.html#idm45902085697664-marker">1</a></sup> See the blog post <a href="https://oreil.ly/uGzr_">“Exposed Kubernetes Clusters”</a>.</p><p data-type="footnote" id="idm45902085687920"><sup><a href="ch26.html#idm45902085687920-marker">2</a></sup> An <a href="https://oreil.ly/h1YGJ">attacker with escalated privileges</a> on a node can compromise a full Kubernetes cluster.</p></div></div></section></body></html>