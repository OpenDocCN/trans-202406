<html><head></head><body><section data-pdf-bookmark="&#xFEFF;Foreword" data-type="foreword" epub:type="foreword"><div class="preface" id="idm46291210495832">&#13;
<h1>﻿Foreword</h1>&#13;
&#13;
&#13;
<p>In the past decade, Node.js has gone from novelty to the de facto platform for new applications. During that period, I have had the opportunity to help thousands of Node.js developers from around the world orient themselves and find their paths to success. I have seen Node.js used for everything. Really:  someone even built a low-level bootable operating system with Node.js.</p>&#13;
&#13;
<p>At the SFNode meetup I created in San Francisco, we have a star speaker who has spoken more than anyone else. You guessed it: Thomas Hunter II, the author of this book. While you may be able to do anything with Node.js, there are some really practical things that particularly benefit from being done with Node.js. In today’s cloud-first world, most systems have become distributed systems. In this book and in the countless talks I’ve had the pleasure to see Thomas give at SFNode and around the world, pragmatism reigns supreme. This book is filled with experience-tested, hands-on guidance to get you from where you are today to where you need to be tomorrow.</p>&#13;
&#13;
<p>The JavaScript language enables us as developers to create at the speed of thought. It requires little ceremony, and the code we write is usually simple enough that writing it by hand is more efficient than generating it. This beautiful simplicity of JavaScript is perfectly matched with Node.js. Node, as we frequently refer to it, is intentionally minimal. Ryan Dahl, its creator, wrote Node to build an application server that was an order of magnitude easier and faster than what anyone was used to. The results have exceeded even our wildest dreams. The ease and simplicity of Node.js enables you to create, validate, and innovate in ways that simply weren’t possible 10 years ago.</p>&#13;
&#13;
<p>Before I had Node.js, I was a full stack developer using JavaScript to build interactive web-based experiences and Java to provide APIs and backend services. I would revel in the creative flow of JavaScript, and then have to completely shift gears to translate all of it into an object model for Java. What a waste of time! When I found Node.js, I could finally iterate efficiently and effectively both on the client and the server. I literally dropped everything, sold my house, and moved to San Francisco to work with Node.js.</p>&#13;
&#13;
<p>I built data aggregation systems, social media platforms, and video chat—all with Node.js. Then I helped Netflix, PayPal, Walmart, and even NASA learn how to use the platform effectively. The JavaScript APIs were rarely folks’ biggest challenge. What confused people most was the asynchronous programming model. If you don’t understand the tools you are using, how can you expect to achieve the best results with those tools? Asynchronous programming requires you to think a bit more like a computer system rather than a linear script of consecutive actions. This asynchrony is the heartbeat of a good distributed system.</p>&#13;
&#13;
<p>When Thomas asked me to review the table of contents of this book to make sure he’d covered everything, I noticed that the section on scaling starts with an overview of the cluster module. I immediately flagged it as an area of concern. Cluster was created to enable single instance concurrency that can be exposed to a single port on a system. I’ve seen folks new to Node.js take this and run with the assumption that since concurrency may be desirable, cluster is the right tool for their needs. In distributed systems, concurrency at the instance level is usually a waste of time. Luck had it that Thomas and I were on the same page, and this led to a delightful talk at SFNode by our top presenter.</p>&#13;
&#13;
<p>So, as you are building your aptitude as a Node.js developer and as a distributed systems developer, take time to understand the constraints and opportunities in your system. Node.js has incredibly performant I/O capabilities. I’ve seen downstream systems become overwhelmed when old services were removed and replaced with Node.js implementations. These systems acted as natural rate limiters that the downstream services had been built to accommodate. Adding a simple Node.js proxy can fix most issues until the downstream services are updated or replaced.</p>&#13;
&#13;
<p>The ease of development with Node will enable you to try many things. Don’t be afraid to throw out code and start over. Node.js development thrives in iteration. Distributed systems let us isolate and encapsulate logic at a service level, which we then can load balance across to validate whole system performance. But don’t just take my word for it. The pages in this book show you how to do this most effectively.</p>&#13;
&#13;
<p>Have fun and share what you learn along the way.</p>&#13;
&#13;
<p class="byline">Dan Shaw (<a class="orm:hideurl" href="https://twitter.com/dshaw">@dshaw</a>)<br/>&#13;
Founder and CTO, NodeSource<br/>&#13;
The Node.js Company<br/>&#13;
Always bet on Node.js</p>&#13;
</div></section></body></html>