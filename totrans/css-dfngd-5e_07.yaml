- en: Chapter 7\. Padding, Borders, Outlines, and Margins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html#basic-visual-formatting), we talked about the basics
    of element display. In this chapter, we’ll look at the CSS properties and values
    you can use to affect how element boxes are drawn and separated from one another.
    These include the padding, borders, and margins around an element, as well as
    any outlines that may be added.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Element Boxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the preceding chapter, all document elements generate a rectangular
    box called the *element box*, which describes the amount of space that an element
    occupies in the layout of the document. Therefore, each box influences the position
    and size of other element boxes. For example, if the first element box in the
    document is an inch tall, the next box will begin at least an inch below the top
    of the document. If the first element box is changed and made to be 2 inches tall,
    every following element box will shift downward an inch, and the second element
    box will begin at least 2 inches below the top of the document.
  prefs: []
  type: TYPE_NORMAL
- en: By default, a visually rendered document is composed of numerous rectangular
    boxes that are distributed so that they don’t overlap. Boxes can overlap if they
    have been manually positioned or placed on a grid, and visual overlap can occur
    if negative margins are used on normal-flow elements.
  prefs: []
  type: TYPE_NORMAL
- en: To understand how margins, padding, and borders are handled, you must understand
    the *box model*, illustrated in [Figure 7-1](#TheCSSboxmodel).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0701](assets/css5_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. The CSS box model
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The diagram in [Figure 7-1](#TheCSSboxmodel) intentionally omits outlines, for
    reasons that will hopefully be clear once we discuss outlines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The height and width of the content area, as well as the sizing of the content
    area along the block and inline directions, are covered in [Chapter 6](ch06.html#basic-visual-formatting).
    If you find some of the rest of this chapter a little confusing because of the
    way height, width, block axis, and inline axis are discussed, refer to that chapter
    for a detailed explanation.
  prefs: []
  type: TYPE_NORMAL
- en: Padding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just beyond the content area of an element, we find its *padding*, nestled between
    the content and any borders. The simplest way to set padding is by using the property
    `padding`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This property accepts any length value or a percentage value. So if you want
    all `<h2>` elements to have 2 em of padding on all sides, it’s this easy (see
    [Figure 7-2](#Addingpaddingtoelements)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0702](assets/css5_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Adding padding to elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As [Figure 7-2](#Addingpaddingtoelements) illustrates, the background of an
    element extends into the padding by default. If the background is transparent,
    setting padding will create extra transparent space around the element’s content,
    but any visible background will extend into the padding area (and beyond, as you’ll
    see in a later section).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Visible backgrounds can be prevented from extending into the padding by using
    the property `background-clip` (see [Chapter 8](ch08.html#backgrounds)).
  prefs: []
  type: TYPE_NORMAL
- en: By default, elements have no padding. The separation between paragraphs, for
    example, has traditionally been enforced with margins alone (as you’ll see later).
    On the other hand, without padding, the border of an element will come very close
    to the content of the element itself. Thus, when putting a border on an element,
    it’s usually a good idea to add some padding as well, as [Figure 7-3](#Theeffectofpaddingonborderedblock-levelelements)
    illustrates.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0703](assets/css5_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. The effect of padding on bordered block-level elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Any length value is permitted, from ems to inches. The simplest way to set
    padding is with a single length value, which is applied equally to all four padding
    sides. At times, however, you might desire a different amount of padding on each
    side of an element. If you want all `<h1>` elements to have a top padding of 10
    pixels, a right padding of 20 pixels, a bottom padding of 15 pixels, and a left
    padding of 5 pixels, you can just say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of the values is important and follows this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A good way to remember this pattern is to keep in mind that the four values
    go clockwise around the element, starting from the top. The padding values are
    *always* applied in this order, so to get the effect you want, you have to arrange
    the values correctly.
  prefs: []
  type: TYPE_NORMAL
- en: An easy way to remember the order in which sides must be declared, other than
    thinking of it as being clockwise from the top, is to keep in mind that getting
    the sides in the correct order helps you avoid “TRouBLe”—that is, *TRBL*, for
    *top, right, bottom, left*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This ordering reveals that `padding`, like `height` and `width`, is a physical
    property: it refers to the physical directions of the page, such as top or left,
    rather than being based on writing direction. (CSS does have writing-mode padding
    properties, as you’ll see in a bit.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s entirely possible to mix up the types of length values you use. You aren’t
    restricted to using a single length type in a given rule, but can use whatever
    makes sense for a given side of the element, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-4](#Mixed-valuepadding) shows you, with a little extra annotation,
    the results of this declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0704](assets/css5_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Mixed-value padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Replicating Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes the values you enter can get a little repetitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t have to keep typing in pairs of numbers like this, though. Instead
    of the preceding rule, try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These two values are enough to take the place of four. But how? CSS defines
    a few rules to accommodate fewer than four values for `padding` (and many other
    shorthand properties):'
  prefs: []
  type: TYPE_NORMAL
- en: If the value for *left* is missing, use the value provided for *right*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value for *bottom* is also missing, use the value provided for *top*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the value for *right* is also missing, use the value provided for *top*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you prefer a more visual approach, take a look at [Figure 7-5](#Valuereplicationpattern).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0705](assets/css5_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. Value-replication pattern
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In other words, if three values are given for `padding`, the fourth (*left*)
    is copied from the second (*right*). If two values are given, the fourth is copied
    from the second, and the third (*bottom*) from the first (*top*). Finally, if
    only one value is given, all the other sides copy that value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This mechanism allows you to supply only as many values as necessary, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The method presents a small drawback, which you’re bound to eventually encounter.
    Suppose you want to set the top and left padding for `<h1>` elements to be 10
    pixels, and the bottom and right padding to be 20 pixels. You’d have to write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You get what you want, but it takes a while to get it all in. Unfortunately,
    there is no way to cut down on the number of values needed in such a circumstance.
    Let’s take another example, one where you want all of the padding to be 0—except
    for the left padding, which should be 3 em:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Using padding to separate the content areas of elements can be trickier than
    using the traditional margins, although it’s not without its rewards. For example,
    to keep paragraphs the traditional “one blank line” apart with padding, you’d
    have to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The half-em top and bottom padding of each paragraph butt up against each other
    and total an em of separation. Why would you bother to do this? Because then you
    could insert separation borders between the paragraphs, and the side borders will
    touch to form the appearance of a solid line. The following code defines these
    effects, illustrated in [Figure 7-6](#Usingpaddinginsteadofmargins):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0706](assets/css5_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. Using padding instead of margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Single-Side Padding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSS provides a way to assign a value to the padding on a single side of an
    element. Four ways, actually. Let’s say you want to set only the left padding
    of `<h2>` elements to be `3em`. Rather than writing out `padding: 0 0 0 3em`,
    you can take this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `padding-left` option is one of four properties devoted to setting the padding
    on each of the four sides of an element box. Their names will come as little surprise.
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties operate in a manner consistent with their names. For example,
    the following two rules will yield the same amount of padding (assuming no other
    CSS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, these rules will create equal padding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For that matter, so will these rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to use more than one of these single-side properties in a single
    rule; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in [Figure 7-7](#Morethanonesingle-sidepadding), the padding
    is set as we wanted. In this case, it might have been easier to use `padding`
    after all, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0707](assets/css5_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. More than one single-side padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In general, once you’re trying to set padding for more than one side, it’s easier
    to use the shorthand `padding`. From the standpoint of your document’s display,
    however, it doesn’t really matter which approach you use, so choose whichever
    is easiest for you.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Padding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ll see throughout this chapter, physical properties have logical counterparts,
    with names that follow a consistent pattern. For `height` and `width`, we have
    `block-size` and `inline-size`. For padding, we have a set of four properties
    that correspond to the padding at the start and end of the block direction and
    the inline direction. These are called *logical properties*, because they use
    a little logic to determine which physical side they should be applied to.
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties are handy when you want to make sure your text has padding
    that has a consistent effect regardless of the writing direction. For example,
    you might want a little bit of padding to set the background edges away from the
    start and end of each block element, and more padding to the sides of each line
    of text. Here’s a way to make that happen, with the result shown in [Figure 7-8](#logical-padding-figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0708](assets/css5_0708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. Logical padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Percentage values for these logical padding properties are always calculated
    with respect to the *physical* width or height of the element’s container, not
    its logical width or height. Thus, for example, `padding-inline-start: 10%` will
    calculate to 100 pixels when the container has `width: 1000px`, even in a vertical
    writing mode. This may change going forward, but that is the consistent (and specified)
    behavior as of late 2022.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s a little tedious to explicitly declare a padding value for each side of
    an element individually, and two shorthand properties can help: one for the block
    axis, and one for the inline axis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With these shorthand properties, you can set block padding in one go, and inline
    padding in another. The following CSS would have the same result as that shown
    in [“Logical Padding”](#logical-padding):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Each property accepts one or two values. If there are two values, they’re always
    in the order *start end*. If there’s only one value, as shown before, the same
    value is used for both the start and end sides. Thus, to give an element 10 pixels
    of block-start padding and 1 em of block-end padding, you could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: A more compact shorthand doesn’t exist for logical padding, unfortunately—no
    `padding-logical` that accepts four values, the way `padding` does. Proposals
    have been made to extend the `padding` property with a keyword value (such as
    `logical`) to allow it to set logical padding instead of physical padding, but
    as of late 2022, those proposals have not been adopted. As of this writing, the
    most compact you can get with logical padding is to use `padding-block` and `padding-inline`.
  prefs: []
  type: TYPE_NORMAL
- en: Percentage Values and Padding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can set percentage values for the padding of an element. Percentages are
    computed in relation to the width of the parent element’s content area, so they
    change if the parent element’s width changes in some way.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume the following, which is illustrated in [Figure 7-9](#Paddingpercentagesandthewidthsofparentelements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0709](assets/css5_0709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9\. Padding, percentages, and the widths of parent elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may have noticed something odd about the paragraphs in [Figure 7-9](#Paddingpercentagesandthewidthsofparentelements).
    Not only did their side padding change according to the width of their parent
    elements, but so did their top and bottom padding. That’s the desired behavior
    in CSS. Refer back to the property definition, and you’ll see that percentage
    values are defined to be relative to the *width* of the parent element. This applies
    to the top and bottom padding as well as to the left and right. Thus, given the
    following styles and markup, the top padding of the paragraph will be 50 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If all this seems strange, consider that most elements in the normal flow are
    (as we are assuming) as tall as necessary to contain their descendant elements,
    including padding. If an element’s top and bottom padding were a percentage of
    the parent’s height, an infinite loop could result where the parent’s height was
    increased to accommodate the top and bottom padding, which would then have to
    increase to match the new height, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than ignore percentages for top and bottom padding, the specification
    authors decided to make it relate to the width of the parent’s content area, which
    does not change based on the width of its descendants. This allows authors to
    get a consistent padding all the way around an element by using the same percentage
    on all four sides.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, consider elements without a declared width. In such cases, the
    overall width of the element box (including padding) is dependent on the width
    of the parent element. This leads to the possibility of *fluid* pages, where the
    padding on elements enlarges or reduces to match the actual size of the parent
    element. If you style a document so that its elements use percentage padding,
    then as the user changes the width of a browser window, the padding will expand
    or shrink to fit. The design choice is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also can mix percentages with length values. Thus, to set `<h2>` elements
    to have top and bottom padding of one-half em, and side padding of 10% the width
    of their parent elements, you can declare the following, illustrated in [Figure 7-10](#Mixedpadding):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0710](assets/css5_0710.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-10\. Mixed padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, although the top and bottom padding will stay constant in any situation,
    the side padding will change based on the width of the parent element.
  prefs: []
  type: TYPE_NORMAL
- en: Padding and Inline Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have noticed that the discussion so far has been solely about padding
    set for elements that generate block boxes. When padding is applied to inline
    nonreplaced elements, the effects are a little different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to set top and bottom padding on strongly emphasized text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is allowed in the specification, but since you’re applying the padding
    to an inline nonreplaced element, it will have absolutely no effect on the line
    height. Since padding is transparent when there’s no visible background, the preceding
    declaration will have no visual effect whatsoever. This happens because padding
    on inline nonreplaced elements doesn’t change the line height of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful: an inline nonreplaced element with a background color and padding
    can have a background that extends above and below the element, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-11](#Paddingonaninlinenonreplacedelement) gives you an idea of what
    this might look like.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0711](assets/css5_0711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-11\. Top padding on an inline nonreplaced element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The line height isn’t changed, but since the background color does extend into
    the padding, each line’s background ends up overlapping the lines that come before
    it. That’s the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding behaviors are true only for the top and bottom sides of inline
    nonreplaced elements; the left and right sides are a different story. We’ll start
    by considering the case of a small, inline nonreplaced element within a single
    line. Here, if you set values for the left or right padding, they will be visible,
    as [Figure 7-12](#Aninlinenonreplacedelementwithleftpadding) makes clear (so to
    speak):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0712](assets/css5_0712.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-12\. An inline nonreplaced element with left padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note the extra space between the end of the word just before the inline nonreplaced
    element and the edge of the inline element’s background. You can add that extra
    space to both ends of the inline if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As expected, [Figure 7-13](#Aninlinenonreplacedelementwith25-pixelsidepadding)
    shows a little extra space on the right and left sides of the inline element,
    and no extra space above or below it.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0713](assets/css5_0713.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-13\. An inline nonreplaced element with 25-pixel side padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, when an inline nonreplaced element stretches across multiple lines, the
    situation changes a bit. [Figure 7-14](#Aninlinenonreplacedelementwith25-pixelsidepaddingdisplayedacrosstwolinesoftext)
    shows what happens when an inline nonreplaced element with padding is displayed
    across multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The left padding is applied to the beginning of the element, and the right padding
    to the end of it. By default, padding is *not* applied to the right and left side
    of each line. Also, you can see that, if not for the padding, the line may have
    broken after “background” instead of where it did. The `padding` property affects
    line breaking only by changing the point at which the element’s content begins
    within a line.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0714](assets/css5_0714.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-14\. An inline nonreplaced element with 25-pixel side padding displayed
    across two lines of text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The way padding is (or isn’t) applied to the ends of each line box can be altered
    with the property `box-decoration-break`. See [Chapter 6](ch06.html#basic-visual-formatting)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Padding and Replaced Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to apply padding to replaced elements. The most surprising case
    for most people is that you can apply padding to an image, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Regardless of whether the replaced element is block-level or inline, the padding
    will surround its content, and the background color will fill into that padding,
    as shown in [Figure 7-15](#Paddingreplacedelements). You can also see that padding
    will push a replaced element’s border (dashed, in this case) away from its content.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0715](assets/css5_0715.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-15\. Padding, borders, and background on a replaced element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, remember all that stuff about how padding on inline nonreplaced elements
    doesn’t affect the height of the lines of text? You can throw it all out for *replaced*
    elements, because they have a different set of rules. As you can see in [Figure 7-16](#Paddingreplacedelements2),
    the padding of an inline replaced element very much affects the height of the
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0716](assets/css5_0716.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-16\. Padding an inline replaced element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The same goes for borders and margins, as you’ll soon see.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the image in [Figure 7-16](#Paddingreplacedelements2) had not loaded,
    or had somehow been set to have 0 height and width, the padding would still be
    rendered around the spot where the element should have been displayed, even if
    that spot has no height or width.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, uncertainty remains over what to do about styling form elements
    such as `<input>`, which are replaced elements. It is not entirely clear where
    the padding of a checkbox resides, for example. Therefore, as of this writing,
    some browsers ignore padding (and other forms of styling) for form elements, while
    others apply the styles as best they can.
  prefs: []
  type: TYPE_NORMAL
- en: Borders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond the padding of an element are its borders. The *border* of an element
    is just one or more lines that surround the content and padding of an element.
    By default, the background of the element stops at the outer border edge, since
    the background does not extend into the margins, and the border is just inside
    the margin, and is thus drawn “underneath” the border. This matters when parts
    of the border are transparent, such as with dashed borders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every border has three aspects: its width, or thickness; its style, or appearance;
    and its color. The default value for the width of a border is `medium`, which
    was explicitly declared to be 3 pixels wide in 2022. Despite this, the reason
    you don’t usually see borders is that the default style is `none`, which prevents
    them from existing at all. (This lack of existence can also reset the `border-width`
    value, but we’ll get to that in a little while.)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the default border color is `currentcolor`, the foreground color of
    the element itself. If no color has been declared for the border, it will be the
    same color as the text of the element. If, on the other hand, an element has no
    text—let’s say it has a table that contains only images—the border color for that
    table will be the text color of its parent element (because `color` is inherited).
    Thus, if a table has a border, and the `<body>` is its parent, given this rule
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: then, by default, the border around the table will be purple (assuming the user
    agent doesn’t set a color for tables).
  prefs: []
  type: TYPE_NORMAL
- en: The CSS specification defines the background area of an element to extend to
    the outside edge of the border, at least by default. This is important because
    some borders are *intermittent*—for example, `dotted` and `dashed` borders—so
    the element’s background should appear in the spaces between the visible portions
    of the border.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Visible backgrounds can be prevented from extending into the border area by
    using the property `background-clip`. See [Chapter 8](ch08.html#backgrounds) for
    details.
  prefs: []
  type: TYPE_NORMAL
- en: Borders with Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll start with border styles, which are the most important aspect of a border—not
    because they control the appearance of the border (although they certainly do
    that) but because without a style, there wouldn’t be any border at all.
  prefs: []
  type: TYPE_NORMAL
- en: CSS defines 10 distinct styles for the property `border-style`, including the
    default value of `none`. [Figure 7-17](#Borderstyles) demonstrates these styles.
    This property is not inherited.
  prefs: []
  type: TYPE_NORMAL
- en: The style value `hidden` is equivalent to `none`, except when applied to tables,
    where it has a slightly different effect on border-conflict resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0717](assets/css5_0717.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-17\. Border styles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As for `double`, it’s defined such that the width of the two lines it creates,
    plus the width of the space between them, is equal to the value of `border-width`
    (discussed in the next section). However, the CSS specification doesn’t say whether
    one of the lines should be thicker than the other, or if they should always be
    the same width, or if the space should be thicker or thinner than the lines. All
    of these options are left up to the user agent to decide, and the author has no
    reliable way to influence the final result.
  prefs: []
  type: TYPE_NORMAL
- en: All the borders shown in [Figure 7-17](#Borderstyles) are based on a `color`
    value of `gray`, which makes all of the visual effects easier to see. The look
    of a border style is always based in some way on the color of the border, although
    the exact method may vary among user agents. The way browsers treat colors in
    the border styles `inset`, `outset`, `groove`, and `ridge` can and does vary.
    For example, [Figure 7-18](#Twovalidwaysofrenderinginset) illustrates two ways
    a browser could render an inset border.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0718](assets/css5_0718.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-18\. Two valid ways of rendering an inset
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, one browser takes the `gray` value for the bottom and right
    sides, and a darker gray for the top and left; the other makes the bottom and
    right lighter than `gray` and the top and left darker, but not as dark as the
    first browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s define a border style for images that are inside any unvisited hyperlink.
    We might make them `outset`, so they have a “raised button” look, as depicted
    in [Figure 7-19](#Applyinganoutsetbordertoahyperlinkedimage):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0719](assets/css5_0719.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-19\. Applying an outset border to a hyperlinked image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By default, the color of the border is based on the element’s value for `color`,
    which in this circumstance is likely to be `blue`. This is because the image is
    contained with a hyperlink, and the foreground color of hyperlinks is usually
    `blue`. If you so desired, you could change that color to silver, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The border will now be based on the light-grayish `silver`, since that’s now
    the foreground color of the image—even though the image doesn’t actually use it,
    it’s still passed on to the border. We’ll talk about another way to change border
    colors in [“Border Colors”](#border-colors).
  prefs: []
  type: TYPE_NORMAL
- en: Remember, though, that the color-shifting in borders is up to the user agent.
    Let’s go back to the blue outset border and compare it in two browsers, as shown
    in [Figure 7-20](#Twooutsetborders).
  prefs: []
  type: TYPE_NORMAL
- en: Again, notice that one browser shifts the colors to the lighter and darker,
    while another just shifts the “shadowed” sides to be darker than blue. This is
    why, if a specific set of colors is desired, authors usually set the exact colors
    they want instead of using a border style like `outset` and leaving the result
    up to the browser. You’ll soon see just how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0720](assets/css5_0720.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-20\. Two outset borders
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Multiple styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can define more than one style for a given border. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The result is a paragraph with a solid top border, a dashed right border, a
    dotted bottom border, and a solid left border.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again we see the TRBL order of values, just as we saw in our discussion of
    setting `padding` with multiple values. All the same rules about value replication
    apply to border styles, just as they did with padding. Thus, the following two
    statements would have the same effect, as depicted in [Figure 7-21](#Equivalentstylerules):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0721](assets/css5_0721.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-21\. Equivalent style rules
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Single-side styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you might want to set border styles for just one side of an element
    box, rather than all four. That’s where the single-side border style properties
    come in.
  prefs: []
  type: TYPE_NORMAL
- en: Single-side border style properties are fairly self-explanatory. If you want
    to change the style for the bottom border, for example, you use `border-bottom-style`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not uncommon to see `border` used in conjunction with a single-side property.
    Suppose you want to set a solid border on three sides of a heading, but not have
    a left border, as shown in [Figure 7-22](#Removingtheleftborder).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0722](assets/css5_0722.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-22\. Removing the left border
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can accomplish this in two ways, each one equivalent to the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s important to remember is that if you’re going to use the second approach,
    you have to place the single-side property *after* the shorthand, as is usually
    the case with shorthand. This is because `border-style: solid` is actually a declaration
    of `border-style: solid solid solid solid`. If you put `border-style-left: none`
    before the `border-style` declaration, the shorthand’s value will override the
    single-side value of `none`.'
  prefs: []
  type: TYPE_NORMAL
- en: Logical styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want your borders to be styled in relation to where they sit in the writing
    mode’s flow, rather than be pinned to physical directions, the following are the
    border-styling properties for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `padding-block` and `padding-inline`, `border-block-style` and `border-inline-style`
    each accept one or two values. If two values are given, they are taken in the
    order of *start end*. Given the following CSS, you’ll get a result like that shown
    in [Figure 7-23](#logical-border-styles):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0723](assets/css5_0723.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-23\. Logical border styles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You could get the same result in the following, more verbose manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the two patterns is the number of characters you
    have to type, so really, which one you use is up to you.
  prefs: []
  type: TYPE_NORMAL
- en: Border Widths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve assigned a border a style, the next step is to give it some width,
    most easily by using the property `border-width` or one of its cousin properties.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these properties is used to set the width on a specific border side,
    just as with the margin properties.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of early 2023, border widths *still* cannot be given percentage values, which
    is rather a shame.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four ways to assign width to a border: you can give it a length value
    such as `4px` or `0.1em`, or use one of three keywords. These keywords are `thin`,
    `medium` (the default value), and `thick`. According to the specification, `thick`
    is 5px, wider than `medium`’s 3px, which is wider than the 1-px `thin`—which makes
    sense.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-24](#Therelationofborder-widthkeywordstoeachother) illustrates these
    three keywords, and how they relate to one another and to the content they surround.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0724](assets/css5_0724.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-24\. The relation of border-width keywords to each other
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s suppose a paragraph has a background color and a border style set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The border’s width is, by default, `medium`. We can change that easily enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Border widths can be taken to fairly ridiculous extremes, such as setting 1,000-pixel
    borders, though this is rarely necessary (or advisable). It is important to remember
    that borders, and therefore `border-width` values, participate in the box model,
    impacting an element’s size.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to set widths for individual sides, using two familiar methods.
    The first is to use any of the specific properties mentioned at the beginning
    of the section, such as `border-bottom-width`. The other way is to use value replication
    in `border-width`, following the usual TRBL pattern, which is illustrated in [Figure 7-25](#Valuereplicationandunevenborderwidths):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0725](assets/css5_0725.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-25\. Value replication and uneven border widths
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Logical border widths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That said, if you want to set border widths based on writing direction, you
    can use the usual complement of logical counterparts to go with the physical properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw with the border widths, these can either be set one side at a time,
    or compressed into the `border-block-width` and `border-inline-width` properties.
    The following two rules will have exactly the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: No border at all
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve talked only about using a visible border style such as `solid`
    or `outset`. Let’s consider what happens when you set `border-style` to `none`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Even though the border’s width is `20px`, the style is set to `none`. In this
    case, not only does the border’s style vanish, so does its width. The border just
    ceases to be. Why?
  prefs: []
  type: TYPE_NORMAL
- en: As you may remember, the terminology used earlier in the chapter indicated that
    a border with a style of `none` *does not exist*. Those words were chosen very
    carefully, because they help explain what’s going on here. Since the border doesn’t
    exist, it can’t have any width, so the width is automatically set to `0` (zero),
    no matter what you try to define.
  prefs: []
  type: TYPE_NORMAL
- en: After all, if a drinking glass is empty, you can’t really describe it as being
    half-full of nothing. You can discuss the depth of a glass’s contents only if
    it has actual contents. In the same way, talking about the width of a border makes
    sense only in the context of a border that exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important to keep in mind because it’s a common mistake to forget to
    declare a border style. This leads to all kinds of developer frustration because,
    at first glance, the styles appear correct. Given the following rule, though,
    no `<h1>` element will have a border of any kind, let alone one that’s 20 pixels
    wide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the default value of `border-style` is `none`, failure to declare a style
    is exactly the same as declaring `border-style: none`. Therefore, if you want
    a border to appear, you need to declare a border style.'
  prefs: []
  type: TYPE_NORMAL
- en: Border Colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to the other aspects of borders, setting the color is pretty easy.
    CSS uses the physical shorthand property `border-color`, which can accept up to
    four color values at one time. (See [“Color”](ch05.html#color) for the valid value
    formats of colors.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are fewer than four values, value replication takes effect as usual.
    So if you want `<h1>` elements to have thin gray top and bottom borders with thick
    green side borders, and medium gray borders around `<p>` elements, the following
    styles will suffice, with the result shown in [Figure 7-26](#Bordershavemanyaspects):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0726](assets/css5_0726.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-26\. Borders have many aspects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A single `color` value will be applied to all four sides, as with the paragraph
    in the previous example. On the other hand, if you supply four color values, you
    can get a different color on each side. Any type of color value can be used, from
    named colors to hexadecimal and HSL values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you don’t declare a color, the default is `currentcolor`, which is always
    the foreground color of the element. Thus, the following declaration will be displayed
    as shown in [Figure 7-27](#Bordercolorsbasedontheelementsforegroundandthevalueoftheborder-colorproperty):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0727](assets/css5_0727.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-27\. Border colors based on the element’s foreground and the value
    of the `border-color` property
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The result is that the first paragraph has a gray border, having used the foreground
    color of the paragraph. The second paragraph, however, has a black border because
    that color was explicitly assigned using `border-color`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Physical single-side border color properties exist as well. They work in much
    the same way as the single-side properties for border style and width. One way
    to give headings a solid black border with a solid gray right border is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Logical border colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as with border styles and widths, logical properties shadow the physical
    properties: two shorthand, four longhand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the following two rules would have the exact same outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Transparent borders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may recall, if a border has no style, it has no width. In some situations,
    however, you’ll want to create an invisible border that still has width. This
    is where the border color value `transparent` comes in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want a set of three links to have borders that are invisible by
    default, but look inset when the link is hovered. We can accomplish this by making
    the borders transparent in the nonhovered case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This will have the effect shown in [Figure 7-28](#using_transparent_borders).
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, `transparent` lets you use borders as if they were extra padding.
    Should you want to make them visible, the space is reserved, preventing a reflow
    of content when visible borders are added in.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0728](assets/css5_0728.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-28\. Using transparent borders
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Single-Side Shorthand Border Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It turns out that shorthand properties such as `border-color` and `border-style`
    aren’t always as helpful as you’d think. For example, you might want to apply
    a thick, gray, solid border to all `<h1>` elements, but only along the bottom.
    If you limit yourself to the properties we’ve discussed so far, you’ll have a
    hard time applying such a border. Here are two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Neither is really convenient, given all the typing involved. Fortunately, a
    better solution is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This will apply the values to the bottom border alone, as shown in [Figure 7-29](#Settingabottomborderwithashorthandproperty),
    leaving the others to their defaults. Since the default border style is `none`,
    no borders appear on the other three sides of the element.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0729](assets/css5_0729.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-29\. Setting a bottom border with a shorthand property
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you may have guessed, CSS has four physical shorthand properties and four
    logical shorthand properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use these properties to create some complex borders, such as those shown
    in [Figure 7-30](#Verycomplexborders):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0730](assets/css5_0730.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-30\. Very complex borders
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can see, the order of the actual values doesn’t really matter. The following
    three rules will yield exactly the same border effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also leave out some values and let their defaults kick in, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Since no border color is declared, the default value (`currentcolor`) is applied
    instead. Just remember that if you leave out a border style, the default value
    of `none` will prevent your border from existing.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, if you set only a style, you will still get a border. Let’s say
    you want a top border style of `dashed` and you’re willing to let the width default
    to `medium` and the color be the same as the text of the element itself. All you
    need in such a case is the following markup (shown in [Figure 7-31](#Dashingacrossthetopofanelement)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0731](assets/css5_0731.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-31\. Dashing across the top of an element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Also note that since each of these border-side properties applies only to a
    specific side, there isn’t any possibility of value replication—it wouldn’t make
    any sense. There can be only one of each type of value: that is, only one width
    value, only one color value, and only one border style. So don’t try to declare
    more than one value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This entire statement is invalid, and a user agent will ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: Global Borders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we come to the shortest shorthand border property of all: `border`, which
    affects all four sides of the element equally.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This property has the advantage of being very compact, although that brevity
    introduces a few limitations. Before we worry about that, let’s see how `border`
    works. If you want all `<h1>` elements to have a thick silver border, the following
    declaration would display as shown in [Figure 7-32](#Areallyshortborderdeclaration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0732](assets/css5_0732.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-32\. A really short border declaration
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The drawback with `border` is that you can define only a single global style,
    width, and color. The values you supply for `border` will apply to all four sides
    equally. If you want the borders to be different for a single side, use some of
    the other border properties. Then again, it’s possible to turn the cascade to
    your advantage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The second rule overrides the width value for the left border assigned by the
    first rule, thus replacing `thick` with `20px`, as you can see in [Figure 7-33](#Usingthecascadetoonesadvantage).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0733](assets/css5_0733.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-33\. Using the cascade to your advantage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You still need to take the usual precautions with shorthand properties: if
    you omit a value, the default will be filled in automatically. This can have unintended
    effects. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve failed to assign a `border-style`, which means that the default
    value of `none` will be used, and thus no `<h4>` elements will have any border
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Borders and Inline Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Dealing with borders and inline elements should sound pretty familiar, since
    the rules are largely the same as those that cover padding and inline elements,
    as we discussed earlier. Still, we’ll briefly touch on the topic again.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, no matter how thick you make your borders on inline elements, the line
    height of the element won’t change. Let’s set block-start and block-end borders
    on boldfaced text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As seen before, adding borders to the block start and end will have absolutely
    no effect on the line height. However, since borders are visible, they’ll be drawn—as
    illustrated in [Figure 7-34](#Bordersoninlinenonreplacedelements).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0734](assets/css5_0734.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-34\. Borders on inline nonreplaced elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The borders have to go somewhere. That’s where they went. They get painted over
    the preceding line of text and under the next line of text if need be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, all of this is true only for the block-start and -end sides of inline
    elements; the inline sides are a different story. If you apply a border along
    an inline side, not only will they be visible, but they’ll displace the text around
    them, as you can see in [Figure 7-35](#Aninlinenonreplacedelementwithaleftborder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0735](assets/css5_0735.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-35\. Inline nonreplaced elements with inline-start borders
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With borders, just as with padding, the browser’s calculations for line breaking
    are not directly affected by any box properties set for inline nonreplaced elements.
    The only effect is that the space taken up by the borders may shift portions of
    the line over a bit, which may in turn change which word is at the end of the
    line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The way borders are (or aren’t) drawn at the ends of each line box can be altered
    with the property `box-decoration-break`. See [Chapter 6](ch06.html#basic-visual-formatting)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'With replaced elements such as images, on the other hand, the effects are very
    much like those we saw with padding: a border *will* affect the height of the
    lines of text, in addition to shifting text around to the sides. Thus, assuming
    the following styles, we get a result like that seen in [Figure 7-36](#Bordersoninlinereplacedelements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0736](assets/css5_0736.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-36\. Borders on inline replaced elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Rounding Border Corners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can soften the square corners of element borders—and actually, the entire
    background area—by using the property `border-radius` to define a rounding distance
    (or two). In this particular case, we’re going to start with the shorthand physical
    property and then mention the individual physical properties at the end of the
    section, after which we’ll check out the logical equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: The radius of a rounded border corner is the radius of a circle or ellipse,
    one-quarter of which is used to define the path of the border’s rounding. We’ll
    start with circles, because they’re a little easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we want to round the corner of an element so that each corner is pretty
    obviously rounded. Here’s one way to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: That will have the result shown in [Figure 7-37](#Howborderradiiarecalculated),
    where circle diagrams have been added to two of the corners. (The same rounding
    is done in all four corners.)
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0737](assets/css5_0737.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-37\. How border radii are calculated
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Focus on the top-left corner. There, the border begins to curve 2 em below the
    top of the border, and 2 em to the right of the left side of the border. The curve
    follows along the outside of the 2-em-radius circle.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to draw a box that contained just the part of the top-left corner
    that is curved, that box would be 2 em wide and 2 em tall. The same would happen
    in the bottom- right corner.
  prefs: []
  type: TYPE_NORMAL
- en: 'With single length values, we get circular corner-rounding shapes. If a single
    percentage is used, the results are far more oval. For example, consider the following,
    illustrated in [Figure 7-38](#Howpercentageborderradiiarecalculated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0738](assets/css5_0738.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-38\. How percentage border radii are calculated
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Again, let’s focus on the top-left corner. On the left edge, the border curve
    begins at the point 33% of the element box’s height down from the top. In other
    words, if the element box is 100 pixels tall from the top border edge to the bottom
    border edge, the curve begins 33 pixels from the top of the element box.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, on the top edge, the curve begins at the point 33% of the element
    box’s width from the left edge. So if the box is (say) 600 pixels wide, the curve
    begins 198 pixels from the left edge, because 600 × 0.33 = 198.
  prefs: []
  type: TYPE_NORMAL
- en: The shape of the curve between those two points is identical to the top-left
    edge of an ellipse whose horizontal radius is 198 pixels long, and whose vertical
    radius is 33 pixels long. (This is the same as an ellipse with a horizontal axis
    of 396 pixels and a vertical axis of 66 pixels.)
  prefs: []
  type: TYPE_NORMAL
- en: The same thing is done in each corner, leading to a set of corner shapes that
    mirror each other, rather than being identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supplying a single length or percentage value for `border-radius` means all
    four corners will have the same rounding shape. As you may have spotted in the
    syntax definition, you can supply `border-radius` with up to four values. Because
    `border-radius` is a physical property, the values go in clockwise order from
    top left to bottom left, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This TL-TR-BR-BL can be remembered with the mnemonic “TiLTeR BuRBLe,” if you’re
    inclined to such things. The important thing is that the rounding starts in the
    top left and works its way clockwise from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a value is omitted, the missing values are filled in using a pattern like
    that used for `padding`, and so on. If there are three values, the fourth is copied
    from the second. If there are two, the third is copied from the first, and the
    fourth from the second. If there’s just one, the missing three are copied from
    the first. Thus, the following two rules are identical and will have the result
    shown in [Figure 7-39](#Avarietyofroundedcorners):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0739](assets/css5_0739.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-39\. A variety of rounded corners
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There’s an important aspect to [Figure 7-39](#Avarietyofroundedcorners): the
    rounding of the content area’s background along with the rest of the background.
    See how the silver curves, and the period sits outside it? That’s the expected
    behavior when the content area’s background is different from the padding background
    (you’ll see how to do that in [Chapter 8](ch08.html#backgrounds)) and the curving
    of a corner is large enough to affect the boundary between content and padding.'
  prefs: []
  type: TYPE_NORMAL
- en: This is because while `border-radius` changes the way the border and background(s)
    of an element are drawn, it does *not* change the shape of the element box. Consider
    the situation depicted in [Figure 7-40](#Elementswithroundedcornersarestillboxes).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0740](assets/css5_0740.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-40\. Elements with rounded corners are still boxes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here, we have an element that’s been floated to the left, and other text flowing
    past it. The border corners are completely round, using `border-radius: 50%` on
    a square element. Some of its text is sticking out past the rounded corners. Beyond
    the rounded corners, the page background is visible where the corners *would*
    have been, were they not rounded.'
  prefs: []
  type: TYPE_NORMAL
- en: So at a glance, you might assume that the element has been reshaped from box
    to circle (technically to ellipse), and the text just happens to stick out of
    it. But look at the text flowing past the float. It doesn’t flow into the area
    the rounded corners “left behind.” That’s because the corners of the floated element
    are still there. They’re just not visibly filled by border and background, thanks
    to `border-radius`.
  prefs: []
  type: TYPE_NORMAL
- en: Rounded corner clamping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'What happens if a radius value is so large that it would spill into other corners?
    For example, what happens with `border-radius: 100%`? Or `border-radius: 9999px`
    on an element that’s nowhere near 10,000 pixels tall or wide?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In any such case, the rounding is “clamped” to the maximum it can be for a
    given quadrant of the element. Making sure that buttons always look like round-ended-pill
    shapes can be done like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: That will just cap off the shortest ends of the element (usually the left and
    right sides, but no guarantees) to be smooth semicircular caps.
  prefs: []
  type: TYPE_NORMAL
- en: More complex corner shaping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve seen how assigning a single radius value to a corner shapes
    it, let’s talk about what happens when corners get two values—and, more importantly,
    how they get those values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we want corners to be rounded by 3 character units horizontally,
    and 1 character unit vertically. We can’t just use `border-radius: 3ch 1ch` because
    that will round the top-left and bottom-right corners by `3ch`, and the other
    two corners by `1ch` each. Inserting a forward slash will get us what we’re after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'This is functionally equivalent to saying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The way this syntax works, the horizontal radius of each corner’s rounding ellipse
    is given, and then after the slash, the vertical radius of each corner is given.
    In both cases, the values are in TiLTeR BuRBLe order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simpler example, illustrated in [Figure 7-41](#Ellipticalcornerrounding):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0741](assets/css5_0741.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-41\. Elliptical corner rounding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each corner is rounded by 1 em along the horizontal axis, and 2 em along the
    vertical axis, in the manner you saw in detail in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a slightly more complex version, providing two lengths to either side
    of the slash, as depicted in [Figure 7-42](#Differentellipticalroundingcalculations):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0742](assets/css5_0742.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-42\. Different elliptical rounding calculations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this case, the top-left and bottom-right corners are curved 2.5 em along
    the horizontal axis, and 1.5 em along the vertical axis. The top-right and bottom-left
    corners, on the other hand, are curved 2 em along the horizontal and 3 along the
    vertical.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, you use horizontal values before the slash, and vertical after. If
    we’d wanted to make the top-left and bottom-right corners rounded 1 em horizontally
    and 1 em vertically (a circular rounding), the values would have been written
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Percentages are also fair game here. If we want to round the corners of an
    element so that the sides are fully rounded but extend only 2 character units
    into the element horizontally, we’d write it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Corner blending
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, the corners we’ve rounded have been pretty simple—always the same width,
    style, and color. That won’t always be the case, though. What happens if a thick,
    red, solid border is rounded into a thin, dashed green border?
  prefs: []
  type: TYPE_NORMAL
- en: The specification directs that the rounding cause as smooth a blend as possible
    when it comes to the width. When rounding from a thicker border to a thinner border,
    the width of the border should gradually shrink throughout the curve of the rounded
    corner.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to differing styles and colors, the specification is less clear
    about how this should be accomplished. Consider the various samples shown in [Figure 7-43](#Roundedcornersupclose).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0743](assets/css5_0743.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-43\. Rounded corners up close
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first is a simple rounded corner, with no variation in color, width, or
    style. The second shows rounding from one thickness to another. You can visualize
    this second case as defining a circular shape on the outer edge and an elliptical
    shape on the inner edge.
  prefs: []
  type: TYPE_NORMAL
- en: In the third case, the color and thickness stay the same, but the corner curves
    from a solid style on the left to a double-line style on top. The transition between
    styles is abrupt and occurs at the halfway point in the curve.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth example shows a transition from a thick solid to a thinner double
    border. Note the placement of the transition, which is *not* at the halfway point.
    It is instead determined by taking the ratio of the two borders’ thicknesses and
    using that to find the transition point. Let’s assume the left border is 10 pixels
    thick, and the top border 5 pixels thick. By summing the two to get 15 pixels,
    the left border gets 2/3 (10/15), and the top border 1/3 (5/15). Thus, the left
    border’s style is used in two-thirds of the curve, and the top border’s style
    in one-third the curve. The width is still smoothly changed over the length of
    the curve.
  prefs: []
  type: TYPE_NORMAL
- en: The fifth and sixth examples show what happens with color added to the mix.
    Effectively, the color stays linked to the style. This hard transition between
    colors is common behavior among browsers as of late 2022, but it may not always
    be so. The specification explicitly states that user agents *may* blend from one
    border color to another by using a linear gradient. Perhaps one day they will,
    but for now, the changeover is sharp.
  prefs: []
  type: TYPE_NORMAL
- en: 'The seventh example in [Figure 7-43](#Roundedcornersupclose) shows a case we
    haven’t really discussed: “What happens if the borders are equal to or thicker
    than the value of `border-radius`?” In this case, the outside of the corner is
    rounded, but the inside is not, as shown. This would occur with code like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Individual rounding properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After that tour of `border-radius`, you might be wondering whether you can just
    round one corner at a time. Yes, you can! First, let’s consider the physical corners,
    which are what `border-radius` brings together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each property sets the curve shape for its corner and doesn’t affect the others.
    The fun part is that if you supply two values, one for the horizontal radius and
    one for the vertical radius, there is *no* slash separating them. Really. This
    means that the following two rules are functionally equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual corner border radius properties are mostly useful for setting
    a common corner rounding and then overriding just one. Thus, a comic-book-like
    word balloon shape could be done as follows, with the result shown in [Figure 7-44](#links-shaped-like-balloons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0744](assets/css5_0744.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-44\. Links shaped like word balloons
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to the physical corners, CSS also has logical corners.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be thinking, “Hold on, that’s not what the other logical properties
    looked like!” And that’s true: these are a fair bit different. That’s because
    if we had a property like `border-block-start-radius`, it would apply to both
    corners along the block-start edge. But if you also had `border-inline-start-radius`,
    it would apply to both corners on the inline-start edge, one of which is also
    on the block-start edge.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So the way the logical border radius properties work is they’re labeled in
    the pattern *border-block-inline-radius*. Thus, `border-start-end-radius` sets
    the radius of the corner that’s at the junction of the block-start and inline-end
    edges. Take the following example, which is illustrated in [Figure 7-45](#logical-border-radius):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0745](assets/css5_0745.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-45\. Rounding the block-start, inline-end corner
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that you can use the same space-separated value pattern for defining
    an elliptical corner radius, as shown earlier in the section for `border-top-left-radius`
    and friends. However, the value is still in the pattern of horizontal radius,
    then vertical radius, instead of being relative to the block and inline flow directions.
    This seems like a bit of an oversight in CSS, but it is how things are as of late
    2022.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that, as you’ve seen, corner shaping affects the
    background and (potentially) the padding and content areas of the element, but
    not any image borders. Wait a minute, image borders? What are those? Glad you
    asked!
  prefs: []
  type: TYPE_NORMAL
- en: Image Borders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The various border styles are nice enough but are still fairly limited. What
    if you want to create a really complicated, visually rich border around some of
    your elements? Back in the day, we’d create complex multirow tables to achieve
    that sort of effect, but thanks to image borders, there’s almost no limit to the
    kinds of borders you can create.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and slicing a border image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re going to use an image to create the borders of an image, you’ll need
    to define it or fetch it from somewhere. The `border-image-source` property is
    how you tell the browser where to look for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s load an image of a single circle to be used as the border image, using
    the following styles, whose result is shown in [Figure 7-46](#Definingaborderimagessource):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0746](assets/css5_0746.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-46\. Defining a border image’s source
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are a few points to note here. First, without the `border: 25px solid`
    declaration, there would have been no border at all. Remember, if the value of
    `border-style` is `none`, the width of the border is 0\. So to make a border image
    appear, you need to have a border, which means declaring a `border-style` value
    other than `none` or `hidden`. It doesn’t have to be `solid`. Second, the value
    of `border-width` determines the actual width of the border images. Without a
    declared value, it will default to `medium`, which is 3 pixels. If the border
    image fails to load, the border is the `border-color` value.'
  prefs: []
  type: TYPE_NORMAL
- en: OK, so we set up a border area 25 pixels wide and then applied an image to it.
    That gave us the same circle in each of the four corners. But why did it appear
    only there and not along the sides? The answer is found in the way the physical
    property `border-image-slice` is defined.
  prefs: []
  type: TYPE_NORMAL
- en: What `border-image-slice` does is establish a set of four slice-lines that are
    laid over the image, and where they fall determines how the image will be sliced
    up for use in an image border. The property takes up to four values, defining
    (in order) offsets from the top, right, bottom, and left edges. Yep, there’s that
    TRBL pattern again, which pegs `border-image-slice` as a physical property. And
    value replication is also in effect here, so a single value will be used for all
    four offsets. [Figure 7-47](#Variousslicingpatterns) shows a small sampling of
    offset patterns, all based on percentages.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0747](assets/css5_0747.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-47\. Various slicing patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, no logical-property equivalent exists for `border-image-slice`.
    If the proposed `logical` keyword, or something equivalent, is ever adopted and
    implemented, using `border-image-slice` in a writing-flow-relative fashion will
    be possible. There are also no single-side properties; that is, there is no such
    thing as `border-left-image-slice`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take an image that has a 3 × 3 grid of circles, each a different
    color, and slice it up for use in an image border. [Figure 7-48](#Anall-aroundimageborder)
    shows a single copy of this image and the resulting image border:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Yikes! That’s…interesting. The stretchiness of the sides is the default behavior,
    and it makes a fair amount of sense, as you’ll see (and find out how to change)
    in [“Altering the repeat pattern”](#altering-the-repeat-pattern). Beyond that
    effect, you can see in [Figure 7-48](#Anall-aroundimageborder) that the slice-lines
    fall right between the circles, because the circles are all the same size and
    so one-third offsets place the slice-lines right between them. The corner circles
    go into the corners of the border, and each side’s circle is stretched out to
    fill its side.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0748](assets/css5_0748.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-48\. An all-around image border
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: (“Wait, what happened to the gray circle in the middle?” you may wonder. It’s
    an interesting question! For now, just accept it as one of life’s little mysteries,
    albeit a mystery that will be explained later in this section.)
  prefs: []
  type: TYPE_NORMAL
- en: All right, so why did our first border image example, back at the beginning
    of the section, place images only in the corners of the border area instead of
    all the way around it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Anytime the slice-lines meet or go past each other, the corner images are created
    but the side images are made empty. This is easiest to visualize with `border-image-slice:
    50%`. In that case, the image is sliced into four quadrants, one for each corner,
    with nothing remaining for the sides.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, any value *above* `50%` has the same basic result, even though the
    image isn’t sliced into neat quadrants anymore. Thus, for `border-image-slice:
    100%`—which is the default value—each corner gets the entire image, and the sides
    are left empty. A few examples of this effect are shown in [Figure 7-49](#Variouspatternsthatpreventsideslices).'
  prefs: []
  type: TYPE_NORMAL
- en: That’s why we had to have a 3 × 3 grid of circles when we wanted to go all the
    way around the border area, corners, and sides.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0749](assets/css5_0749.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-49\. Various patterns that prevent side slices
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In addition to using percentage offsets, we also can define the offsets by
    using a number. Not a length, as you might assume, but a bare number. In raster
    images like PNGs or JPEGs, the number corresponds to pixels in the image on a
    1:1 basis. If you have a raster image and want to define 25-pixel offsets for
    the slice-lines, this is how to do that, as illustrated in [Figure 7-50](#Numberslicing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0750](assets/css5_0750.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-50\. Number slicing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Yikes again! What happened there is that the raster image is 150 × 150 pixels,
    so each circle is 50 × 50 pixels. Our offsets, though, were only `25`, as in 25
    pixels. So the slice-lines were placed on the image as shown in [Figure 7-51](#Slicelinesat25pixels).
  prefs: []
  type: TYPE_NORMAL
- en: This begins to give us an idea of why the default behavior for the side images
    is to stretch them. Note how the corners flow into the sides, visually speaking.
  prefs: []
  type: TYPE_NORMAL
- en: If you change the image to one that has a different size, numeric offsets don’t
    adapt to the new size, whereas percentages do. The interesting thing about number
    offsets is that they work just as well on nonraster images, like SVGs, as they
    do on rasters. So do percentages. In general, it’s probably best to use percentages
    for your slicing offsets whenever possible, even if that means doing a little
    math to get exactly the right percentages.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0751](assets/css5_0751.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-51\. Slice-lines at 25 pixels
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now let’s address the curious case of the image’s center. In the previous examples,
    a circle is at the center of the 3 × 3 grid of circles, but it disappears when
    the image is applied to the border. In the preceding example, in fact, not only
    the middle circle was missing, but the entire center slice. This dropping of the
    center slice is the default behavior for image slicing, but you can override it
    by adding a `fill` keyword to the end of your `border-image-slice` value. If we
    add `fill` to the previous example, as shown here, we’ll get the result shown
    in [Figure 7-52](#Usingthefillslice):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: There’s the center slice, filling up the element’s background area. In fact,
    it’s drawn over the top of whatever background the element might have, including
    any background images or color, so you can use it as a substitute for the background
    or as an addition to it.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0752](assets/css5_0752.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-52\. Using the fill slice
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may have noticed that all our border areas have been a consistent width
    (usually `25px`). This doesn’t have to be the case, regardless of how the border
    image is actually sliced up. Suppose we take the circles border image we’ve been
    using, slice it by thirds as we have, but make the border widths different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: This would have a result like that shown in [Figure 7-53](#Unevenborderimagewidths).
    Even though the slice-lines are intrinsically set to 50 pixels (via `50`), the
    resulting slices are resized to fit into the border areas they occupy.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0753](assets/css5_0753.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-53\. Uneven border image widths
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Altering the image widths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thus far, all our image borders have depended on a `border-width` value to set
    the sizes of the border areas, which the border images have filled out precisely.
    That is, if the top border side is 25 pixels tall, the border image that fills
    it will be 25 pixels tall. If you want to make the images a different size than
    the area defined by `border-width`, you can use the physical property `border-image-width`.
  prefs: []
  type: TYPE_NORMAL
- en: The basic fact to understand about `border-image-width` is that it’s very similar
    to `border-image-slice`, except that `border-image-width` slices up the border
    box itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand what this means, let’s start with length values. We’ll set up
    1-em border widths like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: That pushes slice-lines 1 em inward from each of the border area’s sides, as
    shown in [Figure 7-54](#Placingslice-linesfortheborderimageswidth).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0754](assets/css5_0754.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-54\. Placing slice-lines for the border image’s width
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So the top and bottom border areas are 1 em tall, the right and left border
    areas are 1 em wide, and each corner is 1 em tall and wide. Given that, the border
    images created with `border-image-slice` are filled into those border areas in
    the manner prescribed by `border-image-repeat` (which we’ll get to shortly). Therefore,
    in [Figure 7-55](#css5_border_images-with-and-without), we could have had a `border-width`
    of 0 and still made the border images show up, by using `border-image-width`.
    This is useful if you want to have a solid border as a fallback in case the border
    image doesn’t load, but don’t want to make it as thick as the image border would
    be. You could use something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0755](assets/css5_0755.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-55\. A border with and without its border image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This allows for a 12-pixel star border to be replaced with a 2-pixel solid border
    if border images aren’t available. Remember that if the image border *does* load,
    you’ll need to leave enough space for it to show up without overlapping the content
    (by default, that is). You’ll see how to mitigate this problem in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve established how the width slice-lines are placed, the way percentage
    values are handled should make sense, as long as you keep in mind that the offsets
    are with respect to the overall border box, *not* each border side. For example,
    consider the following declaration, illustrated in [Figure 7-56](#Placementofpercentageslice-lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0756](assets/css5_0756.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-56\. Placement of percentage slice-lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As with length units, the lines are offset from their respective sides of the
    border box. The distance they travel is with respect to the border box. A common
    mistake is to assume that a percentage value is with respect to the border area
    defined by `border-width`; that is, given a `border-width` value of `30px`, the
    result of `border-image-width: 33.333%;` will be 10 pixels. But no! It’s one-third
    the overall border box along that axis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way in which the behavior of `border-image-width` differs from `border-image-slice`
    is in how it handles slices passing each other, such as in this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may recall, for `border-image-slice`, if the slices pass each other,
    then the side areas (top, right, bottom, and/or left) are made empty. With `border-image-width`,
    the values are proportionally reduced until they no longer pass each other. So,
    given the preceding value of `75%`, the browser will treat that as if it were
    `50%`. Similarly, the following two declarations will have equivalent results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in both declarations, the right offset is twice the left value. That’s
    what is meant by proportionally reducing the values until they don’t overlap:
    in other words, until they no longer add up to more than 100%. The same would
    be done with top and bottom, were they to overlap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to number values for `border-image-width`, things get even more
    interesting. If you set `border-image-width: 1`, the border image areas will be
    determined by the value of `border-width`. That’s the default behavior. Thus,
    the following two declarations will have the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: You can increase or reduce the number values to get a certain multiple of the
    border area that `border-width` defines. [Figure 7-57](#Variousnumericborderimagewidths)
    shows a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'In each case, the number has been multiplied by the border area’s width or
    height, and the resulting value indicates the inward distance that the offset
    is placed from the relevant side. Thus, for an element that has `border-top-width`
    set to 3 pixels, `border-image-width: 10` will create a 30-pixel offset from the
    top of the element. Change `border-image-width` to `0.333`, and the top offset
    will be a lone pixel.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0757](assets/css5_0757.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-57\. Various numeric border image widths
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The last value, `auto`, is interesting in that its resulting values depend
    on the state of two other properties. If `border-image-source` has been explicitly
    defined by the author, `border-image-width: auto` uses the values that result
    from `border-image-slice`. Otherwise, it uses the values that result from `border-width`.
    These two declarations will have the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can mix up the value types for `border-image-width`. The following
    are all valid, and would be quite interesting to try out in live web pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with `border-image-slice`, no logical-property equivalent exists for `border-image-width`
    as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a border overhang
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, now that we can define these great big image slices and widths, how do
    we keep them from overlapping the content? We could add lots of padding, but that
    would leave huge amounts of space if the image fails to load, or if the browser
    doesn’t support border images. Handling such scenarios is what the physical property
    `border-image-outset` is built to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether you use a length or a number, `border-image-outset` pushes
    the border image area outward, beyond the border box, in a manner similar to the
    way slice-lines are offset. The difference is that here, the offsets are outward,
    not inward. Just as with `border-image-width`, number values for `border-image-outset`
    are a multiple of the width defined by `border-width`—*not* `border-image-width`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with `border-image-slice` and `border-image-width`, no logical-property equivalent
    exists for `border-image-outset` as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this could be helpful, imagine that we want to use a border image
    but have a fallback of a thin solid border if the image isn’t available. We might
    start out like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have half an em of padding; at default browser settings, that
    will be about 8 pixels. That plus the 2-pixel solid border make a distance of
    10 pixels from the content edge to the outer border edge. So if the border image
    is available and rendered, it will fill not only the border area, but also the
    padding, bringing it right up against the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could increase the padding to account for this, but then if the image *doesn’t*
    appear, we’ll have a lot of excess padding between the content and the thin solid
    border. Instead, let’s push the border image outward, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: This is illustrated in [Figure 7-58](#Creatinganimageborderoverhang), and is
    compared to having no outset nor border image.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0758](assets/css5_0758.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-58\. Creating an image border overhang
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the first case, the image border has been pushed out far enough that rather
    than overlapping the padding area, the images actually overlap the margin area!
    We can also split the difference so that the image border is roughly centered
    on the border area, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: What you have to watch out for is pulling the image border too far outward,
    to the point that it overlaps other content or gets clipped off by the edges of
    the browser window (or both). If it does so, the image border will be painted
    between the previous element’s content and background, hiding the background,
    but will be partially obscured if subsequent content has a background or border.
  prefs: []
  type: TYPE_NORMAL
- en: Altering the repeat pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, you’ve seen a lot of stretched-out images along the sides of our examples.
    The stretching can be handy in some situations but a real eyesore in others. With
    the physical property `border-image-repeat`, you can change the way those sides
    are handled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with the previous border image properties, no logical-property equivalent
    exists for `border-image-repeat` as of late 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see these values in action and then discuss each in turn. You’ve already
    seen `stretch`, so the effect is familiar. Each side gets a single image, stretched
    to match the height and width of the border side area the image is filling.
  prefs: []
  type: TYPE_NORMAL
- en: The `repeat` value tiles the image until it fills up all the space in its border
    side area. The exact arrangement is to center the image in its side box, and then
    tile copies of the image outward from that point, until the border side area is
    filled. This can lead to some of the repeated images being clipped at the sides
    of the border area, as seen in [Figure 7-59](#Variousimagerepeatpatterns).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0759](assets/css5_0759.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-59\. Various image-repeat patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `round` value is a little different. With this value, the browser divides
    the length of the border side area by the size of the image being repeated inside
    it. It then rounds to the nearest whole number and repeats that number of images.
    In addition, it stretches or squashes the images so that they just touch each
    other as they repeat.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, suppose the top border side area is 420 pixels wide, and the
    image being tiled is 50 pixels wide. Dividing 420 by 50 results in 8.4, so that’s
    rounded to 8\. Thus, eight images are tiled. However, each is stretched to be
    52.5 pixels wide (420 ÷ 8 = 52.5). Similarly, if the right border side area is
    280 pixels tall, a 50-pixel-tall image will be tiled six times (280 ÷ 50 = 5.6,
    rounded to 6) and each image will be squashed to 46.6667 pixels tall (280 ÷ 6
    = 46.6667). If you look closely at [Figure 7-59](#Variousimagerepeatpatterns),
    you can see the top and bottom circles are stretched a bit, whereas the right
    and left circles show some squashing. The last value, `space`, starts out similar
    to `round`, in that the border side area’s length is divided by the size of the
    tiled image and then rounded. The differences are that the resulting number is
    always rounded *down*, and images are not distorted but instead distributed evenly
    throughout the border area.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, given a top border side area 420 pixels wide and a 50-pixel-wide image
    to be tiled, there will still be 8 images to repeat (8.4 rounded down is 8). The
    images will take up 400 pixels of space, leaving 20 pixels. That 20 pixels is
    divided by 8, which is 2.5 pixels. Half of that is put to each side of each image,
    meaning each image gets 1.25 pixels of space to either side. That puts 2.5 pixels
    of space between each image, and 1.25 pixels of space before the first and after
    the last image (see [Figure 7-60](#Avarietyofspacerepetitions) for examples of
    `space` repeating).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0760](assets/css5_0760.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-60\. A variety of space repetitions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Shorthand border image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The single shorthand physical property for border images is (unsurprisingly
    enough) `border-image`. The way it’s written is a little unusual, but it offers
    a lot of power without a lot of typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This property value has, it must be admitted, a somewhat unusual syntax. To
    get all the various properties for slices and widths and offsets, *and* be able
    to tell which is which, the decision was made to separate them by forward-slash
    symbols (`/`) and require them to be listed in a specific order: slice, then width,
    then offset. The image source and repeat values can go anywhere outside of that
    three-value chain. Therefore, the following rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: The shorthand clearly means less typing, but also less clarity at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is usually the case with shorthand properties, leaving out any of the individual
    pieces means that the defaults will be supplied. For example, if we supply just
    an image source, the rest of the properties will be set to their default values.
    Thus, the following two declarations will have exactly the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Some examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Border images can be tricky to internalize, conceptually speaking, so it’s worth
    looking at some examples of ways to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s set up a border with scooped-out corners and a raised appearance,
    like a plaque, with a fallback to a simple outset border of similar colors. We
    might use something like these styles and an image, which is shown in [Figure 7-61](#border-ex-01),
    along with both the final result and the fallback result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0761](assets/css5_0761.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-61\. A simple plaque effect and its older-browser fallback
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the side slices are perfectly set up to be stretched—everything
    about them is just repeated strips of color along the axis of stretching. They
    could also be repeated or rounded in this instance, but stretching works just
    fine. And since that’s the default value, we could have omitted the `border-image-repeat`
    declaration altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s try to create something oceanic: an image border that has waves
    marching all the way around. Since we don’t know how wide or tall the element
    will be ahead of time, and we want the waves to flow from one to another, we’ll
    use `round` to take advantage of its scaling behavior while getting in as many
    waves as will reasonably fit. You can see the result in [Figure 7-62](#wavy-border),
    along with the image that’s used to create the effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0762](assets/css5_0762.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-62\. A wavy border
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You should be wary of one issue here, which is what happens if you add in an
    element background. Just to make the situation clear, we’ll add a red background
    to this element, with the result shown in [Figure 7-63](#border-ex-03):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'See how the background color is visible between the waves? That’s because the
    wave image is a PNG with transparent bits, and the combination of image-slice
    widths and outset enable some of the background area to be visible through the
    transparent parts of the border. This can be a problem, because in some cases
    you’ll want to use a background color in addition to an image border—for the fallback
    case where the image fails to appear, if nothing else. Generally, this is a problem
    best addressed by either not needing a background for the fallback case, using
    `border-image-outset` to pull the image out far enough that no part of the background
    area is visible, or using `background-clip: padding-box` (see [“Clipping the Background”](ch08.html#clipping-the-background)).'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, border images have a lot of power. Be sure to use them wisely.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0763](assets/css5_0763.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-63\. The background area, visible through the image border
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Outlines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSS defines a special sort of element decoration called an *outline*. In practice,
    outlines are often drawn just beyond the borders, though (as you’ll see) this
    is not the whole story. As the specification puts it, outlines differ from borders
    in three basic ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Outlines are visible but do not take up layout space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User agents often render outlines on elements in the `:focus` state, precisely
    because they do not take up layout space and so do not change the layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Outlines may be nonrectangular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To these, we’ll add a fourth:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Outlines are an all-or-nothing proposition: you can’t style one side of a border
    independently from the others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start finding out exactly what all that means. First, we’ll run through
    the various properties, comparing them to their border-related counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Outline Styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Much as with `border-style`, you can set a style for your outlines. In fact,
    the values will seem familiar to anyone who’s styled a border before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two major differences are that outlines cannot have a `hidden` style, as
    borders can; and outlines can have the `auto` style. This style allows the user
    agent to get extra-fancy with the appearance of the outline, as explained in the
    CSS specification:'
  prefs: []
  type: TYPE_NORMAL
- en: The `auto` value permits the user agent to render a custom outline style, typically
    a style which is either a user interface default for the platform, or perhaps
    a style that is richer than can be described in detail in CSS—e.g., a rounded
    edge outline with semitranslucent outer pixels that appears to glow.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s also the case that `auto` allows browsers to use different outlines for
    different elements; e.g., the outline for a hyperlink may not be the same as the
    outline for a form input. When using `auto`, the value for `outline-width` may
    be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond those differences, outlines have all the same styles that borders have,
    as illustrated in [Figure 7-64](#Variousoutlinestyles).
  prefs: []
  type: TYPE_NORMAL
- en: The less obvious difference is that unlike `border-style`, `outline-style` is
    *not* a shorthand property. You can’t use it to set a different outline style
    for each side of the outline, because outlines can’t be styled that way. There
    is no `outline-top-style`. This is true for all the rest of the outline properties.
    Because of this aspect of `outline-style`, the one property serves both physical
    and logical layout needs.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0764](assets/css5_0764.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-64\. Various outline styles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Outline Width
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve decided on a style for the outline, assuming the style isn’t `none`,
    you can define a width for the outline.
  prefs: []
  type: TYPE_NORMAL
- en: There’s little to say about outline width that we didn’t already say about border
    width. If the outline style is `none`, the outline’s width is set to `0`. The
    `thick` value is wider than `medium`, which is wider than `thin`, but the specification
    doesn’t define exact widths for these keywords. [Figure 7-65](#Variousoutlinewidths)
    shows a few outline widths.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0765](assets/css5_0765.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-65\. Various outline widths
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As before, the real difference here is that `outline-width` is not a shorthand
    property, and serves both physical and logical layout needs. You can set only
    one width for the whole outline, and cannot set different widths for different
    sides. (The reasons for this will soon become clear.)
  prefs: []
  type: TYPE_NORMAL
- en: Outline Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Does your outline have a style and a width? Great! Let’s give it some color!
  prefs: []
  type: TYPE_NORMAL
- en: This is pretty much the same as `border-color`, with the caveat that it’s an
    all-or-nothing proposition—for example, there’s no `outline-left-color`.
  prefs: []
  type: TYPE_NORMAL
- en: The one major difference is the default value, `invert`. What `invert` is supposed
    to do is perform a “color conversion” on all pixels within the visible parts of
    the outline. The advantage to color inversion is that it can make the outline
    stand out in a wide variety of situations, regardless of what’s behind it.
  prefs: []
  type: TYPE_NORMAL
- en: However, as of late 2022, literally no browser engines support `invert`. (Some
    did for a while, but that support was removed.) Given this, if you use `invert`,
    it will be rejected by the browser, and the color keyword `currentcolor` will
    be used instead. (See [“Color Keywords”](ch05.html#color_keywords) for details.)
  prefs: []
  type: TYPE_NORMAL
- en: The only outline shorthand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, you’ve seen three outline properties that look like shorthand properties
    but aren’t. It’s time for the one outline property that *is* a shorthand: `outline`.'
  prefs: []
  type: TYPE_NORMAL
- en: It probably comes as little surprise that, like `border`, this is a convenient
    way to set the overall style, width, and color of an outline. [Figure 7-66](#Variousoutlines)
    illustrates a variety of outlines.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0766](assets/css5_0766.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-66\. Various outlines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Thus far, outlines seem very much like borders. So how are they different?
  prefs: []
  type: TYPE_NORMAL
- en: How They Are Different
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first major difference between borders and outlines is that outlines, like
    outset border images, don’t affect layout at all. In any way. They’re purely presentational.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand what this means, consider the following styles, illustrated in
    [Figure 7-67](#Outlineovermargin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0767](assets/css5_0767.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-67\. Outline over margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Looks normal, right? What you can’t see is that the outline is completely covering
    up the margin. If we put in a dotted line to show the margin edges, they’d run
    right along the outside edge of the outline. (We’ll deal with margins in the next
    section.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what’s meant by outlines not affecting layout. Let’s consider another
    example, this time with two `<span>` elements that are given outlines. You can
    see the results in [Figure 7-68](#Overlappingoutlines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0768](assets/css5_0768.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-68\. Overlapping outlines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The outlines don’t affect the height of the lines, but they also don’t shove
    the `<span>`s to one side or another. The text is laid out as if the outlines
    aren’t even there.
  prefs: []
  type: TYPE_NORMAL
- en: 'This raises an even more interesting feature of outlines: they are not always
    rectangular, nor are they always contiguous. Consider this outline applied to
    a `<strong>` element that breaks across two lines, as illustrated in two scenarios
    in [Figure 7-69](#Discontinuousandnon-rectangularoutlines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0769](assets/css5_0769.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-69\. Discontinuous and nonrectangular outlines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first case has two complete outline boxes, one for each fragment of the
    `<strong>` element. In the second case, with the longer `<strong>` element causing
    the two fragments to be stacked together, the outline is “fused” into a single
    polygon that encloses the fragments. You won’t find a border doing *that*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why CSS has no side-specific outline properties like `outline-right-style`:
    if an outline becomes nonrectangular, which sides are the right sides?'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, not every browser combines the inline fragments into a single
    contiguous polygon. In those that do not support this behavior, each fragment
    is still a self-contained rectangle, as in the first example in [Figure 7-69](#Discontinuousandnon-rectangularoutlines).
    Also, Firefox and Chrome have outlines follow `border-radius` rounding, whereas
    Safari keeps the corners rectangular.
  prefs: []
  type: TYPE_NORMAL
- en: Margins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The separation between most normal-flow elements occurs because of element *margins*.
    Setting a margin creates extra blank space around an element. *Blank space* generally
    refers to an area in which other elements cannot also exist and in which the parent
    element’s background is visible. [Figure 7-70](#Paragraphswithandwithoutmargins)
    shows the difference between two paragraphs without any margins and the same two
    paragraphs with margins.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0770](assets/css5_0770.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-70\. Paragraphs with, and without, margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The simplest way to set a margin is by using the physical property `margin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to set a quarter-inch margin on `<h1>` elements (a background
    color has been added so you can clearly see the edges of the content area):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This sets a quarter-inch of blank space on each side of an `<h1>` element, as
    illustrated in [Figure 7-71](#Settingamarginforh1elements). Here, dashed lines
    represent the margin’s outer edge, but the lines are purely illustrative and would
    not actually appear in a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0771](assets/css5_0771.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-71\. Setting a margin for `<h1>` elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `margin` property can accept any length of measure, whether in pixels, inches,
    millimeters, or ems. However, the default value for `margin` is effectively `0`,
    so if you don’t declare a value, by default, no margin should appear.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, however, browsers come with preassigned styles for many elements,
    and margins are no exception. For example, in CSS-enabled browsers, margins generate
    the “blank line” above and below each paragraph element. Therefore, if you don’t
    declare margins for the `<p>` element, the browser may apply some margins on its
    own. Whatever you declare will override the default styles.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s possible to set a percentage value for `margin`. The details of
    this value type are discussed in [“Percentages and Margins”](#percentages-and-margins).
  prefs: []
  type: TYPE_NORMAL
- en: Length Values and Margins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Any length value can be used in setting the margins of an element. It’s easy
    enough, for example, to apply 10 pixels of whitespace around paragraph elements.
    The following rule gives paragraphs a silver background, 10 pixels of padding,
    and a 10-pixel margin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds 10 pixels of space to each side of every paragraph, just beyond the
    outer border edge. You can just as easily use `margin` to set extra space around
    an image. Let’s say you want 1 em of space surrounding all images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: That’s all it takes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At times, you might desire a different amount of space on each side of an element.
    That’s easy as well, thanks to the value replication behavior we’ve used before.
    If you want all `<h1>` elements to have a top margin of 10 pixels, a right margin
    of 20 pixels, a bottom margin of 15 pixels, and a left margin of 5 pixels, here’s
    all you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also possible to mix up the types of length values you use. You aren’t
    restricted to using a single length type in a given rule, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 7-72](#Mixed-valuemargins) shows, with a little extra annotation, the
    results of this declaration.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0772](assets/css5_0772.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-72\. Mixed-value margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Percentages and Margins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can set percentage values for the margins of an element. As with padding,
    percentage margin values are computed in relation to the width of the parent element’s
    content area, so they can change if the parent element’s width changes in some
    way. For example, assume the following, which is illustrated in [Figure 7-73](#Parentwidthsandpercentages):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0773](assets/css5_0773.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-73\. Parent widths and percentages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that the top and bottom margins are consistent with the right and left
    margins; in other words, the percentage of top and bottom margins is calculated
    with respect to the element’s width, not its height. You’ve seen this before—in
    [“Padding”](#padding), in case you don’t remember—but it’s worth reviewing again,
    just to see how it operates.
  prefs: []
  type: TYPE_NORMAL
- en: Single-Side Margin Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen throughout the chapter, CSS has properties that let you set the
    margin on a single side of the box, without affecting the others. There are four
    physical side properties, four logical side properties, and two logical shorthand
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties operate as you’d expect. For example, the following two rules
    will give the same amount of margin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the following two rules will have the same outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Margin Collapsing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interesting and often overlooked aspect of the block-start and block-end
    margins on block boxes is that they *collapse* in normal-flow layout. This is
    the process by which two (or more) margins that interact along the block axis
    will collapse to the largest of the interacting margins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The canonical example of this is the space between paragraphs. Generally, that
    space is set using a rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: That sets every paragraph to have block-start and -end margins of `1em`. If
    margins *didn’t* collapse, then whenever one paragraph followed another, there
    would be 2 ems of space between them. Instead, there’s only 1; the two margins
    collapse together.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this a little more clearly, let’s return to the percentage-margin
    example. This time, we’ll add dashed lines to indicate where the margins fall,
    as shown in [Figure 7-74](#Collapsingmargins).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0774](assets/css5_0774.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-74\. Collapsing margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The example shows the separation distance between the contents of the two paragraphs.
    It’s 60 pixels, because that’s the wider of the two margins that are interacting.
    The 30-pixel block-start margin of the second paragraph is collapsed, leaving
    the first paragraph’s block-end margin in charge.
  prefs: []
  type: TYPE_NORMAL
- en: 'So in a sense, [Figure 7-74](#Collapsingmargins) is lying: if you take the
    CSS specification strictly at its word, the block-start (top) margin of the second
    paragraph is actually reset to 0\. It doesn’t stick into the block-end margin
    of the first paragraph because once it collapses, it isn’t there anymore. The
    end result is the same, though.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Margin collapsing also explains some oddities that arise when one element is
    inside another. Consider the following styles and markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The margin on the `<h1>` will push the edges of the `header` away from the content
    of the `<h1>`, right? Well, not entirely. See [Figure 7-75](#Marginscollapsingwithparents).
  prefs: []
  type: TYPE_NORMAL
- en: What happened? The inline-side margins took effect—we can see that from the
    way the text is moved over—but the block-start and block-end margins are gone!
  prefs: []
  type: TYPE_NORMAL
- en: Only they aren’t gone. They’re just sticking out of the `header` element, having
    interacted with the (zero-width) block-start margin of the `header` element. The
    magic of dashed lines in [Figure 7-76](#Marginscollapsingwithparentsrevealed)
    shows us what’s happening.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0775](assets/css5_0775.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-75\. Margins collapsing with parents
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![css5 0776](assets/css5_0776.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-76\. Margins collapsing with parents, revealed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There the block-axis margins are—pushing away any content that might come before
    or after the `<header>` element, but not pushing away the edges of the `<header>`
    itself. This is the intended result, even if it’s often not the *desired* result.
    As for *why* it’s intended, imagine what happens if you put a paragraph in a list
    item. Without the specified margin-collapsing behavior, the paragraph’s block-start
    (in this case, the top) margin would shove it downward, where it would be far
    out of alignment with the list item’s bullet (or number).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Margin collapsing can be interrupted by factors such as padding and borders
    on parent elements. For more details, see the discussion in [“Collapsing Block-Axis
    Margins”](ch06.html#collapsing-block-axis-margins).
  prefs: []
  type: TYPE_NORMAL
- en: Negative Margins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s possible to set negative margins for an element. This can cause the element’s
    box to stick out of its parent or to overlap other elements. Consider these rules,
    which are illustrated in [Figure 7-77](#Negativemarginsinaction):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0777](assets/css5_0777.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-77\. Negative margins in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first case, the math works out such that the paragraph’s computed width
    plus its inline-start and inline-end margins are exactly equal to the width of
    the parent `<div>`. So the paragraph ends up 2 ems wider than the parent element.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, the negative block-start and block-end margins move the
    paragraph’s block-start and -end outer edges inward, which is how it ends up overlapping
    the paragraphs before and after it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining negative and positive margins is actually very useful. For example,
    you can make a paragraph “punch out” of a parent element by being creative with
    positive and negative margins, or you can create a Mondrian effect with several
    overlapping or randomly placed boxes, as shown in [Figure 7-78](#Punchingoutofaparent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the negative bottom margin for the `mond` paragraph, the bottom of
    its parent element is pulled upward, allowing the paragraph to stick out of the
    bottom of its parent.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0778](assets/css5_0778.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-78\. Punching out of a parent
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Margins and Inline Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Margins can also be applied to inline elements. Let’s say you want to set block-start
    and block-end margins on strongly emphasized text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: This is allowed in the specification, but on an inline nonreplaced element,
    they will have absolutely no effect on the line height (the same as for padding
    and borders). And since margins are always transparent, you won’t even be able
    to see that they’re there. In effect, they’ll have no effect at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with padding, the layout effects change a bit when you apply margins to
    the inline-start and inline-end sides of an inline nonreplaced element, as illustrated
    in [Figure 7-79](#Aninlinenonreplacedelementwithaleftmargin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0779](assets/css5_0779.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-79\. An inline nonreplaced element with an inline-start margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note the extra space between the end of the word just before the inline nonreplaced
    element and the edge of the inline element’s background. You can add that extra
    space to both ends of the inline element if you want:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: As expected, [Figure 7-80](#Aninlinenonreplacedelementwith25-pixelsidemargins)
    shows a little extra space on the inline-start and -end sides of the inline element,
    and no extra space above or below it.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0780](assets/css5_0780.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-80\. An inline nonreplaced element with 25-pixel side margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, when an inline nonreplaced element stretches across multiple lines, the
    situation changes. [Figure 7-81](#Aninlinenonreplacedelementwith25-pixelsidemargindisplayedacrosstwolinesoftext)
    shows what happens when an inline nonreplaced element with a margin is displayed
    across multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0781](assets/css5_0781.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-81\. An inline nonreplaced element with 25-pixel side margin displayed
    across two lines of text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The inline-start margin is applied to the beginning of the element, and the
    inline-end margin to the end of it. Margins are *not* applied to the inline-start
    and -end side of each line fragment. Also, you can see that, if not for the margins,
    the line may have broken a word or two sooner. Margins affect line breaking only
    by changing the point at which the element’s content begins within a line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can alter the way margins are (or aren’t) applied to the ends of each line
    box by using the property `box-decoration-break`. See [Chapter 6](ch06.html#basic-visual-formatting)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation gets even more interesting when we apply negative margins to
    inline nonreplaced elements. The block-start and block-end of the element aren’t
    affected, and neither are the heights of lines, but the inline-start and inline-end
    sides of the element can overlap other content, as depicted in [Figure 7-82](#Aninlinenonreplacedelementwithanegativemargin):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0782](assets/css5_0782.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-82\. An inline nonreplaced element with a negative margin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Replaced inline elements represent yet another story: margins set for them
    *do* affect the height of a line, either increasing or reducing it, depending
    on the value for the block-start and block-end margin. The inline-side margins
    of an inline replaced element act the same as for a nonreplaced element. [Figure 7-83](#Inlinereplacedelementswithdifferingmarginvalues)
    shows a series of effects on layout from margins set on inline replaced elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0783](assets/css5_0783.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-83\. Inline replaced elements with differing margin values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to apply margins, borders, and padding to any element allows you
    to manage the separation and appearance of elements in a detailed way. Understanding
    how they interact with each other is the foundation of design for the web.
  prefs: []
  type: TYPE_NORMAL
