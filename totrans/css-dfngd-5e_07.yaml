- en: Chapter 7\. Padding, Borders, Outlines, and Margins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。填充、边框、轮廓和边距
- en: In [Chapter 6](ch06.html#basic-visual-formatting), we talked about the basics
    of element display. In this chapter, we’ll look at the CSS properties and values
    you can use to affect how element boxes are drawn and separated from one another.
    These include the padding, borders, and margins around an element, as well as
    any outlines that may be added.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第6章](ch06.html#basic-visual-formatting) 中，我们讨论了元素显示的基础知识。在本章中，我们将看看你可以使用的
    CSS 属性和值，以影响如何绘制元素框并使其相互分离。这些属性包括围绕元素的填充、边框和外边距，以及可能添加的任何轮廓。
- en: Basic Element Boxes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本元素框
- en: As discussed in the preceding chapter, all document elements generate a rectangular
    box called the *element box*, which describes the amount of space that an element
    occupies in the layout of the document. Therefore, each box influences the position
    and size of other element boxes. For example, if the first element box in the
    document is an inch tall, the next box will begin at least an inch below the top
    of the document. If the first element box is changed and made to be 2 inches tall,
    every following element box will shift downward an inch, and the second element
    box will begin at least 2 inches below the top of the document.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，所有文档元素生成称为*元素框*的矩形框，描述元素在文档布局中占用的空间量。因此，每个框影响其他元素框的位置和大小。例如，如果文档中的第一个元素框高1英寸，那么下一个框将至少从文档顶部向下移动1英寸。如果将第一个元素框更改为高2英寸，每个后续元素框将向下移动1英寸，并且第二个元素框将至少从文档顶部向下移动2英寸。
- en: By default, a visually rendered document is composed of numerous rectangular
    boxes that are distributed so that they don’t overlap. Boxes can overlap if they
    have been manually positioned or placed on a grid, and visual overlap can occur
    if negative margins are used on normal-flow elements.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，视觉渲染的文档由许多不重叠的矩形框组成。如果手动定位或放置在网格上，框可以重叠，如果在正常流元素上使用负边距，可能会发生视觉重叠。
- en: To understand how margins, padding, and borders are handled, you must understand
    the *box model*, illustrated in [Figure 7-1](#TheCSSboxmodel).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解外边距、填充和边框的处理方式，必须了解*盒子模型*，见 [图7-1](#TheCSSboxmodel)。
- en: '![css5 0701](assets/css5_0701.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0701](assets/css5_0701.png)'
- en: Figure 7-1\. The CSS box model
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-1。CSS 盒子模型
- en: The diagram in [Figure 7-1](#TheCSSboxmodel) intentionally omits outlines, for
    reasons that will hopefully be clear once we discuss outlines.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的 [图7-1](#TheCSSboxmodel) 故意省略了轮廓，原因在我们讨论轮廓时会清楚。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The height and width of the content area, as well as the sizing of the content
    area along the block and inline directions, are covered in [Chapter 6](ch06.html#basic-visual-formatting).
    If you find some of the rest of this chapter a little confusing because of the
    way height, width, block axis, and inline axis are discussed, refer to that chapter
    for a detailed explanation.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 内容区域的高度和宽度，以及块和行内方向上内容区域的尺寸，详见 [第6章](ch06.html#basic-visual-formatting)。如果您因高度、宽度、块轴和行内轴的讨论方式而觉得本章的其余部分有些困惑，请参考该章节进行详细解释。
- en: Padding
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充
- en: Just beyond the content area of an element, we find its *padding*, nestled between
    the content and any borders. The simplest way to set padding is by using the property
    `padding`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在元素的内容区域之外，我们发现其*填充*，位于内容和任何边框之间。设置填充的最简单方法是使用属性 `padding`。
- en: 'This property accepts any length value or a percentage value. So if you want
    all `<h2>` elements to have 2 em of padding on all sides, it’s this easy (see
    [Figure 7-2](#Addingpaddingtoelements)):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性接受任何长度值或百分比值。因此，如果您希望所有 `<h2>` 元素的四周都有2 em 的填充，那就很容易实现（参见 [图7-2](#Addingpaddingtoelements)）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![css5 0702](assets/css5_0702.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0702](assets/css5_0702.png)'
- en: Figure 7-2\. Adding padding to elements
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-2。向元素添加填充
- en: As [Figure 7-2](#Addingpaddingtoelements) illustrates, the background of an
    element extends into the padding by default. If the background is transparent,
    setting padding will create extra transparent space around the element’s content,
    but any visible background will extend into the padding area (and beyond, as you’ll
    see in a later section).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图7-2](#Addingpaddingtoelements) 所示，默认情况下，元素的背景延伸到填充区域。如果背景是透明的，则设置填充会在元素内容周围创建额外的透明空间，但任何可见的背景都会延伸到填充区域（以及更远，正如稍后的部分所述）。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Visible backgrounds can be prevented from extending into the padding by using
    the property `background-clip` (see [Chapter 8](ch08.html#backgrounds)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用属性 `background-clip` （参见 [第 8 章](ch08.html#backgrounds)）防止可见背景扩展到填充区域。
- en: By default, elements have no padding. The separation between paragraphs, for
    example, has traditionally been enforced with margins alone (as you’ll see later).
    On the other hand, without padding, the border of an element will come very close
    to the content of the element itself. Thus, when putting a border on an element,
    it’s usually a good idea to add some padding as well, as [Figure 7-3](#Theeffectofpaddingonborderedblock-levelelements)
    illustrates.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，元素没有填充。例如，段落之间的分隔通常仅通过边距来实现（稍后您将看到）。另一方面，如果没有填充，元素的边框将非常接近元素本身的内容。因此，在给元素加边框时，通常也建议添加一些填充，就像
    [图 7-3](#Theeffectofpaddingonborderedblock-levelelements) 所示。
- en: '![css5 0703](assets/css5_0703.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0703](assets/css5_0703.png)'
- en: Figure 7-3\. The effect of padding on bordered block-level elements
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-3\. 填充对有边框的块级元素的影响
- en: 'Any length value is permitted, from ems to inches. The simplest way to set
    padding is with a single length value, which is applied equally to all four padding
    sides. At times, however, you might desire a different amount of padding on each
    side of an element. If you want all `<h1>` elements to have a top padding of 10
    pixels, a right padding of 20 pixels, a bottom padding of 15 pixels, and a left
    padding of 5 pixels, you can just say this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何长度值都是允许的，从 em 到英寸。设置填充的最简单方法是使用单个长度值，该值等量应用于四个填充边。但是，有时您可能希望元素的每一边具有不同的填充量。如果您希望所有
    `<h1>` 元素顶部填充为 10 像素，右侧填充为 20 像素，底部填充为 15 像素，左侧填充为 5 像素，您只需这样说：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The order of the values is important and follows this pattern:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 值的顺序很重要，并遵循此模式：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A good way to remember this pattern is to keep in mind that the four values
    go clockwise around the element, starting from the top. The padding values are
    *always* applied in this order, so to get the effect you want, you have to arrange
    the values correctly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 记住此模式的一个好方法是牢记四个值顺时针围绕元素，从顶部开始。填充值总是按照这个顺序应用，因此为了获得想要的效果，您必须正确排列这些值。
- en: An easy way to remember the order in which sides must be declared, other than
    thinking of it as being clockwise from the top, is to keep in mind that getting
    the sides in the correct order helps you avoid “TRouBLe”—that is, *TRBL*, for
    *top, right, bottom, left*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住边的正确顺序的一种简单方法，除了将其视为从顶部顺时针进行，还有助于避免“TRouBLe”——即 *TRBL*，即 *top, right, bottom,
    left*。
- en: 'This ordering reveals that `padding`, like `height` and `width`, is a physical
    property: it refers to the physical directions of the page, such as top or left,
    rather than being based on writing direction. (CSS does have writing-mode padding
    properties, as you’ll see in a bit.)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此排序显示，像 `padding` 一样，像 `height` 和 `width` 一样，是一个物理属性：它指的是页面的物理方向，例如顶部或左侧，而不是基于书写方向。
    （CSS 确实有书写模式填充属性，稍后您将看到。）
- en: 'It’s entirely possible to mix up the types of length values you use. You aren’t
    restricted to using a single length type in a given rule, but can use whatever
    makes sense for a given side of the element, as shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以混合使用所使用的长度类型。在给定规则中，您不必局限于使用单个长度类型，而是可以根据元素的每一侧适当使用任何类型，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Figure 7-4](#Mixed-valuepadding) shows you, with a little extra annotation,
    the results of this declaration.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-4](#Mixed-valuepadding) 显示了此声明的结果，附带一些额外的注释。'
- en: '![css5 0704](assets/css5_0704.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0704](assets/css5_0704.png)'
- en: Figure 7-4\. Mixed-value padding
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-4\. 混合值填充
- en: Replicating Values
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制值
- en: 'Sometimes the values you enter can get a little repetitive:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您输入的值可能会有点重复：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You don’t have to keep typing in pairs of numbers like this, though. Instead
    of the preceding rule, try this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，您无需像这样一对一对地输入数字。与前述规则不同，尝试这样做：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These two values are enough to take the place of four. But how? CSS defines
    a few rules to accommodate fewer than four values for `padding` (and many other
    shorthand properties):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值足以代替四个。但是如何实现呢？CSS 定义了一些规则来适应 `padding` （以及许多其他简写属性）少于四个值的情况：
- en: If the value for *left* is missing, use the value provided for *right*.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *left* 的值缺失，则使用为 *right* 提供的值。
- en: If the value for *bottom* is also missing, use the value provided for *top*.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *bottom* 的值也缺失，则使用为 *top* 提供的值。
- en: If the value for *right* is also missing, use the value provided for *top*.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *右边* 的值也缺失，则使用提供给 *顶部* 的值。
- en: If you prefer a more visual approach, take a look at [Figure 7-5](#Valuereplicationpattern).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢更视觉化的方法，请看[图 7-5](#Valuereplicationpattern)。
- en: '![css5 0705](assets/css5_0705.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0705](assets/css5_0705.png)'
- en: Figure 7-5\. Value-replication pattern
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-5\. 值复制模式
- en: In other words, if three values are given for `padding`, the fourth (*left*)
    is copied from the second (*right*). If two values are given, the fourth is copied
    from the second, and the third (*bottom*) from the first (*top*). Finally, if
    only one value is given, all the other sides copy that value.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果给定 `padding` 的三个值，第四个（*左边*）将从第二个（*右边*）复制。如果给定两个值，则第四个将从第二个复制，第三个（*底部*）从第一个（*顶部*）复制。最后，如果只给定一个值，则所有其他边将复制该值。
- en: 'This mechanism allows you to supply only as many values as necessary, as shown
    here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制允许你只提供必要的数值，如下所示：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The method presents a small drawback, which you’re bound to eventually encounter.
    Suppose you want to set the top and left padding for `<h1>` elements to be 10
    pixels, and the bottom and right padding to be 20 pixels. You’d have to write
    the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法有一个小缺点，你最终肯定会遇到。假设你想要为 `<h1>` 元素设置顶部和左侧内边距为 10 像素，底部和右侧内边距为 20 像素。你需要写如下内容：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You get what you want, but it takes a while to get it all in. Unfortunately,
    there is no way to cut down on the number of values needed in such a circumstance.
    Let’s take another example, one where you want all of the padding to be 0—except
    for the left padding, which should be 3 em:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你能得到想要的效果，但是要把所有内容都理解清楚需要一些时间。不幸的是，在这种情况下没有办法减少所需数值的数量。让我们再举一个例子，假设你希望所有的内边距都是
    0 —— 除了左内边距应为 3 em：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using padding to separate the content areas of elements can be trickier than
    using the traditional margins, although it’s not without its rewards. For example,
    to keep paragraphs the traditional “one blank line” apart with padding, you’d
    have to write this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内边距来分隔元素的内容区域可能比使用传统的外边距更棘手，尽管它并非没有其奖励。例如，要使用内边距保持段落之间传统的“一个空行”的间距，你需要写成这样：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The half-em top and bottom padding of each paragraph butt up against each other
    and total an em of separation. Why would you bother to do this? Because then you
    could insert separation borders between the paragraphs, and the side borders will
    touch to form the appearance of a solid line. The following code defines these
    effects, illustrated in [Figure 7-6](#Usingpaddinginsteadofmargins):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 每个段落的半个字母的上下内边距靠在一起，并总计形成一个分隔。你为什么要这样做？因为这样你可以在段落之间插入分隔线，侧边框将接触以形成实线外观。以下代码定义了这些效果，如[图 7-6](#Usingpaddinginsteadofmargins)所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![css5 0706](assets/css5_0706.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0706](assets/css5_0706.png)'
- en: Figure 7-6\. Using padding instead of margins
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-6\. 使用内边距而不是外边距
- en: Single-Side Padding
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单边内边距
- en: 'CSS provides a way to assign a value to the padding on a single side of an
    element. Four ways, actually. Let’s say you want to set only the left padding
    of `<h2>` elements to be `3em`. Rather than writing out `padding: 0 0 0 3em`,
    you can take this approach:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 'CSS 提供了一种方法来为元素的单个边设置内边距的值。实际上有四种方式。假设你想要将 `<h2>` 元素的左内边距设置为 `3em`。与其写出 `padding:
    0 0 0 3em`，你可以采用这种方法：'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `padding-left` option is one of four properties devoted to setting the padding
    on each of the four sides of an element box. Their names will come as little surprise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`padding-left` 选项是四个专门用于设置元素盒子四个边的内边距属性之一。它们的名称可能并不让人感到意外。'
- en: 'These properties operate in a manner consistent with their names. For example,
    the following two rules will yield the same amount of padding (assuming no other
    CSS):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性按照它们的名称的方式运作。例如，以下两条规则将产生相同量的内边距（假设没有其他 CSS）：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, these rules will create equal padding:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，这些规则将创建相等的内边距：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For that matter, so will these rules:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，这些规则同样适用：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It’s possible to use more than one of these single-side properties in a single
    rule; for example:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在单个规则中使用多个这些单边属性之一；例如：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see in [Figure 7-7](#Morethanonesingle-sidepadding), the padding
    is set as we wanted. In this case, it might have been easier to use `padding`
    after all, like so:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[图 7-7](#Morethanonesingle-sidepadding)中所见，内边距被设置成我们想要的样子。在这种情况下，使用 `padding`
    可能更容易，像这样：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![css5 0707](assets/css5_0707.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0707](assets/css5_0707.png)'
- en: Figure 7-7\. More than one single-side padding
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-7\. 多个单边内边距
- en: In general, once you’re trying to set padding for more than one side, it’s easier
    to use the shorthand `padding`. From the standpoint of your document’s display,
    however, it doesn’t really matter which approach you use, so choose whichever
    is easiest for you.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，一旦您试图为多个边缘设置填充，使用速记 `padding` 更容易。但是从文档显示的角度来看，无论使用哪种方法都无关紧要，所以选择最简单的方法。
- en: Logical Padding
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑填充
- en: As you’ll see throughout this chapter, physical properties have logical counterparts,
    with names that follow a consistent pattern. For `height` and `width`, we have
    `block-size` and `inline-size`. For padding, we have a set of four properties
    that correspond to the padding at the start and end of the block direction and
    the inline direction. These are called *logical properties*, because they use
    a little logic to determine which physical side they should be applied to.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章节所示，物理属性有逻辑对应物，名称遵循一致的模式。对于 `height` 和 `width`，我们有 `block-size` 和 `inline-size`。对于填充，我们有一组四个属性，对应于块方向和内联方向的起始填充和结束填充。它们被称为
    *逻辑属性*，因为它们使用一些逻辑来确定应该应用到哪个物理边。
- en: 'These properties are handy when you want to make sure your text has padding
    that has a consistent effect regardless of the writing direction. For example,
    you might want a little bit of padding to set the background edges away from the
    start and end of each block element, and more padding to the sides of each line
    of text. Here’s a way to make that happen, with the result shown in [Figure 7-8](#logical-padding-figure):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望确保文本具有填充时，无论书写方向如何，这些属性都非常方便。例如，您可能希望稍微填充以使背景边缘远离每个块元素的起始和结束，并在每行文本的侧边填充更多。以下是实现此目的的一种方法，其结果显示在
    [图 7-8](#logical-padding-figure) 中：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![css5 0708](assets/css5_0708.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0708](assets/css5_0708.png)'
- en: Figure 7-8\. Logical padding
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-8\. 逻辑填充
- en: Warning
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Percentage values for these logical padding properties are always calculated
    with respect to the *physical* width or height of the element’s container, not
    its logical width or height. Thus, for example, `padding-inline-start: 10%` will
    calculate to 100 pixels when the container has `width: 1000px`, even in a vertical
    writing mode. This may change going forward, but that is the consistent (and specified)
    behavior as of late 2022.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '这些逻辑填充属性的百分比值始终相对于元素容器的 *物理* 宽度或高度进行计算，而不是其逻辑宽度或高度。因此，例如，当容器具有 `width: 1000px`
    时，`padding-inline-start: 10%` 将计算为 100 像素，即使在垂直书写模式下也是如此。这可能会有所变化，但这是截至 2022 年末的一致（和规定）行为。'
- en: 'It’s a little tedious to explicitly declare a padding value for each side of
    an element individually, and two shorthand properties can help: one for the block
    axis, and one for the inline axis.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为单独元素的每个边缘显式声明填充值有点繁琐，两个速记属性可以帮助：一个用于块轴，另一个用于内联轴。
- en: 'With these shorthand properties, you can set block padding in one go, and inline
    padding in another. The following CSS would have the same result as that shown
    in [“Logical Padding”](#logical-padding):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些速记属性，您可以一次性设置块填充，另一次性设置内联填充。以下 CSS 与 [“逻辑填充”](#logical-padding) 所示的效果相同：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each property accepts one or two values. If there are two values, they’re always
    in the order *start end*. If there’s only one value, as shown before, the same
    value is used for both the start and end sides. Thus, to give an element 10 pixels
    of block-start padding and 1 em of block-end padding, you could write this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都接受一个或两个值。如果有两个值，它们总是按 *start end* 的顺序。如果只有一个值，如前所示，那么将同一个值用于起始和结束的两个边缘。因此，要为元素设置
    10 像素的块起始填充和 1 em 的块结束填充，可以这样写：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A more compact shorthand doesn’t exist for logical padding, unfortunately—no
    `padding-logical` that accepts four values, the way `padding` does. Proposals
    have been made to extend the `padding` property with a keyword value (such as
    `logical`) to allow it to set logical padding instead of physical padding, but
    as of late 2022, those proposals have not been adopted. As of this writing, the
    most compact you can get with logical padding is to use `padding-block` and `padding-inline`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，逻辑填充没有更紧凑的速记形式——没有像 `padding` 那样接受四个值的 `padding-logical`。有关扩展 `padding`
    属性以允许设置逻辑填充而不是物理填充的提案已被提出，但截至 2022 年末，这些提案尚未被采纳。截至本文撰写时，您能得到的最紧凑的逻辑填充是使用 `padding-block`
    和 `padding-inline`。
- en: Percentage Values and Padding
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 百分比值和填充
- en: We can set percentage values for the padding of an element. Percentages are
    computed in relation to the width of the parent element’s content area, so they
    change if the parent element’s width changes in some way.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为元素的填充设置百分比值。百分比是相对于父元素内容区域的宽度计算的，因此如果父元素的宽度以某种方式更改，则百分比也会更改。
- en: 'For example, assume the following, which is illustrated in [Figure 7-9](#Paddingpercentagesandthewidthsofparentelements):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设以下情况，如[图 7-9](#Paddingpercentagesandthewidthsofparentelements)所示：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![css5 0709](assets/css5_0709.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0709](assets/css5_0709.png)'
- en: Figure 7-9\. Padding, percentages, and the widths of parent elements
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-9\. 填充、百分比和父元素的宽度
- en: 'You may have noticed something odd about the paragraphs in [Figure 7-9](#Paddingpercentagesandthewidthsofparentelements).
    Not only did their side padding change according to the width of their parent
    elements, but so did their top and bottom padding. That’s the desired behavior
    in CSS. Refer back to the property definition, and you’ll see that percentage
    values are defined to be relative to the *width* of the parent element. This applies
    to the top and bottom padding as well as to the left and right. Thus, given the
    following styles and markup, the top padding of the paragraph will be 50 pixels:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到[图 7-9](#Paddingpercentagesandthewidthsofparentelements)中段落的一些奇怪之处。它们的侧面填充不仅根据其父元素的宽度改变，顶部和底部填充也是如此。这是CSS中期望的行为。回顾属性定义，您会发现百分比值定义为相对于父元素的*宽度*。这也适用于顶部和底部填充以及左右填充。因此，给定以下样式和标记，段落的顶部填充将为50像素：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If all this seems strange, consider that most elements in the normal flow are
    (as we are assuming) as tall as necessary to contain their descendant elements,
    including padding. If an element’s top and bottom padding were a percentage of
    the parent’s height, an infinite loop could result where the parent’s height was
    increased to accommodate the top and bottom padding, which would then have to
    increase to match the new height, and so on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些看起来很奇怪，请考虑正常流中的大多数元素（正如我们所假设的那样）与包含其后代元素（包括填充）所需的高度一样高。如果一个元素的顶部和底部填充是父元素高度的百分比，则可能会导致无限循环，其中父元素的高度增加以容纳顶部和底部填充，然后必须增加以匹配新的高度，依此类推。
- en: Rather than ignore percentages for top and bottom padding, the specification
    authors decided to make it relate to the width of the parent’s content area, which
    does not change based on the width of its descendants. This allows authors to
    get a consistent padding all the way around an element by using the same percentage
    on all four sides.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 与忽略顶部和底部填充的百分比不同，规范的作者决定将其与父元素的内容区域宽度相关联，这不会根据其后代的宽度改变。这允许作者通过在所有四个边上使用相同的百分比来获得元素周围一致的填充。
- en: By contrast, consider elements without a declared width. In such cases, the
    overall width of the element box (including padding) is dependent on the width
    of the parent element. This leads to the possibility of *fluid* pages, where the
    padding on elements enlarges or reduces to match the actual size of the parent
    element. If you style a document so that its elements use percentage padding,
    then as the user changes the width of a browser window, the padding will expand
    or shrink to fit. The design choice is up to you.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，考虑没有声明宽度的元素。在这种情况下，元素框（包括填充）的整体宽度取决于父元素的宽度。这导致了*流式*页面的可能性，其中元素的填充根据父元素的实际大小放大或缩小。如果您设计一个文档，使其元素使用百分比填充，则当用户更改浏览器窗口的宽度时，填充将展开或收缩以适应。设计选择取决于您。
- en: 'You also can mix percentages with length values. Thus, to set `<h2>` elements
    to have top and bottom padding of one-half em, and side padding of 10% the width
    of their parent elements, you can declare the following, illustrated in [Figure 7-10](#Mixedpadding):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以混合百分比和长度值。因此，要将`<h2>`元素的顶部和底部填充设定为半个em，并将侧面填充设定为其父元素宽度的10%，您可以声明如下，如[图 7-10](#Mixedpadding)所示：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![css5 0710](assets/css5_0710.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0710](assets/css5_0710.png)'
- en: Figure 7-10\. Mixed padding
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-10\. 混合填充
- en: Here, although the top and bottom padding will stay constant in any situation,
    the side padding will change based on the width of the parent element.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，尽管顶部和底部填充在任何情况下保持不变，但侧面填充将根据父元素的宽度而改变。
- en: Padding and Inline Elements
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充和内联元素
- en: You may have noticed that the discussion so far has been solely about padding
    set for elements that generate block boxes. When padding is applied to inline
    nonreplaced elements, the effects are a little different.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能已经注意到，讨论仅限于生成块级盒子的元素设置的填充。当填充应用于行内非替换元素时，效果略有不同。
- en: 'Let’s say you want to set top and bottom padding on strongly emphasized text:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望在强调的文本上设置顶部和底部填充：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is allowed in the specification, but since you’re applying the padding
    to an inline nonreplaced element, it will have absolutely no effect on the line
    height. Since padding is transparent when there’s no visible background, the preceding
    declaration will have no visual effect whatsoever. This happens because padding
    on inline nonreplaced elements doesn’t change the line height of an element.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这在规范中是允许的，但是因为您将填充应用于行内非替换元素，所以对行高没有任何影响。当没有可见背景时，填充是透明的，因此前述声明在视觉上不会产生任何效果。这是因为行内非替换元素上的填充不会改变元素的行高。
- en: 'Be careful: an inline nonreplaced element with a background color and padding
    can have a background that extends above and below the element, like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心：带有背景颜色和填充的行内非替换元素可能会使背景在元素之上和之下延伸，如下所示：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[Figure 7-11](#Paddingonaninlinenonreplacedelement) gives you an idea of what
    this might look like.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-11](#行内非替换元素的填充) 让您对可能的外观有了一个初步了解。'
- en: '![css5 0711](assets/css5_0711.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0711](assets/css5_0711.png)'
- en: Figure 7-11\. Top padding on an inline nonreplaced element
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-11\. 行内非替换元素的顶部填充
- en: The line height isn’t changed, but since the background color does extend into
    the padding, each line’s background ends up overlapping the lines that come before
    it. That’s the expected result.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 行高不会改变，但由于背景颜色确实延伸到填充区域，每行的背景最终会重叠在之前的行上。这是预期的结果。
- en: 'The preceding behaviors are true only for the top and bottom sides of inline
    nonreplaced elements; the left and right sides are a different story. We’ll start
    by considering the case of a small, inline nonreplaced element within a single
    line. Here, if you set values for the left or right padding, they will be visible,
    as [Figure 7-12](#Aninlinenonreplacedelementwithleftpadding) makes clear (so to
    speak):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前述行为仅适用于行内非替换元素的顶部和底部；左侧和右侧则另当别论。我们将首先考虑单行内的小型行内非替换元素的情况。在这种情况下，如果您设置了左或右填充的值，它们将是可见的，就像[图 7-12](#带有左填充的行内非替换元素)
    明确表明的那样：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![css5 0712](assets/css5_0712.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0712](assets/css5_0712.png)'
- en: Figure 7-12\. An inline nonreplaced element with left padding
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-12\. 带有左填充的行内非替换元素
- en: 'Note the extra space between the end of the word just before the inline nonreplaced
    element and the edge of the inline element’s background. You can add that extra
    space to both ends of the inline if you want:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意单词结束前的行内非替换元素和行内元素背景边缘之间的额外空间。如果需要，您可以在行内两端都添加这额外的空间：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As expected, [Figure 7-13](#Aninlinenonreplacedelementwith25-pixelsidepadding)
    shows a little extra space on the right and left sides of the inline element,
    and no extra space above or below it.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，[图 7-13](#带有 25 像素边填充的行内非替换元素) 显示了行内元素右侧和左侧有少许额外空间，上下没有额外空间。
- en: '![css5 0713](assets/css5_0713.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0713](assets/css5_0713.png)'
- en: Figure 7-13\. An inline nonreplaced element with 25-pixel side padding
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-13\. 带有 25 像素边填充的行内非替换元素
- en: 'Now, when an inline nonreplaced element stretches across multiple lines, the
    situation changes a bit. [Figure 7-14](#Aninlinenonreplacedelementwith25-pixelsidepaddingdisplayedacrosstwolinesoftext)
    shows what happens when an inline nonreplaced element with padding is displayed
    across multiple lines:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当行内非替换元素跨多行时，情况会有所变化。[图 7-14](#带有 25 像素边填充的行内非替换元素跨越两行文本显示) 展示了行内非替换元素带填充在跨多行时的情况：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The left padding is applied to the beginning of the element, and the right padding
    to the end of it. By default, padding is *not* applied to the right and left side
    of each line. Also, you can see that, if not for the padding, the line may have
    broken after “background” instead of where it did. The `padding` property affects
    line breaking only by changing the point at which the element’s content begins
    within a line.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 左填充应用于元素的开头，右填充应用于元素的结尾。默认情况下，填充不会应用于每行的右侧和左侧。此外，您可以看到，如果没有填充，该行可能会在“background”后面而不是当前位置断开。`padding`
    属性只通过改变元素内容在行内开始的位置来影响换行点。
- en: '![css5 0714](assets/css5_0714.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0714](assets/css5_0714.png)'
- en: Figure 7-14\. An inline nonreplaced element with 25-pixel side padding displayed
    across two lines of text
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-14\. 一个具有 25 像素侧填充的内联非替换元素跨两行文本显示
- en: Note
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The way padding is (or isn’t) applied to the ends of each line box can be altered
    with the property `box-decoration-break`. See [Chapter 6](ch06.html#basic-visual-formatting)
    for more details.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过属性`box-decoration-break`来改变每行框的结尾是否应用填充（或不应用填充）。更多细节请参见[第 6 章](ch06.html#basic-visual-formatting)。
- en: Padding and Replaced Elements
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充和替换元素
- en: 'It is possible to apply padding to replaced elements. The most surprising case
    for most people is that you can apply padding to an image, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 替换元素也可以应用填充。对大多数人来说，最令人惊讶的情况是可以为图像应用填充，如下所示：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Regardless of whether the replaced element is block-level or inline, the padding
    will surround its content, and the background color will fill into that padding,
    as shown in [Figure 7-15](#Paddingreplacedelements). You can also see that padding
    will push a replaced element’s border (dashed, in this case) away from its content.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无论替换元素是块级还是内联，填充都会围绕其内容，并且背景颜色将填充到该填充区域，如[图 7-15](#Paddingreplacedelements)所示。你还可以看到填充会将替换元素的边框（在本例中为虚线）从其内容推开。
- en: '![css5 0715](assets/css5_0715.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0715](assets/css5_0715.png)'
- en: Figure 7-15\. Padding, borders, and background on a replaced element
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-15\. 替换元素上的填充、边框和背景
- en: Now, remember all that stuff about how padding on inline nonreplaced elements
    doesn’t affect the height of the lines of text? You can throw it all out for *replaced*
    elements, because they have a different set of rules. As you can see in [Figure 7-16](#Paddingreplacedelements2),
    the padding of an inline replaced element very much affects the height of the
    line.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，记住关于内联非替换元素的填充不影响文本行高度的所有内容？对于*替换*元素，你可以把这些内容全部抛掉，因为它们有不同的规则。正如你在[图 7-16](#Paddingreplacedelements2)中看到的那样，内联替换元素的填充确实会影响行的高度。
- en: '![css5 0716](assets/css5_0716.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0716](assets/css5_0716.png)'
- en: Figure 7-16\. Padding an inline replaced element
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-16\. 填充内联替换元素
- en: The same goes for borders and margins, as you’ll soon see.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 边框和外边距也是如此，您很快就会看到。
- en: Note that if the image in [Figure 7-16](#Paddingreplacedelements2) had not loaded,
    or had somehow been set to have 0 height and width, the padding would still be
    rendered around the spot where the element should have been displayed, even if
    that spot has no height or width.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果[图 7-16](#Paddingreplacedelements2)中的图像未加载，或者某种方式设置为高度和宽度为0，填充仍然会呈现在应该显示该元素的位置周围，即使该位置没有高度或宽度。
- en: Warning
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, uncertainty remains over what to do about styling form elements
    such as `<input>`, which are replaced elements. It is not entirely clear where
    the padding of a checkbox resides, for example. Therefore, as of this writing,
    some browsers ignore padding (and other forms of styling) for form elements, while
    others apply the styles as best they can.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2022 年末，关于如何处理诸如`<input>`这样的表单元素的样式问题，如何处理仍存在不确定性。例如，复选框的填充位于何处并不完全清楚。因此，截至本文写作时，一些浏览器忽略了表单元素的填充（和其他形式的样式），而其他浏览器则尽其所能应用这些样式。
- en: Borders
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边框
- en: Beyond the padding of an element are its borders. The *border* of an element
    is just one or more lines that surround the content and padding of an element.
    By default, the background of the element stops at the outer border edge, since
    the background does not extend into the margins, and the border is just inside
    the margin, and is thus drawn “underneath” the border. This matters when parts
    of the border are transparent, such as with dashed borders.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 超出元素填充的是其边框。元素的*边框*只是围绕内容和填充的一个或多个线条。默认情况下，元素的背景停止在外边框边缘处，因为背景不会延伸到外边距中，而边框刚好在外边距内部，因此被绘制“在”边框的下方。这在边框部分是透明的情况下很重要，例如虚线边框。
- en: 'Every border has three aspects: its width, or thickness; its style, or appearance;
    and its color. The default value for the width of a border is `medium`, which
    was explicitly declared to be 3 pixels wide in 2022. Despite this, the reason
    you don’t usually see borders is that the default style is `none`, which prevents
    them from existing at all. (This lack of existence can also reset the `border-width`
    value, but we’ll get to that in a little while.)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个边框都有三个方面：它的宽度或厚度，它的样式或外观，以及它的颜色。边框的宽度的默认值是`medium`，在2022年明确声明为3像素宽。尽管如此，你通常看不到边框的原因是默认样式是`none`，它完全防止它们存在。（这种不存在还可以重设`border-width`的值，但我们稍后再讨论这个。）
- en: Finally, the default border color is `currentcolor`, the foreground color of
    the element itself. If no color has been declared for the border, it will be the
    same color as the text of the element. If, on the other hand, an element has no
    text—let’s say it has a table that contains only images—the border color for that
    table will be the text color of its parent element (because `color` is inherited).
    Thus, if a table has a border, and the `<body>` is its parent, given this rule
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，默认边框颜色是`currentcolor`，即元素本身的前景色。如果未为边框声明颜色，则它将与元素文本的颜色相同。另一方面，如果一个元素没有文本——比如说它只包含图像的表格——那么该表格的边框颜色将是其父元素的文本颜色（因为`color`是继承的）。因此，如果一个表格有边框，而`<body>`是它的父元素，根据这个规则
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: then, by default, the border around the table will be purple (assuming the user
    agent doesn’t set a color for tables).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，默认情况下，表格周围的边框将是紫色（假设用户代理未设置表格的颜色）。
- en: The CSS specification defines the background area of an element to extend to
    the outside edge of the border, at least by default. This is important because
    some borders are *intermittent*—for example, `dotted` and `dashed` borders—so
    the element’s background should appear in the spaces between the visible portions
    of the border.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: CSS规范将元素的背景区域定义为默认情况下延伸到边框的外缘。这很重要，因为一些边框是*间歇性*的——例如，`dotted`和`dashed`边框——因此，元素的背景应出现在边框可见部分之间的空白处。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Visible backgrounds can be prevented from extending into the border area by
    using the property `background-clip`. See [Chapter 8](ch08.html#backgrounds) for
    details.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用属性`background-clip`来防止可见背景扩展到边框区域。详细信息请参见[第 8 章](ch08.html#backgrounds)。
- en: Borders with Style
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带样式的边框
- en: We’ll start with border styles, which are the most important aspect of a border—not
    because they control the appearance of the border (although they certainly do
    that) but because without a style, there wouldn’t be any border at all.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从边框样式开始，这是边框的最重要的方面——不是因为它们控制边框的外观（尽管它们确实如此），而是因为没有样式，就根本没有边框。
- en: CSS defines 10 distinct styles for the property `border-style`, including the
    default value of `none`. [Figure 7-17](#Borderstyles) demonstrates these styles.
    This property is not inherited.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: CSS为属性`border-style`定义了10种不同的样式，包括默认值`none`。[图 7-17](#Borderstyles)展示了这些样式。此属性不被继承。
- en: The style value `hidden` is equivalent to `none`, except when applied to tables,
    where it has a slightly different effect on border-conflict resolution.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 样式值`hidden`等同于`none`，但当应用于表格时，对边框冲突解决有稍微不同的影响。
- en: '![css5 0717](assets/css5_0717.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0717](assets/css5_0717.png)'
- en: Figure 7-17\. Border styles
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-17\. 边框样式
- en: As for `double`, it’s defined such that the width of the two lines it creates,
    plus the width of the space between them, is equal to the value of `border-width`
    (discussed in the next section). However, the CSS specification doesn’t say whether
    one of the lines should be thicker than the other, or if they should always be
    the same width, or if the space should be thicker or thinner than the lines. All
    of these options are left up to the user agent to decide, and the author has no
    reliable way to influence the final result.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 至于`double`，它被定义为两条线加上它们之间的空间的宽度等于`border-width`的值（在下一节讨论）。然而，CSS规范没有指定其中一条线应该比另一条线更粗，或者它们应该始终具有相同的宽度，或者空间应该比线条更粗或更细。所有这些选项都由用户代理决定，作者无法可靠地影响最终结果。
- en: All the borders shown in [Figure 7-17](#Borderstyles) are based on a `color`
    value of `gray`, which makes all of the visual effects easier to see. The look
    of a border style is always based in some way on the color of the border, although
    the exact method may vary among user agents. The way browsers treat colors in
    the border styles `inset`, `outset`, `groove`, and `ridge` can and does vary.
    For example, [Figure 7-18](#Twovalidwaysofrenderinginset) illustrates two ways
    a browser could render an inset border.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在[图 7-17](#Borderstyles)中显示的边框都基于 `gray` 的 `color` 值，这使所有视觉效果更容易看到。边框样式如 `inset`、`outset`、`groove`
    和 `ridge` 的外观总是以某种方式基于边框的颜色，尽管具体方法可能在用户代理之间有所不同。浏览器如何处理边框样式中的颜色可以并且确实有所不同。例如，[图 7-18](#Twovalidwaysofrenderinginset)展示了浏览器可能渲染内嵌边框的两种方式。
- en: '![css5 0718](assets/css5_0718.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0718](assets/css5_0718.png)'
- en: Figure 7-18\. Two valid ways of rendering an inset
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-18\. 渲染内嵌框的两种有效方式
- en: In this example, one browser takes the `gray` value for the bottom and right
    sides, and a darker gray for the top and left; the other makes the bottom and
    right lighter than `gray` and the top and left darker, but not as dark as the
    first browser.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，一个浏览器将 `gray` 值用于底部和右侧，顶部和左侧使用更深的灰色；另一个浏览器则使底部和右侧比 `gray` 更轻，而顶部和左侧更暗，但不及第一个浏览器那么深。
- en: 'Now let’s define a border style for images that are inside any unvisited hyperlink.
    We might make them `outset`, so they have a “raised button” look, as depicted
    in [Figure 7-19](#Applyinganoutsetbordertoahyperlinkedimage):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为任何未访问的超链接内的图像定义一个边框样式。我们可能会将它们设为 `outset`，这样它们看起来像是一个“凸起的按钮”，如[图 7-19](#Applyinganoutsetbordertoahyperlinkedimage)所示：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![css5 0719](assets/css5_0719.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0719](assets/css5_0719.png)'
- en: Figure 7-19\. Applying an outset border to a hyperlinked image
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-19\. 对超链接图像应用突出边框
- en: 'By default, the color of the border is based on the element’s value for `color`,
    which in this circumstance is likely to be `blue`. This is because the image is
    contained with a hyperlink, and the foreground color of hyperlinks is usually
    `blue`. If you so desired, you could change that color to silver, like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，边框的颜色基于元素对 `color` 的值，在这种情况下，可能是 `blue`。这是因为图像包含在超链接中，超链接的前景色通常是 `blue`。如果你愿意，你可以将该颜色更改为
    `silver`，就像这样：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The border will now be based on the light-grayish `silver`, since that’s now
    the foreground color of the image—even though the image doesn’t actually use it,
    it’s still passed on to the border. We’ll talk about another way to change border
    colors in [“Border Colors”](#border-colors).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，边框将基于淡灰色的 `silver`，因为这是图像的前景色，即使图像实际上没有使用它，但它仍然传递给了边框。我们将在[“边框颜色”](#border-colors)中讨论另一种更改边框颜色的方法。
- en: Remember, though, that the color-shifting in borders is up to the user agent.
    Let’s go back to the blue outset border and compare it in two browsers, as shown
    in [Figure 7-20](#Twooutsetborders).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，边框中的颜色变化是由用户代理决定的。让我们回到蓝色的突出边框，并在两个浏览器中进行比较，如[图 7-20](#Twooutsetborders)所示。
- en: Again, notice that one browser shifts the colors to the lighter and darker,
    while another just shifts the “shadowed” sides to be darker than blue. This is
    why, if a specific set of colors is desired, authors usually set the exact colors
    they want instead of using a border style like `outset` and leaving the result
    up to the browser. You’ll soon see just how to do that.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意到，一个浏览器会将颜色变浅或变深，而另一个浏览器只会使“阴影”边变暗，但不如第一个浏览器那么深。这就是为什么，如果需要特定的颜色集，作者通常会设置他们想要的确切颜色，而不是使用
    `outset` 等边框样式并将结果留给浏览器。很快你会看到如何做到这一点。
- en: '![css5 0720](assets/css5_0720.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0720](assets/css5_0720.png)'
- en: Figure 7-20\. Two outset borders
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-20\. 两个突出边框
- en: Multiple styles
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多种样式
- en: 'We can define more than one style for a given border. For example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为给定边框定义多种样式。例如：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The result is a paragraph with a solid top border, a dashed right border, a
    dotted bottom border, and a solid left border.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个段落，顶部边框是实线，右边边框是虚线，底部边框是点线，左边边框是实线。
- en: 'Again we see the TRBL order of values, just as we saw in our discussion of
    setting `padding` with multiple values. All the same rules about value replication
    apply to border styles, just as they did with padding. Thus, the following two
    statements would have the same effect, as depicted in [Figure 7-21](#Equivalentstylerules):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看到了TRBL顺序的值，就像我们在设置多个值的 `padding` 时讨论过的那样。关于值复制的所有规则都适用于边框样式，就像它们适用于 `padding`
    一样。因此，以下两个语句将产生相同的效果，如[图 7-21](#Equivalentstylerules)所示：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![css5 0721](assets/css5_0721.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0721](assets/css5_0721.png)'
- en: Figure 7-21\. Equivalent style rules
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-21\. 等效样式规则
- en: Single-side styles
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单边样式
- en: Sometimes you might want to set border styles for just one side of an element
    box, rather than all four. That’s where the single-side border style properties
    come in.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能希望仅为元素框的一个边设置边框样式，而不是四个边都设置。这就是单边边框样式属性发挥作用的地方。
- en: Single-side border style properties are fairly self-explanatory. If you want
    to change the style for the bottom border, for example, you use `border-bottom-style`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 单边边框样式属性相当易于理解。例如，如果您想要更改底部边框的样式，可以使用`border-bottom-style`。
- en: It’s not uncommon to see `border` used in conjunction with a single-side property.
    Suppose you want to set a solid border on three sides of a heading, but not have
    a left border, as shown in [Figure 7-22](#Removingtheleftborder).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 见到`border`与单边属性结合使用并不罕见。假设您希望在标题的三个边上设置实线边框，但左边没有边框，如[图 7-22](#Removingtheleftborder)所示。
- en: '![css5 0722](assets/css5_0722.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0722](assets/css5_0722.png)'
- en: Figure 7-22\. Removing the left border
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-22\. 去除左边框
- en: 'You can accomplish this in two ways, each one equivalent to the other:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两种方式来完成此操作，每种方式都与另一种等效：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What’s important to remember is that if you’re going to use the second approach,
    you have to place the single-side property *after* the shorthand, as is usually
    the case with shorthand. This is because `border-style: solid` is actually a declaration
    of `border-style: solid solid solid solid`. If you put `border-style-left: none`
    before the `border-style` declaration, the shorthand’s value will override the
    single-side value of `none`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是要记住，如果您要使用第二种方法，您必须在缩写之后放置单边属性*之后*，通常情况下是这样。这是因为`border-style: solid`实际上是声明`border-style:
    solid solid solid solid`。如果您将`border-style-left: none`放在`border-style`声明之前，那么缩写的值将覆盖`none`的单边值。'
- en: Logical styles
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑样式
- en: If you want your borders to be styled in relation to where they sit in the writing
    mode’s flow, rather than be pinned to physical directions, the following are the
    border-styling properties for you.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望边框的样式与其在书写模式流中的位置有关，而不是固定在物理方向上，那么以下是适合您的边框样式属性。
- en: 'As with `padding-block` and `padding-inline`, `border-block-style` and `border-inline-style`
    each accept one or two values. If two values are given, they are taken in the
    order of *start end*. Given the following CSS, you’ll get a result like that shown
    in [Figure 7-23](#logical-border-styles):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与`padding-block`和`padding-inline`一样，`border-block-style`和`border-inline-style`每个接受一个或两个值。如果给定两个值，则按*start
    end*的顺序取值。给定以下CSS，您将得到类似于[图 7-23](#logical-border-styles)所示的结果：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![css5 0723](assets/css5_0723.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0723](assets/css5_0723.png)'
- en: Figure 7-23\. Logical border styles
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-23\. 逻辑边框样式
- en: 'You could get the same result in the following, more verbose manner:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以以下更冗长的方式获得相同的结果：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The only difference between the two patterns is the number of characters you
    have to type, so really, which one you use is up to you.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种模式之间唯一的区别在于您需要输入的字符数，因此实际上，您可以自行选择使用哪种模式。
- en: Border Widths
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边框宽度
- en: Once you’ve assigned a border a style, the next step is to give it some width,
    most easily by using the property `border-width` or one of its cousin properties.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您为边框分配了样式，下一步就是为其赋予一些宽度，最简单的方法是使用属性`border-width`或其兄弟属性之一。
- en: Each of these properties is used to set the width on a specific border side,
    just as with the margin properties.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些属性用于设置特定边框边的宽度，就像与边距属性一样。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As of early 2023, border widths *still* cannot be given percentage values, which
    is rather a shame.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2023年初，边框宽度*仍然*不能以百分比值给出，这实在有些遗憾。
- en: 'There are four ways to assign width to a border: you can give it a length value
    such as `4px` or `0.1em`, or use one of three keywords. These keywords are `thin`,
    `medium` (the default value), and `thick`. According to the specification, `thick`
    is 5px, wider than `medium`’s 3px, which is wider than the 1-px `thin`—which makes
    sense.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法可以为边框分配宽度：您可以给它一个长度值，例如`4px`或`0.1em`，或者使用三个关键字中的一个。这些关键字是`thin`、`medium`（默认值）和`thick`。根据规范，`thick`是5px，比`medium`的3px宽，比1px的`thin`更宽——这是有道理的。
- en: '[Figure 7-24](#Therelationofborder-widthkeywordstoeachother) illustrates these
    three keywords, and how they relate to one another and to the content they surround.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-24](#Therelationofborder-widthkeywordstoeachother)展示了这三个关键词以及它们如何相互关联以及与它们所围绕的内容之间的关系。'
- en: '![css5 0724](assets/css5_0724.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0724](assets/css5_0724.png)'
- en: Figure 7-24\. The relation of border-width keywords to each other
  id: totrans-214
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-24\. 边框宽度关键词之间的关系
- en: 'Let’s suppose a paragraph has a background color and a border style set:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个段落有背景颜色和边框样式设置：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The border’s width is, by default, `medium`. We can change that easily enough:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，边框的宽度是`medium`。我们可以很容易地改变它：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Border widths can be taken to fairly ridiculous extremes, such as setting 1,000-pixel
    borders, though this is rarely necessary (or advisable). It is important to remember
    that borders, and therefore `border-width` values, participate in the box model,
    impacting an element’s size.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 边框宽度可以被设置为非常夸张的极端值，比如设置1000像素的边框，尽管这很少是必要的（或明智的）。重要的是要记住，边框和因此`border-width`的值参与框模型，影响元素的大小。
- en: 'It’s possible to set widths for individual sides, using two familiar methods.
    The first is to use any of the specific properties mentioned at the beginning
    of the section, such as `border-bottom-width`. The other way is to use value replication
    in `border-width`, following the usual TRBL pattern, which is illustrated in [Figure 7-25](#Valuereplicationandunevenborderwidths):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用两种熟悉的方法为各个边设置宽度。第一种方法是使用本节开头提到的特定属性之一，例如`border-bottom-width`。另一种方法是在`border-width`中使用值复制，遵循通常的TRBL模式，这在[图7-25](#Valuereplicationandunevenborderwidths)中有说明：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![css5 0725](assets/css5_0725.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0725](assets/css5_0725.png)'
- en: Figure 7-25\. Value replication and uneven border widths
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-25。值复制和不均匀边框宽度
- en: Logical border widths
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑边框宽度
- en: That said, if you want to set border widths based on writing direction, you
    can use the usual complement of logical counterparts to go with the physical properties.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，如果希望根据书写方向设置边框宽度，可以使用与物理属性配对的逻辑对应项。
- en: 'As you saw with the border widths, these can either be set one side at a time,
    or compressed into the `border-block-width` and `border-inline-width` properties.
    The following two rules will have exactly the same effect:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你看到的边框宽度，它们可以单独设置每一边，也可以压缩成`border-block-width`和`border-inline-width`属性。以下两条规则将产生完全相同的效果：
- en: '[PRE42]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: No border at all
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有任何边框
- en: 'So far, we’ve talked only about using a visible border style such as `solid`
    or `outset`. Let’s consider what happens when you set `border-style` to `none`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了使用可见的边框样式，比如`solid`或`outset`。让我们考虑一下当你将`border-style`设置为`none`时会发生什么：
- en: '[PRE43]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Even though the border’s width is `20px`, the style is set to `none`. In this
    case, not only does the border’s style vanish, so does its width. The border just
    ceases to be. Why?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管边框的宽度是`20px`，但样式被设置为`none`。在这种情况下，不仅边框的样式消失了，它的宽度也消失了。边框就这样不存在了。为什么？
- en: As you may remember, the terminology used earlier in the chapter indicated that
    a border with a style of `none` *does not exist*. Those words were chosen very
    carefully, because they help explain what’s going on here. Since the border doesn’t
    exist, it can’t have any width, so the width is automatically set to `0` (zero),
    no matter what you try to define.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的那样，在本章早些时候使用的术语表明，样式为`none`的边框*不存在*。这些话语被非常谨慎地选择，因为它们有助于解释这里发生的情况。由于边框不存在，它就不能有任何宽度，所以无论你如何定义，宽度都自动设置为`0`（零）。
- en: After all, if a drinking glass is empty, you can’t really describe it as being
    half-full of nothing. You can discuss the depth of a glass’s contents only if
    it has actual contents. In the same way, talking about the width of a border makes
    sense only in the context of a border that exists.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 毕竟，如果一个饮用杯是空的，你无法真正描述它是半满无物的。只有在杯子里真的有内容时，才能讨论杯子内容的深度。同样地，只有在边框存在的情况下，才有讨论边框宽度的意义。
- en: 'This is important to keep in mind because it’s a common mistake to forget to
    declare a border style. This leads to all kinds of developer frustration because,
    at first glance, the styles appear correct. Given the following rule, though,
    no `<h1>` element will have a border of any kind, let alone one that’s 20 pixels
    wide:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要要记住，因为忘记声明边框样式是一个常见的错误。这会导致开发者各种沮丧，因为乍一看，样式看起来是正确的。不过，根据以下规则，没有任何`<h1>`元素会有任何类型的边框，更不用说宽度为20像素的边框了：
- en: '[PRE44]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since the default value of `border-style` is `none`, failure to declare a style
    is exactly the same as declaring `border-style: none`. Therefore, if you want
    a border to appear, you need to declare a border style.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '由于`border-style`的默认值是`none`，不声明样式与声明`border-style: none`完全相同。因此，如果要显示边框，必须声明边框样式。'
- en: Border Colors
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边框颜色
- en: Compared to the other aspects of borders, setting the color is pretty easy.
    CSS uses the physical shorthand property `border-color`, which can accept up to
    four color values at one time. (See [“Color”](ch05.html#color) for the valid value
    formats of colors.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与边框的其他方面相比，设置颜色非常容易。CSS使用物理简写属性`border-color`，可以一次接受多达四个颜色值。（请参见[“颜色”](ch05.html#color)以了解颜色的有效值格式。）
- en: 'If there are fewer than four values, value replication takes effect as usual.
    So if you want `<h1>` elements to have thin gray top and bottom borders with thick
    green side borders, and medium gray borders around `<p>` elements, the following
    styles will suffice, with the result shown in [Figure 7-26](#Bordershavemanyaspects):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的值少于四个，则通常会进行值复制。因此，如果希望`<h1>`元素具有上下边框为细灰色，侧边框为粗绿色，并且`<p>`元素周围具有中灰色边框，以下样式就足够了，并显示在[图 7-26](#Bordershavemanyaspects)中：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![css5 0726](assets/css5_0726.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0726](assets/css5_0726.png)'
- en: Figure 7-26\. Borders have many aspects
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-26\. 边框有多个方面
- en: 'A single `color` value will be applied to all four sides, as with the paragraph
    in the previous example. On the other hand, if you supply four color values, you
    can get a different color on each side. Any type of color value can be used, from
    named colors to hexadecimal and HSL values:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单一的`color`值将应用于四个边框，就像前面示例中的段落一样。另一方面，如果提供四个颜色值，可以使每个边框颜色不同。可以使用任何类型的颜色值，从命名颜色到十六进制和HSL值：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you don’t declare a color, the default is `currentcolor`, which is always
    the foreground color of the element. Thus, the following declaration will be displayed
    as shown in [Figure 7-27](#Bordercolorsbasedontheelementsforegroundandthevalueoftheborder-colorproperty):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不声明颜色，默认为`currentcolor`，即元素的前景色。因此，以下声明将按[图 7-27](#Bordercolorsbasedontheelementsforegroundandthevalueoftheborder-colorproperty)所示显示：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![css5 0727](assets/css5_0727.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0727](assets/css5_0727.png)'
- en: Figure 7-27\. Border colors based on the element’s foreground and the value
    of the `border-color` property
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-27\. 边框颜色基于元素的前景和`border-color`属性的值
- en: The result is that the first paragraph has a gray border, having used the foreground
    color of the paragraph. The second paragraph, however, has a black border because
    that color was explicitly assigned using `border-color`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是第一个段落具有灰色边框，因为使用了段落的前景色。然而，第二个段落具有黑色边框，因为使用了`border-color`显式指定的颜色。
- en: 'Physical single-side border color properties exist as well. They work in much
    the same way as the single-side properties for border style and width. One way
    to give headings a solid black border with a solid gray right border is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 物理单边边框颜色属性也存在。它们的工作方式与边框样式和宽度的单边属性类似。一种为标题添加实线黑色边框和实线灰色右边框的方法如下：
- en: '[PRE48]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Logical border colors
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑边框颜色
- en: 'Just as with border styles and widths, logical properties shadow the physical
    properties: two shorthand, four longhand.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与边框样式和宽度一样，逻辑属性会覆盖物理属性：两个简写，四个长手写。
- en: 'Thus, the following two rules would have the exact same outcome:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下两条规则将产生完全相同的结果：
- en: '[PRE49]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Transparent borders
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明边框
- en: As you may recall, if a border has no style, it has no width. In some situations,
    however, you’ll want to create an invisible border that still has width. This
    is where the border color value `transparent` comes in.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得的那样，如果边框没有样式，则没有宽度。然而，在某些情况下，您可能希望创建一个看起来没有边框但实际上有宽度的边框。这就是`transparent`边框颜色值的用武之地。
- en: 'Let’s say we want a set of three links to have borders that are invisible by
    default, but look inset when the link is hovered. We can accomplish this by making
    the borders transparent in the nonhovered case:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望一组三个链接在默认情况下具有不可见的边框，但当链接悬停时，边框看起来是凹陷的。我们可以通过在非悬停情况下将边框设为透明来实现这一点：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This will have the effect shown in [Figure 7-28](#using_transparent_borders).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生[图 7-28](#using_transparent_borders)中显示的效果。
- en: In a sense, `transparent` lets you use borders as if they were extra padding.
    Should you want to make them visible, the space is reserved, preventing a reflow
    of content when visible borders are added in.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，`transparent`使您可以像使用额外的填充一样使用边框。如果要使它们可见，空间会被保留，防止在添加可见边框时内容重新排列。
- en: '![css5 0728](assets/css5_0728.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0728](assets/css5_0728.png)'
- en: Figure 7-28\. Using transparent borders
  id: totrans-263
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-28\. 使用透明边框
- en: Single-Side Shorthand Border Properties
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单边简写边框属性
- en: 'It turns out that shorthand properties such as `border-color` and `border-style`
    aren’t always as helpful as you’d think. For example, you might want to apply
    a thick, gray, solid border to all `<h1>` elements, but only along the bottom.
    If you limit yourself to the properties we’ve discussed so far, you’ll have a
    hard time applying such a border. Here are two examples:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 缩写属性（例如`border-color`和`border-style`）并不总是像你想象的那样有用。例如，你可能希望将厚、灰色、实线边框应用于所有`<h1>`元素，但仅限于底部。如果仅使用到目前为止讨论过的属性，将会很难实现这样的边框效果。以下是两个示例：
- en: '[PRE51]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Neither is really convenient, given all the typing involved. Fortunately, a
    better solution is available:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于涉及到的所有输入，这两者都不是很方便。幸运的是，有更好的解决方案可用：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This will apply the values to the bottom border alone, as shown in [Figure 7-29](#Settingabottomborderwithashorthandproperty),
    leaving the others to their defaults. Since the default border style is `none`,
    no borders appear on the other three sides of the element.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅将值应用于底部边框，如[图 7-29](#Settingabottomborderwithashorthandproperty)所示，其他边框将保持默认状态。由于默认的边框样式是`none`，所以元素的其他三个边框不会显示出来。
- en: '![css5 0729](assets/css5_0729.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0729](assets/css5_0729.png)'
- en: Figure 7-29\. Setting a bottom border with a shorthand property
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 7-29\. 使用缩写属性设置底部边框
- en: As you may have guessed, CSS has four physical shorthand properties and four
    logical shorthand properties.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，CSS具有四个物理缩写属性和四个逻辑缩写属性。
- en: 'We can use these properties to create some complex borders, such as those shown
    in [Figure 7-30](#Verycomplexborders):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这些属性创建一些复杂的边框，例如[图 7-30](#Verycomplexborders)中显示的那些：
- en: '[PRE53]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![css5 0730](assets/css5_0730.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0730](assets/css5_0730.png)'
- en: Figure 7-30\. Very complex borders
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 7-30\. 非常复杂的边框
- en: 'As you can see, the order of the actual values doesn’t really matter. The following
    three rules will yield exactly the same border effect:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，实际值的顺序并不重要。以下三条规则将产生完全相同的边框效果：
- en: '[PRE54]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can also leave out some values and let their defaults kick in, like this:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以省略一些值，让它们的默认值生效，如下所示：
- en: '[PRE55]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Since no border color is declared, the default value (`currentcolor`) is applied
    instead. Just remember that if you leave out a border style, the default value
    of `none` will prevent your border from existing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 由于未声明边框颜色，所以默认值（`currentcolor`）会被应用。请记住，如果省略了边框样式，那么`none`的默认值将导致你的边框不存在。
- en: 'By contrast, if you set only a style, you will still get a border. Let’s say
    you want a top border style of `dashed` and you’re willing to let the width default
    to `medium` and the color be the same as the text of the element itself. All you
    need in such a case is the following markup (shown in [Figure 7-31](#Dashingacrossthetopofanelement)):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果仅设置样式，你仍然会得到一个边框。假设你想要一个`dashed`的顶部边框样式，并且愿意让宽度默认为`medium`，颜色与元素文本的颜色相同。在这种情况下，只需以下标记（如[图 7-31](#Dashingacrossthetopofanelement)所示）：
- en: '[PRE56]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![css5 0731](assets/css5_0731.png)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0731](assets/css5_0731.png)'
- en: Figure 7-31\. Dashing across the top of an element
  id: totrans-285
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 7-31\. Dashing across the top of an element
- en: 'Also note that since each of these border-side properties applies only to a
    specific side, there isn’t any possibility of value replication—it wouldn’t make
    any sense. There can be only one of each type of value: that is, only one width
    value, only one color value, and only one border style. So don’t try to declare
    more than one value type:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，由于每个边框边属性仅适用于特定的一侧，所以不存在值复制的可能性——这是毫无意义的。每种类型的值只能有一个：即只有一个宽度值，只有一个颜色值，以及只有一个边框样式。因此，不要尝试声明多个值类型：
- en: '[PRE57]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This entire statement is invalid, and a user agent will ignore it.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 整个声明都是无效的，用户代理会忽略它。
- en: Global Borders
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局边框
- en: 'Now, we come to the shortest shorthand border property of all: `border`, which
    affects all four sides of the element equally.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来讨论最简短的缩写边框属性：`border`，它会对元素的四个边框均产生影响。
- en: 'This property has the advantage of being very compact, although that brevity
    introduces a few limitations. Before we worry about that, let’s see how `border`
    works. If you want all `<h1>` elements to have a thick silver border, the following
    declaration would display as shown in [Figure 7-32](#Areallyshortborderdeclaration):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这种属性的优势在于非常紧凑，尽管这种简洁性会引入一些限制。在我们担心这些之前，让我们看看`border`是如何工作的。如果你希望所有`<h1>`元素都有厚厚的银色边框，下面的声明将显示如[图 7-32](#Areallyshortborderdeclaration)所示：
- en: '[PRE58]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![css5 0732](assets/css5_0732.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0732](assets/css5_0732.png)'
- en: Figure 7-32\. A really short border declaration
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 7-32\. 一个非常简短的边框声明
- en: 'The drawback with `border` is that you can define only a single global style,
    width, and color. The values you supply for `border` will apply to all four sides
    equally. If you want the borders to be different for a single side, use some of
    the other border properties. Then again, it’s possible to turn the cascade to
    your advantage:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`border`的缺点在于你只能定义单一的全局样式、宽度和颜色。你为`border`提供的值会对所有四个边都生效。如果你希望某个边有不同的边框样式，请使用其他的边框属性。然而，再次利用级联特性也是可能的：
- en: '[PRE59]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The second rule overrides the width value for the left border assigned by the
    first rule, thus replacing `thick` with `20px`, as you can see in [Figure 7-33](#Usingthecascadetoonesadvantage).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则将第一条规则分配的左边框宽度值`thick`覆盖为`20px`，如你在[图 7-33](#Usingthecascadetoonesadvantage)中所见。
- en: '![css5 0733](assets/css5_0733.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0733](assets/css5_0733.png)'
- en: Figure 7-33\. Using the cascade to your advantage
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-33\. 利用级联优势
- en: 'You still need to take the usual precautions with shorthand properties: if
    you omit a value, the default will be filled in automatically. This can have unintended
    effects. Consider the following:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要谨慎处理简写属性：如果你省略了一个值，系统将自动填充默认值，这可能会产生意想不到的效果。考虑以下情况：
- en: '[PRE60]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, we’ve failed to assign a `border-style`, which means that the default
    value of `none` will be used, and thus no `<h4>` elements will have any border
    at all.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们未能分配`border-style`，这意味着将使用默认值`none`，因此没有任何`<h4>`元素会有边框。
- en: Borders and Inline Elements
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边框与内联元素
- en: Dealing with borders and inline elements should sound pretty familiar, since
    the rules are largely the same as those that cover padding and inline elements,
    as we discussed earlier. Still, we’ll briefly touch on the topic again.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 处理边框和内联元素应该听起来非常熟悉，因为规则与我们之前讨论的填充和内联元素的规则基本相同。尽管如此，我们还是会简要地再次触及这个话题。
- en: 'First, no matter how thick you make your borders on inline elements, the line
    height of the element won’t change. Let’s set block-start and block-end borders
    on boldfaced text:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，无论你在内联元素上有多厚的边框，元素的行高都不会改变。让我们在加粗文本上设置块起始和块结束的边框：
- en: '[PRE61]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As seen before, adding borders to the block start and end will have absolutely
    no effect on the line height. However, since borders are visible, they’ll be drawn—as
    illustrated in [Figure 7-34](#Bordersoninlinenonreplacedelements).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在块的起始和结束添加边框对行高没有任何影响。然而，由于边框是可见的，它们会被绘制出来，如在[图 7-34](#Bordersoninlinenonreplacedelements)所示。
- en: '![css5 0734](assets/css5_0734.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0734](assets/css5_0734.png)'
- en: Figure 7-34\. Borders on inline nonreplaced elements
  id: totrans-309
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-34\. 内联非替换元素上的边框
- en: The borders have to go somewhere. That’s where they went. They get painted over
    the preceding line of text and under the next line of text if need be.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 边框必须有一个位置。这就是它们所在的位置。如果需要，它们会被绘制在前一行文本的上方，并在下一行文本的下方。
- en: 'Again, all of this is true only for the block-start and -end sides of inline
    elements; the inline sides are a different story. If you apply a border along
    an inline side, not only will they be visible, but they’ll displace the text around
    them, as you can see in [Figure 7-35](#Aninlinenonreplacedelementwithaleftborder):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这一切只适用于内联元素的块起始和块结束两侧；内联两侧则不同。如果你在内联一侧应用边框，它们不仅会可见，还会使周围的文本产生位移，就像你在[图 7-35](#Aninlinenonreplacedelementwithaleftborder)中看到的那样。
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![css5 0735](assets/css5_0735.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0735](assets/css5_0735.png)'
- en: Figure 7-35\. Inline nonreplaced elements with inline-start borders
  id: totrans-314
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-35\. 内联非替换元素具有内联起始边框
- en: With borders, just as with padding, the browser’s calculations for line breaking
    are not directly affected by any box properties set for inline nonreplaced elements.
    The only effect is that the space taken up by the borders may shift portions of
    the line over a bit, which may in turn change which word is at the end of the
    line.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 与填充一样，边框对于浏览器在处理行断开时的计算没有直接影响。唯一的影响是边框所占用的空间可能会稍微移动行的某些部分，这可能会改变行尾的单词。
- en: Note
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The way borders are (or aren’t) drawn at the ends of each line box can be altered
    with the property `box-decoration-break`. See [Chapter 6](ch06.html#basic-visual-formatting)
    for more details.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 边框的绘制方式（或不绘制方式）在每个行框的结束处可以通过`box-decoration-break`属性进行修改。详细信息请参见[第 6 章](ch06.html#basic-visual-formatting)。
- en: 'With replaced elements such as images, on the other hand, the effects are very
    much like those we saw with padding: a border *will* affect the height of the
    lines of text, in addition to shifting text around to the sides. Thus, assuming
    the following styles, we get a result like that seen in [Figure 7-36](#Bordersoninlinereplacedelements):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，对于像图像这样的替换元素，效果与填充类似：边框*会*影响文本行的高度，并将文本向两侧移动。因此，假设以下样式，我们得到类似于[图 7-36](#Bordersoninlinereplacedelements)中看到的结果：
- en: '[PRE63]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![css5 0736](assets/css5_0736.png)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0736](assets/css5_0736.png)'
- en: Figure 7-36\. Borders on inline replaced elements
  id: totrans-321
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-36\. 行内替换元素上的边框
- en: Rounding Border Corners
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 圆角边框
- en: We can soften the square corners of element borders—and actually, the entire
    background area—by using the property `border-radius` to define a rounding distance
    (or two). In this particular case, we’re going to start with the shorthand physical
    property and then mention the individual physical properties at the end of the
    section, after which we’ll check out the logical equivalents.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用属性`border-radius`来定义圆角距离（或两个），软化元素边框的方形角和整个背景区域。在这种特定情况下，我们将从简写物理属性开始，然后在本节末尾提到各个物理属性，之后我们将检查逻辑等效项。
- en: The radius of a rounded border corner is the radius of a circle or ellipse,
    one-quarter of which is used to define the path of the border’s rounding. We’ll
    start with circles, because they’re a little easier to understand.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 圆角边框角的半径是圆形或椭圆的半径，四分之一用于定义边框的曲线路径。我们将从圆形开始，因为它们稍微容易理解。
- en: 'Suppose we want to round the corner of an element so that each corner is pretty
    obviously rounded. Here’s one way to do that:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要使元素的角显然是圆角。以下是一种方法：
- en: '[PRE64]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: That will have the result shown in [Figure 7-37](#Howborderradiiarecalculated),
    where circle diagrams have been added to two of the corners. (The same rounding
    is done in all four corners.)
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在[图 7-37](#Howborderradiiarecalculated)，其中圆形图表已添加到两个角落（所有四个角落都采用相同的四舍五入）。
- en: '![css5 0737](assets/css5_0737.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0737](assets/css5_0737.png)'
- en: Figure 7-37\. How border radii are calculated
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-37\. 边框半径如何计算
- en: Focus on the top-left corner. There, the border begins to curve 2 em below the
    top of the border, and 2 em to the right of the left side of the border. The curve
    follows along the outside of the 2-em-radius circle.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 聚焦于左上角。在那里，边框开始曲线，在边框顶部以下2 em处，距左侧边框2 em处开始。曲线沿着2 em半径圆的外侧进行。
- en: If we were to draw a box that contained just the part of the top-left corner
    that is curved, that box would be 2 em wide and 2 em tall. The same would happen
    in the bottom- right corner.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制一个仅包含曲线部分的左上角的框，那个框将是2 em宽和2 em高。底部右边角也是如此。
- en: 'With single length values, we get circular corner-rounding shapes. If a single
    percentage is used, the results are far more oval. For example, consider the following,
    illustrated in [Figure 7-38](#Howpercentageborderradiiarecalculated):'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单一长度值，我们得到圆形的角度形状。如果使用单一百分比，结果则更椭圆。例如，考虑以下内容，[图 7-38](#Howpercentageborderradiiarecalculated)中有所说明：
- en: '[PRE65]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![css5 0738](assets/css5_0738.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0738](assets/css5_0738.png)'
- en: Figure 7-38\. How percentage border radii are calculated
  id: totrans-335
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-38\. 百分比边框半径如何计算
- en: Again, let’s focus on the top-left corner. On the left edge, the border curve
    begins at the point 33% of the element box’s height down from the top. In other
    words, if the element box is 100 pixels tall from the top border edge to the bottom
    border edge, the curve begins 33 pixels from the top of the element box.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 再次聚焦于左上角。在左边缘上，边框曲线从元素框顶部到底部的高度的33%处开始。换句话说，如果元素框从顶部边框到底部边框的高度为100像素，则曲线将从元素框顶部33像素处开始。
- en: Similarly, on the top edge, the curve begins at the point 33% of the element
    box’s width from the left edge. So if the box is (say) 600 pixels wide, the curve
    begins 198 pixels from the left edge, because 600 × 0.33 = 198.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，在顶部边缘上，曲线从元素框左边缘的宽度的33%处开始。因此，如果框宽（比如）为600像素，曲线将从左边缘开始的198像素处开始，因为600 ×
    0.33 = 198。
- en: The shape of the curve between those two points is identical to the top-left
    edge of an ellipse whose horizontal radius is 198 pixels long, and whose vertical
    radius is 33 pixels long. (This is the same as an ellipse with a horizontal axis
    of 396 pixels and a vertical axis of 66 pixels.)
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两点之间的曲线形状与水平半径为 198 像素、垂直半径为 33 像素的椭圆的左上边缘相同。（这与水平轴为 396 像素、垂直轴为 66 像素的椭圆相同。）
- en: The same thing is done in each corner, leading to a set of corner shapes that
    mirror each other, rather than being identical.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个角落都做同样的事情，形成一组相互镜像而非相同的角形状。
- en: 'Supplying a single length or percentage value for `border-radius` means all
    four corners will have the same rounding shape. As you may have spotted in the
    syntax definition, you can supply `border-radius` with up to four values. Because
    `border-radius` is a physical property, the values go in clockwise order from
    top left to bottom left, like so:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `border-radius` 提供单个长度或百分比值意味着所有四个角都会具有相同的圆角形状。正如你可能在语法定义中看到的那样，你可以为 `border-radius`
    提供最多四个值。因为 `border-radius` 是一个物理属性，这些值按顺时针顺序从左上到左下排列，如下所示：
- en: '[PRE66]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This TL-TR-BR-BL can be remembered with the mnemonic “TiLTeR BuRBLe,” if you’re
    inclined to such things. The important thing is that the rounding starts in the
    top left and works its way clockwise from there.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: TL-TR-BR-BL 这个顺序可以用“TiLTeR BuRBLe”来记忆，如果你倾向于这样的东西的话。重要的是，圆角从左上角开始，顺时针方向开始。
- en: 'If a value is omitted, the missing values are filled in using a pattern like
    that used for `padding`, and so on. If there are three values, the fourth is copied
    from the second. If there are two, the third is copied from the first, and the
    fourth from the second. If there’s just one, the missing three are copied from
    the first. Thus, the following two rules are identical and will have the result
    shown in [Figure 7-39](#Avarietyofroundedcorners):'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略一个值，则使用类似于 `padding` 的模式填充缺失的值，依此类推。如果有三个值，第四个值从第二个值复制。如果有两个值，则第三个值从第一个值复制，第四个值从第二个值复制。如果只有一个值，则缺少的三个值从第一个值复制。因此，以下两条规则是相同的，并将产生
    [图 7-39](#Avarietyofroundedcorners) 中显示的结果：
- en: '[PRE67]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '![css5 0739](assets/css5_0739.png)'
  id: totrans-345
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0739](assets/css5_0739.png)'
- en: Figure 7-39\. A variety of rounded corners
  id: totrans-346
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-39\. 不同圆角的变化
- en: 'There’s an important aspect to [Figure 7-39](#Avarietyofroundedcorners): the
    rounding of the content area’s background along with the rest of the background.
    See how the silver curves, and the period sits outside it? That’s the expected
    behavior when the content area’s background is different from the padding background
    (you’ll see how to do that in [Chapter 8](ch08.html#backgrounds)) and the curving
    of a corner is large enough to affect the boundary between content and padding.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-39](#Avarietyofroundedcorners) 有一个重要的方面：内容区域背景的圆角化与其他背景一起。看看银色的曲线和句点在外面？当内容区域的背景与填充背景不同时（你将在
    [第 8 章](ch08.html#backgrounds) 中看到如何做到这一点），并且圆角足够大以影响内容和填充之间的边界时，这是预期的行为。'
- en: This is because while `border-radius` changes the way the border and background(s)
    of an element are drawn, it does *not* change the shape of the element box. Consider
    the situation depicted in [Figure 7-40](#Elementswithroundedcornersarestillboxes).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `border-radius` 改变了元素的边框和背景的绘制方式，但*不*改变元素框的形状。考虑一下 [图 7-40](#Elementswithroundedcornersarestillboxes)
    所描述的情况。
- en: '![css5 0740](assets/css5_0740.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0740](assets/css5_0740.png)'
- en: Figure 7-40\. Elements with rounded corners are still boxes
  id: totrans-350
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-40\. 圆角元素仍然是框
- en: 'Here, we have an element that’s been floated to the left, and other text flowing
    past it. The border corners are completely round, using `border-radius: 50%` on
    a square element. Some of its text is sticking out past the rounded corners. Beyond
    the rounded corners, the page background is visible where the corners *would*
    have been, were they not rounded.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们有一个浮动到左侧的元素，并且其他文本流经它。圆角边框完全圆形，使用 `border-radius: 50%` 在一个正方形元素上。一些文本从圆角边框外伸出。超出圆角边框后，页面背景可见，圆角
    *本来* 应该在那里的地方。'
- en: So at a glance, you might assume that the element has been reshaped from box
    to circle (technically to ellipse), and the text just happens to stick out of
    it. But look at the text flowing past the float. It doesn’t flow into the area
    the rounded corners “left behind.” That’s because the corners of the floated element
    are still there. They’re just not visibly filled by border and background, thanks
    to `border-radius`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一眼看去，你可能会认为该元素已经从盒子形状变成了圆形（技术上是椭圆），而文本恰好伸出来。但是看看流过浮动的文本。它并没有流入到圆角“留下的”区域。那是因为浮动元素的角落仍然存在。只是由于
    `border-radius` 的存在，它们的边框和背景没有填充进去。
- en: Rounded corner clamping
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 圆角夹紧
- en: 'What happens if a radius value is so large that it would spill into other corners?
    For example, what happens with `border-radius: 100%`? Or `border-radius: 9999px`
    on an element that’s nowhere near 10,000 pixels tall or wide?'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '如果半径值太大，会溢出到其他角落会发生什么？例如，对于 `border-radius: 100%` 或者在元素上使用 `border-radius:
    9999px`，而该元素远未达到10000像素的高度或宽度呢？'
- en: 'In any such case, the rounding is “clamped” to the maximum it can be for a
    given quadrant of the element. Making sure that buttons always look like round-ended-pill
    shapes can be done like so:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何这种情况下，圆角都会“夹紧”到元素的每个象限的最大可能值。确保按钮始终看起来像圆角形状可以通过以下方式实现：
- en: '[PRE68]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: That will just cap off the shortest ends of the element (usually the left and
    right sides, but no guarantees) to be smooth semicircular caps.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅将元素最短的两端（通常是左右侧，但不能保证）封顶为平滑的半圆形。
- en: More complex corner shaping
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更复杂的角落形状
- en: Now that you’ve seen how assigning a single radius value to a corner shapes
    it, let’s talk about what happens when corners get two values—and, more importantly,
    how they get those values.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解到如何将单个半径值分配给角落以形成它的形状，让我们讨论一下当角落获得两个值时会发生什么，更重要的是，它们如何获得这些值。
- en: 'For example, suppose we want corners to be rounded by 3 character units horizontally,
    and 1 character unit vertically. We can’t just use `border-radius: 3ch 1ch` because
    that will round the top-left and bottom-right corners by `3ch`, and the other
    two corners by `1ch` each. Inserting a forward slash will get us what we’re after:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，假设我们希望将角落水平方向圆角化为3个字符单位，垂直方向为1个字符单位。我们不能简单地使用 `border-radius: 3ch 1ch`，因为这样会使得左上角和右下角分别圆角化为
    `3ch`，而其他两个角则分别为 `1ch`。插入一个斜杠将会得到我们想要的效果：'
- en: '[PRE69]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is functionally equivalent to saying the following:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这等效于以下表述：
- en: '[PRE70]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The way this syntax works, the horizontal radius of each corner’s rounding ellipse
    is given, and then after the slash, the vertical radius of each corner is given.
    In both cases, the values are in TiLTeR BuRBLe order.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的工作方式是，给出每个角落圆角化椭圆的水平半径，然后在斜杠后给出每个角落的垂直半径。在这两种情况下，值是按照 TiLTeR BuRBLe 的顺序给出的。
- en: 'Here’s a simpler example, illustrated in [Figure 7-41](#Ellipticalcornerrounding):'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更简单的例子，如[图7-41](#Ellipticalcornerrounding)所示：
- en: '[PRE71]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![css5 0741](assets/css5_0741.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0741](assets/css5_0741.png)'
- en: Figure 7-41\. Elliptical corner rounding
  id: totrans-368
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-41。椭圆形角落圆角化
- en: Each corner is rounded by 1 em along the horizontal axis, and 2 em along the
    vertical axis, in the manner you saw in detail in the previous section.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角落沿水平轴为1em，沿垂直轴为2em进行圆角化，这种方式你在前面的章节中已经详细看到了。
- en: 'Here’s a slightly more complex version, providing two lengths to either side
    of the slash, as depicted in [Figure 7-42](#Differentellipticalroundingcalculations):'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个稍微复杂一点的版本，提供了斜杠两侧的两个长度，如[图7-42](#Differentellipticalroundingcalculations)所示：
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![css5 0742](assets/css5_0742.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0742](assets/css5_0742.png)'
- en: Figure 7-42\. Different elliptical rounding calculations
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-42。不同椭圆形圆角计算
- en: In this case, the top-left and bottom-right corners are curved 2.5 em along
    the horizontal axis, and 1.5 em along the vertical axis. The top-right and bottom-left
    corners, on the other hand, are curved 2 em along the horizontal and 3 along the
    vertical.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，左上角和右下角沿水平轴曲度为2.5em，沿垂直轴为1.5em。而右上角和左下角则分别沿水平轴为2em，沿垂直轴为3em。
- en: 'Remember, you use horizontal values before the slash, and vertical after. If
    we’d wanted to make the top-left and bottom-right corners rounded 1 em horizontally
    and 1 em vertically (a circular rounding), the values would have been written
    like so:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在斜杠前使用水平值，斜杠后使用垂直值。例如，如果我们想让左上角和右下角的圆角水平方向为1em，垂直方向也为1em（即圆形的圆角），则数值应该写成这样：
- en: '[PRE73]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Percentages are also fair game here. If we want to round the corners of an
    element so that the sides are fully rounded but extend only 2 character units
    into the element horizontally, we’d write it like so:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比在这里也是适用的。如果我们希望将元素的角落圆角，使其侧面完全圆角，但仅水平延伸到元素的2个字符单位，我们会这样写：
- en: '[PRE74]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Corner blending
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 角落混合
- en: So far, the corners we’ve rounded have been pretty simple—always the same width,
    style, and color. That won’t always be the case, though. What happens if a thick,
    red, solid border is rounded into a thin, dashed green border?
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们圆角的角落都相当简单 —— 总是相同的宽度、样式和颜色。但情况并非总是如此。如果一个粗的红色实线边框圆角化成一个细的绿色虚线边框会发生什么？
- en: The specification directs that the rounding cause as smooth a blend as possible
    when it comes to the width. When rounding from a thicker border to a thinner border,
    the width of the border should gradually shrink throughout the curve of the rounded
    corner.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 规范指示，在涉及宽度从较粗的边框过渡到较细的边框时，边框的宽度应在圆角的曲线上逐渐收缩。
- en: When it comes to differing styles and colors, the specification is less clear
    about how this should be accomplished. Consider the various samples shown in [Figure 7-43](#Roundedcornersupclose).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到不同的样式和颜色时，规范对如何实现这一点并不那么明确。请考虑[图 7-43](#Roundedcornersupclose)中展示的各种样本。
- en: '![css5 0743](assets/css5_0743.png)'
  id: totrans-383
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0743](assets/css5_0743.png)'
- en: Figure 7-43\. Rounded corners up close
  id: totrans-384
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-43\. 圆角近距离查看
- en: The first is a simple rounded corner, with no variation in color, width, or
    style. The second shows rounding from one thickness to another. You can visualize
    this second case as defining a circular shape on the outer edge and an elliptical
    shape on the inner edge.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是简单的圆角，颜色、宽度或样式没有变化。第二个显示了从一种厚度到另一种厚度的圆角。你可以将第二种情况视为在外边缘定义一个圆形形状，在内边缘定义一个椭圆形状。
- en: In the third case, the color and thickness stay the same, but the corner curves
    from a solid style on the left to a double-line style on top. The transition between
    styles is abrupt and occurs at the halfway point in the curve.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种情况中，颜色和厚度保持不变，但是角落从左侧的实线样式到顶部的双线样式。样式之间的过渡突然，在曲线的中点发生。
- en: The fourth example shows a transition from a thick solid to a thinner double
    border. Note the placement of the transition, which is *not* at the halfway point.
    It is instead determined by taking the ratio of the two borders’ thicknesses and
    using that to find the transition point. Let’s assume the left border is 10 pixels
    thick, and the top border 5 pixels thick. By summing the two to get 15 pixels,
    the left border gets 2/3 (10/15), and the top border 1/3 (5/15). Thus, the left
    border’s style is used in two-thirds of the curve, and the top border’s style
    in one-third the curve. The width is still smoothly changed over the length of
    the curve.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个示例展示了从厚实线过渡到较细双线的情况。请注意过渡点的位置，这*不*是在中点。相反，它是通过取两个边框厚度的比率来确定的，并使用该比率找到过渡点。假设左边框厚度为10像素，顶部边框厚度为5像素。通过将两者相加得到15像素，左边框获得2/3（10/15），顶部边框获得1/3（5/15）。因此，左边框的样式在曲线的2/3处使用，顶部边框的样式在曲线的1/3处使用。宽度仍然在圆角的长度范围内平滑变化。
- en: The fifth and sixth examples show what happens with color added to the mix.
    Effectively, the color stays linked to the style. This hard transition between
    colors is common behavior among browsers as of late 2022, but it may not always
    be so. The specification explicitly states that user agents *may* blend from one
    border color to another by using a linear gradient. Perhaps one day they will,
    but for now, the changeover is sharp.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 第五和第六个示例展示了在混合颜色时会发生什么。实际上，颜色与样式保持链接。这种颜色之间的硬切换是2022年后浏览器的常见行为，但未来可能不会一直如此。规范明确表示用户代理*可能*通过使用线性渐变从一种边框颜色过渡到另一种边框颜色。也许某天会实现，但目前，变换是突然的。
- en: 'The seventh example in [Figure 7-43](#Roundedcornersupclose) shows a case we
    haven’t really discussed: “What happens if the borders are equal to or thicker
    than the value of `border-radius`?” In this case, the outside of the corner is
    rounded, but the inside is not, as shown. This would occur with code like the
    following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 第七个示例在[图 7-43](#Roundedcornersupclose)中展示了一个我们尚未讨论的情况：“如果边框等于或比`border-radius`的值更厚会发生什么？”在这种情况下，角的外侧是圆角的，但内侧不是，如图所示。这将会在以下代码中发生：
- en: '[PRE75]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Individual rounding properties
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 各自的圆角属性
- en: After that tour of `border-radius`, you might be wondering whether you can just
    round one corner at a time. Yes, you can! First, let’s consider the physical corners,
    which are what `border-radius` brings together.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完`border-radius`之后，你可能想知道是否可以一次只圆角一个角。是的，可以！首先，让我们考虑物理角落，这是`border-radius`所汇集的地方。
- en: 'Each property sets the curve shape for its corner and doesn’t affect the others.
    The fun part is that if you supply two values, one for the horizontal radius and
    one for the vertical radius, there is *no* slash separating them. Really. This
    means that the following two rules are functionally equivalent:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性都为其角设置了曲线形状，不影响其他角。有趣的是，如果你提供两个值，一个是水平半径，一个是垂直半径，它们之间没有斜杠。真的。这意味着以下两条规则在功能上是等效的：
- en: '[PRE76]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The individual corner border radius properties are mostly useful for setting
    a common corner rounding and then overriding just one. Thus, a comic-book-like
    word balloon shape could be done as follows, with the result shown in [Figure 7-44](#links-shaped-like-balloons):'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 单个角边框半径属性主要用于设置公共角圆角，然后仅覆盖一个。因此，类似漫画书般的对话气泡形状可以如下所示完成，其结果显示在[图 7-44](#links-shaped-like-balloons)中：
- en: '[PRE77]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![css5 0744](assets/css5_0744.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0744](assets/css5_0744.png)'
- en: Figure 7-44\. Links shaped like word balloons
  id: totrans-398
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-44\. 形状如对话气泡的链接
- en: In addition to the physical corners, CSS also has logical corners.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 除了物理角落外，CSS 还有逻辑角落。
- en: 'You might be thinking, “Hold on, that’s not what the other logical properties
    looked like!” And that’s true: these are a fair bit different. That’s because
    if we had a property like `border-block-start-radius`, it would apply to both
    corners along the block-start edge. But if you also had `border-inline-start-radius`,
    it would apply to both corners on the inline-start edge, one of which is also
    on the block-start edge.'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：“等等，其他逻辑属性看起来不是这样！”是的，这些确实有些不同。这是因为如果我们有一个像`border-block-start-radius`这样的属性，它将应用于沿块起始边的两个角。但是如果你还有`border-inline-start-radius`，它将适用于沿行内起始边的两个角，其中一个也在块起始边上。
- en: 'So the way the logical border radius properties work is they’re labeled in
    the pattern *border-block-inline-radius*. Thus, `border-start-end-radius` sets
    the radius of the corner that’s at the junction of the block-start and inline-end
    edges. Take the following example, which is illustrated in [Figure 7-45](#logical-border-radius):'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 所以逻辑边框半径属性的工作方式是按照*border-block-inline-radius*模式标记的。因此，`border-start-end-radius`设置了位于块起始和行内结束边缘交界处的角的半径。看下面的例子，它在[图 7-45](#logical-border-radius)中有所说明：
- en: '[PRE78]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '![css5 0745](assets/css5_0745.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0745](assets/css5_0745.png)'
- en: Figure 7-45\. Rounding the block-start, inline-end corner
  id: totrans-404
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-45\. 圆角化块起始，行内结束角
- en: Remember that you can use the same space-separated value pattern for defining
    an elliptical corner radius, as shown earlier in the section for `border-top-left-radius`
    and friends. However, the value is still in the pattern of horizontal radius,
    then vertical radius, instead of being relative to the block and inline flow directions.
    This seems like a bit of an oversight in CSS, but it is how things are as of late
    2022.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你可以使用与之前在`border-top-left-radius`及其伙伴部分中显示的椭圆形角半径定义相同的空格分隔值模式。但是，该值仍然符合水平半径然后垂直半径的模式，而不是相对于块和行内流方向。这似乎是
    CSS 中的一个小疏忽，但截至 2022 年末它是现实。
- en: One thing to keep in mind is that, as you’ve seen, corner shaping affects the
    background and (potentially) the padding and content areas of the element, but
    not any image borders. Wait a minute, image borders? What are those? Glad you
    asked!
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一件事是，正如你所见，角形状会影响元素的背景和（可能）填充和内容区域，但不会影响任何图像边框。等等，图像边框？那是什么？很高兴你问！
- en: Image Borders
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像边框
- en: The various border styles are nice enough but are still fairly limited. What
    if you want to create a really complicated, visually rich border around some of
    your elements? Back in the day, we’d create complex multirow tables to achieve
    that sort of effect, but thanks to image borders, there’s almost no limit to the
    kinds of borders you can create.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 各种边框样式已经足够好了，但仍然相当有限。如果你想要在一些元素周围创建一个真正复杂、视觉丰富的边框，该怎么办？以前，我们会创建复杂的多行表格来实现这种效果，但由于图像边框的出现，你几乎可以创造出各种类型的边框，没有几乎没有限制。
- en: Loading and slicing a border image
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 载入和切片边框图像
- en: If you’re going to use an image to create the borders of an image, you’ll need
    to define it or fetch it from somewhere. The `border-image-source` property is
    how you tell the browser where to look for it.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要使用图像来创建图像的边框，你需要定义它或者从某处获取它。`border-image-source`属性告诉浏览器去哪里查找它。
- en: 'Let’s load an image of a single circle to be used as the border image, using
    the following styles, whose result is shown in [Figure 7-46](#Definingaborderimagessource):'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加载一个单个圆形图像作为边框图像，并使用以下样式，其结果如图7-46所示：
- en: '[PRE79]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![css5 0746](assets/css5_0746.png)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0746](assets/css5_0746.png)'
- en: Figure 7-46\. Defining a border image’s source
  id: totrans-414
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-46\. 定义边框图像的来源
- en: 'There are a few points to note here. First, without the `border: 25px solid`
    declaration, there would have been no border at all. Remember, if the value of
    `border-style` is `none`, the width of the border is 0\. So to make a border image
    appear, you need to have a border, which means declaring a `border-style` value
    other than `none` or `hidden`. It doesn’t have to be `solid`. Second, the value
    of `border-width` determines the actual width of the border images. Without a
    declared value, it will default to `medium`, which is 3 pixels. If the border
    image fails to load, the border is the `border-color` value.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '这里有几个要点需要注意。首先，如果没有声明`border: 25px solid`，就根本不会有边框。记住，如果`border-style`的值为`none`，那么边框的宽度就是0。因此，要使边框图像出现，你需要有一个边框，这意味着声明一个`border-style`值，而不是`none`或`hidden`。它不一定要是`solid`。其次，`border-width`的值确定了边框图像的实际宽度。如果没有声明值，它将默认为`medium`，即3像素。如果边框图像加载失败，边框就是`border-color`的值。'
- en: OK, so we set up a border area 25 pixels wide and then applied an image to it.
    That gave us the same circle in each of the four corners. But why did it appear
    only there and not along the sides? The answer is found in the way the physical
    property `border-image-slice` is defined.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们设置了一个宽度为 25 像素的边框区域，然后将图像应用到了上面。这给了我们每个角落相同的圆形。但为什么它只出现在那里，而不沿着边缘呢？答案在于物理属性`border-image-slice`的定义方式。
- en: What `border-image-slice` does is establish a set of four slice-lines that are
    laid over the image, and where they fall determines how the image will be sliced
    up for use in an image border. The property takes up to four values, defining
    (in order) offsets from the top, right, bottom, and left edges. Yep, there’s that
    TRBL pattern again, which pegs `border-image-slice` as a physical property. And
    value replication is also in effect here, so a single value will be used for all
    four offsets. [Figure 7-47](#Variousslicingpatterns) shows a small sampling of
    offset patterns, all based on percentages.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`border-image-slice`的作用是建立一组覆盖在图像上的四条切片线，它们的位置决定了图像在图像边框中如何被切片使用。该属性最多可以接受四个值，依次定义从顶部、右侧、底部和左侧边缘的偏移量。是的，这里又有了那个TRBL模式，将`border-image-slice`作为物理属性固定了下来。并且值的复制在这里也生效了，因此一个值将被用于所有四个偏移量。图7-47展示了一些基于百分比的偏移模式的小样本。'
- en: '![css5 0747](assets/css5_0747.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0747](assets/css5_0747.png)'
- en: Figure 7-47\. Various slicing patterns
  id: totrans-419
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-47\. 不同的切片模式
- en: Note
  id: totrans-420
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As of late 2022, no logical-property equivalent exists for `border-image-slice`.
    If the proposed `logical` keyword, or something equivalent, is ever adopted and
    implemented, using `border-image-slice` in a writing-flow-relative fashion will
    be possible. There are also no single-side properties; that is, there is no such
    thing as `border-left-image-slice`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年末，`border-image-slice`没有逻辑属性的等效物。如果提议的`logical`关键字或类似的内容被采纳并实施，将可以在写入流相关的方式中使用`border-image-slice`。也没有单侧属性；也就是说，没有`border-left-image-slice`这样的东西。
- en: 'Now let’s take an image that has a 3 × 3 grid of circles, each a different
    color, and slice it up for use in an image border. [Figure 7-48](#Anall-aroundimageborder)
    shows a single copy of this image and the resulting image border:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们取一个有着3×3个圆形的网格的图像，并将其切片用于图像边框。图7-48展示了这个图像的单个副本和结果图像边框：
- en: '[PRE80]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Yikes! That’s…interesting. The stretchiness of the sides is the default behavior,
    and it makes a fair amount of sense, as you’ll see (and find out how to change)
    in [“Altering the repeat pattern”](#altering-the-repeat-pattern). Beyond that
    effect, you can see in [Figure 7-48](#Anall-aroundimageborder) that the slice-lines
    fall right between the circles, because the circles are all the same size and
    so one-third offsets place the slice-lines right between them. The corner circles
    go into the corners of the border, and each side’s circle is stretched out to
    fill its side.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！这…有点有趣。边缘的拉伸性是默认行为，这在某种程度上是合理的，正如你将看到的（以及如何改变）在[“改变重复模式”](#altering-the-repeat-pattern)中。除了这种效果外，你可以在[图 7-48](#Anall-aroundimageborder)中看到，切片线恰好位于圆圈之间，因为所有圆圈的大小都相同，所以1/3的偏移量将切片线放置在它们之间。角圆圈进入边框的角落，每边的圆圈被拉伸以填充其边缘。
- en: '![css5 0748](assets/css5_0748.png)'
  id: totrans-425
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0748](assets/css5_0748.png)'
- en: Figure 7-48\. An all-around image border
  id: totrans-426
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-48\. 全景图像边框
- en: (“Wait, what happened to the gray circle in the middle?” you may wonder. It’s
    an interesting question! For now, just accept it as one of life’s little mysteries,
    albeit a mystery that will be explained later in this section.)
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: （“等等，中间的灰色圆圈怎么了？”你可能会想。这是一个有趣的问题！现在，只需将其接受为生活中的一个小谜团，尽管这是一个稍后在本节中会解释的谜团。）
- en: All right, so why did our first border image example, back at the beginning
    of the section, place images only in the corners of the border area instead of
    all the way around it?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，那么为什么我们在本节开始时的第一个边框图像示例中，只在边框区域的角落放置了图像，而不是完全环绕它？
- en: 'Anytime the slice-lines meet or go past each other, the corner images are created
    but the side images are made empty. This is easiest to visualize with `border-image-slice:
    50%`. In that case, the image is sliced into four quadrants, one for each corner,
    with nothing remaining for the sides.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '每当切片线相遇或超过彼此时，角落图像会被创建，但边缘图像会变为空白。这在`border-image-slice: 50%`的情况下最容易可视化，此时图像被切成四个象限，每个角落有一个，边缘没有剩余部分。'
- en: 'However, any value *above* `50%` has the same basic result, even though the
    image isn’t sliced into neat quadrants anymore. Thus, for `border-image-slice:
    100%`—which is the default value—each corner gets the entire image, and the sides
    are left empty. A few examples of this effect are shown in [Figure 7-49](#Variouspatternsthatpreventsideslices).'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，任何值*超过*`50%`都会产生相同的基本结果，即使图像不再被切成整齐的四分之一。因此，对于`border-image-slice: 100%`——这是默认值——每个角落都得到整个图像，而边缘则为空。这种效果的几个示例显示在[图 7-49](#Variouspatternsthatpreventsideslices)中。'
- en: That’s why we had to have a 3 × 3 grid of circles when we wanted to go all the
    way around the border area, corners, and sides.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么当我们想要环绕边框区域、角落和边缘时，我们必须有一个3 × 3的圆圈网格。
- en: '![css5 0749](assets/css5_0749.png)'
  id: totrans-432
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0749](assets/css5_0749.png)'
- en: Figure 7-49\. Various patterns that prevent side slices
  id: totrans-433
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-49\. 各种阻止边缘切片的图案
- en: 'In addition to using percentage offsets, we also can define the offsets by
    using a number. Not a length, as you might assume, but a bare number. In raster
    images like PNGs or JPEGs, the number corresponds to pixels in the image on a
    1:1 basis. If you have a raster image and want to define 25-pixel offsets for
    the slice-lines, this is how to do that, as illustrated in [Figure 7-50](#Numberslicing):'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用百分比偏移外，我们还可以通过数字来定义偏移量。不是长度，正如你可能会认为的那样，而是一个纯数字。在像PNG或JPEG这样的光栅图像中，该数字与图像上的像素一一对应。如果你有一个光栅图像，并想要为切片线定义25像素的偏移量，这就是如何做到的，如[图 7-50](#Numberslicing)所示：
- en: '[PRE81]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '![css5 0750](assets/css5_0750.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0750](assets/css5_0750.png)'
- en: Figure 7-50\. Number slicing
  id: totrans-437
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-50\. 数字切片
- en: Yikes again! What happened there is that the raster image is 150 × 150 pixels,
    so each circle is 50 × 50 pixels. Our offsets, though, were only `25`, as in 25
    pixels. So the slice-lines were placed on the image as shown in [Figure 7-51](#Slicelinesat25pixels).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕！再次发生了！问题在于光栅图像是150 × 150像素，因此每个圆圈都是50 × 50像素。然而，我们的偏移量只有`25`，即25像素。所以切片线被放置在图像上，如[图 7-51](#Slicelinesat25pixels)所示。
- en: This begins to give us an idea of why the default behavior for the side images
    is to stretch them. Note how the corners flow into the sides, visually speaking.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始让我们了解为什么边缘图像的默认行为是拉伸它们。请注意，角落如何流入边缘，从视觉上讲。
- en: If you change the image to one that has a different size, numeric offsets don’t
    adapt to the new size, whereas percentages do. The interesting thing about number
    offsets is that they work just as well on nonraster images, like SVGs, as they
    do on rasters. So do percentages. In general, it’s probably best to use percentages
    for your slicing offsets whenever possible, even if that means doing a little
    math to get exactly the right percentages.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将图像更改为大小不同的图像，则数值偏移不会适应新的大小，而百分比会适应。关于数字偏移的有趣之处在于，它们在非光栅图像（如SVG）上的工作效果与在光栅图像上的工作效果相同。所以也是百分比。一般来说，最好在可能的情况下使用百分比作为切片偏移量，即使这意味着进行一些数学运算以获得完全正确的百分比。
- en: '![css5 0751](assets/css5_0751.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0751](assets/css5_0751.png)'
- en: Figure 7-51\. Slice-lines at 25 pixels
  id: totrans-442
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-51\. 切片线在25像素处
- en: 'Now let’s address the curious case of the image’s center. In the previous examples,
    a circle is at the center of the 3 × 3 grid of circles, but it disappears when
    the image is applied to the border. In the preceding example, in fact, not only
    the middle circle was missing, but the entire center slice. This dropping of the
    center slice is the default behavior for image slicing, but you can override it
    by adding a `fill` keyword to the end of your `border-image-slice` value. If we
    add `fill` to the previous example, as shown here, we’ll get the result shown
    in [Figure 7-52](#Usingthefillslice):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来解决图像中心的奇特情况。在前面的示例中，一个圆圈位于3 × 3的圆圈网格的中心，但当图像应用于边框时，它会消失。事实上，在前面的例子中，不仅中间的圆圈消失了，整个中心切片也消失了。这种中心切片的丢弃是图像切片的默认行为，但您可以通过在`border-image-slice`值的末尾添加`fill`关键字来覆盖它。如果我们在前面的例子中添加`fill`，如下所示，我们将得到[图
    7-52](#Usingthefillslice)所示的结果：
- en: '[PRE82]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: There’s the center slice, filling up the element’s background area. In fact,
    it’s drawn over the top of whatever background the element might have, including
    any background images or color, so you can use it as a substitute for the background
    or as an addition to it.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这是中心切片，填充元素的背景区域。事实上，它覆盖了元素可能具有的任何背景，包括任何背景图像或颜色，因此您可以将其用作背景的替代品或作为其附加项。
- en: '![css5 0752](assets/css5_0752.png)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0752](assets/css5_0752.png)'
- en: Figure 7-52\. Using the fill slice
  id: totrans-447
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-52\. 使用填充切片
- en: 'You may have noticed that all our border areas have been a consistent width
    (usually `25px`). This doesn’t have to be the case, regardless of how the border
    image is actually sliced up. Suppose we take the circles border image we’ve been
    using, slice it by thirds as we have, but make the border widths different:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，所有我们的边框区域的宽度都是一致的（通常为`25px`）。这并不一定是实际情况，无论图像边框实际如何切割。假设我们采用一直在使用的圆圈边框图像，将其分为三等分，但使边框宽度不同：
- en: '[PRE83]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This would have a result like that shown in [Figure 7-53](#Unevenborderimagewidths).
    Even though the slice-lines are intrinsically set to 50 pixels (via `50`), the
    resulting slices are resized to fit into the border areas they occupy.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似于[图 7-53](#Unevenborderimagewidths)所示的结果。尽管切片线本质上设置为50像素（通过`50`），但生成的切片被调整大小以适应其占据的边框区域。
- en: '![css5 0753](assets/css5_0753.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0753](assets/css5_0753.png)'
- en: Figure 7-53\. Uneven border image widths
  id: totrans-452
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-53\. 不均匀的边框图像宽度
- en: Altering the image widths
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变图像的宽度
- en: Thus far, all our image borders have depended on a `border-width` value to set
    the sizes of the border areas, which the border images have filled out precisely.
    That is, if the top border side is 25 pixels tall, the border image that fills
    it will be 25 pixels tall. If you want to make the images a different size than
    the area defined by `border-width`, you can use the physical property `border-image-width`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的图像边框都依赖于`border-width`值来设置边框区域的大小，边框图像精确填充了这些区域。也就是说，如果顶部边框的高度为25像素，则填充它的边框图像将为25像素。如果您希望使图像的大小与由`border-width`定义的区域大小不同，可以使用物理属性`border-image-width`。
- en: The basic fact to understand about `border-image-width` is that it’s very similar
    to `border-image-slice`, except that `border-image-width` slices up the border
    box itself.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`border-image-width`的基本事实是，它与`border-image-slice`非常相似，只是`border-image-width`切片本身的边框框。
- en: 'To understand what this means, let’s start with length values. We’ll set up
    1-em border widths like so:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这意味着什么，让我们从长度值开始。我们将设置1 em边框宽度如下：
- en: '[PRE84]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: That pushes slice-lines 1 em inward from each of the border area’s sides, as
    shown in [Figure 7-54](#Placingslice-linesfortheborderimageswidth).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使切片线向内推1 em，从边框区域的每一侧显示，如[图 7-54](#Placingslice-linesfortheborderimageswidth)所示。
- en: '![css5 0754](assets/css5_0754.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0754](assets/css5_0754.png)'
- en: Figure 7-54\. Placing slice-lines for the border image’s width
  id: totrans-460
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-54\. 放置边框图像宽度的切片线
- en: 'So the top and bottom border areas are 1 em tall, the right and left border
    areas are 1 em wide, and each corner is 1 em tall and wide. Given that, the border
    images created with `border-image-slice` are filled into those border areas in
    the manner prescribed by `border-image-repeat` (which we’ll get to shortly). Therefore,
    in [Figure 7-55](#css5_border_images-with-and-without), we could have had a `border-width`
    of 0 and still made the border images show up, by using `border-image-width`.
    This is useful if you want to have a solid border as a fallback in case the border
    image doesn’t load, but don’t want to make it as thick as the image border would
    be. You could use something like this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，顶部和底部边框区域高度为 1 em，右侧和左侧边框区域宽度为 1 em，每个角落的高度和宽度也为 1 em。鉴于此，使用 `border-image-slice`
    创建的边框图像将填充到这些边框区域中，其方式由 `border-image-repeat` 规定（我们马上会讨论）。因此，在 [Figure 7-55](#css5_border_images-with-and-without)
    中，我们即使将 `border-width` 设置为 0，也能让边框图像显示出来，通过使用 `border-image-width`。如果边框图像加载失败，这很有用，但不希望边框变得像图像边框那样厚。你可以使用类似这样的东西：
- en: '[PRE85]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![css5 0755](assets/css5_0755.png)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0755](assets/css5_0755.png)'
- en: Figure 7-55\. A border with and without its border image
  id: totrans-464
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-55\. 带和不带边框图像的边框
- en: This allows for a 12-pixel star border to be replaced with a 2-pixel solid border
    if border images aren’t available. Remember that if the image border *does* load,
    you’ll need to leave enough space for it to show up without overlapping the content
    (by default, that is). You’ll see how to mitigate this problem in the next section.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有边框图片可用，这允许将一个 12 像素的星星边框替换为一个 2 像素的实线边框。请记住，如果边框图片确实加载了，你需要留出足够的空间让它显示出来，避免与内容重叠（默认情况下）。在下一节中，你将看到如何解决这个问题。
- en: 'Now that we’ve established how the width slice-lines are placed, the way percentage
    values are handled should make sense, as long as you keep in mind that the offsets
    are with respect to the overall border box, *not* each border side. For example,
    consider the following declaration, illustrated in [Figure 7-56](#Placementofpercentageslice-lines):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了宽度切片线的放置方式，处理百分比值的方式应该是有意义的，只要记住偏移量是相对于整体边框框而言，*而不是*每个边框边缘。例如，请考虑以下声明，在
    [Figure 7-56](#Placementofpercentageslice-lines) 中有所说明：
- en: '[PRE86]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '![css5 0756](assets/css5_0756.png)'
  id: totrans-468
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0756](assets/css5_0756.png)'
- en: Figure 7-56\. Placement of percentage slice-lines
  id: totrans-469
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-56\. 百分比切片线的放置
- en: 'As with length units, the lines are offset from their respective sides of the
    border box. The distance they travel is with respect to the border box. A common
    mistake is to assume that a percentage value is with respect to the border area
    defined by `border-width`; that is, given a `border-width` value of `30px`, the
    result of `border-image-width: 33.333%;` will be 10 pixels. But no! It’s one-third
    the overall border box along that axis.'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '与长度单位一样，这些线条与边框框的各自边缘有偏移。它们行进的距离是相对于边框框的。一个常见的错误是假设百分比值是相对于由 `border-width`
    定义的边框区域；也就是说，给定 `border-width` 值为 `30px`，`border-image-width: 33.333%;` 的结果将是
    10 像素。但事实并非如此！它是沿着该轴的整体边框框的三分之一。'
- en: 'One way in which the behavior of `border-image-width` differs from `border-image-slice`
    is in how it handles slices passing each other, such as in this situation:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`border-image-width` 的行为与 `border-image-slice` 不同之处在于它如何处理互相重叠的片段，比如在以下情况下：'
- en: '[PRE87]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As you may recall, for `border-image-slice`, if the slices pass each other,
    then the side areas (top, right, bottom, and/or left) are made empty. With `border-image-width`,
    the values are proportionally reduced until they no longer pass each other. So,
    given the preceding value of `75%`, the browser will treat that as if it were
    `50%`. Similarly, the following two declarations will have equivalent results:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的那样，对于 `border-image-slice`，如果片段互相通过，那么侧边区域（顶部、右侧、底部和/或左侧）将被清空。对于 `border-image-width`，数值将被按比例减少直至它们不再互相通过。因此，给定
    `75%` 的前值，浏览器会将其视为 `50%`。类似地，后面两个声明将得到相同的结果：
- en: '[PRE88]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Note that in both declarations, the right offset is twice the left value. That’s
    what is meant by proportionally reducing the values until they don’t overlap:
    in other words, until they no longer add up to more than 100%. The same would
    be done with top and bottom, were they to overlap.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这两个声明中，右偏移量是左值的两倍。这就是所谓的按比例减少数值直至它们不再重叠的含义：换句话说，直至它们不再总和超过 100%。如果上下重叠，同样的方式也会被应用。
- en: 'When it comes to number values for `border-image-width`, things get even more
    interesting. If you set `border-image-width: 1`, the border image areas will be
    determined by the value of `border-width`. That’s the default behavior. Thus,
    the following two declarations will have the same result:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '当涉及到`border-image-width`的数字值时，情况变得更加有趣。如果设置`border-image-width: 1`，边框图像区域将由`border-width`的值确定。这是默认行为。因此，以下两个声明将产生相同的结果：'
- en: '[PRE89]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: You can increase or reduce the number values to get a certain multiple of the
    border area that `border-width` defines. [Figure 7-57](#Variousnumericborderimagewidths)
    shows a few examples.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以增加或减少数字值，以获得`border-width`定义的边框区域的某个倍数。[Figure 7-57](#Variousnumericborderimagewidths)展示了一些示例。
- en: 'In each case, the number has been multiplied by the border area’s width or
    height, and the resulting value indicates the inward distance that the offset
    is placed from the relevant side. Thus, for an element that has `border-top-width`
    set to 3 pixels, `border-image-width: 10` will create a 30-pixel offset from the
    top of the element. Change `border-image-width` to `0.333`, and the top offset
    will be a lone pixel.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '在每种情况下，数字都已乘以边框区域的宽度或高度，生成的值指示偏移量从相关边缘处放置的内部距离。因此，对于`border-top-width`设置为3像素的元素，`border-image-width:
    10`将在元素顶部创建一个30像素的偏移量。将`border-image-width`更改为`0.333`，顶部偏移量将是一个像素。'
- en: '![css5 0757](assets/css5_0757.png)'
  id: totrans-480
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0757](assets/css5_0757.png)'
- en: Figure 7-57\. Various numeric border image widths
  id: totrans-481
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-57\. 各种数字边框图像宽度
- en: 'The last value, `auto`, is interesting in that its resulting values depend
    on the state of two other properties. If `border-image-source` has been explicitly
    defined by the author, `border-image-width: auto` uses the values that result
    from `border-image-slice`. Otherwise, it uses the values that result from `border-width`.
    These two declarations will have the same result:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一个值，`auto`，非常有趣，因为其结果取决于另外两个属性的状态。如果作者显式定义了`border-image-source`，那么`border-image-width:
    auto`将使用由`border-image-slice`得出的值。否则，它将使用由`border-width`得出的值。这两个声明将产生相同的结果：'
- en: '[PRE90]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Note that you can mix up the value types for `border-image-width`. The following
    are all valid, and would be quite interesting to try out in live web pages:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以混合使用`border-image-width`的值类型。以下都是有效的，并且在实时网页中尝试将会非常有趣：
- en: '[PRE91]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Note
  id: totrans-486
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As with `border-image-slice`, no logical-property equivalent exists for `border-image-width`
    as of late 2022.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 与`border-image-slice`一样，截至2022年末，尚不存在`border-image-width`的逻辑属性等效项。
- en: Creating a border overhang
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建边框悬挂
- en: Well, now that we can define these great big image slices and widths, how do
    we keep them from overlapping the content? We could add lots of padding, but that
    would leave huge amounts of space if the image fails to load, or if the browser
    doesn’t support border images. Handling such scenarios is what the physical property
    `border-image-outset` is built to manage.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，现在我们可以定义这些大图像片段和宽度了，但如何防止它们重叠内容呢？我们可以添加大量填充，但如果图像加载失败或浏览器不支持边框图像，则会留下大量空间。处理这种情况是物理属性`border-image-outset`的用途所在。
- en: Regardless of whether you use a length or a number, `border-image-outset` pushes
    the border image area outward, beyond the border box, in a manner similar to the
    way slice-lines are offset. The difference is that here, the offsets are outward,
    not inward. Just as with `border-image-width`, number values for `border-image-outset`
    are a multiple of the width defined by `border-width`—*not* `border-image-width`.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用长度还是数字，`border-image-outset`都会将边框图像区域向外推，超出边框框盒，在某种程度上类似于切片线的偏移。区别在于这里的偏移是向外而不是向内。就像`border-image-width`一样，`border-image-outset`的数字值是由`border-width`定义的宽度的倍数，而不是`border-image-width`。
- en: Note
  id: totrans-491
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As with `border-image-slice` and `border-image-width`, no logical-property equivalent
    exists for `border-image-outset` as of late 2022.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 与`border-image-slice`和`border-image-width`一样，截至2022年末，尚不存在`border-image-outset`的逻辑属性等效项。
- en: 'To see how this could be helpful, imagine that we want to use a border image
    but have a fallback of a thin solid border if the image isn’t available. We might
    start out like this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这将如何有助于，想象一下我们想要使用边框图像，但如果图像不可用，则使用一个薄实线边框的备用。我们可能会这样开始：
- en: '[PRE92]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: In this case, we have half an em of padding; at default browser settings, that
    will be about 8 pixels. That plus the 2-pixel solid border make a distance of
    10 pixels from the content edge to the outer border edge. So if the border image
    is available and rendered, it will fill not only the border area, but also the
    padding, bringing it right up against the content.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有半个em的填充；在默认的浏览器设置中，这大约是8像素。再加上2像素的实线边框，从内容边缘到外边框边缘的距离为10像素。因此，如果边框图像可用且已呈现，它将不仅填充边框区域，而且还会填充填充区域，直到与内容紧密相连。
- en: 'We could increase the padding to account for this, but then if the image *doesn’t*
    appear, we’ll have a lot of excess padding between the content and the thin solid
    border. Instead, let’s push the border image outward, like so:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增加填充来解决这个问题，但如果图像*没有*出现，那么在内容和细边框之间就会有大量多余的填充。因此，让我们把边框图像向外推，如下所示：
- en: '[PRE93]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: This is illustrated in [Figure 7-58](#Creatinganimageborderoverhang), and is
    compared to having no outset nor border image.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这在[图 7-58](#Creatinganimageborderoverhang)中有详细说明，并且与无外扩边框图像相比较。
- en: '![css5 0758](assets/css5_0758.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0758](assets/css5_0758.png)'
- en: Figure 7-58\. Creating an image border overhang
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-58\. 创建图像边框悬垂
- en: 'In the first case, the image border has been pushed out far enough that rather
    than overlapping the padding area, the images actually overlap the margin area!
    We can also split the difference so that the image border is roughly centered
    on the border area, like this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，图像边框被推得足够远，以至于不仅重叠了填充区域，而且实际上重叠了边距区域！我们还可以分割差异，使图像边框大致居中于边框区域，如下所示：
- en: '[PRE94]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: What you have to watch out for is pulling the image border too far outward,
    to the point that it overlaps other content or gets clipped off by the edges of
    the browser window (or both). If it does so, the image border will be painted
    between the previous element’s content and background, hiding the background,
    but will be partially obscured if subsequent content has a background or border.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果将图像边框拉得太远，以至于重叠其他内容或被浏览器窗口边缘裁剪（或两者兼有），就必须留意。如果是这样，图像边框将会被绘制在前一个元素的内容和背景之间，从而隐藏背景，但如果后续内容有背景或边框，则会部分遮挡。
- en: Altering the repeat pattern
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变重复模式
- en: So far, you’ve seen a lot of stretched-out images along the sides of our examples.
    The stretching can be handy in some situations but a real eyesore in others. With
    the physical property `border-image-repeat`, you can change the way those sides
    are handled.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了很多在示例的边缘拉伸的图像。在某些情况下，这种拉伸可能很方便，但在其他情况下可能是真正的眼中钉。通过物理属性`border-image-repeat`，你可以改变这些边缘的处理方式。
- en: Note
  id: totrans-506
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As with the previous border image properties, no logical-property equivalent
    exists for `border-image-repeat` as of late 2022.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的边框图像属性一样，截至2022年底，`border-image-repeat`没有逻辑属性的等效项。
- en: Let’s see these values in action and then discuss each in turn. You’ve already
    seen `stretch`, so the effect is familiar. Each side gets a single image, stretched
    to match the height and width of the border side area the image is filling.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些值的作用，然后依次讨论每一个。你已经看到了`stretch`，所以效果很熟悉。每个边都会得到一个单独的图像，被拉伸以匹配边框侧区域的高度和宽度，填充图像正在填充的区域。
- en: The `repeat` value tiles the image until it fills up all the space in its border
    side area. The exact arrangement is to center the image in its side box, and then
    tile copies of the image outward from that point, until the border side area is
    filled. This can lead to some of the repeated images being clipped at the sides
    of the border area, as seen in [Figure 7-59](#Variousimagerepeatpatterns).
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`值会平铺图像，直到填满其边框侧区域的所有空间。确切的排列方式是将图像居中放置在其边框盒中，然后从该点向外平铺图像的副本，直到边框侧区域填满。这可能导致一些重复的图像在边框区域的边缘被裁剪，正如在[图 7-59](#Variousimagerepeatpatterns)中所见。'
- en: '![css5 0759](assets/css5_0759.png)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0759](assets/css5_0759.png)'
- en: Figure 7-59\. Various image-repeat patterns
  id: totrans-511
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-59\. 各种图像重复模式
- en: The `round` value is a little different. With this value, the browser divides
    the length of the border side area by the size of the image being repeated inside
    it. It then rounds to the nearest whole number and repeats that number of images.
    In addition, it stretches or squashes the images so that they just touch each
    other as they repeat.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`round`值略有不同。使用此值时，浏览器将边框侧区域的长度除以图像在其中重复的尺寸。然后四舍五入到最接近的整数，并重复该数量的图像。此外，它会拉伸或压缩图像，使它们在重复时紧密接触。'
- en: As an example, suppose the top border side area is 420 pixels wide, and the
    image being tiled is 50 pixels wide. Dividing 420 by 50 results in 8.4, so that’s
    rounded to 8\. Thus, eight images are tiled. However, each is stretched to be
    52.5 pixels wide (420 ÷ 8 = 52.5). Similarly, if the right border side area is
    280 pixels tall, a 50-pixel-tall image will be tiled six times (280 ÷ 50 = 5.6,
    rounded to 6) and each image will be squashed to 46.6667 pixels tall (280 ÷ 6
    = 46.6667). If you look closely at [Figure 7-59](#Variousimagerepeatpatterns),
    you can see the top and bottom circles are stretched a bit, whereas the right
    and left circles show some squashing. The last value, `space`, starts out similar
    to `round`, in that the border side area’s length is divided by the size of the
    tiled image and then rounded. The differences are that the resulting number is
    always rounded *down*, and images are not distorted but instead distributed evenly
    throughout the border area.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设顶部边框侧面区域宽度为 420 像素，平铺的图像宽度为 50 像素。将 420 除以 50 得到 8.4，因此四舍五入为 8。因此，将有八个图像平铺。但是，每个图像都会拉伸到
    52.5 像素宽（420 ÷ 8 = 52.5）。类似地，如果右侧边框侧面区域高度为 280 像素，50 像素高的图像将被平铺六次（280 ÷ 50 = 5.6，四舍五入为
    6），每个图像将被压缩到 46.6667 像素高（280 ÷ 6 = 46.6667）。如果你仔细看 [图 7-59](#Variousimagerepeatpatterns)，你可以看到顶部和底部的圆圈有些拉伸，而右侧和左侧的圆圈显示出一些压缩。最后一个值
    `space`，开始时类似于 `round`，即将边框侧面区域的长度除以平铺图像的大小，然后四舍五入。不同之处在于，得到的数字总是向下取整，并且图像不会被扭曲，而是均匀分布在边框区域内。
- en: Thus, given a top border side area 420 pixels wide and a 50-pixel-wide image
    to be tiled, there will still be 8 images to repeat (8.4 rounded down is 8). The
    images will take up 400 pixels of space, leaving 20 pixels. That 20 pixels is
    divided by 8, which is 2.5 pixels. Half of that is put to each side of each image,
    meaning each image gets 1.25 pixels of space to either side. That puts 2.5 pixels
    of space between each image, and 1.25 pixels of space before the first and after
    the last image (see [Figure 7-60](#Avarietyofspacerepetitions) for examples of
    `space` repeating).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果给定顶部边框侧面区域为 420 像素宽，并且要平铺的图像宽度为 50 像素，则仍然有 8 个图像需要重复（8.4 四舍五入为 8）。这些图像将占据
    400 像素的空间，剩下 20 像素。这 20 像素被 8 除，得到 2.5 像素。每个图像的两侧各占 1.25 像素的空间。这样每个图像之间就有 2.5
    像素的间隙，并且第一个图像之前和最后一个图像之后各有 1.25 像素的空间（参见 [图 7-60](#Avarietyofspacerepetitions)
    中的 `space` 重复示例）。
- en: '![css5 0760](assets/css5_0760.png)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0760](assets/css5_0760.png)'
- en: Figure 7-60\. A variety of space repetitions
  id: totrans-516
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-60\. 各种空间重复
- en: Shorthand border image
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简写边框图像
- en: The single shorthand physical property for border images is (unsurprisingly
    enough) `border-image`. The way it’s written is a little unusual, but it offers
    a lot of power without a lot of typing.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 对于边框图像的单一简写物理属性（毫不奇怪地）是 `border-image`。它的书写方式有些不同寻常，但是在不多打字的情况下提供了很大的功能。
- en: 'This property value has, it must be admitted, a somewhat unusual syntax. To
    get all the various properties for slices and widths and offsets, *and* be able
    to tell which is which, the decision was made to separate them by forward-slash
    symbols (`/`) and require them to be listed in a specific order: slice, then width,
    then offset. The image source and repeat values can go anywhere outside of that
    three-value chain. Therefore, the following rules are equivalent:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 必须承认，这个属性值的语法有些不寻常。为了获取所有不同的片段、宽度和偏移的属性，并且能够区分哪个是哪个，决定将它们用斜线符号（`/`）分隔，并要求按特定顺序列出：片段、宽度，然后是偏移。图像源和重复值可以放在这三个值链之外的任何地方。因此，以下规则是等效的：
- en: '[PRE95]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The shorthand clearly means less typing, but also less clarity at a glance.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 简写明显减少了输入量，但一目了然的清晰度也降低了。
- en: 'As is usually the case with shorthand properties, leaving out any of the individual
    pieces means that the defaults will be supplied. For example, if we supply just
    an image source, the rest of the properties will be set to their default values.
    Thus, the following two declarations will have exactly the same effect:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 和大多数简写属性一样，如果省略了任何一个单独的部分，那么将会提供默认值。例如，如果我们只提供了一个图像源，则其余属性将设置为它们的默认值。因此，以下两个声明将产生完全相同的效果：
- en: '[PRE96]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Some examples
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些例子
- en: Border images can be tricky to internalize, conceptually speaking, so it’s worth
    looking at some examples of ways to use them.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 边框图像在概念上可能难以内化，因此值得看一些使用它们的示例。
- en: 'First, let’s set up a border with scooped-out corners and a raised appearance,
    like a plaque, with a fallback to a simple outset border of similar colors. We
    might use something like these styles and an image, which is shown in [Figure 7-61](#border-ex-01),
    along with both the final result and the fallback result:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个具有凹角和凸起外观的边框，就像一个匾额，同时也提供一个类似颜色的简单外凸边框的后备方案。我们可能会使用类似这样的样式和一张图片，如[图7-61](#border-ex-01)所示，以及最终结果和后备结果：
- en: '[PRE97]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '![css5 0761](assets/css5_0761.png)'
  id: totrans-528
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0761](assets/css5_0761.png)'
- en: Figure 7-61\. A simple plaque effect and its older-browser fallback
  id: totrans-529
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-61\. 一个简单的匾额效果及其旧版浏览器的后备方案
- en: Notice that the side slices are perfectly set up to be stretched—everything
    about them is just repeated strips of color along the axis of stretching. They
    could also be repeated or rounded in this instance, but stretching works just
    fine. And since that’s the default value, we could have omitted the `border-image-repeat`
    declaration altogether.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，侧边的切片被完美设置为可拉伸的一部分 —— 它们沿拉伸轴只是重复的彩色条带。在这种情况下，它们也可以是重复的或圆角的，但拉伸效果已经很好了。而且，由于这是默认值，我们本可以完全省略`border-image-repeat`声明。
- en: 'Next, let’s try to create something oceanic: an image border that has waves
    marching all the way around. Since we don’t know how wide or tall the element
    will be ahead of time, and we want the waves to flow from one to another, we’ll
    use `round` to take advantage of its scaling behavior while getting in as many
    waves as will reasonably fit. You can see the result in [Figure 7-62](#wavy-border),
    along with the image that’s used to create the effect:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试创建一些海洋风格的东西：一个图像边框，其周围有波浪起伏。由于我们事先不知道元素的宽度或高度，并且希望波浪可以从一个流到另一个，我们将使用`round`来利用其缩放行为，同时尽可能容纳更多的波浪。您可以在[图7-62](#wavy-border)中看到结果，以及用于创建效果的图像：
- en: '[PRE98]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '![css5 0762](assets/css5_0762.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0762](assets/css5_0762.png)'
- en: Figure 7-62\. A wavy border
  id: totrans-534
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-62\. 一个波浪边框
- en: 'You should be wary of one issue here, which is what happens if you add in an
    element background. Just to make the situation clear, we’ll add a red background
    to this element, with the result shown in [Figure 7-63](#border-ex-03):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，请注意一种可能的问题，即如果添加了元素背景会发生什么。为了澄清情况，我们将为该元素添加一个红色背景，结果如[图7-63](#border-ex-03)所示：
- en: '[PRE99]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'See how the background color is visible between the waves? That’s because the
    wave image is a PNG with transparent bits, and the combination of image-slice
    widths and outset enable some of the background area to be visible through the
    transparent parts of the border. This can be a problem, because in some cases
    you’ll want to use a background color in addition to an image border—for the fallback
    case where the image fails to appear, if nothing else. Generally, this is a problem
    best addressed by either not needing a background for the fallback case, using
    `border-image-outset` to pull the image out far enough that no part of the background
    area is visible, or using `background-clip: padding-box` (see [“Clipping the Background”](ch08.html#clipping-the-background)).'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '看到波浪之间可见的背景颜色了吗？这是因为波浪图像是带有透明部分的PNG图像，以及图像切片宽度和外推使得部分背景区域可以通过边框的透明部分看到。这可能是一个问题，因为在某些情况下，您可能希望在图像无法显示时使用背景颜色作为后备方案。通常，这是一个最好通过不需要后备情况的背景、使用`border-image-outset`将图像拉出到足够远，以至于背景区域的任何部分都不可见，或者使用`background-clip:
    padding-box`（见[“裁剪背景”](ch08.html#clipping-the-background)）来解决的问题。'
- en: As you can see, border images have a lot of power. Be sure to use them wisely.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，边框图像具有很大的威力。请务必明智地使用它们。
- en: '![css5 0763](assets/css5_0763.png)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0763](assets/css5_0763.png)'
- en: Figure 7-63\. The background area, visible through the image border
  id: totrans-540
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-63\. 通过图像边框可见的背景区域
- en: Outlines
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮廓
- en: 'CSS defines a special sort of element decoration called an *outline*. In practice,
    outlines are often drawn just beyond the borders, though (as you’ll see) this
    is not the whole story. As the specification puts it, outlines differ from borders
    in three basic ways:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: CSS定义了一种特殊的元素装饰，称为*轮廓*。在实践中，轮廓通常绘制在边框的外侧，尽管（正如您将看到的）这并不是全部。正如规范所说，轮廓与边框在三个基本方面有所不同：
- en: Outlines are visible but do not take up layout space.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮廓是可见的，但不占据布局空间。
- en: User agents often render outlines on elements in the `:focus` state, precisely
    because they do not take up layout space and so do not change the layout.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户代理通常在`:focus`状态下渲染元素的轮廓，这正是因为它们不占据布局空间，因此不会改变布局。
- en: Outlines may be nonrectangular.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮廓可以是非矩形的。
- en: 'To these, we’ll add a fourth:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加第四个：
- en: 'Outlines are an all-or-nothing proposition: you can’t style one side of a border
    independently from the others.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮廓是一种全或无的选择：您不能独立地为边框的一侧设置样式。
- en: Let’s start finding out exactly what all that means. First, we’ll run through
    the various properties, comparing them to their border-related counterparts.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始准确了解所有这些意味着什么。首先，我们将逐一比较各种属性，将它们与其边框相关的对应物进行比较。
- en: Outline Styles
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮廓样式
- en: Much as with `border-style`, you can set a style for your outlines. In fact,
    the values will seem familiar to anyone who’s styled a border before.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 与`border-style`类似，您可以为轮廓设置样式。实际上，这些值对于以前设置过边框样式的人来说应该是熟悉的。
- en: 'The two major differences are that outlines cannot have a `hidden` style, as
    borders can; and outlines can have the `auto` style. This style allows the user
    agent to get extra-fancy with the appearance of the outline, as explained in the
    CSS specification:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要的区别是，轮廓不能有`hidden`样式，如边框可以有；而轮廓可以有`auto`样式。这种样式允许用户代理对轮廓的外观进行额外处理，正如CSS规范中所解释的：
- en: The `auto` value permits the user agent to render a custom outline style, typically
    a style which is either a user interface default for the platform, or perhaps
    a style that is richer than can be described in detail in CSS—e.g., a rounded
    edge outline with semitranslucent outer pixels that appears to glow.
  id: totrans-552
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`auto`值允许用户代理渲染自定义的轮廓样式，通常是平台的用户界面默认样式，或者可能比CSS中详细描述的样式更丰富的样式，例如，带有半透明外边缘像素的圆角轮廓，看起来像是发光的。'
- en: It’s also the case that `auto` allows browsers to use different outlines for
    different elements; e.g., the outline for a hyperlink may not be the same as the
    outline for a form input. When using `auto`, the value for `outline-width` may
    be ignored.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一点是，`auto`允许浏览器为不同的元素使用不同的轮廓；例如，超链接的轮廓可能与表单输入的轮廓不同。使用`auto`时，`outline-width`的值可能会被忽略。
- en: Beyond those differences, outlines have all the same styles that borders have,
    as illustrated in [Figure 7-64](#Variousoutlinestyles).
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些差异之外，轮廓具有与边框相同的所有样式，如图7-64所示。
- en: The less obvious difference is that unlike `border-style`, `outline-style` is
    *not* a shorthand property. You can’t use it to set a different outline style
    for each side of the outline, because outlines can’t be styled that way. There
    is no `outline-top-style`. This is true for all the rest of the outline properties.
    Because of this aspect of `outline-style`, the one property serves both physical
    and logical layout needs.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 较不明显的差异在于，与`border-style`不同，`outline-style`并*非*一种简写属性。你不能用它为每条边的轮廓设置不同的样式，因为轮廓不能以这种方式进行样式化。没有`outline-top-style`这样的东西。这对于所有其他轮廓属性也是如此。由于`outline-style`的这一方面，一个属性同时适用于物理和逻辑布局需求。
- en: '![css5 0764](assets/css5_0764.png)'
  id: totrans-556
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0764](assets/css5_0764.png)'
- en: Figure 7-64\. Various outline styles
  id: totrans-557
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-64\. 各种轮廓样式
- en: Outline Width
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮廓宽度
- en: Once you’ve decided on a style for the outline, assuming the style isn’t `none`,
    you can define a width for the outline.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定轮廓的样式（假设样式不是`none`），您可以为轮廓定义一个宽度。
- en: There’s little to say about outline width that we didn’t already say about border
    width. If the outline style is `none`, the outline’s width is set to `0`. The
    `thick` value is wider than `medium`, which is wider than `thin`, but the specification
    doesn’t define exact widths for these keywords. [Figure 7-65](#Variousoutlinewidths)
    shows a few outline widths.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 关于轮廓宽度，我们已经说过的与边框宽度相同的内容很少。如果轮廓样式为`none`，则轮廓的宽度设置为`0`。`thick`比`medium`宽，`medium`比`thin`宽，但规范没有为这些关键字定义确切的宽度。图7-65展示了几种轮廓宽度。
- en: '![css5 0765](assets/css5_0765.png)'
  id: totrans-561
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0765](assets/css5_0765.png)'
- en: Figure 7-65\. Various outline widths
  id: totrans-562
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7-65\. 各种轮廓宽度
- en: As before, the real difference here is that `outline-width` is not a shorthand
    property, and serves both physical and logical layout needs. You can set only
    one width for the whole outline, and cannot set different widths for different
    sides. (The reasons for this will soon become clear.)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 与以往一样，真正的区别在于`outline-width`不是一种简写属性，并且满足物理和逻辑布局需求。您只能为整个轮廓设置一个宽度，并且不能为不同的边设置不同的宽度。（这些原因很快就会变得明确。）
- en: Outline Color
  id: totrans-564
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轮廓颜色
- en: Does your outline have a style and a width? Great! Let’s give it some color!
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 您的轮廓是否有样式和宽度？太好了！让我们为它添加一些颜色！
- en: This is pretty much the same as `border-color`, with the caveat that it’s an
    all-or-nothing proposition—for example, there’s no `outline-left-color`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`border-color`几乎相同，但有一个警告，即它是一种全有或全无的命题——例如，没有`outline-left-color`。
- en: The one major difference is the default value, `invert`. What `invert` is supposed
    to do is perform a “color conversion” on all pixels within the visible parts of
    the outline. The advantage to color inversion is that it can make the outline
    stand out in a wide variety of situations, regardless of what’s behind it.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的主要差异是默认值`invert`。`invert`的预期操作是对大纲可见部分的所有像素执行“颜色转换”。颜色反转的优势在于，它可以使大纲在各种情况下显著突出，无论背景如何。
- en: However, as of late 2022, literally no browser engines support `invert`. (Some
    did for a while, but that support was removed.) Given this, if you use `invert`,
    it will be rejected by the browser, and the color keyword `currentcolor` will
    be used instead. (See [“Color Keywords”](ch05.html#color_keywords) for details.)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，截至2022年底，真正没有浏览器引擎支持`invert`。（有一段时间一些浏览器支持，但后来取消了支持。）考虑到这一点，如果使用`invert`，浏览器将拒绝它，并且将使用颜色关键字`currentcolor`代替。（详见[“颜色关键字”](ch05.html#color_keywords)。）
- en: The only outline shorthand
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 唯一的大纲简写
- en: 'So far, you’ve seen three outline properties that look like shorthand properties
    but aren’t. It’s time for the one outline property that *is* a shorthand: `outline`.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了三个看起来像简写属性但实际上不是的大纲属性。现在是唯一一个真正的简写属性：`outline`。
- en: It probably comes as little surprise that, like `border`, this is a convenient
    way to set the overall style, width, and color of an outline. [Figure 7-66](#Variousoutlines)
    illustrates a variety of outlines.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不足为奇，就像`border`一样，这是设置大纲的整体样式、宽度和颜色的便捷方式。[图 7-66](#Variousoutlines)展示了各种大纲。
- en: '![css5 0766](assets/css5_0766.png)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0766](assets/css5_0766.png)'
- en: Figure 7-66\. Various outlines
  id: totrans-573
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-66\. 各种大纲
- en: Thus far, outlines seem very much like borders. So how are they different?
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，大纲看起来非常像边框。那么它们有什么不同呢？
- en: How They Are Different
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它们的不同之处
- en: The first major difference between borders and outlines is that outlines, like
    outset border images, don’t affect layout at all. In any way. They’re purely presentational.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 边框和大纲之间的第一个主要区别是，就像外凸边框图像一样，大纲根本不影响布局。以任何方式。它们纯粹是表现性的。
- en: 'To understand what this means, consider the following styles, illustrated in
    [Figure 7-67](#Outlineovermargin):'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这意味着什么，请考虑以下样式，[图 7-67](#Outlineovermargin)中有所说明：
- en: '[PRE100]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '![css5 0767](assets/css5_0767.png)'
  id: totrans-579
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0767](assets/css5_0767.png)'
- en: Figure 7-67\. Outline over margin
  id: totrans-580
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-67\. 大纲覆盖页边距
- en: Looks normal, right? What you can’t see is that the outline is completely covering
    up the margin. If we put in a dotted line to show the margin edges, they’d run
    right along the outside edge of the outline. (We’ll deal with margins in the next
    section.)
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很正常，对吧？您看不到的是大纲完全覆盖了页边距。如果我们放置一条虚线来显示页边缘，它们将沿着大纲的外边缘运行。（我们将在下一节处理页边距。）
- en: 'This is what’s meant by outlines not affecting layout. Let’s consider another
    example, this time with two `<span>` elements that are given outlines. You can
    see the results in [Figure 7-68](#Overlappingoutlines):'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的大纲不影响布局。让我们考虑另一个例子，这次是两个`<span>`元素被赋予了大纲。您可以在[图 7-68](#Overlappingoutlines)中看到结果：
- en: '[PRE101]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '![css5 0768](assets/css5_0768.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0768](assets/css5_0768.png)'
- en: Figure 7-68\. Overlapping outlines
  id: totrans-585
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-68\. 重叠的大纲
- en: The outlines don’t affect the height of the lines, but they also don’t shove
    the `<span>`s to one side or another. The text is laid out as if the outlines
    aren’t even there.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 大纲不影响行高，但它们也不会把`<span>`们推向一边。文本的布局就好像大纲根本不存在一样。
- en: 'This raises an even more interesting feature of outlines: they are not always
    rectangular, nor are they always contiguous. Consider this outline applied to
    a `<strong>` element that breaks across two lines, as illustrated in two scenarios
    in [Figure 7-69](#Discontinuousandnon-rectangularoutlines):'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这提出了大纲的一个更有趣的特征：它们不总是矩形的，也不总是连续的。考虑应用于跨越两行的`<strong>`元素的此大纲，如在[图 7-69](#Discontinuousandnon-rectangularoutlines)中的两种情况所示：
- en: '[PRE102]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '![css5 0769](assets/css5_0769.png)'
  id: totrans-589
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0769](assets/css5_0769.png)'
- en: Figure 7-69\. Discontinuous and nonrectangular outlines
  id: totrans-590
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-69\. 不连续和非矩形的大纲
- en: The first case has two complete outline boxes, one for each fragment of the
    `<strong>` element. In the second case, with the longer `<strong>` element causing
    the two fragments to be stacked together, the outline is “fused” into a single
    polygon that encloses the fragments. You won’t find a border doing *that*.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个案例有两个完整的轮廓框，每个碎片都有一个。在第二种情况下，由于较长的`<strong>`元素使得两个碎片堆叠在一起，轮廓“融合”成一个包围碎片的单个多边形。你不会发现边框做*那样*。
- en: 'This is why CSS has no side-specific outline properties like `outline-right-style`:
    if an outline becomes nonrectangular, which sides are the right sides?'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 CSS 没有像`outline-right-style`这样的特定于侧面的轮廓属性：如果轮廓变成非矩形，哪些侧面是正确的？
- en: Warning
  id: totrans-593
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, not every browser combines the inline fragments into a single
    contiguous polygon. In those that do not support this behavior, each fragment
    is still a self-contained rectangle, as in the first example in [Figure 7-69](#Discontinuousandnon-rectangularoutlines).
    Also, Firefox and Chrome have outlines follow `border-radius` rounding, whereas
    Safari keeps the corners rectangular.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年底，不是每个浏览器都将内联碎片合并成单一的连续多边形。在不支持此行为的浏览器中，每个碎片仍然是一个自包含的矩形，就像图 7-69中的第一个例子一样。此外，Firefox
    和 Chrome 根据`border-radius`圆角处理轮廓，而 Safari 则保持角落为矩形。
- en: Margins
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边距
- en: The separation between most normal-flow elements occurs because of element *margins*.
    Setting a margin creates extra blank space around an element. *Blank space* generally
    refers to an area in which other elements cannot also exist and in which the parent
    element’s background is visible. [Figure 7-70](#Paragraphswithandwithoutmargins)
    shows the difference between two paragraphs without any margins and the same two
    paragraphs with margins.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数正常流元素之间的间隔是由于元素的*边距*。设置边距会在元素周围创建额外的空白空间。*空白空间*通常指其他元素无法存在的区域，父元素的背景可见。[图 7-70](#Paragraphswithandwithoutmargins)显示了两个没有任何边距的段落与具有边距的相同两个段落之间的差异。
- en: '![css5 0770](assets/css5_0770.png)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0770](assets/css5_0770.png)'
- en: Figure 7-70\. Paragraphs with, and without, margins
  id: totrans-598
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-70\. 带有和不带有边距的段落
- en: The simplest way to set a margin is by using the physical property `margin`.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单设置边距的方法是使用物理属性`margin`。
- en: 'Suppose you want to set a quarter-inch margin on `<h1>` elements (a background
    color has been added so you can clearly see the edges of the content area):'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望在`<h1>`元素上设置四分之一英寸的边距（已添加背景颜色，以便清楚地看到内容区域的边缘）：
- en: '[PRE103]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This sets a quarter-inch of blank space on each side of an `<h1>` element, as
    illustrated in [Figure 7-71](#Settingamarginforh1elements). Here, dashed lines
    represent the margin’s outer edge, but the lines are purely illustrative and would
    not actually appear in a web browser.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`<h1>`元素的每一侧设置四分之一英寸的空白空间，如[图 7-71](#Settingamarginforh1elements)所示。这里，虚线表示边距的外边缘，但这些线条仅用于说明，在
    Web 浏览器中实际上不会显示。
- en: '![css5 0771](assets/css5_0771.png)'
  id: totrans-603
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0771](assets/css5_0771.png)'
- en: Figure 7-71\. Setting a margin for `<h1>` elements
  id: totrans-604
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-71\. 为`<h1>`元素设置边距
- en: The `margin` property can accept any length of measure, whether in pixels, inches,
    millimeters, or ems. However, the default value for `margin` is effectively `0`,
    so if you don’t declare a value, by default, no margin should appear.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`margin`属性可以接受任何长度的测量单位，无论是像素、英寸、毫米还是 em。然而，`margin`的默认值实际上是`0`，因此如果您不声明一个值，通常不会出现边距。'
- en: In practice, however, browsers come with preassigned styles for many elements,
    and margins are no exception. For example, in CSS-enabled browsers, margins generate
    the “blank line” above and below each paragraph element. Therefore, if you don’t
    declare margins for the `<p>` element, the browser may apply some margins on its
    own. Whatever you declare will override the default styles.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在实际操作中，浏览器通常为许多元素预先分配样式，边距也不例外。例如，在启用 CSS 的浏览器中，边距会在每个段落元素的上方和下方生成“空白行”。因此，如果您不为`<p>`元素声明边距，浏览器可能会自行应用一些边距。无论您声明什么，都会覆盖默认样式。
- en: Finally, it’s possible to set a percentage value for `margin`. The details of
    this value type are discussed in [“Percentages and Margins”](#percentages-and-margins).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以为`margin`设置百分比值。有关此值类型的详细信息，请参阅[“百分比和边距”](#percentages-and-margins)。
- en: Length Values and Margins
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 长度值和边距
- en: 'Any length value can be used in setting the margins of an element. It’s easy
    enough, for example, to apply 10 pixels of whitespace around paragraph elements.
    The following rule gives paragraphs a silver background, 10 pixels of padding,
    and a 10-pixel margin:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 任何长度值都可以用于设置元素的边距。例如，很容易为段落元素应用 10 像素的空白。以下规则为段落元素设置了银色背景、10 像素的填充和 10 像素的边距：
- en: '[PRE104]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This adds 10 pixels of space to each side of every paragraph, just beyond the
    outer border edge. You can just as easily use `margin` to set extra space around
    an image. Let’s say you want 1 em of space surrounding all images:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每个段落的每一侧外边框边缘之外增加 10 像素的空间。您同样可以使用`margin`为图像周围设置额外的空间。比如说，您想要在所有图像周围留出 1
    em 的空间：
- en: '[PRE105]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: That’s all it takes.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。
- en: 'At times, you might desire a different amount of space on each side of an element.
    That’s easy as well, thanks to the value replication behavior we’ve used before.
    If you want all `<h1>` elements to have a top margin of 10 pixels, a right margin
    of 20 pixels, a bottom margin of 15 pixels, and a left margin of 5 pixels, here’s
    all you need:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望在元素的每一边都有不同的空间量。这也很容易，多亏了我们之前使用过的值复制行为。如果您想让所有`<h1>`元素的顶部边距为 10 像素，右侧边距为
    20 像素，底部边距为 15 像素，左侧边距为 5 像素，那么只需这样做：
- en: '[PRE106]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'It’s also possible to mix up the types of length values you use. You aren’t
    restricted to using a single length type in a given rule, as shown here:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以混合使用不同类型的长度值。在给定的规则中，您不受限于使用单一的长度类型，如以下所示：
- en: '[PRE107]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[Figure 7-72](#Mixed-valuemargins) shows, with a little extra annotation, the
    results of this declaration.'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-72](#Mixed-valuemargins) 显示了这个声明的结果，附带一些额外的注释。'
- en: '![css5 0772](assets/css5_0772.png)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0772](assets/css5_0772.png)'
- en: Figure 7-72\. Mixed-value margins
  id: totrans-620
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-72\. 混合值边距
- en: Percentages and Margins
  id: totrans-621
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 百分比和边距
- en: 'We can set percentage values for the margins of an element. As with padding,
    percentage margin values are computed in relation to the width of the parent element’s
    content area, so they can change if the parent element’s width changes in some
    way. For example, assume the following, which is illustrated in [Figure 7-73](#Parentwidthsandpercentages):'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为元素的边距设置百分比值。与填充一样，百分比边距值是相对于父元素内容区域的宽度计算的，因此如果父元素的宽度以某种方式改变，它们也会相应变化。例如，假设以下情况，这在
    [图 7-73](#Parentwidthsandpercentages) 中有说明：
- en: '[PRE108]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '![css5 0773](assets/css5_0773.png)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0773](assets/css5_0773.png)'
- en: Figure 7-73\. Parent widths and percentages
  id: totrans-626
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-73\. 父元素宽度和百分比
- en: Note that the top and bottom margins are consistent with the right and left
    margins; in other words, the percentage of top and bottom margins is calculated
    with respect to the element’s width, not its height. You’ve seen this before—in
    [“Padding”](#padding), in case you don’t remember—but it’s worth reviewing again,
    just to see how it operates.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，顶部和底部边距与右侧和左侧边距保持一致；换句话说，顶部和底部边距的百分比是相对于元素的宽度计算的，而不是其高度。您之前也看到过这种情况——在 [“填充”](#padding)
    中，如果您记不清楚，现在再看一遍，以了解它的运作方式。
- en: Single-Side Margin Properties
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单边边距属性
- en: As you’ve seen throughout the chapter, CSS has properties that let you set the
    margin on a single side of the box, without affecting the others. There are four
    physical side properties, four logical side properties, and two logical shorthand
    properties.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在本章中看到的那样，CSS 有一些属性可以让您在盒子的单侧设置边距，而不影响其他侧。有四个物理边属性、四个逻辑边属性和两个逻辑的简写属性。
- en: 'These properties operate as you’d expect. For example, the following two rules
    will give the same amount of margin:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性的运作方式如您所预期的那样。例如，以下两个规则将给出相同数量的边距：
- en: '[PRE110]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Similarly, the following two rules will have the same outcome:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下两个规则将有相同的结果：
- en: '[PRE111]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Margin Collapsing
  id: totrans-634
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边距合并
- en: An interesting and often overlooked aspect of the block-start and block-end
    margins on block boxes is that they *collapse* in normal-flow layout. This is
    the process by which two (or more) margins that interact along the block axis
    will collapse to the largest of the interacting margins.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在块级盒子的块起始和块结束边距上有一个有趣且经常被忽视的方面是，在正常流布局中它们会*合并*。这是两个（或多个）沿着块轴交互的边距合并成交互边距中最大的一个的过程。
- en: 'The canonical example of this is the space between paragraphs. Generally, that
    space is set using a rule like this:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个经典例子就是段落之间的空间。通常，可以使用以下规则设置该空间：
- en: '[PRE112]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: That sets every paragraph to have block-start and -end margins of `1em`. If
    margins *didn’t* collapse, then whenever one paragraph followed another, there
    would be 2 ems of space between them. Instead, there’s only 1; the two margins
    collapse together.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使每个段落的块起始和块末端边距都设置为`1em`。如果边距*不*折叠，那么每个段落之间将有2个em的间距。但实际上只有1个em；这两个边距一起折叠了。
- en: To illustrate this a little more clearly, let’s return to the percentage-margin
    example. This time, we’ll add dashed lines to indicate where the margins fall,
    as shown in [Figure 7-74](#Collapsingmargins).
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地说明这一点，让我们回到百分比边距的示例。这一次，我们将添加虚线来显示边距的位置，如[图 7-74](#Collapsingmargins)所示。
- en: '![css5 0774](assets/css5_0774.png)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0774](assets/css5_0774.png)'
- en: Figure 7-74\. Collapsing margins
  id: totrans-641
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-74。边距折叠
- en: The example shows the separation distance between the contents of the two paragraphs.
    It’s 60 pixels, because that’s the wider of the two margins that are interacting.
    The 30-pixel block-start margin of the second paragraph is collapsed, leaving
    the first paragraph’s block-end margin in charge.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 该示例显示了两个段落内容之间的分隔距离。这是60像素，因为这是两者交互的较宽边距。第二个段落的块起始边距30像素被折叠，留下了第一个段落的块末端边距控制整体。
- en: 'So in a sense, [Figure 7-74](#Collapsingmargins) is lying: if you take the
    CSS specification strictly at its word, the block-start (top) margin of the second
    paragraph is actually reset to 0\. It doesn’t stick into the block-end margin
    of the first paragraph because once it collapses, it isn’t there anymore. The
    end result is the same, though.'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在某种意义上，[图 7-74](#Collapsingmargins) 是错误的：如果你严格按照CSS规范来看，第二段落的块起始（顶部）边距实际上会被重置为0。它不会伸入第一个段落的块末端边距，因为一旦发生边距折叠，它就不存在了。尽管如此，最终结果是相同的。
- en: 'Margin collapsing also explains some oddities that arise when one element is
    inside another. Consider the following styles and markup:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 边距折叠还解释了当一个元素位于另一个元素内部时出现的一些奇怪情况。考虑以下样式和标记：
- en: '[PRE113]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The margin on the `<h1>` will push the edges of the `header` away from the content
    of the `<h1>`, right? Well, not entirely. See [Figure 7-75](#Marginscollapsingwithparents).
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`<h1>` 上的边距会将 `header` 的边缘推开，远离 `<h1>` 的内容，对吗？嗯，并非完全如此。请参见[图 7-75](#Marginscollapsingwithparents)。'
- en: What happened? The inline-side margins took effect—we can see that from the
    way the text is moved over—but the block-start and block-end margins are gone!
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？内联边距生效了——从文本被移动的方式我们可以看到——但块起始和块末端边距消失了！
- en: Only they aren’t gone. They’re just sticking out of the `header` element, having
    interacted with the (zero-width) block-start margin of the `header` element. The
    magic of dashed lines in [Figure 7-76](#Marginscollapsingwithparentsrevealed)
    shows us what’s happening.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 它们并没有消失。它们只是从`header`元素中突出出来，并与`header`元素的块起始边距（零宽度）发生了交互。虚线在[图 7-76](#Marginscollapsingwithparentsrevealed)中展示了发生了什么。
- en: '![css5 0775](assets/css5_0775.png)'
  id: totrans-649
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0775](assets/css5_0775.png)'
- en: Figure 7-75\. Margins collapsing with parents
  id: totrans-650
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-75。父元素内边距折叠
- en: '![css5 0776](assets/css5_0776.png)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0776](assets/css5_0776.png)'
- en: Figure 7-76\. Margins collapsing with parents, revealed
  id: totrans-652
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-76。父元素内边距折叠，显示
- en: There the block-axis margins are—pushing away any content that might come before
    or after the `<header>` element, but not pushing away the edges of the `<header>`
    itself. This is the intended result, even if it’s often not the *desired* result.
    As for *why* it’s intended, imagine what happens if you put a paragraph in a list
    item. Without the specified margin-collapsing behavior, the paragraph’s block-start
    (in this case, the top) margin would shove it downward, where it would be far
    out of alignment with the list item’s bullet (or number).
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 那里的块轴边距——推开了任何可能位于`<header>`元素之前或之后的内容，但没有推开`<header>`本身的边缘。这是预期的结果，即使这通常不是*期望*的结果。至于*为什么*是预期的结果，想象一下如果你把段落放在列表项中会发生什么。如果没有指定的边距折叠行为，段落的块起始边距（在这种情况下是顶部）将把它向下推，使其与列表项的标志（或编号）严重不对齐。
- en: Note
  id: totrans-654
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Margin collapsing can be interrupted by factors such as padding and borders
    on parent elements. For more details, see the discussion in [“Collapsing Block-Axis
    Margins”](ch06.html#collapsing-block-axis-margins).
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 父元素上的填充和边框等因素可以中断边距的折叠。有关更多详细信息，请参见[“块轴边距的折叠”](ch06.html#collapsing-block-axis-margins)中的讨论。
- en: Negative Margins
  id: totrans-656
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 负边距
- en: 'It’s possible to set negative margins for an element. This can cause the element’s
    box to stick out of its parent or to overlap other elements. Consider these rules,
    which are illustrated in [Figure 7-77](#Negativemarginsinaction):'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为元素设置负边距。这可能导致元素的框突出其父元素或重叠其他元素。考虑以下规则，这些规则在[图 7-77](#Negativemarginsinaction)中有所说明：
- en: '[PRE114]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '![css5 0777](assets/css5_0777.png)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0777](assets/css5_0777.png)'
- en: Figure 7-77\. Negative margins in action
  id: totrans-660
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-77. 负边距的实际应用
- en: In the first case, the math works out such that the paragraph’s computed width
    plus its inline-start and inline-end margins are exactly equal to the width of
    the parent `<div>`. So the paragraph ends up 2 ems wider than the parent element.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，数学计算结果显示，段落的计算宽度加上其内联开始和内联结束边距恰好等于父元素 `<div>` 的宽度。因此，段落最终比父元素宽出 2 ems。
- en: In the second case, the negative block-start and block-end margins move the
    paragraph’s block-start and -end outer edges inward, which is how it ends up overlapping
    the paragraphs before and after it.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况中，负的块开始和块结束边距会将段落的块开始和块结束外边缘向内移动，这就是它最终重叠在它之前和之后的段落上的原因。
- en: 'Combining negative and positive margins is actually very useful. For example,
    you can make a paragraph “punch out” of a parent element by being creative with
    positive and negative margins, or you can create a Mondrian effect with several
    overlapping or randomly placed boxes, as shown in [Figure 7-78](#Punchingoutofaparent):'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 结合负边距和正边距实际上非常有用。例如，你可以通过巧妙地使用正负边距使段落从父元素“突出”，或者可以通过几个重叠或随机放置的框创建蒙德里安效果，如[图 7-78](#Punchingoutofaparent)所示：
- en: '[PRE115]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Thanks to the negative bottom margin for the `mond` paragraph, the bottom of
    its parent element is pulled upward, allowing the paragraph to stick out of the
    bottom of its parent.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `mond` 段落的负底边距，其父元素的底部被向上拉动，使段落能够突出其父元素的底部。
- en: '![css5 0778](assets/css5_0778.png)'
  id: totrans-666
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0778](assets/css5_0778.png)'
- en: Figure 7-78\. Punching out of a parent
  id: totrans-667
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-78. 从父元素中突出
- en: Margins and Inline Elements
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边距和内联元素
- en: 'Margins can also be applied to inline elements. Let’s say you want to set block-start
    and block-end margins on strongly emphasized text:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 边距也可以应用于内联元素。假设你想在强调文本的块开始和块结束上设置边距：
- en: '[PRE116]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This is allowed in the specification, but on an inline nonreplaced element,
    they will have absolutely no effect on the line height (the same as for padding
    and borders). And since margins are always transparent, you won’t even be able
    to see that they’re there. In effect, they’ll have no effect at all.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这在规范中是允许的，但在内联非替换元素上，它们对行高没有任何影响（与填充和边框一样）。由于边距总是透明的，你甚至看不到它们的存在。实际上，它们根本没有任何效果。
- en: 'As with padding, the layout effects change a bit when you apply margins to
    the inline-start and inline-end sides of an inline nonreplaced element, as illustrated
    in [Figure 7-79](#Aninlinenonreplacedelementwithaleftmargin):'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 与填充类似，当你将边距应用于内联非替换元素的内联开始和内联结束两侧时，布局效果会有所改变，如[图 7-79](#Aninlinenonreplacedelementwithaleftmargin)所示：
- en: '[PRE117]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '![css5 0779](assets/css5_0779.png)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0779](assets/css5_0779.png)'
- en: Figure 7-79\. An inline nonreplaced element with an inline-start margin
  id: totrans-675
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-79. 具有内联开始边距的内联非替换元素
- en: 'Note the extra space between the end of the word just before the inline nonreplaced
    element and the edge of the inline element’s background. You can add that extra
    space to both ends of the inline element if you want:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单词的末尾与内联非替换元素的背景边缘之间存在额外空间。如果你希望，可以在内联元素的两端都添加这种额外空间：
- en: '[PRE118]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: As expected, [Figure 7-80](#Aninlinenonreplacedelementwith25-pixelsidemargins)
    shows a little extra space on the inline-start and -end sides of the inline element,
    and no extra space above or below it.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，[图 7-80](#Aninlinenonreplacedelementwith25-pixelsidemargins)显示内联元素的内联开始和内联结束两侧有一些额外空间，但上下没有额外空间。
- en: '![css5 0780](assets/css5_0780.png)'
  id: totrans-679
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0780](assets/css5_0780.png)'
- en: Figure 7-80\. An inline nonreplaced element with 25-pixel side margins
  id: totrans-680
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-80. 具有 25 像素边距的内联非替换元素
- en: 'Now, when an inline nonreplaced element stretches across multiple lines, the
    situation changes. [Figure 7-81](#Aninlinenonreplacedelementwith25-pixelsidemargindisplayedacrosstwolinesoftext)
    shows what happens when an inline nonreplaced element with a margin is displayed
    across multiple lines:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当内联非替换元素跨越多行时，情况就不同了。[图 7-81](#Aninlinenonreplacedelementwith25-pixelsidemargindisplayedacrosstwolinesoftext)展示了当具有边距的内联非替换元素跨越多行文本时会发生什么：
- en: '[PRE119]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '![css5 0781](assets/css5_0781.png)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0781](assets/css5_0781.png)'
- en: Figure 7-81\. An inline nonreplaced element with 25-pixel side margin displayed
    across two lines of text
  id: totrans-684
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-81\. 具有 25 像素侧边距的行内非替换元素显示在两行文本中
- en: The inline-start margin is applied to the beginning of the element, and the
    inline-end margin to the end of it. Margins are *not* applied to the inline-start
    and -end side of each line fragment. Also, you can see that, if not for the margins,
    the line may have broken a word or two sooner. Margins affect line breaking only
    by changing the point at which the element’s content begins within a line.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 行内起始边距应用于元素的开头，行内结束边距应用于元素的末尾。边距不应用于每个行片段的行内起始和行内结束侧。此外，您可以看到，如果没有边距，该行可能会更早地断开一个或两个单词。边距通过改变元素内容在行内开始的点来影响断行。
- en: Tip
  id: totrans-686
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can alter the way margins are (or aren’t) applied to the ends of each line
    box by using the property `box-decoration-break`. See [Chapter 6](ch06.html#basic-visual-formatting)
    for more details.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `box-decoration-break` 属性，您可以改变边框装饰如何（或不）应用于每个行框的末端。详见 [第 6 章](ch06.html#basic-visual-formatting)。
- en: 'The situation gets even more interesting when we apply negative margins to
    inline nonreplaced elements. The block-start and block-end of the element aren’t
    affected, and neither are the heights of lines, but the inline-start and inline-end
    sides of the element can overlap other content, as depicted in [Figure 7-82](#Aninlinenonreplacedelementwithanegativemargin):'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对行内非替换元素应用负边距时，情况变得更加有趣。元素的块起始和块结束不受影响，行高也不受影响，但元素的行内起始和行内结束可能会重叠其他内容，如图
    [7-82 图](#Aninlinenonreplacedelementwithanegativemargin) 所示：
- en: '[PRE120]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '![css5 0782](assets/css5_0782.png)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0782](assets/css5_0782.png)'
- en: Figure 7-82\. An inline nonreplaced element with a negative margin
  id: totrans-691
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-82\. 具有负边距的行内非替换元素
- en: 'Replaced inline elements represent yet another story: margins set for them
    *do* affect the height of a line, either increasing or reducing it, depending
    on the value for the block-start and block-end margin. The inline-side margins
    of an inline replaced element act the same as for a nonreplaced element. [Figure 7-83](#Inlinereplacedelementswithdifferingmarginvalues)
    shows a series of effects on layout from margins set on inline replaced elements.'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 替换的行内元素代表另一个故事：为它们设置的边距确实会影响行的高度，无论是增加还是减少，这取决于块起始和块结束边距的值。行内替换元素的行内侧边距与非替换元素的行内侧边距的行为相同。图
    [7-83 图](#Inlinereplacedelementswithdifferingmarginvalues) 展示了对行内替换元素设置边距所产生的一系列布局效果。
- en: '![css5 0783](assets/css5_0783.png)'
  id: totrans-693
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0783](assets/css5_0783.png)'
- en: Figure 7-83\. Inline replaced elements with differing margin values
  id: totrans-694
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-83\. 具有不同边距值的行内替换元素
- en: Summary
  id: totrans-695
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: The ability to apply margins, borders, and padding to any element allows you
    to manage the separation and appearance of elements in a detailed way. Understanding
    how they interact with each other is the foundation of design for the web.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对任何元素应用边距、边框和填充，这样可以详细管理元素之间的间隔和外观。理解它们如何相互作用是Web设计的基础。
