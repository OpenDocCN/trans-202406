<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Managing Trust Across Teams"><div class="chapter" id="managing_trust_across_teams">
<h1><span class="label">Chapter 8. </span>Managing Trust Across Teams</h1>
<p>In the previous chapter we explored how network policy represents<a contenteditable="false" data-type="indexterm" data-primary="teams" data-secondary="managing trust across" data-seealso="role-based access control" id="idm45326825795328"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="about" data-tertiary="trust across teams" id="idm45326825793712"/><a contenteditable="false" data-type="indexterm" data-primary="trust across teams" data-see="role-based access control" id="idm45326825792048"/> an opportunity to adopt a shift-left philosophy for network security, where security is defined by teams earlier in the development cycle rather than being defined and maintained by a security team late in the process. This approach can bring a lot of benefits, but to be viable, there needs to be a corresponding degree of trust and split of responsibilities between the teams involved.</p>
<p>In most organizations, it’s not practical to shift 100% of the responsibility for security all the way to the left, with all other teams (platform, network, and security) washing their hands of any responsibility for security. So for example, while the responsibility for lower-level details of individual microservice security may be shifted left, the security team may still be responsible for ensuring that your Kubernetes deployment has a security posture that meets internal and external compliance requirements.</p>
<p>Some enterprises handle this by defining internal processes, for example, to ensure the security team reviews all security changes before they are applied. The downside of this approach is it can reduce agility, which is at odds with one of the motivations for shifting left, that being to increase agility.</p>
<p>Fortunately, there are various types of guardrails that can be put in place across a Kubernetes environment that reduce the need for these kinds of traditional process controls. In this chapter we will explore some of these capabilities and how they can be used to control the degree of trust being delegated from one team to another in the context of a shift-left approach to security.</p>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Role-Based Access Control"><div class="sect1" id="role_based_access_control">
<h1 class="less_space">Role-Based Access Control</h1>
<p>Kubernetes role-based access control (RBAC) is the primary tool for<a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="about" id="idm45326825785104"/> defining the scope of what individual users or groups of users are permitted to do in a Kubernetes cluster. RBAC permissions are defined using roles and granted to users or groups of users via role bindings. <a contenteditable="false" data-type="indexterm" data-primary="namespaced role-based access control" id="idm45326825783328"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="namespaced RBAC" id="idm45326825782128"/>Each role includes a list of resources (specified by resource type, cluster-wide, within a namespace, or even a specific resource instance) and the permissions for each of the resources (e.g., get, list, create, update, delete, etc.).</p>
<p>Many Kubernetes resources are namespaced, including deployments, daemonsets, pods, and Kubernetes network policies. This makes the namespace an ideal trust boundary between teams. There are no set rules for how to use namespaces, but one common practice is to use a namespace per microservice. RBAC can then be used to grant permission to manage the resources in the namespace to the team responsible for operating the corresponding microservice.</p>
<p>If security has been shifted left, this would normally include permissions to manage the network policies that apply to the microservice, but not to manage any network policies that apply to microservices they are not responsible for.</p>
<p>If default deny–style best practices are being followed for both ingress<a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="default deny–style best practices" data-tertiary="network policies necessary" id="idm45326825778384"/><a contenteditable="false" data-type="indexterm" data-primary="microservices" data-secondary="network policy and" data-tertiary="default deny–style best practices" id="idm45326825776688"/><a contenteditable="false" data-type="indexterm" data-primary="default deny network policies" data-secondary="network policies necessary" id="idm45326825775024"/> and egress traffic, then the team cannot forget to write network policies, because the microservice will not work without them. In addition, since other teams will have defined equivalent network policies covering both ingress and egress traffic for the microservices they are responsible for, traffic is allowed between two microservices only if both teams have specified network policy that says the traffic is allowed. This further controls the degree of trust being delegated to each team.</p>
<p>Of course, depending on the degree to which security has been shifted left, the responsibility for defining network policies may fall to a different team than the team responsible for operating the microservice. Again, Kubernetes RBAC can be used to easily reflect this split of responsibilities.</p>
<section data-type="sect2" data-pdf-bookmark="Limitations with Kubernetes Network Policies"><div class="sect2" id="limitations_with_kubernetes_network_pol">
<h2>Limitations with Kubernetes Network Policies</h2>
<p>There are a couple of limitations it is worth being aware of when<a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="network policies" data-tertiary="limitations" id="idm45326825770288"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="role-based access control limitations" id="idm45326825768544"/> using RBAC with Kubernetes network policies in a shift-left environment:</p>
<ul>
<li><p>Default deny–style policies need to be created per namespace<a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="default deny–style best practices" data-tertiary="per namespace" id="idm45326825765936"/><a contenteditable="false" data-type="indexterm" data-primary="default deny network policies" data-secondary="per namespace" id="idm45326825764080"/><a contenteditable="false" data-type="indexterm" data-primary="microservices" data-secondary="network policy and" data-tertiary="default deny per namespace" id="idm45326825762688"/><a contenteditable="false" data-type="indexterm" data-primary="namespaced role-based access control" data-secondary="default deny policies per namespace" id="idm45326825761024"/> at the time the namespace is provisioned. The team responsible for defining network policies for the microservice would also have the ability to modify or delete this default policy if they wanted to.</p></li>
<li><p>Network policies are IP-based, <a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="network policies IP-based" id="idm45326825758720"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="about" data-tertiary="IP-based" id="idm45326825757280"/><a contenteditable="false" data-type="indexterm" data-primary="fully qualified domain names (FQDN)" id="idm45326825755632"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="about" data-tertiary="fully qualified domain names" id="idm45326825754512"/>and you cannot use fully qualified domain names (FQDNs). This can be a limitation especially when defining policies to resources external to the cluster.</p></li>
<li><p>Kubernetes RBAC controls access to resources but does not constrain the contents of resources. <a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="labels" data-tertiary="network policies" id="idm45326825751888"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="pod labels for identification" id="idm45326825750240"/>Of particular relevance in the context of network policies are pod labels, since these are used as the primary mechanism for identifying other microservices in network policy rules. So for example, if one team has written a network policy for their microservice with a rule allowing traffic to it from pods with a particular label, then in theory any team with permission to manage pods could add that label to their pods and get access to the microservice. This exposure can be reduced by always using namespace sectors within policy rules and being selective as to which teams have permissions to change namespace labels.</p></li>
</ul>
<p>If standardized policy and label schemas have been defined and <a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="labels" data-tertiary="best practice schemas" id="idm45326825747568"/><a contenteditable="false" data-type="indexterm" data-primary="best practices" data-secondary="network policy" data-tertiary="policy and label schemas" id="idm45326825745840"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="best practices" data-tertiary="policy and label schemas" id="idm45326825744176"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="pod labels for identification" data-tertiary="best practice schemas" id="idm45326825742512"/>the teams are trusted to follow them, then these limitations are more of a theoretical rather than practical issue. However, for some organizations, they may represent genuine issues for their security needs. These organizations may therefore want to leverage additional capabilities beyond Kubernetes RBAC and Kubernetes network policies. In particular, they might <span class="keep-together">consider:</span></p>
<ul>
<li><p>Richer network policy implementations that support additional network policy types, match criteria, and non-namespaced network policies, which open up more options for how to split responsibilities and RBAC across teams</p></li>
<li><p>Admission controllers to enforce controls on a per-field level within resources, for example to ensure a standardized network policy and label schemas are followed, including limiting teams to using particular labels</p></li>
</ul>
<p>We will now review network policy implementations that extend the Kubernetes network policy and how you can use the same to manage trust.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Richer Network Policy Implementations"><div class="sect2" id="richer_network_policy_implementations">
<h2>Richer Network Policy Implementations</h2>
<p>Some network policy implementations support both Kubernetes <a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="network policies" data-tertiary="richer network policy implementations" id="ch08-rich"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="role-based access control limitations" data-tertiary="richer network policy implementations" id="ch08-rich2"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="implementations" data-tertiary="richer network policy implementations" id="ch08-rich3"/>network policies and their own custom network policy resources that can be used alongside or instead of Kubernetes network policies. Depending on the implementation, these may open up additional options for how to split responsibilities and use RBAC across teams. There are vendors that offer richer network policy implementations that support the Kubernetes network policy and add more features (e.g., Weave Net, Kube-router, Antrea, Calico). We encourage you to review these and choose the best one that meets your needs. In this section we will look at the concrete example using Calico, as it is the most widely deployed container network plug-in.</p>
<p>Calico supports the Kubernetes network policy feature set, plus its <a contenteditable="false" data-type="indexterm" data-primary="Calico Enterprise" data-secondary="network policies" data-tertiary="richer network policies" id="ch08-rchr"/>own Calico network policy resources, which can be used alongside Kubernetes network policies. There are two types of Calico network policies, both under the projectcalico.org/v3 API group:</p>
<dl>
<dt>NetworkPolicy</dt>
<dd>These policies are namespaced (just like Kubernetes network policies).</dd>
<dt>GlobalNetworkPolicy</dt>
<dd>These policies apply across the whole of the cluster independent of namespace.</dd>
</dl>
<p>Both types of Calico network policy support a common set of capabilities beyond Kubernetes network policies, including:</p>
<ul>
<li><p>A richer set of match criteria than Kubernetes network policies, for example with the ability to match on Kubernetes service accounts.</p></li>
<li><p>Explicit allow, deny, or log actions for policy rules, rather than Kubernetes network policy actions, which are implicitly always allow.</p></li>
<li><p>Precedence ordering to define the evaluation order of the network policies if multiple policies apply to the same workload. (Note that if you are just using Kubernetes network policies, or Calico policies only with allow actions in them, then evaluation order doesn’t make any difference to the outcome of the policies. However, as soon as there are any policy rules with deny actions, ordering becomes important.)</p></li>
</ul>
<p>We want to mention that there are other network policy implementations that extend the Kubernetes network policy, like Antrea, which offers ClusterNetworkPolicy (similar to GlobalNetworkPolicy).</p>
<p>The following sample shows how you can implement network policies <a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="network policies" data-tertiary="RBAC implemented via" id="idm45326825718688"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="role-based access control implementation" id="idm45326825716944"/>using Kubernetes RBAC. In the example you can control network access based on the labels assigned to a service account. In Kubernetes, pods have service accounts associated with them, and therefore pods can be identified by service accounts. You should use RBAC to control which users can assign labels to service accounts. The network policy in the example uses the labels assigned to service accounts to control network access. Pods with an intern service account can communicate only with pods with service accounts labeled <code>role == intern</code>:</p>
<pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">projectcalico.org/v3</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">NetworkPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">restrict-intern-access</code>
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">prod-engineering</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">serviceAccountSelector</code><code class="p">:</code> <code class="s">'role</code><code class="nv"> </code><code class="s">==</code><code class="nv"> </code><code class="s">"intern"'</code>
  <code class="nt">ingress</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Allow</code>
      <code class="nt">source</code><code class="p">:</code>
        <code class="nt">serviceAccounts</code><code class="p">:</code>
          <code class="nt">selector</code><code class="p">:</code> <code class="s">'role</code><code class="nv"> </code><code class="s">==</code><code class="nv"> </code><code class="s">"intern"'</code>
  <code class="nt">egress</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Allow</code>
      <code class="nt">destination</code><code class="p">:</code>
        <code class="nt">serviceAccounts</code><code class="p">:</code>
          <code class="nt">selector</code><code class="p">:</code> <code class="s">'role</code><code class="nv"> </code><code class="s">==</code><code class="nv"> </code><code class="s">"intern"'</code></pre>
<p>This way you can extend the concept of RBAC, which controls service account access to a Kubernetes resource for network access. It is a two-step process. RBAC is used to control label assignment to service accounts, and a label-based service account selector is used to control network access. These additional capabilities can be leveraged alongside Kubernetes network policies to more cleanly split responsibilities between higher-level cluster ops or security teams and individual microservice teams.</p>
<p>This could look like, for example:</p>
<ul>
<li><p>Giving the cluster ops or security team RBAC permissions to manage Calico network policies at the cluster-wide scope, so they can define basic higher-level rules that set the overall security posture of the cluster. For example, a default deny–style app policy (as discussed in <a data-type="xref" href="ch07.xhtml#network_policy">Chapter 7</a>) and policies can restrict cluster egress to specific pods.</p></li>
<li><p>Giving each microservice team RBAC permissions to define Kubernetes network policies in the microservice’s namespaces, so they can define their own fine-grained constraints for the microservices they are responsible for.</p></li>
</ul>
<p>On top of this basic split in network policy RBAC permissions, the cluster ops or security team can delegate different levels of trust to each microservice team by defining rules using namespaces or service accounts labels, rather than simplifying matching on pod labels. For example, they could define policies to restrict cluster egress to specific pods using service account labels and give the individual microservice teams permissions to use, but not edit, any service accounts assigned to their namespace. Through this mechanism some microservice teams may be granted permission to selectively allow cluster egress from some of their pods, while not offering other teams the same permissions.</p>
<p><a data-type="xref" href="#an_example_of_implementing_trust_bounda">Figure 8-1</a> provides a simplified illustration of how these ideas can be combined.</p>

<p>While these capabilities are reasonably powerful, in some organizations the required split of responsibilities across teams may be more complex, particularly where there are more layers of teams. <a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="hierarchical network policies" id="idm45326825613712"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="network policies" data-tertiary="hierarchical network policies" id="idm45326825612272"/>For example, a compliance team, security team, cluster ops team, and individual microservice teams all may have different levels of responsibility. One way to more easily meet these requirements is to use a network policy implementation that supports the notion of hierarchical network policies.</p>
<figure><div id="an_example_of_implementing_trust_bounda" class="figure">
<img src="Images/ksao_0801.png" alt="" width="1310" height="1169"/>
<h6><span class="label">Figure 8-1. </span>An example of implementing trust boundaries with network policy</h6>
</div></figure>
<p>There are some commercial implementations that support hierarchical network policy using policy tiers. A similar concept (hierarchical namespaces and policies) is also being discussed in the Kubernetes community. RBAC for each tier can be defined to restrict who can interact with the tier. In this model, network policies are layered in tiers, which are evaluated in a defined order, with as many tiers as required to match the organizational split of responsibilities. RBAC for each tier can be defined to restrict who can interact with the tier. The network policies in each tier can make allow or deny decisions (that terminate evaluation of any following policies) or pass the decision on to the next tier in the hierarchy to be evaluated against the policies in that tier.</p>

<p class="pagebreak-before"><a data-type="xref" href="#implementing_hierarchical_network_polic">Figure 8-2</a> provides a simplified illustration of how these capabilities can be used to split responsibilities across three distinct layers of responsibility within an <span class="keep-together">organization.</span><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch08-rich" id="idm45326825604640"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch08-rich2" id="idm45326825603264"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch08-rich3" id="idm45326825601888"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch08-rchr" id="idm45326825600512"/></p>
<figure><div id="implementing_hierarchical_network_polic" class="figure">
<img src="Images/ksao_0802.png" alt="" width="1443" height="884"/>
<h6><span class="label">Figure 8-2. </span>Implementing hierarchical network policies using tiers</h6>
</div></figure>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Admission Controllers"><div class="sect2" id="admissions_controllers">
<h2>Admission Controllers</h2>
<p>We have already discussed the value of defining and following standardized<a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="admission controllers" id="idm45326825595552"/><a contenteditable="false" data-type="indexterm" data-primary="admission controllers" data-secondary="role-based access control" id="idm45326825594160"/><a contenteditable="false" data-type="indexterm" data-primary="role-based access control (RBAC)" data-secondary="network policies" data-tertiary="admission controllers" id="idm45326825592768"/><a contenteditable="false" data-type="indexterm" data-primary="admission controllers" data-secondary="network policies" id="idm45326825591104"/> network policy and label schemas. The approaches for splitting responsibilities between teams discussed earlier are oriented around resource- and namespace-level RBAC, with teams having freedom to whatever they want within the resource and namespace scopes they are allowed to manage. As such, they do not provide any guarantees that any such schemas are being followed by all teams.</p>
<p>Kubernetes itself does not have a built-in ability to enforce restrictions at this granular level, but it does support an Admission Controller API, which allows third-party admission controllers to be plugged into the Kubernetes API machinery to perform semantic validation of objects during create, update, and delete operations. You can additionally use admission controllers, also known as mutating admission controllers, for modifying objects that are admitted.</p>
<p class="pagebreak-before">For example, in the context of implementing network policy, admission controllers can help with the following:</p>
<ul>
<li><p>Validate that network policies have both ingress and egress rules to comply with the best practices the organization is trying to follow.</p></li>
<li><p>Ensure every pod has a specific set of labels to comply with the labeling standards the organization has defined.</p></li>
<li><p>Restrict different groups of users to specific label values.</p></li>
</ul>
<p>But admission controllers have security use cases beyond network policy too. <a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="admission controllers" id="idm45326825584704"/>For example, Kubernetes services include support for specifying an arbitrary IP address to be associated with the service using the service’s ExternalIP field. Without some level of policing, this is a very powerful feature that could be used maliciously to intercept pod traffic to an IP address and redirect it to the Kubernetes service by anyone with RBAC permissions to create and manage Kubernetes services. Policing this with an admission controller might be essential depending on the level of trust within the teams involved.</p>
<p>There are a few options for admission controller implementations, depending on the skill sets and specific needs of the organization:</p>
<ul>
<li><p>Using a preexisting third-party admission controller that specializes in the specific controls the organization needs, if one exists</p></li>
<li><p>Writing a custom admission controller optimized for the organization’s needs</p></li>
<li><p>Using a general-purpose admission controller with a rich policy model that can map to a broad range of use cases</p></li>
</ul>
<p>For many scenarios, choosing a general-purpose admission controller gives a good balance of flexibility and coding complexity. For example, you might consider Kyverno, which has a policy engine specifically designed for Kubernetes, or an admission controller built around Open Policy Agent, where the policy model has flexible matching and language capabilities defined using Rego.</p>
<p>While admission controllers are very powerful, it is generally recommended to implement them only if you genuinely need them. For some organizations, using admission controllers in this way is overkill, given the levels of responsibility and trust across teams. For other organizations, they can be essential to meet internal compliance requirements, and the case for using them will be very clear.</p>
</div></section>
</div></section>
<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000013">
<h1 class="less_space">Conclusion</h1>
<p>Kuberentes security needs to be implemented by various teams and needs collaboration between teams. This chapter covered the following key concepts:</p>
<ul>
<li><p>You should use RBAC and network policy to define boundaries that will help you manage activities across teams.</p></li>
<li><p>You can extend the concept of RBAC to control network access by leveraging service accounts in network policy to help you manage trust.</p></li>
<li><p>Admission controllers help to control access and implement trust boundaries across various teams.</p></li>
<li><p>Collaboration between the development, platform, and the security teams is important to implement security.</p></li>
</ul>
</div></section>
</div></section></div></body></html>