- en: Chapter 16\. CustomResourceDefinitions (CRDs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes provides primitives that support the most common use cases required
    by operators of an application stack. For custom use cases, Kubernetes allows
    for implementing and installing extensions to the platform.
  prefs: []
  type: TYPE_NORMAL
- en: A CustomResourceDefinition (CRD) is a Kubernetes extension mechanism for introducing
    custom API primitives to fulfill requirements not covered by built-in primitives.
    This chapter will primarily focus on the implementation of and interaction with
    CRDs.
  prefs: []
  type: TYPE_NORMAL
- en: Working with CRDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CRDs can be understood as the schema that defines the blueprint for a custom
    object, and then the instantiation of those objects with the newly introduced
    type. For a CRD to be useful, it has to be backed by a *controller*. Controllers
    interact with the Kubernetes API and implement the reconciliation logic that interacts
    with CRD objects. The combination of CRDs and controllers is commonly referred
    to as the *operator pattern*. The exam does not require you to have an understanding
    of controllers; therefore, their implementation won’t be covered in this chapter.
    [Figure 16-1](#operator_pattern) shows the operator patterns with all its moving
    parts.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1601](Images/ckd2_1601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-1\. The Kubernetes operator pattern
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Kubernetes community has implemented many useful operators discoverable
    on [OperatorHub.io](https://operatorhub.io/). You can install many of those operators
    with a single `kubectl`. A prominent operator is the [External Secrets Operator](https://external-secrets.io/)
    that helps with integrating external Secret managers, like AWS Secrets Manager
    and HashiCorp Vault, with Kubernetes. For the exam, you will need to understand
    how to discover CRD schemas provided by external operators and how to interact
    with objects that follow the CRD schema. We’ll go a little further in this chapter
    and talk about creating your own CRD schemas.
  prefs: []
  type: TYPE_NORMAL
- en: Example CRD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation of and interaction with a CRD is best explained by example.
    We will implement and instantiate a CRD that represents a smoke test for a Service
    object to be executed after an application stack has been deployed to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Technical baseline
  prefs: []
  type: TYPE_NORMAL
- en: Assume you are in charge of managing a web-based application. The Kubernetes
    objects needed to manage the application consist of a Deployment for running an
    application in Pods and the Service object that routes the network traffic to
    the replicas.
  prefs: []
  type: TYPE_NORMAL
- en: Desired functionality
  prefs: []
  type: TYPE_NORMAL
- en: A smoke test should be triggered automatically after deploying the Kubernetes
    objects responsible for operating the application. At runtime, the smoke test
    executes HTTPS calls to an endpoint of the application by targeting the Service’s
    DNS name. The result of the smoke test (in the case of success or failure) will
    be sent to an external service so it can be rendered as charts and graphs in a
    dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: Goal
  prefs: []
  type: TYPE_NORMAL
- en: To implement this functionality, you could decide to write a CRD and controller.
    In this chapter, we are only going to cover the CRD for a smoke test, not the
    controller that would do the heavy lifting of executing the smoke test.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a CRD Schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make a CRD operational, you have to create two objects: the custom resource
    schema and the custom resource object. The custom resource schema specifies the
    CRD blueprint in the form of an OpenAPI v3 specification. The custom resource
    object follows the specification of the CRD schema and assigns values to properties
    available to the schema.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubebuilder to generate CRDs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CRD schema specification can become quite extensive. To avoid writing those
    specification by hand, take a look at the [Kubebuilder](https://github.com/kubernetes-sigs/kubebuilder)
    project. One Kubebuilder functionality is the ability to generate CRD schemas
    with minimal input provided by the user. Using the tool can help save time getting
    a Kubernetes operator project started.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s look at the custom resource schema of the smoke test. The schema
    uses the kind CustomResourceDefinition, as shown in [Example 16-1](#custom_resource_schema).
  prefs: []
  type: TYPE_NORMAL
- en: While I can’t explain the meaning of every attribute of a CustomResourceDefinition
    here, I want to point out some important aspects. The CustomResourceDefinition
    specifies the group, version, and names of the custom primitive. It also spells
    out all configurable attributes, including their data types. For a more detailed
    description of the CustomResourceDefinition see the [Kubernetes documentation](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-1\. A custom resource schema to represent a smoke test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_customresourcedefinitions__crds__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of the identifiers `<plural>`.`<group>`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_customresourcedefinitions__crds__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The API group to be used by CRD.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_customresourcedefinitions__crds__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The versions supported by the CRD. A version can define 0..n attributes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_customresourcedefinitions__crds__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The attributes to be set by the custom type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_customresourcedefinitions__crds__CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The identifiers for the custom type, e.g., the kind and the singular/plural/short
    names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file *smoketest-resource.yaml* contains the YAML content shown in the previous
    example. You can now create the object for the schema with the typical `kubectl`
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating an Object for the CRD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the schema object has been created, you can create objects for the new
    custom type. The YAML manifest in [Example 16-2](#custom_resource_object) defines
    a primitive of type SmokeTest named `backend-smoke-test` for the Service named
    `backend`. As you can see in the manifest, additional attributes can be specified
    to fine-tune its runtime behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-2\. Instantiation of CRD kind SmokeTest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_customresourcedefinitions__crds__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The group and Version of the custom kind.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_customresourcedefinitions__crds__CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The kind defined by CRD.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_customresourcedefinitions__crds__CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The attributes and their values that make the custom kind configurable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create the SmokeTest object from the file *smoketest.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can interact with the `backend-smoke-test` like any other object in Kubernetes.
    For example, to list the object use the `get` command. To delete the object, use
    the `delete` command. The following commands show those operations in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can create more objects of this type as needed to execute smoke tests against
    other Services, although each of the objects needs a unique name. We now have
    the CRD schema object in place. In the next section, we’ll interact with it.
  prefs: []
  type: TYPE_NORMAL
- en: Discovering CRDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A CRD schema registers a new API resource. Every API resource can be discovered.
    You can list custom API resources in the same way as you would for built-in API
    resources. The following command lists API resources by the API group `stable.bmuschko.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'CRD objects can be interacted with like any other object using `kubectl`. You
    can create, read, update, and delete them. The following command lists all CRDs
    installed in the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The CRD you see in the output is the one representing a smoke test. If you see
    other CRDs in the output then they may have been provided by the external operator
    installed in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The smoke test object just represents data and won’t be useful by itself. You
    need to add a controller implementation that does something with those objects.
    In a nutshell, a controller acts as a reconciliation process by inspecting the
    state of CRD objects via calls to the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, a controller implementation needs to poll for new SmokeTest objects
    and perform the HTTPS requests to the configured Service endpoint. Finally, the
    controller inspects the response from the request, evaluates the result, and sends
    it to an external service to be recorded in a database. A dashboard can then tap
    into historical results and render them as needed, e.g., as charts and graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Controllers can use one of the Kubernetes [client libraries](https://kubernetes.io/docs/reference/using-api/client-libraries/),
    written in Go or Python, to access custom resources. Visit the relevant documentation
    for more information and examples on how to implement a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CRD schema defines the structure of a custom resource. The schema includes
    the group, name, version, and its configurable attributes. New objects of this
    kind can be created after registering the schema. You can interact with a custom
    object using `kubectl` with the same CRUD commands used by any other primitive.
  prefs: []
  type: TYPE_NORMAL
- en: CRDs realize their full potential when combined with a controller implementation.
    The controller implementation inspects the state of specific custom objects and
    reacts based on their discovered state. Kubernetes refers to the CRD and the corresponding
    controller as the operator pattern. The Kubernetes community has implemented many
    operators to fulfill custom requirements. You can install them into your cluster
    to reuse the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Acquire a high-level understanding of configurable options for a CRD schema
  prefs: []
  type: TYPE_NORMAL
- en: You are not expected to implement a CRD schema. All you need to know is how
    to discover and use them with `kubectl`. Controller implementations are definitely
    outside the scope of the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Practice the commands for installing and discovering CRDs
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to use the `kubectl get crds` command to discover installed CRDs,
    and how to create objects from a CRD schema. If you want to explore further, install
    an open source CRD, such as the [Prometheus operator](https://github.com/prometheus-operator/prometheus-operator)
    or the [Jaeger operator](https://github.com/jaegertracing/jaeger-operator), and
    inspect its schema.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_012.xhtml#appendix_a_crds).
  prefs: []
  type: TYPE_NORMAL
- en: You decide to manage a [MongoDB](https://www.mongodb.com/) installation in Kubernetes
    with the help of the [official community operator](https://github.com/mongodb/mongodb-kubernetes-operator).
    This operator provides a CRD. After installing the operator, you will interact
    with the CRD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the directory *app-a/ch16/mongodb-operator* of the checked-out
    GitHub repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
    Install the operator using the following command: `kubectl apply -f` `mongodbcommunity.mongodb.com_mongodbcommunity.yaml`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: List all CRDs using the appropriate `kubectl` command. Can you identify the
    CRD that was installed by the installation procedure?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inspect the schema of the CRD. What are the type and property names of this
    CRD?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As an application developer, you may want to install Kubernetes functionality
    that extends the platform using the Kubernetes operator pattern. The objective
    of this exercise is to familiarize yourself with creating and managing CRDs. You
    will not need to write a controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a CRD resource named `backup.example.com` with the following specifications:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Group: `example.com`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Version: `v1`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kind: `Backup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Singular: `backup`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Plural: `backups`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Properties of type `string`: `cronExpression`, `podName`, `path`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the details for the `Backup` custom resource created in the previous
    step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a custom object named `nginx-backup` for the CRD. Provide the following
    property values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`cronExpression`: `0 0 * * *`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`podName`: `nginx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path`: `/usr/local/nginx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the details for the `nginx-backup` object created in the previous step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
