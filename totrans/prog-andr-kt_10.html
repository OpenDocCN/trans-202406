<html><head></head><body><section data-pdf-bookmark="Chapter 10. Flows" data-type="chapter" epub:type="chapter"><div class="chapter" id="flows_id">&#13;
<h1><span class="label">Chapter 10. </span>Flows</h1>&#13;
&#13;
&#13;
<p><a data-primary="flows" data-type="indexterm" id="ix_ch10-asciidoc0"/>Up to now, we’ve covered coroutines, suspending functions, and how to deal with streams using <code>Channel</code>s.&#13;
We’ve seen from the previous chapter that working with <code>Channel</code>s implies starting coroutines to send and/or&#13;
receive from those <code>Channel</code>s. The aforementioned coroutines are then <em>hot</em> entities that are sometimes&#13;
hard to debug, or can leak resources if they aren’t cancelled when they should be.</p>&#13;
&#13;
<p><code>Flow</code>s, like <code>Channel</code>s, are meant to handle asynchronous streams of data, but at a higher level of abstraction and with&#13;
better library tooling. Conceptually, <code>Flow</code>s are similar to <code>Sequence</code>s, except that each step of a <code>Flow</code> can be&#13;
asynchronous. It is also easy to integrate flows in structured concurrency, to avoid leaking resources.</p>&#13;
&#13;
<p>However, <code>Flow</code>s<sup><a data-type="noteref" href="ch10.html#idm46669741189760" id="idm46669741189760-marker">1</a></sup> aren’t meant to&#13;
replace <code>Channel</code>s. <code>Channel</code>s are building blocks for flows. <code>Channel</code>s are still appropriate in some architectures&#13;
such as in CSP (see <a data-type="xref" href="ch09.html#channels_id">Chapter 9</a>). Nevertheless, you’ll see that flows suit most needs in asynchronous data&#13;
&#13;
<span class="keep-together">processing.</span></p>&#13;
&#13;
<p>In this chapter, we’ll introduce you to cold and hot flows. You’ll see how <em>cold</em> flows can be a better choice when&#13;
you want to make sure never to leak any resources. On the other hand, <em>hot</em> flows serve a different purpose such as&#13;
when you need a “publish-subscribe” relationship between entities in your app. For example, you can implement an&#13;
event bus using hot flows.</p>&#13;
&#13;
<p>The best way to understand flows is to see how they are used in real-life applications. So this chapter will also go&#13;
through a series of typical use cases.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="An Introduction to Flows" data-type="sect1"><div class="sect1" id="idm46669741183312">&#13;
<h1>An Introduction to Flows</h1>&#13;
&#13;
<p>Lets reimplement <a data-type="xref" href="ch09.html#flows_channel_produce_id">Example 9-6</a>, using a <code>Flow</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">numbers</code><code class="p">():</code> <code class="n">Flow</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">flow</code> <code class="p">{</code>&#13;
    <code class="n">emit</code><code class="p">(</code><code class="m">1</code><code class="p">)</code>&#13;
    <code class="n">emit</code><code class="p">(</code><code class="m">2</code><code class="p">)</code>&#13;
    <code class="c1">// emit other values</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Several aspects are important to notice:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Instead of returning a <code>Channel</code> instance, we’re returning a <code>Flow</code> instance.</p>&#13;
</li>&#13;
<li>&#13;
<p>Inside the flow, we use the <code>emit</code> suspending function instead of <code>send</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>numbers</code> function, which returns a <code>Flow</code> instance, isn’t a suspending function. Invoking the <code>numbers</code> function&#13;
doesn’t start anything by itself—it just immediately returns a <code>Flow</code> instance.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>To sum up, you define in the <code>flow</code> block the emission of values. When invoked, the <code>numbers</code> function quickly returns a&#13;
<code>Flow</code> instance without running anything in the background.</p>&#13;
&#13;
<p>On the consuming site:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">runBlocking</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">flow</code><code> </code><code class="p">=</code><code> </code><code class="n">numbers</code><code class="p">(</code><code class="p">)</code><code>      </code><a class="co" href="#callout_flows_CO1-1" id="co_flows_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="n">flow</code><code class="p">.</code><code class="n">collect</code><code> </code><code class="p">{</code><code>            </code><a class="co" href="#callout_flows_CO1-2" id="co_flows_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">println</code><code class="p">(</code><code class="n">it</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_flows_CO1-1" id="callout_flows_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We get an instance of <code>Flow</code>, using the <code>numbers</code> function.</p></dd>&#13;
<dt><a class="co" href="#co_flows_CO1-2" id="callout_flows_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Once we get a flow, instead of looping over it (like we would with a channel), we use the <code>collect</code> function which,&#13;
in flows parlance, is called a<a data-primary="terminal operator" data-type="indexterm" id="idm46669741086384"/> <em>terminal operator</em>. We’ll extend on <em>flows operators</em> and terminal operators in&#13;
<a data-type="xref" href="#flows_operators">“Operators”</a>.&#13;
For now, we can summarize the purpose of the <code>collect</code> terminal operator: it consumes the flow; foor example, iterate over the flow and execute the given lambda on each element of the flow.</p></dd>&#13;
</dl>&#13;
&#13;
<p>That’s it—you’ve seen the basic usage of a flow. As we mentioned earlier, we’ll now take a more realistic example, so&#13;
you’ll see the real interest of <code>Flow</code>s.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A More Realistic Example" data-type="sect2"><div class="sect2" id="idm46669741054208">&#13;
<h2>A More Realistic Example</h2>&#13;
&#13;
<p><a data-primary="flows" data-secondary="example" data-type="indexterm" id="ix_ch10-asciidoc2"/>Imagine that you need to get tokens from a remote database,<sup><a data-type="noteref" href="ch10.html#idm46669741051328" id="idm46669741051328-marker">2</a></sup>&#13;
then query additional data for each of those tokens. You need to do that only once in a while, so you decide not to&#13;
maintain an active connection to the database (which could be expensive). So you create a connection only when fetching&#13;
the data, and close it when you’re done.</p>&#13;
&#13;
<p>Your implementation should first establish the connection to the database. Then you get a token using a&#13;
suspending function <code>getToken</code>. This <code>getToken</code> function performs a request to the database and returns a token. Then&#13;
you asynchronously get optional data associated with this token. In our example, this is done by invoking the&#13;
suspending function <code>getData</code>, which takes a token as a parameter.&#13;
Once you get the result of <code>getData</code>, you wrap both the token and the result in one <code>TokenData</code> class instance, defined as:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">TokenData</code><code class="p">(</code><code class="k">val</code> <code class="py">token</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="k">val</code> <code class="py">opt</code><code class="p">:</code> <code class="n">String</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code><code class="p">)</code></pre>&#13;
&#13;
<p>To sum up, you need to produce a stream of <code>TokenData</code> objects. This stream requires first establishing a database connection, then performing asynchronous queries for retrieving tokens and getting associated data. You choose how many tokens you need. After you’ve  processed all the tokens, you disconnect and release underlying database connection resources. <a data-type="xref" href="#flow_realistic_id">Figure 10-1</a> shows how to  implement such a flow.</p>&#13;
&#13;
<figure class="width-80"><div class="figure" id="flow_realistic_id">&#13;
<img alt="Implementing the flow for retrieving token data" src="assets/pawk_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>Data flow.</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can find the corresponding <a href="https://oreil.ly/dU4uZ">source code in GitHub</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In this chapter, we sometimes use images instead of code blocks because the screenshots from our IDE show suspension&#13;
points (in the margin) and type hints, which are really helpful.</p>&#13;
</div>&#13;
&#13;
<p>Several aspects of this implementation are particularly important to notice:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Creating a connection to the database and closing it on completion is completely transparent to the client code that&#13;
consumes the flow. Client code only sees a flow of <code>TokenData</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>All operations inside the flow are sequential. For example, once we get the first token (say, “token1”), the flow&#13;
invokes <code>getData("token1")</code> and suspends until it gets the result (say, “data1”). Then the flow emits the first&#13;
<code>TokenData("token1," "data1")</code>. Only after that does the execution proceed with “token2,” etc.</p>&#13;
</li>&#13;
<li>&#13;
<p>Invoking<a data-primary="getDataFlow" data-type="indexterm" id="idm46669740994112"/> the <code>getDataFlow</code> function does nothing on its own. It simply returns a flow. The code inside the flow&#13;
executes only when a coroutine collects the flow, as shown in <a data-type="xref" href="#flow_realistic_collection">Example 10-1</a>.</p>&#13;
<div data-type="example" id="flow_realistic_collection">&#13;
<h5><span class="label">Example 10-1. </span>Collecting a flow</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">flow</code> <code class="p">=</code> <code class="n">getDataFlow</code><code class="p">(</code><code class="m">3</code><code class="p">)</code> <code class="c1">// Nothing runs at initialization</code>&#13;
&#13;
    <code class="c1">// A coroutine collects the flow</code>&#13;
    <code class="n">launch</code> <code class="p">{</code>&#13;
        <code class="n">flow</code><code class="p">.</code><code class="n">collect</code> <code class="p">{</code> <code class="n">data</code> <code class="p">-&gt;</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
</li>&#13;
<li>&#13;
<p>If the coroutine that collects the flow gets cancelled or reaches the end of the flow, the code inside the <code>onCompletion</code>&#13;
block executes. This guarantees that we properly release the connection to the database.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As we already mentioned,<a data-primary="collect" data-type="indexterm" id="idm46669740961456"/> <code>collect</code> is a terminal operator that consumes all elements of the flow. In this&#13;
example, <code>collect</code> invokes a function on each collected element of the flow (e.g., <code>println(data)</code> is&#13;
invoked three times). We’ll cover other terminal operators in <a data-type="xref" href="#flows_use_cases_id">“Examples of Cold Flow Usage”</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Until now, you’ve seen examples of flows that don’t run any code until a coroutine collects them. In flows parlance,&#13;
they are cold flows.<a data-startref="ix_ch10-asciidoc2" data-type="indexterm" id="idm46669740921008"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operators" data-type="sect2"><div class="sect2" id="flows_operators">&#13;
<h2>Operators</h2>&#13;
&#13;
<p><a data-primary="flows" data-secondary="operators" data-type="indexterm" id="idm46669740918592"/><a data-primary="operators" data-type="indexterm" id="idm46669740917392"/>If you need to perform transformations on a flow, much like you would do on collections, the coroutines library provides&#13;
functions such as <code>map</code>, <code>filter</code>, <code>debounce</code>, <code>buffer</code>, <code>onCompletion</code>, etc. Those functions are called <em>flow operators</em>&#13;
or <em>intermediate operators</em>, because they operate on a flow and return another flow. A regular operator shouldn’t be confused&#13;
with a terminal operator, as you’ll see later.</p>&#13;
&#13;
<p>In the following, we have an example usage of the <code>map</code> operator:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code><code class="p">&lt;</code><code class="n">Unit</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">numbers</code><code class="p">:</code> <code class="n">Flow</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="c1">// implementation hidden for brevity</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">newFlow</code><code class="p">:</code> <code class="n">Flow</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">numbers</code><code class="p">().</code><code class="n">map</code> <code class="p">{</code>&#13;
        <code class="n">transform</code><code class="p">(</code><code class="n">it</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">suspend</code> <code class="k">fun</code> <code class="nf">transform</code><code class="p">(</code><code class="n">i</code> <code class="p">:</code><code class="n">Int</code><code class="p">):</code> <code class="n">String</code> <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">delay</code><code class="p">(</code><code class="m">10</code><code class="p">)</code> <code class="c1">// simulate real work</code>&#13;
    <code class="s">"${i + 1}"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The interesting bit here is that <code>map</code> turns a <code>Flow&lt;Int&gt;</code> into a <code>Flow&lt;String&gt;</code>. The type of the resulting flow is&#13;
determined by the return type of the lambda passed to the operator.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <code>map</code> flow operator is conceptually really close to the <code>map</code> extension function on collections. There’s a noticeable&#13;
difference, though: the lambda passed to the <code>map</code> flow operator can be a suspending function.</p>&#13;
</div>&#13;
&#13;
<p>We’ll cover most of the common operators in a series of use cases in the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Terminal Operators" data-type="sect2"><div class="sect2" id="idm46669740810144">&#13;
<h2>Terminal Operators</h2>&#13;
&#13;
<p><a data-primary="flows" data-secondary="terminal operators" data-type="indexterm" id="idm46669740808944"/><a data-primary="operators" data-secondary="terminal" data-type="indexterm" id="idm46669740807968"/>A terminal operator can be easily distinguished from other regular operators since it’s a suspending function&#13;
that starts the collection of the flow. You’ve previously seen <code>collect</code>.</p>&#13;
&#13;
<p>Other terminal operators are available, like <code>toList</code>, <code>collectLatest</code>, <code>first</code>, etc. Here is a brief description of&#13;
those terminal operators:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>toList</code> collects the given flow and returns a <code>List</code> containing all collected &#13;
<span class="keep-together">elements.</span></p>&#13;
</li>&#13;
<li>&#13;
<p><code>collectLatest</code>  collects the given flow with a provided action. The difference from <code>collect</code> is that when the&#13;
original flow emits a new value, the action block for the previous value is cancelled.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>first</code> returns the first element emitted by the flow and then cancels the flow’s collection. It throws a&#13;
<code>NoSuchElementException</code> if the flow was empty. There’s also a variant, <code>firstOrNull</code>, which returns <code>null</code> if the flow&#13;
was empty.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Examples of Cold Flow Usage" data-type="sect1"><div class="sect1" id="flows_use_cases_id">&#13;
<h1>Examples of Cold Flow Usage</h1>&#13;
&#13;
<p><a data-primary="cold flows" data-type="indexterm" id="ix_ch10-asciidoc3"/><a data-primary="flows" data-secondary="cold flows" data-type="indexterm" id="ix_ch10-asciidoc4"/>As it turns out, picking one single example making use of all possible operators isn’t the best path to follow. Instead,&#13;
we’ll provide different use cases, which will illustrate the usage of several flow operators.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use Case #1: Interface with a Callback-Based API" data-type="sect2"><div class="sect2" id="idm46669740793136">&#13;
<h2>Use Case #1: Interface with a Callback-Based API</h2>&#13;
&#13;
<p><a data-primary="callback-based API" data-type="indexterm" id="ix_ch10-asciidoc5"/><a data-primary="cold flows" data-secondary="interfacing with a callback-based API" data-type="indexterm" id="ix_ch10-asciidoc6"/><a data-primary="flows" data-secondary="use case: interfacing with a callback-based API" data-type="indexterm" id="ix_ch10-asciidoc7"/><a data-primary="interface with a callback-based API" data-type="indexterm" id="ix_ch10-asciidoc8"/>Suppose that you’re developing a chat application. Your users can send messages to one another. A message has a&#13;
date, a reference to the author of the message, and content as plain text.</p>&#13;
&#13;
<p>Here is a <code>Message</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Message</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">user</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">date</code><code class="p">:</code> <code class="n">LocalDateTime</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">content</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>Unsurprisingly, we’ll represent the stream of messages as a flow of the <code>Message</code> instance. Every time a user posts&#13;
a message into the app, the flow will transmit that message. For now, assume that you can invoke a function&#13;
<code>getMessageFlow</code>, which returns an instance of <code>Flow&lt;Message&gt;</code>. With the Kotlin Flows library, you are able to create&#13;
your own custom flows. However, it makes the most sense to start by exploring how the flow API can be used&#13;
in common use cases:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">getMessageFlow</code><code class="p">():</code> <code class="n">Flow</code><code class="p">&lt;</code><code class="n">Message</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// we'll implement it later</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, suppose that you want to translate all messages from a given user in a different language, on the fly. Moreover,&#13;
you’d like to perform the translation on a background thread.</p>&#13;
&#13;
<p>To do that, you start by getting the flow of messages, by invoking <code>getMessageFlow()</code>. Then you apply operators to the&#13;
original flow, as shown in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">getMessagesFromUser</code><code class="p">(</code><code class="n">user</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">,</code><code> </code><code class="n">language</code><code class="p">:</code><code> </code><code class="n">String</code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">Flow</code><code class="p">&lt;</code><code class="n">Message</code><code class="p">&gt;</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="n">getMessageFlow</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="p">.</code><code class="n">filter</code><code> </code><code class="p">{</code><code> </code><code class="n">it</code><code class="p">.</code><code class="n">user</code><code> </code><code class="p">=</code><code class="p">=</code><code> </code><code class="n">user</code><code> </code><code class="p">}</code><code>           </code><a class="co" href="#callout_flows_CO2-1" id="co_flows_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="p">.</code><code class="n">map</code><code> </code><code class="p">{</code><code> </code><code class="n">it</code><code class="p">.</code><code class="n">translate</code><code class="p">(</code><code class="n">language</code><code class="p">)</code><code> </code><code class="p">}</code><code>       </code><a class="co" href="#callout_flows_CO2-2" id="co_flows_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="p">.</code><code class="n">flowOn</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code><code>          </code><a class="co" href="#callout_flows_CO2-3" id="co_flows_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_flows_CO2-1" id="callout_flows_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The first operator, <code>filter</code>, operates on the original flow and returns another flow of messages which all originate&#13;
from the same <code>user</code> passed as a parameter.</p></dd>&#13;
<dt><a class="co" href="#co_flows_CO2-2" id="callout_flows_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The second operator, <code>map</code>, operates on the flow returned by <code>filter</code> and returns a flow of translated messages.&#13;
From the <code>filter</code> operator standpoint, the original flow (returned by <code>getMessageFlow()</code>) is the <a data-primary="upstream flow" data-type="indexterm" id="idm46669740637936"/><em>upstream&#13;
flow</em>, while the<a data-primary="downstream flow" data-type="indexterm" id="idm46669740636816"/> <em>downstream flow</em> is represented by all operators happening <em>after</em> <code>filter</code>. The same&#13;
reasoning applies for all intermediate operators—they have their own relative upstream and downstream flow, as&#13;
illustrated in <a data-type="xref" href="#upstream_downstream_id">Figure 10-2</a>.</p></dd>&#13;
<dt><a class="co" href="#co_flows_CO2-3" id="callout_flows_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Finally, the<a data-primary="flowOn" data-type="indexterm" id="idm46669740595840"/> <code>flowOn</code> operator changes the context of the flow it is operating on. &#13;
<span class="keep-together">It changes</span> the coroutine context of the upstream flow, while not affecting the downstream flow. Consequently, steps 1 and 2 are done using the dispatcher&#13;
&#13;
<span class="keep-together"><code>Dispatchers.Default</code></span>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>In other words, the upstream flow’s operators (which are <code>filter</code> and <code>map</code>) are now encapsulated: their&#13;
execution context will always be <code>Dispatchers.Default</code>. It doesn’t matter in which context the resulting flow&#13;
will be collected; the previously mentioned operators will be executed using <code>Dispatchers.Default</code>.</p>&#13;
&#13;
<p>This is a very important property of flows, called<a data-primary="context preservation" data-type="indexterm" id="idm46669740590064"/> <em>context preservation</em>. Imagine that you’re collecting the flow on the UI thread of your &#13;
<span class="keep-together">application—typically,</span> you would do that using the <code>viewModelScope</code> of a <code>ViewModel</code>. It would be embarrassing if the context of execution of one of the flow’s operators leaked downstream and affected the thread in which the flow was ultimately collected. Thankfully, this will never happen. For example, if you collect a flow on the UI thread, all values are emitted by a coroutine that uses <code>Dispatchers.Main</code>. All the necessary context switches are automatically managed for you.</p>&#13;
&#13;
<figure><div class="figure" id="upstream_downstream_id">&#13;
<img alt="pawk 1002" src="assets/pawk_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>Upstream and downstream flows.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Under the hood, <code>flowOn</code> starts a new coroutine when it detects that the context is about to change. This new&#13;
coroutine interacts with the rest of the flow through a channel that is internally managed.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In flow parlance, an intermediate operator like <code>map</code> operates on the upstream flow and returns another flow. From the&#13;
<code>map</code> operator standpoint, the returned flow is the downstream flow.</p>&#13;
&#13;
<p>The <code>map</code> operator accepts a suspending function as a transformation block. So if you wanted to only perform&#13;
message translation using <code>Dispatchers.Default</code> (and not message filtering), you could remove the <code>flowOn</code> operator&#13;
and declare the <code>translate</code> function like so:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="n">suspend</code> <code class="k">fun</code> <code class="nf">Message</code><code class="p">.</code><code class="n">translate</code><code class="p">(</code>&#13;
    <code class="n">language</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">):</code> <code class="n">Message</code>  <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">Default</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// this is a dummy implementation</code>&#13;
    <code class="n">copy</code><code class="p">(</code><code class="n">content</code> <code class="p">=</code> <code class="s">"translated content"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>See how easy it is to offload parts of data transformation to other threads, while still having a big picture&#13;
of the data flow?</p>&#13;
</div>&#13;
&#13;
<p>As you can see, the Flow API allows for a declarative way to express data transformation. When you invoke&#13;
<code>getMessagesFromUser("Amanda," "en-us")</code>, nothing is actually running. All those transformations involve&#13;
intermediate operators, which will be triggered when the flow will be collected.</p>&#13;
&#13;
<p>On the consuming site, if you need to act on each received message, you can use the <code>collect</code> function like so:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="n">getMessagesFromUser</code><code class="p">(</code><code class="s">"Amanda"</code><code class="p">,</code> <code class="s">"en-us"</code><code class="p">).</code><code class="n">collect</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Received message from ${it.user}: ${it.content}"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now that we’ve shown how to transform the flow and consume it, we can provide an implementation for the flow itself: the <code>getMessageFlow</code> function. The signature of this function is to return a flow of <code>Message</code>s. In that particular&#13;
situation, we can reasonably assume that the message machinery is actually a service that runs in its own thread.&#13;
We’ll name this service <code>MessageFactory</code>.</p>&#13;
&#13;
<p>Like most services of that kind, the message factory has a <em>publish/subscribe</em> mechanism—we can register or unregister&#13;
observers for new incoming messages, as shown in the following:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">abstract</code> <code class="k">class</code> <code class="nc">MessageFactory</code> <code class="p">:</code> <code class="n">Thread</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="cm">/* The internal list of observers must be thread-safe */</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">observers</code> <code class="p">=</code> <code class="n">Collections</code><code class="p">.</code><code class="n">synchronizedList</code><code class="p">(</code>&#13;
        <code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">MessageObserver</code><code class="p">&gt;())</code>&#13;
    <code class="k">private</code> <code class="k">var</code> <code class="py">isActive</code> <code class="p">=</code> <code class="k">true</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">run</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
        <code class="k">while</code><code class="p">(</code><code class="n">isActive</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">message</code> <code class="p">=</code> <code class="n">fetchMessage</code><code class="p">()</code>&#13;
            <code class="k">for</code> <code class="p">(</code><code class="n">observer</code> <code class="k">in</code> <code class="n">observers</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="n">observer</code><code class="p">.</code><code class="n">onMessage</code><code class="p">(</code><code class="n">message</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
            <code class="n">delay</code><code class="p">(</code><code class="m">1000</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">abstract</code> <code class="k">fun</code> <code class="nf">fetchMessage</code><code class="p">():</code> <code class="n">Message</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">registerObserver</code><code class="p">(</code><code class="n">observer</code><code class="p">:</code> <code class="n">MessageObserver</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">observers</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">observer</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">unregisterObserver</code><code class="p">(</code><code class="n">observer</code><code class="p">:</code> <code class="n">MessageObserver</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">observers</code><code class="p">.</code><code class="n">removeAll</code> <code class="p">{</code> <code class="n">it</code> <code class="p">==</code> <code class="n">observer</code> <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">fun</code> <code class="nf">cancel</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="n">isActive</code> <code class="p">=</code> <code class="k">false</code>&#13;
        <code class="n">observers</code><code class="p">.</code><code class="n">forEach</code> <code class="p">{</code>&#13;
            <code class="n">it</code><code class="p">.</code><code class="n">onCancelled</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
        <code class="n">observers</code><code class="p">.</code><code class="n">clear</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">interface</code> <code class="n">MessageObserver</code> <code class="p">{</code>&#13;
        <code class="k">fun</code> <code class="nf">onMessage</code><code class="p">(</code><code class="n">msg</code><code class="p">:</code> <code class="n">Message</code><code class="p">)</code>&#13;
        <code class="k">fun</code> <code class="nf">onCancelled</code><code class="p">()</code>&#13;
        <code class="k">fun</code> <code class="nf">onError</code><code class="p">(</code><code class="n">cause</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This implementation polls for new messages every second and notifies observers. Now the question is: how do we&#13;
turn a hot<sup><a data-type="noteref" href="ch10.html#idm46669740498544" id="idm46669740498544-marker">3</a></sup> entity such as this <code>MessageFactory</code> into a flow? <code>MessageFactory</code> is also said to be <em>callback-based</em>,&#13;
because it holds references to <code>MessageObserver</code> instances and calls methods on those instances when new messages&#13;
are retrieved. To bridge the flow world with the “callback” world, you can use the <code>callbackFlow</code> flow builder.&#13;
<a data-type="xref" href="#get_message_flow">Example 10-2</a> shows how you can use it.</p>&#13;
<div class="less_space" data-type="example" id="get_message_flow">&#13;
<h5><span class="label">Example 10-2. </span>Making a flow from a callback-based API</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">getMessageFlow</code><code class="p">(</code><code class="n">factory</code><code class="p">:</code> <code class="n">MessageFactory</code><code class="p">)</code> <code class="p">=</code> <code class="n">callbackFlow</code><code class="p">&lt;</code><code class="n">Message</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">observer</code> <code class="p">=</code> <code class="k">object</code> <code class="err">: </code><code class="nc">MessageFactory</code><code class="p">.</code><code class="n">MessageObserver</code> <code class="p">{</code>&#13;
        <code class="k">override</code> <code class="k">fun</code> <code class="nf">onMessage</code><code class="p">(</code><code class="n">msg</code><code class="p">:</code> <code class="n">Message</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">trySend</code><code class="p">(</code><code class="n">msg</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCancelled</code><code class="p">()</code> <code class="p">{</code>&#13;
            <code class="n">channel</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
&#13;
        <code class="k">override</code> <code class="k">fun</code> <code class="nf">onError</code><code class="p">(</code><code class="n">cause</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">cancel</code><code class="p">(</code><code class="n">CancellationException</code><code class="p">(</code><code class="s">"Message factory error"</code><code class="p">,</code> <code class="n">cause</code><code class="p">))</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="n">factory</code><code class="p">.</code><code class="n">registerObserver</code><code class="p">(</code><code class="n">observer</code><code class="p">)</code>&#13;
    <code class="n">awaitClose</code> <code class="p">{</code>&#13;
        <code class="n">factory</code><code class="p">.</code><code class="n">unregisterObserver</code><code class="p">(</code><code class="n">observer</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>The<a data-primary="callbackFlow builder" data-type="indexterm" id="idm46669740256704"/> <code>callbackFlow</code> builder creates a cold flow which doesn’t perform anything until you invoke a terminal&#13;
operator. Let’s break it down. First off, it’s a parameterized function which returns a <code>Flow</code> of the given type.&#13;
It’s always done in three steps:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">callbackFlow</code> <code class="p">{</code>&#13;
    <code class="cm">/*</code>&#13;
<code class="cm">    1. Instantiate the "callback." In this case, it's an observer.</code>&#13;
<code class="cm">    2. Register that callback using the available api.</code>&#13;
<code class="cm">    3. Listen for close event using `awaitClose`, and provide a</code>&#13;
<code class="cm">       relevant action to take in this case. Most probably,</code>&#13;
<code class="cm">       you'll have to unregister the callback.</code>&#13;
<code class="cm">    */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>It’s worth having a look at the signature of <code>callbackFlow</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">public</code> <code class="n">inline</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">&gt;</code> <code class="n">callbackFlow</code><code class="p">(</code>&#13;
    <code class="n">@BuilderInference</code> <code class="n">noinline</code> <code class="n">block</code><code class="p">:</code> <code class="n">suspend</code> <code class="n">ProducerScope</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.()</code> <code class="p">-&gt;</code> <code class="n">Unit</code>&#13;
<code class="p">):</code> <code class="n">Flow</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Don’t be impressed by this. One key piece of information is that <code>callbackFlow</code> takes a suspending function&#13;
with <code>ProducerScope</code> receiver as the argument. This means that inside the curly braces of the block following <code>callbackFlow</code>,&#13;
you have a <code>ProducerScope</code> instance as an implicit <code>this</code>.</p>&#13;
&#13;
<p>Here is the signature of <code>ProducerScope</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">public</code> <code class="n">interface</code> <code class="n">ProducerScope</code><code class="p">&lt;</code><code class="k">in</code> <code class="n">E</code><code class="p">&gt;</code> <code class="p">:</code> <code class="n">CoroutineScope</code><code class="p">,</code> <code class="n">SendChannel</code><code class="p">&lt;</code><code class="n">E</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>So a <code>ProducerScope</code> is a <code>SendChannel</code>. And that’s what you should remember: <code>callbackFlow</code> provides you with an&#13;
instance of <code>SendChannel</code>, which you can use inside your implementation. You send the object instances you get from your callback to this channel. This is what we do in step 1 of <a data-type="xref" href="#get_message_flow">Example 10-2</a>.<a data-startref="ix_ch10-asciidoc8" data-type="indexterm" id="idm46669740027344"/><a data-startref="ix_ch10-asciidoc7" data-type="indexterm" id="idm46669740026640"/><a data-startref="ix_ch10-asciidoc6" data-type="indexterm" id="idm46669740025968"/><a data-startref="ix_ch10-asciidoc5" data-type="indexterm" id="idm46669740025296"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use Case #2: Concurrently Transform a Stream of Values" data-type="sect2"><div class="sect2" id="use_case_2_id">&#13;
<h2>Use Case #2: Concurrently Transform a Stream of Values</h2>&#13;
&#13;
<p><a data-primary="cold flows" data-secondary="concurrently transforming a stream of values" data-type="indexterm" id="ix_ch10-asciidoc9"/><a data-primary="flows" data-secondary="use case: concurrently transforming a stream of values" data-type="indexterm" id="ix_ch10-asciidoc10"/>Sometimes you have to apply a transformation on a collection or stream of objects, to get a new collection&#13;
of transformed objects. When those transformations should be done asynchronously, things start getting a&#13;
bit complicated. Not with flows!</p>&#13;
&#13;
<p>Imagine that you have a list of <code>Location</code> instances. Each location can be resolved to a <code>Content</code> instance,&#13;
using the <code>transform</code> function:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">transform</code><code class="p">(</code><code class="n">loc</code><code class="p">:</code> <code class="n">Location</code><code class="p">):</code> <code class="n">Content</code> <code class="p">=</code> <code class="n">withContext</code><code class="p">(</code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Actual implementation doesn't matter</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So you are receiving <code>Location</code> instances, and you have to transform them on the fly using the <code>transform</code>&#13;
function. However, processing one <code>Location</code> instance might take quite some time. So you don’t want that&#13;
processing of a location to delay the transformation of the next incoming locations. In other words,&#13;
transformations should be done <em>in parallel</em>, as shown in <a data-type="xref" href="#figure10_3">Figure 10-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure10_3">&#13;
<img alt="Merge flows" src="assets/pawk_1003.png"/>&#13;
<h6><span class="label">Figure 10-3. </span>Merge flows.</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the preceding schema, we’ve limited the concurrency to four; in other words, at most, four locations can be transformed&#13;
simultaneously at a given point in time.</p>&#13;
&#13;
<p><a data-type="xref" href="#figure10_4">Figure 10-4</a> shows how you would implement this behavior using flows.</p>&#13;
&#13;
<figure class="width-90"><div class="figure" id="figure10_4">&#13;
<img alt="pawk 1004" src="assets/pawk_1004.png"/>&#13;
<h6><span class="label">Figure 10-4. </span>Implementing merging flows.</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can find the corresponding <a href="https://oreil.ly/LhW77">source code in GitHub</a>.</p>&#13;
&#13;
<p>To understand what’s going on here, you should realize that <code>locations.map{..}</code> returns a flow of a flow (e.g., the type is&#13;
<code>Flow&lt;Flow&lt;Content&gt;&gt;</code>). Indeed, inside the <code>map{..}</code> operator, a new flow is created upon emission of a location by the&#13;
upstream flow (which is <code>locationsFlow</code>).&#13;
Each of those created flows is of type <code>Flow&lt;Content&gt;</code> and individually performs location transformation.</p>&#13;
&#13;
<p>The last statement, <code>flattenMerge</code>, merges all those created flows inside a new resulting <code>Flow&lt;Content&gt;</code> (which we&#13;
assign to <code>contentFlow</code>). Also, <code>flattenMerge</code> has a &#13;
<span class="keep-together">“concurrency”</span> parameter. Indeed, it would probably be&#13;
inappropriate to concurrently create and collect a flow every time we receive a location. With a concurrency level of 4,&#13;
we ensure that no more than four flows will be collected at a given point in time. This is handy in the case of CPU-bound tasks,&#13;
when you know that your CPU won’t be able to transform more than four locations <em>in parallel</em> (assuming the CPU has four cores).&#13;
In other words, <code>flattenMerge</code>’s concurrency level refers to how many operations/transformations will be done in&#13;
parallel <em>at most</em> at a given point in time.</p>&#13;
&#13;
<p>Thanks to the suspending nature of flows, you get <em>back pressure</em> for free. New locations are collected from&#13;
<code>locationsFlow</code> only when the machinery is available to process them. A similar mechanism could be implemented without&#13;
flows or coroutines, using a thread pool and a blocking queue. However, that would require considerably more lines of code.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of this writing, the <code>flattenMerge</code> operator is marked as<a data-primary="@FlowPreview" data-primary-sortas="FlowPreview" data-type="indexterm" id="idm46669739929360"/> <code>@FlowPreview</code> in the source code, which means&#13;
that this declaration is in a preview state and can be changed in a backward-incompatible manner with a&#13;
best-effort migration.</p>&#13;
&#13;
<p>We hope that by the time we finish writing this book, the flow-merging API will be stabilized. Otherwise, a similar&#13;
operator might replace <code>flattenMerge</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Happens in Case of Error?" data-type="sect2"><div class="sect2" id="idm46669740024496">&#13;
<h2>What Happens in Case of Error?</h2>&#13;
&#13;
<p>If one of the<a data-primary="transformation functions" data-type="indexterm" id="idm46669739925440"/> <code>transform</code> functions raises an exception, the entire flow will be cancelled, and the exception will be&#13;
propagated downstream. While this good default behavior, you might want to handle some exceptions right inside the&#13;
flow itself.</p>&#13;
&#13;
<p>We’ll show how to do that in <a data-type="xref" href="#error_handling_id">“Error Handling”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Final Thoughts" data-type="sect2"><div class="sect2" id="idm46669739922480">&#13;
<h2>Final Thoughts</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Do you realize that we’ve just created a worker pool that concurrently transforms an incoming stream of&#13;
objects, using only five lines of code?</p>&#13;
</li>&#13;
<li>&#13;
<p>You’re guaranteed that the flow machinery is thread-safe. No more headaches figuring out the proper&#13;
synchronization strategy to pass object references from a thread pool to a collecting thread.</p>&#13;
</li>&#13;
<li>&#13;
<p>You can easily tweak the concurrency level, which, in this case, means the maximum number of parallel transformations.<a data-startref="ix_ch10-asciidoc10" data-type="indexterm" id="idm46669739917856"/><a data-startref="ix_ch10-asciidoc9" data-type="indexterm" id="idm46669739917152"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use Case #3: Create a Custom Operator" data-type="sect2"><div class="sect2" id="idm46669739915968">&#13;
<h2>Use Case #3: Create a Custom Operator</h2>&#13;
&#13;
<p><a data-primary="cold flows" data-secondary="creating a custom operator" data-type="indexterm" id="ix_ch10-asciidoc11"/><a data-primary="flows" data-secondary="use case: creating a custom operator" data-type="indexterm" id="ix_ch10-asciidoc12"/><a data-primary="operators" data-secondary="create custom" data-type="indexterm" id="ix_ch10-asciidoc13"/>Even if a lot of flow operators are available out of the box, sometimes you’ll have to make your own. Thankfully,&#13;
flows are composable, and it’s not that difficult to implement custom reactive logic.</p>&#13;
&#13;
<p>For example, by the time we write those lines, there’s no Flows operator equivalent of the <a href="https://oreil.ly/udGs0">Project Reactor’s bufferTimeout</a>.</p>&#13;
&#13;
<p>So, what is <code>bufferTimeout</code> supposed to do? Imagine that you have an upstream flow of elements, but you want&#13;
to process those elements by batches and at a fixed maximum rate. The flow returned by <code>bufferTimeout</code> should buffer&#13;
elements and emit a list (batch) of elements when either:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The buffer is full.</p>&#13;
</li>&#13;
<li>&#13;
<p>A predefined maximum amount of time has elapsed (timeout).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Before going through the implementation, let’s talk about the key idea. The flow returned by <code>bufferTimeout</code>&#13;
should internally consume the upstream flow and buffer elements. When the buffer is full, or a timeout has&#13;
elapsed, the flow should emit the content of the buffer (a list). You can imagine that internally we’ll start&#13;
a coroutine that receives two types of events:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>“An element has just been received from the upstream flow. Should we just add it to the buffer or also send&#13;
the whole buffer?”</p>&#13;
</li>&#13;
<li>&#13;
<p>“Timeout! Send the content of the buffer right now.”</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In <a data-type="xref" href="ch09.html#channels_id">Chapter 9</a> (CSP section), we’ve discussed a similar situation. The <code>select</code> expression is&#13;
perfect for dealing with multiple events coming from several channels.</p>&#13;
&#13;
<p class="pagebreak-before">Now we’re going to implement our <code>bufferTimeout</code> flow operator:</p>&#13;
&#13;
<figure><div class="figure">&#13;
<img alt="pawk 10in01" src="assets/pawk_10in01.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
&#13;
<p>You can find the corresponding <a href="https://oreil.ly/JxkZj">source code in GitHub</a>.</p>&#13;
&#13;
<p class="pagebreak-before">Here is the explanation:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>First of all, the signature of the operator tells us a lot. It’s declared as an extension function of <code>Flow&lt;T&gt;</code>,&#13;
so you can use it like this: <code>upstreamFlow.bufferTimeout(10, 100)</code>. As for the return type, it’s <code>Flow&lt;List&lt;T&gt;&gt;</code>.&#13;
Remember that you want to process elements by batches, so the flow returned by <code>bufferTimeout</code> should return&#13;
elements as <code>List&lt;T&gt;</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Line 17: we’re using a <code>flow{}</code> builder. As a reminder, the builder provides you an instance of <code>FlowCollector</code>,&#13;
and the block of code is an extension function with <code>FlowCollector</code> as the receiver type. In other words, you can&#13;
invoke <code>emit</code> from inside the block of code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Line 21: we’re using<a data-primary="coroutineScope" data-type="indexterm" id="idm46669739887856"/> <code>coroutineScope{}</code> because we’ll start new coroutines, which is only possible within a&#13;
<code>CoroutineScope</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Line 22: from our coroutine standpoint,<sup><a data-type="noteref" href="ch10.html#idm46669739885136" id="idm46669739885136-marker">4</a></sup> received&#13;
elements should come from a <code>ReceiveChannel</code>. So another inner coroutine should be started to consume the&#13;
upstream flow and send them over a channel. This is exactly the purpose of the <code>produceIn</code> flow operator.</p>&#13;
</li>&#13;
<li>&#13;
<p>Line 23: we need to generate “timeout” events. A library function already exists exactly for that purpose:&#13;
<code>ticker</code>. It creates a channel that produces the first item after the given initial delay, and subsequent&#13;
items with the given delay between them. As specified in the documentation, <code>ticker</code> starts a new coroutine&#13;
<em>eagerly</em>, and we’re fully responsible for cancelling it.</p>&#13;
</li>&#13;
<li>&#13;
<p>Line 34: we’re using<a data-primary="whileSelect" data-type="indexterm" id="idm46669739879184"/> <code>whileSelect</code>, which really is just syntax sugar for looping in a <code>select</code> expression&#13;
while clauses return <code>true</code>. Inside the <code>whileSelect{}</code> block you can see the logic of adding an element&#13;
to the buffer only if it’s not full, and emitting the whole buffer otherwise.</p>&#13;
</li>&#13;
<li>&#13;
<p>Line  46:  when  the  upstream  flow  collection  completes,  the  coroutine  started  with <code>produceIn</code> will still attempt to read from that flow, and a &#13;
<span class="keep-together"><code>ClosedReceiveChannelException</code></span>  will  be  raised.  So  we  catch  that  exception, and&#13;
we know that we should emit the content of the buffer.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lines 48 and 49: channels are hot entities—they should be cancelled when they’re not supposed to be used anymore. As for&#13;
the <code>ticker</code>, it should be cancelled too.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Usage" data-type="sect2"><div class="sect2" id="idm46669739915376">&#13;
<h2>Usage</h2>&#13;
&#13;
<p><a data-type="xref" href="#buffer_timeout_usage_id">Figure 10-5</a> shows an example of how <code>bufferTimeout</code> can be used.</p>&#13;
&#13;
<figure class="width-90"><div class="figure" id="buffer_timeout_usage_id">&#13;
<img alt="`bufferTimeout` usage" src="assets/pawk_1005.png"/>&#13;
<h6><span class="label">Figure 10-5. </span><code>bufferTimeout</code> usage.</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can find the corresponding <a href="https://oreil.ly/Y2xVe">source code in GitHub</a>.</p>&#13;
&#13;
<p>The output is:</p>&#13;
&#13;
<pre data-type="programlisting">139 ms: [1, 2, 3, 4]&#13;
172 ms: [5, 6, 7, 8]&#13;
223 ms: [9, 10, 11, 12, 13]&#13;
272 ms: [14, 15, 16, 17]&#13;
322 ms: [18, 19, 20, 21, 22]&#13;
...&#13;
1022 ms: [86, 87, 88, 89, 90]&#13;
1072 ms: [91, 92, 93, 94, 95]&#13;
1117 ms: [96, 97, 98, 99, 100]</pre>&#13;
&#13;
<p>As you can see, the upstream flow is emitting numbers from 1 to 100, with a delay of 10 ms between each emission.&#13;
We set a timeout of 50 ms, and each emitted list can contain at most five numbers<a data-startref="ix_ch10-asciidoc13" data-type="indexterm" id="idm46669739863920"/><a data-startref="ix_ch10-asciidoc12" data-type="indexterm" id="idm46669739863216"/><a data-startref="ix_ch10-asciidoc11" data-type="indexterm" id="idm46669739862544"/>.<a data-startref="ix_ch10-asciidoc4" data-type="indexterm" id="idm46669739861744"/><a data-startref="ix_ch10-asciidoc3" data-type="indexterm" id="idm46669739861040"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Error Handling" data-type="sect1"><div class="sect1" id="error_handling_id">&#13;
<h1>Error Handling</h1>&#13;
&#13;
<p><a data-primary="error handling" data-type="indexterm" id="ix_ch10-asciidoc14"/><a data-primary="flows" data-secondary="error handling" data-type="indexterm" id="ix_ch10-asciidoc15"/>Error handling is fundamental in reactive programming. If you’re familiar with RxJava, you probably handle&#13;
exceptions using the <code>onError</code> callback of the<a data-primary="subscribe method" data-type="indexterm" id="idm46669739855648"/> <code>subscribe</code> method:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="c1">// RxJava sample</code>&#13;
<code class="n">someObservable</code><code class="p">().</code><code class="n">subscribe</code><code class="p">(</code>&#13;
    <code class="p">{</code> <code class="n">value</code> <code class="p">-&gt;</code> <code class="cm">/* Do something useful */</code> <code class="p">},</code>&#13;
    <code class="p">{</code> <code class="n">error</code> <code class="p">-&gt;</code> <code class="n">println</code><code class="p">(</code><code class="s">"Error: $error"</code><code class="p">)</code> <code class="p">}</code>&#13;
<code class="p">)</code></pre>&#13;
&#13;
<p>Using flows, you can handle errors using a combination of techniques, involving:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The classic <code>try</code>/<code>catch</code> block.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>catch</code> operator—we’ll cover this new operator right after we discuss the <code>try</code>/<code>catch</code> block.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The try/catch Block" data-type="sect2"><div class="sect2" id="idm46669739833568">&#13;
<h2>The try/catch Block</h2>&#13;
&#13;
<p><a data-primary="error handling" data-secondary="try/catch block" data-type="indexterm" id="ix_ch10-asciidoc16"/><a data-primary="flows" data-secondary="try/catch block" data-type="indexterm" id="ix_ch10-asciidoc17"/><a data-primary="try/catch block" data-type="indexterm" id="ix_ch10-asciidoc18"/>If we define a dummy upstream flow made of only three <code>Int</code>s, and purposely throw an exception inside the <code>collect{}</code>&#13;
block, we can catch the exception by wrapping the whole chain in a <code>try</code>/<code>catch</code> block:</p>&#13;
&#13;
<figure class="width-70"><div class="figure">&#13;
<img alt="pawk 10in02" src="assets/pawk_10in02.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
&#13;
<p>You can find the corresponding <a href="https://oreil.ly/qcOKV">source code in GitHub</a>.</p>&#13;
&#13;
<p>The output is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Received 1&#13;
Received 2&#13;
Caught java.lang.RuntimeException</pre>&#13;
&#13;
<p>It is important to note that <code>try</code>/<code>catch</code> also works when the exception is raised from inside the upstream flow.&#13;
For example, we get the exact same result if we change the definition of the upstream flow to:</p>&#13;
&#13;
<figure class="width-70"><div class="figure">&#13;
<img alt="pawk 10in03" src="assets/pawk_10in03.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
&#13;
<p>You can find the corresponding <a href="https://oreil.ly/lrrGt">source code in GitHub</a>.</p>&#13;
&#13;
<p>However, if you try to intercept an exception in the flow itself, you’re likely to get unexpected results.&#13;
Here is an example:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="c1">// Warning: DON'T DO THIS, this flow swallows downstream exceptions</code>&#13;
<code class="k">val</code> <code class="py">upstream</code><code class="p">:</code> <code class="n">Flow</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">flow</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="k">in</code> <code class="m">1.</code><code class="p">.</code><code class="m">3</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">try</code> <code class="p">{</code>&#13;
            <code class="n">emit</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>&#13;
        <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Intercept downstream exception $e"</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">try</code> <code class="p">{</code>&#13;
        <code class="n">upstream</code><code class="p">.</code><code class="n">collect</code> <code class="p">{</code> <code class="n">value</code> <code class="p">-&gt;</code>&#13;
            <code class="n">println</code><code class="p">(</code><code class="s">"Received $value"</code><code class="p">)</code>&#13;
            <code class="n">check</code><code class="p">(</code><code class="n">value</code> <code class="p">&lt;=</code> <code class="m">2</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="s">"Collected $value while we expect values below 2"</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Caught $e"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">In this example, we’re using the <code>flow</code> builder to define <code>upstream</code>, and we wrapped the <code>emit</code> invocation&#13;
inside a <code>try</code>/<code>catch</code> statement. Even if it seems useless because <code>emit</code> isn’t throwing exceptions, it could&#13;
make sense with nontrivial emission logic nevertheless. At the consuming site, in the <code>main</code> function, we collect&#13;
that flow and we check that we don’t get values strictly greater than 2. Otherwise, the <code>catch</code> block should&#13;
print <code>Caught java.lang.IllegalStateException Collected x while we expect values below 2</code>.</p>&#13;
&#13;
<p>We expect the following output:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Received 1&#13;
Received 2&#13;
Caught java.lang.IllegalStateException: Collected 3 while we expect values below 2</pre>&#13;
&#13;
<p>However, this is what we actually get:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Received 1&#13;
Received 2&#13;
Received 3&#13;
Intercept downstream exception java.lang.IllegalStateException: Collected 3 while we expect values below 2</pre>&#13;
&#13;
<p>Despite the exception raised by <code>check(value &lt;= 2) {..}</code>, that exception gets caught not&#13;
by the <code>try</code>/<code>catch</code> statement of the <code>main</code> function, but by the <code>try</code>/<code>catch</code> statement of the flow.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>A <code>try</code>/<code>catch</code> statement inside a flow builder might catch <em>downstream</em> exceptions—which&#13;
includes exceptions raised during the collection of the flow.<a data-startref="ix_ch10-asciidoc18" data-type="indexterm" id="idm46669739643728"/><a data-startref="ix_ch10-asciidoc17" data-type="indexterm" id="idm46669739643024"/><a data-startref="ix_ch10-asciidoc16" data-type="indexterm" id="idm46669739642352"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Separation of Concern Is Important" data-type="sect2"><div class="sect2" id="idm46669739832912">&#13;
<h2>Separation of Concern Is Important</h2>&#13;
&#13;
<p><a data-primary="error handling" data-secondary="separation of concern" data-type="indexterm" id="idm46669739640448"/><a data-primary="flows" data-secondary="separation of concern" data-type="indexterm" id="idm46669739639472"/>A flow implementation shouldn’t have a side effect on the code that collects that flow. Likewise, the code that&#13;
collects a flow shouldn’t be aware of the implementation details of the upstream flow. A flow should always be&#13;
<em>transparent to exceptions</em>: it should propagate exceptions coming from a collector. In other words, a flow should&#13;
never swallow downstream exceptions.</p>&#13;
&#13;
<p>Throughout this book, we’ll refer to <em>exception transparency</em> to designate a flow that is <em>transparent to&#13;
exceptions</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exception Transparency Violation" data-type="sect2"><div class="sect2" id="idm46669739635968">&#13;
<h2>Exception Transparency Violation</h2>&#13;
&#13;
<p><a data-primary="error handling" data-secondary="exception transparency violation" data-type="indexterm" id="idm46669739634576"/><a data-primary="exception transparency violation" data-type="indexterm" id="idm46669739633360"/><a data-primary="flows" data-secondary="exception transparency violation" data-type="indexterm" id="idm46669739632672"/>The previous example was an example of exception transparency violation. Trying to emit values from inside a&#13;
<code>try</code>/<code>catch</code> block is another violation. Here<a data-startref="ix_ch10-asciidoc15" data-type="indexterm" id="idm46669739630624"/><a data-startref="ix_ch10-asciidoc14" data-type="indexterm" id="idm46669739629920"/> is an example (again, don’t do this!):</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">violatesExceptionTransparency</code><code class="p">:</code> <code class="n">Flow</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">flow</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">i</code> <code class="k">in</code> <code class="m">1.</code><code class="p">.</code><code class="m">3</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">try</code> <code class="p">{</code>&#13;
            <code class="n">emit</code><code class="p">(</code><code class="n">i</code><code class="p">)</code>&#13;
        <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">emit</code><code class="p">(-</code><code class="m">1</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">try</code> <code class="p">{</code>&#13;
        <code class="n">violatesExceptionTransparency</code><code class="p">.</code><code class="n">collect</code> <code class="p">{</code> <code class="n">value</code> <code class="p">-&gt;</code>&#13;
            <code class="n">check</code><code class="p">(</code><code class="n">value</code> <code class="p">&lt;=</code> <code class="m">2</code><code class="p">)</code> <code class="p">{</code> <code class="s">"Collected $value"</code> <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Throwable</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">println</code><code class="p">(</code><code class="s">"Caught $e"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output is:</p>&#13;
&#13;
<pre data-type="programlisting">Caught java.lang.IllegalStateException: Flow exception transparency is&#13;
violated:&#13;
Previous 'emit' call has thrown exception java.lang.IllegalStateException: Collected 3, but then emission attempt of value '-1' has been detected.&#13;
Emissions from 'catch' blocks are prohibited in order to avoid unspecified behaviour, 'Flow.catch' operator can be used instead.&#13;
For a more detailed explanation, please refer to Flow documentation.</pre>&#13;
&#13;
<p>The  <code>try</code>/<code>catch</code>  block  should  <em>only</em>  be  used  to  surround  the  collector,  to  handle  exceptions raised from the collector&#13;
itself, or (possibly, although it’s not ideal) to handle exceptions raised from the flow.</p>&#13;
&#13;
<p>To handle exceptions inside the flow, you should use the <code>catch</code> operator.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="The catch Operator" data-type="sect2"><div class="sect2" id="idm46669739500768">&#13;
<h2>The catch Operator</h2>&#13;
&#13;
<p><a data-primary="catch operator" data-type="indexterm" id="ix_ch10-asciidoc19"/><a data-primary="flows" data-secondary="catch operator" data-type="indexterm" id="ix_ch10-asciidoc20"/>The <code>catch</code> operator allows for a declarative style of catching exceptions, as shown in <a data-type="xref" href="#declarative">Figure 10-6</a>. It catches all upstream exceptions. By all&#13;
exceptions, we mean that it even catches <code>Throwable</code>s. Since it only catches upstream exceptions, the <code>catch</code> operator&#13;
doesn’t have the exception issue of the <code>try</code>/<code>catch</code> block.</p>&#13;
&#13;
<figure class="width-70"><div class="figure" id="declarative">&#13;
<img alt="pawk 10in04" src="assets/pawk_10in04.png"/>&#13;
<h6><span class="label">Figure 10-6. </span>Declarative style.</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-primary="catch operator" data-secondary="declarative style" data-type="indexterm" id="idm46669739490880"/><a data-primary="declarative style, catch operator" data-type="indexterm" id="idm46669739489904"/>You can find the corresponding <a href="https://oreil.ly/QcUeq">source code in GitHub</a>.</p>&#13;
&#13;
<p>The output is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Received 1&#13;
Received 2&#13;
Caught java.lang.RuntimeException</pre>&#13;
&#13;
<p>The flow raises a <code>RuntimeException</code> if it’s passed a value greater than 2. Right after, in the&#13;
<code>catch</code> operator, we print in the console. However, the collector never get the value 3. So the <code>catch</code> operator&#13;
automatically cancels the flow.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exception transparency" data-type="sect3"><div class="sect3" id="idm46669739484976">&#13;
<h3>Exception transparency</h3>&#13;
&#13;
<p><a data-primary="catch operator" data-secondary="exception transparency" data-type="indexterm" id="idm46669739483600"/><a data-primary="exception transparency" data-type="indexterm" id="idm46669739482624"/>From inside this operator, you can only catch<a data-primary="upstream exceptions" data-type="indexterm" id="idm46669739481760"/> <em>upstream exceptions</em>. When we say upstream, we mean relative to the <code>catch</code> operator. To show what we mean, we’ll pick an example where the collector throws an exception before the flow internally throws another exception. The collector should be able to catch the raised exception (the exception shouldn’t be caught by the flow):</p>&#13;
&#13;
<figure class="width-90"><div class="figure">&#13;
<img alt="pawk 10in05" src="assets/pawk_10in05.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
&#13;
<p>You can find the corresponding <a href="https://oreil.ly/0U5h1">source code in GitHub</a>.</p>&#13;
&#13;
<p>In this example, the collector throws a <code>RuntimeException</code> if it collects a value greater than 2. The collection&#13;
logic is wrapped in a <code>try</code>/<code>catch</code> statement because we don’t want our program to crash and log the exception.&#13;
The flow internally raises a <code>NumberformatException</code> if the value is negative. The <code>catch</code> operator acts as a&#13;
safeguard (logs the exception and cancels the flow).</p>&#13;
&#13;
<p>The output is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Received 0&#13;
Collector stopped collecting the flow</pre>&#13;
&#13;
<p>Note that the flow didn’t intercept the exception raised inside the collector, because it was caught in the catch&#13;
clause of the <code>try</code>/<code>catch</code>. The flow never got to raise a &#13;
<span class="keep-together"><code>NumberformatException</code>,</span> because the&#13;
collector prematurely cancelled the &#13;
<span class="keep-together">collection.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Another example" data-type="sect3"><div class="sect3" id="idm46669739469376">&#13;
<h3>Another example</h3>&#13;
&#13;
<p><a data-primary="catch operator" data-secondary="example" data-type="indexterm" id="idm46669739468176"/>In <a data-type="xref" href="#use_case_2_id">“Use Case #2: Concurrently Transform a Stream of Values”</a>, we held off on talking about error handling. Suppose the <code>transform</code> function might raise&#13;
exceptions, among which is <code>NumberFormatException</code>. You can selectively handle <code>NumberFormatException</code> using the&#13;
<code>catch</code> operator:</p>&#13;
&#13;
<pre class="less_space pagebreak-before" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">main</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">runBlocking</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="c1">// Defining the Flow of Content - nothing is executing yet&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">contentFlow</code><code> </code><code class="p">=</code><code> </code><code class="n">locationsFlow</code><code class="p">.</code><code class="n">map</code><code> </code><code class="p">{</code><code> </code><code class="n">loc</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>        </code><code class="n">flow</code><code> </code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="n">emit</code><code class="p">(</code><code class="n">transform</code><code class="p">(</code><code class="n">loc</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="p">}</code><code class="p">.</code><code class="k">catch</code><code> </code><code class="p">{</code><code> </code><code class="n">cause</code><code class="p">:</code><code> </code><code class="n">Throwable</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code>&#13;
</code><code>            </code><code class="k">if</code><code> </code><code class="p">(</code><code class="n">cause</code><code> </code><code class="k">is</code><code> </code><code class="n">NumberFormatException</code><code class="p">)</code><code> </code><code class="p">{</code><code>   </code><a class="co" href="#callout_flows_CO3-1" id="co_flows_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>                </code><code class="n">println</code><code class="p">(</code><code class="s">"Handling $cause"</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">}</code><code> </code><code class="k">else</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                </code><code class="k">throw</code><code> </code><code class="n">cause</code><code>                         </code><a class="co" href="#callout_flows_CO3-2" id="co_flows_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code class="p">.</code><code class="n">flattenMerge</code><code class="p">(</code><code class="m">4</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="c1">// We now collect the entire flow using the toList terminal operator&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">contents</code><code> </code><code class="p">=</code><code> </code><code class="n">contentFlow</code><code class="p">.</code><code class="n">toList</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_flows_CO3-1" id="callout_flows_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>As the <code>catch</code> operator catches <code>Throwable</code>s, we need to check the type of the error. If the error is a&#13;
<code>NumberFormatException</code>, then we handle it inside the <code>if</code> statement. You can add other checks there for different error&#13;
types.</p></dd>&#13;
<dt><a class="co" href="#co_flows_CO3-2" id="callout_flows_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Otherwise, you don’t know the error’s type. In most cases, it’s preferable not to swallow the error and rethrow.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="You can use emit from inside catch" data-type="sect3"><div class="sect3" id="idm46669739353152">&#13;
<h3>You can use emit from inside catch</h3>&#13;
&#13;
<p><a data-primary="catch operator" data-secondary="emit a particular value" data-type="indexterm" id="idm46669739351776"/>Sometimes it will make sense to emit a particular value when you catch an exception from inside the flow:</p>&#13;
&#13;
<figure><div class="figure">&#13;
<img alt="pawk 10in06" src="assets/pawk_10in06.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
&#13;
<p>You can find the corresponding <a href="https://oreil.ly/vknEm">source code in GitHub</a>.</p>&#13;
&#13;
<p>The output is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Received 1&#13;
Received 3&#13;
Received 0</pre>&#13;
&#13;
<p>Emitting values from inside <code>catch</code> is especially useful to <em>materialize exceptions</em>.<a data-startref="ix_ch10-asciidoc20" data-type="indexterm" id="idm46669739317088"/><a data-startref="ix_ch10-asciidoc19" data-type="indexterm" id="idm46669739316480"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Materialize Your Exceptions" data-type="sect2"><div class="sect2" id="idm46669739500144">&#13;
<h2>Materialize Your Exceptions</h2>&#13;
&#13;
<p><em>Materializing exceptions</em><sup><a data-type="noteref" href="ch10.html#idm46669739314304" id="idm46669739314304-marker">5</a></sup> is the process of catching exceptions and emitting special values or objects that represent those exceptions. The goal is to avoid throwing exceptions from inside the flow, because code&#13;
execution then goes to whatever place that collects that flow. It doesn’t matter whether collection code handles&#13;
exceptions thrown by the flow or not. If the flow throws exceptions, the collection code needs to be aware of&#13;
those exceptions and catch them in order to avoid undefined behavior. Consequently, the flow has a&#13;
<em>side effect on the collection code</em>, and this is a violation of the exception transparency principle.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The collection code shouldn’t be aware of implementation details of the flow. For example, if the flow is a <code>Flow&lt;Number&gt;</code>,&#13;
you should only expect to get <code>Number</code> values (or subtypes)—not exceptions.</p>&#13;
</div>&#13;
&#13;
<p>Let’s take another example. Imagine you’re fetching images, given their URLs. You have an incoming flow of URLs:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="c1">// We don't use realistic URLs, for brevity</code>&#13;
<code class="k">val</code> <code class="py">urlFlow</code> <code class="p">=</code> <code class="n">flowOf</code><code class="p">(</code><code class="s">"url-1"</code><code class="p">,</code> <code class="s">"url-2"</code><code class="p">,</code> <code class="s">"url-retry"</code><code class="p">)</code></pre>&#13;
&#13;
<p>You also have this function already available:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">fetchImage</code><code class="p">(</code><code class="n">url</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">Image</code> <code class="p">{</code>&#13;
    <code class="c1">// Simulate some remote call</code>&#13;
    <code class="n">delay</code><code class="p">(</code><code class="m">10</code><code class="p">)</code>&#13;
&#13;
    <code class="c1">// Simulate an exception thrown by the server or API</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="n">url</code><code class="p">.</code><code class="n">contains</code><code class="p">(</code><code class="s">"retry"</code><code class="p">))</code> <code class="p">{</code>&#13;
        <code class="k">throw</code> <code class="n">IOException</code><code class="p">(</code><code class="s">"Server returned HTTP response code 503"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="n">Image</code><code class="p">(</code><code class="n">url</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Image</code><code class="p">(</code><code class="k">val</code> <code class="py">url</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code></pre>&#13;
&#13;
<p>This<a data-primary="fetchImage" data-type="indexterm" id="idm46669739294016"/> <code>fetchImage</code> function may throw <code>IOException</code>s. In order to craft a “flow of images” using the&#13;
<code>urlFlow</code> and the <code>fetchImage</code> function, you should materialize &#13;
<span class="keep-together"><code>IOException</code>s.</span> Regarding the <code>fetchImage</code> function, it either succeeds or fails—you either get an <code>Image</code> instance, or an exception&#13;
is thrown. You can represent these outcomes by a <code>Result</code> type, with <code>Success</code> and <code>Error</code> subclasses:<sup><a data-type="noteref" href="ch10.html#idm46669739185008" id="idm46669739185008-marker">6</a></sup></p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">sealed</code> <code class="k">class</code> <code class="nc">Result</code>&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Success</code><code class="p">(</code><code class="k">val</code> <code class="py">image</code><code class="p">:</code> <code class="n">Image</code><code class="p">)</code> <code class="p">:</code> <code class="n">Result</code><code class="p">()</code>&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Error</code><code class="p">(</code><code class="k">val</code> <code class="py">url</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code> <code class="p">:</code> <code class="n">Result</code><code class="p">()</code></pre>&#13;
&#13;
<p>In the case of a success, we wrap the actual result—the <code>Image</code> instance. In the case of failure, we felt it was&#13;
appropriate to wrap the URL for which image retrieval failed. However, you’re free to wrap all data that&#13;
might be useful for the collection code, such as the exception itself.</p>&#13;
&#13;
<p>Now you can encapsulate <code>fetchImage</code> usage, by creating a <code>fetchResult</code> function which returns <code>Result</code> instances:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">suspend</code> <code class="k">fun</code> <code class="nf">fetchResult</code><code class="p">(</code><code class="n">url</code><code class="p">:</code> <code class="n">String</code><code class="p">):</code> <code class="n">Result</code> <code class="p">{</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Fetching $url.."</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="k">try</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">image</code> <code class="p">=</code> <code class="n">fetchImage</code><code class="p">(</code><code class="n">url</code><code class="p">)</code>&#13;
        <code class="n">Success</code><code class="p">(</code><code class="n">image</code><code class="p">)</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">IOException</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="n">Error</code><code class="p">(</code><code class="n">url</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Finally, you can implement a <code>resultFlow</code> and collect it safely:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">urlFlow</code> <code class="p">=</code> <code class="n">flowOf</code><code class="p">(</code><code class="s">"url-1"</code><code class="p">,</code> <code class="s">"url-2"</code><code class="p">,</code> <code class="s">"url-retry"</code><code class="p">)</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">resultFlow</code> <code class="p">=</code> <code class="n">urlFlow</code>&#13;
        <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">url</code> <code class="p">-&gt;</code> <code class="n">fetchResult</code><code class="p">(</code><code class="n">url</code><code class="p">)</code> <code class="p">}</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">results</code> <code class="p">=</code> <code class="n">resultFlow</code><code class="p">.</code><code class="n">toList</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Results: $results"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output is:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Fetching url-1..&#13;
Fetching url-2..&#13;
Fetching url-retry..&#13;
Results: [Success(image=Image(url=url-1)), Success(image=Image(url=url-2)), Error(url=url-retry)]</pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A bonus" data-type="sect3"><div class="sect3" id="idm46669738974064">&#13;
<h3>A bonus</h3>&#13;
&#13;
<p>Imagine that you’d like to automatically retry fetching an image in the event of  an error. You can implement a custom&#13;
flow operator that retries an <code>action</code> while the <code>predicate</code> returns true:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">,</code> <code class="n">R</code> <code class="p">:</code> <code class="n">Any</code><code class="p">&gt;</code> <code class="n">Flow</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">mapWithRetry</code><code class="p">(</code>&#13;
    <code class="n">action</code><code class="p">:</code> <code class="n">suspend</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">R</code><code class="p">,</code>&#13;
    <code class="n">predicate</code><code class="p">:</code> <code class="n">suspend</code> <code class="p">(</code><code class="n">R</code><code class="p">,</code> <code class="n">attempt</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Boolean</code>&#13;
<code class="p">)</code> <code class="p">=</code> <code class="n">map</code> <code class="p">{</code> <code class="n">data</code> <code class="p">-&gt;</code>&#13;
    <code class="k">var</code> <code class="py">attempt</code> <code class="p">=</code> <code class="m">0L</code>&#13;
    <code class="k">var</code> <code class="py">shallRetry</code><code class="p">:</code> <code class="n">Boolean</code>&#13;
    <code class="k">var</code> <code class="py">lastValue</code><code class="p">:</code> <code class="n">R</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
    <code class="k">do</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">tr</code> <code class="p">=</code> <code class="n">action</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
        <code class="n">shallRetry</code> <code class="p">=</code> <code class="n">predicate</code><code class="p">(</code><code class="n">tr</code><code class="p">,</code> <code class="p">++</code><code class="n">attempt</code><code class="p">)</code>&#13;
        <code class="k">if</code> <code class="p">(!</code><code class="n">shallRetry</code><code class="p">)</code> <code class="n">lastValue</code> <code class="p">=</code> <code class="n">tr</code>&#13;
    <code class="p">}</code> <code class="k">while</code> <code class="p">(</code><code class="n">shallRetry</code><code class="p">)</code>&#13;
    <code class="k">return</code><code class="n">@map</code> <code class="n">lastValue</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you’d like to retry, three times (at most) before returning an error, you can use this&#13;
operator like so:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">main</code><code class="p">()</code> <code class="p">=</code> <code class="n">runBlocking</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">urlFlow</code> <code class="p">=</code> <code class="n">flowOf</code><code class="p">(</code><code class="s">"url-1"</code><code class="p">,</code> <code class="s">"url-2"</code><code class="p">,</code> <code class="s">"url-retry"</code><code class="p">)</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">resultFlowWithRetry</code> <code class="p">=</code> <code class="n">urlFlow</code>&#13;
        <code class="p">.</code><code class="n">mapWithRetry</code><code class="p">(</code>&#13;
            <code class="p">{</code> <code class="n">url</code> <code class="p">-&gt;</code> <code class="n">fetchResult</code><code class="p">(</code><code class="n">url</code><code class="p">)</code> <code class="p">},</code>&#13;
            <code class="p">{</code> <code class="n">value</code><code class="p">,</code> <code class="n">attempt</code> <code class="p">-&gt;</code> <code class="n">value</code> <code class="k">is</code> <code class="n">Error</code> <code class="p">&amp;&amp;</code> <code class="n">attempt</code> <code class="p">&lt;</code> <code class="m">3L</code> <code class="p">}</code>&#13;
        <code class="p">)</code>&#13;
&#13;
    <code class="k">val</code> <code class="py">results</code> <code class="p">=</code> <code class="n">resultFlowWithRetry</code><code class="p">.</code><code class="n">toList</code><code class="p">()</code>&#13;
    <code class="n">println</code><code class="p">(</code><code class="s">"Results: $results"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The output is:<a data-startref="ix_ch10-asciidoc23" data-type="indexterm" id="idm46669738825872"/><a data-startref="ix_ch10-asciidoc22" data-type="indexterm" id="idm46669738825264"/><a data-startref="ix_ch10-asciidoc21" data-type="indexterm" id="idm46669738731680"/></p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">Fetching url-1..&#13;
Fetching url-2..&#13;
Fetching url-retry..&#13;
Fetching url-retry..&#13;
Fetching url-retry..&#13;
Results: [Success(image=Image(url=url-1)), Success(image=Image(url=url-2)), Error(url=url-retry)]</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hot Flows with SharedFlow" data-type="sect1"><div class="sect1" id="idm46669739859776">&#13;
<h1>Hot Flows with SharedFlow</h1>&#13;
&#13;
<p><a data-primary="flows" data-secondary="hot flows with SharedFlow" data-type="indexterm" id="ix_ch10-asciidoc24"/><a data-primary="hot flows" data-type="indexterm" id="ix_ch10-asciidoc25"/><a data-primary="SharedFlow" data-secondary="hot flows with" data-seealso="hot flows" data-type="indexterm" id="ix_ch10-asciidoc26"/>Previous implementations of flow were <em>cold</em>: nothing runs until you start collecting the flow.&#13;
This is made possible because for each emitted value, only one collector would get the value. Therefore,&#13;
there’s no need to run anything until the collector is ready to collect the values.</p>&#13;
&#13;
<p>However, what if you need to <em>share</em> emitted values among several collectors? For example, say an event like a file download completes in your app. You might want to directly notify various components, such as some view-models, repositories,&#13;
or even some views. Your file downloader might not have to be aware of the existence of other parts of your app.&#13;
A good separation of concerns starts with a loose coupling of classes, and the <em>event bus</em> is one architecture pattern&#13;
that helps in this &#13;
<span class="keep-together">situation.</span></p>&#13;
&#13;
<p>The principle is simple: the downloader emits an event (an instance of a class, optionally holding some state) by giving&#13;
it to the event bus, and all subscribers subsequently receive that event. A <code>SharedFlow</code> can act just like that, as&#13;
shown in <a data-type="xref" href="#shared_flow_principle">Figure 10-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="shared_flow_principle">&#13;
<img alt="SharedFlow" src="assets/pawk_1006.png"/>&#13;
<h6><span class="label">Figure 10-7. </span><code>SharedFlow</code>.</h6>&#13;
</div></figure>&#13;
&#13;
<p>A <code>SharedFlow</code> broadcasts events to all its subscribers.&#13;
Actually, <code>SharedFlow</code> really is a toolbox that can be used in many situations—not just to implement an event bus.&#13;
Before giving examples of usage, we’ll show how to create a <code>SharedFlow</code> and how you can tune it.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create a SharedFlow" data-type="sect2"><div class="sect2" id="idm46669738715520">&#13;
<h2>Create a SharedFlow</h2>&#13;
&#13;
<p><a data-primary="hot flows" data-secondary="create a SharedFlow" data-type="indexterm" id="idm46669738714320"/><a data-primary="SharedFlow" data-secondary="creating" data-type="indexterm" id="idm46669738713120"/>In its simplest usage, you invoke<a data-primary="MutableSharedFLow()" data-type="indexterm" id="idm46669738712048"/> <code>MutableSharedFlow()</code> with no parameter. As its name suggests, you can <em>mutate</em> its&#13;
state, by sending values to it. A common pattern when creating a <code>SharedFlow</code> is to create a private mutable version and&#13;
a public nonmutable one using<a data-primary="asSharedFlow()" data-type="indexterm" id="idm46669738710352"/> <code>asSharedFlow()</code>, as shown in the following:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">val</code> <code class="py">_sharedFlow</code> <code class="p">=</code> <code class="n">MutableSharedFlow</code><code class="p">&lt;</code><code class="n">Data</code><code class="p">&gt;()</code>&#13;
<code class="k">val</code> <code class="py">sharedFlow</code><code class="p">:</code> <code class="n">SharedFlow</code><code class="p">&lt;</code><code class="n">Data</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">_sharedFlow</code><code class="p">.</code><code class="n">asSharedFlow</code><code class="p">()</code></pre>&#13;
&#13;
<p>This pattern is useful when you ensure that subscribers will only be able to <em>read</em> the flow (e.g., not send values).&#13;
You might be surprised to find that &#13;
<span class="keep-together"><code>MutableSharedFlow</code></span> &#13;
<span class="keep-together">is not</span> a class. It’s actually a function that accepts parameters,&#13;
which we’ll cover later &#13;
<span class="keep-together">in this</span> chapter. For now, we’re only showing the default no-arg version of &#13;
<span class="keep-together"><code>MutableSharedFlow</code>.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Register a Subscriber" data-type="sect2"><div class="sect2" id="idm46669738689056">&#13;
<h2>Register a Subscriber</h2>&#13;
&#13;
<p><a data-primary="hot flows" data-secondary="register a subscriber" data-type="indexterm" id="idm46669738687856"/>A subscriber registers when it starts collecting the <code>SharedFlow</code>—preferably the public nonmutable version:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">scope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
   <code class="n">sharedFlow</code><code class="p">.</code><code class="n">collect</code> <code class="p">{</code> <code class="n">data</code> <code class="p">-&gt;</code>&#13;
      <code class="n">println</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
   <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A subscriber can only live in a scope, because the <code>collect</code> terminal operator is a suspending function. This is good&#13;
for structured concurrency: if the scope is cancelled, so is the subscriber.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Send Values to the SharedFlow" data-type="sect2"><div class="sect2" id="idm46669738641008">&#13;
<h2>Send Values to the SharedFlow</h2>&#13;
&#13;
<p><a data-primary="hot flows" data-secondary="send values to the SharedFlow" data-type="indexterm" id="idm46669738639392"/><a data-primary="SharedFlow" data-secondary="sending values to" data-type="indexterm" id="idm46669738638352"/>A <code>MutableSharedFlow</code> exposes two methods to emit values—<code>emit</code> and <code>tryEmit</code>:</p>&#13;
<dl>&#13;
<dt><code>emit</code></dt>&#13;
<dd>&#13;
<p><a data-primary="emit" data-type="indexterm" id="idm46669738634464"/>This suspends under some conditions (discussed shortly).</p>&#13;
</dd>&#13;
<dt><code>tryEmit</code></dt>&#13;
<dd>&#13;
<p><a data-primary="tryEmit" data-type="indexterm" id="idm46669738632352"/>This never suspends. It tries to emit the value immediately.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Why are there two methods to emit values? This is because, by default, when a &#13;
<span class="keep-together"><code>MutableSharedFlow</code></span> emits a value using&#13;
<code>emit</code>, it suspends until <em>all</em> subscribers start processing the value. We will give an example of <code>emit</code> usage in&#13;
the next section.</p>&#13;
&#13;
<p>However, sometimes this isn’t what you want to do. You’ll find situations where you have to emit values from&#13;
nonsuspending code (see <a data-type="xref" href="#shared_flow_as_eventbus">“Using SharedFlow as an Event Bus”</a>). So here comes <code>tryEmit</code>, which tries to emit a value immediately&#13;
and returns <code>true</code> if it succeeded, and <code>false</code> otherwise. We’ll provide more details on the nuances of <code>emit</code> and&#13;
<code>tryEmit</code> in upcoming sections.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using SharedFlow to Stream Data" data-type="sect2"><div class="sect2" id="shared_flow_as_data_stream">&#13;
<h2>Using SharedFlow to Stream Data</h2>&#13;
&#13;
<p><a data-primary="hot flows" data-secondary="SharedFlow to stream data" data-type="indexterm" id="ix_ch10-asciidoc27"/><a data-primary="SharedFlow" data-secondary="streaming data with" data-type="indexterm" id="ix_ch10-asciidoc28"/><a data-primary="streaming data, SharedFlow and" data-type="indexterm" id="ix_ch10-asciidoc29"/>Suppose you are developing a news app. One of the features of your app is that it fetches news from an API or a local&#13;
database and displays this news (or newsfeed). Ideally, you should rely on a local database to avoid using the API&#13;
when possible. In this example, we’ll use the API as the only source of news, although you can easily extend on our&#13;
example to add local persistence.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The architecture" data-type="sect3"><div class="sect3" id="idm46669738594000">&#13;
<h3>The architecture</h3>&#13;
&#13;
<p><a data-primary="SharedFlow" data-secondary="architecture" data-type="indexterm" id="idm46669738592832"/>In our architecture, a view-model relies on a repository to get the newsfeed. When the view-model receives news, it&#13;
notifies the view. The repository is responsible for querying the remote API at regular intervals, and provides a&#13;
means for view-models to get the newsfeed (see <a data-type="xref" href="#shared_flow_example_arch">Figure 10-8</a>).</p>&#13;
&#13;
<figure><div class="figure" id="shared_flow_example_arch">&#13;
<img alt="App architecure" src="assets/pawk_1007.png"/>&#13;
<h6><span class="label">Figure 10-8. </span>App architecture.</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The implementation" data-type="sect3"><div class="sect3" id="idm46669738588384">&#13;
<h3>The implementation</h3>&#13;
&#13;
<p><a data-primary="SharedFlow" data-secondary="implementation" data-type="indexterm" id="ix_ch10-asciidoc30"/>To keep it simple, the following <code>News</code> data class represents news:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">News</code><code class="p">(</code><code class="k">val</code> <code class="py">content</code><code class="p">:</code> <code class="n">String</code><code class="p">)</code></pre>&#13;
&#13;
<p>The repository reaches the API through a<a data-primary="NewsDao" data-type="indexterm" id="idm46669738579616"/> <code>NewsDao</code>. In our example, the data access object (DAO) is manually constructor-injected. In a real application, we recommend that you use a dependency injection (DI) framework such as Hilt or Dagger:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">interface</code> <code class="n">NewsDao</code> <code class="p">{</code>&#13;
    <code class="n">suspend</code> <code class="k">fun</code> <code class="nf">fetchNewsFromApi</code><code class="p">():</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">News</code><code class="p">&gt;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We now have enough material to implement the repository:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">NewsRepository</code><code class="p">(</code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">dao</code><code class="p">:</code><code> </code><code class="n">NewsDao</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">_newsFeed</code><code> </code><code class="p">=</code><code> </code><code class="n">MutableSharedFlow</code><code class="p">&lt;</code><code class="n">News</code><code class="p">&gt;</code><code class="p">(</code><code class="p">)</code><code>    </code><a class="co" href="#callout_flows_CO4-1" id="co_flows_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">newsFeed</code><code> </code><code class="p">=</code><code> </code><code class="n">_newsFeed</code><code class="p">.</code><code class="n">asSharedFlow</code><code class="p">(</code><code class="p">)</code><code>              </code><a class="co" href="#callout_flows_CO4-2" id="co_flows_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">scope</code><code> </code><code class="p">=</code><code> </code><code class="n">CoroutineScope</code><code class="p">(</code><code class="n">Job</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">+</code><code> </code><code class="n">Dispatchers</code><code class="p">.</code><code class="n">IO</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="n">init</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="n">scope</code><code class="p">.</code><code class="n">launch</code><code> </code><code class="p">{</code><code>                                   </code><a class="co" href="#callout_flows_CO4-3" id="co_flows_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>            </code><code class="k">while</code><code> </code><code class="p">(</code><code class="k">true</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                </code><code class="k">val</code><code> </code><code class="py">news</code><code> </code><code class="p">=</code><code> </code><code class="n">dao</code><code class="p">.</code><code class="n">fetchNewsFromApi</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>                </code><code class="n">news</code><code class="p">.</code><code class="n">forEach</code><code> </code><code class="p">{</code><code> </code><code class="n">_newsFeed</code><code class="p">.</code><code class="n">emit</code><code class="p">(</code><code class="n">it</code><code class="p">)</code><code> </code><code class="p">}</code><code>      </code><a class="co" href="#callout_flows_CO4-4" id="co_flows_CO4-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>&#13;
</code><code>                </code><code class="n">delay</code><code class="p">(</code><code class="m">3</code><code class="m">0</code><code class="m">0</code><code class="m">0</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">fun</code><code> </code><code class="nf">stop</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">=</code><code> </code><code class="n">scope</code><code class="p">.</code><code class="n">cancel</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_flows_CO4-1" id="callout_flows_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We create our private mutable shared flow. It will only be used inside the repository.</p></dd>&#13;
<dt><a class="co" href="#co_flows_CO4-2" id="callout_flows_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We create the public nonmutable version of the shared flow.</p></dd>&#13;
<dt><a class="co" href="#co_flows_CO4-3" id="callout_flows_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>As soon as the repository instance is created, we start fetching news from the API.</p></dd>&#13;
<dt><a class="co" href="#co_flows_CO4-4" id="callout_flows_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Every time we get a list of <code>News</code> instances, we emit those values using our <code>MutableSharedFlow</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>All that’s left is to implement a view-model that will subscribe to the repository’s shared flow:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">NewsViewsModel</code><code class="p">(</code><code class="k">private</code> <code class="k">val</code> <code class="py">repository</code><code class="p">:</code> <code class="n">NewsRepository</code><code class="p">)</code> <code class="p">:</code> <code class="n">ViewModel</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">newsList</code> <code class="p">=</code> <code class="n">mutableListOf</code><code class="p">&lt;</code><code class="n">News</code><code class="p">&gt;()</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">_newsLiveData</code> <code class="p">=</code> <code class="n">MutableLiveData</code><code class="p">&lt;</code><code class="n">List</code><code class="p">&lt;</code><code class="n">News</code><code class="p">&gt;&gt;(</code><code class="n">newsList</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">newsLiveData</code><code class="p">:</code> <code class="n">LiveData</code><code class="p">&lt;</code><code class="n">List</code><code class="p">&lt;</code><code class="n">News</code><code class="p">&gt;&gt;</code> <code class="p">=</code> <code class="n">_newsLiveData</code>&#13;
&#13;
    <code class="n">init</code> <code class="p">{</code>&#13;
        <code class="n">viewModelScope</code><code class="p">.</code><code class="n">launch</code> <code class="p">{</code>&#13;
            <code class="n">repository</code><code class="p">.</code><code class="n">newsFeed</code><code class="p">.</code><code class="n">collect</code> <code class="p">{</code>&#13;
                <code class="n">println</code><code class="p">(</code><code class="s">"NewsViewsModel receives $it"</code><code class="p">)</code>&#13;
                <code class="n">newsList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">it</code><code class="p">)</code>&#13;
                <code class="n">_newsLiveData</code><code class="p">.</code><code class="n">value</code> <code class="p">=</code> <code class="n">newsList</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>By invoking <code>repository.newsFeed.collect { .. }</code>, the view-model subscribes to the shared flow. Every time the repository&#13;
emits a <code>News</code> instance to the shared flow, the view-model receives the news and adds it to its <a data-primary="LiveData" data-type="indexterm" id="idm46669738334224"/><code>LiveData</code> to update the&#13;
view.</p>&#13;
&#13;
<p>Notice how the flow collection happens inside a coroutine started with <code>viewModelScope.launch</code>. This implies that if the view-model reaches its end-of-life, the flow collection will automatically be cancelled, and that’s a good thing.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>In our example, we manually constructor-inject an object (in this case, the repository). A DI framework would&#13;
definitely help to avoid boilerplate code. As demonstrating DI frameworks isn’t the primary focus of this chapter, we&#13;
chose to go for a manual repository injection into the view-model.<a data-startref="ix_ch10-asciidoc30" data-type="indexterm" id="idm46669738217408"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Test of our implementation" data-type="sect3"><div class="sect3" id="idm46669738587728">&#13;
<h3>Test of our implementation</h3>&#13;
&#13;
<p><a data-primary="SharedFlow" data-secondary="implementation testing" data-type="indexterm" id="idm46669738215296"/>In order to test the previous code, we need to mock the <code>NewsDao</code>. Our DAO will just send two dummy <code>News</code> instances and increment&#13;
a counter:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">dao</code> <code class="p">=</code> <code class="k">object</code> <code class="err">: </code><code class="nc">NewsDao</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">var</code> <code class="py">index</code> <code class="p">=</code> <code class="m">0</code>&#13;
&#13;
    <code class="k">override</code> <code class="n">suspend</code> <code class="k">fun</code> <code class="nf">fetchNewsFromApi</code><code class="p">():</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">News</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
        <code class="n">delay</code><code class="p">(</code><code class="m">100</code><code class="p">)</code>  <code class="c1">// simulate network delay</code>&#13;
        <code class="k">return</code> <code class="n">listOf</code><code class="p">(</code>&#13;
            <code class="n">News</code><code class="p">(</code><code class="s">"news content ${++index}"</code><code class="p">),</code>&#13;
            <code class="n">News</code><code class="p">(</code><code class="s">"news content ${++index}"</code><code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When we run our code using the preceding DAO, this is what we see in the console:</p>&#13;
&#13;
<pre data-type="programlisting">NewsViewsModel receives News(content=news content 1)&#13;
NewsViewsModel receives News(content=news content 2)&#13;
NewsViewsModel receives News(content=news content 3)&#13;
...</pre>&#13;
&#13;
<p>There is nothing surprising here: our view-model simply receives the news sent by the repository. Things become interesting when&#13;
there’s not one but several view-models that  subscribe  to  the  shared  flow.  We’ve  gone  ahead  and  created  another &#13;
view-model which also logs in the console. We created the other view-model 250 ms <em>after</em> the launch of the program.&#13;
This is the output we get:</p>&#13;
&#13;
<pre class="less_space" data-type="programlisting">NewsViewsModel receives News(content=news content 1)&#13;
NewsViewsModel receives News(content=news content 2)&#13;
NewsViewsModel receives News(content=news content 3)&#13;
AnotherViewModel receives News(content=news content 3)&#13;
NewsViewsModel receives News(content=news content 4)&#13;
AnotherViewModel receives News(content=news content 4)&#13;
NewsViewsModel receives News(content=news content 5)&#13;
AnotherViewModel receives News(content=news content 5)&#13;
NewsViewsModel receives News(content=news content 6)&#13;
AnotherViewModel receives News(content=news content 6)&#13;
...</pre>&#13;
&#13;
<p>You can see that the other view-model <em>missed</em> the first two news entries. This is because, at the time the shared flow emits&#13;
the first two news entries, the first view-model is the only subscriber. The second view-model comes after and only receives&#13;
subsequent news.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Replay values" data-type="sect3"><div class="sect3" id="idm46669738133744">&#13;
<h3>Replay values</h3>&#13;
&#13;
<p><a data-primary="SharedFlow" data-secondary="replay values" data-type="indexterm" id="idm46669738132368"/>What if you need the second view-model to get previous news? A shared flow can <em>optionally</em> cache values so that new&#13;
subscribers receive the last <em>n</em> cached values. In our case, if we want the shared flow to replay the last two news entries,&#13;
all we have to do is to update the line in the repository:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">val</code> <code class="py">_newsFeed</code> <code class="p">=</code> <code class="n">MutableSharedFlow</code><code class="p">&lt;</code><code class="n">News</code><code class="p">&gt;(</code><code class="n">replay</code> <code class="p">=</code> <code class="m">2</code><code class="p">)</code></pre>&#13;
&#13;
<p>With that change, the two view-models receive <em>all</em> news. Replaying data is actually useful in other common situations.&#13;
Imagine the user leaves the fragment that displays the list of news. Potentially, the associated view-model might also&#13;
get destroyed, if its lifecycle is bound to the fragment (that wouldn’t be the case if you chose to bound the view-model&#13;
to the activity). Later on, the user comes back to the news fragment. What happens then? The view-model is re-created and&#13;
immediately gets the last two news entries while waiting for fresh news. Replaying only two news entries might then be insufficient.&#13;
Therefore, you might want to increase the replay count to, &#13;
<span class="keep-together">say, 15.</span></p>&#13;
&#13;
<p>Let’s recap. A <code>SharedFlow</code> can optionally replay values for new subscribers. The number of values to replay is&#13;
configurable, using the <code>replay</code> parameter of the <code>MutableSharedFlow</code> function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Suspend or not?" data-type="sect3"><div class="sect3" id="idm46669738118864">&#13;
<h3>Suspend or not?</h3>&#13;
&#13;
<p><a data-primary="SharedFlow" data-secondary="suspending/not suspending" data-type="indexterm" id="idm46669738117392"/>There’s one last thing about this replay feature that you should be aware of. A shared flow with <code>replay</code> &gt; <code>0</code> internally uses&#13;
a cache that works similarly to a <code>Channel</code>. For example, if you create a shared flow with <code>replay</code> = <code>3</code>, the first&#13;
three <code>emit</code> calls won’t suspend. In this case, <code>emit</code> and <code>tryEmit</code> do exactly the same thing: they add a new value to&#13;
the cache, as shown in <a data-type="xref" href="#shared_flow_cache_not_full">Figure 10-9</a>.</p>&#13;
&#13;
<figure><div class="figure" id="shared_flow_cache_not_full">&#13;
<img alt="Replay cache not full" src="assets/pawk_1008.png"/>&#13;
<h6><span class="label">Figure 10-9. </span>Replay cache not full.</h6>&#13;
</div></figure>&#13;
&#13;
<p>When you submit a fourth value to the shared flow, then it depends on whether you use <a data-primary="emit" data-type="indexterm" id="idm46669738081920"/><code>emit</code> or <a data-primary="tryEmit" data-type="indexterm" id="idm46669738080928"/><code>tryEmit</code>, as shown in&#13;
<a data-type="xref" href="#shared_flow_cache_full">Figure 10-10</a>. By default, when the replay cache is full, <code>emit</code> suspends until all subscribers start&#13;
processing the oldest value in the cache. As for <code>tryEmit</code>, it returns <code>false</code> since it can’t add the value to the cache.&#13;
If you don’t keep track of that fourth value yourself, this value is lost.</p>&#13;
&#13;
<figure><div class="figure" id="shared_flow_cache_full">&#13;
<img alt="Replay cache full" src="assets/pawk_1009.png"/>&#13;
<h6><span class="label">Figure 10-10. </span>Replay cache full.</h6>&#13;
</div></figure>&#13;
&#13;
<p>That behavior (when the replay cache is full) can be changed. You can also opt to discard either the oldest value in the&#13;
cache or the value that is being added to the cache. In both cases, <code>emit</code> does not suspend and <code>tryEmit</code> returns true.&#13;
Therefore, there are three possible behaviors on buffer overflow: suspend, drop oldest, and drop latest.</p>&#13;
&#13;
<p>You apply the desired behavior while creating the shared flow, by using the &#13;
<span class="keep-together"><code>onBufferOverflow</code></span> parameter, as shown in&#13;
the following:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">MutableSharedFlow</code><code class="p">(</code><code class="n">replay</code> <code class="p">=</code> <code class="m">3</code><code class="p">,</code> <code class="n">onBufferOverflow</code> <code class="p">=</code> <code class="n">BufferOverflow</code><code class="p">.</code><code class="n">DROP_OLDEST</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-primary="BufferOverflow" data-type="indexterm" id="idm46669738064784"/><code>BufferOverflow</code> is an <em>enum</em> with three possible values: <code>SUSPEND</code>, <code>DROP_OLDEST</code>, and <code>DROP_LATEST</code>.&#13;
If you don’t specify a value for <code>onBufferOverflow</code>, <code>SUSPEND</code> is the default strategy.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Buffer values" data-type="sect3"><div class="sect3" id="idm46669738061008">&#13;
<h3>Buffer values</h3>&#13;
&#13;
<p><a data-primary="SharedFlow" data-secondary="buffer values" data-type="indexterm" id="idm46669738059568"/>In addition to being able to replay values, a shared flow can <em>buffer</em> values without replaying them, allowing slow&#13;
subscribers to lag behind other, faster subscribers. The size of the buffer is customizable, as shown in&#13;
the following:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="n">MutableSharedFlow</code><code class="p">(</code><code class="n">extraBufferCapacity</code> <code class="p">=</code> <code class="m">2</code><code class="p">)</code></pre>&#13;
&#13;
<p>By default,<a data-primary="extraBufferCapacity" data-type="indexterm" id="idm46669738009936"/> <code>extraBufferCapacity</code> equals zero. When you set a strictly positive value, <code>emit</code> doesn’t suspend while&#13;
there is buffer space remaining—unless you explicitly change the buffer overflow strategy.</p>&#13;
&#13;
<p>You might be wondering in what situations <code>extraBufferCapacity</code> can be useful. &#13;
<span class="keep-together">One immediate</span> consequence of&#13;
creating a shared flow with, for example, &#13;
<span class="keep-together"><code>extraBufferCapacity</code></span> <code>=</code> <code>1</code> and  &#13;
<span class="keep-together"><code>onBufferOverflow</code></span> <code>=</code> <code>BufferOverflow.DROP_OLDEST</code>,&#13;
is that you’re guaranteed that <code>tryEmit</code> will <em>always</em> successfully insert a value into the shared flow. It’s sometimes&#13;
really convenient to insert values in a shared flow from nonsuspending code. A good example of such a use case is when&#13;
using a shared flow as an event bus.<a data-startref="ix_ch10-asciidoc29" data-type="indexterm" id="idm46669738018256"/><a data-startref="ix_ch10-asciidoc28" data-type="indexterm" id="idm46669738017552"/><a data-startref="ix_ch10-asciidoc27" data-type="indexterm" id="idm46669738016880"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using SharedFlow as an Event Bus" data-type="sect2"><div class="sect2" id="shared_flow_as_eventbus">&#13;
<h2>Using SharedFlow as an Event Bus</h2>&#13;
&#13;
<p><a data-primary="hot flows" data-secondary="SharedFlow as an event bus" data-type="indexterm" id="idm46669738014528"/><a data-primary="SharedFlow" data-secondary="as event bus" data-secondary-sortas="event bus" data-type="indexterm" id="idm46669738013584"/>You need an event bus when all the following conditions are met:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>You need to broadcast an event across one or several subscribers.</p>&#13;
</li>&#13;
<li>&#13;
<p>The event should be processed <em>only once</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If a component isn’t registered as a subscriber at the time you emit the event, the event is lost for that component.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Notice the difference with <code>LiveData</code>, which keeps in memory the last emitted value and replays it every time the fragment&#13;
is re-created. With an event bus, the fragment would only receive the event <em>once</em>. For example, if the fragment is&#13;
re-created (the user rotates the device), the event won’t be processed again.</p>&#13;
&#13;
<p>An event bus is particularly useful when you want, for example, to display a message as a <code>Toast</code> or <code>Snackbar</code>. It makes sense to&#13;
display the message only once. To achieve this, a repository can expose a shared flow as shown in the following code. In order to make the exposed flow accessible for view-models, or even fragments, you can use&#13;
a DI framework such as Hilt or Dagger:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MessageRepository</code> <code class="p">{</code>&#13;
    <code class="k">private</code> <code class="k">val</code> <code class="py">_messageFlow</code> <code class="p">=</code> <code class="n">MutableSharedFlow</code><code class="p">&lt;</code><code class="n">String</code><code class="p">&gt;(</code>&#13;
        <code class="n">extraBufferCapacity</code> <code class="p">=</code> <code class="m">1</code><code class="p">,</code>&#13;
        <code class="n">onBufferOverflow</code> <code class="p">=</code> <code class="n">BufferOverflow</code><code class="p">.</code><code class="n">DROP_OLDEST</code>&#13;
    <code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">messageEventBus</code> <code class="p">=</code> <code class="n">_messageFlow</code><code class="p">.</code><code class="n">asSharedFlow</code><code class="p">()</code>&#13;
&#13;
    <code class="k">private</code> <code class="k">fun</code> <code class="nf">someTask</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="c1">// Notify subscribers to display a message</code>&#13;
        <code class="n">_messageFlow</code><code class="p">.</code><code class="n">tryEmit</code><code class="p">(</code><code class="s">"This is important"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ve set <code>extraBufferCapacity</code> to 1 and <code>onBufferOverflow</code> to <code>DROP_OLDEST</code> so that <code>_messageFlow.tryEmit</code> always&#13;
emits successfully. Why do we care about <code>tryEmit</code>? In our example, we use <code>_messageFlow</code> from a nonsuspending function.&#13;
Therefore, we can’t use <code>emit</code> inside <code>someTask</code>.</p>&#13;
&#13;
<p>If you use <code>_messageFlow</code> from inside a coroutine, you can use <code>emit</code>. The behavior would be exactly the same, since&#13;
<code>emit</code> wouldn’t suspend because of the presence of the buffer and the buffer overflow policy.</p>&#13;
&#13;
<p>An event bus is appropriate for dispatching one-time events that some components might miss if they’re not ready to&#13;
receive those events. For example, say you fire a “recording-stopped” event while the user hasn’t navigated to the&#13;
fragment displaying recordings yet. The result is that the event is lost. However, your application can be designed to&#13;
update the state of the fragment anytime the fragment resumes. Consequently, receiving “recording-stopped” is only&#13;
useful when the fragment is in the resumed state, as this should trigger a state update. This is just an example of when&#13;
losing events is totally acceptable and part of your application’s design.</p>&#13;
&#13;
<p>Sometimes, however, this isn’t what you want to achieve. Take, for example, a service that can perform downloads.&#13;
If the service fires a “download-finished” event, you don’t want your UI to miss that. When the user navigates to the&#13;
view displaying the status of the download, the view should render the updated <em>state</em> of the download.</p>&#13;
&#13;
<p>You will face situations where sharing a <em>state</em> is required. This situation is so common that a type of shared flow was&#13;
specifically created for it: <code>StateFlow</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="StateFlow: A Specialized SharedFlow" data-type="sect2"><div class="sect2" id="idm46669738015744">&#13;
<h2>StateFlow: A Specialized SharedFlow</h2>&#13;
&#13;
<p><a data-primary="hot flows" data-secondary="StateFlow" data-type="indexterm" id="ix_ch10-asciidoc31"/><a data-primary="StateFlow" data-type="indexterm" id="ix_ch10-asciidoc32"/>When sharing a state, a state flow:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Shares only one value: the current <em>state</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Replays the state. Indeed, subscribers should get the last state even if they subscribe afterward.</p>&#13;
</li>&#13;
<li>&#13;
<p>Emits an initial value—much like <code>LiveData</code> has an initial value.</p>&#13;
</li>&#13;
<li>&#13;
<p>Emits new values only when the state changes.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As you’ve learned previously, this behavior can be achieved using a shared flow:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">shared</code> <code class="p">=</code> <code class="n">MutableSharedFlow</code><code class="p">(</code>&#13;
    <code class="n">replay</code> <code class="p">=</code> <code class="m">1</code><code class="p">,</code>&#13;
    <code class="n">onBufferOverflow</code> <code class="p">=</code> <code class="n">BufferOverflow</code><code class="p">.</code><code class="n">DROP_OLDEST</code>&#13;
<code class="p">)</code>&#13;
<code class="n">shared</code><code class="p">.</code><code class="n">tryEmit</code><code class="p">(</code><code class="n">initialValue</code><code class="p">)</code> <code class="c1">// emit the initial value</code>&#13;
<code class="k">val</code> <code class="py">state</code> <code class="p">=</code> <code class="n">shared</code><code class="p">.</code><code class="n">distinctUntilChanged</code><code class="p">()</code> <code class="c1">// get StateFlow-like behavior</code></pre>&#13;
&#13;
<p><code>StateFlow</code><sup><a data-type="noteref" href="ch10.html#idm46669737887008" id="idm46669737887008-marker">7</a></sup> is a shorthand for the preceding code. In practice, all you have to write is:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">state</code> <code class="p">=</code> <code class="n">MutableStateFlow</code><code class="p">(</code><code class="n">initialValue</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="An Example of StateFlow Usage" data-type="sect2"><div class="sect2" id="idm46669737821536">&#13;
<h2>An Example of StateFlow Usage</h2>&#13;
&#13;
<p>Imagine that you have a download service that can emit three possible download states: download started,&#13;
downloading, and download finished, as shown in <a data-type="xref" href="#download_state_flow">Figure 10-11</a>.</p>&#13;
&#13;
<figure><div class="figure" id="download_state_flow">&#13;
<img alt="Download state" src="assets/pawk_1010.png"/>&#13;
<h6><span class="label">Figure 10-11. </span>Download state.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Exposing a flow from an Android service can be done in several ways. If you need high decoupling for, say, testability&#13;
purposes, a DI-injected “repository” object can expose the flow. The repository is then injected in all components that&#13;
need to subscribe. Or the service can statically expose the flow in a companion object. This &#13;
<span class="keep-together">induces</span> tight coupling&#13;
between all components that use the flow. However, it might be acceptable in a small app or for demo purpose, such as&#13;
in the following example:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">DownloadService</code> <code class="p">:</code> <code class="n">Service</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
        <code class="k">private</code> <code class="k">val</code> <code class="py">_downloadState</code> <code class="p">=</code>&#13;
            <code class="n">MutableStateFlow</code><code class="p">&lt;</code><code class="n">ServiceStatus</code><code class="p">&gt;(</code><code class="n">Stopped</code><code class="p">)</code>&#13;
        <code class="k">val</code> <code class="py">downloadState</code> <code class="p">=</code> <code class="n">_downloadState</code><code class="p">.</code><code class="n">asStateFlow</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
    <code class="c1">// Rest of the code hidden for brevity</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">sealed</code> <code class="k">class</code> <code class="nc">ServiceStatus</code>&#13;
<code class="k">object</code> <code class="nc">Started</code> <code class="p">:</code> <code class="n">ServiceStatus</code><code class="p">()</code>&#13;
<code class="n">data</code> <code class="k">class</code> <code class="nc">Downloading</code><code class="p">(</code><code class="k">val</code> <code class="py">progress</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">:</code> <code class="n">ServiceStatus</code><code class="p">()</code>&#13;
<code class="k">object</code> <code class="nc">Stopped</code> <code class="p">:</code> <code class="n">ServiceStatus</code><code class="p">()</code></pre>&#13;
&#13;
<p>Internally, the service can update its state by using, for example, &#13;
<span class="keep-together"><code>_downloadState.tryEmit(Stopped)</code>.</span>&#13;
When declared inside a companion object, the state flow can be easily accessed from a view-model, and exposed as a&#13;
<code>LiveData</code> using <code>asLiveData()</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">DownloadViewModel</code> <code class="p">:</code> <code class="n">ViewModel</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">downloadServiceStatus</code> <code class="p">=</code> <code class="n">DownloadService</code><code class="p">.</code><code class="n">downloadState</code><code class="p">.</code><code class="n">asLiveData</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Subsequently, a view can subscribe to the <code>LiveData</code>:</p>&#13;
&#13;
<pre class="less_space" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code><code> </code><code class="nc">DownloadFragment</code><code> </code><code class="p">:</code><code> </code><code class="n">Fragment</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">val</code><code> </code><code class="py">viewModel</code><code class="p">:</code><code> </code><code class="n">DownloadViewModel</code><code> </code><code class="k">by</code><code> </code><code class="n">viewModels</code><code class="p">(</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">override</code><code> </code><code class="k">fun</code><code> </code><code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code><code> </code><code class="n">Bundle</code><code class="p">?</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="n">viewModel</code><code class="p">.</code><code class="n">downloadServiceStatus</code><code class="p">.</code><code class="n">observe</code><code class="p">(</code><code class="k">this</code><code class="p">)</code><code> </code><code class="p">{</code><code>   </code><a class="co" href="#callout_flows_CO5-1" id="co_flows_CO5-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>            </code><code class="n">it</code><code class="o">?.</code><code class="n">also</code><code> </code><code class="p">{</code><code>&#13;
</code><code>                </code><code class="n">onDownloadServiceStatus</code><code class="p">(</code><code class="n">it</code><code class="p">)</code><code>&#13;
</code><code>            </code><code class="p">}</code><code>&#13;
</code><code>        </code><code class="p">}</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">private</code><code> </code><code class="k">fun</code><code> </code><code class="nf">onDownloadServiceStatus</code><code class="p">(</code><code>&#13;
</code><code>        </code><code class="n">status</code><code class="p">:</code><code> </code><code class="n">ServiceStatus</code><code>&#13;
</code><code>    </code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">Nothing</code><code> </code><code class="p">=</code><code> </code><code class="k">when</code><code> </code><code class="p">(</code><code class="n">status</code><code class="p">)</code><code> </code><code class="p">{</code><code>                          </code><a class="co" href="#callout_flows_CO5-2" id="co_flows_CO5-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="n">Started</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">TODO</code><code class="p">(</code><code class="s">"Show download is about to start"</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="n">Stopped</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">TODO</code><code class="p">(</code><code class="s">"Show download stopped"</code><code class="p">)</code><code>&#13;
</code><code>        </code><code class="k">is</code><code> </code><code class="n">Downloading</code><code> </code><code class="p">-</code><code class="p">&gt;</code><code> </code><code class="n">TODO</code><code class="p">(</code><code class="s">"Show progress"</code><code class="p">)</code><code>&#13;
</code><code>    </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_flows_CO5-1" id="callout_flows_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We subscribe to the <code>LiveData</code>. If we receive a nonnull value, then we invoke <code>onDownloadServiceStatus</code> method.</p></dd>&#13;
<dt><a class="co" href="#co_flows_CO5-2" id="callout_flows_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We are purposely using <code>when</code> as an expression so that the Kotlin compiler guarantees that all possible types of&#13;
<code>ServiceStatus</code> are taken into account.</p></dd>&#13;
</dl>&#13;
&#13;
<p>You might be wondering why we used a state flow, and why we haven’t used a <code>LiveData</code> in the first place—eliminating&#13;
the need of <code>asLiveData()</code> in the view-model.</p>&#13;
&#13;
<p>The reason is simple. <code>LiveData</code> is Android-specific. It’s a lifecycle-aware component which is meaningful when used&#13;
within Android views. You might design your application with Kotlin multiplatform code in mind. When targeting Android and&#13;
iOS, only multiplatform code can be shared as common code. The coroutine library is multiplatform. <code>LiveData</code> isn’t.</p>&#13;
&#13;
<p>However, even when not considering Kotlin multiplatform, the Flows API makes more sense since it provides greater&#13;
flexibility with all its flows <a data-startref="ix_ch10-asciidoc33" data-type="indexterm" id="idm46669737529008"/>operators<a data-startref="ix_ch10-asciidoc32" data-type="indexterm" id="idm46669737528176"/><a data-startref="ix_ch10-asciidoc31" data-type="indexterm" id="idm46669737527472"/>.<a data-startref="ix_ch10-asciidoc26" data-type="indexterm" id="idm46669737482256"/><a data-startref="ix_ch10-asciidoc25" data-type="indexterm" id="idm46669737481648"/><a data-startref="ix_ch10-asciidoc24" data-type="indexterm" id="idm46669737481040"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669738729440">&#13;
<h1>Summary</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The Flows API allows for <em>asynchronous data stream transformation</em>. A lot of operators are already available out of the&#13;
box and cover most use cases.</p>&#13;
</li>&#13;
<li>&#13;
<p>Thanks to the <em>composable</em> nature of flow operators, you can fairly easily design your own, if you need to.</p>&#13;
</li>&#13;
<li>&#13;
<p>Some parts of the flow can be offloaded to a background thread or thread pool, and yet keep a high-level view of&#13;
data transformation.</p>&#13;
</li>&#13;
<li>&#13;
<p>A shared flow broadcasts values to all its subscribers. You can enable buffering and/or replay of values. Shared flows&#13;
really are a toolbox. You can use them as an event bus for one-time events, or in more complex interactions between&#13;
&#13;
<span class="keep-together">components.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>When a component shares its state, a special kind of shared flow is appropriate for use: state flow. It replays the&#13;
last state for new subscribers and only notifies subscribers when the state changes.<a data-startref="ix_ch10-asciidoc0" data-type="indexterm" id="idm46669737473712"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669741189760"><sup><a href="ch10.html#idm46669741189760-marker">1</a></sup> We’ll refer to <code>Flow</code>s as <em>flows</em> in the rest of this chapter.</p><p data-type="footnote" id="idm46669741051328"><sup><a href="ch10.html#idm46669741051328-marker">2</a></sup> A token is generally encrypted registration data which the client application stores in memory so that further database access doesn’t require explicit authentication.</p><p data-type="footnote" id="idm46669740498544"><sup><a href="ch10.html#idm46669740498544-marker">3</a></sup> As opposed to cold, a hot entity lives on its own until explicitly stopped.</p><p data-type="footnote" id="idm46669739885136"><sup><a href="ch10.html#idm46669739885136-marker">4</a></sup> The coroutine started with <code>coroutineScope{}</code>.</p><p data-type="footnote" id="idm46669739314304"><sup><a href="ch10.html#idm46669739314304-marker">5</a></sup> <em>Materialize</em> comes<a data-primary="exception handling" data-secondary="materializing exceptions" data-type="indexterm" id="ix_ch10-asciidoc21"/><a data-primary="flows" data-secondary="materializing exceptions" data-type="indexterm" id="ix_ch10-asciidoc22"/><a data-primary="materializing exceptions" data-type="indexterm" id="ix_ch10-asciidoc23"/> from the Rx operator of the same name. See the <a href="https://oreil.ly/SEiRP">Rx documentation</a> for more insight.</p><p data-type="footnote" id="idm46669739185008"><sup><a href="ch10.html#idm46669739185008-marker">6</a></sup> These subclasses are an algebraic data type.</p><p data-type="footnote" id="idm46669737887008"><sup><a href="ch10.html#idm46669737887008-marker">7</a></sup> Actually, <code>StateFlow</code> <em>is</em> a <code>SharedFlow</code> under the hood.</p></div></div></section></body></html>