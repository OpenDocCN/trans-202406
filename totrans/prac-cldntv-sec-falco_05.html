<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Understanding Falco’s Architecture"><div class="chapter" id="understanding_falcoapostr">
<h1><span class="label">Chapter 3. </span>Understanding Falco’s Architecture</h1>
<p><a contenteditable="false" data-primary="architecture of Falco" data-type="indexterm" id="ch03.html0"/>Welcome to <a data-type="xref" href="part02.xhtml#ii_the_architecture_of_falco">Part II</a> of the book! In <a data-type="xref" href="part01.xhtml#i_the_basics">Part I</a>, you learned what Falco is and what it does. You also took a high-level look at its architecture, installed it on your machine, and took it for a spin. Now it’s time to step up your game!</p>
<p>In this part of the book (Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="#understanding_falcoapostr">3</a> through <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.xhtml#the_output_framework">8</a>), we’ll get into the inner workings of Falco. You will learn about its architecture in more detail, including its main components and how data flows across them. We’ll show you how Falco interfaces with the kernel of the operating system and with the cloud logs to collect data, and how this data is enriched with context and metadata. <a data-type="xref" href="ch06.xhtml#fields_and_filters">Chapter 6</a> will then introduce you to the important topic of fields and filters, while <a data-type="xref" href="ch07.xhtml#falco_rules">Chapter 7</a> will get you more familiar with Falco rules. We’ll conclude <a data-type="xref" href="part02.xhtml#ii_the_architecture_of_falco">Part II</a> by talking about the outputs framework, a key piece of Falco.</p>
<p>Do you really need to learn about the internals of Falco in order to operate it? The answer, as it is so often in life, is “it depends.” If your goal is simply to deploy Falco in its default configuration and show your boss that it’s up and working, then you’re probably fine skipping this part of the book. However, doing so will make some things hard, and others impossible. For example, in Parts <a data-type="xref" data-xrefstyle="select:labelnumber" href="part03.xhtml#iii_running_falco_in_production">III</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="part04.xhtml#iv_extending_falco">IV</a> we’ll cover:</p>
<ul>
<li><p>Interpreting Falco’s output</p></li>
<li><p>Determining if an alert could be a false positive</p></li>
<li><p>Fine-tuning Falco to privilege accuracy over noise</p></li>
<li><p>Precisely adapting Falco to your environment</p></li>
<li><p>Customizing and extending Falco</p></li>
</ul>
<p>All of these tasks require you to truly understand the core concepts behind Falco and its architecture, and that’s what we’ll help you accomplish here.</p>
<p>True security is never trivial. It requires an investment that goes beyond a superficial understanding. But that investment is typically paid back in spades, because it can make the difference in whether your software gets compromised and your company ends up in the news for all the wrong reasons.</p>
<p>Assuming we’ve convinced you, let’s get started. <a data-type="xref" href="#the_high_level_architecture_of_a_typica">Figure 3-1</a> depicts the main components of a typical Falco sensor deployment.</p>
<figure><div id="the_high_level_architecture_of_a_typica" class="figure">
<img src="Images/pcns_0301.png" alt="" width="600" height="323"/>
<h6><span class="label">Figure 3-1. </span>The high-level architecture of a typical Falco sensor deployment</h6>
</div></figure>
<p>The architecture depicted in <a data-type="xref" href="#the_high_level_architecture_of_a_typica">Figure 3-1</a> reflects the components as they are organized at the code level in the <a href="https://oreil.ly/ClRJj">Falcosecurity organization on GitHub</a>. At this level of granularity, the main components are:</p>
<dl class="pagebreak-after">
<dt>Falco libraries</dt>
<dd><p><a contenteditable="false" data-primary="Falco libraries" data-type="indexterm" id="idm45324228275792"/><a contenteditable="false" data-primary="libraries" data-type="indexterm" id="idm45324228274592"/>The <a href="https://oreil.ly/6CbQH">Falco libraries</a>, or “libs,” are responsible for collecting the data the sensor will process. They also manage state and provide multiple layers of enrichment for the collected data.</p></dd>
<dt>Plugins</dt>
<dd><p><a contenteditable="false" data-primary="plugins" data-secondary="defined" data-type="indexterm" id="idm45324228271776"/>The <a href="https://oreil.ly/9Jyi8">plugins</a> extend the sensor with additional data sources. For example, plugins make it possible for Falco to use AWS CloudTrail and Kubernetes audit logs as data sources.</p></dd>
<dt>Falco</dt>
<dd><p>This is the <a href="https://oreil.ly/2IQkj">main sensor executable</a>, including the rule engine.</p></dd>
<dt>Falcosidekick</dt>
<dd><p><a contenteditable="false" data-primary="Falcosidekick" data-secondary="defined" data-type="indexterm" id="idm45324228266928"/><a href="https://oreil.ly/lmOie">Falcosidekick</a> is responsible for routing the notifications and connecting the sensor to the external world.</p></dd>
</dl>
<p>Of the components in <a data-type="xref" href="#the_high_level_architecture_of_a_typica">Figure 3-1</a>, Falco and the Falco libs are required and always installed, while Falcosidekick and the plugins are optional; you can install them based on your deployment strategy and needs.</p>
<section data-type="sect1" data-pdf-bookmark="Falco and the Falco Libraries: A Data-Flow View"><div class="sect1" id="falco_and_the_falco_libraries_a_data_fl">
<h1>Falco and the Falco Libraries: A Data-Flow View</h1>
<p><a contenteditable="false" data-primary="architecture of Falco" data-secondary="data flows/critical modules" data-type="indexterm" id="idm45324228261120"/><a contenteditable="false" data-primary="data flows" data-type="indexterm" id="idm45324228259728"/>Let’s take the two most important of the components we just described, the Falco libraries and Falco, and explore their data flows and critical modules.</p>
<p><a contenteditable="false" data-primary="system calls" data-secondary="as data source" data-secondary-sortas="data source" data-type="indexterm" id="idm45324228258208"/>As <a data-type="xref" href="#sensor_data_flow_and_main_modules">Figure 3-2</a> shows, system calls are one of the core sources of data. These are captured in the kernel of the operating system by one of Falco’s two drivers: the <em>kernel module</em> and the <em>eBPF (extended Berkeley Packet Filter) probe</em>.</p>
<figure><div id="sensor_data_flow_and_main_modules" class="figure">
<img src="Images/pcns_0302.png" alt="" width="600" height="345"/>
<h6><span class="label">Figure 3-2. </span>Sensor data flow and main modules</h6>
</div></figure>
<p><a contenteditable="false" data-primary="libscap" data-secondary="data flows and" data-type="indexterm" id="idm45324228252208"/>The collected system calls flow into the first of the Falco core libraries, <em>libscap</em>, which can also receive data from the plugins and exposes a common interface to the upper layers. <a contenteditable="false" data-primary="libsinsp" data-secondary="data flows and" data-type="indexterm" id="idm45324228250176"/>Data is then passed to the other key library, <em>libsinsp</em>, to be parsed and enriched. Next, the data is fed to the rule engine for evaluation. Falco receives the output of the rule engine and emits the resulting notifications, which can optionally go to Falcosidekick.</p>
<p>Pretty straightforward, right? <a data-type="xref" href="#key_roles_of_the_sensorapostrophes_main">Figure 3-3</a> gives further details about what each of these modules does, and in the following sections we’ll explore them in more depth.</p>
<figure><div id="key_roles_of_the_sensorapostrophes_main" class="figure">
<img src="Images/pcns_0303.png" alt="" width="600" height="508"/>
<h6><span class="label">Figure 3-3. </span>Key roles of the sensor’s main modules</h6>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Drivers"><div class="sect1" id="drivers">
<h1>Drivers</h1>
<p><a contenteditable="false" data-primary="architecture of Falco" data-secondary="drivers" data-type="indexterm" id="idm45324228242528"/><a contenteditable="false" data-primary="drivers" data-secondary="basics" data-type="indexterm" id="idm45324228241152"/><a contenteditable="false" data-primary="system calls" data-secondary="drivers and" data-type="indexterm" id="idm45324228239776"/>System calls are Falco’s original data source, and to this day they remain the most important. Collecting system calls is at the core of Falco’s ability to trace the behavior of processes, containers, and users in a very granular way and with high efficiency. Reliable and efficient system call collection needs to be performed from inside the kernel of the operating system, so it requires a driver that runs inside the OS itself. As mentioned in the previous section, Falco offers two such drivers: the kernel module and the eBPF probe.</p>
<p>These two components offer identical functionality and are deployed in a mutually exclusive way: if you deploy the kernel module, you can’t run the eBPF probe, and vice versa. <a contenteditable="false" data-primary="eBPF probe" data-secondary="kernel module versus" data-type="indexterm" id="idm45324228237664"/><a contenteditable="false" data-primary="kernel module" data-secondary="eBPF probe versus" data-type="indexterm" id="idm45324228236288"/>So what distinguishes them?</p>
<p>The kernel module works with any version of the Linux kernel, including older ones. Also, it requires somewhat fewer resources to run, so you should use it when you care about Falco having the smallest possible overhead.</p>
<p>The eBPF probe, on the other hand, runs only on more recent versions of Linux, starting at kernel 4.11. Its advantage is that it’s safer, because its code is strictly validated by the operating system before it is executed. This means that even if it contains a bug, it is (in theory) guaranteed not to crash your machine. Compared to the kernel module, it is also much better protected from security flaws that could compromise the machine where you run it. Therefore, in most cases, the eBPF probe is the option you should go with. Note also that some environments—in particular, cloud-based managed containerized environments—prevent kernel modules from being loaded in the operating system kernel. In such environments, the eBPF probe is your only option.</p>
<p>Both the kernel module and the eBPF probe are entrusted with a set of very important tasks:</p>
<dl>
<dt>Capturing system calls</dt>
<dd><p>The driver’s first responsibility is capturing system calls. This happens through a kernel facility called <a href="https://oreil.ly/tEYsq">tracepoints</a> and is heavily optimized to minimize the performance impact on the monitored applications.</p></dd>
<dt>System call packing</dt>
<dd><p>The driver then encodes the system call information into a transfer buffer, using a format that the rest of the Falco stack can parse easily and efficiently.</p></dd>
<dt>Zero-copy data transfer</dt>
<dd><p>Finally, the driver is responsible for efficiently transferring this data from the kernel to the user level, where <em>libscap</em> will receive it. We should really call this efficiently <em>not</em> transferring the data, since both the kernel module and the eBPF probe are designed around a zero-copy architecture that maps the data buffers into user-level memory so that <em>libscap</em> can access the original data without needing to copy or transfer it.</p></dd>
</dl>
<p>In <a data-type="xref" href="ch04.xhtml#data_source">Chapter 4</a> you will learn all you need to know about drivers, including their architecture, functionality, and usage scenarios.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Plugins"><div class="sect1" id="plugins">
<h1>Plugins</h1>
<p><a contenteditable="false" data-primary="architecture of Falco" data-secondary="plugins" data-type="indexterm" id="idm45324228224048"/><a contenteditable="false" data-primary="plugins" data-secondary="basics" data-type="indexterm" id="idm45324228222672"/>Plugins are a way to add additional data sources to Falco simply and without the need to rebuild it. Plugins implement an interface that feeds events into Falco, similar to what the kernel module and eBPF probe do. However, plugins are not limited to capturing system calls: they can feed Falco any kind of data, including logs and API events.</p>
<p>Falco has several powerful plugins that extend its scope. For example, the CloudTrail plugin ingests JSON logs from AWS CloudTrail and allows Falco to alert you when something dangerous happens in your cloud infrastructure. Plugins can be written in any language, but there are Go and C++ software development kits (SDKs) available that make it easier to write them in those languages. We will talk more about plugins in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.xhtml#data_source">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.xhtml#using_falco_for_cloud_se">11</a>.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="libscap"><div class="sect1" id="libscap">
<h1>libscap</h1>
<p><a contenteditable="false" data-primary="architecture of Falco" data-secondary="libscap" data-type="indexterm" id="ch03.html1"/><a contenteditable="false" data-primary="libscap" data-secondary="basics" data-type="indexterm" id="ch03.html2"/>The name <em>libscap</em> stands for “library for system capture,” a clear hint about its purpose. <em>libscap</em> is the gateway through which the input data passes before getting into the Falco processing pipeline. Let’s take a look at the main things <em>libscap</em> does <span class="keep-together">for us.</span></p>
<section data-type="sect2" data-pdf-bookmark="Managing Data Sources"><div class="sect2" id="managing_data_sources">
<h2>Managing Data Sources</h2>
<p><a contenteditable="false" data-primary="data sources" data-secondary="libscap’s management of" data-type="indexterm" id="idm45324228209328"/><a contenteditable="false" data-primary="libscap" data-secondary="managing data sources" data-type="indexterm" id="idm45324228207792"/>The <em>libscap</em> library contains the logic to control both the kernel module and the eBPF probe, including loading them, starting and stopping captures, and reading the data they produce. It also includes the logic to load, manage, and run plugins.</p>
<p><em>libscap</em> is designed to export a generic capture source abstraction to the upper layers of the stack. This means that no matter how you collect data (kernel module, eBPF probe, a plugin), programs that use <em>libscap</em> will have a consistent way to enumerate and control data sources, start and stop captures, and receive captured events, and you won’t have to worry about the nuances of interfacing with these disparate input sources.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Supporting Trace Files"><div class="sect2" id="supporting_trace_files">
<h2>Supporting Trace Files</h2>
<p><a contenteditable="false" data-primary="libscap" data-secondary="trace file support" data-type="indexterm" id="ch03.html3"/><a contenteditable="false" data-primary="trace files" data-secondary="libscap’s support of" data-type="indexterm" id="ch03.html4"/>Another extremely important piece of functionality in <em>libscap</em> is support for trace files. If you’ve ever created or opened a PCAP file with Wireshark or tcpdump, we’re sure you understand how useful (and powerful!) the concept of trace files is. If not, allow us to explain.</p>
<p>In addition to capturing and decoding network traffic, protocol analyzers (like Wireshark and tcpdump) let you “dump” the captured network packets into a <em>trace file</em>. The trace file contains a copy of each packet so that later you can open it to analyze the activity of that network segment. You can also share it with other people or filter its contents to isolate relevant information.</p>
<p><a contenteditable="false" data-primary="PCAP files" data-seealso="trace files" data-type="indexterm" id="idm45324228197792"/>Trace files are often referred to as PCAP <em>files</em>, a name that originates from the <em>.pcap</em> file format used to encode the data inside them (an open, standardized format understood by every networking tool in the universe). This enables an endless list of the capture now, analyze later workflows that are critical in computer networks.</p>
<p>Many Falco users don’t realize that Falco supports trace files using the <em>.pcap</em> format. This feature is extremely powerful and should definitely be part of your arsenal as you gain more experience. For example, trace files are invaluable when it comes to writing new rules.</p>
<p class="pagebreak-before">We’ll talk extensively about how to leverage trace files, for example in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.xhtml#data_source">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch13.xhtml#writing_falco_rules">13</a>, but for now let’s whet your appetite by teaching you how to create a trace file and have Falco read it, in two simple steps. To do that, we need to introduce a command-line tool called sysdig. You’ll learn more about sysdig in <a data-type="xref" href="ch04.xhtml#data_source">Chapter 4</a>, but for the moment we’ll just use it as a simple trace file generator.</p>
<section data-type="sect3" data-pdf-bookmark="Step 1: Create the trace file"><div class="sect3" id="step_one_create_the_trace_file">
<h3>Step 1: Create the trace file</h3>
<p>Install sysdig on your Linux host by following the <a href="https://oreil.ly/Rmkxr">installation instructions</a>. After finishing the installation, run the following on your command line, which instructs sysdig to capture all of the system calls generated by the host and write them to a file called <em>testfile.scap</em>:</p>
<pre data-type="programlisting">$ <strong>sudo sysdig -w testfile.scap</strong></pre>
<p>Wait a few seconds to make sure your machine is working on it, then press Ctrl-C to stop sysdig.</p>
<p>Now you have a snapshot of a few seconds’ worth of your host’s activity. Let’s take a look at what it contains:</p>
<pre data-type="programlisting">$ <strong>sysdig -r testfile.scap</strong>
1 17:41:13.628568857 0 prlcp (4358) &lt; write res=0 data=.N;.n... 
2 17:41:13.628573305 0 prlcp (4358) &gt; write fd=6(&lt;p&gt;pipe:[43606]) size=1 
3 17:41:13.628588359 0 prlcp (4358) &lt; write res=1 data=. 
4 17:41:13.609136030 3 gmain (2935) &lt; poll res=0 fds= 
5 17:41:13.609146818 3 gmain (2935) &gt; write fd=4(&lt;e&gt;) size=8 
6 17:41:13.609149203 3 gmain (2935) &lt; write res=8 data=........ 
7 17:41:13.609151765 3 gmain (2935) &gt; read fd=7(&lt;i&gt;) size=4096 
8 17:41:13.609153301 3 gmain (2935) &lt; read res=-11(EAGAIN) data= 
9 17:41:13.626956525 0 Xorg (3214) &lt; epoll_wait res=1 
10 17:41:13.626964759 0 Xorg (3214) &gt; setitimer 
11 17:41:13.626966955 0 Xorg (3214) &lt; setitimer 
12 17:41:13.626969972 0 Xorg (3214) &gt; recvmsg fd=42(&lt;u&gt;@/tmp/.X11-unix/X0) 
13 17:41:13.626976118 0 Xorg (3214) &lt; recvmsg res=28 size=28 data=....E..... ... 
14 17:41:13.626992585 0 Xorg (3214) &gt; writev fd=42(&lt;u&gt;@/tmp/.X11-unix/X0) size=32 
15 17:41:13.627013409 0 Xorg (3214) &lt; writev res=32 data=...7E.............. ... 
  
...</pre>
<p>We’ll go through the format of this output in detail later, but you can probably tell that this is a bunch of background input/output (I/O) activity performed by system tools like Xorg, gmain, and prlcp, which are running on this machine while it’s idle.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Step 2: Process the trace file with Falco"><div class="sect3" id="step_two_process_the_trace_file_with_fa">
<h3>Step 2: Process the trace file with Falco</h3>
<p>Think of the trace file as taking us back in time: you took a snapshot of your host at a specific point in time, and now you can trace the system calls generated on the host around that time, observing every process in detail. Processing the trace file with Falco is easy and lets you see quickly if any security violations happened during that time. Here’s a sample of its output:</p>
<pre data-type="programlisting">$ <strong>falco -e testfile.scap</strong>
Wed Sep 29 18:04:00 2021: Falco version 0.30.0
Wed Sep 29 18:04:00 2021: Falco initialized with configuration file /etc/falco
/falco.yaml
Wed Sep 29 18:04:00 2021: Loading rules from file /etc/falco/falco_rules.yaml:
Wed Sep 29 18:04:00 2021: Reading system call events from file: testfile.scap
Events detected: 0
Rule counts by severity:
Triggered rules by rule name:
Syscall event drop monitoring:
   - event drop detected: 0 occurrences
   - num times actions taken: 0</pre>
<p>Fortunately, it looks like we’re safe. This consistent, back-in-time way of running Falco is useful when writing or unit-testing rules. We’ll talk more about it when we deep dive into rules in <a data-type="xref" href="ch13.xhtml#writing_falco_rules">Chapter 13</a>.<a contenteditable="false" data-primary="" data-startref="ch03.html4" data-type="indexterm" id="idm45324228178784"/><a contenteditable="false" data-primary="" data-startref="ch03.html3" data-type="indexterm" id="idm45324228177376"/></p>
</div></section>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Collecting System State"><div class="sect2" id="collecting_system_state">
<h2>Collecting System State</h2>
<p><a contenteditable="false" data-primary="libscap" data-secondary="system state collection" data-type="indexterm" id="idm45324228174224"/><a contenteditable="false" data-primary="state" data-type="indexterm" id="idm45324228172848"/><a contenteditable="false" data-primary="system state" data-type="indexterm" id="idm45324228171744"/>System state collection is an important task that’s specifically related to capturing system calls. The kernel module and the eBPF probe produce raw system calls, which lack some important context Falco needs.</p>
<p>Let’s take a look at an example. A very common system call is <code>read</code>, which, as the name implies, reads a buffer of data from a file descriptor. Here is the prototype of <code>read</code>:</p>
<pre data-type="programlisting">ssize_t read(int fd, void *buf, size_t count);</pre>
<p>It has three inputs: the numeric file descriptor identifier, a buffer to fill, and the buffer size. It returns the amount of data that was written in the buffer.</p>
<p><a contenteditable="false" data-primary="file descriptors" data-secondary="defined" data-type="indexterm" id="idm45324228167664"/>A <em>file descriptor</em> is like the ID of an object inside the operating system kernel: it can indicate a file, a network connection (specifically, a socket), the endpoint of a pipe, a mutex (used for process synchronization), a timer, or several other types of objects.</p>
<p>Knowing the file descriptor number is not very useful when crafting a Falco rule. As users, we prefer to think about a file or directory name, or maybe a connection’s IP addresses and ports, than a file descriptor number. <em>libscap</em> helps us do that. When Falco starts, <em>libscap</em> fetches a bunch of data from a diverse set of sources within the operating system (for example, the <em>/proc</em> Linux filesystem). It uses this data to construct a set of tables that can be used to resolve cryptic numbers—file descriptors, process IDs, and so forth—into logical entities and their details, which are much easier for humans to use.</p>
<p class="pagebreak-before">This functionality is part of why Falco’s syntax is so much more expressive and usable than that of most comparable tools. One theme that you will be hearing often in this book is that <em>granular data is useless without context</em>. This gives you a hint of what that means.<a contenteditable="false" data-primary="" data-startref="ch03.html2" data-type="indexterm" id="idm45324228162240"/><a contenteditable="false" data-primary="" data-startref="ch03.html1" data-type="indexterm" id="idm45324228160896"/> Next we’ll dive into the other important Falco library: <em>libsinsp</em>.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="libsinsp"><div class="sect1" id="libsinsp">
<h1>libsinsp</h1>
<p><a contenteditable="false" data-primary="architecture of Falco" data-secondary="libsinsp" data-type="indexterm" id="ch03.html5"/><a contenteditable="false" data-primary="libsinsp" data-type="indexterm" id="ch03.html6"/><em>libsinsp</em> stands for “library for system inspection.” This library taps into the stream of data <em>libscap</em> produces, enriches it, and provides a number of higher-level primitives to work with it. Let’s start by exploring its most important functionality, the state engine.</p>
<section data-type="sect2" data-pdf-bookmark="State Engine"><div class="sect2" id="state_engine">
<h2>State Engine</h2>
<p><a contenteditable="false" data-primary="libsinsp" data-secondary="state engine" data-type="indexterm" id="idm45324228151056"/><a contenteditable="false" data-primary="state tables" data-type="indexterm" id="idm45324228149680"/>As we noted in the previous section, when Falco starts, <em>libscap</em> constructs a set of tables to convert low-level identifiers, like file descriptor numbers, into high-level, actionable information, like IP addresses and filenames. This is great, but what if a program opens a file <em>after</em> Falco starts? For example, a very common system call in Unix is <code>open</code>, which takes two input arguments, the filename and some flags, and returns a file descriptor identifying the newly opened file:</p>
<pre data-type="programlisting">int open(const char *pathname, int flags);</pre>
<p>In practice, <code>open</code>, like many other system calls, creates a new file descriptor, effectively changing the state of the process that called it. If a process invokes <code>open</code> after Falco has been launched, its new file descriptor will not be part of the state table, and Falco won’t know what to do with that descriptor. However, consider this: <code>open</code> is a system call. More generally, system calls are always used to create, destroy, or modify file descriptors. Recall, too, that the Falco libs capture <em>all</em> system calls from <em>every</em> process.</p>
<p><em>libsinsp</em>, in particular, has logic to inspect every state-changing system call and, based on the system call arguments, update the state tables. In other words, it tracks the activity of the whole machine to keep the state in sync with the underlying operating system. Further, it does so in a way that accurately supports containers. <em>libsinsp</em> keeps this constantly updated information in a hierarchical structure. This structure (<a data-type="xref" href="#the_libsinsp_state_hierarchy">Figure 3-4</a>) starts with a process table, each entry of which contains a file descriptor table, among other information.</p>
<p>These accurate, constantly updated state tables are at the core of Falco’s data enrichment, which in turn is a key building block of the rule engine.</p>
<figure><div id="the_libsinsp_state_hierarchy" class="figure">
<img src="Images/pcns_0304.png" alt="" width="600" height="467"/>
<h6><span class="label">Figure 3-4. </span>The libsinsp state hierarchy</h6>
</div></figure>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Event Parsing"><div class="sect2" id="event_parsing">
<h2>Event Parsing</h2>
<p><a contenteditable="false" data-primary="event parser" data-type="indexterm" id="idm45324228136704"/><a contenteditable="false" data-primary="libsinsp" data-secondary="event parsing" data-type="indexterm" id="idm45324228135504"/>The state engine requires a substantial amount of logic to understand system calls and parse their arguments. This is what <em>libsinsp</em>’s <em>event parser</em> does. State tracking leverages event parsing, but it’s used for other purposes as well. For example, it extracts useful arguments from system calls or other data sources, making them available to the rule engine. It also collates and reconstructs buffers that can be spread across multiple collected messages, making it easier to decode their content from Falco rules.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Filtering"><div class="sect2" id="filtering">
<h2>Filtering</h2>
<p><a contenteditable="false" data-primary="filters" data-secondary="libsinsp and" data-type="indexterm" id="idm45324228131232"/><a contenteditable="false" data-primary="libsinsp" data-secondary="filtering" data-type="indexterm" id="idm45324228129632"/>Filtering is one of the most important concepts in Falco, and it’s fully implemented in <em>libsinsp</em>. <a contenteditable="false" data-primary="filters" data-secondary="defined" data-type="indexterm" id="idm45324228127600"/>A <em>filter</em> is a Boolean expression that ties together multiple <em>checks</em>, each of which compares a filter field with a constant value. The importance of filters is obvious when we look at rules. (Indeed, it’s so important that we dedicate all of <a data-type="xref" href="ch06.xhtml#fields_and_filters">Chapter 6</a> to it.) Let’s take the simple rule shown here:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shell_in_container</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shell opened inside a container</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">container.id != host and proc.name = bash</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shell in a container (user=%user.name container_id=%container.id)</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">WARNING</code><code class="w"/></pre>
<p>The <code>condition</code> section of the rule is a <em>libsinsp</em> filter. The condition in our example checks that the container ID is not <code>host</code> and that the name of the process is <code>bash</code>. Every captured system call that meets both criteria will trigger the rule.</p>
<p><em>libsinsp</em> is responsible for defining and implementing system call–related filter fields. It also contains the engine that evaluates filters and tells us if the rule should trigger, so it’s not an exaggeration to say that <em>libsinsp</em> is the heart of Falco.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Output Formatting"><div class="sect2" id="output_formatting-id000022">
<h2>Output Formatting</h2>
<p><a contenteditable="false" data-primary="libsinsp" data-secondary="output formatting" data-type="indexterm" id="idm45324228101568"/><a contenteditable="false" data-primary="outputs" data-secondary="libsinsp and formatting" data-type="indexterm" id="idm45324228100192"/>If we take another look at the example rule, we can see that the <code>output</code> section makes use of a syntax similar to that of the <code>condition</code> section:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shell in a container (user=%user.name container_id=%container.id)</code><code class="w"/></pre>
<p>Output is what Falco prints when the rule triggers—and yes, you can use filter fields in this section (the same fields that you can use in the <code>condition</code> section) by prepending the <code>%</code> character to the field names. <em>libsinsp</em> has logic to resolve these fields and create the final output string. What’s nice is that if you become an expert at writing condition filters, you will also have mastered output strings!</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="One More Thing About libsinsp"><div class="sect2" id="one_more_thing_about_libsinsp">
<h2>One More Thing About libsinsp</h2>
<p>By now you can probably see that a lot of Falco’s logic is in <em>libsinsp</em>. That’s deliberate. Falco’s developers recognized the value (and elegance) of its data collection stack and realized it could be the base for many other tools. That’s precisely why <em>libsinsp</em> exists. It sits on top of the powerful Falco collection stack (which includes the drivers, plugins, and <em>libscap</em>) and adds the most important pieces of the Falco logic in a way that makes them reusable. What’s more, <em>libsinsp</em> includes all you need to collect security and forensics data from containers, virtual machines, Linux hosts, and cloud infrastructure. It’s stable, efficient, and well documented.</p>
<p>Several other open source and commercial tools have been built on top of <em>libsinsp</em>. If you would like to write one, or if you are just curious and want to learn more, we recommend you start at the <a href="https://oreil.ly/Cp2Nt"><em>falcosecurity/libs</em> repository</a>.<a contenteditable="false" data-primary="" data-startref="ch03.html6" data-type="indexterm" id="idm45324228085696"/><a contenteditable="false" data-primary="" data-startref="ch03.html5" data-type="indexterm" id="idm45324228084288"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Rule Engine"><div class="sect1" id="rule_engine">
<h1>Rule Engine</h1>
<p><a contenteditable="false" data-primary="rule engine" data-type="indexterm" id="idm45324228080976"/>The Falco rule engine is the component you interact with when you run Falco. Here are some of the things that the rule engine is responsible for:</p>
<ul>
<li><p>Loading Falco rules files</p></li>
<li><p>Parsing the rules in a file</p></li>
<li><p>Applying local customizations (such as appends and overrides) to rules based on local rules files</p></li>
<li><p>Using <em>libsinsp</em> to compile the condition and output of each rule</p></li>
<li><p>Performing the appropriate action, including emitting the output, when a rule triggers</p></li>
</ul>
<p>Thanks to the power of <em>libscap</em> and <em>libsinsp</em>, the rule engine is simple and relatively independent from the rest of the stack.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000002">
<h1>Conclusion</h1>
<p>Now you know what’s inside Falco and how its components relate to each other—you’re well on your way to mastering it! In the next chapters we’ll dive deeper into some of the components and concepts that this chapter introduced.<a contenteditable="false" data-primary="" data-startref="ch03.html0" data-type="indexterm" id="idm45324228010144"/></p>
</div></section>
</div></section></div></body></html>