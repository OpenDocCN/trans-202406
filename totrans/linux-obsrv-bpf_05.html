<html><head></head><body><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Tracing with BPF"><div class="chapter" id="tracing_with_bpf">
<h1><span class="label">Chapter 4. </span>Tracing with BPF</h1>


<p>In software engineering, tracing is a method to collect data for profiling and debugging.<a data-type="indexterm" data-primary="tracing with BPF" id="ix_trcBPF"/> The objective is to provide useful information at runtime for future analysis. The main advantage of using BPF for tracing is that you can access almost any piece of information from the Linux kernel and your applications. BPF adds a minimum amount of overhead to the system’s performance and latency in comparison with other tracing technologies, and it doesn’t require developers to modify their applications for the only purpose of gathering data from them.</p>

<p>The Linux kernel provides several instrumentation capabilities that can be used in conjunction with BPF. In this chapter we talk about these different capabilities. We show you how the kernel exposes those capabilities in your operating system so that you know how to find the information available to your BPF programs.</p>

<p>Tracing’s end goal is to provide you with a deep understanding of any system by taking all of the available data and presenting it to you in a useful way. We’re going to talk about a few different data representations and how you can use them in different <span class="keep-together">scenarios</span>.</p>

<p>Beginning in this chapter, we’re going to use a powerful toolkit to write BPF programs, the BPF Compiler Collection (BCC).<a data-type="indexterm" data-primary="BPF Compiler Collection" data-see="BCC" id="idm46623557550200"/><a data-type="indexterm" data-primary="compilers" data-secondary="BPF Compiler Collection (BCC)" id="idm46623557549224"/><a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" id="idm46623557548312"/> BCC is a set of components that makes building BPF programs more predictable. Even if you master Clang and LLVM, you won’t probably want to spend more time than necessary building the same utilities and ensuring that the BPF verifier doesn’t reject your programs. BCC provides reusable components for common structures, like Perf event maps, and integration with the LLVM backend to provide better debugging options. On top of that, BCC includes bindings for several programming languages; we’re going to use Python in our examples. These bindings allow you to write the user-space part of your BPF programs in a high-level language, which results in more useful programs. We also use BCC in following chapters to make our examples more concise.</p>

<p>The first step to be able to trace programs in the Linux kernel is to identify the extension points that it provides for you to attach BPF programs. Those extension points are commonly called <em>probes</em>.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="probes" id="ix_trcBPFprb"/><a data-type="indexterm" data-primary="probes" id="ix_prbs"/></p>






<section data-type="sect1" data-pdf-bookmark="Probes"><div class="sect1" id="probes-section">
<h1>Probes</h1>

<p>One of the definitions in the English dictionary for the word <em>probe</em> is as follows:</p>
<blockquote>
<p>An unmanned exploratory spacecraft designed to transmit information about its <span class="keep-together">environment</span>.</p></blockquote>

<p>This definition evokes memories of sci-fi movies and epic NASA missions in our minds, and probably in yours too. When we talk about tracing probes, we can use a very similar definition.</p>
<blockquote>
<p>Tracing probes are exploratory programs designed to transmit information about the environment in which they are executed.</p></blockquote>

<p>They collect data in your system and make it available for you to explore and analyze. Traditionally, using probes in Linux involved writing programs that were compiled into kernel modules, which could cause catastrophic problems in production systems. Over the years, they evolved to be safer to execute but still cumbersome to write and test. Tools like SystemTap established new protocols to write probes and paved the way to get much richer information from the Linux kernel and all programs running on user-space.</p>

<p>BPF piggybacks on tracing probes to collect information for debugging and analysis. The safety nature of BPF programs makes them more compelling to use than tools that still rely on recompiling the kernel. Re-compiling the kernel to include external modules can introduce a risk of <a data-type="indexterm" data-primary="kernel" data-secondary="recompiling to include external modules, risks with" id="idm46623557544936"/>crashes due to missbehaving code. The BPF verifier eliminates this risk by analyzing the program before loading in the kernel. The BPF developers took advantage of probe definitions, and modified the kernel to execute BPF programs rather than kernel modules when a code execution finds one of those definitions.</p>

<p>Understanding the different types of probes that you can define is fundamental to exploring what’s happening within your system. In this section, we classify the different probe definitions, how to discover them in your system, and how to attach BPF programs to them.</p>

<p>In this chapter, we cover four different types of probes:</p>
<dl>
<dt>Kernel probes</dt>
<dd>
<p>These give you dynamic access to internal components in the kernel.</p>
</dd>
<dt>Tracepoints</dt>
<dd>
<p>These provide static access to internal components in the kernel.</p>
</dd>
<dt>User-space probes</dt>
<dd>
<p>These give you dynamic access to programs running in user-space.</p>
</dd>
<dt>User statically defined tracepoints</dt>
<dd>
<p>These allow static access to programs running in user-space.</p>
</dd>
</dl>

<p>Let’s begin with kernel probes.<a data-type="indexterm" data-primary="probes" data-secondary="kernel" id="ix_prbsker"/></p>








<section data-type="sect2" data-pdf-bookmark="Kernel Probes"><div class="sect2" id="idm46623557534856">
<h2>Kernel Probes</h2>

<p>Kernel probes allow you to set dynamic flags, or breaks, in almost any kernel instruction with a minimum of overhead.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="probes" data-tertiary="kernel probes" id="ix_trcBPFprbker"/><a data-type="indexterm" data-primary="kernel probes" id="ix_kerprb"/> When the kernel reaches one of these flags, it executes the code attached to the probe, and then resumes its usual routine. Kernel probes can give you information about anything happening in your system, such as files opened in your system and binaries being executed. One important thing to keep in mind about kernel probes is that they don’t have a stable application binary interface (ABI), which means that they might change between kernel versions.<a data-type="indexterm" data-primary="application binary interface (ABI), kernel probes and" id="idm46623557530120"/> The same code might stop working if you try to attach the same probe to two systems with two different kernel versions.</p>

<p>Kernel probes are divided into two categories: <em>kprobes</em> and <em>kretprobes</em>. Their use depends on where in the execution cycle you can insert your BPF program. This section guides you on how to use each one of them to attach BPF programs to those probes and extract information from the kernel.</p>










<section data-type="sect3" data-pdf-bookmark="Kprobes"><div class="sect3" id="idm46623557527592">
<h3>Kprobes</h3>

<p>Kprobes allow you to insert BPF programs before any kernel instruction is executed.<a data-type="indexterm" data-primary="kernel probes" data-secondary="kprobes" id="idm46623557526024"/><a data-type="indexterm" data-primary="probes" data-secondary="kernel" data-tertiary="kprobes" id="idm46623557525048"/> You need to know the function signature that you want to break into, and as we mentioned earlier, this is not a stable ABI, so you’ll want to be careful setting these probes if you’re going to run the same program in different kernel versions. When the kernel execution arrives to the instruction where you set your probe, it sidesteps into your code, runs your BPF program, and returns the execution to the original instruction.</p>

<p>To show you how to use kprobes, we’re going to write a BPF program that prints the name of any binary that’s executed in your system. We’re going to use the Python frontend for the BCC tools in this example,<a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="Python frontend, using" id="idm46623557522648"/><a data-type="indexterm" data-primary="Python" data-secondary="BCC tools frontend" id="idm46623557521608"/> but you can write it with any other BPF tooling:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code><code> </code><code class="nn">bcc</code><code> </code><code class="kn">import</code><code> </code><code class="n">BPF</code><code>
</code><code>
</code><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">int do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) { </code><a class="co" id="co_tracing_with_bpf_CO1-1" href="#callout_tracing_with_bpf_CO1-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  char comm[16];</code><code class="s2">
</code><code class="s2">  bpf_get_current_comm(&amp;comm, sizeof(comm));</code><code class="s2">
</code><code class="s2">  bpf_trace_printk(</code><code class="s2">"</code><code class="s2">executing program: </code><code class="si">%s</code><code class="s2">"</code><code class="s2">, comm);</code><code class="s2">
</code><code class="s2">  return 0;</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO1-2" href="#callout_tracing_with_bpf_CO1-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">execve_function</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf</code><code class="o">.</code><code class="n">get_syscall_fnname</code><code class="p">(</code><code class="s2">"</code><code class="s2">execve</code><code class="s2">"</code><code class="p">)</code><code>		</code><a class="co" id="co_tracing_with_bpf_CO1-3" href="#callout_tracing_with_bpf_CO1-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_kprobe</code><code class="p">(</code><code class="n">event</code><code> </code><code class="o">=</code><code> </code><code class="n">execve_function</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">do_sys_execve</code><code class="s2">"</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO1-4" href="#callout_tracing_with_bpf_CO1-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">trace_print</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO1-1" href="#co_tracing_with_bpf_CO1-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Our BPF program starts. The helper <code>bpf_get_current_comm</code> is going to fetch the current command’s name that the kernel is running and store it in our <code>comm</code> variable.<a data-type="indexterm" data-primary="bpf_get_current_comm function" id="idm46623557216808"/><a data-type="indexterm" data-primary="commands" data-secondary="fetching current command kernel is running" id="idm46623557216104"/> We’ve defined this as a fixed-length array because the kernel has a 16-character limit for command names. After getting the command name, we print it in our debug trace, so the person running the Python script can see all commands captured by BPF.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO1-2" href="#co_tracing_with_bpf_CO1-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Load the BPF program into the kernel.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO1-3" href="#co_tracing_with_bpf_CO1-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Associate the program with the <code>execve</code> syscall.<a data-type="indexterm" data-primary="execve system call" id="idm46623557164808"/> The name of this syscall has changed in different kernel versions, and BCC provides a function to retrieve this name without you having to remember which kernel version you’re running.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO1-4" href="#co_tracing_with_bpf_CO1-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>The code outputs the trace log, so you can see all of the commands that you’re tracing with this program.</p></dd>
</dl>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Kretprobes"><div class="sect3" id="kretprobes">
<h3>Kretprobes</h3>

<p>Kretprobes are going to insert your BPF program when a kernel instruction returns a value after being executed.<a data-type="indexterm" data-primary="kernel probes" data-secondary="kretprobes" id="idm46623557159640"/><a data-type="indexterm" data-primary="probes" data-secondary="kernel" data-tertiary="kretprobes" id="idm46623557158792"/> Usually, you’ll want to combine both kprobes and kretprobes into a single BPF program so that you have a full picture of the instruction’s behavior.</p>

<p>We’re going to use a similar example to the one in the previous section to show you how kretprobes work:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code><code> </code><code class="nn">bcc</code><code> </code><code class="kn">import</code><code> </code><code class="n">BPF</code><code>
</code><code>
</code><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">int ret_sys_execve(struct pt_regs *ctx) {	</code><a class="co" id="co_tracing_with_bpf_CO2-1" href="#callout_tracing_with_bpf_CO2-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  int return_value;</code><code class="s2">
</code><code class="s2">  char comm[16];</code><code class="s2">
</code><code class="s2">  bpf_get_current_comm(&amp;comm, sizeof(comm));</code><code class="s2">
</code><code class="s2">  return_value = PT_REGS_RC(ctx);</code><code class="s2">
</code><code class="s2">
</code><code class="s2">  bpf_trace_printk(</code><code class="s2">"</code><code class="s2">program: </code><code class="si">%s</code><code class="s2">, return: </code><code class="si">%d</code><code class="s2">"</code><code class="s2">, comm, return_value);</code><code class="s2">
</code><code class="s2">  return 0;</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">)</code><code>	   </code><a class="co" id="co_tracing_with_bpf_CO2-2" href="#callout_tracing_with_bpf_CO2-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">execve_function</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf</code><code class="o">.</code><code class="n">get_syscall_fnname</code><code class="p">(</code><code class="s2">"</code><code class="s2">execve</code><code class="s2">"</code><code class="p">)</code><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_kretprobe</code><code class="p">(</code><code class="n">event</code><code> </code><code class="o">=</code><code> </code><code class="n">execve_function</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">ret_sys_execve</code><code class="s2">"</code><code class="p">)</code><code>  </code><a class="co" id="co_tracing_with_bpf_CO2-3" href="#callout_tracing_with_bpf_CO2-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">trace_print</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO2-1" href="#co_tracing_with_bpf_CO2-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Define the function that implements the BPF program. The kernel will execute it immediately after the <code>execve</code> syscall finishes. <code>PT_REGS_RC</code> is a macro that’s going to read the returned value from BPF register for this specific context.<a data-type="indexterm" data-primary="PT_REGS_RC macro" id="idm46623557081032"/><a data-type="indexterm" data-primary="bpf_trace_printk function" id="idm46623557080360"/> We also use <code>bpf_trace_printk</code> to print the command and its returned value in our debug log.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO2-2" href="#co_tracing_with_bpf_CO2-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Initialize the BPF program and load it in the kernel.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO2-3" href="#co_tracing_with_bpf_CO2-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Change the attachment function to <code>attach_kretprobe</code>.</p></dd>
</dl>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46623557073864">
<h5>What’s That Context Argument?</h5>
<p>You might have noticed that both BPF programs have the same first argument in the attached function, identified as <code>ctx</code>. <a data-type="indexterm" data-primary="context (ctx) argument" id="idm46623557027656"/>This parameter (called <code>context</code>) is going to give you access to the information that the kernel is currently processing. Therefore, this context is going to depend on the type of BPF program you’re running at the time. The CPU will store different information about the current task that the kernel is executing. This structure also depends on your system architecture; an ARM processor will include a different set of registers than an x64 processor. You can access those registers without having to worry about the architecture with macros defined by the kernel, like <code>PT_REGS_RC</code>.</p>
</div></aside>

<p>Kernel probes are a powerful way to access the kernel. But as we mentioned earlier, they might be unstable because you’re attaching to dynamic points in the kernel’s source that might change or disappear from one version to another. Now you’ll see a different method to attach programs to the kernel that is safer.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="probes" data-tertiary="kernel probes" data-startref="ix_trcBPFprbker" id="idm46623557024744"/><a data-type="indexterm" data-primary="probes" data-secondary="kernel" data-startref="ix_prbsker" id="idm46623557023416"/><a data-type="indexterm" data-primary="kernel probes" data-startref="ix_kerprb" id="idm46623557022328"/></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Tracepoints"><div class="sect2" id="idm46623557021352">
<h2>Tracepoints</h2>

<p>Tracepoints are static markers in the kernel’s code that you can use to attach code in a running kernel.<a data-type="indexterm" data-primary="probes" data-secondary="tracepoints" id="ix_prbstrcp"/><a data-type="indexterm" data-primary="tracepoints" id="ix_trcpt"/> The main difference with kprobes is that they are codified by the kernel developers when they implement changes in the kernel; that’s why we refer to them as static. Because they are static, the ABI for tracepoints is more stable; the kernel always guarantees that a tracepoint in an old version is going to exist in new versions. However, given that developers need to add them to the kernel, they might not cover all the subsystems that form the kernel.</p>

<p>As we mentioned in <a data-type="xref" href="ch02.html#running_your_first_BPF_programs">Chapter 2</a>, you can see all of the available tracepoints in your system by listing all the files in <em>/sys/kernel/debug/tracing/events</em>.<a data-type="indexterm" data-primary="/sys/kernel/debug/tracing/events_ directory" data-primary-sortas="sys/kernel/debug" id="idm46623557015688"/><a data-type="indexterm" data-primary="BPF" data-secondary="finding tracepoints for" id="idm46623557014840"/> For example, you can find all of the tracepoints for BPF itself by listing the events defined in <em>/sys/kernel/debug/tracing/events/bpf</em>:</p>
<pre>sudo ls -la /sys/kernel/debug/tracing/events/bpf
total 0
drwxr-xr-x  14 root root 0 Feb  4 16:13 .
drwxr-xr-x 106 root root 0 Feb  4 16:14 ..
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_create
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_delete_elem
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_lookup_elem
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_next_key
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_map_update_elem
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_obj_get_map
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_obj_get_prog
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_obj_pin_map
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_obj_pin_prog
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_prog_get_type
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_prog_load
drwxr-xr-x   2 root root 0 Feb  4 16:13 bpf_prog_put_rcu
-rw-r--r--   1 root root 0 Feb  4 16:13 enable
-rw-r--r--   1 root root 0 Feb  4 16:13 filter</pre>

<p>Every subdirectory listed in that output corresponds to a tracepoint that we can attach BPF programs to. But there are two additional files there. The first file, <code>enable</code>, allows you to enable and disable all tracepoints for the BPF subsystem. If the content of the file is 0, the tracepoints are disabled; if the content of the file is 1, the tracepoints are enabled. The <em>filter</em> file allows you to write expressions that the Trace subsystem in the kernel will use to filter events. BPF doesn’t use this file; read more in the kernel’s <a href="https://oreil.ly/miNRd">tracing documentation</a>.</p>

<p>Writing BPF programs to take advantage of tracepoints is similar to tracing with kprobes. Here’s an example that uses a BPF program to trace all of the applications in your system that load other BPF programs:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code><code> </code><code class="nn">bcc</code><code> </code><code class="kn">import</code><code> </code><code class="n">BPF</code><code>
</code><code>
</code><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">int trace_bpf_prog_load(void ctx) {	</code><a class="co" id="co_tracing_with_bpf_CO3-1" href="#callout_tracing_with_bpf_CO3-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  char comm[16];</code><code class="s2">
</code><code class="s2">  bpf_get_current_comm(&amp;comm, sizeof(comm));</code><code class="s2">
</code><code class="s2">
</code><code class="s2">  bpf_trace_printk(</code><code class="s2">"</code><code class="si">%s</code><code class="s2"> is loading a BPF program</code><code class="s2">"</code><code class="s2">, comm);</code><code class="s2">
</code><code class="s2">  return 0;</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">)</code><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_tracepoint</code><code class="p">(</code><code class="n">tp</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">bpf:bpf_prog_load</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>                      </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">trace_bpf_prog_load</code><code class="s2">"</code><code class="p">)</code><code> </code><a class="co" id="co_tracing_with_bpf_CO3-2" href="#callout_tracing_with_bpf_CO3-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">trace_print</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO3-1" href="#co_tracing_with_bpf_CO3-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Declare the function that defines the BPF program. This code must look familiar to you already; there are only a few syntactic changes from the first example you saw when we talked about kprobes.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO3-2" href="#co_tracing_with_bpf_CO3-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>The main difference in this program: instead of attaching the program to a kprobe, we’re attaching it to a tracepoint. BCC follows a convention to name tracepoints; first you specify the subsystem to trace—<code>bpf</code> in this case—followed by a colon, followed by the tracepoint in the subsystem, <code>pbf_prog_load</code>. This means that every time the kernel executes the function <code>bpf_prog_load</code>, this program will receive the event, and it will print the name of the application that’s executing that <code>bpf_prog_load</code> instruction.</p></dd>
</dl>

<p>Kernel probes and tracepoints are going to give you full access to the kernel. We recommend that you to use tracepoints whenever possible, but don’t feel obligated to stick to tracepoints only because they are safer. Take advantage of the dynamic nature of the kernel probes. In the next section we discuss how to get a similar level of visibility in programs running in user-space.<a data-type="indexterm" data-primary="probes" data-secondary="tracepoints" data-startref="ix_prbstrcp" id="idm46623556920984"/><a data-type="indexterm" data-primary="tracepoints" data-startref="ix_trcpt" id="idm46623556919864"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="User-Space Probes"><div class="sect2" id="uprobes">
<h2>User-Space Probes</h2>

<p>User-space probes allow you to set dynamic flags in programs running in user-space.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="probes" data-tertiary="user-space" id="ix_trcBPFprbusr"/><a data-type="indexterm" data-primary="user-space" data-secondary="probes" id="ix_usrprb"/><a data-type="indexterm" data-primary="probes" data-secondary="user-space" id="ix_prbsusr"/> They are the equivalent of kernel-probes for instrumenting programs that run outside the kernel. When you define a uprobe, the kernel creates a trap around the attached instruction. When your application reaches that instruction, the kernel triggers an event that has your probe function as a callback. Uprobes also give you access to any library that your program is linked to, and you can trace those calls if you know the correct name for the instruction.</p>

<p>Much like kernel probes, user-space probes are also divided in two categories, uprobes and uretprobes, depending on where in the execution cycle you can insert your BPF program. Let’s jump right in with some examples.</p>










<section data-type="sect3" data-pdf-bookmark="Uprobes"><div class="sect3" id="uprobes-section">
<h3>Uprobes</h3>

<p>Generally speaking, uprobes are hooks that the kernel inserts into a program’s instruction set before a specific instruction is executed.<a data-type="indexterm" data-primary="probes" data-secondary="user-space" data-tertiary="uprobes" id="idm46623556894312"/><a data-type="indexterm" data-primary="user-space" data-secondary="probes" data-tertiary="uprobes" id="idm46623556893224"/> You need to be careful when you attach uprobes to different versions of the same program because function signatures might change internally between those versions. The only way to guarantee that a BPF program is going to run in two different versions is to ensure that the signature has not changed.<a data-type="indexterm" data-primary="nm command" id="idm46623556891688"/><a data-type="indexterm" data-primary="ELF (Executable and Linkable Format)" data-secondary="listing all symbols in ELF object file" id="idm46623556891080"/> You can use the command <code>nm</code> in Linux to list all the symbols included in an ELF object file, which is a good way to check whether the instruction that you’re tracing still exists in your program, for example:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>
<code class="kn">import</code> <code class="s">"fmt"</code>

<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>
        <code class="nx">fmt</code><code class="p">.</code><code class="nx">Println</code><code class="p">(</code><code class="s">"Hello, BPF"</code><code class="p">)</code>
<code class="p">}</code></pre>

<p>You can compile this Go program by using <code>go build -o hello-bpf main.go</code>. You can use the command <code>nm</code> to get information about all the instruction points that the binary file includes. <code>nm</code> is a program included in the GNU Development Tools that lists symbols from object files. If you filter the symbols with <code>main</code> in their name, you get a list similar to this one:</p>
<pre>nm hello-bpf | grep main
0000000004850b0 T main.init
00000000567f06 B main.initdone.
00000000485040 T main.main
000000004c84a0 R main.statictmp_0
00000000428660 T runtime.main
0000000044da30 T runtime.main.func1
00000000044da80 T runtime.main.func2
000000000054b928 B runtime.main_init_done
00000000004c8180 R runtime.mainPC
0000000000567f1a B runtime.mainStarted</pre>

<p>Now that you have a list of symbols, you can trace when they are executed, even between different processes executing the same binary.</p>

<p>To trace when the main function in our previous Go example is executed, we’re going to write a BPF program, and we’re going to attach it to a uprobe that will break before any process invokes that instruction:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code><code> </code><code class="nn">bcc</code><code> </code><code class="kn">import</code><code> </code><code class="n">BPF</code><code>
</code><code>
</code><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">int trace_go_main(struct pt_regs *ctx) {</code><code class="s2">
</code><code class="s2">  u64 pid = bpf_get_current_pid_tgid();		</code><a class="co" id="co_tracing_with_bpf_CO4-1" href="#callout_tracing_with_bpf_CO4-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  bpf_trace_printk(</code><code class="s2">"</code><code class="s2">New hello-bpf process running with PID: </code><code class="si">%d</code><code class="s2">"</code><code class="s2">, pid);</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">)</code><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_uprobe</code><code class="p">(</code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">hello-bpf</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>    </code><code class="n">sym</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">main.main</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">trace_go_main</code><code class="s2">"</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO4-2" href="#callout_tracing_with_bpf_CO4-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">trace_print</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO4-1" href="#co_tracing_with_bpf_CO4-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Use the function <code>bpf_get_current_pid_tgid</code> to get the process identifier (PID) for the process that’s running our <code>hello-bpf</code> program.<a data-type="indexterm" data-primary="bpf_get_current_pid_tgid function" id="idm46623556767416"/><a data-type="indexterm" data-primary="process identifiers (PIDs)" data-secondary="getting for process running" id="idm46623556766712"/></p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO4-2" href="#co_tracing_with_bpf_CO4-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Attach this program to a uprobe. This call needs to know that the object we want to trace, <code>hello-bpf</code>, is the absolute path to the object file. It also needs the symbol that we’re tracing inside the object, <code>main.main</code> in this case, and the BPF program that we want to run. With this, every time someone runs <code>hello-bpf</code> in our system, we’ll get a new log in our trace pipe.</p></dd>
</dl>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Uretprobes"><div class="sect3" id="idm46623556895816">
<h3>Uretprobes</h3>

<p>Uretprobes are the parallel probe to kretprobes, but for user-space programs.<a data-type="indexterm" data-primary="user-space" data-secondary="probes" data-tertiary="uretprobes" id="idm46623556737464"/><a data-type="indexterm" data-primary="probes" data-secondary="user-space" data-tertiary="uretprobes" id="idm46623556736376"/> They attach BPF programs to instructions that return values, and give you access to those returned values by accessing the registers from your BPF code.</p>

<p>Combining uprobes and uretprobes allows you to write more complex BPF programs. They can give you a more holistic view of applications running in your system. When you can inject tracing code before a function runs and immediately after it completes, you can begin gathering more data and measure application behaviors. A common use case is to measure how long a function takes to execute, without having to change a single line of code in your application.</p>

<p>We’re going to reuse the Go program we wrote in <a data-type="xref" href="#uprobes-section">“Uprobes”</a> to measure how long it takes to execute the main function. This BPF example is longer than the previous examples that you’ve seen, so we’ve divided it into different blocks of code:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">int trace_go_main(struct pt_regs *ctx) {</code><code class="s2">
</code><code class="s2">  u64 pid = bpf_get_current_pid_tgid();</code><code class="s2">
</code><code class="s2">  bpf_trace_printk(</code><code class="s2">"</code><code class="s2">New hello-bpf process running with PID: </code><code class="si">%d</code><code class="s2">"</code><code class="s2">, pid); </code><a class="co" id="co_tracing_with_bpf_CO5-1" href="#callout_tracing_with_bpf_CO5-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">)</code><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_uprobe</code><code class="p">(</code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">hello-bpf</code><code class="s2">"</code><code class="p">,</code><code> 	</code><a class="co" id="co_tracing_with_bpf_CO5-2" href="#callout_tracing_with_bpf_CO5-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="n">sym</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">main.main</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">trace_go_main</code><code class="s2">"</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO5-3" href="#callout_tracing_with_bpf_CO5-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">trace_print</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO5-1" href="#co_tracing_with_bpf_CO5-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Create a BPF hash map. This table allows us to share data between the uprobe and uretprobe functions. In this case we use the application PID as the table key, and we store the function start time as the value. The two most interesting operations in our uprobe function happen as described next.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO5-2" href="#co_tracing_with_bpf_CO5-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Capture the current time in the system in nanoseconds, as seen by the kernel.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO5-3" href="#co_tracing_with_bpf_CO5-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Create an entry in our cache with the program PID and the current time. We can assume that this time is the application’s function start time. Let’s declare our <span class="keep-togethre">uretprobe</span> function now:</p></dd>
</dl>

<p>Implement the function to attach when your instruction finishes. This uretprobe function is similar to others that you saw in <a data-type="xref" href="#kretprobes">“Kretprobes”</a>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf_source</code><code> </code><code class="o">+</code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">static int print_duration(struct pt_regs *ctx) {</code><code class="s2">
</code><code class="s2">  u64 pid = bpf_get_current_pid_tgid();       </code><a class="co" id="co_tracing_with_bpf_CO6-1" href="#callout_tracing_with_bpf_CO6-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  u64 start_time_ns = cache.lookup(&amp;pid);</code><code class="s2">
</code><code class="s2">  if (start_time_ns == 0) {</code><code class="s2">
</code><code class="s2">    return 0;</code><code class="s2">
</code><code class="s2">  }</code><code class="s2">
</code><code class="s2">  u64 duration_ns = bpf_ktime_get_ns() - start_time_ns;</code><code class="s2">
</code><code class="s2">  bpf_trace_printk(</code><code class="s2">"</code><code class="s2">Function call duration: </code><code class="si">%d</code><code class="s2">"</code><code class="s2">, duration_ns);  </code><a class="co" id="co_tracing_with_bpf_CO6-2" href="#callout_tracing_with_bpf_CO6-2"><img src="assets/2.png" alt="2"/></a><code class="s2">
</code><code class="s2">  return 0;     </code><a class="co" id="co_tracing_with_bpf_CO6-3" href="#callout_tracing_with_bpf_CO6-3"><img src="assets/3.png" alt="3"/></a><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO6-1" href="#co_tracing_with_bpf_CO6-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Obtain the PID for our application; we need it to find its starting time. We use the map function <code>lookup</code> to fetch that time from the map where we stored it before the function ran.<a data-type="indexterm" data-primary="process identifiers (PIDs)" data-secondary="obtaining for application" id="idm46623556592648"/></p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO6-2" href="#co_tracing_with_bpf_CO6-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Calculate the function duration by subtracting that time from the current time.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO6-3" href="#co_tracing_with_bpf_CO6-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Print the latency in our trace log so we can display it in the terminal.</p></dd>
</dl>

<p>Now, the rest of the program needs to attach these two BPF functions to the right probes:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf</code> <code class="o">=</code> <code class="n">BPF</code><code class="p">(</code><code class="n">text</code> <code class="o">=</code> <code class="n">bpf_source</code><code class="p">)</code>
<code class="n">bpf</code><code class="o">.</code><code class="n">attach_uprobe</code><code class="p">(</code><code class="n">name</code> <code class="o">=</code> <code class="s2">"hello-bpf"</code><code class="p">,</code> <code class="n">sym</code> <code class="o">=</code> <code class="s2">"main.main"</code><code class="p">,</code>
           <code class="n">fn_name</code> <code class="o">=</code> <code class="s2">"trace_start_time"</code><code class="p">)</code>
<code class="n">bpf</code><code class="o">.</code><code class="n">attach_uretprobe</code><code class="p">(</code><code class="n">name</code> <code class="o">=</code> <code class="s2">"hello-bpf"</code><code class="p">,</code> <code class="n">sym</code> <code class="o">=</code> <code class="s2">"main.main"</code><code class="p">,</code>
           <code class="n">fn_name</code> <code class="o">=</code> <code class="s2">"print_duration"</code><code class="p">)</code>
<code class="n">bpf</code><code class="o">.</code><code class="n">trace_print</code><code class="p">()</code></pre>

<p>We’ve added a line to our original uprobe example where we’re attaching our print function to the uretprobe for our application.</p>

<p>In this section you saw how to trace operations that happen in user-space with BPF. By combining BPF functions that are executed at different points in your application’s lifecycle, you can begin extracting much richer information from it. However, as we mentioned at the beginning of this section, user-space probes are powerful, but they are also unstable. Our BPF examples can stop working only because someone decides to rename an application’s function. Now let’s look at a more stable way to trace user-space programs.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="probes" data-tertiary="user-space" data-startref="ix_trcBPFprbusr" id="idm46623556510840"/><a data-type="indexterm" data-primary="user-space" data-secondary="probes" data-startref="ix_usrprb" id="idm46623556509416"/><a data-type="indexterm" data-primary="probes" data-secondary="user-space" data-startref="ix_prbsusr" id="idm46623556508200"/></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="User Statically Defined Tracepoints"><div class="sect2" id="idm46623556761160">
<h2>User Statically Defined Tracepoints</h2>

<p>User statically defined tracepoints (USDTs) provide static tracepoints for applications in user-space.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="user statically-defined tracepoints (USDTs)" id="ix_trcBPFusdts"/><a data-type="indexterm" data-primary="tracepoints" data-secondary="user statically-defined" id="ix_trcptusr"/><a data-type="indexterm" data-primary="user-space" data-secondary="user statically-defined tracepoints" id="ix_usrtrcpt"/> This is a convenient way to instrument applications because they give you a low-overhead entry point to the tracing capabilities that BPF offers. You can also use them as a convention to trace applications in production, regardless of the programming language with which these applications are written.</p>

<p>USDTs were popularized by DTrace, a tool originally developed at Sun Microsystems for dynamic instrumentation of Unix systems. DTrace was not available in Linux until recently due to licensing issues; however, the Linux kernel developers took a lot of inspiration from the original work in DTrace to implement USDTs.</p>

<p>Much like the static kernel tracepoints you saw earlier, USDTs require developers to instrument their code with instructions that the kernel will use as traps to execute BPF programs. The Hello World version of USDTs is only a few lines of code:</p>

<pre data-type="programlisting" data-code-language="c"> <code class="cp">#include &lt;sys/sdt.h&gt;</code>
 <code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
   <code class="n">DTRACE_PROBE</code><code class="p">(</code><code class="s">"hello-usdt"</code><code class="p">,</code> <code class="s">"probe-main"</code><code class="p">);</code>
 <code class="p">}</code></pre>

<p>In this example, we’re using a macro that Linux provides to define our first USDT. You can already see where the kernel takes inspiration from. <code>DTRACE_PROBE</code> is going to register the tracepoint that the kernel will use to inject our BPF function callback.<a data-type="indexterm" data-primary="DTRACE_PROBE macro" id="idm46623556428728"/> The first argument in this macro is the program that’s reporting the trace. The second one is the name of the trace that we’re reporting.</p>

<p>Many applications that you might have installed in your system use this type of probe to give you access to runtime tracing data in a predictable way. The popular database MySQL, for example, exposes all kinds of information using statically defined tracepoints. You can gather information from queries executed in the server as well as from many other user operations. Node.js, the JavaScript runtime built on top of Chrome’s V8 engine, also provides tracepoints that you can use to extract runtime information.</p>

<p>Before showing you how to attach BPF programs to user-defined tracepoint, we need to talk about discoverability. Because these tracepoints are defined in binary format inside the executable files, we need a way to list the probes defined by a program without having to dig through the source code. One way to extract this information is by reading the ELF binary directly. First, we’re going to compile our previous Hello World USDT example; we can use GCC for that:</p>
<pre>gcc -o hello_usdt hello_usdt.c</pre>

<p>This command is going to generate a binary file called <em>hello_usdt</em> that we can use to start playing with several tools to discover the tracepoints that it defines.<a data-type="indexterm" data-primary="readelf utility" id="idm46623556490280"/><a data-type="indexterm" data-primary="ELF (Executable and Linkable Format)" data-secondary="getting information about binary files with readelf" id="idm46623556489576"/> Linux provides a utility called <code>readelf</code> to show you information about ELF files. You can use it with our compiled example:</p>
<pre>readelf -n ./hello_usdt</pre>

<p>You can see the USDT that we defined in the output of this command:</p>
<pre>Displaying notes found in: .note.stapsdt
  Owner                 Data size        Description
  stapsdt              0x00000033        NT_STAPSDT (SystemTap probe descriptors)
    Provider: "hello-usdt"
    Name: "probe-main"</pre>

<p><code>readelf</code> can give you a lot of information about a binary file; in our small example, it shows only a few lines of information, but its output becomes cumbersome to parse for more complicated binaries.</p>

<p>A better option to discover the tracepoints defined in a binary file is to use BCC’s <code>tplist</code> tool, which can display both kernel tracepoints and USDTs.<a data-type="indexterm" data-primary="tplist tool" id="idm46623556480344"/><a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="tplist tool" id="idm46623556479640"/> The advantage of this tool is the simplicity of its output; it shows you only tracepoint definitions, without any additional information about the executable. Its usage is similar to <span class="keep-together"><code>readelf</code></span>:</p>
<pre> tplist -l ./hello_usdt</pre>

<p>It lists every tracepoint that you define in individual lines. In our example, it displays only a single line with our <code>probe-main</code> definition:</p>
<pre> ./hello_usdt "hello-usdt":"probe-main"</pre>

<p>After you know the supported tracepoints in your binary, you can attach BPF programs to them in a similar way to what you’ve seen in previous examples:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code><code> </code><code class="nn">bcc</code><code> </code><code class="kn">import</code><code> </code><code class="n">BPF</code><code class="p">,</code><code> </code><code class="n">USDT</code><code>
</code><code>
</code><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">#include &lt;uapi/linux/ptrace.h&gt;</code><code class="s2">
</code><code class="s2">int trace_binary_exec(struct pt_regs *ctx) {</code><code class="s2">
</code><code class="s2">  u64 pid = bpf_get_current_pid_tgid();</code><code class="s2">
</code><code class="s2">  bpf_trace_printk(</code><code class="s2">"</code><code class="s2">New hello_usdt process running with PID: </code><code class="si">%d</code><code class="s2">"</code><code class="s2">, pid);</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">usdt</code><code> </code><code class="o">=</code><code> </code><code class="n">USDT</code><code class="p">(</code><code class="n">path</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">./hello_usdt</code><code class="s2">"</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO7-1" href="#callout_tracing_with_bpf_CO7-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="n">usdt</code><code class="o">.</code><code class="n">enable_probe</code><code class="p">(</code><code class="n">probe</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">probe-main</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">trace_binary_exec</code><code class="s2">"</code><code class="p">)</code><code>     </code><a class="co" id="co_tracing_with_bpf_CO7-2" href="#callout_tracing_with_bpf_CO7-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">,</code><code> </code><code class="n">usdt</code><code> </code><code class="o">=</code><code> </code><code class="n">usdt</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO7-3" href="#callout_tracing_with_bpf_CO7-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">trace_print</code><code class="p">(</code><code class="p">)</code></pre>

<p>There is a major change in this example that requires some explanation.</p>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO7-1" href="#co_tracing_with_bpf_CO7-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Create a USDT object; we haven’t done this in our previous examples. USDTs are not part of BPF, in the sense that you can use them without having to interact with the BPF VM. Because they are independent of one another, it makes sense that their usage is independent of the BPF code.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO7-2" href="#co_tracing_with_bpf_CO7-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Attach the BPF function to trace program executions to the probe in our <span class="keep-together">application</span>.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO7-3" href="#co_tracing_with_bpf_CO7-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Initialize our BPF environment with the tracepoint definition that we just created. This will inform BCC that it needs to generate the code to connect our BPF program with the probe definition in our binary file. When both of them are connected, we can print the traces generated by our BPF program to discover new executions of our binary example.</p></dd>
</dl>










<section data-type="sect3" data-pdf-bookmark="USDTs bindings for other languages"><div class="sect3" id="idm46623556311256">
<h3>USDTs bindings for other languages</h3>

<p>You can also use USDTs to trace applications written with programming languages besides C.<a data-type="indexterm" data-primary="tracepoints" data-secondary="user statically-defined" data-tertiary="for languages other than C" id="idm46623556280824"/><a data-type="indexterm" data-primary="user-space" data-secondary="user statically-defined tracepoints" data-tertiary="for languages other than C" id="idm46623556279736"/> You’ll be able to find bindings for Python, Ruby, Go, Node.js, and many other languages in GitHub.<a data-type="indexterm" data-primary="Ruby, USDT bindings for" id="idm46623556278408"/> The Ruby bindings are one of our favorites because of their simplicity and interoperability with frameworks such as Rails.<a data-type="indexterm" data-primary="Hamel, Dale" id="idm46623556277528"/> Dale Hamel, who currently works at Shopify, wrote an excellent report about the usage of USDTs in his <a href="https://oreil.ly/7pgNO">blog</a>. He also maintains a library called <a href="https://oreil.ly/ge6cu"><em>ruby-static-tracing</em></a> that makes tracing Ruby and Rails applications even more straightforward.</p>

<p>Hamel’s static tracing library allows you to inject tracing capabilities at the class level without requiring you to add the tracing logic to every method in that class. In complex scenarios, it also gives you convenient methods to register dedicated tracing endpoints yourself.</p>

<p>To use <code>ruby-static-tracing</code> in your applications, first you need to configure when the tracepoints are going to be enabled. You can turn them on by default when the application starts, but if you want to avoid the overhead of collecting data all the time, you can activate them using a syscall signal. Hamel recommends using <code>PROF</code> as this signal:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="nb">require</code> <code class="s1">'ruby-static-tracing'</code>

<code class="no">StaticTracing</code><code class="o">.</code><code class="n">configure</code> <code class="k">do</code> <code class="o">|</code><code class="n">config</code><code class="o">|</code>
  <code class="n">config</code><code class="o">.</code><code class="n">mode</code> <code class="o">=</code> <code class="ss">StaticTracing</code><code class="p">:</code><code class="ss">:Configuration</code><code class="o">::</code><code class="ss">Modes</code><code class="p">:</code><code class="ss">:SIGNAL</code>
  <code class="n">config</code><code class="o">.</code><code class="n">signal</code> <code class="o">=</code> <code class="ss">StaticTracing</code><code class="p">:</code><code class="ss">:Configuration</code><code class="o">::</code><code class="ss">Modes</code><code class="p">:</code><code class="ss">:SIGNALS</code><code class="o">::</code><code class="no">SIGPROF</code>
<code class="k">end</code></pre>

<p>With this configuration in place, you can use the <code>kill</code> command to enable your application’s static tracepoints on demand.<a data-type="indexterm" data-primary="kill command" data-secondary="using to enable application's static tracepoints" id="idm46623556197384"/><a data-type="indexterm" data-primary="process identifiers (PIDs)" data-secondary="getting with pgrep" id="idm46623556196376"/><a data-type="indexterm" data-primary="pgrep utility" id="idm46623556195464"/> In the next example, we assume that there is only a Ruby process running on our machine, and we can get its process identifier using <code>pgrep</code>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nb">kill</code> -SIGPROF <code class="sb">`</code>pgrep -nx ruby<code class="sb">`</code></pre>

<p>Besides configuring when the tracepoints are active, you might want to use some of the built-in tracing mechanisms that <em>ruby-static-tracing</em> provides. At the time of writing this, the library incorporates tracepoints to measure latency and to collect stack traces. We really like how a tedious task such as measuring function latency becomes almost trivial by using this built-in module. First, you need to add the latency tracer to your initial configuration:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="nb">require</code> <code class="s1">'ruby-static-tracing'</code>
<code class="nb">require</code> <code class="s1">'ruby-static-tracing/tracer/concerns/latency_tracer'</code>

<code class="no">StaticTracing</code><code class="o">.</code><code class="n">configure</code> <code class="k">do</code> <code class="o">|</code><code class="n">config</code><code class="o">|</code>
  <code class="n">config</code><code class="o">.</code><code class="n">add_tracer</code><code class="p">(</code><code class="ss">StaticTracing</code><code class="p">:</code><code class="ss">:Tracer</code><code class="o">::</code><code class="no">Latency</code><code class="p">)</code>
<code class="k">end</code></pre>

<p>After that, every class that includes the latency module generates static tracepoints for each public method defined. When tracing is enabled, you can query those tracepoints to collect timing data. In our next example, <code>ruby-static-tracing</code> generates a static tracepoint named <code>usdt:/proc/X/fd/Y:user_model:find</code>, following the convention of using the class name as the namespace for the tracepoint and using the method name as the tracepoint name:</p>

<pre data-type="programlisting" data-code-language="ruby"><code class="k">class</code> <code class="nc">UserModel</code>
  <code class="k">def</code> <code class="nf">find</code><code class="p">(</code><code class="nb">id</code><code class="p">)</code>
  <code class="k">end</code>

  <code class="kp">include</code> <code class="ss">StaticTracing</code><code class="p">:</code><code class="ss">:Tracer</code><code class="o">::</code><code class="ss">Concerns</code><code class="p">:</code><code class="ss">:Latency</code>
<code class="k">end</code></pre>

<p>Now we can use BCC to extract the latency information for each call to our <code>find</code> method. To do that, we use BCC’s built-in functions <code>bpf_usdt_readarg</code> and <code>bpf_usdt_readarg_p</code>. These functions read the arguments set each time our application’s code is executed. <code>ruby-static-tracing</code> always sets the method name as the first argument for the tracepoint, whereas it sets the calculated value as the second argument. The next snippet implements the BPF program that gets the tracepoint information and prints it in the tracing log:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf_source</code> <code class="o">=</code> <code class="s2">"""</code>
<code class="s2">#include &lt;uapi/linux/ptrace.h&gt;</code>
<code class="s2">int trace_latency(struct pt_regs *ctx) {</code>
<code class="s2">  char method[64];</code>
<code class="s2">  u64 latency;</code>

<code class="s2">  bpf_usdt_readarg_p(1, ctx, &amp;method, sizeof(method));</code>
<code class="s2">  bpf_usdt_readarg(2, ctx, &amp;latency);</code>

<code class="s2">  bpf_trace_printk("method </code><code class="si">%s</code><code class="s2"> took </code><code class="si">%d</code><code class="s2"> ms", method, latency);</code>
<code class="s2">}</code>
<code class="s2">"""</code></pre>

<p>We also need to load the previous BPF program into the kernel. Because we’re tracing a specific application that’s already running in our machine, we can attach the program to the specific process identifier:<a data-type="indexterm" data-primary="process identifiers (PIDs)" data-secondary="attaching program to" id="idm46623556066328"/></p>

<pre data-type="programlisting" data-code-language="python"><code class="n">parser</code><code> </code><code class="o">=</code><code> </code><code class="n">argparse</code><code class="o">.</code><code class="n">ArgumentParser</code><code class="p">(</code><code class="p">)</code><code>
</code><code class="n">parser</code><code class="o">.</code><code class="n">add_argument</code><code class="p">(</code><code class="s2">"</code><code class="s2">-p</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">--pid</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="nb">type</code><code> </code><code class="o">=</code><code> </code><code class="nb">int</code><code class="p">,</code><code> </code><code class="n">help</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Process ID</code><code class="s2">"</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO8-1" href="#callout_tracing_with_bpf_CO8-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="n">args</code><code> </code><code class="o">=</code><code> </code><code class="n">parser</code><code class="o">.</code><code class="n">parse_args</code><code class="p">(</code><code class="p">)</code><code>
</code><code>
</code><code class="n">usdt</code><code> </code><code class="o">=</code><code> </code><code class="n">USDT</code><code class="p">(</code><code class="n">pid</code><code> </code><code class="o">=</code><code> </code><code class="nb">int</code><code class="p">(</code><code class="n">args</code><code class="o">.</code><code class="n">pid</code><code class="p">)</code><code class="p">)</code><code>
</code><code class="n">usdt</code><code class="o">.</code><code class="n">enable_probe</code><code class="p">(</code><code class="n">probe</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">latency</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">trace_latency</code><code class="s2">"</code><code class="p">)</code><code>		</code><a class="co" id="co_tracing_with_bpf_CO8-2" href="#callout_tracing_with_bpf_CO8-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">,</code><code> </code><code class="n">usdt</code><code> </code><code class="o">=</code><code> </code><code class="n">usdt</code><code class="p">)</code><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">trace_print</code><code class="p">(</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO8-1" href="#co_tracing_with_bpf_CO8-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Specify that PID.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO8-2" href="#co_tracing_with_bpf_CO8-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Enable the probe, load the program into the kernel, and print the tracing log. (This section is very similar to the one you saw earlier.)</p></dd>
</dl>

<p>In this section, we’ve shown you how to introspect applications that define tracepoints statically. Many well-known libraries and programing languages include these probes to help you debug running applications, gaining more visibility when they run in production environments. This is only the tip of the iceberg; after you have the data, you need to make sense of it. This is what we explore next.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="user statically-defined tracepoints (USDTs)" data-startref="ix_trcBPFusdts" id="idm46623555919896"/><a data-type="indexterm" data-primary="user-space" data-secondary="user statically-defined tracepoints" data-startref="ix_usrtrcpt" id="idm46623555918680"/><a data-type="indexterm" data-primary="tracepoints" data-secondary="user statically-defined" data-startref="ix_trcptusr" id="idm46623555917496"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="probes" data-startref="ix_trcBPFprb" id="idm46623555916280"/><a data-type="indexterm" data-primary="probes" data-startref="ix_prbs" id="idm46623555915064"/></p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Visualizing Tracing Data"><div class="sect1" id="idm46623557976344">
<h1>Visualizing Tracing Data</h1>

<p>So far, we’ve shown examples that print data in our debug output. This is not very useful in production environments.<a data-type="indexterm" data-primary="visualizing tracing data" id="ix_vistrc"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="visualizing tracing data" id="ix_trcBPFvis"/> You want to make sense of that data, but nobody likes to make sense of long and complicated logs. If we want to monitor changes in latency and CPU utilization, it’s easier to do it by looking at graphs over a time period than aggregating numbers from a file stream.</p>

<p>This section explores different ways to present BPF tracing data. On one hand, we’ll show you how BPF programs can structure information in aggregates for you. On the other hand, you’ll learn how to export that information in a portable representation and use off-the-shelf tools to access a richer representation and share your findings with other people.</p>








<section data-type="sect2" data-pdf-bookmark="Flame Graphs"><div class="sect2" id="idm46623555867896">
<h2>Flame Graphs</h2>

<p><em>Flame graphs</em> are diagrams that help you visualize how your system is spending time.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="visualizing tracing data" data-tertiary="using flame graphs" id="ix_trcBPFvisflgr"/><a data-type="indexterm" data-primary="visualizing tracing data" data-secondary="using flame graphs" id="ix_vgristrcflm"/><a data-type="indexterm" data-primary="flame graphs" id="ix_flmgr"/> They can give you a clear representation of which code in an application is executed more often.<a data-type="indexterm" data-primary="Gregg, Brendan" id="idm46623555861960"/> Brendan Gregg, the creator of flame graphs, maintains a set of scripts to easily generate these visualization formats <a href="https://oreil.ly/3iiZx">on GitHub</a>. We use those scripts to generate flame graphs from data collected with BPF later in this section. You can see what these graphs look like in <a data-type="xref" href="#flamegraph">Figure 4-1</a>.</p>

<figure><div id="flamegraph" class="figure">
<img src="assets/lbpf_0401.png" alt="Flame graph visualization"/>
<h6><span class="label">Figure 4-1. </span>A CPU flame graph</h6>
</div></figure>

<p>There are two important things to remember about what a flame graph shows:</p>

<ul>
<li>
<p>The x-axis is ordered alphabetically. The width of each stack represents how often it appears in the collect data, which can be correlated to how often that code path has been visited while the profiler was enabled.</p>
</li>
<li>
<p>The y-axis shows the stack traces ordered as the profiler reads them, preserving the trace hierarchy.</p>
</li>
</ul>

<p>The most well-known flame graphs represent the most frequent code consuming CPU in your system; these are called <em>on-CPU graphs</em>.<a data-type="indexterm" data-primary="on-CPU and off-CPU graphs" id="idm46623555854424"/><a data-type="indexterm" data-primary="CPUs" data-secondary="on-CPU and off-CPU flame graphs" id="idm46623555853816"/> Another interesting flame graph visualization is <em>off-CPU graphs</em>; they represent the time that a CPU spends on other tasks that are not related to your application. By combining on-CPU and off-CPU graphs, you can get a complete view of what your system is spending CPU cycles on.</p>

<p>Both, on-CPU and off-CPU graphs use stack traces to indicate where the system is spending time. Some programming languages, such as Go, always include trace information in their binaries, but others, such as C++ and Java, require some extra work to make stack traces readable. After your application includes stack trace information, BPF programs can use it to aggregate the most frequent code paths as seen by the <span class="keep-together">kernel</span>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are advantages and disadvantages<a data-type="indexterm" data-primary="kernel" data-secondary="stack trace aggregation in" id="idm46623555849912"/> to stack trace aggregation in the kernel. On one hand, it’s an efficient way to count stack trace frequency because it happens in the kernel, avoiding sending every stack information to user-space and reducing the data interchange between the kernel and user-space. On the other hand, the number of events to process for off-CPU graphs can be significantly high, because you’re keeping track of every event that occurs during your application’s context switch. This can create significant overhead in your system if you try to profile it for too long. Keep this in mind when you’re working with flame graphs.</p>
</div>

<p>BCC provides several utilities to help you aggregate and visualize stack traces, but the main<a data-type="indexterm" data-primary="BPF_STACK_TRACE macro" id="idm46623555847448"/> one is the macro <code>BPF_STACK_TRACE</code>. This macro generates a BPF map of type <code>BPF_MAP_TYPE_STACK_TRACE</code> to store the stacks that your BPF program accumulates.<a data-type="indexterm" data-primary="stack trace maps" id="idm46623555845944"/><a data-type="indexterm" data-primary="BPF_MAP_TYPE_STACK_TRACE type" id="idm46623555845336"/><a data-type="indexterm" data-primary="maps (BPF)" data-secondary="stack trace map" id="idm46623555844728"/> On top of that, this BPF map is enhanced with methods to extract the stack information from the program’s context and walk the stack traces accumulated when you want to use them after aggregating them.</p>

<p>In the next example, we<a data-type="indexterm" data-primary="profiler (BPF) for stack traces from user-space applications" data-secondary="implementing" id="idm46623555843272"/> build a simple BPF profiler that prints the stack traces collected from user-space applications. We generate on-CPU flame graphs with the traces that our profiler collects. To test this profiler, we’re going to write a minimal Go program that generates CPU load. This is the code for that minimal application:</p>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>

<code class="kn">import</code> <code class="s">"time"</code>

<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>
	<code class="nx">j</code> <code class="o">:=</code> <code class="mi">3</code>
	<code class="k">for</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Since</code><code class="p">(</code><code class="nx">time</code><code class="p">.</code><code class="nx">Now</code><code class="p">())</code> <code class="p">&lt;</code> <code class="nx">time</code><code class="p">.</code><code class="nx">Second</code> <code class="p">{</code>
		<code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="p">&lt;</code> <code class="mi">1000000</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>
			<code class="nx">j</code> <code class="o">*=</code> <code class="nx">i</code>
		<code class="p">}</code>
	<code class="p">}</code>
<code class="p">}</code></pre>

<p>If you save this code in a file called <em>main.go</em> and run it with <code>go run main.go</code>, you’ll see that your system’s CPU utilization increases significantly. You can stop the execution by pressing Ctrl-C on your keyboard, and the CPU utilization will go back to normal.</p>

<p>The first part of our BPF program is going to initialize the profiler structures:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">#include &lt;uapi/linux/ptrace.h&gt;</code><code class="s2">
</code><code class="s2">#include &lt;uapi/linux/bpf_perf_event.h&gt;</code><code class="s2">
</code><code class="s2">#include &lt;linux/sched.h&gt;</code><code class="s2">
</code><code class="s2">
</code><code class="s2">struct trace_t { 	</code><a class="co" id="co_tracing_with_bpf_CO9-1" href="#callout_tracing_with_bpf_CO9-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  int stack_id;</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">
</code><code class="s2">BPF_HASH(cache, struct trace_t);	</code><a class="co" id="co_tracing_with_bpf_CO9-2" href="#callout_tracing_with_bpf_CO9-2"><img src="assets/2.png" alt="2"/></a><code class="s2">
</code><code class="s2">BPF_STACK_TRACE(traces, 10000);		</code><a class="co" id="co_tracing_with_bpf_CO9-3" href="#callout_tracing_with_bpf_CO9-3"><img src="assets/3.png" alt="3"/></a><code class="s2">
</code><code class="s2">"""</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO9-1" href="#co_tracing_with_bpf_CO9-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Initialize a structure that will store the reference identifier for each one of the stack frames that our profiler receives. We use these identifiers later to find out which code path was being executed at that time.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO9-2" href="#co_tracing_with_bpf_CO9-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Initialize a BPF hash map that we use to aggregate how often we see the same strack frame. The flame graph scripts use this aggregated value to determine how frequent the same code is executed.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO9-3" href="#co_tracing_with_bpf_CO9-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Initialize our BPF stack trace map. We’re setting a maximum size for this map, but it can vary depending on how much data you want to process. It would be better to have this value as a variable, but we know that our Go application is not very big, so 10,000 elements is plenty.</p></dd>
</dl>

<p>Next, we<a data-type="indexterm" data-primary="collect_stack_traces function" id="idm46623555762680"/> implement the function that aggregates stack traces in our <span class="keep-together">profiler</span>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf_source</code><code> </code><code class="o">+</code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">int collect_stack_traces(struct bpf_perf_event_data *ctx) {</code><code class="s2">
</code><code class="s2">  u32 pid = bpf_get_current_pid_tgid() &gt;&gt; 32;		</code><a class="co" id="co_tracing_with_bpf_CO10-1" href="#callout_tracing_with_bpf_CO10-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  if (pid != PROGRAM_PID)</code><code class="s2">
</code><code class="s2">    return 0;</code><code class="s2">
</code><code class="s2">
</code><code class="s2">  struct trace_t trace = {	</code><a class="co" id="co_tracing_with_bpf_CO10-2" href="#callout_tracing_with_bpf_CO10-2"><img src="assets/2.png" alt="2"/></a><code class="s2">
</code><code class="s2">    .stack_id = traces.get_stackid(&amp;ctx-&gt;regs, BPF_F_USER_STACK)</code><code class="s2">
</code><code class="s2">  };</code><code class="s2">
</code><code class="s2">
</code><code class="s2">  cache.increment(trace);	</code><a class="co" id="co_tracing_with_bpf_CO10-3" href="#callout_tracing_with_bpf_CO10-3"><img src="assets/3.png" alt="3"/></a><code class="s2">
</code><code class="s2">  return 0;</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO10-1" href="#co_tracing_with_bpf_CO10-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Verify that the process ID for the program in the current BPF context is the one for our Go application; otherwise, we ignore the event. We have not defined the value for <code>PROGRAM_PID</code> at the moment.<a data-type="indexterm" data-primary="process identifiers (PIDs)" data-secondary="PROGRAM_PID" id="idm46623555665672"/> Let’s replace this string in the Python part of the profiler before initializing the BPF program. This is a current limitation in the way BCC initializes BPF program; we cannot pass any variables from <span class="keep-togethre">user-space</span>, and as a common practice, these strings are replaced in the code before initialization.<a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="initialization of BPF programs, limitation of" id="idm46623555663576"/></p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO10-2" href="#co_tracing_with_bpf_CO10-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Create a trace to aggregate its usage. We fetch the stack ID from the program’s context with <a data-type="indexterm" data-primary="get_stackid function" id="idm46623555660152"/>the built-in function <code>get_stackid</code>. This is one of the helpers that BCC adds to our stack trace map. We use the flag <code>BPF_F_USER_STACK</code> to indicate <a data-type="indexterm" data-primary="BPF_F_USER_STACK flag" id="idm46623555628728"/>that we want to get the stack ID for the user-space application, and we don’t care about what happens inside the kernel.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO10-3" href="#co_tracing_with_bpf_CO10-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Increment the counter for our trace to keep track of how often the same code is being exercised.</p></dd>
</dl>

<p>Next, we’re going to attach our <a data-type="indexterm" data-primary="Perf events" data-secondary="attaching stack trace collector to" id="idm46623555624808"/>stack trace collector to all Perf events in the kernel:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">program_pid</code><code> </code><code class="o">=</code><code> </code><code class="nb">int</code><code class="p">(</code><code class="n">sys</code><code class="o">.</code><code class="n">argv</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="p">)</code><code>		</code><a class="co" id="co_tracing_with_bpf_CO11-1" href="#callout_tracing_with_bpf_CO11-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="o">.</code><code class="n">replace</code><code class="p">(</code><code class="s1">'</code><code class="s1">PROGRAM_PID</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="n">program_pid</code><code class="p">)</code><code> </code><a class="co" id="co_tracing_with_bpf_CO11-2" href="#callout_tracing_with_bpf_CO11-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">)</code><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_perf_event</code><code class="p">(</code><code class="n">ev_type</code><code> </code><code class="o">=</code><code> </code><code class="n">PerfType</code><code class="o">.</code><code class="n">SOFTWARE</code><code class="p">,</code><code>          </code><a class="co" id="co_tracing_with_bpf_CO11-3" href="#callout_tracing_with_bpf_CO11-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>                      </code><code class="n">ev_config</code><code> </code><code class="o">=</code><code> </code><code class="n">PerfSWConfig</code><code class="o">.</code><code class="n">CPU_CLOCK</code><code class="p">,</code><code>
</code><code>                      </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'</code><code class="s1">collect_stack_traces</code><code class="s1">'</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO11-1" href="#co_tracing_with_bpf_CO11-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>The first argument for our Python program. This is the process identifier for the Go application that we’re profiling.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO11-2" href="#co_tracing_with_bpf_CO11-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Use Python’s built-in <code>replace</code> function to swap the string <code>PROGRAM_ID</code> in our BPF source with the argument provided to the profiler.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO11-3" href="#co_tracing_with_bpf_CO11-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Attach the BPF program to all Software Perf events, this will ignore any other events, like Hardware events. We’re also configuring our BPF program to use the CPU clock as time source so we can measure execution time.</p></dd>
</dl>

<p>Finally, we need to implement the code that will dump the stack traces in our standard <a data-type="indexterm" data-primary="Python" data-secondary="program to dump stack traces to stdout" id="idm46623555549032"/>output when the profiler is interrupted:</p>

<pre data-type="programlisting" data-code-language="python"><code class="k">try</code><code class="p">:</code><code>
</code><code>  </code><code class="n">sleep</code><code class="p">(</code><code class="mi">99999999</code><code class="p">)</code><code>
</code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>
</code><code>  </code><code class="n">signal</code><code class="o">.</code><code class="n">signal</code><code class="p">(</code><code class="n">signal</code><code class="o">.</code><code class="n">SIGINT</code><code class="p">,</code><code> </code><code class="n">signal_ignore</code><code class="p">)</code><code>
</code><code>
</code><code class="k">for</code><code> </code><code class="n">trace</code><code class="p">,</code><code> </code><code class="n">acc</code><code> </code><code class="ow">in</code><code> </code><code class="nb">sorted</code><code class="p">(</code><code class="n">cache</code><code class="o">.</code><code class="n">items</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="n">key</code><code class="o">=</code><code class="k">lambda</code><code> </code><code class="n">cache</code><code class="p">:</code><code> </code><code class="n">cache</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="o">.</code><code class="n">value</code><code class="p">)</code><code class="p">:</code><code>   </code><a class="co" id="co_tracing_with_bpf_CO12-1" href="#callout_tracing_with_bpf_CO12-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>  </code><code class="n">line</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="p">]</code><code>
</code><code>  </code><code class="k">if</code><code> </code><code class="n">trace</code><code class="o">.</code><code class="n">stack_id</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">0</code><code> </code><code class="ow">and</code><code> </code><code class="n">trace</code><code class="o">.</code><code class="n">stack_id</code><code> </code><code class="o">==</code><code> </code><code class="o">-</code><code class="n">errno</code><code class="o">.</code><code class="n">EFAULT</code><code>		     </code><a class="co" id="co_tracing_with_bpf_CO12-2" href="#callout_tracing_with_bpf_CO12-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>    </code><code class="n">line</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="s1">'</code><code class="s1">Unknown stack</code><code class="s1">'</code><code class="p">]</code><code>
</code><code>  </code><code class="k">else</code><code>
</code><code>    </code><code class="n">stack_trace</code><code> </code><code class="o">=</code><code> </code><code class="nb">list</code><code class="p">(</code><code class="n">traces</code><code class="o">.</code><code class="n">walk</code><code class="p">(</code><code class="n">trace</code><code class="o">.</code><code class="n">stack_id</code><code class="p">)</code><code class="p">)</code><code>
</code><code>    </code><code class="k">for</code><code> </code><code class="n">stack_address</code><code> </code><code class="ow">in</code><code> </code><code class="nb">reversed</code><code class="p">(</code><code class="n">stack_trace</code><code class="p">)</code><code>			             </code><a class="co" id="co_tracing_with_bpf_CO12-3" href="#callout_tracing_with_bpf_CO12-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>      </code><code class="n">line</code><code class="o">.</code><code class="n">extend</code><code class="p">(</code><code class="n">bpf</code><code class="o">.</code><code class="n">sym</code><code class="p">(</code><code class="n">stack_address</code><code class="p">,</code><code> </code><code class="n">program_pid</code><code class="p">)</code><code class="p">)</code><code>		     	</code><a class="co" id="co_tracing_with_bpf_CO12-4" href="#callout_tracing_with_bpf_CO12-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code>
</code><code>  </code><code class="n">frame</code><code> </code><code class="o">=</code><code> </code><code class="s-Affix">b</code><code class="s2">"</code><code class="s2">;</code><code class="s2">"</code><code class="o">.</code><code class="n">join</code><code class="p">(</code><code class="n">line</code><code class="p">)</code><code class="o">.</code><code class="n">decode</code><code class="p">(</code><code class="s1">'</code><code class="s1">utf-8</code><code class="s1">'</code><code class="p">,</code><code> </code><code class="s1">'</code><code class="s1">replace</code><code class="s1">'</code><code class="p">)</code><code>		     	</code><a class="co" id="co_tracing_with_bpf_CO12-5" href="#callout_tracing_with_bpf_CO12-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code>  </code><code class="k">print</code><code class="p">(</code><code class="s2">"</code><code class="si">%s</code><code class="s2"> </code><code class="si">%d</code><code class="s2">"</code><code> </code><code class="o">%</code><code> </code><code class="p">(</code><code class="n">frame</code><code class="p">,</code><code> </code><code class="n">acc</code><code class="o">.</code><code class="n">value</code><code class="p">)</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO12-1" href="#co_tracing_with_bpf_CO12-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Iterate over all the traces we collected so that we can print them in order.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO12-2" href="#co_tracing_with_bpf_CO12-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Validate that we got stack identifiers that we can correlate with specific lines of code later. If we get an invalid value, we’ll use a placeholder in our flame graph.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO12-3" href="#co_tracing_with_bpf_CO12-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Iterate over all the entries in the stack trace in reverse order. We do this because we want to see the first most recently executed code path at the top, like you’d expect in any stack trace.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO12-4" href="#co_tracing_with_bpf_CO12-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>Use the BCC helper <code>sym</code> to translate the memory address for the stack frame into a function name in our source code.<a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="sym helper" id="idm46623555337928"/><a data-type="indexterm" data-primary="sym helper function" id="idm46623555336984"/></p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO12-5" href="#co_tracing_with_bpf_CO12-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>Format the stack trace line separated by semicolons. This is the format that the flame graph scripts expect later to be able to generate our visualization.</p></dd>
</dl>

<p>With our BPF profiler complete, we can run it as <code>sudo</code> to collect stack traces for our busy Go program. We need to pass the Go program’s process ID to our profiler to make sure that we collect only traces for this application; we can find that PID using <code>pgrep</code>.<a data-type="indexterm" data-primary="sudo command" data-secondary="running BPF stack trace profiler" id="idm46623555252328"/><a data-type="indexterm" data-primary="profiler (BPF) for stack traces from user-space applications" data-secondary="running" id="idm46623555251480"/> This is how you run the profiler if you save it in a file called <em>profiler.py</em>:</p>

<pre data-type="programlisting" data-code-language="bash">./profiler.py <code class="sb">`</code>pgrep -nx go<code class="sb">`</code> &gt; /tmp/profile.out</pre>

<p><code>pgrep</code> will search the PID for a process running on your system whose name matches <code>go</code>. We send our profiler’s output to a temporary file so that we can generate the flame graph visualization.<a data-type="indexterm" data-primary="pgrep utility" id="idm46623555249736"/></p>

<p>As we mentioned earlier, <a data-type="indexterm" data-primary="Gregg, Brendan" data-secondary="FlameGraph scripts" id="idm46623555248680"/>we’re going to use Brendan Gregg’s FlameGraph scripts to generate an SVG file for our graph; you can find those scripts in his <a href="https://oreil.ly/orqcb">GitHub repository</a>. After you’ve downloaded that repository, you can use <code>flamegraph.pl</code> to generate the graph. You can open the graph with your favorite browser; we’re using Firefox in this example:</p>
<pre>./flamegraph.pl /tmp/profile.out &gt; /tmp/flamegraph.svg &amp;&amp; \
  firefox /tmp/flamefraph.svg</pre>

<p>This kind of profiler is useful for tracing performance issues in your system. BCC already includes a more advanced profiler than the one in our example that you can use in your production environments directly. <a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="profiler and visualization tools" id="idm46623555243848"/>Besides the profiler, BCC includes tools to help you generate off-CPU flame graphs and many other visualizations to analyze systems.</p>

<p>Flame graphs are useful for performance analysis. We use them frequently in our day-to-day work. In many scenarios, besides visualizing hot code paths, you’ll want to measure how often events in your systems occur. We focus on that next.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="visualizing tracing data" data-tertiary="using flame graphs" data-startref="ix_trcBPFvisflgr" id="idm46623555242024"/><a data-type="indexterm" data-primary="visualizing tracing data" data-secondary="using flame graphs" data-startref="ix_vgristrcflm" id="idm46623555240536"/><a data-type="indexterm" data-primary="flame graphs" data-startref="ix_flmgr" id="idm46623555239352"/></p>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Histograms"><div class="sect2" id="idm46623555866984">
<h2>Histograms</h2>

<p>Histograms are diagrams that show you how frequently several ranges of values occur.<a data-type="indexterm" data-primary="visualizing tracing data" data-secondary="using histograms" id="ix_vistrchst"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="visualizing tracing data" data-tertiary="using histograms" id="ix_trcBPFvishis"/><a data-type="indexterm" data-primary="histograms" id="ix_histgr"/> The numeric data to represent this is divided into buckets, and each bucket contains the number of occurrences of any data point within the bucket. The frequency that histograms measure is the combination of the height and width of each bucket. If the buckets are divided in equal ranges, this frequency matches the histogram’s height, but if the ranges are not divided equally, you need to multiply each height by each width to find the correct frequency.</p>

<p>Histograms are a fundamental component to do systems performance analysis. They are a great tool to represent the distribution of measurable events, like instruction latency, because they show you more correct information than you can get with other measurements, like averages.</p>

<p>BPF programs can create histograms based on many metrics. You can use BPF maps to collect the information, classify it in buckets, and then generate the histogram representation for your data. Implementing this logic is not complicated, but it becomes tedious if you want to print histograms every time you need to analyze a program’s output. BCC includes an implementation out of the box that you can reuse in every program, without having to calculate bucketing and frequency manually every single time. However, the kernel source has a fantastic implementation that we encourage you to check out in the BPF samples.</p>

<p>As a fun experiment, we’re going to show you how to use BCC’s histograms to visualize the latency introduced by loading BPF programs when an application calls the <code>bpf_prog_load</code> instruction.<a data-type="indexterm" data-primary="BCC (BPF Compiler Collection)" data-secondary="histogram visualizing latency from loading BPF programs" id="idm46623555229848"/> We use kprobes to collect how long it takes for that instruction to complete, and we’ll accumulate the results in a histogram that we’ll visualize later.<a data-type="indexterm" data-primary="kprobe programs" id="idm46623555228600"/> We’ve divided this example into several parts to make it easier to follow.</p>

<p>This first part includes the initial source for our BPF program:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">#include &lt;uapi/linux/ptrace.h&gt;</code><code class="s2">
</code><code class="s2">
</code><code class="s2">BPF_HASH(cache, u64, u64);</code><code class="s2">
</code><code class="s2">BPF_HISTOGRAM(histogram);</code><code class="s2">
</code><code class="s2">
</code><code class="s2">int trace_bpf_prog_load_start(void ctx) {		</code><a class="co" id="co_tracing_with_bpf_CO13-1" href="#callout_tracing_with_bpf_CO13-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  u64 pid = bpf_get_current_pid_tgid();			</code><a class="co" id="co_tracing_with_bpf_CO13-2" href="#callout_tracing_with_bpf_CO13-2"><img src="assets/2.png" alt="2"/></a><code class="s2">
</code><code class="s2">  u64 start_time_ns = bpf_ktime_get_ns();</code><code class="s2">
</code><code class="s2">  cache.update(&amp;pid, &amp;start_time_ns);			</code><a class="co" id="co_tracing_with_bpf_CO13-3" href="#callout_tracing_with_bpf_CO13-3"><img src="assets/3.png" alt="3"/></a><code class="s2">
</code><code class="s2">  return 0;</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO13-1" href="#co_tracing_with_bpf_CO13-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Use a macro to create a BPF hash map to store the initial time when the <code>bpf_prog_load</code> instruction is triggered.<a data-type="indexterm" data-primary="BPF_HASH macro" id="idm46623555179464"/></p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO13-2" href="#co_tracing_with_bpf_CO13-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Use a new macro to create a BPF histogram map.<a data-type="indexterm" data-primary="BPF_HISTOGRAM macro" id="idm46623555176264"/> This is not a native BPF map; BCC includes this macro to make it easier for you to create these visualizations. Under the hood, this BPF histogram uses array maps to store the information. It also has several helpers to do the bucketing and create the final graph.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO13-3" href="#co_tracing_with_bpf_CO13-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Use the programs PID to store when the application triggers the instruction we want to trace. (This function will look familiar to you—we took it from the previous Uprobes example.),</p></dd>
</dl>

<p>Let’s see how we calculate the delta for the latency and store it in our histogram. The initial lines of this new block of code will also look familiar because we’re still following the example we talked about in <a data-type="xref" href="#uprobes-section">“Uprobes”</a>.</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf_source</code><code> </code><code class="o">+</code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">int trace_bpf_prog_load_return(void ctx) {</code><code class="s2">
</code><code class="s2">  u64 *start_time_ns, delta;</code><code class="s2">
</code><code class="s2">  u64 pid = bpf_get_current_pid_tgid();</code><code class="s2">
</code><code class="s2">  start_time_ns = cache.lookup(&amp;pid);</code><code class="s2">
</code><code class="s2">  if (start_time_ns == 0)</code><code class="s2">
</code><code class="s2">    return 0;</code><code class="s2">
</code><code class="s2">
</code><code class="s2">  delta = bpf_ktime_get_ns() - *start_time_ns;		</code><a class="co" id="co_tracing_with_bpf_CO14-1" href="#callout_tracing_with_bpf_CO14-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">  histogram.increment(bpf_log2l(delta));		</code><a class="co" id="co_tracing_with_bpf_CO14-2" href="#callout_tracing_with_bpf_CO14-2"><img src="assets/2.png" alt="2"/></a><code class="s2">
</code><code class="s2">  return 0;</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO14-1" href="#co_tracing_with_bpf_CO14-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Calculate the delta between the time the instruction was invoked and the time it took our program to arrive here; we can assume that it’s also the time the instruction completed.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO14-2" href="#co_tracing_with_bpf_CO14-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Store that delta in our histogram. We do two operations in this line. First, we use the built-in function <code>bpf_log2l</code> to generate the bucket identifier for the value of the delta. This function creates a stable distribution of values over time. Then, we use the <code>increment</code> function to add a new item to this bucket. By default, <code>increment</code> adds 1 to the value if the bucket existed in the histogram, or it starts a new bucket with the value of 1, so you don’t need to worry about whether the value exists in advance.</p></dd>
</dl>

<p>The last piece of code that we need to write attaches these two functions to the valid kprobes and prints the histogram on the screen so that we can see the latency distribution. This section is where we initialize our BPF program and we wait for events to generate the histogram:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">)</code><code>			</code><a class="co" id="co_tracing_with_bpf_CO15-1" href="#callout_tracing_with_bpf_CO15-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_kprobe</code><code class="p">(</code><code class="n">event</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">bpf_prog_load</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>    </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">trace_bpf_prog_load_start</code><code class="s2">"</code><code class="p">)</code><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_kretprobe</code><code class="p">(</code><code class="n">event</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">bpf_prog_load</code><code class="s2">"</code><code class="p">,</code><code>
</code><code>    </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">trace_bpf_prog_load_return</code><code class="s2">"</code><code class="p">)</code><code>
</code><code>
</code><code class="k">try</code><code class="p">:</code><code>						</code><a class="co" id="co_tracing_with_bpf_CO15-2" href="#callout_tracing_with_bpf_CO15-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>  </code><code class="n">sleep</code><code class="p">(</code><code class="mi">99999999</code><code class="p">)</code><code>
</code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>
</code><code>  </code><code class="k">print</code><code class="p">(</code><code class="p">)</code><code>
</code><code>
</code><code class="n">bpf</code><code class="p">[</code><code class="s2">"</code><code class="s2">histogram</code><code class="s2">"</code><code class="p">]</code><code class="o">.</code><code class="n">print_log2_hist</code><code class="p">(</code><code class="s2">"</code><code class="s2">msecs</code><code class="s2">"</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO15-3" href="#callout_tracing_with_bpf_CO15-3"><img src="assets/3.png" alt="3"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO15-1" href="#co_tracing_with_bpf_CO15-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Initialize BPF and attach our functions to kprobes.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO15-2" href="#co_tracing_with_bpf_CO15-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Make our program wait so that we can gather as many events as we need from our system.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO15-3" href="#co_tracing_with_bpf_CO15-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Print the histogram map in our terminal with the traced distribution of events—this is another BCC macro that allows us to get the histogram map.</p></dd>
</dl>

<p>As we mentioned at the beginning of this section, histograms can be useful to observe anomalies in your system. The BCC tools include numerous scripts that make use of histograms to represent data; we highly recommend you take a look at them when you need inspiration to dive into your system.<a data-type="indexterm" data-primary="visualizing tracing data" data-secondary="using histograms" data-startref="ix_vistrchst" id="idm46623554983544"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="visualizing tracing data" data-tertiary="using histograms" data-startref="ix_trcBPFvishis" id="idm46623554982392"/><a data-type="indexterm" data-primary="histograms" data-startref="ix_histgr" id="idm46623554950456"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Perf Events"><div class="sect2" id="idm46623555238152">
<h2>Perf Events</h2>

<p>We believe that Perf events are probably the most important communication method that you need to master to use BPF tracing successfully.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="visualizing tracing data" data-tertiary="Perf events" id="ix_trcBPFvisPe"/><a data-type="indexterm" data-primary="visualizing tracing data" data-secondary="Perf events" id="ix_vistrcPe"/><a data-type="indexterm" data-primary="Perf events" data-secondary="tracing" id="ix_Pevnt"/> We talked about BPF Perf event array maps in the previous chapter.<a data-type="indexterm" data-primary="maps (BPF)" data-secondary="Perf events array map" id="idm46623554944248"/><a data-type="indexterm" data-primary="Perf events array maps" id="idm46623554943400"/> They allow you to put data in a buffer ring that’s synchronized in real time with user-space programs. This is ideal when you’re collecting a large amount of data in your BPF program and want to offload processing and visualization to a user-space program. That will allow you to have more control over the presentation layer because you’re not restricted by the BPF VM regarding programming capabilities. Most of the BPF tracing programs that you can find use Perf events only for this purpose.</p>

<p>Here, we show you how to use them to extract information about binary execution and classify that information to print which binaries are the most executed in your system. We’ve divided this example into two blocks of code so that you can easily follow the example. In the first block, we define our BPF program and attach it to a kprobe, like we did in <a data-type="xref" href="#probes-section">“Probes”</a>:</p>

<pre data-type="programlisting" data-code-language="python"><code class="n">bpf_source</code><code> </code><code class="o">=</code><code> </code><code class="s2">"""</code><code class="s2">
</code><code class="s2">#include &lt;uapi/linux/ptrace.h&gt;</code><code class="s2">
</code><code class="s2">
</code><code class="s2">BPF_PERF_OUTPUT(events);		</code><a class="co" id="co_tracing_with_bpf_CO16-1" href="#callout_tracing_with_bpf_CO16-1"><img src="assets/1.png" alt="1"/></a><code class="s2">
</code><code class="s2">
</code><code class="s2">int do_sys_execve(struct pt_regs *ctx, void filename, void argv, void envp) {</code><code class="s2">
</code><code class="s2">  char comm[16];</code><code class="s2">
</code><code class="s2">  bpf_get_current_comm(&amp;comm, sizeof(comm));</code><code class="s2">
</code><code class="s2">
</code><code class="s2">  events.perf_submit(ctx, &amp;comm, sizeof(comm));		</code><a class="co" id="co_tracing_with_bpf_CO16-2" href="#callout_tracing_with_bpf_CO16-2"><img src="assets/2.png" alt="2"/></a><code class="s2">
</code><code class="s2">  return 0;</code><code class="s2">
</code><code class="s2">}</code><code class="s2">
</code><code class="s2">"""</code><code>
</code><code>
</code><code class="n">bpf</code><code> </code><code class="o">=</code><code> </code><code class="n">BPF</code><code class="p">(</code><code class="n">text</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf_source</code><code class="p">)</code><code>						</code><a class="co" id="co_tracing_with_bpf_CO16-3" href="#callout_tracing_with_bpf_CO16-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code class="n">execve_function</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf</code><code class="o">.</code><code class="n">get_syscall_fnname</code><code class="p">(</code><code class="s2">"</code><code class="s2">execve</code><code class="s2">"</code><code class="p">)</code><code>
</code><code class="n">bpf</code><code class="o">.</code><code class="n">attach_kprobe</code><code class="p">(</code><code class="n">event</code><code> </code><code class="o">=</code><code> </code><code class="n">execve_function</code><code class="p">,</code><code> </code><code class="n">fn_name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">do_sys_execve</code><code class="s2">"</code><code class="p">)</code></pre>

<p>In the first line of this example, we’re importing a library from Python’s standard library. We’re going to use a Python counter to aggregate the events we’re receiving from our BPF program.</p>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO16-1" href="#co_tracing_with_bpf_CO16-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Use <code>BPF_PERF_OUTPUT</code> to declare a Perf events map.<a data-type="indexterm" data-primary="BPF_PERF_OUTPUT macro" id="idm46623554873544"/> This is a convinient macro that BCC provides to declare this kind of map. We’re naming this map <em>events</em>.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO16-2" href="#co_tracing_with_bpf_CO16-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Send it to user-space for aggregation after we have the name of the program that the kernel has executed. We do that with <code>perf_submit</code>. This function updates the Perf events map with our new piece of information.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO16-3" href="#co_tracing_with_bpf_CO16-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Initialize the BPF program and attach it to the kprobe to be triggered when a new program is executed in our system.</p></dd>
</dl>

<p>Now that we have written the code to collect all programs that are executed in our system, we need to aggregate them in user-space. There is a lot of information in the next code snippet, so we’re going to walk you through the most important lines:</p>

<pre data-type="programlisting" data-code-language="python"><code class="kn">from</code><code> </code><code class="nn">collections</code><code> </code><code class="kn">import</code><code> </code><code class="n">Counter</code><code>
</code><code class="n">aggregates</code><code> </code><code class="o">=</code><code> </code><code class="n">Counter</code><code class="p">(</code><code class="p">)</code><code>			</code><a class="co" id="co_tracing_with_bpf_CO17-1" href="#callout_tracing_with_bpf_CO17-1"><img src="assets/1.png" alt="1"/></a><code>
</code><code>
</code><code class="k">def</code><code> </code><code class="nf">aggregate_programs</code><code class="p">(</code><code class="n">cpu</code><code class="p">,</code><code> </code><code class="n">data</code><code class="p">,</code><code> </code><code class="n">size</code><code class="p">)</code><code class="p">:</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO17-2" href="#callout_tracing_with_bpf_CO17-2"><img src="assets/2.png" alt="2"/></a><code>
</code><code>  </code><code class="n">comm</code><code> </code><code class="o">=</code><code> </code><code class="n">bpf</code><code class="p">[</code><code class="s2">"</code><code class="s2">events</code><code class="s2">"</code><code class="p">]</code><code class="o">.</code><code class="n">event</code><code class="p">(</code><code class="n">data</code><code class="p">)</code><code>		 </code><a class="co" id="co_tracing_with_bpf_CO17-3" href="#callout_tracing_with_bpf_CO17-3"><img src="assets/3.png" alt="3"/></a><code>
</code><code>  </code><code class="n">aggregates</code><code class="p">[</code><code class="n">comm</code><code class="p">]</code><code> </code><code class="o">+</code><code class="o">=</code><code> </code><code class="mi">1</code><code>
</code><code>
</code><code class="n">bpf</code><code class="p">[</code><code class="s2">"</code><code class="s2">events</code><code class="s2">"</code><code class="p">]</code><code class="o">.</code><code class="n">open_perf_buffer</code><code class="p">(</code><code class="n">aggregate_programs</code><code class="p">)</code><code>	</code><a class="co" id="co_tracing_with_bpf_CO17-4" href="#callout_tracing_with_bpf_CO17-4"><img src="assets/4.png" alt="4"/></a><code>
</code><code class="k">while</code><code> </code><code class="bp">True</code><code class="p">:</code><code>
</code><code>    </code><code class="k">try</code><code class="p">:</code><code>
</code><code>      </code><code class="n">bpf</code><code class="o">.</code><code class="n">perf_buffer_poll</code><code class="p">(</code><code class="p">)</code><code>
</code><code>    </code><code class="k">except</code><code> </code><code class="ne">KeyboardInterrupt</code><code class="p">:</code><code>				</code><a class="co" id="co_tracing_with_bpf_CO17-5" href="#callout_tracing_with_bpf_CO17-5"><img src="assets/5.png" alt="5"/></a><code>
</code><code>      </code><code class="k">break</code><code>
</code><code>
</code><code class="k">for</code><code> </code><code class="p">(</code><code class="n">comm</code><code class="p">,</code><code> </code><code class="n">times</code><code class="p">)</code><code> </code><code class="ow">in</code><code> </code><code class="n">aggregates</code><code class="o">.</code><code class="n">most_common</code><code class="p">(</code><code class="p">)</code><code class="p">:</code><code>
</code><code>  </code><code class="k">print</code><code class="p">(</code><code class="s2">"</code><code class="s2">Program {} executed {} times</code><code class="s2">"</code><code class="o">.</code><code class="n">format</code><code class="p">(</code><code class="n">comm</code><code class="p">,</code><code> </code><code class="n">times</code><code class="p">)</code><code class="p">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_tracing_with_bpf_CO17-1" href="#co_tracing_with_bpf_CO17-1"><img src="assets/1.png" alt="1"/></a></dt>
<dd><p>Declare a counter to store our program information. We use the name of the program as the key, and the values will be counters.
We use the <code>aggregate_programs</code> function to collect the data from the Perf events map. In this example, you can see how we use the BCC macro to access the map and extract the next incoming data event from the top of the stack.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO17-2" href="#co_tracing_with_bpf_CO17-2"><img src="assets/2.png" alt="2"/></a></dt>
<dd><p>Increment the number of times we’ve received an event with the same program name.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO17-3" href="#co_tracing_with_bpf_CO17-3"><img src="assets/3.png" alt="3"/></a></dt>
<dd><p>Use the function <code>open_perf_buffer</code> to tell BCC that it needs to execute the function <code>aggregate_programs</code> every time it receives an event from the Perf events map.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO17-4" href="#co_tracing_with_bpf_CO17-4"><img src="assets/4.png" alt="4"/></a></dt>
<dd><p>BCC polls events after opening the ring buffer until we interrupt this Python program. The longer you wait, the more information you’re going to process. You can see how we use <code>perf_buffer_poll</code> for this purpose.</p></dd>
<dt><a class="co" id="callout_tracing_with_bpf_CO17-5" href="#co_tracing_with_bpf_CO17-5"><img src="assets/5.png" alt="5"/></a></dt>
<dd><p>Use the <code>most_common</code> function to get the list of elements in the counter and loop to print the top executed programs in your system first.</p></dd>
</dl>

<p>Perf events can open the door to processing all of the data that BPF exposes in novel and unexpected ways. We’ve shown you an example to inspire your imagination when you need to collect some kind of arbitrary data from the kernel; you can find many other examples in the tools that BCC provides for tracing.<a data-type="indexterm" data-primary="tracing with BPF" data-secondary="visualizing tracing data" data-tertiary="Perf events" data-startref="ix_trcBPFvisPe" id="idm46623554654680"/><a data-type="indexterm" data-primary="Perf events" data-secondary="tracing" data-startref="ix_Pevnt" id="idm46623554653352"/><a data-type="indexterm" data-primary="visualizing tracing data" data-secondary="Perf events" data-startref="ix_vistrcPe" id="idm46623554652264"/><a data-type="indexterm" data-primary="visualizing tracing data" data-startref="ix_vistrc" id="idm46623554651176"/><a data-type="indexterm" data-primary="tracing with BPF" data-secondary="visualizing tracing data" data-startref="ix_trcBPFvis" id="idm46623554650328"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46623554949016">
<h1>Conclusion</h1>

<p>In this chapter we’ve only scratched the surface of tracing with BPF. The Linux kernel gives you access to information that’s more difficult to obtain with other tools. BPF makes this process more predictable because it provides a common interface to access this data. In later chapters you’ll see more examples that use some of the techniques described here, such as attaching functions to tracepoints. They will help you cement what you’ve learned here.</p>

<p>We used the BCC framework in this chapter to write most of the examples. You can implement the same examples in C, like we did in previous chapters, but BCC provides several built-in features that make writing tracing programs much more accessible than C. If you’re up for a fun challenge, try rewriting these examples in C.<a data-type="indexterm" data-primary="tracing with BPF" data-startref="ix_trcBPF" id="idm46623554646904"/></p>

<p>In the next chapter, we show you some tools that the systems community has built on top of BPF to do performance analysis and tracing. Writing your own programs is powerful, but these dedicated tools give you access to much of the information we’ve seen here in packaged format. This way, you don’t need to rewrite tools that already exist.</p>
</div></section>







</div></section></body></html>