<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Introduction" data-type="chapter" epub:type="chapter"><div class="chapter" id="intro">&#13;
<h1><span class="label">Chapter 1. </span>Introduction</h1>&#13;
&#13;
&#13;
<p>Programming Kubernetes can mean different things to different people. In this chapter, we’ll first establish the scope and focus of this book. Also, we will share the set of assumptions about the environment we’re operating in and what you’ll need to bring to the table, ideally, to benefit most from this book. We will define what exactly we mean by programming Kubernetes, what Kubernetes-native apps are, and, by having a look at a concrete example, what their characteristics are. We will discuss the basics of controllers and operators, and how the event-driven Kubernetes control plane functions in principle. Ready? Let’s get to it.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Does Programming Kubernetes Mean?" data-type="sect1"><div class="sect1" id="programming-kubernetes-meaning">&#13;
<h1>What Does Programming Kubernetes Mean?</h1>&#13;
&#13;
<p>We assume you have access to a running Kubernetes cluster such as Amazon EKS, Microsoft AKS, Google GKE, or one of the OpenShift offerings.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You<a data-primary="Kubernetes" data-secondary="local development environment" data-type="indexterm" id="idm46336877077624"/><a data-primary="local development environment" data-type="indexterm" id="idm46336877076600"/> will spend a fair amount of time developing <em>locally</em> on your laptop or desktop environment; that is, the Kubernetes cluster against which you’re developing is local, rather than in the cloud or in your datacenter. When developing locally, you have a number of options available. Depending on your operating system and other preferences you might choose one (or maybe even more) of the following solutions for running Kubernetes locally: <a href="https://kind.sigs.k8s.io">kind</a>, <a href="http://bit.ly/2Ja1LaH">k3d</a>, or <a href="https://dockr.ly/2PTJVLL">Docker Desktop</a>.<sup><a data-type="noteref" href="ch01.html#idm46336877072840" id="idm46336877072840-marker">1</a></sup></p>&#13;
</div>&#13;
&#13;
<p>We<a data-primary="Go programming language" data-type="indexterm" id="idm46336877069944"/><a data-primary="Kubernetes" data-secondary="programming in Go" data-type="indexterm" id="idm46336877069208"/> also assume that you are a Go programmer—that is, you have experience or at least basic familiarity with the Go programming language. Now is a good time, if any of those assumptions do not apply to you, to train up: for Go, we recommend <a href="https://www.gopl.io"><em>The Go Programming Language</em></a> by Alan A. A. Donovan and Brian W. Kernighan (Addison-Wesley) and <a href="http://bit.ly/2tdCt5j"><em>Concurrency in Go</em></a> by Katherine Cox-Buday (O’Reilly). For<a data-primary="Kubernetes" data-secondary="additional resources" data-type="indexterm" id="idm46336877066136"/> Kubernetes, check out one or more of the following books:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a class="orm:hideurl" href="http://bit.ly/2Tb8Ydo"><em>Kubernetes in Action</em></a> by Marko Lukša (Manning)</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/2SaANU4"><em>Kubernetes: Up and Running</em>, 2nd Edition</a> by Kelsey Hightower et al. (O’Reilly)</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/2BaE1iq"><em>Cloud Native DevOps with Kubernetes</em></a> by John Arundel and Justin Domingus (O’Reilly)</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/2wtHcAm"><em>Managing Kubernetes</em></a> by Brendan Burns and Craig Tracey (O’Reilly)</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="http://bit.ly/2FTgJzk"><em>Kubernetes Cookbook</em></a> by Sébastien Goasguen and Michael Hausenblas (O’Reilly)</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Why do we focus on programming Kubernetes in Go? Well, an analogy might be useful here: Unix was written in the C programming language, and if you wanted to write applications or tooling for Unix you would default to C. Also, in order to extend and customize Unix—even if you were to use a language other than C—you would need to at least be able to read C.</p>&#13;
&#13;
<p>Now, Kubernetes and many related cloud-native technologies, from container runtimes to monitoring such as Prometheus, are written in Go. We believe that the majority of native applications will be Go-based and hence we focus on it in this book. Should you prefer other languages, keep an eye on the <a href="http://bit.ly/2xfSrfT">kubernetes-client</a> GitHub organization. It may, going forward, contain a client in your favorite programming language.</p>&#13;
</div>&#13;
&#13;
<p>By<a data-primary="Kubernetes" data-secondary="meaning of programming Kubernetes" data-type="indexterm" id="idm46336877052184"/> “programming Kubernetes” in the context of this book, we mean the following: you are about to develop a Kubernetes-native application that directly interacts with the API server, querying the state of resources and/or updating their state. We<a data-primary="commercially available off-the-shelf (COTS) apps" data-type="indexterm" id="idm46336877050824"/> do not mean running off-the-shelf apps, such as WordPress or Rocket Chat or your favorite enterprise CRM system, oftentimes called <em>commercially available off-the-shelf</em> (COTS) apps. Besides, in <a data-type="xref" href="ch07.html#ch_shipping">Chapter 7</a>, we do not really focus too much on operational issues, but mainly look at the development and testing phase. So, in a nutshell, this book is about developing<a data-primary="cloud-native applications" data-secondary="types of apps running on Kubernetes" data-type="indexterm" id="idm46336877048424"/> genuinely cloud-native applications. <a data-type="xref" href="#apps-on-kube">Figure 1-1</a> might help you soak that in better.</p>&#13;
&#13;
<figure><div class="figure" id="apps-on-kube">&#13;
<img alt="Different types of apps running on Kubernetes" src="assets/prku_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>Different types of apps running on Kubernetes</h6>&#13;
</div></figure>&#13;
&#13;
<p>As<a data-primary="Kubernetes" data-secondary="types of apps running on" data-type="indexterm" id="idm46336877044168"/> you can see, there are different styles at your disposal:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Take a COTS such as Rocket Chat and run it on Kubernetes. The app itself is not aware it runs on Kubernetes and usually doesn’t have to be. Kubernetes controls the app’s lifecycle—find node to run, pull image, launch container(s), carry out health checks, mount volumes, and so on—and that is that.</p>&#13;
</li>&#13;
<li>&#13;
<p>Take a bespoke app, something you wrote from scratch, with or without having had Kubernetes as the runtime environment in mind, and run it on Kubernetes. The same modus operandi as in the case of a COTS applies.</p>&#13;
</li>&#13;
<li>&#13;
<p>The case we focus on in this book is a cloud-native or Kubernetes-native application that is fully aware it is running on Kubernetes and leverages Kubernetes APIs and resources to some extent.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>The<a data-primary="Kubernetes API" data-secondary="benefits of" data-type="indexterm" id="idm46336877306968"/> price you pay developing against the Kubernetes API pays off: on the one hand you gain portability, as your app will now run in any environment (from an on-premises deployment to any public cloud provider), and on the other hand you benefit from the clean, declarative mechanism Kubernetes provides.</p>&#13;
&#13;
<p>Let’s move on to a concrete example now.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Motivational Example" data-type="sect1"><div class="sect1" id="mot-example">&#13;
<h1>A Motivational Example</h1>&#13;
&#13;
<p>To<a data-primary="cloud-native applications" data-secondary="example of" data-type="indexterm" id="idm46336877303096"/><a data-primary="Kubernetes" data-secondary="native app example" data-type="indexterm" id="idm46336877302120"/> demonstrate the power of a Kubernetes-native app, let’s assume you want to implement <code>at</code>—that is, <a href="http://bit.ly/2L4VqzU">schedule the execution of a command</a> at a given time.</p>&#13;
&#13;
<p>We<a data-primary="cnat (cloud-native at) example" data-type="indexterm" id="idm46336877299192"/> call this <a href="http://bit.ly/2RpHhON"><code>cnat</code></a> or cloud-native <code>at</code>, and it works as follows. Let’s say you want to execute the command <code>echo "Kubernetes native rocks!"</code> at 2 a.m. on July 3, 2019. Here’s what you would do with <code>cnat</code>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>cat cnat-rocks-example.yaml&#13;
apiVersion: cnat.programming-kubernetes.info/v1alpha1&#13;
kind: At&#13;
metadata:&#13;
  name: cnrex&#13;
spec:&#13;
  schedule: <code class="s2">"2019-07-03T02:00:00Z"</code>&#13;
  containers:&#13;
  - name: shell&#13;
    image: centos:7&#13;
    <code class="nb">command</code>:&#13;
    - <code class="s2">"bin/bash"</code>&#13;
    - <code class="s2">"-c"</code>&#13;
    - <code class="nb">echo</code> <code class="s2">"Kubernetes native rocks!"</code>&#13;
&#13;
<code class="nv">$ </code>kubectl apply -f cnat-rocks-example.yaml&#13;
cnat.programming-kubernetes.info/cnrex created</pre>&#13;
&#13;
<p>Behind the scenes, the following components are involved:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A custom resource called <code>cnat.programming-kubernetes.info/cnrex</code>, representing the schedule.</p>&#13;
</li>&#13;
<li>&#13;
<p>A controller to execute the scheduled command at the correct time.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In addition, a <code>kubectl</code> plug-in for the CLI UX would be useful, allowing simple handling via commands like <code>kubectl</code> <code>at</code> <code>"02:00 Jul 3"</code> <code>echo</code> <code>"Kubernetes native rocks!"</code> We<a data-primary="Kubernetes" data-secondary="documentation" data-type="indexterm" id="idm46336874055880"/> won’t write this in this book, but you can refer to <a href="http://bit.ly/2J1dPuN"> the Kubernetes documentation for instructions</a>.</p>&#13;
&#13;
<p>Throughout the book, we will use this example to discuss aspects of Kubernetes, its inner workings, and how to extend it.</p>&#13;
&#13;
<p>For the more advanced examples in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#ch_custom-api-servers">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#ch_advanced-topics">9</a>, we will simulate a pizza restaurant with pizza and topping objects in the cluster. See <a data-type="xref" href="ch08.html#aggregation-example">“Example: A Pizza Restaurant”</a> for details.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extension Patterns" data-type="sect1"><div class="sect1" id="idm46336874473944">&#13;
<h1>Extension Patterns</h1>&#13;
&#13;
<p>Kubernetes<a data-primary="extension patterns" data-secondary="overview of" data-type="indexterm" id="idm46336874126488"/><a data-primary="Kubernetes" data-secondary="extension patterns" data-type="indexterm" id="idm46336874844056"/> is a powerful and inherently extensible system. In general, there are multiple ways to customize and/or extend Kubernetes:&#13;
using <a href="http://bit.ly/2KteqbA">configuration files and flags</a> for control plane components like the <code>kubelet</code> or the Kubernetes API server, and through a number of defined extension points:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>So-called <a href="http://bit.ly/2FpHInw">cloud providers</a>, which were traditionally in-tree as part of the controller manager. As of 1.11, Kubernetes makes out-of-tree development possible by providing a <a href="http://bit.ly/2WWlcxk">custom <code>cloud-controller-manager</code> process to integrate with a cloud</a>. Cloud providers allow the use of cloud provider–specific tools like load balancers or Virtual Machines (VMs).</p>&#13;
</li>&#13;
<li>&#13;
<p>Binary <code>kubelet</code> plug-ins for <a href="http://bit.ly/2L1tPzm">network</a>, <a href="http://bit.ly/2XthLgM">devices</a> (such as GPUs), <a href="http://bit.ly/2x7Unaa">storage</a>, and <a href="http://bit.ly/2Zzh1Eq">container runtimes</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Binary <code>kubectl</code> <a href="http://bit.ly/2FmH7mu">plug-ins</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Access extensions in the API server, such as the <a href="http://bit.ly/2DwR2Y3">dynamic admission control with webhooks</a> (see <a data-type="xref" href="ch09.html#ch_advanced-topics">Chapter 9</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Custom resources (see <a data-type="xref" href="ch04.html#ch_crds">Chapter 4</a>) and custom controllers; see the following <span class="keep-together">section</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Custom API servers (see <a data-type="xref" href="ch08.html#ch_custom-api-servers">Chapter 8</a>).</p>&#13;
</li>&#13;
<li>&#13;
<p>Scheduler extensions, such as using a <a href="http://bit.ly/2xcg4FL">webhook</a> to implement your own scheduling decisions.</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="http://bit.ly/2Oh6DPS">Authentication</a> with webhooks.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In the context of this book we focus on custom resources, controllers, webhooks, and custom API servers, along with the Kubernetes <a href="http://bit.ly/2L2SJ1C">extension patterns</a>. If you’re interested in other extension points, such as storage or network plug-ins, check out the <a href="http://bit.ly/2Y0L1J9">official documentation</a>.</p>&#13;
&#13;
<p>Now that you have a basic understanding of the Kubernetes extension patterns and the scope of this book, let’s move on to the heart of the Kubernetes control plane and see how we can extend it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Controllers and Operators" data-type="sect1"><div class="sect1" id="ch_controllers-operators">&#13;
<h1>Controllers and Operators</h1>&#13;
&#13;
<p>In<a data-primary="Kubernetes" data-secondary="controllers and operators" data-type="indexterm" id="Kcont01"/><a data-primary="controllers and operators" data-secondary="functions of" data-type="indexterm" id="idm46336876819224"/> this section you’ll learn about controllers and operators in Kubernetes and how they work.</p>&#13;
&#13;
<p>Per the <a href="http://bit.ly/2IWGlxz">Kubernetes glossary</a>, a <em>controller</em> implements a control loop, watching the shared state of the cluster through the API server and making changes in an attempt to move the current state toward the desired state.</p>&#13;
&#13;
<p>Before we dive into the controller’s inner workings, let’s define our terminology:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Controllers can act on core resources such as deployments or services, which are typically part of the <a href="http://bit.ly/2WUAEVy">Kubernetes controller manager</a> in the control plane, or can watch and manipulate user-defined custom resources.</p>&#13;
</li>&#13;
<li>&#13;
<p>Operators are controllers that encode some operational knowledge, such as <span class="keep-together">application</span> lifecycle management, along with the custom resources defined in <a data-type="xref" href="ch04.html#ch_crds">Chapter 4</a>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Naturally, given that the latter concept is based on the former, we’ll look at controllers first and then discuss the more specialized case of an operator.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Control Loop" data-type="sect2"><div class="sect2" id="controller-loop">&#13;
<h2>The Control Loop</h2>&#13;
&#13;
<p>In<a data-primary="controllers and operators" data-secondary="control loop" data-type="indexterm" id="idm46336873812920"/> general, the control loop looks as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Read the state of resources, preferably event-driven (using watches, as discussed in <a data-type="xref" href="ch03.html#ch_client-go">Chapter 3</a>). See <a data-type="xref" href="#controller-events">“Events”</a> and <a data-type="xref" href="#edge-vs-level">“Edge- Versus Level-Driven Triggers”</a> for details.</p>&#13;
</li>&#13;
<li>&#13;
<p>Change the state of objects in the cluster or the cluster-external world. For example, launch a pod, create a network endpoint, or query a cloud API. See <a data-type="xref" href="#controller-change-world">“Changing Cluster Objects or the External World”</a> for details.</p>&#13;
</li>&#13;
<li>&#13;
<p>Update status of the resource in step 1 via the API server in <code>etcd</code>. See <a data-type="xref" href="#optimistic-concurrency">“Optimistic Concurrency”</a> for details.</p>&#13;
</li>&#13;
<li>&#13;
<p>Repeat cycle; return to step 1.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>No matter how complex or simple your controller is, these three steps—read resource state ˃ change the world ˃ update resource status—remain the same. Let’s dig a bit deeper into how these steps are actually implemented in a Kubernetes controller. The control loop is depicted in <a data-type="xref" href="#controller-loop-overview">Figure 1-2</a>, which shows the typical moving parts, with the main loop of the controller in the middle. This main loop is continuously running inside of the controller process. This process is usually running inside a pod in the cluster.</p>&#13;
&#13;
<figure><div class="figure" id="controller-loop-overview">&#13;
<img alt="Kubernetes control loop" src="assets/prku_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>Kubernetes control loop</h6>&#13;
</div></figure>&#13;
&#13;
<p>From an architectural point of view, a controller typically uses the following data structures (as discussed in detail in <a data-type="xref" href="ch03.html#ch_client-go">Chapter 3</a>):</p>&#13;
<dl>&#13;
<dt>Informers</dt>&#13;
<dd>&#13;
<p>Informers<a data-primary="informers" data-secondary="overview of" data-type="indexterm" id="idm46336877282952"/> watch the desired state of resources in a scalable and sustainable fashion. They also implement a resync mechanism (see <a data-type="xref" href="ch03.html#informers">“Informers and Caching”</a> for details) that enforces periodic reconciliation, and is often used to make sure that the cluster state and the assumed state cached in memory do not drift (e.g., due bugs or network issues).</p>&#13;
</dd>&#13;
<dt>Work queues</dt>&#13;
<dd>&#13;
<p>Essentially, a work<a data-primary="work queues" data-type="indexterm" id="idm46336868792744"/> queue is a component that can be used by the event handler to handle queuing of state changes and help to implement retries. In <code>client-go</code> this functionality is available via the <a href="http://bit.ly/2x7zyeK"><em>workqueue</em> package</a> (see <a data-type="xref" href="ch03.html#workqueue">“Work Queue”</a>). Resources can be requeued in case of errors when updating the world or writing the status (steps 2 and 3 in the loop), or just because we have to reconsider the resource after some time for other reasons.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>For<a data-primary="Kubernetes" data-secondary="additional resources" data-type="indexterm" id="idm46336868788472"/> a more formal discussion of Kubernetes as a declarative engine and state transitions, read <a href="http://bit.ly/2IV2lcb">“The Mechanics of Kubernetes”</a> by Andrew Chen and Dominik Tornow.</p>&#13;
&#13;
<p>Let’s now take a closer look at the control loop, starting with Kubernetes event-driven architecture.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Events" data-type="sect2"><div class="sect2" id="controller-events">&#13;
<h2>Events</h2>&#13;
&#13;
<p>The<a data-primary="controllers and operators" data-secondary="events" data-type="indexterm" id="idm46336873365176"/><a data-primary="events" data-secondary="overview of" data-type="indexterm" id="idm46336873364200"/> Kubernetes control plane heavily employs events and the principle of loosely coupled components. Other distributed systems use<a data-primary="remote procedure calls (RPCs)" data-type="indexterm" id="idm46336873362984"/> remote procedure calls (RPCs) to trigger behavior. Kubernetes does not. Kubernetes controllers watch changes to Kubernetes objects in the API server: adds, updates, and removes. When such an event happens, the controller executes its business logic.</p>&#13;
&#13;
<p>For example, in order to launch a pod via a deployment, a number of controllers and other control plane components work together:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The deployment controller<a data-primary="kube-controller-manager" data-type="indexterm" id="idm46336873359976"/> (inside of <code>kube-controller-manager</code>) notices (through a deployment informer) that the user creates a deployment. It creates a replica set in its business logic.</p>&#13;
</li>&#13;
<li>&#13;
<p>The replica set controller (again inside of <code>kube-controller-manager</code>) notices (through a replica set informer) the new replica set and subsequently runs its business logic, which creates a pod object.</p>&#13;
</li>&#13;
<li>&#13;
<p>The scheduler<a data-primary="kube-scheduler" data-type="indexterm" id="idm46336873356296"/> (inside the <code>kube-scheduler</code> binary)—which is also a controller—notices the pod (through a pod informer) with an empty <code>spec.nodeName</code> field. Its business logic puts the pod in its scheduling queue.</p>&#13;
</li>&#13;
<li>&#13;
<p>Meanwhile<a data-primary="kubelet" data-type="indexterm" id="idm46336873353624"/> the <code>kubelet</code>—another controller—notices the new pod (through its pod informer). But the new pod’s <code>spec.nodeName</code> field is empty and therefore does not match the <code>kubelet</code>’s node name. It ignores the pod and goes back to sleep (until the next event).</p>&#13;
</li>&#13;
<li>&#13;
<p>The scheduler takes the pod out of the work queue and schedules it to a node that has enough free resources by updating the <code>spec.nodeName</code> field in the pod and writing it to the API server.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>kubelet</code> wakes up again due to the pod update event. It again compares the <code>spec.nodeName</code> with its own node name. The names match, and so the <code>kubelet</code> starts the containers of the pod and reports back that the containers have been started by writing this information into the pod status, back to the API server.</p>&#13;
</li>&#13;
<li>&#13;
<p>The replica set controller notices the changed pod but has nothing to do.</p>&#13;
</li>&#13;
<li>&#13;
<p>Eventually the pod terminates. The <code>kubelet</code> will notice this, get the pod object from the API server and set the “terminated” condition in the pod’s status, and write it back to the API server.</p>&#13;
</li>&#13;
<li>&#13;
<p>The replica set controller notices the terminated pod and decides that this pod must be replaced. It deletes the terminated pod on the API server and creates a new one.</p>&#13;
</li>&#13;
<li>&#13;
<p>And so on.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>As you can see, a number of independent control loops communicate purely through object changes on the API server and events these changes trigger through informers.</p>&#13;
&#13;
<p>These events are sent from the API server to the informers inside the controllers via<a data-primary="watches" data-type="indexterm" id="idm46336868769272"/> watches (see <a data-type="xref" href="ch03.html#client-go-watches">“Watches”</a>)—that is, streaming connections of watch events. All of this is mostly invisible to the user. Not even the API server audit mechanism makes these events visible; only the object updates are visible. Controllers often use log output, though, when they react on events.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46336868767384">&#13;
<h5>Watch Events Versus the Event Object</h5>&#13;
<p>Watch<a data-primary="events" data-secondary="watch events versus event objects" data-type="indexterm" id="idm46336868766008"/> events and the top-level <code>Event</code> object in Kubernetes are two different things:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Watch events are sent through streaming HTTP connections between the API server and controllers to drive informers.</p>&#13;
</li>&#13;
<li>&#13;
<p>The top-level <code>Event</code> object is a resource like pods, deployments, or services, with the special property that it has a time-to-live of an hour and then is purged automatically from <code>etcd</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><code>Event</code> objects are merely a user-visible logging mechanism. A number of controllers create these events in order to communicate aspects of their business logic to the user. For example, the <code>kubelet</code> reports the lifecycle events for pods (i.e., when a container was started, restarted, and terminated).</p>&#13;
&#13;
<p>You<a data-primary="kubectl" data-type="indexterm" id="idm46336868759928"/><a data-primary="kube-system" data-type="indexterm" id="idm46336868759320"/> can list the second class of events happening in the cluster yourself using <code>kubectl</code>. By issuing the following command, you see what is going on in the <code>kube-system</code> namespace:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>-n</code><code> </code><code>kube-system</code><code> </code><code>get</code><code> </code><code>events</code></strong><code>&#13;
</code><code>LAST</code><code> </code><code>SEEN</code><code>   </code><code>FIRST</code><code> </code><code>SEEN</code><code>   </code><code>COUNT</code><code>  </code><code>NAME</code><code>                                              </code><code>KIND</code><code>&#13;
</code><code>3m</code><code>          </code><code>3m</code><code>           </code><code class="m">1</code><code>      </code><code>kube-controller-manager-master.15932b6faba8e5ad</code><code>   </code><code>Pod</code><code>&#13;
</code><code>3m</code><code>          </code><code>3m</code><code>           </code><code class="m">1</code><code>      </code><code>kube-apiserver-master.15932b6fa3f3fbbc</code><code>            </code><code>Pod</code><code>&#13;
</code><code>3m</code><code>          </code><code>3m</code><code>           </code><code class="m">1</code><code>      </code><code>etcd-master.15932b6fa8a9a776</code><code>                      </code><code>Pod</code><code>&#13;
</code><code>…</code><code>&#13;
</code><code>2m</code><code>          </code><code>3m</code><code>           </code><code class="m">2</code><code>      </code><code>weave-net-7nvnf.15932b73e61f5bc6</code><code>                  </code><code>Pod</code><code>&#13;
</code><code>2m</code><code>          </code><code>3m</code><code>           </code><code class="m">2</code><code>      </code><code>weave-net-7nvnf.15932b73efeec0b3</code><code>                  </code><code>Pod</code><code>&#13;
</code><code>2m</code><code>          </code><code>3m</code><code>           </code><code class="m">2</code><code>      </code><code>weave-net-7nvnf.15932b73e8f7d318</code><code>                  </code><code>Pod</code><code>&#13;
</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>If<a data-primary="Kubernetes" data-secondary="additional resources" data-type="indexterm" id="idm46336868587944"/> you want to learn more about events, read Michael Gasch’s blog post <a href="http://bit.ly/2MZwbl6">“Events, the DNA of Kubernetes”</a>, where he provides more background and examples.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Edge- Versus Level-Driven Triggers" data-type="sect2"><div class="sect2" id="edge-vs-level">&#13;
<h2>Edge- Versus Level-Driven Triggers</h2>&#13;
&#13;
<p>Let’s<a data-primary="triggers" data-secondary="edge- versus level-driven triggers" data-type="indexterm" id="idm46336868578856"/><a data-primary="controllers and operators" data-secondary="edge- versus level-driven triggers" data-type="indexterm" id="idm46336868581288"/> step back a bit and look more abstractly at how we can structure business logic implemented in controllers, and why Kubernetes has chosen to use events (i.e., state changes) to drive its logic.</p>&#13;
&#13;
<p>There are two principled options to<a data-primary="state change" data-secondary="detecting" data-type="indexterm" id="idm46336868583208"/> detect state change (the event itself):</p>&#13;
<dl>&#13;
<dt>Edge-driven triggers</dt>&#13;
<dd>&#13;
<p>At<a data-primary="edge-driven triggers" data-type="indexterm" id="idm46336868591560"/> the point in time the state change occurs, a handler is triggered—for example, from no pod to pod running.</p>&#13;
</dd>&#13;
<dt>Level-driven triggers</dt>&#13;
<dd>&#13;
<p>The state is checked at<a data-primary="level-driven triggers" data-type="indexterm" id="idm46336868593080"/> regular intervals and if certain conditions are met (for example, pod running), then a handler is triggered.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The<a data-primary="polling" data-type="indexterm" id="idm46336868595224"/> latter is a form of polling. It does not scale well with the number of objects, and the latency of controllers noticing changes depends on the interval of polling and how fast the API server can answer. With many asynchronous controllers involved, as described in <a data-type="xref" href="#controller-events">“Events”</a>, the result is a system that takes a long time to implement the users’ desire.</p>&#13;
&#13;
<p>The former option is much more efficient with many objects. The latency mostly depends on the number of worker threads in the controller’s processing events. Hence, Kubernetes is based on events (i.e., edge-driven triggers).</p>&#13;
&#13;
<p>In<a data-primary="event sources" data-type="indexterm" id="idm46336868601384"/><a data-primary="event producers" data-type="indexterm" id="idm46336868600648"/> the Kubernetes control plane, a number of components change objects on the API server, with each change leading to an event (i.e., an edge). We call these components <em>event sources</em> or <em>event producers</em>. On the other hand, in the context of controllers, we’re interested in consuming events—that is, when and how to react to an event (via an informer).</p>&#13;
&#13;
<p>In a distributed system there are many actors running in parallel, and events come in asynchronously in any order. When we have a buggy controller logic, some slightly wrong state machine, or an external service failure, it is easy to lose events in the sense that we don’t process them completely. Hence, we have to take a deeper look at how to<a data-primary="errors" data-secondary="coping with trigger errors" data-type="indexterm" id="idm46336868606264"/><a data-primary="triggers" data-secondary="coping with errors" data-type="indexterm" id="idm46336868605288"/> cope with errors.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#edge-vs-level-overview">Figure 1-3</a> you can see different strategies at work:</p>&#13;
<ol>&#13;
<li>&#13;
<p>An example of an edge-driven-only logic, where potentially the second state change is missed.</p>&#13;
</li>&#13;
<li>&#13;
<p>An example of an edge-triggered logic, which always gets the latest state (i.e., level) when processing an event. In other words, the logic is edge-triggered but level-driven.</p>&#13;
</li>&#13;
<li>&#13;
<p>An example of an edge-triggered, level-driven logic with additional resync.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<figure><div class="figure" id="edge-vs-level-overview">&#13;
<img alt="Trigger options (edge vs. level)" src="assets/prku_0103.png"/>&#13;
<h6><span class="label">Figure 1-3. </span>Trigger options (edge-driven versus level-driven)</h6>&#13;
</div></figure>&#13;
&#13;
<p>Strategy 1 does not cope well with missed events, whether because broken networking makes it lose events, or because the controller itself has bugs or some external cloud API was down. Imagine that the replica set controller would replace pods only when they terminate. Missing events would mean that the replica set would always run with fewer pods because it never reconciles the whole state.</p>&#13;
&#13;
<p>Strategy 2 recovers from those issues when another event is received because it implements its logic based on the latest state in the cluster. In the case of the replica set controller, it will always compare the specified replica count with the running pods in the cluster. When it loses events, it will replace all missing pods the next time a pod update is received.</p>&#13;
&#13;
<p>Strategy 3 adds continuous resync (e.g., every five minutes). If no pod events come in, it will at least reconcile every five minutes, even if the application runs very stably and does not lead to many pod events.</p>&#13;
&#13;
<p>Given the challenges of pure edge-driven triggers, the Kubernetes controllers typically implement the third strategy.</p>&#13;
&#13;
<p>If<a data-primary="Kubernetes" data-secondary="additional resources" data-type="indexterm" id="idm46336868626088"/> you want to learn more about the origins of the triggers and the motivations for level triggering with reconciliation in Kubernetes, read James Bowes’s article, <a href="http://bit.ly/2FmLLAW">“Level Triggering and Reconciliation in Kubernetes”</a>.</p>&#13;
&#13;
<p>This concludes the discussion of the different, abstract ways to detect external changes and to react on them. The next step in the control loop of <a data-type="xref" href="#controller-loop-overview">Figure 1-2</a> is to change the cluster objects or to change the external world following the spec. We’ll look at it now.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Changing Cluster Objects or the External World" data-type="sect2"><div class="sect2" id="controller-change-world">&#13;
<h2>Changing Cluster Objects or the External World</h2>&#13;
&#13;
<p>In<a data-primary="controllers and operators" data-secondary="changing cluster objects or the external world" data-type="indexterm" id="idm46336868635224"/> this phase, the controller changes the state of the objects it is supervising. For example, the <code>ReplicaSet</code> controller in the <a href="http://bit.ly/2WUAEVy">controller manager</a> is supervising pods. On each event (edge-triggered), it will observe the current state of its pods and compare that with the desired state (level-driven).</p>&#13;
&#13;
<p>Since the act of changing the resource state is domain- or task-specific, we can provide little guidance. Instead, we’ll keep looking at the <code>ReplicaSet</code> controller we introduced earlier. <code>ReplicaSet</code>s are used in deployments, and the bottom line of the respective controller is: maintain a user-defined number of identical pod replicas. That is, if there are fewer pods than the user specified—for example, because a pod died or the replica value has been increased—the controller will launch new pods. If, however, there are too many pods, it will select some for termination. The entire business logic of the controller is available via <a href="http://bit.ly/2L4eKxa">the <em>replica_set.go</em> package</a>, and the following excerpt of the Go code deals with the state change (edited for clarity):</p>&#13;
&#13;
<pre class="small" data-code-language="go" data-type="programlisting"><code class="c1">// manageReplicas checks and updates replicas for the given ReplicaSet.</code>&#13;
<code class="c1">// It does NOT modify &lt;filteredPods&gt;.</code>&#13;
<code class="c1">// It will requeue the replica set in case of an error while creating/deleting pods.</code>&#13;
<code class="kd">func</code> <code class="p">(</code><code class="nx">rsc</code> <code class="o">*</code><code class="nx">ReplicaSetController</code><code class="p">)</code> <code class="nx">manageReplicas</code><code class="p">(</code>&#13;
	<code class="nx">filteredPods</code> <code class="p">[]</code><code class="o">*</code><code class="nx">v1</code><code class="p">.</code><code class="nx">Pod</code><code class="p">,</code> <code class="nx">rs</code> <code class="o">*</code><code class="nx">apps</code><code class="p">.</code><code class="nx">ReplicaSet</code><code class="p">,</code>&#13;
<code class="p">)</code> <code class="kt">error</code> <code class="p">{</code>&#13;
    <code class="nx">diff</code> <code class="o">:=</code> <code class="nb">len</code><code class="p">(</code><code class="nx">filteredPods</code><code class="p">)</code> <code class="o">-</code> <code class="nb">int</code><code class="p">(</code><code class="o">*</code><code class="p">(</code><code class="nx">rs</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Replicas</code><code class="p">))</code>&#13;
    <code class="nx">rsKey</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">controller</code><code class="p">.</code><code class="nx">KeyFunc</code><code class="p">(</code><code class="nx">rs</code><code class="p">)</code>&#13;
    <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
        <code class="nx">utilruntime</code><code class="p">.</code><code class="nx">HandleError</code><code class="p">(</code>&#13;
        	<code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"Couldn't get key for %v %#v: %v"</code><code class="p">,</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">Kind</code><code class="p">,</code> <code class="nx">rs</code><code class="p">,</code> <code class="nx">err</code><code class="p">),</code>&#13;
        <code class="p">)</code>&#13;
        <code class="k">return</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">if</code> <code class="nx">diff</code> <code class="p">&lt;</code> <code class="mi">0</code> <code class="p">{</code>&#13;
        <code class="nx">diff</code> <code class="o">*=</code> <code class="o">-</code><code class="mi">1</code>&#13;
        <code class="k">if</code> <code class="nx">diff</code> <code class="p">&gt;</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">burstReplicas</code> <code class="p">{</code>&#13;
            <code class="nx">diff</code> <code class="p">=</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">burstReplicas</code>&#13;
        <code class="p">}</code>&#13;
        <code class="nx">rsc</code><code class="p">.</code><code class="nx">expectations</code><code class="p">.</code><code class="nx">ExpectCreations</code><code class="p">(</code><code class="nx">rsKey</code><code class="p">,</code> <code class="nx">diff</code><code class="p">)</code>&#13;
        <code class="nx">klog</code><code class="p">.</code><code class="nx">V</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="nx">Infof</code><code class="p">(</code><code class="s">"Too few replicas for %v %s/%s, need %d, creating %d"</code><code class="p">,</code>&#13;
        	<code class="nx">rsc</code><code class="p">.</code><code class="nx">Kind</code><code class="p">,</code> <code class="nx">rs</code><code class="p">.</code><code class="nx">Namespace</code><code class="p">,</code> <code class="nx">rs</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code> <code class="o">*</code><code class="p">(</code><code class="nx">rs</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Replicas</code><code class="p">),</code> <code class="nx">diff</code><code class="p">,</code>&#13;
        <code class="p">)</code>&#13;
        <code class="nx">successfulCreations</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">slowStartBatch</code><code class="p">(</code>&#13;
        	<code class="nx">diff</code><code class="p">,</code>&#13;
        	<code class="nx">controller</code><code class="p">.</code><code class="nx">SlowStartInitialBatchSize</code><code class="p">,</code>&#13;
        	<code class="kd">func</code><code class="p">()</code> <code class="kt">error</code> <code class="p">{</code>&#13;
        		<code class="nx">ref</code> <code class="o">:=</code> <code class="nx">metav1</code><code class="p">.</code><code class="nx">NewControllerRef</code><code class="p">(</code><code class="nx">rs</code><code class="p">,</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">GroupVersionKind</code><code class="p">)</code>&#13;
                <code class="nx">err</code> <code class="o">:=</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">podControl</code><code class="p">.</code><code class="nx">CreatePodsWithControllerRef</code><code class="p">(</code>&#13;
            	    <code class="nx">rs</code><code class="p">.</code><code class="nx">Namespace</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">rs</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Template</code><code class="p">,</code> <code class="nx">rs</code><code class="p">,</code> <code class="nx">ref</code><code class="p">,</code>&#13;
                <code class="p">)</code>&#13;
                <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="o">&amp;&amp;</code> <code class="nx">errors</code><code class="p">.</code><code class="nx">IsTimeout</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>&#13;
                	<code class="k">return</code> <code class="kc">nil</code>&#13;
                <code class="p">}</code>&#13;
                <code class="k">return</code> <code class="nx">err</code>&#13;
            <code class="p">},</code>&#13;
        <code class="p">)</code>&#13;
        <code class="k">if</code> <code class="nx">skippedPods</code> <code class="o">:=</code> <code class="nx">diff</code> <code class="o">-</code> <code class="nx">successfulCreations</code><code class="p">;</code> <code class="nx">skippedPods</code> <code class="p">&gt;</code> <code class="mi">0</code> <code class="p">{</code>&#13;
            <code class="nx">klog</code><code class="p">.</code><code class="nx">V</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="nx">Infof</code><code class="p">(</code><code class="s">"Slow-start failure. Skipping creation of %d pods,"</code> <code class="o">+</code>&#13;
            	<code class="s">" decrementing expectations for %v %v/%v"</code><code class="p">,</code>&#13;
            	<code class="nx">skippedPods</code><code class="p">,</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">Kind</code><code class="p">,</code> <code class="nx">rs</code><code class="p">.</code><code class="nx">Namespace</code><code class="p">,</code> <code class="nx">rs</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code>&#13;
            <code class="p">)</code>&#13;
            <code class="k">for</code> <code class="nx">i</code> <code class="o">:=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="p">&lt;</code> <code class="nx">skippedPods</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code> <code class="p">{</code>&#13;
                <code class="nx">rsc</code><code class="p">.</code><code class="nx">expectations</code><code class="p">.</code><code class="nx">CreationObserved</code><code class="p">(</code><code class="nx">rsKey</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
        <code class="k">return</code> <code class="nx">err</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="nx">diff</code> <code class="p">&gt;</code> <code class="mi">0</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="nx">diff</code> <code class="p">&gt;</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">burstReplicas</code> <code class="p">{</code>&#13;
            <code class="nx">diff</code> <code class="p">=</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">burstReplicas</code>&#13;
        <code class="p">}</code>&#13;
        <code class="nx">klog</code><code class="p">.</code><code class="nx">V</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="nx">Infof</code><code class="p">(</code><code class="s">"Too many replicas for %v %s/%s, need %d, deleting %d"</code><code class="p">,</code>&#13;
        	<code class="nx">rsc</code><code class="p">.</code><code class="nx">Kind</code><code class="p">,</code> <code class="nx">rs</code><code class="p">.</code><code class="nx">Namespace</code><code class="p">,</code> <code class="nx">rs</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code> <code class="o">*</code><code class="p">(</code><code class="nx">rs</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Replicas</code><code class="p">),</code> <code class="nx">diff</code><code class="p">,</code>&#13;
        <code class="p">)</code>&#13;
&#13;
        <code class="nx">podsToDelete</code> <code class="o">:=</code> <code class="nx">getPodsToDelete</code><code class="p">(</code><code class="nx">filteredPods</code><code class="p">,</code> <code class="nx">diff</code><code class="p">)</code>&#13;
        <code class="nx">rsc</code><code class="p">.</code><code class="nx">expectations</code><code class="p">.</code><code class="nx">ExpectDeletions</code><code class="p">(</code><code class="nx">rsKey</code><code class="p">,</code> <code class="nx">getPodKeys</code><code class="p">(</code><code class="nx">podsToDelete</code><code class="p">))</code>&#13;
        <code class="nx">errCh</code> <code class="o">:=</code> <code class="nb">make</code><code class="p">(</code><code class="kd">chan</code> <code class="kt">error</code><code class="p">,</code> <code class="nx">diff</code><code class="p">)</code>&#13;
        <code class="kd">var</code> <code class="nx">wg</code> <code class="nx">sync</code><code class="p">.</code><code class="nx">WaitGroup</code>&#13;
        <code class="nx">wg</code><code class="p">.</code><code class="nx">Add</code><code class="p">(</code><code class="nx">diff</code><code class="p">)</code>&#13;
        <code class="k">for</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">pod</code> <code class="o">:=</code> <code class="k">range</code> <code class="nx">podsToDelete</code> <code class="p">{</code>&#13;
            <code class="k">go</code> <code class="kd">func</code><code class="p">(</code><code class="nx">targetPod</code> <code class="o">*</code><code class="nx">v1</code><code class="p">.</code><code class="nx">Pod</code><code class="p">)</code> <code class="p">{</code>&#13;
                <code class="k">defer</code> <code class="nx">wg</code><code class="p">.</code><code class="nx">Done</code><code class="p">()</code>&#13;
                <code class="k">if</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">podControl</code><code class="p">.</code><code class="nx">DeletePod</code><code class="p">(</code>&#13;
                	<code class="nx">rs</code><code class="p">.</code><code class="nx">Namespace</code><code class="p">,</code>&#13;
                	<code class="nx">targetPod</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code>&#13;
                	<code class="nx">rs</code><code class="p">,</code>&#13;
                <code class="p">);</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
                    <code class="nx">podKey</code> <code class="o">:=</code> <code class="nx">controller</code><code class="p">.</code><code class="nx">PodKey</code><code class="p">(</code><code class="nx">targetPod</code><code class="p">)</code>&#13;
                    <code class="nx">klog</code><code class="p">.</code><code class="nx">V</code><code class="p">(</code><code class="mi">2</code><code class="p">).</code><code class="nx">Infof</code><code class="p">(</code><code class="s">"Failed to delete %v, decrementing "</code> <code class="o">+</code>&#13;
                    	<code class="s">"expectations for %v %s/%s"</code><code class="p">,</code>&#13;
                    	<code class="nx">podKey</code><code class="p">,</code> <code class="nx">rsc</code><code class="p">.</code><code class="nx">Kind</code><code class="p">,</code> <code class="nx">rs</code><code class="p">.</code><code class="nx">Namespace</code><code class="p">,</code> <code class="nx">rs</code><code class="p">.</code><code class="nx">Name</code><code class="p">,</code>&#13;
                    <code class="p">)</code>&#13;
                    <code class="nx">rsc</code><code class="p">.</code><code class="nx">expectations</code><code class="p">.</code><code class="nx">DeletionObserved</code><code class="p">(</code><code class="nx">rsKey</code><code class="p">,</code> <code class="nx">podKey</code><code class="p">)</code>&#13;
                    <code class="nx">errCh</code> <code class="o">&lt;-</code> <code class="nx">err</code>&#13;
                <code class="p">}</code>&#13;
            <code class="p">}(</code><code class="nx">pod</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
        <code class="nx">wg</code><code class="p">.</code><code class="nx">Wait</code><code class="p">()</code>&#13;
&#13;
        <code class="k">select</code> <code class="p">{</code>&#13;
        <code class="k">case</code> <code class="nx">err</code> <code class="o">:=</code> <code class="o">&lt;-</code><code class="nx">errCh</code><code class="p">:</code>&#13;
            <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
                <code class="k">return</code> <code class="nx">err</code>&#13;
            <code class="p">}</code>&#13;
        <code class="k">default</code><code class="p">:</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="kc">nil</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can see that the controller computes the difference between specification and current state in the line <code>diff</code> <code>:= len(filteredPods) - int(*(rs.Spec.Replicas))</code> and then implements two cases depending on that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>diff</code> <code>&lt;</code> <code>0</code>: Too few replicas; more pods must be created.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>diff</code> <code>&gt;</code> <code>0</code>: Too many replicas; pods must be deleted.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>It also implements a strategy to choose pods where it is least harmful to delete them in <code>getPodsToDelete</code>.</p>&#13;
&#13;
<p>Changing the resource state does not, however, necessarily mean that the resources themselves have to be part of the Kubernetes cluster. In other words, a controller can change the state of resources that are located outside of Kubernetes, such as a cloud storage service. For example, the <a href="http://bit.ly/2ItJcif">AWS Service Operator</a> allows you to manage AWS resources. Among other things, it allows you to manage S3 buckets—that is, the S3 controller is supervising a resource (the S3 bucket) that exists outside of Kubernetes, and the state changes reflect concrete phases in its lifecycle: an S3 bucket is created and at some point deleted.</p>&#13;
&#13;
<p>This should convince you that with a custom controller you can manage not only core resources, like pods, and custom resources, like our <code>cnat</code> example, but even compute or store resources that exist outside of Kubernetes. This makes controllers very flexible and powerful integration mechanisms, providing a unified way to use resources across platforms and environments.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimistic Concurrency" data-type="sect2"><div class="sect2" id="optimistic-concurrency">&#13;
<h2>Optimistic Concurrency</h2>&#13;
&#13;
<p>In <a data-type="xref" href="#controller-loop">“The Control Loop”</a>, we<a data-primary="controllers and operators" data-secondary="optimistic concurrency" data-type="indexterm" id="idm46336867951688"/><a data-primary="optimistic concurrency" data-type="indexterm" id="idm46336867950696"/><a data-primary="Kubernetes" data-secondary="optimistic concurrency in" data-type="indexterm" id="idm46336867950024"/> discussed in step 3 that a controller—after updating cluster objects and/or the external world according to the spec—writes the results into the status of the resource that triggered the controller run in step 1.</p>&#13;
&#13;
<p>This and actually any other write (also in step 2) can go wrong. In a distributed system, this controller is probably only one of many that update resources. Concurrent writes can fail because of write conflicts.</p>&#13;
&#13;
<p>To better understand what’s happening, let’s step back a bit and have a look at <a data-type="xref" href="#scheduling-archs">Figure 1-4</a>.<a data-primary="Omega (Google research paper)" data-type="indexterm" id="idm46336867946840"/><sup><a data-type="noteref" href="ch01.html#idm46336867946120" id="idm46336867946120-marker">2</a></sup></p>&#13;
&#13;
<figure><div class="figure" id="scheduling-archs">&#13;
<img alt="Scheduling architectures in distributed systems" src="assets/prku_0104.png"/>&#13;
<h6><span class="label">Figure 1-4. </span>Scheduling architectures in distributed systems</h6>&#13;
</div></figure>&#13;
&#13;
<p>The<a data-primary="parallel scheduler architecture" data-type="indexterm" id="idm46336867942520"/> source defines Omega’s parallel scheduler architecture as follows:</p>&#13;
<blockquote>&#13;
<p>Our solution is a new parallel scheduler architecture built around shared state, using lock-free optimistic concurrency control, to achieve both implementation extensibility and performance scalability. This architecture is being used in Omega, Google’s next-generation cluster management system.</p></blockquote>&#13;
&#13;
<p>While<a data-primary="Borg" data-type="indexterm" id="idm46336867940232"/> Kubernetes inherited a lot of traits and lessons learned from <a href="http://bit.ly/2XNSv5p">Borg</a>, this specific, transactional control plane feature comes from Omega: in order to carry out concurrent operations without locks, the Kubernetes API server uses optimistic <span class="keep-together">concurrency</span>.</p>&#13;
&#13;
<p>This means, in a nutshell, that if and when the API server detects concurrent write attempts, it rejects the latter of the two write operations. It is then up to the client (controller, scheduler, <code>kubectl</code>, etc.) to handle a conflict and potentially retry the write operation.</p>&#13;
&#13;
<p>The following demonstrates the idea of optimistic concurrency in Kubernetes:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">var err error&#13;
<code class="k">for</code> retries :<code class="o">=</code> 0<code class="p">;</code> retries &lt; 10<code class="p">;</code> retries++ <code class="o">{</code>&#13;
    foo, <code class="nv">err</code> <code class="o">=</code> client.Get<code class="o">(</code><code class="s2">"foo"</code>, metav1.GetOptions<code class="o">{})</code>&#13;
    <code class="k">if</code> err !<code class="o">=</code> nil <code class="o">{</code>&#13;
        <code class="nb">break</code>&#13;
    <code class="o">}</code>&#13;
&#13;
    &lt;update-the-world-and-foo&gt;&#13;
&#13;
    _, <code class="nv">err</code> <code class="o">=</code> client.Update<code class="o">(</code>foo<code class="o">)</code>&#13;
    <code class="k">if</code> err !<code class="o">=</code> nil <code class="o">&amp;&amp;</code> errors.IsConflict<code class="o">(</code>err<code class="o">)</code> <code class="o">{</code>&#13;
        <code class="k">continue</code>&#13;
    <code class="o">}</code> <code class="k">else</code> <code class="k">if</code> err !<code class="o">=</code> nil <code class="o">{</code>&#13;
        <code class="nb">break</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>The code shows a retry loop that gets the latest object <code>foo</code> in each iteration, then tries to update the world and <code>foo</code>’s status to match <code>foo</code>’s spec. The changes done before the <code>Update</code> call are optimistic.</p>&#13;
&#13;
<p>The returned object <code>foo</code> from the <code>client.Get</code> call<a data-primary="resource version" data-type="indexterm" id="idm46336867898280"/> contains a <em>resource version</em> (part of the embedded <code>ObjectMeta</code> struct—see <a data-type="xref" href="ch03.html#ObjectMeta">“ObjectMeta”</a> for details), which will tell <code>etcd</code> on the write operation behind the <code>client.Update</code> call that another actor in the cluster wrote the <code>foo</code> object in the meantime. If that’s the case, our retry loop<a data-primary="resource version conflict errors" data-type="indexterm" id="idm46336867894520"/><a data-primary="conflict errors" data-type="indexterm" id="idm46336867893848"/><a data-primary="errors" data-secondary="conflict errors" data-type="indexterm" id="idm46336867893176"/> will get a <em>resource version conflict error</em>. This means that the optimistic concurrency logic failed. In other words, the <code>client.Update</code> call is also optimistic.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The resource version is actually the <code>etcd</code> key/value version. The resource version of each object is a string in Kubernetes that contains an integer. This integer comes directly from <code>etcd</code>. <code>etcd</code> maintains a counter that increases each time the value of a key (which holds the object’s serialization) is modified.</p>&#13;
&#13;
<p>Throughout the API machinery code the resource version is (more or less consequently) handled like an arbitrary string, but with some ordering on it. The fact that integers are stored is just an implementation detail of the current <code>etcd</code> storage backend.</p>&#13;
</div>&#13;
&#13;
<p>Let’s look at a concrete example. Imagine your client is not the only actor in the cluster that modifies a pod. There<a data-primary="kubelet" data-type="indexterm" id="idm46336867887208"/> is another actor, namely the <code>kubelet</code>, that constantly modifies some fields because a container is constantly crashing. Now your controller reads the pod object’s latest state like so:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">foo</code>&#13;
  <code class="nt">resourceVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">57</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="l-Scalar-Plain">...</code>&#13;
<code class="nt">status</code><code class="p">:</code>&#13;
  <code class="l-Scalar-Plain">...</code></pre>&#13;
&#13;
<p>Now assume the controller needs several seconds with its updates to the world. Seven seconds later, it tries to update the pod it read—for example, it sets an annotation. Meanwhile, the <code>kubelet</code> has noticed yet another container restart and updated the pod’s status to reflect that; that is, <code>resourceVersion</code> has increased to 58.</p>&#13;
&#13;
<p>The object your controller sends in the update request has <code>resourceVersion: 57</code>. The API server tries to set the <code>etcd</code> key for the pod with that value. <code>etcd</code> notices that the resource versions do not match and reports back that 57 conflicts with 58. The update fails.</p>&#13;
&#13;
<p>The bottom line of this example is that for your controller, you are responsible for implementing a retry strategy and for adapting if an optimistic operation failed. You never know who else might be manipulating state, whether other custom controllers or core controllers such as the deployment controller.</p>&#13;
&#13;
<p>The essence of this is: <em>conflict errors are totally normal in controllers. Always expect them and handle them gracefully</em>.</p>&#13;
&#13;
<p>It’s important to point out that optimistic concurrency is a perfect fit for level-based logic, because by using level-based logic you can just rerun the control loop (see <a data-type="xref" href="#edge-vs-level">“Edge- Versus Level-Driven Triggers”</a>). Another run of that loop will automatically undo optimistic changes from the previous failed optimistic attempt, and it will try to update the world to the latest state.</p>&#13;
&#13;
<p>Let’s move on to a specific case of custom controllers (along with custom resources): the operator.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operators" data-type="sect2"><div class="sect2" id="operators-basics">&#13;
<h2>Operators</h2>&#13;
&#13;
<p>Operators<a data-primary="controllers and operators" data-secondary="operators" data-type="indexterm" id="idm46336867816744"/><a data-primary="operators" data-secondary="overview of" data-type="indexterm" id="idm46336867815768"/><a data-primary="CoreOS" data-type="indexterm" id="idm46336867814824"/> as a concept in Kubernetes were introduced by CoreOS in 2016. In his seminal blog post, <a href="http://bit.ly/2ZC4Rui">“Introducing Operators: Putting Operational Knowledge into Software”</a>, CoreOS CTO Brandon Philips defined operators as <span class="keep-together">follows</span>:</p>&#13;
<blockquote>&#13;
<p>A<a data-primary="Site Reliability Engineers (SREs)" data-type="indexterm" id="idm46336867811832"/> Site Reliability Engineer (SRE) is a person [who] operates an application by writing software. They are an engineer, a developer, who knows how to develop software specifically for a particular application domain. The resulting piece of software has an application’s operational domain knowledge programmed into it.</p>&#13;
&#13;
<p>[…]</p>&#13;
&#13;
<p>We call this new class of software Operators. An Operator is an application-specific controller that extends the Kubernetes API to create, configure, and manage instances of complex stateful applications on behalf of a Kubernetes user. It builds upon the basic Kubernetes resource and controller concepts but includes domain or application-specific knowledge to automate common tasks.</p></blockquote>&#13;
&#13;
<p>In the context of this book, we will use operators as Philips describes them and, more formally, require that the following three conditions hold (see also <a data-type="xref" href="#operator-conceptual">Figure 1-5</a>):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>There’s some domain-specific operational knowledge you’d like to automate.</p>&#13;
</li>&#13;
<li>&#13;
<p>The best practices for this operational knowledge are known and can be made explicit—for example, in the case of a Cassandra operator, when and how to re-balance nodes, or in the case of an operator for a service mesh, how to create a route.</p>&#13;
</li>&#13;
<li>&#13;
<p>The artifacts shipped in the context of the operator are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A<a data-primary="custom resource definitions (CRDs)" data-secondary="role of" data-type="indexterm" id="idm46336867803944"/> set of <em>custom resource definitions</em> (CRDs) capturing the domain-specific schema and custom resources following the CRDs that, on the instance level, represent the domain of interest.</p>&#13;
</li>&#13;
<li>&#13;
<p>A custom controller, supervising the custom resources, potentially along with core resources. For example, the custom controller might spin up a pod.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="operator-conceptual">&#13;
<img alt="The concept of an operator" src="assets/prku_0105.png"/>&#13;
<h6><span class="label">Figure 1-5. </span>The concept of an operator</h6>&#13;
</div></figure>&#13;
&#13;
<p>Operators<a data-primary="OperatorHub.io" data-type="indexterm" id="idm46336867777880"/> have <a href="http://bit.ly/2x5TSNw">come a long way</a> from the conceptual work and prototyping in 2016 to the launch of <a href="https://operatorhub.io">OperatorHub.io</a> by Red Hat (which acquired CoreOS in 2018 and continued to build out the idea) in early 2019. See <a data-type="xref" href="#operatorhub">Figure 1-6</a> for a screenshot of the hub in mid-2019 sporting some 17 operators, ready to be used.<a data-primary="" data-startref="Kcont01" data-type="indexterm" id="idm46336867774696"/></p>&#13;
&#13;
<figure><div class="figure" id="operatorhub">&#13;
<img alt="OperatorHub.io screen shot" src="assets/prku_0106.png"/>&#13;
<h6><span class="label">Figure 1-6. </span>OperatorHub.io screenshot</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46336874835288">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this first chapter we defined the scope of our book and what we expect from you. We explained what we mean by programming Kubernetes and defined Kubernetes-native apps in the context of this book. As preparation for later examples, we also provided a high-level introduction to controllers and operators.</p>&#13;
&#13;
<p>So, now that you know what to expect from the book and how you can benefit from it, let’s jump into the deep end. In the next chapter, we’ll take a closer look at the Kubernetes API, the API server’s inner workings, and how you can interact with the API using command-line tools such as <code>curl</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46336877072840"><sup><a href="ch01.html#idm46336877072840-marker">1</a></sup> For more on this topic, see Megan O’Keefe’s <a href="http://bit.ly/2WXfzu1">“A Kubernetes Developer Workflow for MacOS”</a>, <em>Medium</em>, January 24, 2019; and Alex Ellis’s blog post, <a href="http://bit.ly/2XkK9C1">“Be KinD to yourself”</a>, December 14, 2018.</p><p data-type="footnote" id="idm46336867946120"><sup><a href="ch01.html#idm46336867946120-marker">2</a></sup> Source: <a href="http://bit.ly/2PjYZ59">“Omega: Flexible, Scalable Schedulers for Large Compute Clusters”</a>, by Malte Schwarzkopf et al., Google AI, 2013.</p></div></div></section></body></html>