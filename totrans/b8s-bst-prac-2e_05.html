<html><head></head><body><section data-pdf-bookmark="Chapter 5. Continuous Integration, Testing, and Deployment" data-type="chapter" epub:type="chapter"><div class="chapter" id="continuous_integration_testing_and_deployment">&#13;
<h1><span class="label">Chapter 5. </span>Continuous Integration, Testing, <span class="keep-together">and Deployment</span></h1>&#13;
&#13;
&#13;
<p>In this chapter, we <a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="purpose of" data-type="indexterm" id="id609"/>look at the key concepts of how to integrate a continuous integration/continuous deployment (CI/CD) pipeline to deliver your applications to Kubernetes. Building a well-integrated pipeline will enable you to deliver applications to&#13;
production with confidence, so here we look at the methods, tools, and&#13;
processes to enable CI/CD in your environment. The goal of CI/CD is to have a&#13;
fully automated process, from a developer checking in code to rolling out&#13;
the new code to production. You want to avoid manually rolling out updates&#13;
to your apps deployed to Kubernetes because it can be very error prone.&#13;
Manually managing application updates in Kubernetes leads to&#13;
configuration drift and fragile deployment updates, and overall agility&#13;
delivering an application is lost.</p>&#13;
&#13;
<p>We cover the following topics in this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Version control</p>&#13;
</li>&#13;
<li>&#13;
<p>Continuous integration</p>&#13;
</li>&#13;
<li>&#13;
<p>Testing</p>&#13;
</li>&#13;
<li>&#13;
<p>Container builds</p>&#13;
</li>&#13;
<li>&#13;
<p>Container image tagging</p>&#13;
</li>&#13;
<li>&#13;
<p>Continuous deployment</p>&#13;
</li>&#13;
<li>&#13;
<p>Deployment strategies</p>&#13;
</li>&#13;
<li>&#13;
<p>Testing in production</p>&#13;
</li>&#13;
<li>&#13;
<p>Chaos testing</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p class="pagebreak-before">We also go through an example CI/CD pipeline, which consists of the&#13;
following tasks:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Pushing code changes to the Git repository</p>&#13;
</li>&#13;
<li>&#13;
<p>Running a build of the application code</p>&#13;
</li>&#13;
<li>&#13;
<p>Running test against the code</p>&#13;
</li>&#13;
<li>&#13;
<p>Building a container image on a successful test</p>&#13;
</li>&#13;
<li>&#13;
<p>Pushing the container image to a container registry</p>&#13;
</li>&#13;
<li>&#13;
<p>Deploying the application to Kubernetes</p>&#13;
</li>&#13;
<li>&#13;
<p>Running a test against a deployed application</p>&#13;
</li>&#13;
<li>&#13;
<p>Performing rolling upgrades on Deployments</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Version Control" data-type="sect1"><div class="sect1" id="id36">&#13;
<h1>Version Control</h1>&#13;
&#13;
<p>Every<a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="version control" data-type="indexterm" id="id610"/><a data-primary="version control" data-secondary="CI/CD" data-type="indexterm" id="id611"/> CI/CD pipeline starts with version control, which maintains a running history of application and configuration code changes. Git has become the industry standard as a source-control management platform, and every Git repository will contain <a data-primary="Git" data-type="indexterm" id="id612"/>a <em>main branch</em>. A main branch contains your production code. You will have other branches for feature and development work that eventually will be merged to your main branch. There are many ways to set up a branching strategy, and the setup will be very dependent on the organization structure and separation of duties. We find that including both application code and configuration code, such as&#13;
a Kubernetes manifest or Helm charts, helps promote good DevOps principles of communication and collaboration. Having both application developers and operation engineers collaborate in a single repository builds confidence in a team to deliver an application to production.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Continuous Integration" data-type="sect1"><div class="sect1" id="id37">&#13;
<h1>Continuous Integration</h1>&#13;
&#13;
<p>CI is <a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="continuous integration in" data-type="indexterm" id="id613"/><a data-primary="CI (continuous integration)" data-type="indexterm" id="id614"/>the process of integrating code changes continuously into a version-control repository. Instead of committing&#13;
large changes less often, you commit smaller changes more often. Each time a code change is committed to the repository, a build is kicked off. This allows you to have a quicker feedback loop into what might have broken the application if problems indeed arise. Many solutions provide CI, with Jenkins being one of the more popular tools. At this point you might be asking, “Why do I need to know about how the application is built; isn’t that the application developer’s role?” Traditionally, this might have been the&#13;
case, but as companies move toward embracing a DevOps culture, the operations team comes closer to the application code and software development workflows.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing" data-type="sect1"><div class="sect1" id="id200">&#13;
<h1>Testing</h1>&#13;
&#13;
<p>The goal<a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="testing in" data-type="indexterm" id="id615"/><a data-primary="testing" data-secondary="in CI/CD pipeline" data-secondary-sortas="CI/CD pipeline" data-type="indexterm" id="id616"/> of running tests in the pipeline is to quickly provide a&#13;
feedback loop for code changes that break the build. The language that you’re using will determine the testing framework you&#13;
use. For example, Go applications can use <code>go test</code> for running a suite of&#13;
unit tests against your code base. Having an extensive test suite helps to avoid delivering bad code into your production environment. You’ll&#13;
want to ensure that if tests fail in the pipeline, the build fails&#13;
after the test suite runs. You don’t want to build the container image&#13;
and push it to a registry if you have failing tests against your code&#13;
base.</p>&#13;
&#13;
<p>Again, you might be asking, “Isn’t creating tests a developer’s job?” As&#13;
you begin automating the delivery of infrastructure and applications to&#13;
production, you need to think about running automated tests against all&#13;
of the pieces of the code base. For example, in <a data-type="xref" href="ch02.html#developer_workflows">Chapter 2</a>, we talked&#13;
about using Helm to package applications for Kubernetes. Helm includes a&#13;
tool called <code>helm lint</code>, which runs a series of tests against a chart&#13;
to examine any potential issues with the chart provided. Many different tests need to be run in an end-to-end pipeline. Some are the developer’s responsibility, like unit testing for the application, but others, like smoke testing, will be a joint effort. Testing the code base and its delivery to production is a team effort and needs to be implemented end to end.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Container Builds" data-type="sect1"><div class="sect1" id="id38">&#13;
<h1>Container Builds</h1>&#13;
&#13;
<p>When <a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="image size optimization" data-type="indexterm" id="cicd-image-optimize"/><a data-primary="containers" data-secondary="image size optimization" data-type="indexterm" id="container-image-optimize"/><a data-primary="image management" data-secondary="size optimization" data-type="indexterm" id="image-mgmt-optimize"/><a data-primary="optimizing images" data-type="indexterm" id="optimize-image"/>building your images, you should optimize the size of the image.&#13;
Having a smaller image decreases the time it takes to pull and deploy the&#13;
image, and also increases the security of the image. There are multiple&#13;
ways of optimizing the image size, but some do have trade-offs. The&#13;
following strategies will help you build the smallest image possible for&#13;
your application:</p>&#13;
<dl>&#13;
<dt>Multistage builds</dt>&#13;
<dd>&#13;
<p>These <a data-primary="multistage builds" data-type="indexterm" id="id617"/>allow you to remove the dependencies not needed for&#13;
your applications to run. For example, with Golang, we don’t need all the build tools used to build the static binary, so multistage builds allow you to run a build step in a single Dockerfile with the final image containing only the static binary that’s needed to run the application.</p>&#13;
</dd>&#13;
<dt>Distroless base images</dt>&#13;
<dd>&#13;
<p>These remove<a data-primary="distroless images" data-type="indexterm" id="id618"/> all the unneeded binaries and shells from&#13;
the image. This reduces the size of the image and increases the&#13;
security. The trade-off with distroless images is you don’t have a shell,&#13;
so you can’t attach a debugger to the image. You might think this is great,&#13;
but it can be a pain to debug an application. Distroless images contain no&#13;
package manager, shell, or other typical OS packages, so you might not have&#13;
access to the debugging tools you are accustomed to with a typical OS.</p>&#13;
</dd>&#13;
<dt>Optimized base images</dt>&#13;
<dd>&#13;
<p>These are<a data-primary="optimized base images" data-type="indexterm" id="id619"/> images that focus on removing the cruft out&#13;
of the OS layer and provide a slimmed-down image. For example, Alpine&#13;
provides a base image that starts at just 10 MB, and it allows you&#13;
to attach a local debugger for local development. Other distros also&#13;
typically offer an optimized base image, such as Debian’s Slim image.&#13;
This might be a good option for you because its optimized images give you the capabilities you expect for development while also optimizing for image size and lower security exposure.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Optimizing your images is extremely important and often overlooked by&#13;
users. You might have obstacles due to company standards for OSes that are approved for use in the enterprise, but push back on&#13;
these so that you can maximize the value of <span class="keep-together">containers.</span></p>&#13;
&#13;
<p>We have found that companies starting out with Kubernetes tend to be successful with initially using their current OS but then choose a more optimized image, like Debian Slim. After you mature in operationalizing and developing against a container environment, you’ll be comfortable with distroless<a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="image size optimization" data-startref="cicd-image-optimize" data-type="indexterm" id="id620"/><a data-primary="containers" data-secondary="image size optimization" data-startref="container-image-optimize" data-type="indexterm" id="id621"/><a data-primary="image management" data-secondary="size optimization" data-startref="image-mgmt-optimize" data-type="indexterm" id="id622"/><a data-primary="optimizing images" data-startref="optimize-image" data-type="indexterm" id="id623"/> images.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Container Image Tagging" data-type="sect1"><div class="sect1" id="id39">&#13;
<h1>Container Image Tagging</h1>&#13;
&#13;
<p>Another<a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="image tagging" data-type="indexterm" id="cicd-image-tag"/><a data-primary="containers" data-secondary="image tagging" data-type="indexterm" id="container-image-tag"/><a data-primary="image management" data-secondary="tagging" data-type="indexterm" id="image-mgmt-tag"/><a data-primary="tagging images" data-type="indexterm" id="tag-image"/> step in the CI pipeline is to build a container image so that you&#13;
have an image artifact to deploy to an environment. It’s important to&#13;
have an image-tagging strategy so that you can easily identify the versioned&#13;
images you have deployed to your environments. We can’t preach enough about one of the most important things: do not use  “latest” as an image tag.&#13;
Using that as an image tag is not a <em>version</em> and will lead to not&#13;
having the ability to identify what code change belongs to the rolled-out image. Every image that is built in the CI pipeline should have a&#13;
unique tag.</p>&#13;
&#13;
<p>There are multiple strategies we’ve found to be effective when&#13;
tagging images in the CI pipeline. The following strategies&#13;
allow you to easily identify the code changes and the build with which&#13;
they are associated:</p>&#13;
<dl>&#13;
<dt class="arabic">BuildID</dt>&#13;
<dd>&#13;
<p>When a CI build kicks off, it has a buildID associated with it. Using this part of the tag allows you to reference which build assembled the image.</p>&#13;
</dd>&#13;
<dt class="arabic">Build System-buildID</dt>&#13;
<dd>&#13;
<p>This tag is the same as BuildID but adds the Build System for&#13;
users who have multiple build systems.</p>&#13;
</dd>&#13;
<dt class="arabic">Git hash</dt>&#13;
<dd>&#13;
<p>On new code commits, a Git hash is generated, and using the&#13;
hash for the tag allows you to easily reference which commit generated&#13;
the image.</p>&#13;
</dd>&#13;
<dt class="arabic">githash-buildID</dt>&#13;
<dd>&#13;
<p>This allows you to reference both the code commit&#13;
and the buildID that generated the image. The only caution here is that the&#13;
tag can be kind <a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="image tagging" data-startref="cicd-image-tag" data-type="indexterm" id="id624"/><a data-primary="containers" data-secondary="image tagging" data-startref="container-image-tag" data-type="indexterm" id="id625"/><a data-primary="image management" data-secondary="tagging" data-startref="image-mgmt-tag" data-type="indexterm" id="id626"/><a data-primary="tagging images" data-startref="tag-image" data-type="indexterm" id="id627"/>of long.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Continuous Deployment" data-type="sect1"><div class="sect1" id="id40">&#13;
<h1>Continuous Deployment</h1>&#13;
&#13;
<p>CD is <a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="continuous deployment in" data-type="indexterm" id="id628"/><a data-primary="CD (continuous delivery)" data-secondary="testing, importance of" data-type="indexterm" id="id629"/>the process by which changes that have passed&#13;
successfully through the CI pipeline are deployed to&#13;
production without human intervention. Containers provide a great&#13;
advantage for deploying changes into production. Container images become&#13;
an immutable object that can be promoted through dev and staging and into&#13;
production. For example, a major issue we’ve&#13;
always had has been maintaining consistent environments. Almost everyone has&#13;
experienced a Deployment that works fine in staging, but when it gets&#13;
promoted to production, it breaks. This is due to <a data-primary="configuration drift" data-type="indexterm" id="id630"/>having <em>configuration&#13;
drift</em>, with libraries and versioning of components differing in each&#13;
environment. Kubernetes gives us a declarative way to describe our&#13;
Deployment objects that can be versioned and deployed consistently.</p>&#13;
&#13;
<p>One thing to keep in mind is that you need a solid CI&#13;
pipeline set up before focusing on CD. If you don’t have a robust set of tests to catch issues early in the pipeline, you’ll end up rolling bad code to all your environments.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deployment Strategies" data-type="sect1"><div class="sect1" id="id41">&#13;
<h1>Deployment Strategies</h1>&#13;
&#13;
<p>Now that<a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="deployment strategies" data-type="indexterm" id="cicd-strategies"/><a data-primary="deployment strategies" data-type="indexterm" id="deploy-strategies"/> we learned the principles of CD, let’s look at the different rollout strategies you can use. Kubernetes&#13;
provides multiple strategies to roll out new versions of your&#13;
application. And even though it has a built-in mechanism to provide rolling&#13;
updates, you can also utilize more advanced strategies. Here, we examine the following strategies to deliver updates to your application:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Rolling updates</p>&#13;
</li>&#13;
<li>&#13;
<p>Blue/green deployments</p>&#13;
</li>&#13;
<li>&#13;
<p>Canary deployments</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><em>Rolling updates</em> are<a data-primary="rolling updates" data-type="indexterm" id="rolling-update"/> built into Kubernetes and allow you to trigger an&#13;
update to the currently running application without downtime. For&#13;
example, if you took your frontend app that is currently running&#13;
frontend:v1 and updated the Deployment to frontend:v2, Kubernetes&#13;
would update the replicas in a rolling fashion to frontend:v2. <a data-type="xref" href="#rolling_update">Figure 5-1</a> depicts a rolling update.</p>&#13;
&#13;
<figure><div class="figure" id="rolling_update">&#13;
<img alt="A Kubernetes rolling update" src="assets/kbp2_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>A Kubernetes rolling update</h6>&#13;
</div></figure>&#13;
&#13;
<p>A Deployment object also lets you configure the maximum amount of replicas&#13;
to be updated and the maximum unavailable pods during the rollout. The following&#13;
manifest is an example of how you specify the rolling update strategy:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">brendanburns/frontend:v1</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">strategy</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RollingUpdate</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">rollingUpdate</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">maxSurge</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"> </code><code class="c1"># Maximum amount of replicas to update at one time</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">maxUnavailable</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1</code><code class="w"> </code><code class="c1"># Maximum amount of replicas unavailable during rollout</code><code class="w"/></pre>&#13;
&#13;
<p>You need to be cautious with rolling updates because using this strategy&#13;
can cause dropped connections. To deal with this issue, you can<a data-primary="readiness probes" data-type="indexterm" id="id631"/><a data-primary="preStop life-cycle hooks" data-type="indexterm" id="id632"/> utilize&#13;
<em>readiness probes</em> and <em>preStop</em> life-cycle hooks. The readiness probe&#13;
ensures that the new version deployed is ready to accept traffic, whereas&#13;
the preStop hook can ensure that connections are drained on the current&#13;
deployed application. The life-cycle hook is called before the container&#13;
exits and is synchronous, so it must complete before the final&#13;
termination signal is given. The following example implements a readiness&#13;
probe and life-cycle hook:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">frontend</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">brendanburns/frontend:v1</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">livenessProbe</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="c1"># ...</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">readinessProbe</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">httpGet</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/readiness</code><code class="w"> </code><code class="c1"># probe endpoint</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8888</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">lifecycle</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">preStop</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">exec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"/usr/sbin/nginx"</code><code class="p-Indicator">,</code><code class="s">"-s"</code><code class="p-Indicator">,</code><code class="s">"quit"</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">strategy</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1"># ...</code><code class="w"/></pre>&#13;
&#13;
<p>The preStop life-cycle hook in this example will gracefully exit NGINX, whereas a SIGTERM conducts a nongraceful, quick exit.</p>&#13;
&#13;
<p>Another concern with rolling updates is that you now have two versions of the application running at the same time during the rollover. Your database schema needs to support both versions of the application. You can also use a feature flag strategy in which your schema indicates the new columns created by the new app version. After the rolling update has completed, the old columns can be removed.</p>&#13;
&#13;
<p class="pagebreak-before">We have also defined a readiness and liveness probe in our Deployment manifest. A readiness probe will ensure that your application is ready to serve traffic before putting it behind the service as an endpoint. The liveness probe ensures that your application is healthy and running, and it restarts the pod if it fails its liveness probe. Kubernetes can automatically restart a failed pod only if the pod exits on error. For example, the liveness probe can check its endpoint and restart it if we had a deadlock from which the pod did not<a data-primary="rolling updates" data-startref="rolling-update" data-type="indexterm" id="id633"/> exit.</p>&#13;
&#13;
<p><em>Blue/green deployments</em> allow <a data-primary="blue/green deployments" data-type="indexterm" id="bluegreen"/>you to release your application predictably. With blue/green deployments, you control when the traffic is shifted&#13;
over to the new environment, so it gives you a lot of control over the&#13;
rollout of a new version of your application. With blue/green deployments, you&#13;
are required to have the capacity to deploy both the existing and new&#13;
environment at the same time. These types of deployments have a&#13;
lot of advantages, such as easily switching back to your previous version of the application. There are some things that you need to consider with this deployment strategy, however:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Database migrations can become difficult with this deployment option because you need to consider in-flight transactions and schema update&#13;
compatibility.</p>&#13;
</li>&#13;
<li>&#13;
<p>There is the risk of accidental deletion of both environments.</p>&#13;
</li>&#13;
<li>&#13;
<p>You need extra capacity for both environments.</p>&#13;
</li>&#13;
<li>&#13;
<p>There are coordination issues for hybrid deployments in which legacy apps can’t handle the&#13;
deployment.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#blue_green_deployment">Figure 5-2</a> depicts a blue/green deployment.</p>&#13;
&#13;
<figure><div class="figure" id="blue_green_deployment">&#13;
<img alt="A blue/green deployment" src="assets/kbp2_0502.png"/>&#13;
<h6><span class="label">Figure 5-2. </span>A blue/green deployment</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before"><em>Canary deployments</em> are<a data-primary="canary deployments" data-type="indexterm" id="canary"/> very similar to blue/green deployments, but they give you&#13;
much more control over shifting traffic to the new release. Most modern&#13;
Ingress implementations will give you the ability to release a&#13;
percentage of traffic to a new release, but you can also implement a&#13;
service mesh technology, like Istio, Linkerd, or HashiCorp Consul, which gives you a number of features that help implement this deployment strategy.</p>&#13;
&#13;
<p>Canary deployments allow you to test new features for only a subset of users. For example, you might roll out a new version of an application and want to test the deployment for only 10% of your user base. This allows you to reduce the risk of a bad deployment or broken features to a much smaller subset of users. If there are no errors with the deployment or new features, you can begin shifting a greater percentage of traffic to the new version of the application. There are also more advanced techniques that you can use with canary deployments in which you&#13;
release to only a specific region of users or only target users with a specific profile. These types of releases are often referred to as A/B or dark releases because users are unaware they are testing new feature deployments.</p>&#13;
&#13;
<p>With canary deployments, you have some of the same considerations that&#13;
you have with blue/green deployments, but there are some additional considerations as well. You must have:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The ability to shift traffic to a percentage of users</p>&#13;
</li>&#13;
<li>&#13;
<p>A firm knowledge of steady state to compare against a new release</p>&#13;
</li>&#13;
<li>&#13;
<p>Metrics to understand whether the new release is in a “good” or “bad”&#13;
state</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#canary_development">Figure 5-3</a> provides an example of a canary deployment.</p>&#13;
&#13;
<figure><div class="figure" id="canary_development">&#13;
<img alt="A canary deployment" src="assets/kbp2_0503.png"/>&#13;
<h6><span class="label">Figure 5-3. </span>A canary deployment</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Canary releases also suffer from having multiple versions of the application running at the same time. Your database schema needs to support both versions of the application. When using these strategies, you’ll need to focus on how to handle dependent services and having multiple versions running. This includes having strong API contracts and ensuring that your data services support the multiple versions you have deployed at the<a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="deployment strategies" data-startref="cicd-strategies" data-type="indexterm" id="id634"/><a data-primary="deployment strategies" data-startref="deploy-strategies" data-type="indexterm" id="id635"/><a data-primary="canary deployments" data-startref="canary" data-type="indexterm" id="id636"/> same time.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing in Production" data-type="sect1"><div class="sect1" id="id42">&#13;
<h1>Testing in Production</h1>&#13;
&#13;
<p>Testing in <a data-primary="testing" data-secondary="in production" data-secondary-sortas="production" data-type="indexterm" id="test-production"/><a data-primary="production, testing in" data-type="indexterm" id="production-test"/>production helps you to build confidence in the resiliency,&#13;
scalability, and UX of your application. This comes with the caveat that <em>testing in production</em> doesn’t come without challenges and risk,&#13;
but it’s worth the effort to ensure reliability in your systems. There are&#13;
important aspects you need to address up front when embarking on the&#13;
implementation. You need to ensure that you have an in-depth observability&#13;
strategy in place, in which you have the ability to identify the effects of&#13;
testing in production. Without being able to observe metrics that&#13;
affect the end users’ experience of your applications, you won’t have a&#13;
clear indication of what to focus on when trying to improve the resiliency of your system. You&#13;
also need a high degree of automation in place to be able to&#13;
automatically recover from failures that you inject into your <span class="keep-together">systems.</span></p>&#13;
&#13;
<p>You’ll need to implement many tools to reduce risk and effectively test your systems when they’re in production. We have discussed some tools in this chapter, but there are some new ones, like distributed tracing, instrumentation, chaos engineering, and&#13;
traffic shadowing. To recap, here are the tools we have already mentioned:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Canary deployments</p>&#13;
</li>&#13;
<li>&#13;
<p>Blue/green deployments</p>&#13;
</li>&#13;
<li>&#13;
<p>Traffic shifting</p>&#13;
</li>&#13;
<li>&#13;
<p>Feature flags</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Chaos engineering was<a data-primary="chaos engineering" data-type="indexterm" id="id637"/> developed by Netflix. It is the&#13;
practice of deploying experiments into live production systems to&#13;
discover weaknesses within those systems. Chaos engineering allows you to learn about the&#13;
behavior of your system by observing it during a controlled experiment.&#13;
Following are the steps that you want to implement before doing a “game-day” experiment:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Build a hypothesis and learn about your steady state.</p>&#13;
</li>&#13;
<li>&#13;
<p>Have a varying degree of real-world events that can affect the system.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<ol class="pagebreak-before" start="3">&#13;
<li>&#13;
<p>Build a control group and experiment to compare to steady state.</p>&#13;
</li>&#13;
<li>&#13;
<p>Perform experiments to test the hypothesis.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>It’s extremely important that when you’re running experiments, you minimize&#13;
the “blast radius” to ensure that the issues that might arise are minimal. You’ll&#13;
also want to ensure that when you’re building experiments, you focus on&#13;
automating them, given that running experiments can be labor intensive.</p>&#13;
&#13;
<p>By this point, <a data-primary="testing" data-secondary="in staging" data-secondary-sortas="staging" data-type="indexterm" id="id638"/><a data-primary="staging, testing in" data-type="indexterm" id="id639"/>you might be asking, “Why wouldn’t I just test in&#13;
staging?” We find there are some inherent problems when testing in&#13;
staging, such as the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Nonidentical deployment of resources.</p>&#13;
</li>&#13;
<li>&#13;
<p>Configuration drift from production.</p>&#13;
</li>&#13;
<li>&#13;
<p>Traffic and user behavior tend to be generated synthetically.</p>&#13;
</li>&#13;
<li>&#13;
<p>The number of requests generated don’t mimic a real workload.</p>&#13;
</li>&#13;
<li>&#13;
<p>Lack of monitoring implemented in staging.</p>&#13;
</li>&#13;
<li>&#13;
<p>The data services deployed contain differing data and load than in&#13;
production.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We can’t stress this enough: ensure that you have solid confidence in&#13;
the monitoring you have in place for production, because this practice tends&#13;
to fail users who don’t have adequate observability of their production&#13;
systems. Also, starting with smaller experiments to first learn about&#13;
your experiments and their effects will help build <a data-primary="testing" data-secondary="in production" data-secondary-sortas="production" data-startref="test-production" data-type="indexterm" id="id640"/><a data-primary="production, testing in" data-startref="production-test" data-type="indexterm" id="id641"/>confidence.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up a Pipeline and Performing a Chaos Experiment" data-type="sect1"><div class="sect1" id="id201">&#13;
<h1>Setting Up a Pipeline and Performing a Chaos Experiment</h1>&#13;
&#13;
<p>The <a data-primary="application example" data-secondary="CI/CD workflow" data-type="indexterm" id="app-example-cicd"/><a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="application example" data-type="indexterm" id="cicd-example"/>first step in the process is to fork a GitHub repository so that&#13;
you can have your own repository to use throughout the chapter. You will&#13;
need to use the GitHub interface to fork the <a href="https://oreil.ly/TtJfd">sample application repository</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up CI" data-type="sect2"><div class="sect2" id="id43">&#13;
<h2>Setting Up CI</h2>&#13;
&#13;
<p>Now that<a data-primary="CI (continuous integration)" data-type="indexterm" id="ci-example"/> you have learned about CI, you will set up a&#13;
build of the code that we cloned previously.</p>&#13;
&#13;
<p>For this example, we<a data-primary="Drone" data-type="indexterm" id="id642"/> use the hosted <em>drone.io</em>. You’ll need to <a href="https://cloud.drone.io">sign up for a free account</a>. Log in with your GitHub credentials (this registers your repositories in Drone and allows you to synchronize the repositories). After you’re logged in to Drone, select Activate on your forked repository. The first thing that you need to do is add some secrets to&#13;
your settings so that you can push the app to your Docker Hub registry and also&#13;
deploy the app to your Kubernetes cluster.</p>&#13;
&#13;
<p>Under your repository in Drone, click Settings and add the following&#13;
secrets (see <a data-type="xref" href="#fig0504">Figure 5-4</a>):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>docker_username</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>docker_password</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>kubernetes_server</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>kubernetes_cert</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>kubernetes_token</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure class="width-60"><div class="figure" id="fig0504">&#13;
<img alt="Drone secrets configuration" src="assets/kbp2_0504.png"/>&#13;
<h6><span class="label">Figure 5-4. </span>Drone secrets configuration</h6>&#13;
</div></figure>&#13;
&#13;
<p>The Docker username and password will be whatever you used to register&#13;
on Docker Hub. The following steps show how to create a Kubernetes&#13;
service account and certificate and retrieve the token.</p>&#13;
&#13;
<p>For the Kubernetes server, you will need a publicly available Kubernetes API <span class="keep-together">endpoint.</span></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You will need cluster-admin privileges on your Kubernetes cluster to perform the steps in this section.</p>&#13;
</div>&#13;
&#13;
<p>You can retrieve your API endpoint by using the following command:</p>&#13;
<pre>kubectl cluster-info</pre>&#13;
&#13;
<p>You should see something like the following: Kubernetes master is running&#13;
at https://kbp.centralus.azmk8s.io:443. You’ll store this in the <code>kubernetes_server</code> secret.</p>&#13;
&#13;
<p>Now let’s create a service account that Drone will use to connect to the&#13;
cluster. Use the following command to create the <code>serviceaccount</code>:</p>&#13;
<pre>kubectl create serviceaccount drone</pre>&#13;
&#13;
<p>Next, use the following command to create a <code>clusterrolebinding</code> for the&#13;
<code>service​ac⁠count</code>:</p>&#13;
<pre>kubectl create clusterrolebinding drone-admin \&#13;
  --clusterrole=cluster-admin \&#13;
  --serviceaccount=default:drone</pre>&#13;
&#13;
<p>Now retrieve your <code>serviceaccount</code> token:</p>&#13;
<pre>TOKENNAME=`kubectl -n default get serviceaccount/drone&#13;
    -o jsonpath='{.secrets[0].name}'`&#13;
TOKEN=`kubectl -n default get secret $TOKENNAME -o jsonpath='{.data.token}' |&#13;
    base64 -d`&#13;
echo $TOKEN</pre>&#13;
&#13;
<p>You’ll want to store the output of the token in the <code>kubernetes_token</code> secret.</p>&#13;
&#13;
<p>You will also need the user certificate to authenticate to the cluster, so use&#13;
the following command and paste the <code>ca.crt</code> for the <code>kubernetes_cert</code> secret:</p>&#13;
<pre>kubectl get secret $TOKENNAME -o yaml | grep 'ca.crt:'</pre>&#13;
&#13;
<p>Now, build your app in a Drone pipeline and then push it to Docker Hub.</p>&#13;
&#13;
<p>The first step is the <em>build step</em>, which will build your Node.js&#13;
frontend. Drone utilizes container images to run its steps, which gives&#13;
you a lot of flexibility in what you can do with it. For the build&#13;
step, use a Node.js image from Docker Hub:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">pipeline</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">build</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">node</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">commands</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">cd frontend</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">npm i redis --save</code><code class="w"/></pre>&#13;
&#13;
<p>When the build completes, you’ll want to test it, so we include a <em>test step</em>, which will run <code>npm</code> against the newly built app:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">test</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">node</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">commands</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">cd frontend</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">npm i redis --save</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">npm test</code><code class="w"/></pre>&#13;
&#13;
<p>Now that you have successfully built and tested your app, you will move on to a&#13;
<em>publish step</em> to create a container image of the app and push it to&#13;
Docker Hub.</p>&#13;
&#13;
<p>In the <em>.drone.yml</em> file, make the following code change:</p>&#13;
<pre>repo: &lt;your-registry&gt;/frontend</pre>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">publish</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">plugins/docker</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">dockerfile</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">./frontend/Dockerfile</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">context</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">./frontend</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">repo</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">dstrebel/frontend</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">tags</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">latest</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">v2</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">secrets</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="nv">docker_username</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">docker_password</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/></pre>&#13;
&#13;
<p>After the Docker build step finishes, it will push the image to your&#13;
Docker <a data-primary="CI (continuous integration)" data-startref="ci-example" data-type="indexterm" id="id643"/>registry.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up CD" data-type="sect2"><div class="sect2" id="id202">&#13;
<h2>Setting Up CD</h2>&#13;
&#13;
<p>For the <a data-primary="CD (continuous delivery)" data-secondary="setting up" data-type="indexterm" id="id644"/>deployment step in your pipeline, you will push your application&#13;
to your Kubernetes cluster. You will use the deployment manifest that is&#13;
under the frontend app folder in your repository:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kubectl</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">dstrebel/drone-kubectl-helm</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">secrets</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="nv">kubernetes_server</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">kubernetes_cert</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">kubernetes_token</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">kubectl</code><code class="p">:</code><code class="w"> </code><code class="s">"apply</code><code class="nv"> </code><code class="s">-f</code><code class="nv"> </code><code class="s">./frontend/deployment.yaml"</code><code class="w"/></pre>&#13;
&#13;
<p>After the pipeline finishes its deployment, you will see the pods&#13;
running in your cluster. Run the following command to confirm that the pods are running:</p>&#13;
<pre>kubectl get pods</pre>&#13;
&#13;
<p>You can also add a test step that will retrieve the status of the&#13;
deployment by adding the following step in your Drone pipeline:</p>&#13;
<pre>  test-deployment:&#13;
    image: dstrebel/drone-kubectl-helm&#13;
    secrets: [ kubernetes_server, kubernetes_cert, kubernetes_token ]&#13;
    kubectl: "get deployment frontend"</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performing a Rolling Upgrade" data-type="sect2"><div class="sect2" id="id44">&#13;
<h2>Performing a Rolling Upgrade</h2>&#13;
&#13;
<p>Let’s <a data-primary="rolling updates" data-type="indexterm" id="id645"/>demonstrate a rolling upgrade by changing a line in the&#13;
frontend code. In the <em>server.js</em> file, change the following line and then commit the change:</p>&#13;
<pre>console.log('api server is running.');</pre>&#13;
&#13;
<p>You will see the deployment rolling out and rolling updates&#13;
happening to the existing pods. After the rolling update finishes, you’ll have the new version of the application deployed.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Simple Chaos Experiment" data-type="sect2"><div class="sect2" id="id45">&#13;
<h2>A Simple Chaos Experiment</h2>&#13;
&#13;
<p>A variety<a data-primary="chaos engineering" data-type="indexterm" id="chaos-engineer"/> of tools in the Kubernetes ecosystem can help with&#13;
performing chaos experiments in your environment. They range from&#13;
sophisticated hosted  Chaos as a Service solutions to basic chaos experiment tools that kill pods in your environment. Following are some of the successful tools:</p>&#13;
<dl>&#13;
<dt>Gremlin</dt>&#13;
<dd>&#13;
<p>Hosted <a data-primary="Gremlin" data-type="indexterm" id="id646"/>chaos service that provides advanced features for&#13;
running chaos <span class="keep-together">experiments</span></p>&#13;
</dd>&#13;
<dt>PowerfulSeal</dt>&#13;
<dd>&#13;
<p>Open source project <a data-primary="PowerfulSeal" data-type="indexterm" id="id647"/>that provides advanced chaos&#13;
scenarios</p>&#13;
</dd>&#13;
<dt>Chaos Toolkit</dt>&#13;
<dd>&#13;
<p>Open source project<a data-primary="Chaos Toolkit" data-type="indexterm" id="id648"/> with a mission to provide a&#13;
free, open, and community-driven toolkit and API to all the various forms&#13;
of chaos engineering tools</p>&#13;
</dd>&#13;
<dt>KubeMonkey</dt>&#13;
<dd>&#13;
<p>Open source<a data-primary="KubeMonkey" data-type="indexterm" id="id649"/> tool that provides basic resiliency testing&#13;
for pods in your cluster</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Let’s set up a quick chaos experiment to test the resiliency of your&#13;
application by automatically terminating pods. For this experiment, we’ll use <a data-primary="application example" data-secondary="CI/CD workflow" data-startref="app-example-cicd" data-type="indexterm" id="id650"/><a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="application example" data-startref="cicd-example" data-type="indexterm" id="id651"/>Chaos Toolkit:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">pip<code class="w"> </code>install<code class="w"> </code>-U<code class="w"> </code>chaostoolkit<code class="w"/></pre>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">pip<code class="w"> </code>install<code class="w"> </code>chaostoolkit-kubernetes<code class="w"/></pre>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nb">export</code><code class="w"> </code><code class="nv">FRONTEND_URL</code><code class="o">=</code><code class="s2">"http://</code><code class="k">$(</code>kubectl<code class="w"> </code>get<code class="w"> </code>svc<code class="w"> </code>frontend<code class="w"/>&#13;
<code class="w">    </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s2">"{.status.loadBalancer.ingress[*].ip}"</code><code class="k">)</code><code class="s2">:8080/api/"</code><code class="w"/></pre>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">chaos<code class="w"> </code>run<code class="w"> </code>experiment.json<code class="w"/></pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Best Practices for CI/CD" data-type="sect1"><div class="sect1" id="id203">&#13;
<h1>Best Practices for CI/CD</h1>&#13;
&#13;
<p>Your <a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="best practices" data-type="indexterm" id="cicd-best-practice"/><a data-primary="best practices" data-secondary="CI/CD workflow" data-type="indexterm" id="best-practice-cicd"/>CI/CD pipeline won’t be perfect on day one, but consider some of the&#13;
following best practices to iteratively improve on the pipeline:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>With CI, focus on automation and providing quick&#13;
builds. Optimizing the build speed will provide developers quick&#13;
feedback if their changes have broken the build.</p>&#13;
</li>&#13;
<li>&#13;
<p>Focus on providing reliable tests in your pipeline. This will give&#13;
developers rapid feedback on issues with their code. The faster the&#13;
feedback loop to developers, the more productive they’ll become in their&#13;
workflow.</p>&#13;
</li>&#13;
<li>&#13;
<p>When deciding on CI/CD tools, ensure that the tools allow you to define the&#13;
pipeline as code. This will allow you to version-control the pipeline&#13;
with your application code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ensure that you optimize your images so that you can reduce the size of&#13;
the image and also reduce the attack surface when running the image in&#13;
production. Multistage Docker builds allow you to remove packages not&#13;
needed for the application to run. For example, you might need Maven to&#13;
build the application, but you don’t need it for the actual running&#13;
image.</p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid using “latest” as an image tag, and utilize a <em>tag</em> that can be&#13;
referenced back to the buildID or Git commit.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you are new to CD, utilize Kubernetes rolling&#13;
updates to start. They are easy to use and will get you&#13;
comfortable with deployment. As you become more comfortable and confident&#13;
with CD, look at utilizing blue/green and canary deployment&#13;
strategies.</p>&#13;
</li>&#13;
<li>&#13;
<p>With CD, ensure that you test how client connections&#13;
and database schema upgrades are handled in your application.</p>&#13;
</li>&#13;
<li>&#13;
<p>Testing in production will help you build reliability into your&#13;
application and ensure that you have good monitoring in place. With testing&#13;
in production, also start at a small scale and limit the blast radius of&#13;
the<a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="best practices" data-startref="cicd-best-practice" data-type="indexterm" id="id652"/><a data-primary="best practices" data-secondary="CI/CD workflow" data-startref="best-practice-cicd" data-type="indexterm" id="id653"/> experiment.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id352">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we discussed the stages of building a CI/CD pipeline for&#13;
your applications, which let you reliably deliver software with&#13;
confidence. CI/CD pipelines help reduce risk and increase throughput of&#13;
delivering applications to Kubernetes. We also discussed the different&#13;
deployment strategies that can be utilized for delivering <span class="keep-together">applications.</span></p>&#13;
</div></section>&#13;
</div></section></body></html>