["```\nconst mysteryObject = new Date(2021, 2, 1);\n\nif (mysteryObject instanceof Date) {\n  // We end up here because mysteryObject is a Date\n}\n```", "```\nif (!(mysteryObject instanceof Date)) {\n  // You get here if mysteryObject isn't a Date\n}\n\n// Don't make this mistake!\nif (!mysteryObject instanceof Date) {\n  // This code never runs\n}\n```", "```\nconst testNumber = 42;\nif (testNumber instanceof Number) {\n  // This code never runs\n}\n\nconst testString = 'Hello';\nif (testString instanceof String) {\n  // This code never runs\n}\n\n// The following two tests work because the primitives are wrapped in objects,\n// but that's uncommon in modern JavaScript.\nconst numberObject = new Number(42);\nif (numberObject instanceof Number) {\n  // This code runs\n}\n\nconst stringObject = new String('Hello');\nif (stringObject instanceof String) {\n  // This code runs\n}\n```", "```\nconst mysteryPrimitive = 42;\nconst mysteryObject = new Date();\n\nif (typeof mysteryPrimitive === 'number') {\n  // This code runs\n}\n\nif (typeof mysteryObject === 'object') {\n  // This code runs, because a Date is an object, not a primitive\n\n  if (mysteryObject instanceof Date) {\n    // This code also runs\n  }\n}\n```", "```\nif (mysteryObject instanceof Object) {\n  // This is true, unless mysteryObject is a primitive type\n}\n```", "```\nconst employee = {\n  employeeId: 402,\n  firstName: 'Lisa',\n  lastName: 'Stanecki',\n  birthDate: new Date(1995, 8, 15)\n};\n\nconsole.log(employee.firstName);  // 'Lisa'\n```", "```\nemployee.role = 'Manager';\n```", "```\nconst employee = new Object();\nemployee.employeeId = 402;\nemployee.firstName = 'Lisa';\nemployee.lastName = 'Stanecki';\nemployee.birthDate = new Date(1995, 8, 15);\n```", "```\nconst employee = new Object();\nemployee['employeeId'] = 402;\nemployee['firstName'] = 'Lisa';\nemployee['lastName'] = 'Stanecki';\nemployee['birthDate'] = new Date(1995, 8, 15);\n```", "```\nconst employee = {\n  employeeId: 402,\n  firstName: 'Lisa',\n  lastName: 'Stanecki',\n  birthPlace: {country: 'Canada', city: 'Toronto'}\n};\n\nconsole.log(employee.birthPlace.city);  // 'Toronto'\n```", "```\nemployee.employeeId = 402;\n```", "```\nemployee['employeeId'] = 402;\n```", "```\nconst dynamicProperty = 'nickname';\nconst dynamicPropertyValue = 'The Izz';\n\nemployee[dynamicProperty] = dynamicPropertyValue;\n// Now employee.nickname = 'The Izz'\n\nconst i = 10;\nemployee['sequence' + i] = 1;\n// Now employee.sequence10 = 1\n```", "```\nconst employee = {};\nconst today = new Date();\n\nemployee[today] = 42;\n\n// This reveals that 42 is stored in a property that has a long string name like\n// \"Tue May 04 2021 08:18:16 GMT-0400 (Eastern Daylight Time)\"\nconsole.log(employee);\n```", "```\nconst dynamicProperty = 'nickname';\nconst dynamicPropertyValue = 'The Izz';\nconst i = 10;\n\nconst employee = {\n  employeeId: 402,\n  firstName: 'Lisa',\n  lastName: 'Stanecki',\n  [dynamicProperty]: dynamicPropertyValue,\n  ['sequence' + i]: 1\n};\n```", "```\nconst address = {\n  country: 'Australia',\n  city: 'Sydney',\n  streetNum: '412',\n  streetName: 'Worcestire Blvd'\n};\n\nif ('country' in address) {\n  // This code runs, because there is an address.country property\n}\n\nif ('zipCode' in address) {\n  // This code does not run, because there is no address.zipCode property\n}\n```", "```\nconst address = {\n  country: 'Australia',\n  city: 'Sydney',\n  streetNum: '412',\n  streetName: 'Worcestire Blvd'\n};\n\nconsole.log(address.hasOwnProperty('country'));  // true\nconsole.log(address.hasOwnProperty('zipCode'));  // false\n```", "```\nconst address = {\n  country: 'Australia', city: 'Sydney', streetNum: '412',\n  streetName: 'Worcestire Blvd'\n};\n\nconst properties = Object.keys(address);\n\n// Show every property and its value\nfor (const property of properties) {\n  console.log(`Property: ${property}, Value: ${address[property]}`);\n}\n```", "```\nProperty: country, Value: Australia\nProperty: city, Value: Sydney\nProperty: streetNum, Value: 412\nProperty: streetName, Value: Worcestire Blvd\n```", "```\nconst address = {\n  country: 'Australia', city: 'Sydney', streetNum: '412',\n  streetName: 'Worcestire Blvd'\n};\n\nproperties = Object.keys(address);\nconsole.log(`The address object has a length of ${properties.length}`);\n// (In this example, the length is 4.)\n```", "```\nfor (const property in address) {\n  console.log(`Property: ${property}, Value: ${address[property]}`);\n}\n```", "```\nconst blankObject = {};\n\nif (Object.keys(blankObject).length === 0) {\n  // This code runs because there's nothing in this object\n}\n\nconst objectWithProperty = {price: 47.99};\nif (Object.keys(objectWithProperty).length === 0) {\n  // This code won't run, because objectWithProperty isn't empty\n}\n```", "```\nconst blankObject = {};\n```", "```\nconst blankObject = new Object();\n```", "```\nconst objectWithProperty = {price: 47.99};\ndelete objectWithProperty.price;\n\nif (Object.keys(objectWithProperty).length === 0) {\n  // This code runs, because objectWithProperty had its only property removed\n}\n```", "```\nconst blankObject = {};\nconst unknownObject = {};\n\nif (unknownObject === blankObject) {\n  // We never get here\n  // Even though unknownObject is empty, like blankObject, it holds a\n  // different reference to a different memory location\n}\n```", "```\nconst address = {\n  country: 'Australia', city: 'Sydney', streetNum: '412',\n  streetName: 'Worcestire Blvd'\n};\n\nconst customer = {\n  firstName: 'Lisa', lastName: 'Stanecki'\n};\n\nconst customerWithAddress = {...customer, ...address};\nconsole.log(customerWithAddress);\n// The customerWithAddress now has all six properties\n```", "```\nconst address = {\n  `country``:` `'Australia'`, city: 'Sydney', streetNum: '412',\n  streetName: 'Worcestire Blvd'\n};\n\nconst customer = {\n  firstName: 'Lisa', lastName: 'Stanecki', `country``:` `'South Korea'`\n};\n\nconst customerWithAddress = {...customer, ...address};\nconsole.log(customerWithAddress.country);  // Shows 'Australia' \n```", "```\nconst data = {};\n```", "```\nconst data = {};\n\nObject.defineProperty(data, 'type', {\n  value: 'primary',\n  enumerable: true\n});\n\n// Attempt to change the read-only property\nconsole.log(data.type); // primary\ndata.type = 'secondary';\nconsole.log(data.type); // nope, still primary\n\nObject.defineProperty(data, 'id', {\n  value: 1,\n  writable: true\n});\n\n// Change this modifiable property\nconsole.log(data.id); // 1\ndata.id = 300;\nconsole.log(data.id); // 300\n\n// See what properties appear during enumeration\nfor (prop in data) {\n  console.log(prop); // only type displays\n}\n```", "```\nconst person = {\n  firstName: 'Joe',\n  lastName: 'Khan',\n  dateOfBirth: new Date(1996, 6, 12)\n};\n\nObject.defineProperty(person, 'age', {\n  configurable: true,\n  enumerable: true,\n  get: function() {\n    // Calculate the difference in years\n    const today = new Date();\n    let age = today.getFullYear() - this.dateOfBirth.getFullYear();\n\n    // Adjust if the bithday hasn't happened yet this year\n    const monthDiff = today.getMonth() - this.dateOfBirth.getMonth();\n    if (monthDiff < 0 ||\n       (monthDiff === 0 && today.getDate() < this.dateOfBirth.getDate())) {\n      age -= 1;\n    }\n\n    return age;\n  }\n});\n\nconsole.log(person.age);\n```", "```\nconst customer = {\n  firstName: 'Josephine',\n  lastName: 'Stanecki'\n};\n\n// freeze the object\nObject.freeze(customer);\n\n// This statement throws an error in strict mode\ncustomer.firstName = 'Joe';\n\n// So does an attempt to add a property\ncustomer.middleInitial = 'P';\n\n// Or remove one\ndelete customer.lastName;\n```", "```\nif (Object.isFrozen(obj)) ...\n```", "```\n// This is the object that we'll watch with the proxy\nconst product = {name: 'banana'};\n\n// This is the handler that the proxy uses to intercept traps\nconst propertyChecker = {\n  set: function(target, property, value) {\n    if (property === 'price') {\n      if (typeof value !== 'number') {\n        throw new TypeError('price is not a number');\n      }\n      else if (value <= 0) {\n        throw new RangeError('price must be greater than zero');\n      }\n    }\n    else if (property !== 'name') {\n      throw new ReferenceError(`property '${property}' not valid`);\n    }\n    target[property] = value;\n  }\n};\n\n// Create the proxy\nconst proxy = new Proxy(product, propertyChecker);\n\n// Now, modify the product object through the proxy object\nproxy.name = 'apple';\n\n// This throws a ReferenceError\nproxy.type = 'red delicious';\n\n// This throws a TypeError\nproxy.price = 'three dollars';\n\n// This throws a RangeError\nproxy.price = -1.00;\n\n// This bypasses the proxy and succeeds\nproduct.price = -1.00;\n```", "```\nconst handler = {\n    get: function(array, index) {\n      if (array[index] === 0) {\n        return false;\n      }\n      else {\n        return true;\n      }\n    }\n};\n\nconst numbers = [1,0,6,1,1,0];\nconst proxy = new Proxy(numbers, handler);\n\nconsole.log(proxy[2]);  // true\nconsole.log(proxy[0]);  // true\nconsole.log(proxy[1]);  // false\n```", "```\nconst animal = {\n  name: 'Red Fox', class: 'Mammalia', order: 'Carnivora',\n  family: 'Canidae', genus: 'Vulpes', species: 'Vulpes vulpes'\n};\n\nconst animalCopy = {...animal};\nconsole.log(animalCopy.species);  // 'Vulpes vulpes'\n```", "```\nconst animalCopy = animal;\n```", "```\nconst animalCopy = Object.assign({}, animal);\n```", "```\nconst student = {\n  firstName: 'Tazie', lastName: 'Yang',\n  testScores: [78, 88, 94, 91, 88, 96]\n};\n\nconst studentCopy = {...student};\n\n// Now there are two objects sharing the same testScores array\n// We can see this if we change some details.\n// This affects just the copy:\nstudentCopy.firstName = 'Dori';\n// This affects both objects:\nstudentCopy.testScores[0] = 56;\n\nconsole.log(student);\n// {firstName: \"Tazie\", lastName: \"Yang\", testScores: [56, 88, 94, 91, 88, 96]\nconsole.log(studentCopy);\n// {firstName: \"Dori\", lastName: \"Yang\", testScores: [56, 88, 94, 91, 88, 96]\n```", "```\nconst student = {\n  firstName: 'Tazie', lastName: 'Yang',\n  testScores: [78, 88, 94, 91, 88, 96]\n};\n\nfunction cloneStudent(student) {\n  // Start with a shallow copy\n  const studentCopy = {...student};\n\n  // Now duplicate the array (by expanding it with spread)\n  studentCopy.testScores = [...studentCopy.testScores];\n\n  return studentCopy;\n}\n\n// Create a truly independent student copy\nconst studentCopy = cloneStudent(student);\n\n// Verify the arrays are separate\nstudentCopy.testScores[0] = 56;\n\nconsole.log(student.testScores[0]);      // 78\nconsole.log(studentCopy.testScores[0]);  // 56\n```", "```\nclass Student {\n  constructor(firstName, lastName, testScores) {\n    this.firstName = firstName;\n    this.lastName = lastName;\n    this.testScores = testScores;\n  }\n\n  clone() {\n    return new Student(this.firstName, this.lastName,\n     [...this.testScores]);\n  }\n}\n\nconst student = new Student('Tazie', 'Yang', [78, 88, 94, 91, 88, 96]);\nconst studentCopy = student.clone();\n\n// Verif the arrays are separate\nstudentCopy.testScores[0] = 56;\n\nconsole.log(student.testScores[0]);      // 78\nconsole.log(studentCopy.testScores[0]);  // 56\n```", "```\nconst newObj = {};\n\n// Set a unique property that will never clash with anything else\nconst uniqueId = Symbol();\nnewObj[uniqueId] = 'No two alike';\n\n// Set another one\nconst anotherUniqueId = Symbol();\nnewObj[anotherUniqueId] = 'This will not clash, either';\n\nconsole.log(newObj);\n```", "```\n{Symbol(): 'No two alike', Symbol(): 'This will not clash, either'}\n```", "```\nconsole.log(newObj[uniqueID]);  // 'No two alike'\n```", "```\nnewObj = {};\nconst propertyName = Symbol('Log Status');\nnewObj[propertyName] = 'logged';\n```", "```\n// Create three constants to use as an enum\nconst TrafficLight = {\n  Green: Symbol('green'),\n  Red: Symbol('red'),\n  Yellow: Symbol('yellow')\n}\n\n// This function uses the light enum\nfunction switchLight(newLight) {\n  if (newLight === TrafficLight.Green) {\n    console.log('Turning light green');\n  }\n  else if (newLight === TrafficLight.Yellow) {\n    console.log('Get ready to stop');\n  }\n  else {\n    console.log('Turning light red');\n  }\n  return newLight;\n}\n\nlet light = TrafficLight.Green;\nlight = switchLight(TrafficLight.Yellow);\nlight = switchLight(TrafficLight.Red);\n\nconsole.log(light);   // shows \"Symbol('red')\"\n```", "```\nconst Units = {\n  Meters: 100,\n  Centimeters: 1,\n  Kilometers: 100000,\n  Yards: 91.44,\n  Feet: 30.48,\n  Miles: 160934,\n  Furlongs: 20116.8,\n  Elephants: 625,\n  Boeing747s: 7100\n};\n```"]