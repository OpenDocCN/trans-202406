- en: Chapter 15\. Web Authentication and State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: My family and I recently moved. After filling out and signing several forms
    (my hand is *still* tired), we were handed the keys to the front door. Each time
    we come back home, we are able to use those keys to unlock the door and enter.
    I’m grateful that I don’t need to complete the form each time that I come home,
    but also appreciate having a lock so that we don’t have any unexpected guests.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side web authentication works in much the same way. Our users will fill
    out a form and will be handed a key to the website, in the form of a password
    alongside a token stored in their browser. When they return to the site they will
    either be automatically authenticated with the token, or be able to sign back
    in using their password.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll build out a web authentication system with our GraphQL
    API. To do this, we’ll be building forms, storing JWTs in the browser, sending
    tokens with each request, and keeping track of our application’s state.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Sign-up Form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started with our application’s client authentication, we can create a
    user sign-up React component. Before doing so, let’s map out how the component
    will work.
  prefs: []
  type: TYPE_NORMAL
- en: First, a user will navigate to the */signup* route within our application. On
    this page they will be presented with a form where they can enter their email
    address, desired username, and password. Submitting the form will perform our
    API’s `signUp` mutation. If the mutation is successful, a new user account will
    be created and the API will return a JWT. If there is an error, we can inform
    the user. We’ll be displaying a generic error message, but we could update our
    API to return specific error messages, such as a pre-existing username or a duplicate
    email address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started by creating our new route. First, we’ll create a new React
    component at *src/pages/signup.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll update our route list in *src/pages/index.js* to include the `signup`
    route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding the route, we will be able to navigate to *http://localhost:1234/signup*
    to see the (mostly empty) sign-up page. Now, let’s add the markup for our form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: htmlFor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re just learning React, one of the common gotchas are JSX attributes
    that differ from their HTML counterparts. In this case we are using the JSX `htmlFor`
    in place of HTML’s `for` attribute to avoid any JavaScript collisions. You can
    see a full, though short, list of these attributes in the [React DOM Elements
    documentation](https://oreil.ly/Kn5Ke).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add some style by importing our `Button` component and styling the
    form as a styled component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: React Forms and State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an application, things change. Data is entered into a form, a user toggles
    a slider open, a message is sent. In React, we can track these changes at the
    component level by assigning *state*. In our form, we’ll need to track the state
    of each form element, so that it can be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: React Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book we’re using functional components and React’s newer Hooks API.
    If you’ve used other learning resources that make use of React’s `class` components,
    this may look a little different. You can read more about Hooks in the [React
    documentation](https://oreil.ly/Tz9Hg).
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with state, we’ll first update the React import at the top of
    our *src/pages/signup.js* file to include `useState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, within our `SignUp` component we’ll set the default form value state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll update our component to change the state when a form field is entered
    and perform an operation when a user submits the form. First, we’ll create an
    `onChange` function, which will update our component’s state whenever the form
    is updated. We’ll also update the markup of each form element to call this function
    when a user makes a change, using the `onChange` property. Then we’ll update our
    `form` element to include an `onSubmit` handler. For now, we’ll simply log our
    form data to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In */src/pages/sigunp.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With this form markup in place, we’re ready to request data with a GraphQL mutation.
  prefs: []
  type: TYPE_NORMAL
- en: signUp Mutation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To sign up a user, we’ll be using our API’s `signUp` mutation. This mutation
    will accept an email, username, and password as variables and return a JWT if
    the signup is successful. Let’s write our mutation and integrate it into our sign-up
    form.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll need to import our Apollo libraries. We’ll be making using of
    the `useMutation` and `useApolloClient` hooks, as well as the `gql` syntax, from
    Apollo Client. In *src/pages/signUp*, add the following alongside the other library
    import statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now write the GraphQL mutation as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With the mutation written, we can update our React component markup to perform
    the mutation when a user submits the form, passing the form elements as variables.
    For now, we’ll log our response (which, if successful, should be a JWT) to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now if you complete and submit the form, you should see a JWT logged to your
    console ([Figure 15-1](#web_signup)). Additionally, if you perform a `users` query
    in the GraphQL Playground (*http://localhost:4000/api*), you’ll see the new account
    ([Figure 15-2](#web_signup_playground)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of our form and a JSON Web Token in the console](assets/jsev_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. If successful, a JSON Web Token will print to our console when
    we submit the form
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![A screenshot of the users query and results in GraphQL Playground](assets/jsev_1502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2\. We can also see a list of users by performing a users query in
    the GraphQL Playground
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With our mutation in place and returning the expected data, next we want to
    store the response that we receive.
  prefs: []
  type: TYPE_NORMAL
- en: JSON Web Tokens and Local Storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our `signUp` mutation is successful, it returns a JSON Web Token (JWT).
    You may recall from the API portion of the book that a [JWT](https://jwt.io) allows
    us to securely store a user’s ID on the user’s device. To achieve this in our
    user’s web browser, we’ll store the token in the browser’s `localStorage`. `localStorage`
    is a simple key-value store that persists across browser sessions until the storage
    is updated or cleared. Let’s update our mutation to store the token in `localStorage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *src/pages/signup.js*, update the `useMutation` hook to store the token
    in `local``Storage` (see [Figure 15-3](#web_token_storage)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![A screenshot of our token in the browser''s localStorage](assets/jsev_1503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-3\. Our web token is now stored in the browser’s localStorage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JWTs and Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a token is stored in `localStorage`, any JavaScript that can be run on
    the page has access to the token, making it susceptible to cross-site scripting
    (XSS) attacks. For this reason, when using `localStorage` to store token credentials,
    you need to take extra care to limit (or avoid) CDN hosted scripts. If a third-party
    script is compromised, it would have access to the JWT.
  prefs: []
  type: TYPE_NORMAL
- en: With our JWT stored locally, we’re prepared to use it in our GraphQL mutations
    and queries.
  prefs: []
  type: TYPE_NORMAL
- en: Redirects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently when a user completes the sign-up form, the form re-renders as an
    empty form. This doesn’t leave the user with much of a visual cue that their account
    registration was successful. Instead, let’s redirect the user to the home page
    of our application. Another option would be to create a “Success” page that thanks
    the user for registering and onboards them to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall from earlier in the chapter, we’re passing the properties
    into the component. We can redirect a route using React Router’s `history`, which
    will be available to us through `props.history.push`. To implement this, we’ll
    update our mutation’s `onCompleted` event to include a redirect like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With this change, users will now be redirected to our application’s home page
    after registering for an account.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching Headers to Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though we are storing our token in `localStorage`, our API does not yet have
    access to it. This means that even if a user has created an account, the API has
    no way of identifying the user. If you recall from our API development, each API
    call receives a token in the header of the request. We’ll modify our client to
    send the JWT as a header with each request.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *src/App.js* we’ll update our dependencies to include `createHttpLink` from
    Apollo Client as well as `setContext` from Apollo’s Link Context package. We’ll
    then update Apollo’s configuration to send the token in the header of each request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this change, we’ll now be able to pass the information of the logged-in
    user to our API.
  prefs: []
  type: TYPE_NORMAL
- en: Local State Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve looked at managing state within a component, but what about across our
    application? There are times where it’s useful to have some information shared
    among many components. We could pass `props` from a base component across our
    application, but as soon as we get past a couple of levels of subcomponents, this
    can get messy. Libraries such as [Redux](https://redux.js.org) and [MobX](https://mobx.js.org)
    have sought to solve the challenges of state management and have proven useful
    for many developers and teams. In our case, we’re already making use of the Apollo
    Client library, which includes the ability to use GraphQL queries for local state
    management. Rather than introducing another dependency, let’s implement a local
    state property that will store whether the user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: The Apollo React library puts the `ApolloClient` instance within React’s context,
    but at times we may need to access it directly. We can do so with the `useApolloClient`
    hook, which will allow us to perform actions such as directly updating or resetting
    the cache store or writing local data.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have two ways to determine if a user is logged in to our application.
    First, we know they are a current user if they’ve successfully submitted the sign-up
    form. Second, we know that if a visitor accesses the site with a token stored
    in `localStorage`, then they are already logged in. Let’s begin by adding to our
    state when a user completes the sign-up form. To achieve this, we’ll write directly
    to our Apollo Client’s local store, using `client.writeData` and the `useApolloClient`
    hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *src/pages/signup.js* we first need to update the `@apollo/client` library
    import to include `useApolloClient`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In *src/pages/signup.js* we’ll call the `useApolloClient` function and update
    the mutation to add to the local store, using `writeData`, when it is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s update our application to check for a pre-existing token when the
    page loads and update the state when a token is found. In `src/App.js`, first
    update the `ApolloClient` configuration to an empty `resolvers` object. This will
    allow us to perform GraphQL queries on our local cache.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can perform the check on the initial page load of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here comes the cool part: we can now access `isLoggedIn` as a GraphQL query
    anywhere within our application by using the `@client` directive. To demonstrate
    this, let’s update the header of our application to display a “Sign Up” and “Sign
    In” link if `isLoggedIn` is `false` and a “Log Out” link if `isLoggedIn` is `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In *src/components/Header.js*, import the necessary dependencies and write
    the query like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within our React component we can include a simple query to retrieve the
    state along with a tertiary operator that displays options either to log out or
    sign in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, when a user is logged in they’ll see a “Log Out” option: otherwise,
    they’ll be presented with options to sign up or in, all thanks to local state.
    We’re not limited to simple boolean logic, either. Apollo enables us to write
    local resolvers and type definitions, allowing us to take advantage of everything
    GraphQL has to offer within our local state.'
  prefs: []
  type: TYPE_NORMAL
- en: Logging Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently once a user is signed in, they have no way to log out of our application.
    Let’s turn the “Log Out” language in our header into a button that, when clicked,
    will log out the user. To do this, when the button is clicked we will remove the
    token that has been stored in `localStorage`. We’ll use a `<button>` element for
    its built-in accessibility, as it both serves as a semantic representation of
    a user action and receives focus, like a link, when a user is navigating the application
    with their keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing our code, let’s write a styled component that will render a
    button like a link. Create a new file at *src/Components/ButtonAsLink.js* and
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in *src/components/Header.js* we can implement our logout functionality.
    We need to use React Router’s `withRouter` higher-order component to handle the
    redirect since our *Header.js* file is a UI component and not a defined route.
    Let’s begin by importing the `ButtonAsLink` component as well as `withRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, within our JSX we’ll update our component to include the `props` parameter
    and update the logout markup to be a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: withRouter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to include routing in a component that is not itself directly routable,
    we need to use React Router’s `withRouter` higher-order component.
  prefs: []
  type: TYPE_NORMAL
- en: When a user logs out of our application, we want to reset the cache store to
    prevent any unwanted data from appearing outside of the session. Apollo offers
    the ability to call the `resetStore` function, which will fully clear the cache.
    Let’s add an `onClick` handler to our component’s button to remove the user’s
    token, reset the Apollo Store, update the local state, and redirect the user to
    the home page. To accomplish this, we’ll update our `useQuery` hook to include
    a reference to the client and wrap our component in the `withRouter` higher-order
    component in our `export` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will need Apollo to add the user state back to our cached state
    when the store is reset. In *src/App.js* update the cache settings to include
    `onResetStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With this, logged-in users are able to easily log out of our application. We’ve
    integrated this functionality directly into our `Header` component, but in the
    future we could refactor it into a standalone component.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Sign-In Form
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently our users are able to sign up and log out of our application, but
    they have no way to sign back in. Let’s create a sign-in form and do a bit of
    refactoring along the way so that we can reuse much of the code found in our signup
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first step will be to create a new page component that will live at */signin*.
    In a new file at *src/pages/signin.js*, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can make our page routable, so that users can navigate to it. In *src/pages/index.js*
    import the route page and add a new route path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let’s pause here, before we implement our sign-in form, to consider our options.
    We could reimplement a form, much like we wrote for our Sign Up page, but that
    feels tedious and would require us to maintain two similar forms. When one changes,
    we would need to be sure to update the other. Another option is to isolate the
    form into its own component, which would allow us to reuse common code and make
    updates in a single location. Let’s go forward with the shared form component
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first create a new component at *src/components/UserForm.js*, bringing
    over our `<form>` markup and styles. We will be making a few minor, but notable,
    changes to this form to use the properties that it receives from the parent component.
    First, we’ll rename our `onSubmit` mutation to `props.action`, which will allow
    us to pass the mutation to our form through the component’s properties. Second,
    we’ll add some conditional statements where we know that our two forms will differ.
    We’ll make use of a second property named `formType`, which we’ll pass a string.
    We can change our template’s rendering based on the value of the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll write these either as an inline `if` statement with a logical `&&` operator
    or as a conditional ternary operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can simplify our *src/pages/signup.js* component to make use of the
    shared form component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can write our `SignIn` component, making use of our `signIn` mutation
    and `UserForm` component. In *src/pages/signin.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: With this, we now have a manageable form component and have enabled users to
    both sign up and sign in to our application.
  prefs: []
  type: TYPE_NORMAL
- en: Protected Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common application pattern is to limit access to specific pages or portions
    of the site to authenticated users. In our case, nonauthenticated users would
    have no use for the My Notes or Favorites pages. We can implement this pattern
    in our router, automatically routing unauthenticated users to the application’s
    Sign In page when they attempt to visit those routes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *src/pages/index.js* we’ll start by importing the necessary dependencies
    and adding our `isLoggedIn` query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll import React Router’s `Redirect` library and write a `PrivateRoute`
    component, which will redirect the user if they are not logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can update any of our routes intended for logged-in users to use
    the `Private``Route` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Redirect State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we redirect a private route, we are also storing the referring URL as state.
    This allows us to redirect users back to the page they were originally attempting
    to navigate to. We could update our redirect on the Sign In page to optionally
    use `props.state.`​`location.from` to enable this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Now when a user attempts to navigate to a page intended for logged-in users,
    they will be redirected to our Sign In page.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we’ve covered two critical concepts for building client-side
    JavaScript applications: authentication and state. By building a full authentication
    flow, you’ve gained insight into how user accounts work with a client application.
    From here, I would encourage you to explore alternate options such as OAuth and
    authentication services such as Auth0, Okta, and Firebase. Additionally, you’ve
    learned to manage state in an application, both at the component level, using
    the React Hooks API, as well as across the application, using Apollo’s local state.
    With these key concepts behind you, you can now build robust user interface applications.'
  prefs: []
  type: TYPE_NORMAL
