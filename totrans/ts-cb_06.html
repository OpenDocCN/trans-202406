<html><head></head><body><section data-pdf-bookmark="Chapter 5. Conditional Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch05">&#13;
<h1><span class="label">Chapter 5. </span>Conditional Types</h1>&#13;
&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="overview" data-type="indexterm" id="id660"/>In this chapter, we will take a good look at a feature that is unique to TypeScript: <em>conditional types</em>. Conditional types allow us to select types based on subtype checks, allowing us to move around in the type space and get even more flexibility in how we want to design interfaces and function signatures.</p>&#13;
&#13;
<p>Conditional types are a powerful tool that allows you to make up types on the fly. It makes TypeScript’s type system turing complete, as shown in <a href="https://oreil.ly/igPhB">this GitHub issue</a>, which is both outstanding but also a bit frightening. With so much power in your hands, it’s easy to lose focus on which types you actually need, leading you into dead ends or crafting types that are too hard to read. Throughout this book, we will discuss the usage of conditional types thoroughly, always reassessing that what we do actually leads to our desired goal.</p>&#13;
&#13;
<p>Note that this chapter is much shorter than others. This is not because there’s not a lot to say about conditional types: quite the contrary. It’s more because we will see good use of conditional types in the subsequent chapters. Here, we want to focus on the fundamentals and establish terminology that you can use and refer to whenever you need some type magic.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.1 Managing Complex Function Signatures" data-type="sect1"><div class="sect1" id="ch05_function_signatures">&#13;
<h1>5.1 Managing Complex Function Signatures</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id218">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="managing complex function signatures" data-type="indexterm" id="ix_05-01-asciidoc0"/><a data-primary="function overloads" data-secondary="managing complex function signatures" data-type="indexterm" id="ix_05-01-asciidoc1"/><a data-primary="function signatures" data-secondary="managing complex function signatures" data-type="indexterm" id="ix_05-01-asciidoc2"/>You are creating a function with varying parameters and return types. Managing all variations using function overloads gets increasingly complex.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id661">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use conditional types to define a set of rules for parameter and return types.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id86">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>You create software that presents certain attributes as labels based on user-defined input. You distinguish between <code>StringLabel</code> and <code>NumberLabel</code> to allow for different kinds of filter operations and searches:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">StringLabel</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">NumberLabel</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>User input is either a string or a number. The <code>createLabel</code> function takes the input as a primitive type and produces either a <code>StringLabel</code> or <code>NumberLabel</code> object:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With the basic functionality done, you see that your types are way too broad. If you enter a <code>number</code>, the return type of <code>createLabel</code> is still <code>NumberLabel | StringLabel</code>, when it can only be <code>NumberLabel</code>. The solution? Adding function overloads to explicitly define type relationships, like we learned in <a data-type="xref" href="ch02.html#ch02_item_function_overloads">Recipe 2.6</a>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">StringLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The way function overloads work is that the overloads themselves define types for usage, whereas the last function declaration defines the types for the implementation of the function body. With <code>createLabel</code>, we are able to pass in a <code>string</code> and get a <code>StringLabel</code> or pass in a <code>number</code> and get a <code>NumberLabel</code>, as those are the types available to the outside.</p>&#13;
&#13;
<p>This is problematic in cases where we couldn’t narrow the input type beforehand. We lack a function type to the outside that allows us to pass in input that is either <code>number</code> or <code>string</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">inputToLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="p">);</code>&#13;
  <code class="c1">//                    ^</code>&#13;
  <code class="c1">// No overload matches this call. (2769)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To circumvent this, we add another overload that mirrors the implementation function signature for very broad input types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">StringLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code> <code class="o">|</code> <code class="nx">StringLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What we see here is that we already need three overloads and four function signature declarations total to describe the most basic behavior for this functionality. And from there on, it just gets worse.</p>&#13;
&#13;
<p>We want to extend our function to be able to copy existing <code>StringLabel</code> and <code>NumberLabel</code> objects. This ultimately means more overloads:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">StringLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="nx">StringLabel</code><code class="p">)</code><code class="o">:</code> <code class="nx">StringLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="nx">NumberLabel</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code><code class="p">)</code><code class="o">:</code> <code class="nx">StringLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code><code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">NumberLabel</code><code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code>&#13;
  <code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="o">|</code> <code class="nx">NumberLabel</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code> <code class="o">|</code> <code class="nx">StringLabel</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code>&#13;
  <code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="o">|</code> <code class="nx">NumberLabel</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="s2">"id"</code> <code class="k">in</code> <code class="nx">input</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code><code class="p">.</code><code class="nx">id</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code><code class="p">.</code><code class="nx">name</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Truth be told, depending on how expressive we want our type hints to be, we can write fewer but also a lot more function overloads. The problem is still apparent: more variety results in more complex function signatures.</p>&#13;
&#13;
<p>One tool in TypeScript’s toolbelt can help with situations like this: conditional types. Conditional types allow us to select a type based on certain subtype checks. We ask if a generic type parameter is of a certain subtype and, if so, return the type from the <code>true</code> branch, or otherwise return the type from the <code>false</code> branch.</p>&#13;
&#13;
<p>For example, the following type returns the input parameter if <code>T</code> is a subtype of <code>string</code> (which means all strings or very specific ones). Otherwise, it returns <code>never</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">IsString</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="nx">T</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">IsString</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// string</code>&#13;
<code class="kr">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">IsString</code><code class="o">&lt;</code><code class="s2">"hello"</code> <code class="o">|</code> <code class="s2">"world"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// string</code>&#13;
<code class="kr">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">IsString</code><code class="o">&lt;</code><code class="mi">1000</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// never</code></pre>&#13;
&#13;
<p>TypeScript borrows this syntax from JavaScript’s ternary operator. And just like &#13;
<span class="keep-together">JavaScript’s</span> ternary operator, it checks if certain conditions are valid. But instead of having the typical set of conditions you know from a programming language, TypeScript’s type system checks only if the values of the input type are included in the set of values we check against.</p>&#13;
&#13;
<p>With that tool, we are able to write a conditional type called <code>GetLabel&lt;T&gt;</code>. We check if the input is either of <code>string</code> or <code>StringLabel</code>. If so, we return <code>StringLabel</code>; else, we know that it must be a <code>NumberLabel</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="o">?</code> <code class="nx">StringLabel</code> <code class="o">:</code> <code class="nx">NumberLabel</code><code class="p">;</code></pre>&#13;
&#13;
<p>This type only checks if the inputs <code>string</code>, <code>StringLabel</code>, <code>number</code>, and <code>NumberLabel</code> are in the <code>else</code> branch. If we want to be on the safe side, we would also include a check against possible inputs that produce a <code>NumberLabel</code> by nesting conditional types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code>&#13;
  <code class="o">?</code> <code class="nx">StringLabel</code>&#13;
  <code class="o">:</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">NumberLabel</code>&#13;
  <code class="o">?</code> <code class="nx">NumberLabel</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Now it’s time to wire up our generics. We add a new generic type parameter <code>T</code> to <code>cr⁠ea⁠te​Lab⁠el</code> that is constrained to all possible input types. This <code>T</code> parameter serves as input for <code>GetLabel&lt;T&gt;</code>, where it will produce the respective return type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createLabel</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="o">|</code> <code class="nx">NumberLabel</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">input</code><code class="o">:</code> <code class="nx">T</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code> <code class="p">}</code> <code class="kr">as</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code> <code class="p">}</code> <code class="kr">as</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="s2">"id"</code> <code class="k">in</code> <code class="nx">input</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code><code class="p">.</code><code class="nx">id</code> <code class="p">}</code> <code class="kr">as</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code><code class="p">.</code><code class="nx">name</code> <code class="p">}</code> <code class="kr">as</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now we are ready to handle all possible type combinations and will still get the correct return type from <code>getLabel</code>, all in just one line of code.</p>&#13;
&#13;
<p>If you look closely, you will see that we needed to work around type-checks for the return type. Unfortunately, TypeScript is not able to do proper control flow analysis when working with generics and conditional types. A little type assertion tells TypeScript that we are dealing with the right return type.</p>&#13;
&#13;
<p>Another workaround would be to think of the function signature with conditional types as an overload to the original broadly typed function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">createLabel</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="o">|</code> <code class="nx">NumberLabel</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">input</code><code class="o">:</code> <code class="nx">T</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">GetLabel</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kd">function</code> <code class="nx">createLabel</code><code class="p">(</code>&#13;
  <code class="nx">input</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="o">|</code> <code class="nx">NumberLabel</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">NumberLabel</code> <code class="o">|</code> <code class="nx">StringLabel</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">input</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="s2">"id"</code> <code class="k">in</code> <code class="nx">input</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="nx">input</code><code class="p">.</code><code class="nx">id</code> <code class="p">};</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="nx">input</code><code class="p">.</code><code class="nx">name</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This way, we have a flexible type for the outside world that tells exactly what output we get based on our input. And for implementation, you have the full flexibility you know from a broad set of types.</p>&#13;
&#13;
<p>Does this mean you should prefer conditional types over function overloads in all scenarios? Not necessarily. In <a data-type="xref" href="ch12.html#ch12_overloads_vs_conditionals">Recipe 12.7</a> we look at situations where function overloads are the better choice.<a data-startref="ix_05-01-asciidoc2" data-type="indexterm" id="id662"/><a data-startref="ix_05-01-asciidoc1" data-type="indexterm" id="id663"/><a data-startref="ix_05-01-asciidoc0" data-type="indexterm" id="id664"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.2 Filtering with never" data-type="sect1"><div class="sect1" id="ch05_filtering_never">&#13;
<h1>5.2 Filtering with never</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id219">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="filtering with never" data-type="indexterm" id="ix_05-02-asciidoc0"/><a data-primary="distributive conditional type" data-secondary="for filtering with never" data-type="indexterm" id="ix_05-02-asciidoc1"/><a data-primary="never type" data-secondary="filtering with" data-type="indexterm" id="ix_05-02-asciidoc2"/>You have a union of various types but you just want to have all subtypes of string.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id665">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a distributive conditional type to filter for the right type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id87">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Let’s say you have some legacy code in your application where you tried to re-create frameworks like <em>jQuery</em>. You have your own kind of <code>ElementList</code> that has helper functions to add and remove class names to objects of type <code>HTMLElement</code>, or to bind event listeners to events.</p>&#13;
&#13;
<p>Additionally, you can access each element of your list through index access. A type for such an <code>ElementList</code> can be described using an index access type for number index access, together with regular string property keys:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ElementList</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">addClass</code><code class="o">:</code> <code class="p">(</code><code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ElementList</code><code class="p">;</code>&#13;
  <code class="nx">removeClass</code><code class="o">:</code> <code class="p">(</code><code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ElementList</code><code class="p">;</code>&#13;
  <code class="nx">on</code><code class="o">:</code> <code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">ev</code><code class="o">:</code> <code class="nx">Event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ElementList</code><code class="p">;</code>&#13;
  <code class="nx">length</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="p">[</code><code class="nx">x</code><code class="o">:</code> <code class="kt">number</code><code class="p">]</code><code class="o">:</code> <code class="nx">HTMLElement</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This data structure has been designed to have a fluent interface. Meaning that if you call methods like <code>addClass</code> or <code>removeClass</code>, you get the same object back so you can chain your method calls.</p>&#13;
&#13;
<p>A sample implementation of these methods could look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// begin excerpt</code>&#13;
  <code class="nx">addClass</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">ElementList</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">this</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">classList</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">className</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">removeClass</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">ElementList</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">this</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">classList</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="nx">className</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">on</code><code class="o">:</code> <code class="kd">function</code> <code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">ev</code><code class="o">:</code> <code class="nx">Event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="nx">ElementList</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">this</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">addEventListener</code><code class="p">(</code><code class="nx">event</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">;</code>&#13;
  <code class="p">},</code>&#13;
<code class="c1">// end excerpt</code></pre>&#13;
&#13;
<p>As an extension of a built-in collection like <code>Array</code> or <code>NodeList</code>, changing things on a set of <code>HTMLElement</code> objects becomes really convenient:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">declare</code> <code class="kr">const</code> <code class="nx">myCollection</code><code class="o">:</code> <code class="nx">ElementList</code><code class="p">;</code>&#13;
&#13;
<code class="nx">myCollection</code>&#13;
  <code class="p">.</code><code class="nx">addClass</code><code class="p">(</code><code class="s2">"toggle-off"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">removeClass</code><code class="p">(</code><code class="s2">"toggle-on"</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{});</code></pre>&#13;
&#13;
<p>Let’s say you need to maintain your <em>jQuery</em> substitute and figure out that direct element access has proven to be somewhat unsafe. When parts of your application can change things directly, it becomes harder for you to figure out where changes come from, if not from your carefully designed <code>ElementList</code> data structure:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">myCollection</code><code class="p">[</code><code class="mi">1</code><code class="p">].</code><code class="nx">classList</code><code class="p">.</code><code class="nx">toggle</code><code class="p">(</code><code class="s2">"toggle-on"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Since you can’t change the original library code (too many departments depend on it), you decide to wrap the original <code>ElementList</code> in a <code>Proxy</code>.</p>&#13;
&#13;
<p><code>Proxy</code> objects take an original target object and a handler object that defines how to handle access. The following implementation shows a <code>Proxy</code> that allows only read access, and only if the property key is of type <code>string</code> and not a string that is a string representation of a number:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">safeAccessCollection</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Proxy</code><code class="p">(</code><code class="nx">myCollection</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code>&#13;
      <code class="k">typeof</code> <code class="nx">property</code> <code class="o">===</code> <code class="s2">"string"</code> <code class="o">&amp;&amp;</code>&#13;
      <code class="nx">property</code> <code class="k">in</code> <code class="nx">target</code> <code class="o">&amp;&amp;</code>&#13;
      <code class="s2">""</code> <code class="o">+</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">property</code><code class="p">)</code> <code class="o">!==</code> <code class="nx">property</code>&#13;
    <code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">target</code><code class="p">[</code><code class="nx">property</code> <code class="kr">as</code> <code class="kr">keyof</code> <code class="k">typeof</code> <code class="nx">target</code><code class="p">];</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">});</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Handler objects in <code>Proxy</code> objects receive only string or symbol properties. If you do index access with a number—for example, <code>0</code>—JavaScript converts this to the string <code>"0"</code>.</p>&#13;
</div>&#13;
&#13;
<p>This works great in JavaScript, but our types don’t match anymore. The return type of the <code>Proxy</code> constructor is <code>ElementList</code> again, which means that the number index access is still intact:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Works in TypeScript throws in JavaScript</code>&#13;
<code class="nx">safeAccessCollection</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">classList</code><code class="p">.</code><code class="nx">toggle</code><code class="p">(</code><code class="s2">"toggle-on"</code><code class="p">);</code></pre>&#13;
&#13;
<p>We need to tell TypeScript that we are now dealing with an object with no number index access by defining a new type.</p>&#13;
&#13;
<p>Let’s look at the keys of <code>ElementList</code>. If we use the <code>keyof</code> operator, we get a union type of all possible access methods for objects of type <code>ElementList</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// resolves to "addClass" | "removeClass" | "on" | "length" | number</code>&#13;
<code class="kr">type</code> <code class="nx">ElementListKeys</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">ElementList</code><code class="p">;</code></pre>&#13;
&#13;
<p>It contains four strings as well as all possible numbers. Now that we have this union, we can create a conditional type that gets rid of everything that isn’t a string:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">JustStrings</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="nx">T</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p><code>JustStrings&lt;T&gt;</code> is what we call a <em>distributive conditional type</em>. Since <code>T</code> is on its own in the condition—not wrapped in an object or array—TypeScript will treat a conditional type of a union as a union of conditional types. Effectively, TypeScript does the same conditional check for every member of the union <code>T</code>.</p>&#13;
&#13;
<p>In our case, it goes through all members of <code>keyof ElementList</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">JustElementListStrings</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="s2">"addClass"</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="s2">"addClass"</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="s2">"removeClass"</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="s2">"removeClass"</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="s2">"on"</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="s2">"on"</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="s2">"length"</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="s2">"length"</code> <code class="o">:</code> <code class="kr">never</code>&#13;
  <code class="o">|</code> <code class="kt">number</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="kt">number</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>The only condition that hops into the <code>false</code> branch is the last one, where we check if <code>number</code> is a subtype of <code>string</code>, which it isn’t. If we resolve every condition, we end up with a new union type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">JustElementListStrings</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="s2">"addClass"</code>&#13;
  <code class="o">|</code> <code class="s2">"removeClass"</code>&#13;
  <code class="o">|</code> <code class="s2">"on"</code>&#13;
  <code class="o">|</code> <code class="s2">"length"</code>&#13;
  <code class="o">|</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>A union with <code>never</code> effectively drops <code>never</code>. If you have a set with no possible value and you join it with a set of values, the values remain:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">JustElementListStrings</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="s2">"addClass"</code>&#13;
  <code class="o">|</code> <code class="s2">"removeClass"</code>&#13;
  <code class="o">|</code> <code class="s2">"on"</code>&#13;
  <code class="o">|</code> <code class="s2">"length"</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is exactly the list of keys we consider safe to access! By using the <code>Pick</code> helper type, we can create a type that is effectively a supertype of <code>ElementList</code> by picking all keys that are of type <code>string</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SafeAccess</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">ElementList</code><code class="p">,</code> <code class="nx">JustStrings</code><code class="o">&lt;</code><code class="kr">keyof</code> <code class="nx">ElementList</code><code class="o">&gt;&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>If we hover over it, we see that the resulting type is exactly what we were looking for:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">SafeAccess</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">addClass</code><code class="o">:</code> <code class="p">(</code><code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ElementList</code><code class="p">;</code>&#13;
  <code class="nx">removeClass</code><code class="o">:</code> <code class="p">(</code><code class="nx">className</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ElementList</code><code class="p">;</code>&#13;
  <code class="nx">on</code><code class="o">:</code> <code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">ev</code><code class="o">:</code> <code class="nx">Event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">ElementList</code><code class="p">;</code>&#13;
  <code class="nx">length</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Let’s add the type as an annotation to <code>safeAccessCollection</code>. Since it’s possible to assign to a supertype, TypeScript will treat <code>safeAccessCollection</code> as a type with no number index access from that moment on:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">safeAccessCollection</code><code class="o">:</code> <code class="nx">Pick</code><code class="o">&lt;</code>&#13;
  <code class="nx">ElementList</code><code class="p">,</code>&#13;
  <code class="nx">JustStrings</code><code class="o">&lt;</code><code class="kr">keyof</code> <code class="nx">ElementList</code><code class="o">&gt;</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Proxy</code><code class="p">(</code><code class="nx">myCollection</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code>&#13;
      <code class="k">typeof</code> <code class="nx">property</code> <code class="o">===</code> <code class="s2">"string"</code> <code class="o">&amp;&amp;</code>&#13;
      <code class="nx">property</code> <code class="k">in</code> <code class="nx">target</code> <code class="o">&amp;&amp;</code>&#13;
      <code class="s2">""</code> <code class="o">+</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">property</code><code class="p">)</code> <code class="o">!==</code> <code class="nx">property</code>&#13;
    <code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">target</code><code class="p">[</code><code class="nx">property</code> <code class="kr">as</code> <code class="kr">keyof</code> <code class="k">typeof</code> <code class="nx">target</code><code class="p">];</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>When we now try to access elements from <code>safeAccessCollection</code>, TypeScript will greet us with an error:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">safeAccessCollection</code><code class="p">[</code><code class="mi">1</code><code class="p">].</code><code class="nx">classList</code><code class="p">.</code><code class="nx">toggle</code><code class="p">(</code><code class="s2">"toggle-on"</code><code class="p">);</code>&#13;
<code class="c1">// ^ Element implicitly has an 'any' type because expression of</code>&#13;
<code class="c1">// type '1' can't be used to index type</code>&#13;
<code class="c1">// 'Pick&lt;ElementList, "addClass" | "removeClass" | "on" | "length"&gt;'.</code></pre>&#13;
&#13;
<p>And that’s exactly what we need. The power of distributive conditional types is that we change members of a union. We will see another example in <a data-type="xref" href="#ch05_grouping_elements">Recipe 5.3</a>, where we work with built-in helper types.<a data-startref="ix_05-02-asciidoc2" data-type="indexterm" id="id666"/><a data-startref="ix_05-02-asciidoc1" data-type="indexterm" id="id667"/><a data-startref="ix_05-02-asciidoc0" data-type="indexterm" id="id668"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.3 Grouping Elements by Kind" data-type="sect1"><div class="sect1" id="ch05_grouping_elements">&#13;
<h1>5.3 Grouping Elements by Kind</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id88">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="grouping elements by kind" data-type="indexterm" id="ix_05-03-asciidoc0"/><a data-primary="Extract helper" data-type="indexterm" id="ix_05-03-asciidoc1"/><a data-primary="Group type" data-type="indexterm" id="ix_05-03-asciidoc2"/><a data-primary="kind property" data-type="indexterm" id="ix_05-03-asciidoc3"/><a data-primary="union types" data-secondary="grouping elements by kind" data-type="indexterm" id="ix_05-03-asciidoc4"/>Your <code>Group</code> type from <a data-type="xref" href="ch04.html#ch04_new_object_types">Recipe 4.5</a> works fine, but the type for each entry of the group is too broad.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id669">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the <code>Extract</code> helper type to pick the right member from a union type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id89">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Let’s go back to the toy shop example from Recipes <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03_item_modelling_data">3.1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04_new_object_types">4.5</a>. We started with a thoughtfully crafted model, with discriminated union types allowing us to get exact information about every possible value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ToyBase</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">description</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">minimumAge</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">BoardGame</code> <code class="o">=</code> <code class="nx">ToyBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"boardgame"</code><code class="p">;</code>&#13;
  <code class="nx">players</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Puzzle</code> <code class="o">=</code> <code class="nx">ToyBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"puzzle"</code><code class="p">;</code>&#13;
  <code class="nx">pieces</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Doll</code> <code class="o">=</code> <code class="nx">ToyBase</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">kind</code><code class="o">:</code> <code class="s2">"doll"</code><code class="p">;</code>&#13;
  <code class="nx">material</code><code class="o">:</code> <code class="s2">"plush"</code> <code class="o">|</code> <code class="s2">"plastic"</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Toy</code> <code class="o">=</code> <code class="nx">Doll</code> <code class="o">|</code> <code class="nx">Puzzle</code> <code class="o">|</code> <code class="nx">BoardGame</code><code class="p">;</code></pre>&#13;
&#13;
<p>We then found a way to <em>derive</em> another type called <code>GroupedToys</code> from <code>Toy</code>, where we take the union type members of the <code>kind</code> property as property keys for a mapped type, where each property is of type <code>Toy[]</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">k</code> <code class="k">in</code> <code class="nx">Toy</code><code class="p">[</code><code class="s2">"kind"</code><code class="p">]]</code><code class="o">?:</code> <code class="nx">Toy</code><code class="p">[];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Thanks to generics, we were able to define a helper type <code>Group&lt;Collection, Selector&gt;</code> to reuse the same pattern for different scenarios:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Group</code><code class="o">&lt;</code>&#13;
  <code class="nx">Collection</code> <code class="kr">extends</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">Selector</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">Collection</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Collection</code><code class="p">[</code><code class="nx">Selector</code><code class="p">]]</code><code class="o">:</code> <code class="nx">Collection</code><code class="p">[];</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Group</code><code class="o">&lt;</code><code class="nx">Toy</code><code class="p">,</code> <code class="s2">"kind"</code><code class="o">&gt;&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>The helper type works great, but there’s one caveat. If we hover over the generated type, we see that while <code>Group&lt;Collection, Selector&gt;</code> is able to pick the discriminant of the <code>Toy</code> union type correctly, all properties point to a very broad <code>Toy[]</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">boardgame</code><code class="o">?:</code> <code class="nx">Toy</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">puzzle</code><code class="o">?:</code> <code class="nx">Toy</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">doll</code><code class="o">?:</code> <code class="nx">Toy</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>But shouldn’t we know more? For example, why does <code>boardgame</code> point to a <code>Toy[]</code> when the only realistic type should be <code>BoardGame[]</code>. Same for puzzles and dolls, and all the subsequent toys we want to add to our collection. The type we are expecting should look more like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">boardgame</code><code class="o">?:</code> <code class="nx">BoardGame</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">puzzle</code><code class="o">?:</code> <code class="nx">Puzzle</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">doll</code><code class="o">?:</code> <code class="nx">Doll</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>We can achieve this type by <em>extracting</em> the respective member from the <code>Collection</code> union type. Thankfully, there is a helper type for that: <code>Extract&lt;T, U&gt;</code>, where <code>T</code> is the collection, <code>U</code> is part of <code>T</code>.</p>&#13;
&#13;
<p><code>Extract&lt;T, U&gt;</code> is defined as:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Extract</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">U</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">U</code> <code class="o">?</code> <code class="nx">T</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-primary="distributive conditional type" data-secondary="grouping elements by kind with" data-type="indexterm" id="id670"/>As <code>T</code> in the condition is a naked type, <code>T</code> is a <em>distributive conditional type</em>, which means TypeScript checks if each member of <code>T</code> is a subtype of <code>U</code>, and if this is the case, it keeps this member in the union type. How would this work for picking the right group of toys from <code>Toy</code>?</p>&#13;
&#13;
<p>Let’s say we want to pick <code>Doll</code> from <code>Toy</code>. <code>Doll</code> has a couple of properties, but the <code>kind</code> property separates distinctly from the rest. So for a type to look only for <code>Doll</code> would mean that we extract <em>from</em> <code>Toy</code> every type where <code>{ kind: "doll" }</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ExtractedDoll</code> <code class="o">=</code> <code class="nx">Extract</code><code class="o">&lt;</code><code class="nx">Toy</code><code class="p">,</code> <code class="p">{</code> <code class="nx">kind</code><code class="o">:</code> <code class="s2">"doll"</code> <code class="p">}</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>With distributive conditional types, a conditional type of a union is a union of conditional types, so each member of <code>T</code> is checked against <code>U</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ExtractedDoll</code> <code class="o">=</code>&#13;
  <code class="nx">BoardGame</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">kind</code><code class="o">:</code> <code class="s2">"doll"</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">BoardGame</code> <code class="o">:</code> <code class="kr">never</code> <code class="o">|</code>&#13;
  <code class="nx">Puzzle</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">kind</code><code class="o">:</code> <code class="s2">"doll"</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">Puzzle</code> <code class="o">:</code> <code class="kr">never</code> <code class="o">|</code>&#13;
  <code class="nx">Doll</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">kind</code><code class="o">:</code> <code class="s2">"doll"</code> <code class="p">}</code> <code class="o">?</code> <code class="nx">Doll</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Both <code>BoardGame</code> and <code>Puzzle</code> are not subtypes of <code>{ kind: "doll" }</code>, so they resolve to <code>never</code>. But <code>Doll</code> <em>is</em> a subtype of <code>{ kind: "doll" }</code>, so it resolves to <code>Doll</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ExtractedDoll</code> <code class="o">=</code> <code class="kr">never</code> <code class="o">|</code> <code class="kr">never</code> <code class="o">|</code> <code class="nx">Doll</code><code class="p">;</code></pre>&#13;
&#13;
<p>In a union with <code>never</code>, <code>never</code> just disappears. So the resulting type is <code>Doll</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">ExtractedDoll</code> <code class="o">=</code> <code class="nx">Doll</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is exactly what we are looking for. Let’s get that check into our <code>Group</code> helper type. Thankfully, we have all parts available to extract a specific type from a group’s &#13;
<span class="keep-together">collection:</span></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>Collection</code> itself, a placeholder that eventually is substituted with <code>Toy</code></p>&#13;
</li>&#13;
<li>&#13;
<p>The discriminant property in <code>Selector</code>, which eventually is substituted with <code>"kind"</code></p>&#13;
</li>&#13;
<li>&#13;
<p>The discriminant type we want to extract, which is a string type and coincidentally also the property key we map out in <code>Group</code>: <code>K</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>So the generic version of <code>Extract&lt;Toy, { kind: "doll" }&gt;</code> within <code>Group&lt;Collection, Selector&gt;</code> is this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Group</code><code class="o">&lt;</code>&#13;
  <code class="nx">Collection</code> <code class="kr">extends</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code><code class="p">,</code>&#13;
  <code class="nx">Selector</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">Collection</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Collection</code><code class="p">[</code><code class="nx">Selector</code><code class="p">]]</code><code class="o">:</code> <code class="nx">Extract</code><code class="o">&lt;</code><code class="nx">Collection</code><code class="p">,</code> <code class="p">{</code> <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">Selector</code><code class="p">]</code><code class="o">:</code> <code class="nx">K</code> <code class="p">}</code><code class="o">&gt;</code><code class="p">[];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>If we substitute <code>Collection</code> with <code>Toy</code> and <code>Selector</code> with <code>"kind"</code>, the type reads as follows:</p>&#13;
<dl>&#13;
<dt><code>[K in Collection[Selector]]</code></dt>&#13;
<dd>&#13;
<p>Take each member of <code>Toy["kind"]</code>—in that case, <code>"boardgame"</code>, <code>"puzzle"</code>, and <code>"doll"</code>—as a property key for a new object type.</p>&#13;
</dd>&#13;
<dt><code>Extract&lt;Collection, …​&gt;</code></dt>&#13;
<dd>&#13;
<p>Extract from the <code>Collection</code>, the union type <code>Toy</code>, each member that is a subtype of…​</p>&#13;
</dd>&#13;
<dt><code>{ [P in Selector]: K }</code></dt>&#13;
<dd>&#13;
<p>Go through each member of <code>Selector</code>—in our case, it’s just <code>"kind"</code>—and create an object type that points to <code>"boardgame"</code> when the property key is <code>"boardgame"</code>, <code>"puzzle"</code> when the property key is <code>"puzzle"</code>, and so on.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>That’s how we pick for each property key the right member of <code>Toy</code>. The result is as expected:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="nx">Partial</code><code class="o">&lt;</code><code class="nx">Group</code><code class="o">&lt;</code><code class="nx">Toy</code><code class="p">,</code> <code class="s2">"kind"</code><code class="o">&gt;&gt;</code><code class="p">;</code>&#13;
<code class="c1">// resolves to:</code>&#13;
<code class="kr">type</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">boardgame</code><code class="o">?:</code> <code class="nx">BoardGame</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">puzzle</code><code class="o">?:</code> <code class="nx">Puzzle</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
  <code class="nx">doll</code><code class="o">?:</code> <code class="nx">Doll</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Fantastic! The type is now a lot clearer, and we can make sure that we don’t need to deal with puzzles when we selected board games. But some new problems have &#13;
<span class="keep-together">popped</span> up.</p>&#13;
&#13;
<p>Since the types of each property are much more refined and don’t point to the very broad <code>Toy</code> type, TypeScript struggles a bit with resolving each collection in our group correctly:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">groupToys</code><code class="p">(</code><code class="nx">toys</code><code class="o">:</code> <code class="nx">Toy</code><code class="p">[])</code><code class="o">:</code> <code class="nx">GroupedToys</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">groups</code><code class="o">:</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="p">{};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">toy</code> <code class="nx">of</code> <code class="nx">toys</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">=</code> <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">??</code> <code class="p">[];</code>&#13;
<code class="c1">//  ^ Type 'BoardGame[] | Doll[] | Puzzle[]' is not assignable to</code>&#13;
<code class="c1">//    type '(BoardGame[] &amp; Puzzle[] &amp; Doll[]) | undefined'. (2322)</code>&#13;
    <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">toy</code><code class="p">);</code>&#13;
<code class="c1">//                         ^</code>&#13;
<code class="c1">//  Argument of type 'Toy' is not assignable to</code>&#13;
<code class="c1">//  parameter of type 'never'.  (2345)</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">groups</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The problem is that TypeScript still thinks of <code>toy</code> as potentially being all toys, whereas each property of <code>group</code> points to some very specific ones. There are three ways to solve this issue.</p>&#13;
&#13;
<p>First, we could again check for each member individually. Since TypeScript thinks of <code>toy</code> as a very broad type, narrowing makes the relationship clear again:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">groupToys</code><code class="p">(</code><code class="nx">toys</code><code class="o">:</code> <code class="nx">Toy</code><code class="p">[])</code><code class="o">:</code> <code class="nx">GroupedToys</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">groups</code><code class="o">:</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="p">{};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">toy</code> <code class="nx">of</code> <code class="nx">toys</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">switch</code> <code class="p">(</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">case</code> <code class="s2">"boardgame"</code><code class="o">:</code>&#13;
        <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">=</code> <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">??</code> <code class="p">[];</code>&#13;
        <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">toy</code><code class="p">);</code>&#13;
        <code class="k">break</code><code class="p">;</code>&#13;
      <code class="k">case</code> <code class="s2">"doll"</code><code class="o">:</code>&#13;
        <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">=</code> <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">??</code> <code class="p">[];</code>&#13;
        <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">toy</code><code class="p">);</code>&#13;
        <code class="k">break</code><code class="p">;</code>&#13;
      <code class="k">case</code> <code class="s2">"puzzle"</code><code class="o">:</code>&#13;
        <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">=</code> <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">??</code> <code class="p">[];</code>&#13;
        <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">toy</code><code class="p">);</code>&#13;
        <code class="k">break</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">groups</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That works, but there’s lots of duplication and repetition we want to avoid.</p>&#13;
&#13;
<p>Second, we can use a type assertion to widen the type of <code>groups[toy.kind]</code> so TypeScript can ensure index access:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">groupToys</code><code class="p">(</code><code class="nx">toys</code><code class="o">:</code> <code class="nx">Toy</code><code class="p">[])</code><code class="o">:</code> <code class="nx">GroupedToys</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">groups</code><code class="o">:</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="p">{};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">toy</code> <code class="nx">of</code> <code class="nx">toys</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="p">(</code><code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="kr">as</code> <code class="nx">Toy</code><code class="p">[])</code> <code class="o">=</code> <code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="o">??</code> <code class="p">[];</code>&#13;
    <code class="p">(</code><code class="nx">groups</code><code class="p">[</code><code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">]</code> <code class="kr">as</code> <code class="nx">Toy</code><code class="p">[])</code><code class="o">?</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">toy</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">groups</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This effectively works like before our change to <code>GroupedToys</code>, and the type assertion tells us that we intentionally changed the type here to get rid of type errors.</p>&#13;
&#13;
<p>Third, we can work with a little indirection. Instead of adding <code>toy</code> directly to a group, we use a helper function <code>assign</code> where we work with generics:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">groupToys</code><code class="p">(</code><code class="nx">toys</code><code class="o">:</code> <code class="nx">Toy</code><code class="p">[])</code><code class="o">:</code> <code class="nx">GroupedToys</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">groups</code><code class="o">:</code> <code class="nx">GroupedToys</code> <code class="o">=</code> <code class="p">{};</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">toy</code> <code class="nx">of</code> <code class="nx">toys</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">assign</code><code class="p">(</code><code class="nx">groups</code><code class="p">,</code> <code class="nx">toy</code><code class="p">.</code><code class="nx">kind</code><code class="p">,</code> <code class="nx">toy</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">groups</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">assign</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="nx">K</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">groups</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">key</code><code class="o">:</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">value</code><code class="o">:</code> <code class="nx">K</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// Initialize when not available</code>&#13;
  <code class="nx">groups</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">groups</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">??</code> <code class="p">[];</code>&#13;
  <code class="nx">groups</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, we narrow the right member of the <code>Toy</code> union by using TypeScript’s generic substitution:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>groups</code> is <code>T</code>, a <code>Record&lt;string, K[]</code>&gt;. <code>K[]</code> can be potentially broad.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>key</code> is in relation to <code>T</code>: a property key of <code>T</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>value</code> is of type <code>K</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>All three function parameters are in relation to one another, and the way we designed the type relations allows us to safely access <code>groups[key]</code> and push <code>value</code> to the array.</p>&#13;
&#13;
<p class="pagebreak-before">Also, the types of each parameter when we call <code>assign</code> fulfill the generic type constraints we just set. If you want to know more about this technique, check out <a data-type="xref" href="ch12.html#ch12_unexpected_intersections">Recipe 12.6</a>.<a data-startref="ix_05-03-asciidoc4" data-type="indexterm" id="id671"/><a data-startref="ix_05-03-asciidoc3" data-type="indexterm" id="id672"/><a data-startref="ix_05-03-asciidoc2" data-type="indexterm" id="id673"/><a data-startref="ix_05-03-asciidoc1" data-type="indexterm" id="id674"/><a data-startref="ix_05-03-asciidoc0" data-type="indexterm" id="id675"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.4 Removing Specific Object Properties" data-type="sect1"><div class="sect1" id="ch05_removing_object_properties">&#13;
<h1>5.4 Removing Specific Object Properties</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id220">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="removing specific object properties" data-type="indexterm" id="ix_05-04-asciidoc0"/><a data-primary="object type" data-secondary="removing specific object properties" data-type="indexterm" id="ix_05-04-asciidoc1"/><a data-primary="properties" data-secondary="removing specific object properties" data-type="indexterm" id="ix_05-04-asciidoc2"/>You want to create a generic helper type for objects, where you select properties based on their type rather than the property’s name.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id676">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Filter with conditional types and type assertions when mapping property keys.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id90">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript allows you to create types based on other types, so you can keep them up to date without maintaining every one of their derivates. We’ve seen examples in earlier items, like <a data-type="xref" href="ch04.html#ch04_new_object_types">Recipe 4.5</a>. In the following scenario, we want to adapt an existing object type based on the types of its properties. Let’s look at a type for <code>Person</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>It consists of two strings—<code>profession</code> and <code>name</code>—and a number: <code>age</code>. We want to create a type that consists only of string type properties:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonStrings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>TypeScript already has certain helper types to deal with filtering property names. For example, the mapped type <code>Pick&lt;T&gt;</code> takes a subset of an object’s keys to create a new object that contains only those keys:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Only includes "name"</code>&#13;
<code class="kr">type</code> <code class="nx">PersonName</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="s2">"name"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Includes "name" and "profession"</code>&#13;
<code class="kr">type</code> <code class="nx">PersonStrings</code> <code class="o">=</code> <code class="nx">Pick</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="s2">"name"</code> <code class="o">|</code> <code class="s2">"profession"</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>If we want to remove certain properties, we can use <code>Omit&lt;T&gt;</code>, which works just like <code>Pick&lt;T&gt;</code> with the small difference that we map through a slightly altered set of properties, one where we remove property names that we don’t want to include:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">|</code> <code class="kt">number</code> <code class="o">|</code> <code class="nx">symbol</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">P</code> <code class="k">in</code> <code class="nx">Exclude</code><code class="o">&lt;</code><code class="kr">keyof</code> <code class="nx">T</code><code class="p">,</code> <code class="nx">K</code><code class="o">&gt;</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">P</code><code class="p">];</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Omits age, thus includes "name" and "profession"</code>&#13;
<code class="kr">type</code> <code class="nx">PersonWithoutAge</code> <code class="o">=</code> <code class="nx">Omit</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="s2">"age"</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>To select the right properties based on their type, rather than their name, we would need to create a similar helper type, one where we map a dynamically generated set of property names that point only to the types  we are looking for. <a data-primary="never type" data-secondary="removing specific object properties with" data-type="indexterm" id="id677"/>We know from <a data-type="xref" href="#ch05_filtering_never">Recipe 5.2</a> that when using conditional types over a union type, we can use <code>never</code> to filter elements from this union.</p>&#13;
&#13;
<p>So a first possibility could be that we map all property keys of <code>Person</code> and check if <code>Person[K]</code> is a subset of our desired type. If so, we return the type; otherwise, we return <code>never</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="c1">// Not there yet</code>&#13;
<code class="kr">type</code> <code class="nx">PersonStrings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">Person</code><code class="p">]</code><code class="o">: </code><code class="kr">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="nx">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This is good, but it comes with a caveat: the types we are checking are not in a union but are types from a mapped type. So instead of filtering property keys, we would get properties that point to type <code>never</code>, meaning that we would forbid certain properties to be set at all.</p>&#13;
&#13;
<p>Another idea would be to set the type to <code>undefined</code>, treating the property as sort of optional but, as we learned in <a data-type="xref" href="ch03.html#ch03_item_missing_vs_undefined">Recipe 3.11</a>, missing properties and undefined values are not the same.</p>&#13;
&#13;
<p>What we actually want to do is drop the property keys that point to a certain type. This can be achieved by putting the condition not on the righthand side of the object but on the lefthand side, where the properties are created.</p>&#13;
&#13;
<p>Just like with the <code>Omit</code> type, we need to make sure that we map over a specific set of properties. When mapping <code>keyof Person</code>, it is possible to change the type of the property key with a type assertion. Just like with regular type assertions, there is a sort of fail-safe mechanism, meaning you just can’t assert it to be anything: it has to be within the boundaries of a property key.</p>&#13;
&#13;
<p>We want to assert that <code>K</code> part of the set if <code>Person[K]</code> is of type <code>string</code>. If this is true, we keep <code>K</code>; otherwise, we filter the element of the set with <code>never</code>. With <code>never</code> being on the lefthand side of the object, the property gets dropped:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonStrings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">Person</code> <code class="kr">as</code> <code class="nx">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">?</code> <code class="nx">K</code> <code class="o">:</code> <code class="kr">never</code><code class="p">]</code><code class="o">: </code><code class="kr">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>And with that, we select only property keys that point to string values. There is one catch: optional string properties have a broader type than regular strings, as &#13;
<span class="keep-together"><code>undefined</code></span> is also included as a possible value. Using a union type ensures that optional properties are also kept:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonStrings</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">Person</code> <code class="kr">as</code> <code class="nx">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">|</code> <code class="kc">undefined</code>&#13;
    <code class="o">?</code> <code class="nx">K</code>&#13;
    <code class="o">:</code> <code class="kr">never</code><code class="p">]</code><code class="o">: </code><code class="kr">Person</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>The next step is making this type generic. We create a type <code>Select&lt;O, T&gt;</code> by replacing <code>Person</code> with <code>O</code> and <code>string</code> with <code>T</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Select</code><code class="o">&lt;</code><code class="nx">O</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">O</code> <code class="kr">as</code> <code class="nx">O</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="nx">T</code> <code class="o">|</code> <code class="kc">undefined</code> <code class="o">?</code> <code class="nx">K</code> <code class="o">:</code> <code class="kr">never</code><code class="p">]</code><code class="o">:</code> <code class="nx">O</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This new helper type is versatile. We can use it to select properties of a certain type from our own object types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">PersonStrings</code> <code class="o">=</code> <code class="nx">Select</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="kr">type</code> <code class="nx">PersonNumbers</code> <code class="o">=</code> <code class="nx">Select</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>But we can also figure out, for example, which functions in the string prototype return a number:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">StringFnsReturningNumber</code> <code class="o">=</code> <code class="nx">Select</code><code class="o">&lt;</code><code class="nb">String</code><code class="p">,</code> <code class="p">(...</code><code class="nx">args</code><code class="o">:</code> <code class="kr">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>An inverse helper type <code>Remove&lt;O, T&gt;</code>, where we want to remove property keys of a certain type, is very similar to <code>Select&lt;O, T&gt;</code>. The only difference is to switch the condition and return <code>never</code> in the <code>true</code> branch:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">O</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">O</code> <code class="kr">as</code> <code class="nx">O</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="nx">T</code> <code class="o">|</code> <code class="kc">undefined</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">O</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">PersonWithoutStrings</code> <code class="o">=</code> <code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">Person</code><code class="p">,</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>This is especially helpful if you create a serializable version of your object types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">User</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">posts</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">[];</code>&#13;
  <code class="nx">greeting</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">SerializeableUser</code> <code class="o">=</code> <code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">User</code><code class="p">,</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>By knowing that you can do conditional types while mapping out keys, you suddenly have access to a wide range of potential helper types. More about that in <a data-type="xref" href="ch08.html#ch08">Chapter 8</a>.<a data-startref="ix_05-04-asciidoc2" data-type="indexterm" id="id678"/><a data-startref="ix_05-04-asciidoc1" data-type="indexterm" id="id679"/><a data-startref="ix_05-04-asciidoc0" data-type="indexterm" id="id680"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="5.5 Inferring Types in Conditionals" data-type="sect1"><div class="sect1" id="ch05_inferring_types_in_conditionals">&#13;
<h1>5.5 Inferring Types in Conditionals</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id91">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="inferring types in conditionals" data-type="indexterm" id="ix_05-05-asciidoc0"/><a data-primary="infer keyword" data-type="indexterm" id="ix_05-05-asciidoc1"/><a data-primary="recursive conditional types" data-secondary="inferring types in conditionals" data-type="indexterm" id="ix_05-05-asciidoc2"/><a data-primary="serialize function" data-type="indexterm" id="ix_05-05-asciidoc3"/>You want to create a class for object serialization, which removes all unserializable properties of an object like functions. If your object has a <code>serialize</code> function, the serializer takes the return value of the function instead of serializing the object on its own. How can you type that?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id681">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a recursive conditional type to modify the existing object type. For objects that implement <code>serialize</code>, use the <code>infer</code> keyword to pin the generic return type to a &#13;
<span class="keep-together">concrete</span> type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id92">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p><a data-primary="serialization, defined" data-type="indexterm" id="id682"/>Serialization is the process of converting data structures and objects into a format that can be stored or transferred. Think of taking a JavaScript object and storing its data on disk, just to pick it up later by deserializing it again into JavaScript.</p>&#13;
&#13;
<p>JavaScript objects can hold any type of data: primitive types like strings or numbers, as well as compound types like objects, and even functions. Functions are interesting as they don’t contain data but behavior: something that can’t be serialized well. One approach to serializing JavaScript objects is to get rid of functions entirely. And this is what we want to implement in this lesson.</p>&#13;
&#13;
<p>We start with a simple object type <code>Person</code>, which contains the usual subjects of data we want to store: a person’s name and age. It also has a <code>hello</code> method, which produces a string:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>We want to serialize objects of this type. A <code>Serializer</code> class contains an empty constructor and a generic function <code>serialize</code>. Note that we add the generic type parameter to <code>serialize</code> and not to the class. That way, we can reuse <code>serialize</code> for different object types. <a data-primary="Serialize&lt;T&gt; type" data-type="indexterm" id="ix_05-05-asciidoc4"/>The return type points to a generic type <code>Serialize&lt;T&gt;</code>, which will be the result of the serialization process:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Serializer</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{}</code>&#13;
  <code class="nx">serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// tbd...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We will take care of the implementation later. For now let’s focus on the &#13;
<span class="keep-together"><code>Serialize&lt;T&gt;</code></span> type. The first idea that comes to mind is to just drop properties that are functions. We already defined a <code>Remove&lt;O, T&gt;</code> type in <a data-type="xref" href="#ch05_removing_object_properties">Recipe 5.4</a> that comes in handy, as it does exactly that—removes properties that are of a certain type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">O</code><code class="p">,</code> <code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">O</code> <code class="kr">as</code> <code class="nx">O</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="nx">T</code> <code class="o">|</code> <code class="kc">undefined</code> <code class="o">?</code> <code class="kr">never</code> <code class="o">:</code> <code class="nx">K</code><code class="p">]</code><code class="o">:</code> <code class="nx">O</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>The first iteration is done, and it works for simple, one-level-deep objects. Objects can be complex, however. For example, <code>Person</code> could nest other objects, which in turn also could have functions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="nx">level</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
    <code class="nx">printProfession</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>To solve this, we need to check each property if it is another object, and if so, use the <code>Serialize&lt;T&gt;</code> type again. A mapped type called <code>NestSerialization</code> checks in a conditional type if each property is of type <code>object</code> and returns a serialized version of that type in the <code>true</code> branch and the type itself in the <code>false</code> branch:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">NestSerialization</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code><code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code> <code class="kr">extends</code> <code class="nx">object</code> <code class="o">?</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code> <code class="o">:</code> <code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">];</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>We redefine <code>Serialize&lt;T&gt;</code> by wrapping the original <code>Remove&lt;T, Function&gt;</code> type of <code>Serialize&lt;T&gt;</code> in <code>NestSerialization</code>, effectively creating a <em>recursive type</em>: &#13;
<span class="keep-together"><code>Serialize&lt;T&gt;</code></span> uses <code>NestSerialization&lt;T&gt;</code> uses <code>Serialize&lt;T&gt;</code>, and so on:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">NestSerialization</code><code class="o">&lt;</code><code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nb">Function</code><code class="o">&gt;&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>TypeScript can handle type recursion to a certain degree. In this case, it can see that there is literally a condition to break out of type recursion in <code>NestSerialization</code>.</p>&#13;
&#13;
<p>And that’s serialization type! Now for the implementation of the function, which is curiously a straight translation of our type declaration in JavaScript. We check for every property if it’s an object. If so, we call <code>serialize</code> again. If not, we carry over the property only if it isn’t a function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Serializer</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{}</code>&#13;
  <code class="nx">serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">ret</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{};</code>&#13;
&#13;
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">===</code> <code class="s2">"object"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">ret</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">serialize</code><code class="p">(</code><code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>&#13;
      <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">!==</code> <code class="s2">"function"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">ret</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="nx">ret</code> <code class="kr">as</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that since we are generating a new object within <code>serialize</code>, we start out with a very broad <code>Record&lt;string, any&gt;</code>, which allows us to set any string property key to basically anything, and assert at the end that we created an object that fits our return type. This pattern is common when you create new objects, but it ultimately requires you to be 100% sure that you did everything right. Please test this function &#13;
<span class="keep-together">extensively.</span></p>&#13;
&#13;
<p>With the first implementation done, we can create a new object of type <code>Person</code> and pass it to our newly generated serializer:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">person</code><code class="o">: </code><code class="kr">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Software Developer"</code><code class="p">,</code>&#13;
    <code class="nx">level</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code>&#13;
    <code class="nx">printProfession</code><code class="p">()</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">title</code><code class="si">}</code><code class="sb">, Level </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">level</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="p">},</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">hello</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="sb">`Hello </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">serializer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Serializer</code><code class="p">();</code>&#13;
<code class="kr">const</code> <code class="nx">serializedPerson</code> <code class="o">=</code> <code class="nx">serializer</code><code class="p">.</code><code class="nx">serialize</code><code class="p">(</code><code class="nx">person</code><code class="p">);</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">serializedPerson</code><code class="p">);</code></pre>&#13;
&#13;
<p>The result is as expected: the type of <code>serializedPerson</code> lacks all information on methods and functions. And if we log <code>serializedPerson</code>, we also see that all methods and functions are gone. The type matches the implementation result:</p>&#13;
&#13;
<pre data-type="programlisting">[LOG]: {&#13;
  "name": "Stefan",&#13;
  "age": 40,&#13;
  "profession": {&#13;
    "title": "Software Developer",&#13;
    "level": 5&#13;
  }&#13;
}</pre>&#13;
&#13;
<p>But we are not done yet. The serializer has a special feature. Objects can implement a <code>serialize</code> method, and if they do, the serializer takes the output of this method instead of serializing the object on its own. Let’s extend the <code>Person</code> type to feature a <code>serialize</code> method:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="nx">level</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
    <code class="nx">printProfession</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
  <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">serialize</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">person</code><code class="o">: </code><code class="kr">Person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="nx">profession</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Software Developer"</code><code class="p">,</code>&#13;
    <code class="nx">level</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code>&#13;
    <code class="nx">printProfession</code><code class="p">()</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">title</code><code class="si">}</code><code class="sb">, Level </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">level</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="p">},</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">hello</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="sb">`Hello </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">serialize</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">profession</code><code class="p">.</code><code class="nx">title</code><code class="si">}</code><code class="sb"> L</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">profession</code><code class="p">.</code><code class="nx">level</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p class="pagebreak-before">We need to adapt the <code>Serialize&lt;T&gt;</code> type. Before running <code>NestSerialization</code>, we check in a conditional type if the object implements a <code>serialize</code> method. We do so by asking if <code>T</code> is a subtype of a type that contains a <code>serialize</code> method. If so, we need to get to the return type, because that’s the result of serialization.</p>&#13;
&#13;
<p>This is where the <code>infer</code> keyword comes into play. It allows us to take a type from a condition and use it as a type parameter in the <code>true</code> branch. We tell TypeScript, if this condition is true, take the type that you found there and make it available to us:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="p">{</code> <code class="nx">serialize</code><code class="p">()</code><code class="o">:</code> <code class="kr">infer</code> <code class="nx">R</code> <code class="p">}</code>&#13;
  <code class="o">?</code> <code class="nx">R</code>&#13;
  <code class="o">:</code> <code class="nx">NestSerialization</code><code class="o">&lt;</code><code class="nx">Remove</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nb">Function</code><code class="o">&gt;&gt;</code><code class="p">;</code></pre>&#13;
&#13;
<p>Think of <code>R</code> as being <code>any</code> at first. If we check <code>Person</code> against <code>{ serialize(): any }</code> we hop into the <code>true</code> branch, as <code>Person</code> has a <code>serialize</code> function, making it a valid sub-type. <a data-primary="any type" data-secondary="Serialize&lt;T&gt; and" data-type="indexterm" id="id683"/>But <code>any</code> is broad, and we are interested in the specific type at the position of <code>any</code>. The <code>infer</code> keyword can pick that exact type. So <code>Serialize&lt;T&gt;</code> now reads:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If <code>T</code> contains a <code>serialize</code> method, get its return type and return it.</p>&#13;
</li>&#13;
<li>&#13;
<p>Otherwise, start serialization by deeply removing all properties that are of type <code>Function</code>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We want to mirror that type’s behavior in our JavaScript implementation as well. We do a couple of type-checks (checking if <code>serialize</code> is available and if it’s a function) and ultimately call it. TypeScript requires us to be explicit with type guards, to be absolutely sure that this function exists:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">Serializer</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{}</code>&#13;
  <code class="nx">serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code>&#13;
      <code class="c1">// is an object</code>&#13;
      <code class="k">typeof</code> <code class="nx">obj</code> <code class="o">===</code> <code class="s2">"object"</code> <code class="o">&amp;&amp;</code>&#13;
      <code class="c1">// not null</code>&#13;
      <code class="nx">obj</code> <code class="o">&amp;&amp;</code>&#13;
      <code class="c1">// serialize is available</code>&#13;
      <code class="s2">"serialize"</code> <code class="k">in</code> <code class="nx">obj</code> <code class="o">&amp;&amp;</code>&#13;
      <code class="c1">// and a function</code>&#13;
      <code class="k">typeof</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">serialize</code> <code class="o">===</code> <code class="s2">"function"</code>&#13;
    <code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">obj</code><code class="p">.</code><code class="nx">serialize</code><code class="p">();</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">const</code> <code class="nx">ret</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{};</code>&#13;
&#13;
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">obj</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">===</code> <code class="s2">"object"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">ret</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">serialize</code><code class="p">(</code><code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>&#13;
      <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">!==</code> <code class="s2">"function"</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">ret</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">[</code><code class="nx">k</code><code class="p">];</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="nx">ret</code> <code class="kr">as</code> <code class="nx">Serialize</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this change, the type of <code>serializedPerson</code> is <code>string</code>, and the result is as expected:</p>&#13;
&#13;
<pre data-type="programlisting">[LOG]: "Stefan: Software Developer L5"</pre>&#13;
&#13;
<p>This powerful tool helps greatly with object generation. And there’s beauty in the fact that we create a type using a declarative metalanguage that is TypeScript’s type system, to ultimately see the same process imperatively written in JavaScript<a data-startref="ix_05-05-asciidoc4" data-type="indexterm" id="id684"/>.<a data-startref="ix_05-05-asciidoc3" data-type="indexterm" id="id685"/><a data-startref="ix_05-05-asciidoc2" data-type="indexterm" id="id686"/><a data-startref="ix_05-05-asciidoc1" data-type="indexterm" id="id687"/><a data-startref="ix_05-05-asciidoc0" data-type="indexterm" id="id688"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>