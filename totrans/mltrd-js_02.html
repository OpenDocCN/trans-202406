<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" class="calibre4" data-pdf-bookmark="Chapter 1. Introduction"><div class="preface" id="ch_intro">
<h1 class="calibre12"><span class="keep-together">Chapter 1. </span>Introduction</h1>


<p class="author1">Computers used to be much simpler. That’s not to say they were easy to use or write code for, but conceptually there was a lot less to work with. PCs in the 1980s typically had a single 8-bit CPU core and not a whole lot of memory. You typically could only run a single program at one time. What we think of these days as operating systems would not even be running at the same time as the program the user was interacting with.</p>

<p class="author1">Eventually, people wanted to run more than one program at once, and multitasking was born. This allowed operating systems to run several programs at the same time by switching execution between them. Programs could decide when it would be an appropriate time to let another program run by yielding execution to the operating system. This <a data-type="indexterm" data-primary="cooperative multitasking" id="idm45995937294696" class="calibre6"/><a data-type="indexterm" data-primary="multitasking" data-secondary="cooperative multitasking" id="idm45995937294024" class="calibre6"/>approach is called <em class="calibre7">cooperative multitasking</em>.</p>

<p class="author1">In a cooperative multitasking environment, when a program fails to yield execution for any reason, no other program can continue executing. This interruption of other programs is not desirable, so <a data-type="indexterm" data-primary="multitasking" data-secondary="preemptive multitasking" id="idm45995937291944" class="calibre6"/><a data-type="indexterm" data-primary="preemptive multitasking" id="idm45995937290968" class="calibre6"/>eventually operating systems moved toward <em class="calibre7">preemptive multitasking</em>. In this model, the operating system would determine which program would run on the CPU at which time, using its own notion of scheduling, rather than relying on the programs themselves to be the sole deciders of when to switch execution. To this day, almost every operating system uses this approach, even on 
<span class="keep-together">multi-core</span> systems, because we generally have more programs running than we have 
<span class="keep-together">CPU cores.</span></p>

<p class="author1">Running multiple tasks at once is extremely useful for both programmers and users. Before threads, a single <a data-type="indexterm" data-primary="processes" id="idm45995937287656" class="calibre6"/><a data-type="indexterm" data-primary="multitasking" data-secondary="processes" id="idm45995937286952" class="calibre6"/>program (that is, a single <em class="calibre7">process</em>) could not have multiple tasks running at the same time. Instead, programmers wishing to perform tasks concurrently would either have to split up the task into smaller chunks and schedule them inside the process or run separate tasks in separate processes and have them communicate with each other.</p>

<p class="author1">Even today, in some high-level languages the appropriate way to run multiple tasks at once is to run additional processes. In some languages, like Ruby and Python, there’s a <em class="calibre7">global interpreter lock (GIL)</em>, meaning <a data-type="indexterm" data-primary="GIL (global interpreter lock)" id="idm45995937284056" class="calibre6"/>only one thread can be executing at a given time. While this makes memory management far more practical, it makes multithreaded programming not as attractive to programmers, and instead multiple processes are employed.</p>

<p class="author1">Until fairly recently, JavaScript <a data-type="indexterm" data-primary="multitasking" data-secondary="JavaScript and" id="idm45995937282312" class="calibre6"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="multitasking" id="idm45995937281336" class="calibre6"/>was a language where the only multitasking mechanisms available were splitting tasks up and scheduling their pieces for later execution, and in the case of Node.js, running additional processes. We’d typically break code <a data-type="indexterm" data-primary="callbacks" data-secondary="asynchronous code" id="idm45995937280024" class="calibre6"/><a data-type="indexterm" data-primary="code" data-secondary="asynchronous" id="idm45995937279080" class="calibre6"/><a data-type="indexterm" data-primary="asynchronous code" id="idm45995937278136" class="calibre6"/><a data-type="indexterm" data-primary="Node.js" data-secondary="callbacks" id="idm45995937277464" class="calibre6"/>up into asynchronous units using callbacks or promises. A typical chunk of code written in this manner might look something like <a data-type="xref" href="#ex_async_code" class="calibre6">Example 1-1</a>, breaking up the operations by callbacks or <code class="calibre18">await</code>.</p>
<div id="ex_async_code" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-1. </span>A typical chunk of asynchronous JavaScript code, using two different patterns</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="nx">readFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="p">(</code><code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">doSomethingWithData</code><code class="p">(</code><code class="nx">data</code><code class="p">,</code> <code class="p">(</code><code class="nx">modifiedData</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">writeFile</code><code class="p">(</code><code class="nx">modifiedData</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'done'</code><code class="p">);</code>
    <code class="p">});</code>
  <code class="p">});</code>
<code class="p">});</code>

<code class="c">// or</code>

<code class="kr">const</code> <code class="nx">data</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">readFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">);</code>
<code class="kr">const</code> <code class="nx">modifiedData</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">doSomethingWithData</code><code class="p">(</code><code class="nx">data</code><code class="p">);</code>
<code class="nx">await</code> <code class="nx">writeFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">);</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'done'</code><code class="p">);</code></pre></div>

<p class="author1">Today, in all major JavaScript environments, we have access to threads, and unlike Ruby and Python, we don’t have a GIL making them effectively useless for performing CPU-intensive tasks. Instead, other trade-offs are made, like not sharing JavaScript objects across threads (at least not directly). Still, threads are useful to JavaScript developers for cordoning off CPU-intensive tasks. In the browser, there are also special-purpose threads that have feature sets available to them that are different from the main thread. The details of how we can do this are the topics of later chapters, but to give you an idea, spawning a new thread and handling a message in a browser can be as simple as <a data-type="xref" href="#ex_intro_spawn_thread" class="calibre6">Example 1-2</a>.</p>
<div id="ex_intro_spawn_thread" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-2. </span>Spawning a browser thread</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code> <code class="nx">worker</code> <code class="o">=</code> <code class="kr">new</code> <code class="nx">Worker</code><code class="p">(</code><code class="s">'worker.js'</code><code class="p">);</code>
<code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="s">'Hello, world'</code><code class="p">);</code>

<code class="c">// worker.js</code>
<code class="nx">self</code><code class="p">.</code><code class="nx">onmessage</code> <code class="o">=</code> <code class="p">(</code><code class="nx">msg</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">data</code><code class="p">);</code></pre></div>

<p class="author1">The purpose of this book is to explore and explain JavaScript threads as a programming concept and tool. You’ll learn how to use them and, more importantly, when to use them. Not every problem needs to be solved with threads. Not even every CPU-intensive problem needs to be solved with threads. It’s the job of software developers to evaluate problems and tools to determine the most appropriate solutions. The aim here is to give you another tool and enough knowledge around it to know when to use it and how.</p>






<section data-type="sect1" data-pdf-bookmark="What Are Threads?" class="calibre4"><div class="preface" id="idm45995933617304">
<h1 class="calibre13">What Are Threads?</h1>

<p class="author1">In all modern operating systems, all units of execution outside the kernel are organized into processes and threads. Developers can use processes and threads, and communication between them, to add concurrency to a project. On systems with multiple CPU cores, this also means adding parallelism.</p>

<p class="author1">When you execute a program, such as Node.js or a code editor, you’re initiating a process. This means that <a data-type="indexterm" data-primary="processes" data-secondary="initiating" id="idm45995933615464" class="calibre6"/>code is loaded into a memory space unique to that process, and no other memory space can be addressed by the program without asking the kernel either for more memory or for a different memory space to be mapped in. Without adding <a data-type="indexterm" data-primary="instructions, executing" id="idm45995933614120" class="calibre6"/>threads or additional processes, only one <em class="calibre7">instruction</em> is executed at a time, in the appropriate order as prescribed by the program code. If you’re unfamiliar, you can think of instructions as a single unit of code, like a line of code. (In fact, an instruction generally corresponds to one line in your processor’s assembly code!)</p>

<p class="author1">A program may spawn additional <a data-type="indexterm" data-primary="processes" data-secondary="memory" id="idm45995933612216" class="calibre6"/><a data-type="indexterm" data-primary="memory" data-secondary="processes" id="idm45995933611240" class="calibre6"/>processes, which have their own memory space. These processes do not share memory (unless it’s mapped in via additional system calls) and have their own instruction pointers, meaning each one can be executing a different instruction at the same time. If the processes are being executed on the same core, the processor may switch back and forth between processes, temporarily stopping execution for that one process while another one executes.</p>

<p class="author1">A process may also spawn <a data-type="indexterm" data-primary="processes" data-secondary="threads" id="idm45995933609320" class="calibre6"/>threads, rather than full-blown processes. A thread is just like a process, except that it shares memory space with the process that it belongs to. A process can have many threads, and each one has its own instruction pointer. All the same properties about execution of processes apply to threads as well. Because they share a memory space, it’s easy to share program code and other values between threads. This makes them more valuable than processes for adding concurrency to programs, but at the cost of some complexity in programming, which we’ll cover later on in this book.</p>

<p class="author1">A typical way to take advantage of threads is to offload CPU-intensive work, like mathematical operations, to an additional thread or pool of threads while the main thread is free to interact <a data-type="indexterm" data-primary="threads" data-secondary="HTTP requests" id="idm45995933607032" class="calibre6"/><a data-type="indexterm" data-primary="HTTP requests" id="idm45995933606056" class="calibre6"/>externally with the user or other programs by checking for new interactions inside an infinite loop. Many classic web server programs, such as Apache, use a system like this to handle large loads of HTTP requests. This might end up looking something like <a data-type="xref" href="#fig_http_worker_threads_sequence" class="calibre6">Figure 1-1</a>. In this model, HTTP request data is passed to a worker thread for processing, and when the response is ready, it’s handed back to the main thread to be returned back to the user agent.</p>

<figure class="calibre29"><div id="fig_http_worker_threads_sequence" class="figure">
<h6 class="calibre30"><span class="keep-together">Figure 1-1. </span>Worker threads as they might be used in an HTTP server</h6>
</div></figure>

<p class="author1">In order for threads to be useful, they need to be able to coordinate with each other. This means they have to be able to do things like wait for things to happen on other threads and get data from them. As discussed, we have a shared memory space between threads, and with some other basic primitives, systems for passing messages between threads can be constructed. In many cases, these sorts of constructs are available at the language or platform level.</p>
</div></section>













<section data-type="sect1" class="calibre4" data-pdf-bookmark="Concurrency Versus Parallelism"><div class="preface" id="idm45995933601048">
<h1 class="calibre13">Concurrency Versus Parallelism</h1>

<p class="author1">It’s important to distinguish between <a data-type="indexterm" data-primary="concurrency" id="concur" class="calibre6"/><a data-type="indexterm" data-primary="parallelism" id="paraism" class="calibre6"/>concurrency and parallelism, since they’ll come up fairly often when programming in a multithreaded manner. These are closely related terms that can mean very similar things depending on the circumstances. Let’s start with some definitions.</p>
<dl class="calibre14">
<dt class="calibre15">Concurrency</dt>
<dd class="calibre16">
<p class="calibre17">Tasks are run in overlapping time.</p>
</dd>
<dt class="calibre15">Parallelism</dt>
<dd class="calibre16">
<p class="calibre17">Tasks are run at exactly the same time.</p>
</dd>
</dl>

<p class="author1">While it may seem like these mean the same thing, consider that tasks may be broken up into smaller parts and then interleaved. In this case, concurrency can be achieved without parallelism because the time frames that the tasks run in can be overlapped. For tasks to be running with parallelism, they must be running at <em class="calibre7">exactly the same time</em>. Generally, this means they must be running on separate CPU cores at exactly the same time.</p>

<p class="author1">Consider <a data-type="xref" href="#fig_concurrency_vs_parallelism" class="calibre6">Figure 1-2</a>. In it, we have two tasks running in parallel and concurrently. In the concurrent case, only one task is being executed at a given time, but throughout the entire period, execution switched between the two tasks. This means they’re running in overlapping time, so it fits the definition of concurrency. In the parallel case, both tasks are executing simultaneously, so they’re running in parallel. Since they’re <em class="calibre7">also</em> running in an overlapping time period, they’re also running concurrently. Parallelism is a subset of concurrency.</p>

<figure class="calibre29"><div id="fig_concurrency_vs_parallelism" class="figure">
<img src="Images/mtjs_0102.png" alt="Visualizing the difference between parallelism." class="calibre31"/>
<h6 class="calibre30"><span class="keep-together">Figure 1-2. </span>Concurrency versus parallelism</h6>
</div></figure>

<p class="author1">Threads do not automatically provide parallelism. The system hardware must allow for this by having multiple CPU cores, and the operating system scheduler must decide to run the <a data-type="indexterm" data-primary="CPU, parallelism" id="idm45995933119784" class="calibre6"/>threads on separate CPU cores. On single-core systems, or systems with more threads running than CPU cores, multiple threads may be run on a single CPU concurrently by switching between them at appropriate times. Also, in languages with a GIL like Ruby and Python, threads are explicitly prevented from offering parallelism because only one instruction can be executed at a time throughout the entire runtime.</p>

<p class="author1">It’s important to also think about this in terms of timing because threads are typically added to a program to increase performance. If your system is only allowing for concurrency due to only having a single CPU core available or being already loaded with other tasks, then there may not be any perceived benefit to using extra threads. In fact, the overhead of synchronization and context-switching between the threads may end up making the program perform even worse. Always measure the performance of your application under the conditions it’s expected to run in. That way you can verify whether a multithreaded programming model will actually be <a data-type="indexterm" data-primary="concurrency" data-startref="concur" id="idm45995933117464" class="calibre6"/><a data-type="indexterm" data-primary="parallelism" data-startref="paraism" id="idm45995933116488" class="calibre6"/>beneficial to you.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Single-Threaded JavaScript" class="calibre4"><div class="preface" id="idm45995933115288">
<h1 class="calibre13">Single-Threaded JavaScript</h1>

<p class="author1">Historically, the platforms that JavaScript <a data-type="indexterm" data-primary="single-threaded JavaScript" id="sing_Java" class="calibre6"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="single-threading" id="JavaSing" class="calibre6"/>ran on did not provide any thread support, so the language was thought of as single-threaded. Whenever you hear someone say that JavaScript is single-threaded, they’re referring to this historical background and the programming style that it naturally lent itself to. It’s true that, despite the title of this book, the language itself does not have any built-in functionality to create threads. This shouldn’t be that much of a surprise because it also doesn’t have any built-in functionality to interact with the network, devices, or filesystem, or to make any system calls. Indeed, even such basics as <code class="calibre18">setTimeout()</code> aren’t actually JavaScript features. Instead environments the virtual machine (VM) is embedded in, such as Node.js or browsers, provide these via environment-specific APIs.</p>

<p class="author1">Instead of threads as a <a data-type="indexterm" data-primary="JavaScript" data-secondary="event orientation" id="idm45995933109368" class="calibre6"/>concurrency primitive, most JavaScript code is written in an event-oriented manner operating on a single execution thread. As various events like user interactions or I/O happen, they trigger the execution of functions previously set to run upon these events. These <a data-type="indexterm" data-primary="callbacks" id="idm45995933107976" class="calibre6"/>functions are typically called <em class="calibre7">callbacks</em> and are at the core of how asynchronous programming is done in Node.js and the browser. Even in promises or the <code class="calibre18">async</code>/<code class="calibre18">await</code> syntax, callbacks are the underlying primitive. It’s important to recognize that callbacks are not running in parallel, or alongside any other code. When code in a callback is running, that’s the only code that’s currently running. Put another way, only one call stack is active at any given time.</p>

<p class="author1">It’s often easy to think of operations happening in parallel, when in fact they’re happening concurrently. For example, imagine you want to open three files containing numbers, named <em class="calibre7">1.txt</em>, <em class="calibre7">2.txt</em>, and <em class="calibre7">3.txt</em>, and then add up the results and print them. In Node.js, you might <a data-type="indexterm" data-primary="Node.js" data-secondary="reading from files" id="idm45995933103448" class="calibre6"/>do something like <a data-type="xref" href="#ex_node_async_promise_all_concurrency" class="calibre6">Example 1-3</a>.</p>
<div id="ex_node_async_promise_all_concurrency" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-3. </span>Reading from files concurrently in Node.js</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">import</code> <code class="nx">fs</code> <code class="nx">from</code> <code class="s">'fs/promises'</code><code class="p">;</code>

<code class="nx">async</code> <code class="kr">function</code> <code class="nx">getNum</code><code class="p">(</code><code class="nx">filename</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">return</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">await</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="s">'utf8'</code><code class="p">),</code> <code class="mi">10</code><code class="p">);</code>
<code class="p">}</code>

<code class="kr">try</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">numberPromises</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="nx">getNum</code><code class="p">(</code><code class="s">`</code><code class="si">${</code><code class="nx">i</code><code class="si">}</code><code class="s">.txt`</code><code class="p">));</code>
  <code class="kr">const</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="nx">await</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code><code class="nx">numberPromises</code><code class="p">);</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">numbers</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">+</code> <code class="nx">numbers</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">+</code> <code class="nx">numbers</code><code class="p">[</code><code class="mi">2</code><code class="p">]);</code>
<code class="p">}</code> <code class="kr">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s">'Something went wrong:'</code><code class="p">);</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">To run this code, save it in a file called <em class="calibre7">reader.js</em>. Make sure you have text files named <em class="calibre7">1.txt</em>, <em class="calibre7">2.txt</em>, and <em class="calibre7">3.txt</em>, each containing integers, and then run the program with <code class="calibre18">node reader.js</code>.</p></div>

<p class="author1">Since we’re using <code class="calibre18">Promise.all()</code>, we’re waiting for all three files to be read and parsed. If you squint a bit, it may even look similar to the <code class="calibre18">pthread_join()</code> from the C example later in this chapter. However, just because the promises are being created together and waited upon together doesn’t mean that the code resolving them runs at the same time, it just means their time frames are overlapping. There’s still only one instruction pointer, and only one instruction is being executed at a time.</p>

<p class="author1">In the absence of threads, there’s only one JavaScript <a data-type="indexterm" data-primary="environments" id="idm45995934215576" class="calibre6"/>environment to work with. This means one instance of the VM, one instruction pointer, and one instance of the garbage collector. By one instruction pointer, we mean that the JavaScript interpreter is only executing one instruction at any given time. That doesn’t mean we’re restricted to one global object though. In both the browser and Node.js, we have <a href="https://oreil.ly/uy7E2" class="calibre6">realms</a> at our disposal.</p>

<p class="author1">Realms can be thought of as <a data-type="indexterm" data-primary="realms" id="idm45995934213384" class="calibre6"/>instances of the JavaScript environment as provided to JavaScript code. This means that each realm gets its own global object, and all of the associated <a data-type="indexterm" data-primary="objects" data-secondary="global" id="idm45995934211992" class="calibre6"/><a data-type="indexterm" data-primary="global objects" id="idm45995934211048" class="calibre6"/><a data-type="indexterm" data-primary="realms" data-secondary="objects" data-tertiary="global" id="idm45995934210376" class="calibre6"/>properties of the global object, such as built-in classes like <code class="calibre18">Date</code> and other objects like <code class="calibre18">Math</code>. The global object is referred <a data-type="indexterm" data-primary="Node.js" data-secondary="global object" id="idm45995934208232" class="calibre6"/>to as <code class="calibre18">global</code> in Node.js and <code class="calibre18">window</code> 
<span class="keep-together">in browsers,</span> but in modern versions of both, you can refer to the global object as 
<span class="keep-together"><code class="calibre18">globalThis</code></span>.</p>

<p class="author1">In browsers, each frame in a web page has a realm for all of the JavaScript within it. Because each frame has its own copy of <code class="calibre18">Object</code> and other primitives within it, you’ll notice that they have their own inheritance trees, and <code class="calibre18">instanceof</code> might not work as you expect it to when operating on objects from different realms. This is demonstrated in <a data-type="xref" href="#ex_browser_iframe_object" class="calibre6">Example 1-4</a>.</p>
<div id="ex_browser_iframe_object" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-4. </span>Objects from a different frame in a browser</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code><code class="calibre18"> </code><code class="nx">iframe</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s">'iframe'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="nb">document</code><code class="p">.</code><code class="nx">body</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">iframe</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">FrameObject</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">iframe</code><code class="p">.</code><code class="nx">contentWindow</code><code class="p">.</code><code class="nb">Object</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO1-1" href="#callout_introduction_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">

</code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="calibre18"> </code><code class="o">===</code><code class="calibre18"> </code><code class="nx">FrameObject</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO1-2" href="#callout_introduction_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
</code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kr">new</code><code class="calibre18"> </code><code class="nb">Object</code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="kr">instanceof</code><code class="calibre18"> </code><code class="nx">FrameObject</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO1-3" href="#callout_introduction_CO1-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">
</code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">FrameObject</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO1-4" href="#callout_introduction_CO1-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO1-1" href="#co_introduction_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The global object inside the <code class="calibre18">iframe</code> is accessible with the <code class="calibre18">contentWindow</code> property.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO1-2" href="#co_introduction_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">This returns false, so the <code class="calibre18">Object</code> inside the frame is not the same as in the main frame.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO1-3" href="#co_introduction_CO1-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34"><code class="calibre18">instanceof</code> evaluates to <code class="calibre18">false</code>, as expected since they’re not the same <code class="calibre18">Object</code>.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO1-4" href="#co_introduction_CO1-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">Despite all this, the constructors have the same <code class="calibre18">name</code> property.</p></dd>
</dl></div>

<p class="author1">In Node.js, realms can be constructed <a data-type="indexterm" data-primary="realms" data-secondary="Node.js" id="idm45995934006600" class="calibre6"/><a data-type="indexterm" data-primary="Node.js" data-secondary="realms" id="idm45995934005624" class="calibre6"/><a data-type="indexterm" data-primary="vm.createContext() function" id="idm45995934004680" class="calibre6"/><a data-type="indexterm" data-primary="functions" data-secondary="vm.createContext()" id="idm45995934003992" class="calibre6"/>with the <code class="calibre18">vm.createContext()</code> function, as shown in <a data-type="xref" href="#ex_node_context" class="calibre6">Example 1-5</a>. In Node.js parlance, <a data-type="indexterm" data-primary="Node.js" data-secondary="Contexts" id="idm45995934001640" class="calibre6"/><a data-type="indexterm" data-primary="Contexts" id="idm45995934000664" class="calibre6"/>realms are called Contexts. All the same rules and properties applying to browser frames also apply to Contexts, but in Contexts, you don’t have access to any global properties or anything else that might be in scope in your Node.js files. If you want to use these features, they need to be manually passed in to the Context.</p>
<div id="ex_node_context" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-5. </span>Objects from a new Context in Node.js</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code><code class="calibre18"> </code><code class="nx">vm</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">require</code><code class="p">(</code><code class="s">'vm'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">ContextObject</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">vm</code><code class="p">.</code><code class="nx">runInNewContext</code><code class="p">(</code><code class="s">'Object'</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO2-1" href="#callout_introduction_CO2-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">

</code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">Object</code><code class="calibre18"> </code><code class="o">===</code><code class="calibre18"> </code><code class="nx">ContextObject</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO2-2" href="#callout_introduction_CO2-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
</code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="kr">new</code><code class="calibre18"> </code><code class="nb">Object</code><code class="p">(</code><code class="p">)</code><code class="calibre18"> </code><code class="kr">instanceof</code><code class="calibre18"> </code><code class="nx">ContextObject</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO2-3" href="#callout_introduction_CO2-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">
</code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ContextObject</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO2-4" href="#callout_introduction_CO2-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO2-1" href="#co_introduction_CO2-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">We can get objects from a new context using <code class="calibre18">runInNewContext</code>.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO2-2" href="#co_introduction_CO2-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">This returns false, so as with browser iframes, <code class="calibre18">Object</code> inside the context is not the same as in the main context.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO2-3" href="#co_introduction_CO2-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">Similarly, <code class="calibre18">instanceof</code> evaluates to <code class="calibre18">false</code>.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO2-4" href="#co_introduction_CO2-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">Once again, the constructors have the same <code class="calibre18">name</code> property.</p></dd>
</dl></div>

<p class="author1">In any of these realm cases, it’s important to note that we still only have one instruction pointer, and code from only one realm is running at a time, because we’re still only talking about single-threaded <a data-type="indexterm" data-primary="single-threaded JavaScript" data-startref="sing_Java" id="idm45995936565192" class="calibre6"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="single-threading" data-startref="JavaSing" id="idm45995936564360" class="calibre6"/>execution.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Hidden Threads" class="calibre4"><div class="preface" id="sec_hidden_threads">
<h1 class="calibre13">Hidden Threads</h1>

<p class="author1">While your JavaScript code <a data-type="indexterm" data-primary="threads" data-secondary="hidden" id="thrhid" class="calibre6"/><a data-type="indexterm" data-primary="hidden threads" id="hidthr" class="calibre6"/>may run, at least by default, in a single-threaded environment, that doesn’t mean the process running your code is single-threaded. In fact, many threads might be used to have that code running smoothly and efficiently. It’s a common misconception that Node.js is a single-threaded process.</p>

<p class="author1">Modern JavaScript engines like V8 use <a data-type="indexterm" data-primary="V8" id="idm45995936558200" class="calibre6"/>separate threads to handle garbage collection and other features that don’t need to happen in line with JavaScript execution. In addition, the platform runtimes themselves may use additional threads to provide other features.</p>

<p class="author1">In Node.js, <code class="calibre18">libuv</code> is used <a data-type="indexterm" data-primary="Node.js" data-secondary="libuv" id="idm45995936556296" class="calibre6"/><a data-type="indexterm" data-primary="libuv library" id="idm45995936555288" class="calibre6"/><a data-type="indexterm" data-primary="libraries" data-secondary="libuv" id="idm45995936554616" class="calibre6"/>as an OS-independent asynchronous I/O interface, and since not all system-provided I/O interfaces are asynchronous, it uses a pool of worker threads to avoid blocking program code when using otherwise-blocking APIs, such as filesystem APIs. By default, four of these threads are spawned, though this number is configurable via the <code class="calibre18">UV_THREADPOOL_SIZE</code> environment variable, and can be up to 1,024.</p>

<p class="author1">On Linux systems, you can see these extra threads by using <code class="calibre18">top -H</code> on a given process. In <a data-type="xref" href="#ex_threads_from_top" class="calibre6">Example 1-6</a>, a simple Node.js web server was started, and the PID was noted and passed to <code class="calibre18">top</code>. You can see the various V8 and <code class="calibre18">libuv</code> threads add up to seven threads, including the one that the JavaScript code runs in. You can try this with your own Node.js programs, and even try changing the <code class="calibre18">UV_THREADPOOL_SIZE</code> environment variable to see the number of threads change.</p>
<div id="ex_threads_from_top" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-6. </span>Output from <code class="calibre18">top</code>, showing the threads in a Node.js process</h5>

<pre data-type="programlisting" class="calibre28">$ top -H -p 81862
top - 14:18:49 up 1 day, 23:18,  1 user,  load average: 0.59, 0.82, 0.83
Threads:   7 total,   0 running,   7 sleeping,   0 stopped,   0 zombie
%Cpu(s):  2.2 us,  0.0 sy,  0.0 ni, 97.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :  15455.1 total,   2727.9 free,   5520.4 used,   7206.8 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   8717.3 avail Mem

    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND
  81862 bengl     20   0  577084  29272  25064 S   0.0   0.2   0:00.03 node
  81863 bengl     20   0  577084  29272  25064 S   0.0   0.2   0:00.00 node
  81864 bengl     20   0  577084  29272  25064 S   0.0   0.2   0:00.00 node
  81865 bengl     20   0  577084  29272  25064 S   0.0   0.2   0:00.00 node
  81866 bengl     20   0  577084  29272  25064 S   0.0   0.2   0:00.00 node
  81867 bengl     20   0  577084  29272  25064 S   0.0   0.2   0:00.00 node
  81868 bengl     20   0  577084  29272  25064 S   0.0   0.2   0:00.00 node</pre></div>

<p class="author1">Browsers similarly perform many tasks, such as Document Object Model (DOM) rendering, in threads other than the one used <a data-type="indexterm" data-primary="DOM (Document Object Model)" id="idm45995936545688" class="calibre6"/>for JavaScript execution. An experiment with <code class="calibre18">top -H</code> like we did for Node.js would result in a similar handful of threads. Modern browsers take this even further by using multiple processes to add a layer of security by isolation.</p>

<p class="author1">It’s important to think about these extra threads when going through a resource-planning exercise for your application. You should never assume that just because JavaScript is single-threaded that only one thread will be used by your JavaScript application. For example, in production Node.js applications, measure the number of threads used by the application and plan accordingly. Don’t forget that many of the native addons in the Node.js ecosystem spawn threads of their own as well, so it’s important to <a data-type="indexterm" data-primary="threads" data-secondary="hidden" data-startref="thrhid" id="idm45995936543272" class="calibre6"/><a data-type="indexterm" data-primary="hidden threads" data-startref="hidthr" id="idm45995936542024" class="calibre6"/>go through this exercise on an application-by-application basis.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Threads in C: Get Rich with Happycoin" class="calibre4"><div class="preface" id="ch_intro_sec_happycoin">
<h1 class="calibre13">Threads in C: Get Rich with Happycoin</h1>

<p class="author1">Threads are obviously not unique to JavaScript. They’re a long-standing concept at the operating system level, independent of <a data-type="indexterm" data-primary="C, threads" id="idm45995936538904" class="calibre6"/><a data-type="indexterm" data-primary="threads" data-secondary="C" id="idm45995936538200" class="calibre6"/>languages. Let’s explore how a threaded program might look in C. C is an obvious choice here because the C interface for threads is what underlies most thread implementations in higher-level languages, even if there may seem to be different semantics.</p>

<p class="author1">Let’s start with an example. Imagine a proof-of-work algorithm for a simple and impractical cryptocurrency called <a data-type="indexterm" data-primary="threads" data-secondary="C" data-tertiary="Happycoin example" id="idm45995936536344" class="calibre6"/>Happycoin, as follows:</p>
<ol class="calibre35">
<li class="calibre36">
<p class="author1">Generate a random unsigned 64-bit integer.</p>
</li>
<li class="calibre36">
<p class="author1">Determine whether or not the integer is happy.</p>
</li>
<li class="calibre36">
<p class="author1">If it’s not happy, it’s not a Happycoin.</p>
</li>
<li class="calibre36">
<p class="author1">If it’s not divisible by 10,000, it’s not a Happycoin.</p>
</li>
<li class="calibre36">
<p class="author1">Otherwise, it’s a Happycoin.</p>
</li>

</ol>

<p class="author1">A number is happy if it eventually goes to 1 when replacing it with the sum of the squares of its digits, and looping until either the 1 happens, or a previously seen number arises. <a href="https://oreil.ly/vRr3P" class="calibre6">Wikipedia defines it clearly</a> and also points out that if any previously seen numbers arise, then 4 will arise, and vice versa. You may notice that our algorithm is needlessly too expensive because we could check for divisibility before checking for happiness. This is intentional because we’re trying to demonstrate a heavy workload.</p>

<p class="author1">Let’s build a simple C program that runs the proof-of-work algorithm 10,000,000 times, printing any Happycoins found, and a count of them.</p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="author1">The <code class="calibre18">cc</code> in the compilation steps here can be replaced with <code class="calibre18">gcc</code> or <code class="calibre18">clang</code>, depending on which is available to you. On most systems, <code class="calibre18">cc</code> is an alias for either <code class="calibre18">gcc</code> or <code class="calibre18">clang</code>, so that’s what we’ll use here.</p>

<p class="author1">Windows users may have to do some extra work here to get this going in Visual Studio, and the threads example won’t work out-of-the-box on Windows because it uses Portable Operating System Interface (POSIX) <a data-type="indexterm" data-primary="POSIX (Portable Operating System Interface)" data-secondary="threads" id="idm45995936523560" class="calibre6"/>threads rather than Windows threads, which are different. To simplify trying this on Windows, the recommendation is to use Windows Subsystem for Linux so that you have a POSIX-compatible environment to work with.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="With Only the Main Thread" class="calibre4"><div class="preface" id="idm45995936522008">
<h2 class="calibre37">With Only the Main Thread</h2>

<p class="author1">Create a file called <em class="calibre7">happycoin.c</em>, in a directory called <em class="calibre7">ch1-c-threads/</em>. We’ll build up this file over the course of this section. To start off, add the code as shown in <a data-type="xref" href="#ex_happycoin_c_1" class="calibre6">Example 1-7</a>.</p>
<div id="ex_happycoin_c_1" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-7. </span><em class="calibre7">ch1-c-threads/happycoin.c</em></h5>

<pre data-type="programlisting" data-code-language="c" class="calibre28"><code class="cp">#</code><code class="cp">include &lt;inttypes.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include &lt;stdbool.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include &lt;stdio.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include &lt;stdlib.h&gt;</code><code class="cp">
</code><code class="cp">#</code><code class="cp">include &lt;time.h&gt;</code><code class="cp">
</code><code class="calibre18">
</code><code class="kt">uint64_t</code><code class="calibre18"> </code><code class="nf">random64</code><code class="p">(</code><code class="kt">uint32_t</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">seed</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kt">uint64_t</code><code class="calibre18"> </code><code class="nx">result</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kt">uint8_t</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">result8</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="p">(</code><code class="kt">uint8_t</code><code class="calibre18"> </code><code class="o">*</code><code class="p">)</code><code class="o">&amp;</code><code class="nx">result</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO3-1" href="#callout_introduction_CO3-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kt">size_t</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="kr">sizeof</code><code class="p">(</code><code class="nx">result</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="o">+</code><code class="o">+</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
</code><code class="calibre18">    </code><code class="nx">result8</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">rand_r</code><code class="p">(</code><code class="nx">seed</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="p">}</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">result</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO3-1" href="#co_introduction_CO3-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">This line uses pointers, which <a data-type="indexterm" data-primary="pointers" id="idm45995927182632" class="calibre6"/>may be unfamiliar to you if you’re coming from a mostly JavaScript background. The short version of what’s going on here is that <code class="calibre18">result8</code> is an array of eight 8-bit unsigned integers, backed by the same memory as <code class="calibre18">result</code>, which is a single 64-bit unsigned integer.</p></dd>
</dl></div>

<p class="author1">We’ve added a bunch of <code class="calibre18">includes</code>, which give us <a data-type="indexterm" data-primary="includes" id="idm45995927179608" class="calibre6"/>handy things like types, I/O functions, and the time and random number functions we’ll be needing. Since the 
<span class="keep-together">algorithm</span> 
<span class="keep-together">requires</span> the generation of a random 64-bit unsigned integer (i.e., a <code class="calibre18">uint64_t</code>), we need eight <a data-type="indexterm" data-primary="random64() function" id="idm45995927176824" class="calibre6"/><a data-type="indexterm" data-primary="functions" data-secondary="random64()" id="idm45995927176088" class="calibre6"/>random bytes, which <code class="calibre18">random64()</code> gives us by calling <code class="calibre18">rand_r()</code> until we have enough bytes. Since <code class="calibre18">rand_r()</code> also requires a reference to a seed, we’ll pass that into <code class="calibre18">random64()</code> as well.</p>

<p class="author1">Now let’s add our happy number calculation as shown in <a data-type="xref" href="#ex_happycoin_c_2" class="calibre6">Example 1-8</a>.</p>
<div id="ex_happycoin_c_2" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-8. </span><em class="calibre7">ch1-c-threads/happycoin.c</em></h5>

<pre data-type="programlisting" data-code-language="c" class="calibre28"><code class="kt">uint64_t</code> <code class="nf">sum_digits_squared</code><code class="p">(</code><code class="kt">uint64_t</code> <code class="nx">num</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">uint64_t</code> <code class="nx">total</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kr">while</code> <code class="p">(</code><code class="nx">num</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="kt">uint64_t</code> <code class="nx">num_mod_base</code> <code class="o">=</code> <code class="nx">num</code> <code class="o">%</code> <code class="mi">10</code><code class="p">;</code>
    <code class="nx">total</code> <code class="o">+=</code> <code class="nx">num_mod_base</code> <code class="o">*</code> <code class="nx">num_mod_base</code><code class="p">;</code>
    <code class="nx">num</code> <code class="o">=</code> <code class="nx">num</code> <code class="o">/</code> <code class="mi">10</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="kr">return</code> <code class="nx">total</code><code class="p">;</code>
<code class="p">}</code>

<code class="kt">bool</code> <code class="nf">is_happy</code><code class="p">(</code><code class="kt">uint64_t</code> <code class="nx">num</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">while</code> <code class="p">(</code><code class="nx">num</code> <code class="o">!=</code> <code class="mi">1</code> <code class="o">&amp;&amp;</code> <code class="nx">num</code> <code class="o">!=</code> <code class="mi">4</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">num</code> <code class="o">=</code> <code class="nx">sum_digits_squared</code><code class="p">(</code><code class="nx">num</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kr">return</code> <code class="nx">num</code> <code class="o">==</code> <code class="mi">1</code><code class="p">;</code>
<code class="p">}</code>

<code class="kt">bool</code> <code class="nf">is_happycoin</code><code class="p">(</code><code class="kt">uint64_t</code> <code class="nx">num</code><code class="p">)</code> <code class="p">{</code>
  <code class="kr">return</code> <code class="nx">is_happy</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="nx">num</code> <code class="o">%</code> <code class="mi">10000</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre></div>

<p class="author1">To get the sum of the squares of the digits in <code class="calibre18">sum_digits_squared</code>, we’re using the mod operator, <code class="calibre18">%</code>, to get each digit from right to left, squaring it, then adding it to our running total. We then use this function in <code class="calibre18">is_happy</code> in a loop, stopping when the number is 1 or 4. We stop at 1 because that indicates the number is happy. We also stop at 4 because that’s indicative of an infinite loop where we never end up at 1. Finally, in <code class="calibre18">is_happycoin()</code>, we do the work of checking whether a number is happy and also divisible by 10,000.</p>

<p class="author1">Let’s wrap this all up in our <code class="calibre18">main()</code> function as shown in <a data-type="xref" href="#ex_happycoin_c_3" class="calibre6">Example 1-9</a>.</p>
<div id="ex_happycoin_c_3" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-9. </span><em class="calibre7">ch1-c-threads/happycoin.c</em></h5>

<pre data-type="programlisting" data-code-language="c" class="calibre28"><code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">uint32_t</code> <code class="nx">seed</code> <code class="o">=</code> <code class="nx">time</code><code class="p">(</code><code class="nb">NULL</code><code class="p">);</code>
  <code class="kt">int</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kr">for</code> <code class="p">(</code><code class="kt">int</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10000000</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="kt">uint64_t</code> <code class="nx">random_num</code> <code class="o">=</code> <code class="nx">random64</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">seed</code><code class="p">);</code>
    <code class="kr">if</code> <code class="p">(</code><code class="nx">is_happycoin</code><code class="p">(</code><code class="nx">random_num</code><code class="p">))</code> <code class="p">{</code>
      <code class="nx">printf</code><code class="p">(</code><code class="s">"%"</code> <code class="nx">PRIu64</code> <code class="s">" "</code><code class="p">,</code> <code class="nx">random_num</code><code class="p">);</code>
      <code class="nx">count</code><code class="o">++</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="nx">printf</code><code class="p">(</code><code class="s">"</code><code class="se">\n</code><code class="s">count %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="nx">count</code><code class="p">);</code>
  <code class="kr">return</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre></div>

<p class="author1">First, we need a seed for the <a data-type="indexterm" data-primary="random number generator" data-secondary="seeds" id="idm45995927044664" class="calibre6"/>random number generator. The current time is as suitable a seed as any, so we’ll use that via <code class="calibre18">time()</code>. Then, we’ll loop 10,000,000 times, first getting a random number from <code class="calibre18">random64()</code>, then checking if it’s a Happycoin. If it is, we’ll increment the count and print the number out. The weird <code class="calibre18">PRIu64</code> syntax in the <code class="calibre18">printf()</code> call is necessary for properly printing out 64-bit unsigned integers. When the loop completes, we print out the count and exit the program.</p>

<p class="author1">To compile and run this program, use <a data-type="indexterm" data-primary="code samples" data-secondary="ch1-c-threads" id="idm45995926908200" class="calibre6"/>the following commands in your <em class="calibre7">ch1-c-threads</em> directory.</p>

<pre data-type="programlisting" class="calibre38">$ cc -o happycoin happycoin.c
$ ./happycoin</pre>

<p class="author1">You’ll get a list of Happycoins found on one line and the count of them on the next line. For a given run of the program, it might look something like this:</p>

<pre data-type="programlisting" class="calibre38">11023541197304510000 ...  [ 167 more entries ] ... 770541398378840000
count 169</pre>

<p class="author1">It takes a nontrivial amount of time to run this program; about 2 seconds on a run-of-the-mill computer. This is a case where threads can be useful to speed things up because many iterations of the same largely mathematical operation are being run.</p>

<p class="author1">Let’s go ahead and convert this example to a multithreaded program.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="With Four Worker Threads" class="calibre4"><div class="preface" id="idm45995936521416">
<h2 class="calibre37">With Four Worker Threads</h2>

<p class="author1">We’ll set up four threads that <a data-type="indexterm" data-primary="threads" data-secondary="worker threads" id="thwork" class="calibre6"/><a data-type="indexterm" data-primary="worker threads" id="workthread" class="calibre6"/>will each run a quarter of the iterations of the loop that generates a random number and tests if it’s a Happycoin.</p>

<p class="author1">In POSIX C, threads are managed <a data-type="indexterm" data-primary="functions" data-secondary="pthread family" id="idm45995926898504" class="calibre6"/><a data-type="indexterm" data-primary="pthread functions" id="idm45995926897528" class="calibre6"/><a data-type="indexterm" data-primary="pthread_create() function" id="idm45995926896856" class="calibre6"/><a data-type="indexterm" data-primary="functions" data-secondary="pthread_create()" id="idm45995926896216" class="calibre6"/><a data-type="indexterm" data-primary="pthread_join() function" id="idm45995926895272" class="calibre6"/><a data-type="indexterm" data-primary="functions" data-secondary="pthread_join()" id="idm45995926894600" class="calibre6"/>with the <code class="calibre18">pthread_*</code> family of functions. The <code class="calibre18">pthread_create()</code> function is use to create a thread. A function is passed in that will be executed on that thread. Program flow continues on the main thread. The program can wait for a thread’s completion by calling <code class="calibre18">pthread_join()</code> on it. You can pass arguments to the function being run on the thread via <code class="calibre18">pthread_create()</code> and get return values from <code class="calibre18">pthread_join()</code>.</p>

<p class="author1">In our program, we’ll isolate the generation of Happycoins in a function called <code class="calibre18">get_happycoins()</code> and that’s what will run in our threads. We’ll create the four threads, and then immediately wait for the completion of them. Whenever we get the results back from a thread, we’ll output them and store the count so we can print the total at the end. To help in passing the results back, we’ll create a simple <code class="calibre18">struct</code> called <code class="calibre18">happy_result</code>.</p>

<p class="author1">Make a copy of your existing <em class="calibre7">happycoin.c</em> and name it <em class="calibre7">happycoin-threads.c</em>. Then in the new file, insert the code in <a data-type="xref" href="#ex_happycoin_threads_c_1" class="calibre6">Example 1-10</a> under the last <code class="calibre18">#include</code> in the file.</p>
<div id="ex_happycoin_threads_c_1" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-10. </span><em class="calibre7">ch1-c-threads/happycoin-threads.c</em></h5>

<pre data-type="programlisting" data-code-language="c" class="calibre28"><code class="cp">#include &lt;pthread.h&gt;</code>

<code class="kr">struct</code> <code class="nx">happy_result</code> <code class="p">{</code>
  <code class="kt">size_t</code> <code class="nx">count</code><code class="p">;</code>
  <code class="kt">uint64_t</code> <code class="o">*</code> <code class="nx">nums</code><code class="p">;</code>
<code class="p">};</code></pre></div>

<p class="author1">The first line includes <code class="calibre18">pthread.h</code>, which gives us access to the various thread functions we’ll need. Then <code class="calibre18">struct happy_result</code> is defined, which we’ll use as the return value for our thread function <code class="calibre18">get_happycoins()</code> later on. It stores an array of found happycoins, represented here by a pointer, and the count of them.</p>

<p class="author1">Now, go ahead and delete the whole <code class="calibre18">main()</code> function because we’re about to replace it. First, let’s add our <code class="calibre18">get_happycoins()</code> function in <a data-type="xref" href="#ex_happycoin_threads_c_2" class="calibre6">Example 1-11</a>, which is the code that will run on our worker threads.</p>
<div id="ex_happycoin_threads_c_2" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-11. </span><em class="calibre7">ch1-c-threads/happycoin-threads.c</em></h5>

<pre data-type="programlisting" data-code-language="c" class="calibre28"><code class="kt">void</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nf">get_happycoins</code><code class="p">(</code><code class="kt">void</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">arg</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kt">int</code><code class="calibre18"> </code><code class="nx">attempts</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="o">*</code><code class="p">(</code><code class="kt">int</code><code class="calibre18"> </code><code class="o">*</code><code class="p">)</code><code class="nx">arg</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_introduction_CO4-1" href="#callout_introduction_CO4-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="kt">int</code><code class="calibre18"> </code><code class="nx">limit</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">attempts</code><code class="o">/</code><code class="mi">10000</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kt">uint32_t</code><code class="calibre18"> </code><code class="nx">seed</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">time</code><code class="p">(</code><code class="nb">NULL</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kt">uint64_t</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">nums</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">malloc</code><code class="p">(</code><code class="nx">limit</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="kr">sizeof</code><code class="p">(</code><code class="kt">uint64_t</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kr">struct</code><code class="calibre18"> </code><code class="nx">happy_result</code><code class="calibre18"> </code><code class="o">*</code><code class="calibre18"> </code><code class="nx">result</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">malloc</code><code class="p">(</code><code class="kr">sizeof</code><code class="p">(</code><code class="kr">struct</code><code class="calibre18"> </code><code class="nx">happy_result</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="nx">result</code><code class="o">-</code><code class="o">&gt;</code><code class="nx">nums</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">nums</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="nx">result</code><code class="o">-</code><code class="o">&gt;</code><code class="nx">count</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kt">int</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">1</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="nx">attempts</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="o">+</code><code class="o">+</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
</code><code class="calibre18">    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">result</code><code class="o">-</code><code class="o">&gt;</code><code class="nx">count</code><code class="calibre18"> </code><code class="o">=</code><code class="o">=</code><code class="calibre18"> </code><code class="nx">limit</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
</code><code class="calibre18">      </code><code class="kr">break</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">    </code><code class="p">}</code><code class="calibre18">
</code><code class="calibre18">    </code><code class="kt">uint64_t</code><code class="calibre18"> </code><code class="nx">random_num</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">random64</code><code class="p">(</code><code class="o">&amp;</code><code class="nx">seed</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">is_happycoin</code><code class="p">(</code><code class="nx">random_num</code><code class="p">)</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
</code><code class="calibre18">      </code><code class="nx">result</code><code class="o">-</code><code class="o">&gt;</code><code class="nx">nums</code><code class="p">[</code><code class="nx">result</code><code class="o">-</code><code class="o">&gt;</code><code class="nx">count</code><code class="o">+</code><code class="o">+</code><code class="p">]</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">random_num</code><code class="p">;</code><code class="calibre18">
</code><code class="calibre18">    </code><code class="p">}</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="p">}</code><code class="calibre18">
</code><code class="calibre18">  </code><code class="kr">return</code><code class="calibre18"> </code><code class="p">(</code><code class="kt">void</code><code class="calibre18"> </code><code class="o">*</code><code class="p">)</code><code class="nx">result</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_introduction_CO4-1" href="#co_introduction_CO4-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">This weird pointer casting thing basically says “treat this arbitrary pointer as a pointer to an <code class="calibre18">int</code>, and then get me the value of that <code class="calibre18">int</code>.”</p></dd>
</dl></div>

<p class="author1">You’ll notice that this function takes in a single <code class="calibre18">void *</code> and returns a single <code class="calibre18">void *</code>. That’s the function signature expected by <code class="calibre18">pthread_create()</code>, so we don’t have a choice here. This means we have to cast our arguments to what we want them to be. We’ll be passing in the number of attempts, so we’ll cast the argument to an <code class="calibre18">int</code>. Then, we’ll set the seed as we did in the previous example, but this time it’s happening in our thread function, so we get a different seed per thread.</p>

<p class="author1">After allocating enough space for our array and <code class="calibre18">struct happy_result</code>, we go ahead into the same loop that we did in <code class="calibre18">main()</code> in the single-threaded example, only this time we’re putting the results into the <code class="calibre18">struct</code> instead of printing them. Once the loop is done, we return the <code class="calibre18">struct</code> as a pointer, which we cast as <code class="calibre18">void *</code> to satisfy the function signature. This is how information is passed back to the main thread, which will make sense of it.</p>

<p class="author1">This demonstrates one of the key properties of threads that we don’t get from processes, which is the shared memory space. If, for example, we were using processes instead of threads <a data-type="indexterm" data-primary="IPC (Inter-Process Communication)" id="idm45995926485688" class="calibre6"/>and some <em class="calibre7">interprocess communication (IPC)</em> mechanism to transfer results back, we wouldn’t be able to simply pass a memory address back to the main process because the main process wouldn’t have access to memory of the worker process. Thanks <a data-type="indexterm" data-primary="virtual memory" id="idm45995926484152" class="calibre6"/><a data-type="indexterm" data-primary="memory" data-secondary="virtual memory" id="idm45995926424440" class="calibre6"/>to virtual memory, the memory address might refer to something else entirely in the main process. Instead of passing a pointer, we’d have to pass the entire value back over the IPC channel, which can introduce performance overhead. Since we’re using threads instead of processes, we can just use the pointer, so that the main thread can use it just the same.</p>

<p class="author1">Shared memory isn’t without <a data-type="indexterm" data-primary="shared memory" id="idm45995926422552" class="calibre6"/><a data-type="indexterm" data-primary="memory" data-secondary="shared memory" id="idm45995926430504" class="calibre6"/>its trade-offs, though. In our case, there’s no need for the worker thread to make any use of the memory it has now passed to the main thread. This isn’t always the case with threads. In a great multitude of cases, it’s necessary to properly manage how threads access shared memory via synchronization; otherwise, some unpredictable results may occur. We’ll go into how this works in JavaScript in detail in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.xhtml#ch_shared_mem" class="calibre6">4</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch05.xhtml#ch_adv_shared_mem" class="calibre6">5</a>.</p>

<p class="author1">Now, let’s wrap this up with the <code class="calibre18">main()</code> function in <a data-type="xref" href="#ex_happycoin_threads_c_3" class="calibre6">Example 1-12</a>.</p>
<div id="ex_happycoin_threads_c_3" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 1-12. </span><em class="calibre7">ch1-c-threads/happycoin-threads.c</em></h5>

<pre data-type="programlisting" data-code-language="c" class="calibre28"><code class="cp">#define THREAD_COUNT 4</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">()</code> <code class="p">{</code>
  <code class="kt">pthread_t</code> <code class="kr">thread</code> <code class="p">[</code><code class="nx">THREAD_COUNT</code><code class="p">];</code>

  <code class="kt">int</code> <code class="nx">attempts</code> <code class="o">=</code> <code class="mi">10000000</code><code class="o">/</code><code class="nx">THREAD_COUNT</code><code class="p">;</code>
  <code class="kt">int</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
  <code class="kr">for</code> <code class="p">(</code><code class="kt">int</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">THREAD_COUNT</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">pthread_create</code><code class="p">(</code><code class="o">&amp;</code><code class="kr">thread</code><code class="p">[</code><code class="nx">i</code><code class="p">],</code> <code class="nb">NULL</code><code class="p">,</code> <code class="nx">get_happycoins</code><code class="p">,</code> <code class="o">&amp;</code><code class="nx">attempts</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kr">for</code> <code class="p">(</code><code class="kt">int</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">j</code> <code class="o">&lt;</code> <code class="nx">THREAD_COUNT</code><code class="p">;</code> <code class="nx">j</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">struct</code> <code class="nx">happy_result</code> <code class="o">*</code> <code class="nx">result</code><code class="p">;</code>
    <code class="nx">pthread_join</code><code class="p">(</code><code class="kr">thread</code><code class="p">[</code><code class="nx">j</code><code class="p">],</code> <code class="p">(</code><code class="kt">void</code> <code class="o">**</code><code class="p">)</code><code class="o">&amp;</code><code class="nx">result</code><code class="p">);</code>
    <code class="nx">count</code> <code class="o">+=</code> <code class="nx">result</code><code class="o">-&gt;</code><code class="nx">count</code><code class="p">;</code>
    <code class="kr">for</code> <code class="p">(</code><code class="kt">int</code> <code class="nx">k</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">k</code> <code class="o">&lt;</code> <code class="nx">result</code><code class="o">-&gt;</code><code class="nx">count</code><code class="p">;</code> <code class="nx">k</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">printf</code><code class="p">(</code><code class="s">"%"</code> <code class="nx">PRIu64</code> <code class="s">" "</code><code class="p">,</code> <code class="nx">result</code><code class="o">-&gt;</code><code class="nx">nums</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="nx">printf</code><code class="p">(</code><code class="s">"</code><code class="se">\n</code><code class="s">count %d</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code> <code class="nx">count</code><code class="p">);</code>
  <code class="kr">return</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre></div>

<p class="author1">First, we’ll declare our four threads <a data-type="indexterm" data-primary="threads" data-secondary="arrays, declaring as" id="idm45995926550312" class="calibre6"/><a data-type="indexterm" data-primary="arrays" data-secondary="threads, declaring" id="idm45995926549464" class="calibre6"/>as an array on the stack. Then, we divide our desired number of attempts (10,000,000) by the number of threads. This is what will be passed to <code class="calibre18">get_happycoins()</code> as an argument, which we see inside the first loop, which creates each of the threads with <code class="calibre18">pthread_create()</code>, passing in the number of attempts per thread as an argument. In the next loop, we wait for each of the threads to finish their execution with <code class="calibre18">pthread_join()</code>. Then we can print the results and the total from all the threads, just like we would in the single-threaded example.</p>
<div data-type="note" epub:type="note" class="calibre22"><h6 class="calibre23">Note</h6>
<p class="author1">This program leaks memory. One hard part of multithreaded programming in C and some other languages is that it can be very easy to lose track of where and when memory is allocated and where and when it should be freed. See if you can modify the code here to ensure the program exits with all heap-allocated memory freed.</p>
</div>

<p class="author1">With the changes complete, you can compile and run this program with the following commands in your <em class="calibre7">ch1-c-threads</em> directory.</p>

<pre data-type="programlisting" class="calibre38">$ cc -pthread -o happycoin-threads happycoin-threads.c
$ ./happycoin-threads</pre>

<p class="author1">The output should look something like this:</p>

<pre data-type="programlisting" class="calibre38">2466431682927540000 ... [ 154 more entries ] ... 15764177621931310000
count 156</pre>

<p class="author1">You’ll notice output similar to the single-threaded example.<sup class="calibre39"><a data-type="noteref" id="idm45995926720824-marker" href="ch01.xhtml#idm45995926720824" class="calibre40">1</a></sup> You’ll also notice that it’s a bit faster. On a run-of-the-mill computer it finishes in about 0.8 seconds. This isn’t <em class="calibre7">quite</em> four times as fast, since there’s some initial overhead in the main thread, and also the cost of printing of results. We could print the results as soon as they’re ready on the thread that’s doing the work, but if we do that, the results may clobber each other in the output because nothing stops two threads from printing to the output stream at the same time. By sending the results to the main thread, we can coordinate the printing of results there so that nothing gets clobbered.</p>

<p class="author1">This illustrates the primary advantage and one drawback of threaded code. On one hand, it’s useful for splitting up computationally expensive tasks so that they can be run in parallel. On the other hand, we need to ensure that some events are properly synchronized so that weird errors don’t occur. When adding threads to your code in any language, it’s worth making sure that the use is appropriate. Also, as with any exercise in attempting to make faster programs, always be measuring. You don’t want to have the complexity of threaded code in your application if it doesn’t turn out to give you any actual benefit.</p>

<p class="author1">Any programming language supporting threads is going to provide some mechanisms for creating and destroying threads, passing messages in between, and interacting with data that’s shared between the threads. This may not look the same in every language, because as languages and <a data-type="indexterm" data-primary="threads" data-secondary="worker threads" data-startref="thwork" id="idm45995926717032" class="calibre6"/><a data-type="indexterm" data-primary="worker threads" data-startref="workthread" id="idm45995926715784" class="calibre6"/>their paradigms are different, so are their programmatic models of parallel programming. Now that we’ve explored what threaded programs look like in a low-level language like C, let’s dive in to JavaScript. Things will look a little different, but as you’ll see, the principles remain the same.</p>
</div></section>





</div></section>







<div data-type="footnotes" class="calibre41"><p data-type="footnote" id="idm45995926720824" class="calibre42"><sup class="calibre43"><a href="ch01.xhtml#idm45995926720824-marker" class="calibre40">1</a></sup> The fact that the total count from the multithreaded example is different from the single-threaded example is irrelevant because the count is dependent on how many random numbers happened to be Happycoins. The result will be completely different between two different runs.</p></div></div></section></div></body></html>