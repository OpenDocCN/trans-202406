- en: Chapter 8\. Backgrounds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the *background area* of an element consists of the content box,
    padding box, and border box, with the borders drawn on top of the background.
    (You can change that to a degree with CSS, as you’ll see in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: CSS lets you apply one solid opaque or semitransparent color to the background
    of an element, as well as apply one or more images to the background of a single
    element, or even describe your own color gradients of various shapes to fill the
    background area.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Background Colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To declare a color for the background of an element, you use the property `background-color`,
    which accepts any valid color value.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the color to extend out a little bit from the content area of the
    element, add some padding to the mix, as shown in the following code and illustrated
    in [Figure 8-1](#cab_fig07):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0801](assets/css5_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Background color and padding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can set a background color for any element, from `<body>` all the way down
    to inline elements such as `<em>` and `<a>`. The value of `background-color` is
    not inherited.
  prefs: []
  type: TYPE_NORMAL
- en: 'Its default value is the keyword `transparent`, which should make sense: if
    an element doesn’t have a defined color, its background should be transparent
    so that the background and content of its ancestor elements will be visible.'
  prefs: []
  type: TYPE_NORMAL
- en: One way to picture what that means is to imagine a clear (i.e., transparent)
    plastic sign mounted to a textured wall. The wall is still visible through the
    sign, but this is not the background of the sign; it’s the background of the wall
    (in CSS terms, anyway). Similarly, if you set the page canvas to have a background,
    it can be seen through all of the elements in the document that don’t have their
    own backgrounds.
  prefs: []
  type: TYPE_NORMAL
- en: They don’t inherit the background; it is visible *through* the elements. This
    may seem like an irrelevant distinction, but as you’ll see when we discuss background
    images, it’s a critical difference.
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly Setting a Transparent Background
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time, you’ll have no reason to use the keyword `transparent`, since
    that’s the default value. On occasion, though, it can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that a third-party script you have to include has set all images to
    have a white background, but your design includes a few transparent PNG images,
    and you don’t want the background on those images to be white. To make sure your
    design choice prevails, you would declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Without this (and adding classes to your images), your semitransparent images
    would not appear semitransparent; rather, they would look like they had a solid
    white background.
  prefs: []
  type: TYPE_NORMAL
- en: While the right color background on a semitransparent image is a nice-to-have,
    good contrast between text and the text’s background color is a must-have. If
    the contrast between text and any part of the background isn’t great enough, the
    text will be illegible. Always ensure that the contrast between the text and background
    is greater than or equal to 4.5:1 for small text and 3:1 for large text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring both a color and a background color, with a good contrast, on your
    root element is generally considered a good practice. Not declaring a background
    color when declaring a color will lead the CSS validator to generate warnings
    such as, “You have no `background-color` with your `color`” to remind you that
    author-user color interaction can occur, and your rule has not taken this possibility
    into account. Warnings do not mean your styles are invalid: only errors prevent
    validation.'
  prefs: []
  type: TYPE_NORMAL
- en: Background and Color Combinations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By combining `color` and `background-color`, you can create interesting effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 8-2](#cab_fig08) depicts this example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0802](assets/css5_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. A reverse-text effect for `<h1>` elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are as many color combinations as there are colors, and we can’t show
    all of them here. Still, we’ll try to give you some idea of what you can do.
  prefs: []
  type: TYPE_NORMAL
- en: 'This stylesheet is a little more complicated, as illustrated by [Figure 8-3](#cab_fig09):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0803](assets/css5_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. The results of a more complicated stylesheet
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And then there’s the question of what happens when you apply a background to
    a replaced element. We already discussed images with transparent portions, like
    a PNG or WebP. Suppose, though, you want to create a two-tone border around a
    JPEG. You can pull that off by adding a background color and a little bit of padding
    to your image, as shown in the following code and illustrated in [Figure 8-4](#cab_fig10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0804](assets/css5_0804.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. Using background and border to two-tone an image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Technically, the background goes to the outer border edge, but since the border
    is solid and continuous, we can’t see the background behind it. The 5 pixels of
    padding allow a thin ring of background to be seen between the image and its border,
    creating the visual effect of an “inner border.” This technique could be extended
    to create more complicated effects with box shadows (discussed at the end of the
    chapter) and background images like gradients (discussed in [Chapter 9](ch09.html#gradients)).
  prefs: []
  type: TYPE_NORMAL
- en: Clipping the Background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you apply a background to a replaced element, such as an image, the background
    will show through any transparent portions. Background colors, by default, go
    to the outer edge of the element’s border, showing behind the border if the border
    is itself transparent, or if it has transparent areas such as the spaces between
    dots, dashes, or lines when border style `dotted`, `dashed`, or `double` is applied.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent the background from showing behind semitransparent or fully transparent
    borders, we can use `background-clip`. This property defines how far out an element’s
    background will go.
  prefs: []
  type: TYPE_NORMAL
- en: The default value `border-box` indicates that the *background painting area*
    (which is what `background-clip` defines) extends out to the outer edge of the
    border. Given this value, the background will *always* be drawn behind the visible
    parts of the border, if any.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose the value `padding-box`, the background will extend to only the
    outer edge of the padding area (which is also the inner edge of the border). Thus,
    the background won’t be drawn behind the border. The value `content-box`, on the
    other hand, restricts the background to just the content area of the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The effects of these three values are illustrated in [Figure 8-5](#cab_fig11),
    which is the result of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0805](assets/css5_0805.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. The three box-oriented types of background clipping
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: That might seem pretty simple, but several caveats exist. First, `background-clip`
    has no effect on the root element (in HTML, that’s either the `<html>` element,
    or the `<body>` element if you haven’t defined any background styles on `<html>`).
    This has to do with how the background painting of the root element has to be
    handled.
  prefs: []
  type: TYPE_NORMAL
- en: Second, the exact clipping of the background area can be reduced if the element
    has rounded corners, thanks to the `border-radius` property (see [Chapter 7](ch07.html#padding-borders-outlines-and-margins)).
    This is basically common sense, since if you give your element significantly rounded
    corners, you want the background to be clipped by those corners instead of stick
    out past them. The way to think of this is that the background painting area is
    determined by `background-clip`, and then any corners that have to be further
    clipped by rounded corners are appropriately clipped.
  prefs: []
  type: TYPE_NORMAL
- en: Third, the value of `background-clip` can interact poorly with some of the more
    interesting values of `background-repeat`, which we’ll get to later.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, `background-clip` defines the clipping area of the background. It doesn’t
    affect other background properties. When it comes to flat background colors, that’s
    a distinction without meaning; but when it comes to background images, which we’ll
    talk about in the next section, it can make a great deal of difference.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more value, `text`, which clips the background to the text of the
    element. In other words, the text is “filled in” with the background, and the
    rest of the element’s background area remains transparent. This is a simple way
    to add textures to text, by “filling in” the text of an element with its background.
  prefs: []
  type: TYPE_NORMAL
- en: 'The kicker is that to see this effect, you have to remove the foreground color
    of the element. Otherwise, the foreground color obscures the background. Consider
    the following, which has the result shown in [Figure 8-6](#cbag_css4_background-clip-text):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0806](assets/css5_0806.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. Clipping the background to the text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For the first example, the foreground color is made completely transparent,
    and the blue background is visible only where it intersects with the text shapes
    in the element’s content. It is not visible through the image inside the paragraph,
    since an image’s foreground can’t be set to `transparent`.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the foreground color has been set to `rgba(255 0 0 0.5)`,
    which is a half-opaque red. The text there is rendered purple, because the half-opaque
    red combines with the blue underneath. The borders, on the other hand, blend their
    half-opaque red with the white background behind them, yielding a light red.
  prefs: []
  type: TYPE_NORMAL
- en: In the third example, the foreground color is a solid, opaque red. The text
    and borders are both fully red, with no hint of the blue background. It can’t
    be seen in this instance, because it’s been clipped to the text. The foreground
    just completely obscures the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique works for any background, including gradient and image backgrounds,
    topics that we’ll cover in a bit. Remember, however: if the background for some
    reason fails to be drawn behind the text, the transparent text meant to be “filled”
    with the background will instead be completely unreadable.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As of late 2022, not all browsers support `background-clip: text` correctly.
    Blink browsers (Chrome and Edge) require a `-webkit-` prefix, supporting `-webkit-background-clip:
    text`. Also, since browsers may not support the `text` value in the future (it’s
    under discussion for removal from CSS as we write this), include the prefixed
    and nonprefixed versions of `background-clip` and set the transparent color inside
    a `@supports` feature query (for more information, see [Chapter 21](ch21.html#css-at-rules)).'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Background Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having covered the basics of background colors, we turn now to the subject of
    background images. By default, images are tiled, repeating in both horizontal
    and vertical directions to fill up the entire background of the document. This
    default CSS behavior created horrific websites often referred to as “Geocities
    1996,” but CSS can do a great deal more than simple tiling of background images.
    It can be used to create subtle beauty. We’ll start with the basics and then work
    our way up.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to get an image into the background in the first place, use the property
    `background-image`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value of `none` means about what you’d expect: no image is placed
    in the background. If you want a background image, you must give this property
    at least one image reference, such as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Because of the default values of other background properties, this will cause
    the image *bg23.gif* to be tiled in the document’s background, as shown in [Figure 8-7](#cab_fig12).
    You’ll learn how to change that shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0807](assets/css5_0807.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7\. Applying a background image in CSS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s usually a good idea to specify a background color to go along with your
    background image; we’ll come back to that concept a little later. (We’ll also
    talk about how to have more than one image at the same time, but for now we’re
    going to stick to just one background image per element.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply background images to any element, block-level or inline. If you
    have more than one background image, comma-separate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you combine simple icons with creative attribute selectors, you can (by
    using properties we’ll get to in just a bit) mark when a link points to a PDF,
    word processor document, email address, or other unusual resource. You can, for
    example, use the following code to display [Figure 8-8](#cab_fig14):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0808](assets/css5_0808.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8\. Adding link icons as background images
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s true that you can add multiple background images to an element, but until
    you learn how to position each image and prevent it from repeating, you most likely
    won’t want to. We’ll cover repeating background images after we cover these necessary
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like `background-color`, `background-image` is not inherited—in fact,
    not a single one of the background properties is inherited. Remember also that
    when specifying the URL of a background image, it falls under the usual restrictions
    and caveats for `url()` values: a relative URL should be interpreted with respect
    to the stylesheet (see [“URLs”](ch05.html#urls)).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Why Backgrounds Aren’t Inherited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we specifically noted that backgrounds are not inherited. Background
    images demonstrate why inherited backgrounds would be a bad thing. Imagine a situation
    that backgrounds were inherited, and you applied a background image to the `<body>`.
    That image would be used for the background of every element in the document,
    with each element doing its own tiling, as shown in [Figure 8-9](#cab_fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0809](assets/css5_0809.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9\. What inherited backgrounds would do to layout
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note that the pattern restarts at the top left of every element, including
    the links. This isn’t what most authors would want, and this is why background
    properties are not inherited. If you do want this particular effect for some reason,
    you can make it happen with a rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could use the value `inherit` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Following Good Background Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images are laid on top of whatever background color you specify. If your images
    aren’t tiled or have areas that are not opaque, the background will show through,
    blending its color with that of the semitransparent images. If the image fails
    to load, the background color specified will show instead of the image. For this
    reason, it’s always a good idea to specify a background color when using a background
    image, so that you’ll at least get a legible result if the image doesn’t appear.
  prefs: []
  type: TYPE_NORMAL
- en: Background images can cause accessibility issues. For example, if you have an
    image of a clear blue sky as a background image with dark text, that is likely
    very legible. But what if there is a bird in the sky? If dark text lands on a
    dark part of the background, that text will not be legible. Adding a drop shadow
    to the text (see [Chapter 15](ch15.html#text_properties)) or a list semitransparent
    background color behind all the text can reduce the risk of illegibility.
  prefs: []
  type: TYPE_NORMAL
- en: Positioning Background Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: OK, so we can put images in the background of an element. How about positioning
    the image exactly where you want? No problem! The `background-position` property
    is here to help.
  prefs: []
  type: TYPE_NORMAL
- en: That value syntax looks horrific, but it isn’t; it’s just what happens when
    you try to formalize the fast-and-loose implementations of a new technology into
    a regular syntax and then layer even more features on top of that while trying
    to reuse parts of the old syntax. (So, OK, kind of horrific.) In practice, the
    syntax for `background-position` is simple, but the percent values can be a little
    difficult to wrap your head around.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Throughout this section, we’ll be using the rule `background-repeat: no-repeat`
    to prevent tiling of the background image. You’re not imagining things: we haven’t
    talked about `background-repeat` yet! For now, just accept that the rule restricts
    the background to a single image. You’ll learn more details in [“Background Repeating
    (or Lack Thereof)”](#background-repeating-or-lack-thereof).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can center a background image in the `<body>` element as follows,
    with the result depicted in [Figure 8-10](#cab_fig17):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0810](assets/css5_0810.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10\. Centering a single background image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we’ve placed a single image in the background and then prevented it from
    being repeated with `background-repeat`. Every background that includes an image
    starts with a single image. This starting image is called the *origin image*.
  prefs: []
  type: TYPE_NORMAL
- en: The placement of the origin image is accomplished with `background-position`,
    and there are several ways to supply values for this property. First off, we can
    use the keywords `top`, `bottom`, `left`, `right`, and `center`. Usually, these
    appear in pairs, but (as the previous example shows) this is not always true.
    We can also use length values, such as `50px` or `2cm`; the combinations of keywords
    and length values, such as `right 50px bottom 2cm`; and finally, percentage values,
    such as `43%`. Each type of value has a slightly different effect on the placement
    of the background image.
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The image placement keywords are easiest to understand. They have the effects
    you’d expect from their names; for example, `top right` would cause the origin
    image to be placed in the top-right corner of the element’s background. Let’s
    use a small yin-yang symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will place a nonrepeated origin image in the top-right corner of each paragraph’s
    background, and the result would be exactly the same if the position were declared
    as `right top`.
  prefs: []
  type: TYPE_NORMAL
- en: This is because position keywords can appear in any order, as long as there
    are no more than two of them—one for the horizontal and one for the vertical.
    If you use two horizontal (`right right`) or two vertical (`top top`) keywords,
    the whole value is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'If only one keyword appears, the other is assumed to be `center`. So if you
    want an image to appear in the top center of every paragraph, you need only declare
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Percentage values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Percentage values are closely related to the keywords, although they behave
    in a more sophisticated way. Let’s say that you want to center an origin image
    within its element by using percentage values. That’s straightforward enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This places the origin image such that its center is aligned with the center
    of its element’s background. In other words, the percentage values apply to both
    the element and the origin image. The pixel of the image that is 50% from the
    top and 50% from the left in the image is placed 50% from the top and 50% from
    the left of the element on which it was set.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what that means, let’s examine the process in closer detail. When
    you center an origin image in an element’s background, the point in the image
    that can be described as `50% 50%` (the center) is lined up with the point in
    the background that can be described the same way. If the image is placed at `0%
    0%`, its top-left corner is placed in the top-left corner of the element’s background.
    Using `100% 100%` causes the bottom-right corner of the origin image to go into
    the bottom-right corner of the background. [Figure 8-11](#cab_fig19) contains
    examples of those values, as well as a few others, with the points of alignment
    for each located at the center of the concentric rings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, if you want to place a single origin image a third of the way across
    the background and two-thirds of the way down, your declaration would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With these rules, the point in the origin image that is one-third across and
    two-thirds down from the top-left corner of the image will be aligned with the
    point that is farthest from the top-left corner of the background. Note that the
    horizontal value *always* comes first with percentage values. If you were to switch
    the percentages in the preceding example, the point in the image that is two-thirds
    from the left side of the image and one-third of the way down from the top would
    be placed two-thirds of the way across the background and one-third of the way
    down.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0811](assets/css5_0811.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11\. Various percentage positions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you supply only one percentage value, the single value supplied is taken
    to be the horizontal value, and the vertical is assumed to be `50%`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The origin image is placed one-quarter of the way across the paragraph’s background
    and halfway down it, as if `background-position: 25% 50%;` had been set.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 8-1](#cab_table02) gives a breakdown of keyword and percentage equivalencies.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Positional equivalents
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword(s) | Equivalent keywords | Equivalent percentages |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `center` | `center center` | `50% 50%` `50%` |'
  prefs: []
  type: TYPE_TB
- en: '| `right` | `center right` `right center` | `100% 50%` `100%` |'
  prefs: []
  type: TYPE_TB
- en: '| `left` | `center left` `left center` | `0% 50%` `0%` |'
  prefs: []
  type: TYPE_TB
- en: '| `top` | `top center` `center top` | `50% 0%` |'
  prefs: []
  type: TYPE_TB
- en: '| `bottom` | `bottom center` `center bottom` | `50% 100%` |'
  prefs: []
  type: TYPE_TB
- en: '| `top left` | `left top` | `0% 0%` |'
  prefs: []
  type: TYPE_TB
- en: '| `top right` | `right top` | `100% 0%` |'
  prefs: []
  type: TYPE_TB
- en: '| `bottom right` | `right bottom` | `100% 100%` |'
  prefs: []
  type: TYPE_TB
- en: '| `bottom left` | `left bottom` | `0% 100%` |'
  prefs: []
  type: TYPE_TB
- en: As the property table in [“Positioning Background Images”](#background-positioning)
    showed, the default values for `background-position` are `0% 0%`, which is functionally
    the same as `top left`. This is why, unless you set different values for the position,
    background images always start tiling from the top-left corner of the element’s
    background.
  prefs: []
  type: TYPE_NORMAL
- en: Length values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we turn to length values for positioning. When you supply lengths for
    the position of the origin image, they are interpreted as offsets from the top-left
    corner of the element’s background. The offset point is the top-left corner of
    the origin image; thus, if you set the values `20px 30px`, the top-left corner
    of the origin image will be 20 pixels to the right of, and 30 pixels below, the
    top-left corner of the element’s background, as shown (along with a few other
    length examples) in [Figure 8-12](#cab_fig21). As with percentages, the horizontal
    value comes first with length values.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0812](assets/css5_0812.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-12\. Offsetting the background image by using length measures
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is quite different from percentage values because the offset is from one
    top-left corner to another. In other words, the top-left corner of the origin
    image lines up with the point specified in the `background-position` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can combine length and percentage values to get a “best of both worlds”
    effect. Let’s say you need to have a background image that is all the way to the
    right side of the background and 10 pixels down from the top. As always, the horizontal
    value comes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For that matter, you can get the same result by using `right 10px`, since you’re
    allowed to mix keywords with lengths and percentages. The syntax enforces axis
    order when using nonkeyword values; if you use a length or percentage value, the
    horizontal value must *always* come first, and the vertical must *always* come
    second. That means `right 10px` is fine, whereas `10px right` is invalid and will
    be ignored (because `right` is not a valid vertical keyword).
  prefs: []
  type: TYPE_NORMAL
- en: Negative values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re using lengths or percentages, you can use negative values to pull
    the origin image outside of the element’s background. Consider a document with
    a very large yin-yang symbol for a background. What if we want only part of it
    visible in the top-left corner of the element’s background? No problem, at least
    in theory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that the origin image is 300 pixels tall by 300 pixels wide and that
    only the bottom-right third of the image should be visible, we get the desired
    effect (shown in [Figure 8-13](#cab_fig23)) like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0813](assets/css5_0813.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-13\. Using negative length values to position the origin image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Or, say you want just the right half of the origin image to be visible and
    vertically centered within the element’s background area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Negative values will come into play later, as they are useful in creating gorgeous
    backgrounds; see [“Conic Gradients”](ch09.html#conic-gradients).
  prefs: []
  type: TYPE_NORMAL
- en: 'Negative percentages are also possible, although they are somewhat interesting
    to calculate. The origin image and the element are likely to be very different
    sizes, for one thing, and that can lead to unexpected effects. Consider, for example,
    the situation created by the following rule, illustrated in [Figure 8-14](#cab_fig24):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0814](assets/css5_0814.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-14\. Varying effects of negative percentage values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The rule calls for the point outside the origin image defined by `-10% -10%`
    to be aligned with a similar point for each paragraph. The image is 300 × 300
    pixels, so we know its alignment point can be described as 30 pixels above the
    top of the image, and 30 pixels to the left of its left edge (effectively `-30px`
    and `-30px`). The paragraph elements are all the same width (`500px`), so the
    horizontal alignment point is 50 pixels to the left of the left edge of their
    backgrounds. This means that each origin image’s left edge will be 20 pixels to
    the left of the left padding edge of the paragraphs. This is because the `-30px`
    alignment point of the images lines up with the `-50px` point for the paragraphs.
    The difference between the two is 20 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: The paragraphs have different heights, however, so the vertical alignment point
    changes for each paragraph. If a paragraph’s background area is 300 pixels high,
    to pick a semi-random example, then the top of the origin image will line up exactly
    with the top of the element’s background, because both will have vertical alignment
    points of `-30px`. If a paragraph is 50 pixels tall, its alignment point would
    be `-5px`, and the top of the origin image will actually be 25 pixels *below*
    the top of the background. This is why you can see all the tops of the background
    images in [Figure 8-14](#cab_fig24)—the paragraphs are shorter than the background
    image.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the offset edges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It’s time for a confession: throughout this whole discussion of background
    positioning, we’ve been keeping two facts from you. We acted as though the value
    of `background-position` could have no more than two keywords, and that all offsets
    were always made from the top-left corner of the background area.'
  prefs: []
  type: TYPE_NORMAL
- en: That was originally the case with CSS but hasn’t been true for a while. When
    we include four keywords, or two keywords and two length or percentage values
    in a very specific pattern, we can set the edge from which the background image
    should be offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example: placing the origin image a quarter of the
    way across and 30 pixels down from the top-left corner. Using what we saw in previous
    sections, that would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s do the same thing with this four-part syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This four-part value says, “From the `left` edge, have a horizontal offset of
    `25%`; from the `top` edge, have an offset of `30px`.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, so that’s a more verbose way of getting the default behavior. Now let’s
    change the code so the origin image is placed a quarter of the way across and
    30 pixels up from the bottom-right corner, as shown in [Figure 8-15](#cab_fig25)
    (which assumes no repeating of the background image, for clarity’s sake):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a value that means “from the `right` edge, have a horizontal offset
    of `25%`; from the `bottom` edge, have an offset of `30px`.”
  prefs: []
  type: TYPE_NORMAL
- en: Thus, the general pattern is *edge keyword, offset distance, edge keyword, offset
    distance*. You can mix the order of horizontal and vertical information; that
    is, `bottom 30px right 25%` works just as well as `right 25% bottom 30px`. However,
    you cannot omit either of the edge keywords; `30px right 25%` is invalid and will
    be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0815](assets/css5_0815.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-15\. Changing the offset edges for the origin image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: That said, you can omit an offset distance when you want it to be 0. So `right`
    `bottom` `30px` would put the origin image against the right edge and 30 pixels
    up from the bottom of the background area, whereas `right 25% bottom` would place
    the origin image a quarter of the way across from the right edge and up against
    the bottom. These are both illustrated in [Figure 8-16](#cab_fig26).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0816](assets/css5_0816.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-16\. Inferred zero-length offsets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can define only the edges of an element as offset bases, not the center.
    A value like `center 25% center 25px` will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple background images and only one background position, all
    the images will be placed in the same location. If you want to place them in different
    spots, provide a comma-separated list of background positions. They will be applied
    to the images in order. If you have more images than position values, the positions
    get repeated (as we’ll explore further later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Changing the positioning box
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now you know how to add an image to the background, and can even change where
    the origin image is placed. But what if we want to place it with respect to the
    border edge, or to the outer content edge, instead of to the default outer padding
    edge? We can use the property `background-origin`.
  prefs: []
  type: TYPE_NORMAL
- en: This property probably looks similar to `background-clip`, and with good reason,
    but its effect is distinct. Whereas `background-clip` defines the *background
    painting area*, `background-origin` defines the edge that’s used to determine
    placement of the origin image. This is also known as *defining the background
    positioning area*.
  prefs: []
  type: TYPE_NORMAL
- en: The default, `padding-box`, means that the top-left corner of the origin image
    will be placed in the top-left corner of the outer edge of the element’s padding
    box (if `background-position` hasn’t been changed from its default of `top left`
    or `0 0`), which is just inside the border area.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use the value `border-box`, the top-left corner of a `background-position:
    0 0` origin image will go into the top-left corner of the padding area. The border,
    if any, will be drawn over the origin image (assuming the background painting
    area wasn’t restricted to be `padding-box` or `content-box`, that is).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `content-box`, you shift the origin image to the top-left corner of the
    content area. The following code depicts the three options, illustrated in [Figure 8-17](#cab_fig27):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0817](assets/css5_0817.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-17\. The three types of background origins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember that this “placed in the top left” behavior is the default behavior,
    which you can change with `background-position`. The position of the origin image
    is calculated with respect to the box defined by `background-origin`: the border
    edge, the padding edge, or the content edge. Consider, for example, this variant
    of our previous example, which is illustrated in [Figure 8-18](#cab_fig28):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0818](assets/css5_0818.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-18\. The three types of background origins, redux
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Things can get *really* interesting if you’ve explicitly defined your background
    origin and clipping to be different boxes. Imagine you have the origin placed
    with respect to the padding edge but the background clipped to the content area,
    or vice versa. The following code results in [Figure 8-19](#cab_fig29):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0819](assets/css5_0819.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-19\. When origin and clipping diverge
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first example, the edges of the origin image are clipped because it is
    positioned with respect to the padding box, but the background painting area has
    been clipped at the edge of the content box. In the second example, the origin
    image is placed with respect to the content box, but the painting area extends
    into the padding box. Thus, the origin image is visible all the way down to the
    bottom padding edge, even though its top is not placed against the top padding
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: Background Repeating (or Lack Thereof)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Viewports come in an infinite number of sizes. Fortunately, we can tile background
    images, meaning we don’t need to create backgrounds of multiple sizes or serve
    large-format (and file size) wallpaper to small-screen low-bandwidth devices.
    When you want to repeat an image in a specific way, or when you don’t want to
    repeat it at all, we have `background-repeat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value syntax for `background-repeat` looks a bit complicated at first glance,
    but it’s fairly straightforward. In fact, at its base, it uses just four values:
    `repeat`, `no-repeat`, `space`, and `round`. The other two, `repeat-x` and `repeat-y`,
    are considered shorthand for combinations of the others. [Table 8-2](#cab_table03)
    shows how they break down.'
  prefs: []
  type: TYPE_NORMAL
- en: If two values are given, the first applies in the horizontal direction, and
    the second in the vertical. If there is just one value, it applies in both the
    horizontal and vertical directions, with the exception, as shown in [Table 8-2](#cab_table03),
    of `repeat-x` and `repeat-y`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Repeat keyword equivalents
  prefs: []
  type: TYPE_NORMAL
- en: '| Single keyword | Equivalent keywords |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `repeat-x` | `repeat no-repeat` |'
  prefs: []
  type: TYPE_TB
- en: '| `repeat-y` | `no-repeat repeat` |'
  prefs: []
  type: TYPE_TB
- en: '| `repeat` | `repeat repeat` |'
  prefs: []
  type: TYPE_TB
- en: '| `no-repeat` | `no-repeat no-repeat` |'
  prefs: []
  type: TYPE_TB
- en: '| `space` | `space space` |'
  prefs: []
  type: TYPE_TB
- en: '| `round` | `round round` |'
  prefs: []
  type: TYPE_TB
- en: 'As you might guess, `repeat` by itself causes the image to tile infinitely
    in all directions. The `repeat-x` and `repeat-y` values cause the image to be
    repeated in the horizontal or vertical directions, respectively, and `no-repeat`
    prevents the image from tiling along a given axis. If you have more than one image,
    each with different repeat patterns, provide a comma-separated list of values.
    We said “all directions” rather than “both directions” because a `background-position`
    may have put the initial repeating image somewhere other than the top-left corner
    of the clip box. With `repeat`, the image repeats in all directions. By default,
    the background image will start from the top-left corner of an element. Therefore,
    the following rules will have the effect shown in [Figure 8-20](#cab_fig30):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0820](assets/css5_0820.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-20\. Tiling the background image vertically
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s assume, though, that you want the image to repeat only across the top
    of the document. Rather than creating a special image with a whole lot of blank
    space underneath, you can just make a small change to that last rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As [Figure 8-21](#cab_fig31) shows, the image is repeated along the x-axis (horizontally)
    from its starting position—in this case, the top-left corner of the `<body>` element’s
    background area.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0821](assets/css5_0821.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-21\. Tiling the background image horizontally
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, you may not want to repeat the background image. In this case, use
    the value `no-repeat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'With this tiny image, `no-repeat` may not seem terribly useful, but it is the
    most common value, and unfortunately not the default. Let’s try it again with
    a much bigger symbol. The following code results in [Figure 8-22](#cab_fig32):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0822](assets/css5_0822.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-22\. Placing a single large background image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The ability to control the repeat direction dramatically expands the range
    of possible effects. For example, let’s say you want a triple border on the left
    side of each `<h1>` element in your document. You can take that concept further
    and decide to set a wavy border along the top of each `<h2>` element. The image
    is colored in such a way that it blends with the background color and produces
    the wavy effect shown in [Figure 8-23](#cab_fig33), which is the result of the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0823](assets/css5_0823.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-23\. Bordering elements with background images
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are better ways to create a wavy-border effect—notably, the border image
    properties explored in [“Image Borders”](ch07.html#image-borders).
  prefs: []
  type: TYPE_NORMAL
- en: Positioning images that repeat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we explored the values `repeat-x`, `repeat-y`, and
    `repeat`, and how they affect the tiling of background images. In each case, the
    tiling pattern always started from the top-left corner of the element’s background.
    That’s because, as you’ve seen, the default values for `background-position` are
    `0% 0%`. Given that you know how to change the position of the origin image, you
    need to know how user agents will handle it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will be easier to show an example and then explain it. Consider the following
    markup, which is illustrated in [Figure 8-24](#cab_fig34):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0824](assets/css5_0824.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-24\. Centering the origin image and repeating it
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So there you have it: stripes running through the center of the elements. It
    may look wrong, but it isn’t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These examples are correct because the origin image has been placed in the
    center of the first `<p>` element. In the first example, the image is tiled along
    the y-axis *in both* *directions*—up *and* down, starting from the origin image
    at the center. In the second example, the images are tiled along the x-axis, starting
    from the origin image, and repeated to both the right *and* left. You may notice
    the first and last repetitions are slightly cut off, whereas when we started with
    `background-position: 0 0`, only the last image, or rightmost and bottommost images,
    risked being clipped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting an image in the center of the `<p>` and then letting it fully repeat
    will cause it to tile in all *four* directions: up, down, left, and right. The
    only difference `background-position` makes is in where the tiling starts. When
    the background image repeats from the center, the grid of yin-yang symbols is
    centered within the element, resulting in consistent clipping along the edges.
    When the tiling begins at the top-left corner of the padding area, the clipping
    is not consistent around the edges. The `spacing` and `rounding` values, on the
    other hand, prevent image clipping but have their own drawbacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In case you’re wondering, CSS has no single-direction values such as `repeat-left`
    or `repeat-up`.
  prefs: []
  type: TYPE_NORMAL
- en: Spacing and rounding repeat patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Beyond the basic tiling patterns you’ve seen thus far, `background-repeat`
    has the ability to exactly fill out the background area. Consider, for example,
    what happens if we use the value `space` to define the tiling pattern, as shown
    in [Figure 8-25](#cab_fig36):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0825](assets/css5_0825.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-25\. Tiling the background image with filler space
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ll notice background images in each of the four corners of the element.
    Furthermore, the images are spaced out so that they occur at regular intervals
    in both the horizontal and vertical directions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what `space` does: it determines the number of repetitions that will
    fully fit along a given axis, and then spaces them out at regular intervals so
    that the repetitions go from one edge of the background to another. This doesn’t
    guarantee a regular square grid, with intervals that are all the same both horizontally
    and vertically. It just means that you’ll have what look like columns and rows
    of background images. While no image will be clipped, unless there isn’t enough
    room for even one iteration (as can happen with very large background images),
    this value often results in different horizontal and vertical separations. [Figure 8-26](#cab_fig37)
    shows some examples.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0826](assets/css5_0826.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8-26\. Tiling with different intervals showing `background-repeat: space`
    on elements of different sizes'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Keep in mind that any background color, or the “backdrop” of the element (that
    is, the combined backgrounds of the element’s ancestors) will show through the
    gaps between `space`-separated background images.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if you have a really big image that won’t fit more than once,
    or even once, along the given axis? That image is drawn once, placed as determined
    by the value of `background-position`, and clipped as necessary. The flip side
    is that if more than one repetition of the image will fit along an axis, the value
    of `background-position` is ignored along that axis. The following code, for example,
    displays [Figure 8-27](#cab_fig38):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0827](assets/css5_0827.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-27\. Spacing along one axis but not the other
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the images are spaced horizontally, and thus override the `center`
    position along that axis, but are centered vertically and not spaced (because
    there isn’t enough room to do so). That’s the effect of `space` overriding `center`
    along one axis but not the other.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the value `round` will most likely result in scaling of the background
    image as it is repeated, *and* (strangely enough) will not override `background-position`.
    If an image won’t quite repeat so that it goes from edge to edge of the background,
    that image will be scaled up *or* down to make it fit a whole number of times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the images can be scaled differently along each axis. The `round`
    value is the only background property value that can alter an image’s intrinsic
    aspect ratio automatically if needed. While `background-size` can also lead to
    a change in the aspect ratio, distorting the image, this happens only by explicit
    direction from the author. You can see an example in [Figure 8-28](#cab_fig39),
    which is the result of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0828](assets/css5_0828.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-28\. Tiling the background image with scaling
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that if you have a background 850 pixels wide and a horizontally rounded
    image that’s 300 pixels wide, a browser can decide to use three images and scale
    them down to fit three across into the 850-pixel area (thus making each instance
    of the image 283.333 pixels wide). With `space`, the browser would have to use
    two images and put 250 pixels of space between them, but `round` is not so constrained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the interesting wrinkle: while `round` will resize the images so that
    you can fit a whole number of them into the background, it will *not* move them
    to make sure that they actually touch the edges of the background. The only way
    to make sure your repeating pattern fits and no background images are clipped
    is to put the origin image in a corner. If the origin image is anywhere else,
    clipping will occur. The following code shows an example, illustrated in [Figure 8-29](#cab_fig40):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0829](assets/css5_0829.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-29\. Rounded background images that are clipped
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The images are still scaled so that they would fit into the background positioning
    area a whole number of times. They just aren’t repositioned to actually do so.
    Thus, if you’re going to use `round` and don’t want to have any clipped background
    tiles, make sure you’re starting from one of the four corners (and make sure the
    background positioning and painting areas are the same; see [“Tiling and clipping
    repeated backgrounds”](#tiling-and-clipping) for more).
  prefs: []
  type: TYPE_NORMAL
- en: Tiling and clipping repeated backgrounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you may recall, `background-clip` can alter the area in which the background
    is drawn, and `background-origin` determines the placement of the origin image.
    So what happens when you’ve made the clipping area and the origin area different,
    *and* you’re using either `space` or `round` for the tiling pattern?
  prefs: []
  type: TYPE_NORMAL
- en: The basic answer is that if your values for `background-origin` and `background-clip`
    aren’t the same, clipping will happen. This is because `space` and `round` are
    calculated with respect to the background positioning area, not the painting area.
    [Figure 8-30](#cab_fig41) shows some examples of what can happen.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0830](assets/css5_0830.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-30\. Clipping due to mismatched clip and origin values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As for the best combination of values to use, that’s a matter of opinion and
    circumstance. In most cases, setting both `background-origin` and `background-clip`
    to `padding-box` will likely get you the results you desire. If you plan to have
    borders with see-through bits, though, `border-box` might be a better choice.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Attached
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you know how to place the origin image for the background anywhere in the
    background of an element, and you know how to control (to a large degree) the
    way it tiles. As you may have realized already, placing an image in the center
    of the `<body>` element could mean, given a sufficiently long document, that the
    background image won’t be initially visible to the reader. After all, a browser
    is a viewport providing a window onto the document. If the document is too long
    to be completely shown in the viewport, the user can scroll back and forth through
    the document. The center of the body could be two or three “screens” below the
    beginning of the document, or just far enough down to push most of the origin
    image beyond the bottom of the browser window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, if the origin image is initially visible, by default it scrolls
    with the document—vanishing when the user scrolls beyond the location of the image.
    Never fear: CSS provides a way to prevent the background image from scrolling
    out of view.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the property `background-attachment`, you can declare the origin image
    to be fixed with respect to the viewing area and therefore immune to the effects
    of scrolling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Doing this has two immediate effects. First, the origin image does not scroll
    along with the document. Second, the placement of the origin image is determined
    by the size of the viewport, not the size (or placement within the viewport) of
    the element that contains it. [Figure 8-31](#cab_fig43) shows the image still
    sitting in the center of the viewport, even though the document has been scrolled
    partway through the text.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0831](assets/css5_0831.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-31\. The centering continues to hold
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The element-specific version of `fixed` is `local`. In this case, though, the
    effect is seen only when an element’s content (rather than the whole document)
    has to be scrolled. This is tricky to grasp at first. Consider the following,
    where `background-attachment` is defaulting to `scroll`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this situation, if the content of an `aside` is taller than 20 em, the overflowed
    content is not visible but can be accessed using a scrollbar. The background image,
    however, will *not* scroll with the content. It will instead stay in the top-right
    corner of the element box.
  prefs: []
  type: TYPE_NORMAL
- en: 'By adding `background-attachment: local`, the image is attached to the local
    context. The visual effect is rather like an `iframe`, if you have any experience
    with those. [Figure 8-32](#cbag_css4_background-attachment-local) shows the results
    of the previous code sample and the following code side by side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0832](assets/css5_0832.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-32\. Default scroll attachment versus local attachment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One other value for `background-attachment` is the default value `scroll`. As
    you might expect, this causes the background image to scroll along with the rest
    of the document when viewed in a web browser, and it doesn’t necessarily change
    the position of the origin image as the window is resized. If the document width
    is fixed (perhaps by assigning an explicit `width` to the `<body>` element), resizing
    the viewing area won’t affect the placement of a scroll-attachment origin image
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: Useful side effects of attached backgrounds
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In technical terms, when a background image has been fixed, it is positioned
    with respect to the viewing area, not the element that contains it. However, the
    background will be visible only within its containing element. Aligning images
    to the viewport, rather than the element, can be used to our advantage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have a document with a tiled background that actually looks like
    it’s tiled, and both `<h1>` and `<h2>` elements with the same pattern, only in
    a different color. You set both the `<body>` and heading elements to have fixed
    backgrounds as follows, resulting in [Figure 8-33](#cab_fig44):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This neat trick is made possible because when a background’s attachment is `fixed`,
    the origin element is positioned with respect to the *viewport*. Thus, both background
    patterns begin tiling from the top-left corner of the viewport, not from the individual
    elements. For the `<body>`, you can see the entire repeat pattern. For the `<h1>`,
    however, the only place you can see its background is in the padding and content
    of the `<h1>` itself. Since both background images are the same size and have
    precisely the same origin, they appear to line up, as shown in [Figure 8-33](#cab_fig44).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0833](assets/css5_0833.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-33\. Perfect alignment of backgrounds
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This capability can be used to create sophisticated effects. One of the most
    famous examples is the [“complexspiral distorted” demonstration](https://meyerweb.com/eric/css/edge/complexspiral/glassy.html),
    shown in [Figure 8-34](#cab_fig45).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0834](assets/css5_0834.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-34\. The complexspiral distorted
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The visual effects are caused by assigning different fixed-attachment background
    images to non-`<body>` elements. The entire demo is driven by one HTML document,
    four JPEG images, and a stylesheet. Because all four images are positioned in
    the top-left corner of the browser window but are visible only where they intersect
    with their elements, the images line up to create the illusion of translucent
    rippled glass. (Now we can use SVG filters for these sorts of special effects,
    but fixed-attachment backgrounds made creating faux filters possible back in 2002.)
  prefs: []
  type: TYPE_NORMAL
- en: It is also the case that in paged media, such as printouts, every page generates
    its own viewport. Therefore, a fixed-attachment background should appear on every
    page of the printout. This could be used for effects such as watermarking all
    the pages in a document.
  prefs: []
  type: TYPE_NORMAL
- en: Sizing Background Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, we’ve taken images of varying sizes and dropped them into element
    backgrounds to be repeated (or not), positioned, clipped, and attached. In every
    case, we just took the image at whatever intrinsic size it was (with the automated
    exception of `round` repeating). Ready to actually change the size of the origin
    image and all the tiled images that spawn from it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by explicitly resizing a background image. We’ll drop in an image
    that’s 200 × 200 pixels and then resize it to be twice as big. The following code
    results in [Figure 8-35](#cab_fig46):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0835](assets/css5_0835.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-35\. Resizing the origin image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With `background-size`, we can resize the origin image to be smaller. We can
    size it using ems, pixels, viewport widths, any length unit, or a combination
    thereof.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even distort the image by changing its size. [Figure 8-36](#cab_fig47)
    illustrates the results when changing the previous code sample to use `background-size:
    400px 4em`, with both repeated and nonrepeated backgrounds.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0836](assets/css5_0836.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-36\. Distorting the origin image by resizing it
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, when `background-size` has two values, the first is the horizontal
    size and the second is the vertical. If you allow the image to repeat, all the
    repeated images will be the same size as the origin image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Percentages are a little more interesting. If you declare a percentage value,
    it’s calculated with respect to the background positioning area—that is, the area
    defined by `background-origin`, and *not* by `background-clip`. Suppose you want
    an image that’s half as wide and half as tall as its background positioning area;
    the following code results in [Figure 8-37](#cab_fig48):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0837](assets/css5_0837.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-37\. Resizing the origin image with percentages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'And yes, you can mix lengths and percentages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Negative length and percentage values are not permitted for `background-size`.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining the background image’s aspect ratio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, what about the default value of `auto`? First off, when only one value
    is provided, it’s taken for the horizontal size, and the vertical size is set
    to `auto`. (Thus `background-size: auto` is equivalent to `background-size: auto
    auto`.) If you want to size the origin image vertically and leave the horizontal
    size to be automatic, thus preserving the intrinsic aspect ratio of the image,
    you have to write it explicitly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In many ways, `auto` in `background-size` acts a lot like the `auto` values
    of `height` and `width` (also `block-size` and `inline-size`) when applied to
    replaced elements such as images. That is to say, you’d expect roughly similar
    results from the following two rules, if they were applied to the same image in
    different contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Covering and containing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now for some real fun! Suppose you want to cover the entire background of an
    element with an image, and you don’t care if parts of it stick outside the background
    painting area. In this case, you can use `cover`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This scales the origin image so that it completely covers the background positioning
    area while still preserving its intrinsic aspect ratio, assuming it has one. You
    can see an example in [Figure 8-38](#cab_fig50), where a 200 × 200 pixel image
    is scaled up to cover the background of an 800 × 400 pixel element. The following
    code provides this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that there is no `background-repeat` in this example. That’s because we
    expect the image to fill out the entire background, so whether it’s repeated or
    not doesn’t really matter.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that `cover` is very different from `100% 100%`. If we’d used
    `100% 100%`, the origin image would have been stretched to be 800 pixels wide
    by 400 pixels tall. Instead, `cover` made it 800 pixels wide and tall, then centered
    the image inside the background positioning area. This is the same as if we’d
    said `100% auto` in this particular case, but the beauty of `cover` is that it
    works regardless of whether your element is wider than it is tall, or taller than
    it is wide.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0838](assets/css5_0838.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-38\. Covering the background with the origin image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By contrast, `contain` will scale the image so that it fits exactly inside
    the background positioning area, even if that leaves some of the rest of the background
    showing around it. This is illustrated in [Figure 8-39](#cab_fig51), which is
    the result of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0839](assets/css5_0839.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-39\. Containing the origin image within the background
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this case, since the element is shorter than it is tall, the origin image
    is scaled so it is as tall as the background positioning area, and the width is
    scaled to match, just as if we’d declared `auto 100%`. If an element is taller
    than it is wide, `contain` acts like `100% auto`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll note that we brought `no-repeat` back to the example so the visual result
    wouldn’t become too visually confusing. Removing that declaration would cause
    the background to repeat, which is no big deal if that’s what you want. [Figure 8-40](#cab_fig52)
    shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0840](assets/css5_0840.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-40\. Repeating a contained origin image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Always remember: the sizing of `cover` and `contain` images is always with
    respect to the background positioning area, which is defined by `background-origin`.
    This is true even if the background painting area defined by `background-clip`
    is different! Consider the following rules, which are depicted in [Figure 8-41](#cab_fig53):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0841](assets/css5_0841.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-41\. Covering and containing with `background-clip` and `background-origin`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Yes, you can see background color around the edges of some of these, and others
    get clipped. That’s the difference between the painting area and the positioning
    area. You’d think that `cover` and `contain` would be sized with respect to the
    painting area, but they aren’t, as depicted in the last examples in [Figure 8-41](#cab_fig53).
    Keep that firmly in mind whenever you use these values.
  prefs: []
  type: TYPE_NORMAL
- en: If you have more than one background image, with different values for position,
    repeat, or size, include a comma-separated list of values. Each value in a list
    will be associated with the image in that position in the list. If there are more
    values than images, the extra values are ignored. If there are fewer, the list
    is repeated. You can set only one background color, though.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this section, we used raster images (GIFs, to be precise) even though they
    tend to look horrible when scaled up and represent a waste of network resources
    when scaled down. (We did this so that it would be extra obvious when lots of
    up-scaling was happening.) This is an inherent risk in scaling background raster
    images. On the other hand, you can just as easily use SVGs as background images,
    and they scale up or down with no loss of quality or waste of bandwidth. If you’re
    going to be scaling a background image and it doesn’t have to be a photograph,
    strongly consider using SVG or CSS gradients.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing It All Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As is often the case with thematic areas of CSS, the background properties
    can all be brought together in a single shorthand property: `background`. Whether
    you might want to do that is another question entirely.'
  prefs: []
  type: TYPE_NORMAL
- en: This syntax can get a little confusing. Let’s start simple and work our way
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'First off, the following statements are all equivalent to one another and will
    have the effect shown in [Figure 8-42](#cab_fig54):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0842](assets/css5_0842.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-42\. Using shorthand
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can mostly mix up the order of the values however you like, with three
    restrictions. First, any `background-size` value *must* come immediately after
    the `background-position` value, and must be separated from it by a forward slash
    (`/`). Second, within those values, the usual restrictions apply: the horizontal
    value comes first, and the vertical value follows, assuming that you’re supplying
    axis-derived values (as opposed to, say, `cover`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, if you supply values for both `background-origin` and `background-clip`,
    the first of the two you list will be assigned to `background-origin`, and the
    second to `background-clip`. Therefore, the following two rules are functionally
    identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Related to that, if you supply only one such value, it sets both `background-origin`
    and `background-clip`. Thus, the following shorthand sets both the background
    positioning area and the background painting area to the padding box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As is the case for shorthand properties, if you leave out any values, the defaults
    for the relevant properties are filled in automatically. Thus, the following two
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, `background` has no required values—as long as you have at least
    one value present, you can omit the rest. It’s possible to set just the background
    color using the shorthand property, which is a very common practice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'On that note, remember that `background` is a shorthand property, and, as such,
    its default values can obliterate previously assigned values for a given element.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Given these rules, `<h1>` elements will be styled according to the first rule.
    And `<h2>` elements will be styled according to the second, which means they’ll
    just have a flat silver background. No image will be applied to `<h2>` backgrounds,
    let alone centered and repeated horizontally. It is more likely that the author
    meant to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This lets the background color be changed without wiping out all the other values.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more restriction will lead us very neatly into the next section: you can
    supply a background color to only the final background layer. No other background
    layer can have a solid color declared. What the heck does that mean? So glad you
    asked.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Multiple Backgrounds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Throughout most of this chapter, we’ve only briefly mentioned that almost all
    the background properties accept a comma-separated list of values. For example,
    if you wanted to have three different background images, you could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Seriously. It will look like [Figure 8-43](#cab_fig55).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0843](assets/css5_0843.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-43\. Multiple background images
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This creates three background layers, one for each image, with the last being
    the final, bottom background layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The three images are piled into the top-left corner of the element and don’t
    repeat. The lack of repetition occurs because we declared `background-repeat:
    no-repeat`. We declared it only once, and there are three background images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a mismatch occurs between the number of values in a background-related
    property and the `background-image` property, the missing values are derived by
    repeating the sequence in the property with a value undercount. Thus, in the previous
    example, it was as though we had said this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we want to put the first image at the top right, put the second
    at the center of the left side, and put the last layer at the center of the bottom.
    We can layer `background-position` as follows, resulting in [Figure 8-44](#cab_fig56):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0844](assets/css5_0844.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-44\. Individually positioning background images
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Similarly, say we want to keep the first two layers from repeating, but horizontally
    repeat the third:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Nearly every background property can be comma-listed this way. You can have
    different origins, clipping boxes, sizes, and just about everything else for each
    background layer you create. Technically, there is no limit to the number of layers
    you can have, though at a certain point it’s just going to get silly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the shorthand `background` can be comma-separated. The following example
    is exactly equivalent to the previous one, and the result is shown in [Figure 8-45](#cab_fig57):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0845](assets/css5_0845.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-45\. Multiple background layers via shorthand
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The only real restriction on multiple backgrounds is that `background-color`
    does *not* repeat in this manner, and if you provide a comma-separated list for
    the `background` shorthand, the color can appear on only the last background layer.
    If you add a color to any other layer, the entire `background` declaration is
    made invalid. Thus, if we want to have a green background fill for the previous
    example, we’d do it in one of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The reason for this restriction is pretty straightforward. Imagine if you were
    able to add a full background color to the first background layer. It would fill
    in the whole background and obscure all the background layers behind it! So if
    you do supply a color, it can be on only the last layer, which is “bottommost.”
  prefs: []
  type: TYPE_NORMAL
- en: 'This ordering is important to internalize as soon as possible, because it runs
    counter to the instincts you’ve likely built up in the course of using CSS. After
    all, you know what will happen here—the `<h1>` background will be green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrast that with this multiple-background rule, which will make the `<h1>`
    background red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Yes, red. The red GIF is tiled to cover the entire background area, as is the
    green GIF, but the red GIF is “on top of” the green GIF. It’s closer to you. And
    the effect is exactly backward from the “last one wins” rules built into the cascade.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visualize it like this: when there are multiple backgrounds, they’re
    listed like the layers in a drawing program such as Adobe Photoshop or Illustrator.
    In the layer palette of a drawing program, layers at the top of the palette are
    drawn over the layers at the bottom. The same process plays out here: the layers
    listed at the top of the list are drawn over the layers at the bottom of the list.'
  prefs: []
  type: TYPE_NORMAL
- en: The odds are pretty good that you will, at some point, set up a bunch of background
    layers in the wrong order, because your cascade-order reflexes will kick in. (This
    error still occasionally trips up the authors even to this day, so don’t get down
    on yourself if it gets you too.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Another fairly common mistake when you’re getting started with multiple backgrounds
    is to use the `background` shorthand and forget to explicitly turn off background
    tiling for your background layers by letting the `background-repeat` value default
    to `repeat`, thus obscuring all but the top layer. See [Figure 8-46](#cab_fig59),
    for example, which is the result of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see only the top layer because it’s tiling infinitely, thanks to the
    default value of `background-repeat`. That’s why the example at the beginning
    of this section used `background-repeat: no-repeat`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0846](assets/css5_0846.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-46\. Obscuring layers with repeated images
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using the Background Shorthand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One way to avoid these sorts of situations is to use the `background` shorthand,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: That way, when you add or subtract background layers, the values you meant to
    apply specifically to them will come in or go out with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can mean some annoying repetition if all the backgrounds should have the
    same value of a given property, like `background-origin`. If that’s the situation,
    you can blend the two approaches, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This works just as long as you don’t need to make any exceptions. The minute
    you decide to change the origin of one of those background layers, you’ll need
    to explicitly list them, whether you do it in `background` or with the separate
    `background-origin` declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the number of layers is determined by the number of background
    images, and so, by definition, `background-image` values are *not* repeated to
    equal the number of comma-separated values given for other properties. You might
    want to put the same image in all four corners of an element and think you could
    do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The result, however, would be to place a single red box in the top-left corner
    of the element. To get images in all four corners, as shown in [Figure 8-47](#cab_fig60),
    you’ll have to list the same image four times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0847](assets/css5_0847.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-47\. Placing the same image in all four corners
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Creating Box Shadows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have learned about border images, outlines, and background images. CSS
    has another property that can decorate both the inside and outside of an element
    without impacting the box model: `box-shadow`.'
  prefs: []
  type: TYPE_NORMAL
- en: It might seem a little out of place to talk about shadows in a chapter mostly
    concerned with backgrounds, but you’ll understand our reasoning in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a simple box drop shadow: one that’s 10 pixels down and 10 pixels
    to the right of an element box, and a half-opaque black. Behind it we’ll put a
    repeating background on the `<body>` element. All of this is illustrated in [Figure 8-48](#Asimpleboxshadow)
    and created with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0848](assets/css5_0848.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-48\. A simple box shadow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can see that the `<body>`’s background is visible through the half-opaque
    (or half-transparent, if you prefer) drop shadow. Because no blur or spread distances
    are defined, the drop shadow exactly mimics the outer shape of the element box
    itself—at least it appears to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason it only appears to mimic the shape of the box is that the shadow
    is visible only outside the outer border edge of the element. We couldn’t really
    see that in the previous figure, because the element had an opaque background.
    You might have just assumed that the shadow extended all the way under the element,
    but it doesn’t. Consider the following, illustrated in [Figure 8-49](#Boxshadowsareincomplete):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0849](assets/css5_0849.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-49\. Box shadows are incomplete
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So it looks as though the element’s content (and padding and border) area “knocks
    out” part of the shadow. In truth, it’s just that the shadow was never drawn there,
    because of the way box shadows are defined in the specification. This does mean,
    as [Figure 8-49](#Boxshadowsareincomplete) demonstrates, that any background “behind” the
    box with a drop shadow can be visible through the element itself. This (perhaps
    bizarre-seeming) interaction with the backgrounds and borders is why `box-shadow`
    is covered here, instead of at an earlier point in the text.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve seen box shadows defined with two length values. The first defines
    a horizontal offset, and the second a vertical offset. Positive numbers move the
    shadow down and to the right, and negative numbers move the shadow up and to the
    left.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a third length is given, it defines a blur distance, which determines how
    much space is given to blurring. A fourth length defines a spread distance, which
    changes the size of the shadow. Positive length values make the shadow expand
    before blurring happens; negative values cause the shadow to shrink. The following
    has the results shown in [Figure 8-50](#Variousblurredandspreadshadows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0850](assets/css5_0850.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-50\. Various blurred and spread shadows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may have noticed that some of these boxes have rounded corners (via `border-radius`),
    and that their shadows are curved to match. This is the defined behavior, fortunately.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have yet to cover one aspect of `box-shadow`, which is the `inset` keyword.
    If `inset` is added to the value of `box-shadow`, the shadow is rendered inside
    the box, as if the box were a punched-out hole in the canvas rather than floating
    above it (visually speaking). Let’s take the previous set of examples and redo
    them with inset shadows. This will have the result shown in [Figure 8-51](#Variousinsetshadows):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0851](assets/css5_0851.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-51\. Various inset shadows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that the `inset` keyword can appear before the rest of the value, or after,
    but *not* in the middle of the lengths and colors. A value like `0 0 0.1em inset
    gray` would be ignored as invalid because of the placement of the `inset` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last point to note is that you can apply to an element a list of as many
    comma-separated box shadows as you like, just as with text shadows. Some could
    be inset, and some outset. The following rules are just two of the infinite possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple shadows are drawn back to front, just as background layers are, so
    the first shadow in the comma-separated list will be “on top” of all the others.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The green is drawn first, then the blue on top of the green, and the red drawn
    last, on top of the blue. While box shadows can be infinitely wide, they do not
    contribute to the box model and take up no space. Because of this, make sure to
    include enough space, especially if you’re doing large offsets or blur distances.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `filter` property is another way to create element drop shadows, although
    it is much closer in behavior to `text-shadow` than `box-shadow`, albeit applying
    to the entire element box and text. See [Chapter 20](ch20.html#filters-compositing)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding backgrounds to elements, whether with colors or images, gives you a great
    deal of power over the total visual presentation. The advantage of CSS over older
    methods is that colors and backgrounds can be applied to any element in a document,
    and manipulated in surprisingly complex ways.
  prefs: []
  type: TYPE_NORMAL
