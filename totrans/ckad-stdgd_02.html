<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Kubernetes in a Nutshell" class="praise"><div class="dedication" id="kubernetes_nutshell">
<h1 class="calibre14"><span class="keep-together">Chapter 2. </span>Kubernetes in a Nutshell</h1>


<p class="author1">It’s helpful to get a quick rundown of what Kubernetes is and how it works if you are new to the space. Many tutorials and 101 courses are available on the web, but I would like to summarize the most important background information and concepts in this chapter. In the course of this book, we’ll reference cluster node components, so feel free to come back to this information at any time.</p>






<section data-type="sect1" data-pdf-bookmark="What Is Kubernetes?" class="praise"><div class="dedication" id="id139">
<h1 class="calibre17">What Is Kubernetes?</h1>

<p class="author1">To understand what Kubernetes is, first let’s define microservices and containers.</p>

<p class="author1">Microservice architectures call for developing and executing pieces of the application stack as individual services, and those services have to communicate with one another. If you decide to operate those services in containers, you will need to manage a lot of them while at the same time thinking about cross-cutting concerns like scalability, security, persistence, and load balancing.</p>

<p class="author1">Tools like <a href="https://github.com/moby/buildkit" class="calibre10">buildkit</a> and <a href="https://podman.io/" class="calibre10">Podman</a> package software artifacts into a container image. Container runtime engines like <a href="https://docs.docker.com/engine/" class="calibre10">Docker Engine</a> and <a href="https://containerd.io/" class="calibre10">containerd</a> use the image to run a container. This works great on developer machines for testing purposes or for ad-hoc executions, e.g., as part of a Continuous Integration pipeline. For more information on containers, refer to <a data-type="xref" href="ch04.xhtml#containers" class="calibre10">Chapter 4</a>.</p>

<p class="author1">Kubernetes is a container orchestration tool that helps with operating hundreds or even thousands of containers on physical machines, virtual machines, or in the cloud. Kubernetes can also fulfill those cross-cutting concerns mentioned earlier. The container runtime engine integrates with Kubernetes. Whenever a container creation is triggered, Kubernetes will delegate life cycle aspects to the container runtime engine.</p>

<p class="author1">The most essential primitive in a Kubernetes is a Pod. The Pod can run one or many containers while at the same time adding cross-cutting concerns like security requirements and resource consumption expectations. Have a look at <a data-type="xref" href="ch05.xhtml#pods_namespaces" class="calibre10">Chapter 5</a> to learn about those aspects.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Features" class="praise"><div class="dedication" id="id140">
<h1 class="calibre17">Features</h1>

<p class="author1">The previous section touched on some features provided by Kubernetes. Here, we are going to dive a little deeper by explaining those features with more detail:</p>
<dl class="calibre18">
<dt class="calibre19">Declarative model</dt>
<dd class="calibre20">
<p class="calibre21">You do not have to write imperative code using a programming language to tell Kubernetes how to operate an application. All you need to do as an end user is to declare a desired state. The desired state can be defined using a YAML or JSON manifest that conforms to an API schema. Kubernetes then maintains the state and recovers it in case of a failure.</p>
</dd>
<dt class="calibre19">Autoscaling</dt>
<dd class="calibre20">
<p class="calibre21">You will want to scale up resources when your application load increases, and scale down when traffic to your application decreases. This can be achieved in Kubernetes by manual or automated scaling. The most practical, optimized option is to let Kubernetes automatically scale resources needed by a containerized application.</p>
</dd>
<dt class="calibre19">Application management</dt>
<dd class="calibre20">
<p class="calibre21">Changes to applications, e.g., new features and bug fixes, are usually baked into a container image with a new tag. You can easily roll out those changes across all containers running them using Kubernetes’ convenient replication feature. If needed, Kubernetes also allows for rolling back to a previous application version in case of a blocking bug or if a security vulnerability is detected.</p>
</dd>
<dt class="calibre19">Persistent storage</dt>
<dd class="calibre20">
<p class="calibre21">Containers offer only a temporary filesystem. Upon restart of the container, all data written to the filesystem is lost. Depending on the nature of your application, you may need to persist data for longer, for example, if your application interacts with a database. Kubernetes offers the ability to mount storage required by application workloads.</p>
</dd>
<dt class="calibre19">Networking</dt>
<dd class="calibre20">
<p class="calibre21">To support a microservices architecture, the container orchestrator needs to allow for communication between containers, and from end users to containers from outside of the cluster. Kubernetes employs internal and external load balancing for routing network traffic.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="High-Level Architecture" class="praise"><div class="dedication" id="id141">
<h1 class="calibre17">High-Level Architecture</h1>

<p class="author1">Architecturally, a Kubernetes cluster consists of control plane nodes and worker nodes, as shown in <a data-type="xref" href="#kubernetes-architecture" class="calibre10">Figure 2-1</a>. Each node runs on infrastructure provisioned on a physical or virtual machine, or in the cloud. The number of nodes you want to add to the cluster and their topology depends on the application resource needs.</p>

<figure class="calibre35"><div id="kubernetes-architecture" class="figure">
<img src="Images/ckd2_0201.png" alt="ckd2 0201" class="calibre40"/>
<h6 class="calibre32"><span class="keep-together">Figure 2-1. </span>Kubernetes cluster nodes and components</h6>
</div></figure>

<p class="author1">Control plane nodes and worker nodes have specific responsibilities:</p>
<dl class="calibre18">
<dt class="calibre19">Control plane node</dt>
<dd class="calibre20">
<p class="calibre21">This node exposes the Kubernetes API through the API server and manages the nodes that make up the cluster. It also responds to cluster events, for example, when the end user requested to scale up the number of Pods to distribute the load for an application. Production clusters employ a <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/ha-topology/" class="calibre10">highly available (HA) architecture</a> that usually involves three or more control plane nodes.</p>
</dd>
<dt class="calibre19">Worker node</dt>
<dd class="calibre20">
<p class="calibre21">The worker node executes workload in containers managed by Pods. Every worker node needs a container runtime engine installed on the host machine to be able to manage containers.</p>
</dd>
</dl>

<p class="author1">In the next two sections, we’ll talk about the essential components embedded in those nodes to fulfill their tasks. Add-ons like cluster DNS are not discussed explicitly here. See the <a href="https://kubernetes.io/docs/concepts/overview/components/" class="calibre10">Kubernetes documentation</a> for more details.</p>








<section data-type="sect2" data-pdf-bookmark="Control Plane Node Components" class="praise"><div class="dedication" id="id142">
<h2 class="calibre33">Control Plane Node Components</h2>

<p class="author1">The control plane node requires a specific set of components to perform its job. The following list of components will give you an overview:</p>
<dl class="calibre18">
<dt class="calibre19">API server</dt>
<dd class="calibre20">
<p class="calibre21">The API server exposes the API endpoints clients use to communicate with the Kubernetes cluster. For example, if you execute the tool <code class="calibre15">kubectl</code>, a command-line based Kubernetes client, you will make a RESTful API call to an endpoint exposed by the API server as part of its implementation. The API processing procedure inside of the API server will ensure aspects like authentication, authorization, and admission control. For more information on that topic, see <a data-type="xref" href="ch17.xhtml#authentication_authorization_admission_control" class="calibre10">Chapter 17</a>.</p>
</dd>
<dt class="calibre19">Scheduler</dt>
<dd class="calibre20">
<p class="calibre21">The scheduler is a background process that watches for new Kubernetes Pods with no assigned nodes and assigns them to a worker node for execution.</p>
</dd>
<dt class="calibre19">Controller manager</dt>
<dd class="calibre20">
<p class="calibre21">The controller manager watches the state of your cluster and implements changes where needed. For example, if you make a configuration change to an existing object, the controller manager will try to bring the object into the desired state.</p>
</dd>
<dt class="calibre19">Etcd</dt>
<dd class="calibre20">
<p class="calibre21">Cluster state data needs to be persisted over time so it can be reconstructed upon a node or even a full cluster restart. That’s the responsibility of <a href="https://etcd.io/" class="calibre10">etcd</a>, an open source software Kubernetes integrates with. At its core, etcd is a key-value store used to persist all data related to the Kubernetes cluster.</p>
</dd>
</dl>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Common Node Components" class="praise"><div class="dedication" id="id143">
<h2 class="calibre33">Common Node Components</h2>

<p class="author1">Kubernetes employs components that are leveraged by all nodes independent of their specialized responsibility:</p>
<dl class="calibre18">
<dt class="calibre19">Kubelet</dt>
<dd class="calibre20">
<p class="calibre21">The kubelet runs on every node in the cluster; however, it makes the most sense to exist on a worker node. The reason is that the control plane node usually doesn’t execute workload, and the worker node’s primary responsibility is to run workload. The kubelet is an agent that makes sure that the necessary containers are running in a Pod. You could say that the kubelet is the glue between Kubernetes and the container runtime engine and ensures that containers are running and healthy. We’ll have a touch point with the kubelet in <a data-type="xref" href="ch14.xhtml#container_probes" class="calibre10">Chapter 14</a>.</p>
</dd>
<dt class="calibre19">Kube proxy</dt>
<dd class="calibre20">
<p class="calibre21">The kube proxy is a network proxy that runs on each node in a cluster to maintain network rules and enable network communication. In part, this component is responsible for implementing the Service concept covered in <a data-type="xref" href="ch21.xhtml#services" class="calibre10">Chapter 21</a>.</p>
</dd>
<dt class="calibre19">Container runtime</dt>
<dd class="calibre20">
<p class="calibre21">As mentioned earlier, the container runtime is the software responsible for managing containers. Kubernetes can be configured to choose from a range of different container runtime engines. While you can install a container runtime engine on a control plane, it’s not necessary as the control plane node usually doesn’t handle workload. We’ll use a container runtime in <a data-type="xref" href="ch04.xhtml#containers" class="calibre10">Chapter 4</a> to create a container image and run a container with the produced image.</p>
</dd>
</dl>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Advantages" class="praise"><div class="dedication" id="id144">
<h1 class="calibre17">Advantages</h1>

<p class="author1">This chapter points out a couple of advantages of Kubernetes, which are summarized here:</p>
<dl class="calibre18">
<dt class="calibre19">Portability</dt>
<dd class="calibre20">
<p class="calibre21">A container runtime engine can manage a container independent of its runtime environment. The container image bundles everything it needs to work, including the application’s binary or code, its dependencies, and its configuration. Kubernetes can run applications in a container in on-premise and cloud environments. As an administrator, you can choose the platform you think is most suitable to your needs without having to rewrite the application. Many cloud offerings provide product-specific, opt-in features. While using product-specific features helps with operational aspects, be aware that they will diminish your ability to switch easily between platforms.</p>
</dd>
<dt class="calibre19">Resilience</dt>
<dd class="calibre20">
<p class="calibre21">Kubernetes is designed as a declarative state machine. Controllers are reconciliation loops that watch the state of your cluster, then make or request changes where needed. The goal is to move the current cluster state closer to the desired state.</p>
</dd>
<dt class="calibre19">Scalability</dt>
<dd class="calibre20">
<p class="calibre21">Enterprises run applications at scale. Just imagine how many software components retailers like Amazon, Walmart, or Target need to operate to run their businesses. Kubernetes can scale the number of Pods based on demand or automatically according to resource consumption or historical trends.</p>
</dd>
<dt class="calibre19">API based</dt>
<dd class="calibre20">
<p class="calibre21">Kubernetes exposes its functionality through APIs. We learned that every client needs to interact with the API server to manage objects. It is easy to implement a new client that can make RESTful API calls to exposed endpoints.</p>
</dd>
<dt class="calibre19">Extensibility</dt>
<dd class="calibre20">
<p class="calibre21">The API aspect stretches even further. Sometimes, the core functionality of Kubernetes doesn’t fulfill your custom needs, but you can implement your own extensions to Kubernetes. With the help of specific extension points, the Kubernetes community can build custom functionality according to their requirements, e.g., monitoring or logging solutions.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id145">
<h1 class="calibre17">Summary</h1>

<p class="author1">Kubernetes is software for managing containerized applications at scale. Every Kubernetes cluster consists of at least a single control plane node and a worker node. The control plane node is responsible for scheduling the workload and acts as the single entrypoint to manage its functionality. Worker nodes handle the workload assigned to them by the control plane node.</p>

<p class="author1">Kubernetes is a production-ready runtime environment for companies wanting to operate microservice architectures while also supporting nonfunctional requirements like scalability, security, load balancing, and extensibility.</p>

<p class="author1">The next chapter will explain how to interact with a Kubernetes cluster using the command-line tool <code class="calibre15">kubectl</code>. You will learn how run it to manage objects, an essential skill for acing the exam.</p>
</div></section>
</div></section></div></body>
</html>