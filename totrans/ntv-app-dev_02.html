<html><head></head><body><section data-pdf-bookmark="Chapter 1. UI Controllers" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_ui_controllers">&#13;
<h1><span class="label">Chapter 1. </span>UI Controllers</h1>&#13;
&#13;
&#13;
<p>User interface (UI) controllers serve as a connection between your UI and any business logic in your application that controls, or is instructed by, that UI.</p>&#13;
&#13;
<p>If your application were a Shakespearean play put on in some elaborate, Old World theater, the UI controller would play the part of stage manager. It would be ushering actors out to the stage, taking commands from the director, and helping transition between scenes.</p>&#13;
&#13;
<p>Any time you want to display an image, list, or piece of text in an app, you’ll need a UI. The presentation of the UI—how it’s rendered on the screen—is usually controlled by layout instructions (often markup, like XML or HTML); the UI Controller acts as the bridge between input commands, database queries, IPC requests, messages, and much more. In a sense, it’s the heart of any app.</p>&#13;
&#13;
<p>All of this juggling requires an incredibly complex series of events with one technology built on top of another, operating in concert. Fortunately, both Android and iOS have provided some common tools and abstractions to handle the heavy lifting of this process. Let’s learn about some core tasks in this area that are central to both <span class="keep-together">platforms</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177255791256">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="UI (user interface) controllers" data-secondary="task overview" data-type="indexterm" id="idm46177255789896"/> this chapter, you’ll learn:</p>&#13;
<ol>&#13;
<li>&#13;
<p>How to create your app’s starting UI controller.</p>&#13;
</li>&#13;
<li>&#13;
<p>How to change the active UI controller.</p>&#13;
</li>&#13;
<li>&#13;
<p>The UI controller life cycle.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177255785384">&#13;
<h1>Android</h1>&#13;
&#13;
<p>Less<a data-primary="UI (user interface) controllers" data-secondary="Android" data-tertiary="recommended navigation style" data-type="indexterm" id="idm46177255877256"/><a data-primary="Android" data-secondary="UI (user interface) controllers" data-tertiary="recommended navigation style" data-type="indexterm" id="idm46177255875944"/><a data-primary="Activity class" data-secondary="recommended navigation style" data-type="indexterm" id="idm46177255874696"/><a data-primary="Fragment class" data-secondary="recommended navigation style" data-type="indexterm" id="idm46177255873736"/><a data-primary="Navigation component" data-type="indexterm" id="idm46177255872776"/><a data-primary="Jetpack suite" data-secondary="Navigation component" data-type="indexterm" id="idm46177255872104"/> than a year prior to the time of this writing, Google announced that its recommended style of navigation was for an application to use a single <code>Activity</code> instance, and <code>Fragment</code> class instances within that single <code>Activity</code> to represent operations and manage views. The new <code>Navigation</code> component released in the Jetpack suite should be used to manage interactions between fragments and display history.</p>&#13;
&#13;
<p>Note that this goes against recommended practices that have been provided since Android was launched over a decade ago, where an <code>Activity</code> was recommended for any “activity” (roughly approximate to a “screen” or a single web page), and nesting <code>Fragments</code> was intermittently (!) discouraged. In fact, even today the Android dev-docs start the chapter on <code>Activity</code> with this:</p>&#13;
<blockquote>&#13;
<p>An activity is a single, focused thing that the user can do.</p></blockquote>&#13;
&#13;
<p>There are valid arguments for both sides, but since Google is the maintainer of Android, we believe we need to accede to its recommendation going forward. That said, we know there are a <em>lot</em> of legacy apps out in the wild that do not use the pattern and don’t plan on re-architecting several years of work to conform to it. We won’t take a side, so we will show the basics of both approaches. When in doubt, we’ll defer to the prevalent, existing patterns—launching new <code>Activity</code> instances, passing data<a data-primary="Bundle instances" data-type="indexterm" id="idm46177255864360"/> as <code>Bundle</code> instances of primitive information, and managing modular content with <code>Fragment</code> instances and <code>Activity</code> controller methods, rather than the newer <code>Navigation</code> architecture component and its siblings.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How to Create Your App’s Starting UI Controller" data-type="sect2"><div class="sect2" id="idm46177255861752">&#13;
<h2>How to Create Your App’s Starting UI Controller</h2>&#13;
&#13;
<p>Let’s<a data-primary="Android" data-secondary="UI (user interface) controllers" data-tertiary="creating" data-type="indexterm" id="idm46177255859832"/><a data-primary="UI (user interface) controllers" data-secondary="Android" data-tertiary="creating" data-type="indexterm" id="idm46177255858584"/> jump right in. When your app launches, it will perform some initialization logic, during which time you’ll see the “window background” (usually just a solid color, depending on your screen, but this can be set to any valid<a data-primary="Drawable instance" data-type="indexterm" id="idm46177255857032"/> <code>Drawable</code> instance). This work occurs on the main thread and cannot be preempted or interrupted—it’s just going to happen. Note that if you provide<a data-primary="Application class" data-type="indexterm" id="idm46177255855656"/> a custom <code>Application</code> class for your app, anything<a data-primary="Android commands and methods" data-secondary="onCreate" data-type="indexterm" id="idm46177255854408"/> in the <code>onCreate</code> method will happen at this time. Again, it’s extremely important to remember that this is happening on the main (UI) thread, so this will block anything else from happening. However, you’re free to perform asynchronous work on your own background threads at this time.</p>&#13;
&#13;
<p>Once<a data-primary="Activity class" data-secondary="starting UI controller" data-type="indexterm" id="idm46177255852024"/> application initialization is complete, the application will launch a single instance of the <code>Activity</code> class that you defined in your application manifest with the<a data-primary="Android commands and methods" data-secondary="android.intent.category.LAUNCHER" data-type="indexterm" id="idm46177255708216"/> <code>android.intent.category.LAUNCHER</code> value for its category node. This <code>Activity</code> entry should also include an <code>action</code> name equal<a data-primary="Android commands and methods" data-secondary="android.intent.action.MAIN" data-type="indexterm" id="idm46177255705784"/> to <code>android.intent.action.MAIN</code>, which should be present for any of your app’s entry points (e.g., launcher icon, deep link, system-wide broadcast, etc.).</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Remember that you just provide the class’s canonical name, and instantiation, references, and setup are performed in the background automagically (meaning the process is entirely opaque to us as developers or users).</p>&#13;
</div>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;intent-filter&gt;</code>&#13;
  <code class="nt">&lt;action</code> <code class="na">android:name=</code><code class="s">"android.intent.action.MAIN"</code> <code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;category</code> <code class="na">android:name=</code><code class="s">"android.intent.category.LAUNCHER"</code> <code class="nt">/&gt;</code>&#13;
<code class="nt">&lt;/intent-filter&gt;</code></pre>&#13;
&#13;
<p>In a complete manifest, the preceding might look like this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;manifest</code> <code class="na">package=</code><code class="s">"org.oreilly.nmd"</code>&#13;
          <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code><code class="nt">&gt;</code>&#13;
&#13;
  <code class="nt">&lt;application</code>&#13;
      <code class="na">android:allowBackup=</code><code class="s">"false"</code>&#13;
      <code class="na">android:icon=</code><code class="s">"@mipmap/ic_launcher"</code>&#13;
      <code class="na">android:label=</code><code class="s">"@string/app_name"</code>&#13;
      <code class="na">android:roundIcon=</code><code class="s">"@mipmap/ic_launcher_round"</code>&#13;
      <code class="na">android:supportsRtl=</code><code class="s">"true"</code>&#13;
      <code class="na">android:theme=</code><code class="s">"@style/AppTheme"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;activity</code> <code class="na">android:name=</code><code class="s">".MainActivity"</code><code class="nt">&gt;</code>&#13;
      <code class="nt">&lt;intent-filter&gt;</code>&#13;
        <code class="nt">&lt;action</code> <code class="na">android:name=</code><code class="s">"android.intent.action.MAIN"</code> <code class="nt">/&gt;</code>&#13;
        <code class="nt">&lt;action</code> <code class="na">android:name=</code><code class="s">"android.intent.action.VIEW"</code> <code class="nt">/&gt;</code>&#13;
        <code class="nt">&lt;category</code> <code class="na">android:name=</code><code class="s">"android.intent.category.LAUNCHER"</code> <code class="nt">/&gt;</code>&#13;
      <code class="nt">&lt;/intent-filter&gt;</code>&#13;
    <code class="nt">&lt;/activity&gt;</code>&#13;
    <code class="nt">&lt;activity</code> <code class="na">android:name=</code><code class="s">".BrowseContentActivity"</code> <code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;activity</code> <code class="na">android:name=</code><code class="s">".BookDetailActivity"</code> <code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;activity</code> <code class="na">android:name=</code><code class="s">".SearchResultsActivity"</code> <code class="nt">/&gt;</code>&#13;
  <code class="nt">&lt;/application&gt;</code>&#13;
&#13;
<code class="nt">&lt;/manifest&gt;</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note<a data-primary="Activity class" data-secondary="registering in ApplicationManifest.xml" data-type="indexterm" id="idm46177255690024"/> that any <code>Activity</code> you intend to use in your application must be registered in your <em>ApplicationManifest.xml</em> as a child of the <code>application</code> node (<code>manifest</code> → <code>application</code> → all activity nodes). Check the code block immediately following this note.</p>&#13;
</div>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;activity</code> <code class="na">android:name=</code><code class="s">".MyActivity"</code> <code class="nt">/&gt;</code></pre>&#13;
&#13;
<p>While you’re interacting with an Android app, you are always considered to be within an <code>Activity</code> (unless you’re dealing with remote operations like status bar interactions with a <code>Service</code>, but that’s a little too in the weeds for this chapter). You will never have a usable piece of UI that is not within an <code>Activity</code> (the one exception to this is the <code>RemoteViews</code> class—a small, simple subset of <code>View</code> classes—which is available in notification windows).</p>&#13;
&#13;
<p>Note that you cannot nest <code>Activity</code> instances. Generally speaking, a single <code>Activity</code> occupies the entire screen at any one time (or at least, the portion of the screen delegated to your app).</p>&#13;
&#13;
<p>As referenced, remember that we’re not creating a new instance of an <code>Activity</code>; we’re simply supplying the <code>Activity</code> class we want to start. Behind the scenes, the Android framework will generate the instance and perform infrastructure tasks before displaying it to the user. Furthermore, this is an <em>asynchronous</em> operation, and the system will decide exactly when the new <code>Activity</code> starts.</p>&#13;
&#13;
<p>This is also important because of various launch modes that are assigned to <code>Activity</code> classes in your manifest file. A particular launch mode might allow any number of a particular <code>Activity</code> class to exist at any time. For example, you may want to allow the user to have any number of<a data-primary="ComposeEmailActivity instances" data-type="indexterm" id="idm46177252052984"/> <code>ComposeEmailActivity</code> instances in a single task stack. However, you may wish to impose limits on other kinds of <code>Activity</code> classes, like only allowing a single instance of a<a data-primary="LoginActivity" data-type="indexterm" id="idm46177252051128"/> <code>LoginActivity</code>, which might either bring the last used <code>LoginActivity</code> to the top of the task stack or possibly destroy everything between the current <code>Activity</code> and the last used <code>LoginActivity</code>, depending on the launch mode. We won’t do a deep dive on launch modes here, but definitely check out the developer docs on this subject if you’re curious.</p>&#13;
&#13;
<p>So we’ve successfully started an <code>Activity</code>—why is nothing showing up on the screen? Because an <code>Activity</code> is a controller-level class and is not a view itself. In order to render elements on the screen, it needs at least a single <code>View</code> instance, and probably several (as children of the single <code>View</code> used as the <code>Activity</code> root). This is generally done with the <code>setContentView</code> method and passing in an XML layout resource. See <a data-type="xref" href="ch02.html#topics_views">Chapter 2</a>, where we discuss views.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How to Change the Active UI Controller" data-type="sect2"><div class="sect2" id="idm46177255861128">&#13;
<h2>How to Change the Active UI Controller</h2>&#13;
&#13;
<p>Once<a data-primary="Android" data-secondary="UI (user interface) controllers" data-tertiary="changing active" data-type="indexterm" id="idm46177252042184"/><a data-primary="UI (user interface) controllers" data-secondary="Android" data-tertiary="changing active" data-type="indexterm" id="idm46177252040568"/> your initial (“launch”) <code>Activity</code> is presented to the user, you can start any other <code>Activity</code> by calling the<a data-primary="Android commands and methods" data-secondary="startActivity(Intent intent)" data-type="indexterm" id="idm46177252017848"/> <code>startActivity(Intent intent)</code> method from any<a data-primary="Context instance" data-type="indexterm" id="idm46177252016264"/> <code>Context</code> instance (the <code>Activity</code> class inherits from <code>Context</code>, so it has a “is-a” relationship with <code>Context</code>—an <code>Activity</code> instance <em>is</em> a <code>Context</code> instance). The<a data-primary="Java" data-secondary="UI controllers" data-tertiary="changing active UI controller" data-type="indexterm" id="idm46177252012296"/><a data-primary="Kotlin" data-secondary="UI controllers" data-tertiary="changing active UI controller" data-type="indexterm" id="idm46177252010952"/> <code>Intent</code> requires a <code>Context</code> instance as well, as the first parameter, and a reference to the <code>Activity</code> class to launch:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177252041848">&#13;
<h5/>&#13;
<p><em>Java<a data-primary="Java" data-secondary="changing active UI controller" data-type="indexterm" id="idm46177252006632"/></em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// assume we're in the scope of the launcher Activity</code>&#13;
<code class="n">Intent</code> <code class="n">intent</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Intent</code><code class="o">(</code><code class="k">this</code><code class="o">,</code> <code class="n">AnotherActivity</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
<code class="n">startActivity</code><code class="o">(</code><code class="n">intent</code><code class="o">);</code>&#13;
<code class="c1">// if you're not in an activity, but have access to a Context object,</code>&#13;
<code class="c1">// your code might look a little like this...</code>&#13;
<code class="c1">// assume we have a variable "context" that represents a Context object.</code>&#13;
<code class="n">Intent</code> <code class="n">intent</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Intent</code><code class="o">(</code><code class="n">context</code><code class="o">,</code> <code class="n">AnotherActivity</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
<code class="n">context</code><code class="o">.</code><code class="na">startActivity</code><code class="o">(</code><code class="n">intent</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// assume we're in the scope of the launcher Activity</code>&#13;
<code class="k">val</code> <code class="py">intent</code> <code class="p">=</code> <code class="n">Intent</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="n">AnotherActivity</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code><code class="p">)</code>&#13;
<code class="n">startActivity</code><code class="p">(</code><code class="n">intent</code><code class="p">)</code>&#13;
<code class="c1">// if you're not in an activity, but have access to a Context object,</code>&#13;
<code class="c1">// your code might look a little like this...</code>&#13;
<code class="c1">// assume we have a variable "context" that represents a Context object.</code>&#13;
<code class="k">val</code> <code class="py">intent</code> <code class="p">=</code> <code class="n">Intent</code><code class="p">(</code><code class="n">context</code><code class="p">,</code> <code class="n">AnotherActivity</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code><code class="p">)</code>&#13;
<code class="n">context</code><code class="p">.</code><code class="n">startActivity</code><code class="p">(</code><code class="n">intent</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>It’s critical to understand that the system will handle instantiation, initialization, and configuration of <code>Activity</code> classes you’ll show to your user, and they cannot be instantiated with the <code>new</code> keyword or configured or otherwise modified when being started. We send an <code>Intent</code> to the system that indicates what <code>Activity</code> we want to present to the user, and the system does the rest. For this reason, <code>Activity</code> instances cannot be assigned variables or have methods called directly as they are being started (with standard library methods).</p>&#13;
</div>&#13;
&#13;
<p>So<a data-primary="Activity class" data-secondary="passing information to" data-type="indexterm" id="idm46177251733416"/> if we can’t modify variables on an <code>Activity</code> instance or call methods directly on the <code>Activity</code> as we launch it, how do we pass information to it? In many UI frameworks, you can create a new view controller class instance, assign it some data, and allow it to render that data.</p>&#13;
&#13;
<p>In<a data-primary="Java" data-secondary="UI controllers" data-tertiary="attaching primitive values to Intent" data-type="indexterm" id="idm46177251730872"/><a data-primary="Kotlin" data-secondary="UI controllers" data-tertiary="attaching primitive values to Intent" data-type="indexterm" id="idm46177251729624"/> the Android framework, your options are much more limited. The classic approach is to attach primitive values to the <code>Intent</code> object, like so:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177251672296">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// assume we're in the scope of the launcher Activity</code>&#13;
<code class="n">Intent</code> <code class="n">intent</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Intent</code><code class="o">(</code><code class="k">this</code><code class="o">,</code> <code class="n">AnotherActivity</code><code class="o">.</code><code class="na">class</code><code class="o">);</code>&#13;
<code class="n">intent</code><code class="o">.</code><code class="na">putExtra</code><code class="o">(</code><code class="s">"id"</code><code class="o">,</code> <code class="mi">10</code><code class="o">);</code>&#13;
<code class="n">startActivity</code><code class="o">(</code><code class="n">intent</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// assume we're in the scope of the launcher Activity</code>&#13;
<code class="n">Intent</code> <code class="n">intent</code> <code class="p">=</code> <code class="n">Intent</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="n">AnotherActivity</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code><code class="p">);</code>&#13;
<code class="n">intent</code><code class="p">.</code><code class="n">putExtra</code><code class="p">(</code><code class="s">"id"</code><code class="p">,</code> <code class="m">10</code><code class="p">)</code>&#13;
<code class="n">startActivity</code><code class="p">(</code><code class="n">intent</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>The <code>Intent</code> instance<a data-primary="Java" data-secondary="UI controllers" data-tertiary="getIntent method" data-type="indexterm" id="idm46177251584024"/><a data-primary="Kotlin" data-secondary="UI controllers" data-tertiary="getIntent method" data-type="indexterm" id="idm46177251549608"/> that started the <code>Activity</code> is available via the <code>getIntent</code> method:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177251547272">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyActivity</code> <code class="kd">extends</code> <code class="n">Activity</code> <code class="o">{</code>&#13;
 <code class="nd">@Override</code>&#13;
 <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">Bundle</code> <code class="n">savedInstanceState</code><code class="o">)</code> <code class="o">{</code>&#13;
   <code class="kd">super</code><code class="o">.</code><code class="na">onCreate</code><code class="o">(</code><code class="n">savedInstanceState</code><code class="o">);</code>&#13;
   <code class="n">Intent</code> <code class="n">intent</code> <code class="o">=</code> <code class="n">getIntent</code><code class="o">();</code>&#13;
   <code class="kt">int</code> <code class="n">id</code> <code class="o">=</code> <code class="n">intent</code><code class="o">.</code><code class="na">getIntExtra</code><code class="o">(</code><code class="s">"id"</code><code class="o">,</code> <code class="mi">0</code><code class="o">);</code>&#13;
   <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"id: "</code> <code class="o">+</code> <code class="n">id</code><code class="o">);</code>&#13;
 <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyActivity</code> <code class="p">:</code> <code class="n">Activity</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">id</code> <code class="p">=</code> <code class="n">intent</code><code class="p">.</code><code class="n">getIntExtra</code><code class="p">(</code><code class="s">"id"</code><code class="p">,</code> <code class="m">0</code><code class="p">)</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"id: $id"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>This is perfectly fine for passing small, primitive data like an identifier or URL but is not appropriate for large data (like serialized Java classes or even large <code>Strings</code> like JSON representing complex class instances). That data is contained within a particular system-level data store that is capped at 1 MB and can be shared among any process on the device. From the documentation for the <code>Bundle</code> API:</p>&#13;
<blockquote>&#13;
<p>The Binder transaction buffer has a limited fixed size, currently 1MB, which is shared by all transactions in progress for the process. Since this limit is at the process level rather than at the per activity level, these transactions include all binder transactions in the app such as onSaveInstanceState, startActivity and any interaction with the system.</p></blockquote>&#13;
&#13;
<p>To pass complex information to a newly created <code>Activity</code> requires either saving that information to disk before starting the new <code>Activity</code>, to be read back out once that <code>Activity</code> has been created, or passing a reference to a “globally reachable” data structure. This is often simple a class-level variable (<code>static</code>), but there are drawbacks to using <code>static</code> variables in this case. Android engineers have previously endorsed a <code>Map</code> of <code>WeakReferences</code> as a static member on a utility class, or you might find the <code>Application</code> instance (which is always accessible from any <code>Context</code> instance via <code>Context.getApplicationContext</code>) to be a little cleaner. It’s important to note that as long as your application is running, the <code>Application</code> instance will be reachable, which some would argue means it could never meet the traditional definition of a memory leak. In<a data-primary="Kotlin" data-secondary="UI controllers" data-tertiary="global contextuality" data-type="indexterm" id="idm46177251376488"/> Kotlin, global contextuality is handled a little differently, but generally speaking, the warnings about passing information still apply.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fragments" data-type="sect3"><div class="sect3" id="idm46177251381640">&#13;
<h3>Fragments</h3>&#13;
&#13;
<p>A<a data-primary="Fragment class" data-secondary="versus Activity" data-secondary-sortas="Activity" data-type="indexterm" id="idm46177251373160"/><a data-primary="Activity class" data-secondary="versus Fragments" data-secondary-sortas="Fragments" data-type="indexterm" id="idm46177251371880"/> <code>Fragment</code>, in Android framework parlance, is kind of a lightweight <code>Activity</code>; it can be thought of as a <em>controller</em> for a view, rather than a view itself, but it must have a root view delegation (in Android, the role of the “view” pattern implementer from<a data-primary="Model-View-Presenter (MVP)" data-type="indexterm" id="idm46177251369128"/> Model-View-Presenter [MVP], Model-View-Controller [MVC], <a data-primary="Model-View-ViewModel (MVVM)" data-type="indexterm" id="idm46177251368328"/>Model-View-ViewModel [MVVM], etc., is filled by the <code>View</code> class, which is usually an atomic visual element, like a piece of text, an image, or a container of other <code>View</code> instances; see <a data-type="xref" href="ch02.html#topics_views">Chapter 2</a> where views are discussed in more detail).</p>&#13;
&#13;
<p>The nice thing about <code>Fragments</code>, compared to <code>Activities</code>, is that we can instantiate them directly with custom constructor signatures, configurations, member and method access, etc. We create <code>Fragment</code> instances like we would any other class instance in <code>Java</code>. In addition, <code>Fragments</code>, unlike <code>Activities</code>, <em>can</em> be nested—however, there has historically been some unreliability around that, and more specifically around life-cycle callbacks, but that too is really out of scope for this chapter. Google “android fragment controversy” and you’ll find plenty of material on the topic. Again, this book chooses to remain neutral in this senseless, bloody feud.</p>&#13;
&#13;
<p>So you<a data-primary="Kotlin" data-secondary="UI controllers" data-tertiary="creating Fragment class" data-type="indexterm" id="idm46177251361272"/><a data-primary="Java" data-secondary="UI controllers" data-tertiary="creating Fragment class" data-type="indexterm" id="idm46177251359992"/><a data-primary="Fragment class" data-secondary="creating" data-type="indexterm" id="idm46177251358776"/> create a <code>Fragment</code> like anything else:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177251357160">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyFragment</code> <code class="kd">extends</code> <code class="n">Fragment</code> <code class="o">{</code>&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="n">View</code> <code class="nf">onCreateView</code><code class="o">(</code><code class="n">LayoutInflater</code> <code class="n">inflater</code><code class="o">,</code> <code class="n">ViewGroup</code> <code class="n">container</code><code class="o">,</code>&#13;
    <code class="n">Bundle</code> <code class="n">savedInstanceState</code><code class="o">)</code> <code class="o">{</code>&#13;
   <code class="k">return</code> <code class="n">inflater</code><code class="o">.</code><code class="na">inflate</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">layout</code><code class="o">.</code><code class="na">my_layout</code><code class="o">,</code> <code class="n">container</code><code class="o">,</code> <code class="kc">false</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyFragment</code> <code class="p">:</code> <code class="n">Fragment</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreateView</code><code class="p">(</code><code class="n">inflater</code><code class="p">:</code> <code class="n">LayoutInflater</code><code class="p">,</code> <code class="n">container</code><code class="p">:</code> <code class="n">ViewGroup</code><code class="p">?,</code>&#13;
    <code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">):</code> <code class="n">View</code><code class="p">?</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">inflater</code><code class="p">.</code><code class="n">inflate</code><code class="p">(</code><code class="n">R</code><code class="p">.</code><code class="n">layout</code><code class="p">.</code><code class="n">my_layout</code><code class="p">,</code> <code class="n">container</code><code class="p">,</code> <code class="k">false</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Ideally, you<a data-primary="Fragment class" data-secondary="adding to layout XML" data-type="indexterm" id="idm46177251270952"/> can add your <code>Fragment</code> to your layout XML like you would any <code>View</code>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</code>&#13;
<code class="nt">&lt;LinearLayout</code> <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
    <code class="na">android:layout_width=</code><code class="s">"match_parent"</code>&#13;
    <code class="na">android:layout_height=</code><code class="s">"match_parent"</code><code class="nt">&gt;</code>&#13;
    <code class="nt">&lt;fragment</code> <code class="na">android:name=</code><code class="s">".ListFragment"</code>&#13;
            <code class="na">android:layout_width=</code><code class="s">"200dp"</code>&#13;
            <code class="na">android:layout_height=</code><code class="s">"match_parent"</code> <code class="nt">/&gt;</code>&#13;
    <code class="nt">&lt;fragment</code> <code class="na">android:name=</code><code class="s">".DetailFragment"</code>&#13;
            <code class="na">android:layout_weight=</code><code class="s">"1"</code>&#13;
            <code class="na">android:layout_width=</code><code class="s">"0dp"</code>&#13;
            <code class="na">android:layout_height=</code><code class="s">"match_parent"</code> <code class="nt">/&gt;</code>&#13;
<code class="nt">&lt;/LinearLayout&gt;</code></pre>&#13;
&#13;
<p>However, we<a data-primary="Fragment class" data-secondary="configuring programatically" data-type="indexterm" id="idm46177251214216"/> are faced again with system-level, opaque instantiation. In order to configure a custom <code>Fragment</code> class programmatically, you’ll need to instantiate it with the <code>new</code> keyword and use a <code>FragmentManager</code> and a <code>FragmentTransaction</code> to add it to the existing view hierarchy.</p>&#13;
&#13;
<p>Note you could have a custom constructor with configuration parameters here if you so choose, although when the <code>Fragment</code> is reconstructed, it will lose constructor arguments, so Android suggests developers use no-arg constructors and assume <code>Fragment</code> instances may be created with the <code>Class.newInstance</code> method.</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177251144376">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Fragment</code> <code class="n">fragment</code> <code class="o">=</code> <code class="k">new</code> <code class="n">MyFragment</code><code class="o">();</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">fragment</code> <code class="p">=</code> <code class="n">MyFragment</code><code class="p">()</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>From this point, since a <code>Fragment</code> is not a <code>View</code> itself, but rather a view or UI controller, it must be instructed to render using a specific <code>View</code> or <code>View</code> tree. It’s common to use a single, empty container <code>ViewGroup</code> like a <code>FrameLayout</code> to hold the <code>View</code> instances that represent <code>Fragment</code> instances.</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177251070536">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">FragmentTransaction</code> <code class="n">transaction</code> <code class="o">=</code> <code class="n">getSupportFragmentManager</code><code class="o">().</code><code class="na">beginTransaction</code><code class="o">();</code>&#13;
<code class="n">transaction</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">id</code><code class="o">.</code><code class="na">my_view_group</code><code class="o">,</code> <code class="n">fragment</code><code class="o">);</code>&#13;
<code class="n">transaction</code><code class="o">.</code><code class="na">commit</code><code class="o">();</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">transaction</code> <code class="p">=</code> <code class="n">supportFragmentManager</code><code class="p">.</code><code class="n">beginTransaction</code><code class="p">()</code>&#13;
<code class="n">transaction</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">R</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="n">my_view_group</code><code class="p">,</code> <code class="n">fragment</code><code class="p">)</code>&#13;
<code class="n">transaction</code><code class="p">.</code><code class="n">commit</code><code class="p">()</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>The <code>FragmentTransaction</code> is<a data-primary="Kotlin" data-secondary="UI controllers" data-tertiary="Fragment update tasks" data-type="indexterm" id="idm46177251017832"/><a data-primary="Java" data-secondary="UI controllers" data-tertiary="Fragment update tasks" data-type="indexterm" id="idm46177251016648"/> able to perform a variety of update tasks for any <span class="keep-together"><code>Fragment</code></span> instances you have references to. Generally, open a transaction, make all the atomic changes you want, and then <code>commit</code> the transaction:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177251028248">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">FragmentTransaction</code> <code class="n">transaction</code> <code class="o">=</code> <code class="n">getSupportFragmentManager</code><code class="o">().</code><code class="na">beginTransaction</code><code class="o">();</code>&#13;
<code class="c1">//transaction.add(R.id.my_layout, fragment);</code>&#13;
<code class="c1">//transaction.replace(R.id.my_layout, anotherFragment);</code>&#13;
<code class="c1">//transaction.remove(fragment);</code>&#13;
<code class="c1">//transaction.detach(fragment);</code>&#13;
<code class="c1">//transaction.attach(fragment);</code>&#13;
<code class="c1">//transaction.hide(fragment);</code>&#13;
<code class="c1">//transaction.show(fragment);</code>&#13;
<code class="n">transaction</code><code class="o">.</code><code class="na">commit</code><code class="o">();</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">transaction</code> <code class="p">=</code> <code class="n">supportFragmentManager</code><code class="p">.</code><code class="n">beginTransaction</code><code class="p">()</code>&#13;
<code class="c1">//transaction.add(R.id.my_layout, fragment)</code>&#13;
<code class="c1">//transaction.replace(R.id.my_layout, anotherFragment)</code>&#13;
<code class="c1">//transaction.remove(fragment)</code>&#13;
<code class="c1">//transaction.detach(fragment)</code>&#13;
<code class="c1">//transaction.attach(fragment)</code>&#13;
<code class="c1">//transaction.hide(fragment)</code>&#13;
<code class="c1">//transaction.show(fragment)</code>&#13;
<code class="n">transaction</code><code class="p">.</code><code class="n">commit</code><code class="p">()</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Unlike <code>Activity</code>, the <code>Fragment</code> class does not extend <code>Context</code> and so loses direct access to many APIs; however, <code>Fragment</code> instances do have both a <code>getContext</code> and a <code>getActivity</code> method, so in most cases you’re just one lookup away.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of this writing, while the <code>Navigation</code> component is stable, some associated features (like the Navigation Editor UI) are not. There is some controversy about including UI code generation tools as future-proof Android tools. That said, the <code>Navigation</code> component is capable of handling <code>Fragment</code> actions like the preceding without traditional <code>FragmentTransaction</code>s or <code>FragmentManager</code>s.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding the UI Controller Life Cycle" data-type="sect2"><div class="sect2" id="idm46177252043384">&#13;
<h2>Understanding the UI Controller Life Cycle</h2>&#13;
&#13;
<p>As<a data-primary="Android" data-secondary="UI (user interface) controllers" data-tertiary="controller life cycle" data-type="indexterm" id="idm46177250889176"/><a data-primary="UI (user interface) controllers" data-secondary="Android" data-tertiary="controller life cycle" data-type="indexterm" id="idm46177250887928"/> UI controllers travel through various states from inception through termination, a number of life-cycle callbacks are called and can be a great place to hook into application events. Both<a data-primary="Activity class" data-secondary="life-cycle events" data-type="indexterm" id="idm46177250886360"/><a data-primary="Fragment class" data-secondary="life-cycle events" data-type="indexterm" id="idm46177250885416"/> <code>Activity</code> and <code>Fragment</code> classes have life-cycle events (in fact, so do <code>View</code> instances, but those are rather limited and outside the scope of this chapter).</p>&#13;
&#13;
<p>There’s a <a href="https://oreil.ly/LW_u1">well-known diagram</a> describing the <code>Activity</code> life cycle that has a tremendously detailed write-up, but we’ll go over the critical points now.</p>&#13;
&#13;
<p><a data-type="xref" href="#activity_lifecycle">Figure 1-1</a> presents a copy of that diagram as a baseline.</p>&#13;
&#13;
<p>When<a data-primary="Android commands and methods" data-secondary="onCreate" data-type="indexterm" id="idm46177250879864"/> an <code>Activity</code> is first created, the <code>onCreate</code> method is called.</p>&#13;
&#13;
<p><em>It is critical to understand that</em> <code>onCreate</code> <em>is</em> also <em>called when an</em> <code>Activity</code> <em>is re-created.</em> Occasionally, an app’s resources will be reclaimed by the system for other use; in this case, your app is completely destroyed behind the scenes, with some primitive values about the current state saved on the local disk.</p>&#13;
&#13;
<p>When an <code>Activity</code> is first created, the single method parameter—a <code>Bundle</code>—will be <code>null</code>. If it is being re-created after resource reclamation (as happens during a “configuration change,” like rotating the device or plugging in a new display), the value passed to the <code>onCreate</code> method will be a nonnull <code>Bundle</code> instance.</p>&#13;
&#13;
<p><code>onStart</code> is<a data-primary="Android commands and methods" data-secondary="onStart" data-type="indexterm" id="idm46177250870728"/> called when the <code>Activity</code> becomes visible to the user, after being not visible (for example, when behind another <code>Activity</code>). <code>onStart</code> will always follow <code>onCreate</code>, but not all <code>onStart</code> events are preceded by an <code>onCreate</code> event.</p>&#13;
&#13;
<p><code>onResume</code> <a data-primary="Android commands and methods" data-secondary="onResume" data-type="indexterm" id="idm46177250848424"/>is called any time an <code>Activity</code> regains focus. An <code>Activity</code> can lose focus if the containing app is minimized, or anything else takes the foreground, whether that’s another app, a phone call, or even a <code>Dialog</code> overlaying the <code>Activity</code>’s content, despite much of that content still being visible.  When that focus is regained—by closing the other app, hanging up the phone call, or dismissing the <code>Dialog</code>—<code>onResume</code> will fire. <code>onResume</code> will always follow an <code>onStart</code>, but not all <code>onResume</code> events are preceded by <code>onStart</code> events.</p>&#13;
&#13;
<figure><div class="figure" id="activity_lifecycle">&#13;
<img alt="Activity Lifecycle" src="assets/nmdv_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>Activity life cycle</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now let’s start down the other trail, to destruction.</p>&#13;
&#13;
<p><code>onPause</code> is<a data-primary="Android commands and methods" data-secondary="onPause" data-type="indexterm" id="idm46177250839800"/> called any time the <code>Activity</code> loses focus (see <code>onResume</code>).</p>&#13;
&#13;
<p><code>onStop</code> is<a data-primary="Android commands and methods" data-secondary="onStop" data-type="indexterm" id="idm46177250836616"/> a tricky one, and one that’s often misrepresented in casual conversation. <code>onStop</code> is effectively called when an <code>Activity</code> is destroyed but can be re-created—for example, if the system reclaims your app’s resources. An <code>onStop</code> will be followed by either an <code>onDestroy</code> event (see the following) or an <code>onRestart</code> event, which means the <code>Activity</code> is being rebuilt from saved “hints” after it has been stopped. All <code>onStop</code> events are preceded by <code>onPause</code>, but not all <code>onPause</code> events are followed by an <code>onStop</code>. See <a href="https://oreil.ly/POytI">the documentation on this particular event</a> if you’re interested. Here’s a relevant piece directly from that source:</p>&#13;
<blockquote>&#13;
<p>When your activity is no longer visible to the user, it has entered the <em>Stopped</em> state, and the system invokes the <code>onStop()</code> callback. This may occur, for example, when a newly launched activity covers the entire screen. The system may also call <code>onStop()</code> when the activity has finished running, and is about to be terminated.</p></blockquote>&#13;
&#13;
<p><code>onDestroy</code> <a data-primary="onDestroy method" data-type="indexterm" id="idm46177250827432"/>fires when the <code>Activity</code> is about to be terminated (gracefully) and cannot be re-created. If you tap back out of an <code>Activity</code>, it will call <code>onDestroy</code>. This is a great opportunity for cleanup. All <code>onDestroy</code> events are preceded by <code>onStop</code>, but not all <code>onStop</code> events are followed by <code>onDestroy</code>.</p>&#13;
&#13;
<p>The documentation clearly states that you cannot count on <code>onDestroy</code> to fire to clean up large objects or asynchronous operations. This is true, but it’s often interpreted to mean that you <em>can</em> count on <code>onStop</code> or <code>onPause</code>, which is no more true. Imagine that your device gets run over by a truck (or, more likely, the battery dies). Your app is going to shut down immediately, without any chance to fire callbacks or perform cleanup operations. You’re no safer doing this kind of work in <code>onPause</code> than you are in <code>onDestroy</code>. That said, since <code>onDestroy</code> generally means that the <code>Activity</code> is going to become unreachable and eligible for garbage collection, it often doesn’t matter—you don’t need to worry about cleaning up something that’s about to be nuked.</p>&#13;
&#13;
<p>The <code>Fragment</code> life cycle is very similar but includes callbacks for <code>onCreateView</code> (which is critical—the return of this method must return a <code>View</code> instance in order for the <code>Fragment</code> to have a visible UI) and <code>onDestroyView</code>. There’s also a callback for <code>onActivityCreated</code>, and callbacks that fire when a <code>Fragment</code> is added (<code>onAttached</code>) to, or removed from (<code>onDetached</code>), the UI using <code>FragmentTransaction</code> methods.</p>&#13;
&#13;
<p>Note that the <code>Fragment</code>, <code>FragmentManager</code>, and <code>FragmentTransaction</code> classes have changed between OS releases. For consistency, and to make sure you’re always dealing with the latest release, we recommend using the support library classes. For <em>most</em> uses, they are interchangeable—just import <code>android.support.v4.app.Fragment</code> rather than <code>android.app.Fragment</code>; when you call <code>new Fragment();</code>, you’ll get a <code>Fragment</code> from the support library package. Similarly, use <code>android.support.v7.app.AppCompatActivity</code> rather than <code>android.app.Activity</code>, which will have a <code>getSupportFragmentManager</code> method, which will provide updated APIs to use with support library <code>Fragments</code>.</p>&#13;
&#13;
<p>In addition, the AndroidX<a data-primary="AndroidX" data-type="indexterm" id="idm46177250807400"/> version of identical classes (and some new ones) is available as well, but in reality even after a year is not entirely stable (although it does have multiple released marked “stable”). The Jetpack<a data-primary="Jetpack suite" data-secondary="pros and cons of" data-type="indexterm" id="idm46177250806312"/> libraries can serve a lot of these same functions, and in new projects Google encourages their use where possible, but let’s keep in mind that greenfield development is much rarer than maintenance. Feel free to explore these alternatives and see what works best for you and your team; we (the authors) have opted to use the libraries and toolsets we have simply because that’s what currently powers the majority of these features. That’s sure to change in time, and as with any technology, it’s almost a full-time job keeping up to date with best and recommended practices.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177250890408">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>UIKit, the<a data-primary="UI (user interface) controllers" data-secondary="iOS" data-tertiary="UIKit" data-type="indexterm" id="idm46177250803112"/><a data-primary="UIKit" data-secondary="UIViewController" data-type="indexterm" id="idm46177250801864"/> UI framework that almost all iOS apps rely on, is rooted in an MVC architecture. In iOS, the UI controller, or “C,” part of this framework refers, more specifically, to <code>UIViewController</code>. Within a typical app, there are a number of <code>UIViewController</code> instances and subclasses linked together to manage the behavior and hierarchy of the objects they control: views.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How to Create Your App’s Starting UI Controller" data-type="sect2"><div class="sect2" id="idm46177250799544">&#13;
<h2>How to Create Your App’s Starting UI Controller</h2>&#13;
&#13;
<p>Before we get into the details of actually creating the app’s initial UI controller, we need to discuss views, windows, controllers, and how they relate to the functionality we’re about to cover.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Views and UI Controllers" data-type="sect3"><div class="sect3" id="idm46177250797672">&#13;
<h3>Views and UI Controllers</h3>&#13;
&#13;
<p>Views<a data-primary="UI (user interface) controllers" data-secondary="iOS" data-tertiary="creating" data-type="indexterm" id="idm46177250796136"/><a data-primary="iOS" data-secondary="UI (user interface) controllers" data-tertiary="creating" data-type="indexterm" id="idm46177250794520"/> and <code>UIViewController</code>s are inextricably linked in iOS, such that discussing one necessitates some discussion of the other. Now, views are covered in greater depth in <a data-type="xref" href="ch02.html#topics_views">Chapter 2</a>, but they’re important to note here because the root of an app’s view controller hierarchy starts on a single property of a specialized view: the app’s window, an<a data-primary="UIKit" data-secondary="UIWindow class" data-type="indexterm" id="idm46177250791560"/> instance of <code>UIWindow</code>. Every iOS application has a single <code>UIWindow</code> instance that the <code>UIApplication</code> presents. The property where the<a data-primary="rootViewController property" data-type="indexterm" id="idm46177250789160"/> root view controller lives is the aptly named <code>rootViewController</code>. Setting the <code>rootViewController</code> of a <code>UIWindow</code> to a defined view controller can be done in one line:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">window</code><code class="p">.</code><code class="n">rootViewController</code> <code class="p">=</code> <code class="n">viewController</code></pre>&#13;
&#13;
<p>When the root view controller is set this way, it is almost always done during an application’s launch, usually within <code>application(_:didFinishLaunchingWithOptions:)</code>. However, going into Xcode and creating a new Single View Application project will create an application delegate that has the following code within the same method:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">application</code><code class="p">(</code><code class="kc">_</code> <code class="n">application</code><code class="p">:</code> <code class="bp">UIApplication</code><code class="p">,</code>&#13;
  <code class="n">didFinishLaunchingWithOptions</code> <code class="n">launchOptions</code><code class="p">:</code> <code class="p">[</code><code class="bp">UIApplication</code><code class="p">.</code><code class="n">LaunchOptionsKey</code><code class="p">:</code> <code class="nb">Any</code><code class="p">]?)</code> <code class="p">-&gt;</code>&#13;
  <code class="nb">Bool</code> <code class="p">{</code>&#13;
    <code class="c1">// Override point for customization after application launch</code>&#13;
    <code class="k">return</code> <code class="kc">true</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice that nowhere in that method body is the <code>rootViewController</code> property set. In fact, there isn’t even a mention of a <code>UIWindow</code>—only a <code>true</code> return value. And yet, the application launches and displays a view controller created within a storyboard and seemingly never linked to or set anywhere. How very mysterious.</p>&#13;
&#13;
<p>Xcode isn’t magic, so what’s going on here? Well, if you look closer at some other important files within this sample Xcode project, the mystery reveals itself fairly quickly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The hunt begins" data-type="sect3"><div class="sect3" id="idm46177250778632">&#13;
<h3>The hunt begins</h3>&#13;
&#13;
<p>First, let’s<a data-primary="Info.plist file" data-type="indexterm" id="idm46177250776904"/> start our detective work in a file within the project named <em>Info.plist</em>. This is a special file that is set within the Xcode project settings. It provides configuration values for our app via known XML keys. Within this file, there is a value for a property defined like so:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;key&gt;</code>UIMainStoryboardFile<code class="nt">&lt;/key&gt;</code>&#13;
<code class="nt">&lt;string&gt;</code>Main<code class="nt">&lt;/string&gt;</code></pre>&#13;
&#13;
<p>The <code>key</code> for<a data-primary="UIKit" data-secondary="UIMainStoryboardFile" data-type="indexterm" id="idm46177244895224"/> this property, <code>UIMainStoryboardFile</code>, indicates the storyboard filename the application should use when it’s starting up. The value given to this property is <code>Main</code>, which just happens to map to a file within this sample project named <em>Main.storyboard</em>. Let’s continue our hunt for clues with that file.</p>&#13;
&#13;
<p>If we open up <em>Main.storyboard</em> in the visual editor within Xcode, we’ll see a single scene with a large arrow pointing toward it. Each<a data-primary="UIKit" data-secondary="UIViewController" data-type="indexterm" id="idm46177250691832"/><a data-primary="storyboards" data-secondary="UIViewController class and" data-type="indexterm" id="idm46177250690856"/> scene in a storyboard is mapped to a <code>UIViewController</code> that is set within the Identity inspector on the righthand side of the screen. This is, by default, just a standard <code>UIViewController</code> instance, but by using the inspector it can be set to a custom subclass by typing the name of the subclass into the <code>Class</code> field. Our sample project has its custom class set to “ViewController,” which is a subclass defined in the project inside of <em>ViewController.swift</em> (<a data-type="xref" href="#topics_ui_controllers_xcode_storyboard">Figure 1-2</a>).</p>&#13;
&#13;
<p>Now, about the large arrow on the left of the view controller scene: this just happens to be the “smoking gun” in our root view controller search. In the Attributes inspector within Xcode, there is a checkbox labeled “Is Initial View Controller” that is currently checked on our view controller scene. Unchecking this box makes the large arrow disappear. Build and run the app with the checkbox unchecked and you’ll get some warnings and the following error in Xcode’s console:</p>&#13;
&#13;
<pre data-type="programlisting">Failed to instantiate the default view controller&#13;
    for UIMainStoryboardFile 'Main' - perhaps the designated entry point is not&#13;
    set?</pre>&#13;
&#13;
<p>Success! We’ve found the source of our root view controller. But, how does this all string together to add our root view controller to the app’s window?</p>&#13;
&#13;
<p>Well, on startup, the app looks for the <code>UIMainStoryboardFile</code> key within its <em>Info.plist</em> file. Inside the main storyboard file, the view controller scene that’s been set via our checkbox as our initial view controller is instantiated for the subclass given. Because it’s the initial view controller in the main storyboard, the application adds this view controller to the app window’s <code>rootViewController</code> property and voila! The app now has a root view controller that is displayed and active.</p>&#13;
&#13;
<figure><div class="figure" id="topics_ui_controllers_xcode_storyboard">&#13;
<img alt="The Storyboard Editor in Xcode" src="assets/nmdv_0102.png"/>&#13;
<h6><span class="label">Figure 1-2. </span>Storyboard editor in Xcode</h6>&#13;
</div></figure>&#13;
&#13;
<p>You could, if you desired, achieve the same result with the following code inside the application delegate:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">application</code><code class="p">(</code><code class="kc">_</code> <code class="n">application</code><code class="p">:</code> <code class="bp">UIApplication</code><code class="p">,</code>&#13;
  <code class="n">didFinishLaunchingWithOptions</code> <code class="n">launchOptions</code><code class="p">:</code> <code class="p">[</code><code class="bp">UIApplication</code><code class="p">.</code><code class="n">LaunchOptionsKey</code><code class="p">:</code> <code class="nb">Any</code><code class="p">]?)</code> <code class="p">-&gt;</code>&#13;
  <code class="nb">Bool</code> <code class="p">{</code>&#13;
    <code class="n">window</code> <code class="p">=</code> <code class="bp">UIWindow</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="bp">UIScreen</code><code class="p">.</code><code class="n">main</code><code class="p">.</code><code class="n">bounds</code><code class="p">)</code>&#13;
    <code class="n">window</code><code class="p">?.</code><code class="n">rootViewController</code> <code class="p">=</code> <code class="bp">UIStoryboard</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"Main"</code><code class="p">,</code> <code class="n">bundle</code><code class="p">:</code> <code class="kc">nil</code><code class="p">).</code>&#13;
                                   <code class="n">instantiateInitialViewController</code><code class="p">()</code>&#13;
    <code class="n">window</code><code class="p">?.</code><code class="n">makeKeyAndVisible</code><code class="p">()</code>&#13;
    <code class="k">return</code> <code class="kc">true</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s walk through this.</p>&#13;
&#13;
<p>First, we set the <code>window</code> variable that’s defined as part of the <code>UIApplicationDelegate</code> protocol to a <code>UIWindow</code> instance that is the same size as the device’s main, and most likely only, screen via <code>UIScreen.main.bounds</code>. Next, the root view controller on our window object is set to a view controller. This could be any view controller we have, but in our example, we’re using the initial view controller defined in the <code>Main.storyboard</code> file; this is done by calling the <code>instantiateInitialViewController()</code> method on our <code>UIStoryboard</code> object.</p>&#13;
&#13;
<p>Finally, we show this window by<a data-primary="iOS methods" data-secondary="makeKeyAndVisible()" data-type="indexterm" id="idm46177244717416"/> calling <code>makeKeyAndVisible()</code>. This method takes the window object and makes it the primary window of the application, displacing any other windows currently displayed.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Generally speaking, iOS apps display only one window at a time, but this is not <em>always</em> the case. Apps that need to output video to another screen might need need more than one window; a Keynote-like app is a good example of when this might necessary. However, consider this the exception to the rule, not the default.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code versus storyboard" data-type="sect3"><div class="sect3" id="idm46177250778008">&#13;
<h3>Code versus storyboard</h3>&#13;
&#13;
<p>Now, the<a data-primary="storyboards" data-secondary="versus code" data-secondary-sortas="code" data-type="indexterm" id="idm46177244712648"/><a data-primary="Info.plist file" data-type="indexterm" id="idm46177244711368"/> recommended approach for any simple app is to stick with configuration via <em>Info.plist</em> and the main storyboard detailed earlier. However, as an app gets more and more complex, it could become necessary, or convenient, to dive directly into the code. It’s also possible that you might <em>prefer</em> the codebase over storyboard configuration. There isn’t really a truly “right” way to set up your application’s starting UI controller; it’ll come down to personal preference and the requirements of the project.</p>&#13;
&#13;
<p>Quickly, however, an application with a only single UI controller is going to become pretty limiting or incredibly complex. Let’s look at how UI controllers switch out which view is currently displayed and provide a richer experience for the app.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How to Change the Active UI Controller" data-type="sect2"><div class="sect2" id="idm46177244708360">&#13;
<h2>How to Change the Active UI Controller</h2>&#13;
&#13;
<p>There<a data-primary="iOS" data-secondary="UI (user interface) controllers" data-tertiary="changing active" data-type="indexterm" id="idm46177244707064"/><a data-primary="UI (user interface) controllers" data-secondary="iOS" data-tertiary="changing active" data-type="indexterm" id="idm46177244705768"/> are a number of different ways to switch active UI controllers in iOS, some directly in code and some code-free transitions wired up through “segues” in the storyboard editor. More than likely, you’ll encounter both approaches in the wild, often within the same codebase. Let’s start with the code first, because it’ll help understand what’s happening under the scenes and provide better context for understanding the magic of segues.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="It’s showtime!" data-type="sect3"><div class="sect3" id="idm46177244703816">&#13;
<h3>It’s showtime!</h3>&#13;
&#13;
<p>Let’s<a data-primary="iOS methods" data-secondary="show(_:sender:)" data-type="indexterm" id="idm46177244701896"/> say we have two view controllers: one named <code>primaryViewController</code> and another named <code>secondaryViewController</code>. In this example, our currently active view controller is <code>primaryViewController</code>. To present <code>secondaryViewController</code> to the user, the simplest method would be an inherited method on <code>UIViewController</code> named <code>show(_:sender:)</code>. Let’s do this in the code that follows:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// Create the view controllers</code>&#13;
<code class="kd">let</code> <code class="nv">primaryViewController</code> <code class="p">=</code> <code class="p">...</code>&#13;
<code class="kd">let</code> <code class="nv">secondaryViewController</code> <code class="p">=</code> <code class="p">...</code>&#13;
&#13;
<code class="c1">// Present the secondary view controller as the active view controller</code>&#13;
<code class="n">primaryViewController</code><code class="p">.</code><code class="n">show</code><code class="p">(</code><code class="n">secondaryViewController</code><code class="p">,</code> <code class="n">sender</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code></pre>&#13;
&#13;
<p>In this simple example, invoking the <code>show(_:sender:)</code> method would probably cause <code>secondaryViewController</code> to be presented modally from the bottom of the screen in front of <code>primaryViewController</code>. However, a key word in that previous sentence was “probably.” We don’t know with 100% certainty without more context—<code>show(_:sender:)</code> decouples the process of presenting the view controller from the view controller that is calling for the presentation. This is powerful and leads to simpler logic most of the time. For example, consider the following code that doesn’t use <code>show(_:sender:)</code>:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">primaryViewController</code> <code class="p">=</code> <code class="bp">UIViewController</code><code class="p">(</code><code class="n">nibName</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">bundle</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nv">secondaryViewController</code> <code class="p">=</code> <code class="bp">UIViewController</code><code class="p">(</code><code class="n">nibName</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">bundle</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Add the primary view controller to a navigation controller</code>&#13;
<code class="kd">let</code> <code class="nv">_</code> <code class="p">=</code> <code class="bp">UINavigationController</code><code class="p">(</code><code class="n">rootViewController</code><code class="p">:</code> <code class="n">primaryViewController</code><code class="p">)</code>&#13;
&#13;
<code class="p">...</code>&#13;
&#13;
<code class="c1">// Check if the view controller is part of a navigation controller</code>&#13;
<code class="k">if</code> <code class="kd">let</code> <code class="nv">navigationController</code> <code class="p">=</code> <code class="n">primaryViewController</code><code class="p">.</code><code class="n">navigationController</code> <code class="p">{</code>&#13;
    <code class="c1">// Push the view controller onto the navigation stack</code>&#13;
    <code class="n">navigationController</code><code class="p">.</code><code class="n">pushViewController</code><code class="p">(</code><code class="n">secondaryViewController</code><code class="p">,</code> <code class="n">animated</code><code class="p">:</code> <code class="kc">true</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="c1">// Present the view controller modally because no navigation stack exists</code>&#13;
    <code class="n">primaryViewController</code><code class="p">.</code><code class="n">present</code><code class="p">(</code><code class="n">secondaryViewController</code><code class="p">,</code> <code class="n">animated</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code> <code class="n">completion</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The<a data-primary="UIKit" data-secondary="UINavigationController" data-type="indexterm" id="idm46177244620696"/> first thing you might notice is that we’ve introduced a new class: <code>UINavigationController</code>. This is a common class in iOS that helps manage a stack of view controllers; usually pushing onto or popping off a navigation controller’s stack is demonstrated in the app with a sideways transition from the right or left of the application. This is arguably the most common type of active view controller transition in iOS, possibly only behind a tab bar controller. In our preceding example, <code>primaryViewController</code> is added at the root of the navigation stack on the <code>UINavigationController</code> at instantiation.</p>&#13;
&#13;
<p>As shown in our <code>show</code>-less example let’s say we wanted to add a new view controller to the stack of view controllers and make it the active view controller. First, we’d have to check if the <code>navigationController</code> property on <code>primaryViewController</code> is <code>nil</code>. If it’s not, the view controller is part of a navigation controller’s hierarchy, so we can then proceed to push the new view controller, <code>secondaryViewController</code> in this example, onto the stack by capturing the <code>navigationController</code> property’s value and calling the<a data-primary="iOS methods" data-secondary="push(_:animated:completion:)" data-type="indexterm" id="idm46177244493528"/> method <code>push(_:animated:completion:)</code> on it. If, however, the view controller doing the presenting is not on a navigation controller’s stack, we need to present this view controller in another way. In the example, we use a more direct, and older, style of presenting by calling <code>present(_:animated:completion:)</code>.</p>&#13;
&#13;
<p>There is more control in the code just shown, but it’s considerably more complex—and this is a simple example! What’s more, <code>show(_:sender:)</code> allows for some customization in how a view controller is presented as shown:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">primaryViewController</code> <code class="p">=</code> <code class="bp">UIViewController</code><code class="p">(</code><code class="n">nibName</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">bundle</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nv">secondaryViewController</code> <code class="p">=</code> <code class="bp">UIViewController</code><code class="p">(</code><code class="n">nibName</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">bundle</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Change the presentation style and the transition style</code>&#13;
<code class="n">secondaryViewController</code><code class="p">.</code><code class="n">modalPresentationStyle</code> <code class="p">=</code> <code class="p">.</code><code class="n">formSheet</code>&#13;
<code class="n">secondaryViewController</code><code class="p">.</code><code class="n">modalTransitionStyle</code> <code class="p">=</code> <code class="p">.</code><code class="n">flipHorizontal</code>&#13;
&#13;
<code class="c1">// Change the active UI controller</code>&#13;
<code class="n">primaryViewController</code><code class="p">.</code><code class="n">show</code><code class="p">(</code><code class="n">secondaryViewController</code><code class="p">,</code> <code class="n">sender</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code></pre>&#13;
&#13;
<p>Here<a data-primary="modalPresentationStyle" data-type="indexterm" id="idm46177244487864"/><a data-primary="modalTransitionStyle" data-type="indexterm" id="idm46177244394696"/> <code>modalPresentationStyle</code> changes the state in which the view controller is displayed, and <code>modalTransitionStyle</code> changes the transition that happens to get that view controller to that state. In this example, the presentation style is a<a data-primary="Form Sheet" data-type="indexterm" id="idm46177244392984"/> Form Sheet, a specially formatted display mode for the iPad that takes up only part of the screen. The transition style is a horizontal flip that flips the view around to reveal itself.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>On<a data-primary="UIKit" data-secondary="size class handling" data-type="indexterm" id="idm46177244390744"/><a data-primary=".compact size class" data-primary-sortas="compact size class" data-type="indexterm" id="idm46177244389736"/><a data-primary=".regular size class" data-primary-sortas="regular size class" data-type="indexterm" id="idm46177244388792"/> iPhones, or other <code>.compact</code> size classes, the presentation style <code>.formSheet</code> is ignored and UIKit adapts the style to a full-screen view. On larger iPhones, like iPhone XS Max or iPhone 8 Plus, the Form Sheet in landscape is displayed the same as it is on a tablet because these devices have a <code>.regular</code> size class in landscape; in a portrait orientation, these devices have a <code>.compact</code> size class, and the Form Sheet is displayed as a full-screen view just like on smaller phones. We point this out because there are always exceptions and edge cases. It’s important to test on a wide variety of simulators or devices.</p>&#13;
</div>&#13;
&#13;
<p>We’ve only scratched the surface of switching out active view controllers in the app programmatically. Before we go much further, we should discuss a (somewhat) code-free option in iOS called segues.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Segues" data-type="sect3"><div class="sect3" id="idm46177244703224">&#13;
<h3>Segues</h3>&#13;
&#13;
<p>Everything<a data-primary="segues" data-type="indexterm" id="idm46177244383224"/><a data-primary="storyboards" data-secondary="segues" data-type="indexterm" id="idm46177244382488"/> that’s been shown in code can be done in some form inside of a storyboard using segues. Segues are transitions between two view controllers; they are used to present view controllers within an app. They are most easily created within the storyboard editor in Xcode.</p>&#13;
&#13;
<p>To create a new segue, you must first have two view controller scenes to transition between. Control-click on the source view controller scene and drag the mouse to the destination view controller within the storyboard editor. This will highlight the whole scene in blue to indicate the scene you are targeting with the mouse. Releasing the mouse will cause a pop-up to display that allows you to select the kind of segue. The options presented correspond with the options shown so far: using <code>show(_:sender:)</code> under the hood and letting UIKit figure out the best segue or explicitly using a modal segue, among other options.</p>&#13;
&#13;
<p>After you create the segue, if it’s from a view controller to a view controller, you’ll need a way to programmatically call the segue. Click on the segue itself (e.g., the line connecting the scenes in the storyboard of the segue listed out as part of the scene itself like an object), open up the attributes inspector, and add a unique identifier. For our example, let’s use the name ExampleSegue.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The identifier you use for segues needs to be unique to the storyboard in which the view controller resides.</p>&#13;
</div>&#13;
&#13;
<p>Calling the segue is done like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">primaryViewController</code><code class="p">.</code><code class="n">performSegue</code><code class="p">(</code><code class="n">withIdentifier</code><code class="p">:</code> <code class="s">"ExampleSegue"</code><code class="p">,</code> <code class="n">sender</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code></pre>&#13;
&#13;
<p>The<a data-primary="iOS methods" data-secondary="performSegue(withIdentifier:sender:)" data-type="indexterm" id="idm46177244438808"/> <code>performSegue(withIdentifier:sender:)</code> method takes a string (ExampleSegue from earlier) and a <code>sender</code>, which could be any object. It’s common to pass a reference to a button if the segue was triggered via a button press, but it’s acceptable to pass in <code>nil</code> as we’re doing in the example.</p>&#13;
&#13;
<p>It’s also possible to wire up a button, or other control, to trigger a segue explicitly. This is done through the same Control-click mechanism in the storyboard editor, but instead of clicking and dragging on a whole scene, click and drag on a specific button within the source view controller. This makes it easy because the segue doesn’t need to be called programmatically like before using <code>performSegue(withIdentifier:sender:)</code> to make the transition between view controllers occur.</p>&#13;
&#13;
<p>Sometimes additional data needs to be provided between view controllers during a segue. There are methods called between the source and destination view controllers whenever a segue is performed allowing you to pass data or state to help set up a destination view controller or perform an action. Here is an example of a view controller presenting another view controller with the ExampleSegue, defined previously:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">buttonPressed</code><code class="p">(</code><code class="n">button</code><code class="p">:</code> <code class="bp">UIButton</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c1">// Code to trigger the segue. This could also be done directly</code>&#13;
        <code class="c1">// on the button itself within the storyboard editor</code>&#13;
        <code class="n">performSegue</code><code class="p">(</code><code class="n">withIdentifier</code><code class="p">:</code> <code class="s">"ExampleSegue"</code><code class="p">,</code> <code class="n">sender</code><code class="p">:</code> <code class="n">button</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">shouldPerformSegue</code><code class="p">(</code><code class="n">withIdentifier</code> <code class="n">identifier</code><code class="p">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="n">sender</code><code class="p">:</code> <code class="nb">Any</code><code class="p">?)</code> <code class="p">-&gt;</code> <code class="nb">Bool</code> <code class="p">{</code>&#13;
        <code class="c1">// This is an optional method that returns true by default</code>&#13;
        <code class="c1">// Returing false would cancel the segue</code>&#13;
        <code class="k">return</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">prepare</code><code class="p">(</code><code class="k">for</code> <code class="n">segue</code><code class="p">:</code> <code class="bp">UIStoryboardSegue</code><code class="p">,</code> <code class="n">sender</code><code class="p">:</code> <code class="nb">Any</code><code class="p">?)</code> <code class="p">{</code>&#13;
        <code class="c1">// This is the destination view controller in the segue</code>&#13;
        <code class="kd">let</code> <code class="nv">destinationViewController</code> <code class="p">=</code> <code class="n">segue</code><code class="p">.</code><code class="n">destination</code>&#13;
&#13;
        <code class="c1">// Let's pass some data to the destination segue</code>&#13;
        <code class="p">...</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Within this example <code>UIViewController</code> subclass, there is a method named <code>buttonPressed(_:)</code> that is triggered whenever a button is pressed. This code uses <code>performSegue(withIdentifier:sender:)</code> to trigger the segue. (This could also be accomplished by directly linking the button within the storyboard editor, but is shown to demonstrate what is happening within this class.)</p>&#13;
&#13;
<p>Now, before<a data-primary="iOS methods" data-secondary="shouldPerformSegue(withI dentifier:sender:)" data-type="indexterm" id="idm46177244231096"/> the segue starts, the method <code>shouldPerformSegue(withIdentifier:sender:)</code> is called. This is an optional method within a view controller that can be overridden to provide some customization around the decision about whether or not a segue should be performed. The default value returned is <code>true</code>. The destination view controller has not been created before this method is called. Returning <code>false</code> will cause the segue to be cancelled, and nothing further will occur. It’s not all that common to use <code>shouldPerformSegue(withIdentifier:sender:)</code> to cancel segues; however, it is a useful integration point at times.</p>&#13;
&#13;
<p>Finally, in the chain of events, <code>prepare(for:sender:)</code> is the last to occur. At this point, the destination view controller has now been instantiated and is one step away from being presented. This is the last chance for the source view controller to pass some state or contextual information to help the destination view controller during or after the segue.</p>&#13;
&#13;
<p>We know how to create and set up the initial view controller in an app, and we know how to transition between active view controllers. Let’s take a step back and make sure understand the life of a view controller in iOS.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding the Controller Life Cycle" data-type="sect2"><div class="sect2" id="idm46177244226040">&#13;
<h2>Understanding the Controller Life Cycle</h2>&#13;
&#13;
<p>In<a data-primary="UI (user interface) controllers" data-secondary="iOS" data-tertiary="controller life cycle" data-type="indexterm" id="idm46177244224456"/><a data-primary="iOS" data-secondary="UI (user interface) controllers" data-tertiary="controller life cycle" data-type="indexterm" id="idm46177244223112"/> order to create a UI controller in iOS, you have a number of methods at your disposal, but the most common method is to use storyboards to design and define your app’s UI controllers.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating UI controllers from storyboards" data-type="sect3"><div class="sect3" id="idm46177244221416">&#13;
<h3>Creating UI controllers from storyboards</h3>&#13;
&#13;
<p>In<a data-primary="storyboards" data-secondary="creating UI controllers from" data-type="indexterm" id="idm46177244219912"/> order to create a view controller from a storyboard, first you must create a view controller scene in the storyboard. You can do this in Xcode by adding a view controller to the editing stage. After this has been done, make sure to open up the Identity inspector and add any custom subclass used in the Class field. Additionally, give the view controller a specific Storyboard ID. This identifier is used to identify the specific view controller scene to use when creating the view controller programmatically from a storyboard. Usually the identifier is just the name of the class, like this:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">viewController</code> <code class="p">=</code> <code class="bp">UIStoryboard</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"Main"</code><code class="p">,</code> <code class="n">bundle</code><code class="p">:</code> <code class="kc">nil</code><code class="p">).</code>&#13;
                    <code class="n">instantiateViewController</code><code class="p">(</code><code class="n">withIdentifier</code><code class="p">:</code> <code class="s">"ExampleViewController"</code><code class="p">)</code></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>While the strings are easy to use, things can get out of control fast. It’s best to store storyboard identifiers separately in a constants <code>struct</code>, an <code>enum</code>, or through some other abstraction for compile-time safety and to prevent future maintenance woes.</p>&#13;
</div>&#13;
&#13;
<p>When view controllers are created through storyboards, UIKit uses a special method that can be overridden in the class to help with initialization. This<a data-primary="iOS methods" data-secondary="init(coder:)" data-type="indexterm" id="idm46177244201512"/> method, <code>init(coder:)</code>, is a great place to perform any setup or customization that needs doing before the view is loaded into the class and before it’s placed in the hierarchy of view controllers. Overriding this method is done like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
&#13;
    <code class="kr">required</code> <code class="kd">init</code><code class="p">?(</code><code class="n">coder</code> <code class="n">aDecoder</code><code class="p">:</code> <code class="bp">NSCoder</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="kd">init</code><code class="p">(</code><code class="n">coder</code><code class="p">:</code> <code class="n">aDecoder</code><code class="p">)</code>&#13;
&#13;
        <code class="c1">// Perform some customization</code>&#13;
    <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>While <code>init(coder:)</code> is easy to override, you cannot use custom parameters in the method itself. Injecting properties into view controllers at initialization via the object’s constructor is easier in Android than in iOS with the use of storyboards. Often, injection of values is done by setting properties directly or calling a setup method after the view controller has already been instantiated. Each has its own set of trade-offs, and often both patterns will be used throughout a project.</p>&#13;
</div>&#13;
&#13;
<p>The life cycle of the UI controller is tied to the life cycle of the view it controls. There is a set of events besides the initializer the view controller receives from the view and other objects that control it to help make managing the view, and other dependent objects, easier. Let’s talk about a few of these.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="viewDidLoad" data-type="sect3"><div class="sect3" id="idm46177244182456">&#13;
<h3>viewDidLoad</h3>&#13;
&#13;
<p>This<a data-primary="iOS methods" data-secondary="viewDidLoad" data-type="indexterm" id="idm46177244124856"/> method is called after the UI controller’s view has loaded. It’s called only once during the life cycle of a view controller, and it’s the place where any view setup occurs. All outlets and actions set up inside a storyboard are wired up and ready for use at this point. Typically, things like setting a view’s background color, fonts on labels, and other stylistic operations are done within this method. Occasionally, notifications are set up here (see <a data-type="xref" href="ch11.html#topics_preferences">Chapter 11</a>). If that is the case, make sure to unsubscribe from notification in <code>deinit</code> or another method to prevent crashes or memory leaks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="viewWillAppear and viewDidAppear" data-type="sect3"><div class="sect3" id="idm46177244121800">&#13;
<h3>viewWillAppear and viewDidAppear</h3>&#13;
&#13;
<p>This<a data-primary="iOS methods" data-secondary="viewWillAppear" data-type="indexterm" id="idm46177244120504"/><a data-primary="iOS methods" data-secondary="viewDidAppear" data-type="indexterm" id="idm46177244119496"/> set of methods is called before and after a view is presented on the tree of views that form the view hierarchy. At this point, the view often has a known size (but not always—modals do not have a view size determined until <code>viewDidAppear</code>) and that can be used for some last-minute size adjustments. This is also a good place to turn on memory- or CPU-intensive things like GPS tracking or accelerometer events.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="viewWillDisappear and viewDidDisappear" data-type="sect3"><div class="sect3" id="idm46177244117352">&#13;
<h3>viewWillDisappear and viewDidDisappear</h3>&#13;
&#13;
<p>These<a data-primary="iOS methods" data-secondary="viewWillDisappear" data-type="indexterm" id="idm46177244116056"/><a data-primary="iOS methods" data-secondary="viewDidDisappear" data-type="indexterm" id="idm46177244115048"/> methods are similar to <code>viewWillAppear</code> and <code>viewDidAppear</code>, but they are triggered whenever a view is about to be, or has been, removed from the view hierarchy and is no longer visible. This is a great place to disable the things enabled in the previous set of methods.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Interactive swipe back gestures that are used by the user do not call <code>viewDidDisappear</code>. Be sure to test by tapping on the OS-provided back button and by swiping to pop a view off the screen.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="didReceiveMemoryWarning" data-type="sect3"><div class="sect3" id="idm46177244110984">&#13;
<h3>didReceiveMemoryWarning</h3>&#13;
&#13;
<p>It’s<a data-primary="iOS methods" data-secondary="didReceiveMemoryWarning" data-type="indexterm" id="idm46177244109416"/> important to handle memory warnings in iOS because memory is sometimes very constrained on mobile devices. Clear up unnecessary resource caching, clear outlets created from storyboards, etc. If the app doesn’t recover from this, it will eventually shut down and the application will be terminated.</p>&#13;
&#13;
<p>Here’s an example of a class that handles all these methods:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">hugeDataFile</code><code class="p">:</code> <code class="nb">Any</code><code class="p">?</code>&#13;
&#13;
    <code class="kr">required</code> <code class="kd">init</code><code class="p">?(</code><code class="n">coder</code> <code class="n">aDecoder</code><code class="p">:</code> <code class="bp">NSCoder</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="kd">init</code><code class="p">(</code><code class="n">coder</code><code class="p">:</code> <code class="n">aDecoder</code><code class="p">)</code>&#13;
        <code class="c1">// Set up operations not dependent on a view</code>&#13;
        <code class="c1">// For example, setting up that hugeDataFile object in the background</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
        <code class="c1">// The view has been loaded from the storyboard</code>&#13;
        <code class="n">title</code> <code class="p">=</code> <code class="s">"Awesome View Controller Example"</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewWillAppear</code><code class="p">(</code><code class="kc">_</code> <code class="n">animated</code><code class="p">:</code> <code class="nb">Bool</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewWillAppear</code><code class="p">(</code><code class="n">animated</code><code class="p">)</code>&#13;
        <code class="c1">// The view is about to be displayed on the screen</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidAppear</code><code class="p">(</code><code class="kc">_</code> <code class="n">animated</code><code class="p">:</code> <code class="nb">Bool</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidAppear</code><code class="p">(</code><code class="n">animated</code><code class="p">)</code>&#13;
        <code class="c1">// The view has been displayed on the screen</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewWillDisappear</code><code class="p">(</code><code class="kc">_</code> <code class="n">animated</code><code class="p">:</code> <code class="nb">Bool</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewWillDisappear</code><code class="p">(</code><code class="n">animated</code><code class="p">)</code>&#13;
        <code class="c1">// The view is about to disappear from the screen</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidDisappear</code><code class="p">(</code><code class="kc">_</code> <code class="n">animated</code><code class="p">:</code> <code class="nb">Bool</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidDisappear</code><code class="p">(</code><code class="n">animated</code><code class="p">)</code>&#13;
        <code class="c1">// The view has disappeared from the screen</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">didReceiveMemoryWarning</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">didReceiveMemoryWarning</code><code class="p">()</code>&#13;
        <code class="c1">// Uh-oh! Better clear out that huge data file we were holding on to</code>&#13;
        <code class="n">hugeDataFile</code> <code class="p">=</code> <code class="kc">nil</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice that all the methods are <code>override</code> methods that call their <code>super</code> equivalents in the method body. <em>It’s important to do this</em>, otherwise subsequent view controllers in the view controller hierarchy won’t receive calls for any missing calls. Why this isn’t a compiler addition handled just like <code>retain</code> and <code>release</code> calls is beyond the scope of this book. Just don’t forget to include these method calls in your overrides!</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Both Android and iOS support the use of an MVC architecture. This architecture is sometimes given pejoratively as “Massive View Controller” because without discipline, it lends itself to dumping all controlling logic for views into classes that are thousands of lines long. It’s important to be diligent in maintaining single-use responsibility of a class as much as possible and using container views appropriately.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Navigation controllers, tab bars, and split view controllers" data-type="sect3"><div class="sect3" id="idm46177243945288">&#13;
<h3>Navigation controllers, tab bars, and split view controllers</h3>&#13;
&#13;
<p>There<a data-primary="UIKit" data-secondary="UINavigationController" data-type="indexterm" id="idm46177243943688"/><a data-primary="UIKit" data-secondary="UITabBarController" data-type="indexterm" id="idm46177243942680"/><a data-primary="UIKit" data-secondary="UISplitViewController" data-type="indexterm" id="idm46177243941736"/> are special classes in iOS that have special behavior specifically for managing view controllers. The three you’ll most likely encounter are navigation controllers (<code>UINavigationController</code>), tab bar controllers (<code>UITabBarController</code>), and split view controllers (<code>UISplitViewController</code>).</p>&#13;
&#13;
<p>Navigation controllers are used to handle stacks of view controllers and make transitioning between them consistent and easier to spatially navigate and reason about versus a series of modal view controllers stacked visually on top of each other.</p>&#13;
&#13;
<p>Tab bar controllers are a special class that handle managing active view controllers with an anchored tab bar at the bottom of the screen. This is a common method of segmenting distinct sections within an app (e.g., a tab for Search, Checkout, and Orders in a shopping app).</p>&#13;
&#13;
<p>Split view controllers originated from the iPad but have since migrated to the iPhone. They are used to display a master set of data, typically in list form, and then provide a detail view of that data whenever an item is selected.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="showDetail(_:sender:)" data-type="sect3"><div class="sect3" id="idm46177243937192">&#13;
<h3>showDetail(_:sender:)</h3>&#13;
&#13;
<p>If<a data-primary="iOS methods" data-secondary="showDetail(_:sender:)" data-type="indexterm" id="idm46177243935640"/> you’re using a <code>UISplitController</code>, you can use <code>showDetail(_:sender:)</code> to present a detail view controller in lieu of <code>show(_:sender:)</code>. This will adapt to a full-screen modal view when a <code>UISplitController</code> isn’t available for a device (as on <code>.compact</code> size class devices like the smaller-sized iPhones).</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177243932072">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>Within this chapter we’ve covered a lot of information about UI controllers:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We talked about the different architectures present within Android and iOS and showed how an <code>Activity</code> stacks up to a <code>UIViewController</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The startup logic for an app to display a view on the screen at the direction of a UI controller was demonstrated in both platforms. In Android, there was more configuration versus the more convention-based approach of iOS.</p>&#13;
</li>&#13;
<li>&#13;
<p>We covered scene transitions and changing the active view, along with some tools in Android like <code>Fragment</code> objects to make controlling those views a bit simpler.</p>&#13;
</li>&#13;
<li>&#13;
<p>We discussed the various methods that are called as part of a UI controller for Android and iOS.</p>&#13;
</li>&#13;
<li>&#13;
<p>We introduced storyboards in iOS and their role in connecting different scenes.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>It’s surprising that even with this broad knowledge base there is a huge amount of information that wasn’t covered. We talk more about some of the details of views outside of the context of UI controllers in <a data-type="xref" href="ch02.html#topics_views">Chapter 2</a>. There is also additional information in <a data-type="xref" href="part02.html#part_2_app">Part II</a> where we walk through building a sample application for both platforms.</p>&#13;
&#13;
<p>If you’re ready to learn about views now, though, head to the next chapter for a great comparison!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>