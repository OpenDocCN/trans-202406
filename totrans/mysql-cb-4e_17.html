<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 17. Statistical Techniques"><div class="chapter" id="nch-stats"><h1><span class="label">Chapter 17. </span>Statistical Techniques</h1><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820338480432"><h5>A note for Early Release readers</h5><p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p></div></aside><section data-type="sect1" data-pdf-bookmark="17.0 Introduction"><div class="sect1" id="nch-stats-stats-intro"><h1>17.0 Introduction</h1><p>This chapter covers several topics that relate to basic statistical
    techniques. For the most part, these recipes build on those described in
    earlier chapters, such as the summary techniques discussed in <a data-type="xref" href="ch10.xhtml#nch-sum">Chapter 10</a>, and join techniques from <a data-type="xref" href="ch16.xhtml#nch-multi">Chapter 16</a>. The examples here thus show additional ways to
    apply the material from those chapters. Broadly speaking, the topics
    discussed in this chapter include:</p><ul><li><p>Techniques for characterizing a dataset, such as calculating
        descriptive statistics, generating frequency distributions, counting
        missing values, and calculating least-squares regressions or
        correlation coefficients</p></li><li><p>Randomization methods, such as how to generate random numbers
        and apply them to randomizing a set of rows or to selecting individual
        items randomly from the rows</p></li><li><p>Techniques for calculating successive-observation differences,
        cumulative sums, and running averages.</p></li><li><p>Methods for producing rank assignments and generating team
        standings</p></li></ul><p>Statistics covers such a large and diverse array of topics that this
    chapter necessarily only scratches the surface and simply illustrates a
    few of the potential areas in which MySQL may be applied to statistical
    analysis. Note that some statistical measures can be defined in different
    ways (for example, do you calculate standard deviation based on
    <em><code>n</code></em> degrees of freedom, or
    <em><code>n</code></em>–1?). If the definition I use for a given term
    doesn’t match the one you prefer, adapt the queries or algorithms shown
    here appropriately.</p><p>You can find scripts related to the examples discussed here in the
    <em class="filename">stats</em> directory of the <code>recipes</code> distribution, and scripts for creating
    example tables in the <em class="filename">tables</em>
    directory.</p></div></section><section data-type="sect1" data-pdf-bookmark="17.1 Calculating Descriptive Statistics"><div class="sect1" id="nch-stats-stats-descriptive"><h1>17.1 Calculating Descriptive Statistics</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820338467824"><h2>Problem</h2><p>You want to characterize a dataset by computing general descriptive or
      summary statistics.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820338466736"><h2>Solution</h2><p>Many common descriptive statistics, such as mean and standard
      deviation, are obtained by applying aggregate functions to your data. Others, such as median
      or mode, are calculated based on counting queries.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820338465792"><h2>Discussion</h2><p>Suppose that a <code>testscore</code> table
      contains observations representing subject ID, age, sex, and test
      score:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT subject, age, sex, score FROM testscore ORDER BY subject;</code></strong>
+---------+-----+-----+-------+
| subject | age | sex | score |
+---------+-----+-----+-------+
|       1 |   5 | M   |     5 |
|       2 |   5 | M   |     4 |
|       3 |   5 | F   |     6 |
|       4 |   5 | F   |     7 |
|       5 |   6 | M   |     8 |
|       6 |   6 | M   |     9 |
|       7 |   6 | F   |     4 |
|       8 |   6 | F   |     6 |
|       9 |   7 | M   |     8 |
|      10 |   7 | M   |     6 |
|      11 |   7 | F   |     9 |
|      12 |   7 | F   |     7 |
|      13 |   8 | M   |     9 |
|      14 |   8 | M   |     6 |
|      15 |   8 | F   |     7 |
|      16 |   8 | F   |    10 |
|      17 |   9 | M   |     9 |
|      18 |   9 | M   |     7 |
|      19 |   9 | F   |    10 |
|      20 |   9 | F   |     9 |
+---------+-----+-----+-------+</pre><p>A good first step in analyzing a set of observations is to
      generate some descriptive statistics that summarize their general
      characteristics as a whole. Common statistical values of this kind
      include:</p><ul><li><p>The number of observations, their sum, and their range
          (minimum and maximum)</p></li><li><p>Measures of central tendency, such as mean, median, and mode</p></li><li><p>Measures of variation, such as standard deviation and variance</p></li></ul><p>Aside from the median and mode, all of these can be calculated
      easily by invoking aggregate functions:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(score) AS n,</code></strong>
    -&gt; <strong><code>SUM(score) AS sum,</code></strong>
    -&gt; <strong><code>MIN(score) AS minimum,</code></strong>
    -&gt; <strong><code>MAX(score) AS maximum,</code></strong>
    -&gt; <strong><code>AVG(score) AS mean,</code></strong>
    -&gt; <strong><code>STDDEV_SAMP(score) AS 'std. dev.',</code></strong>
    -&gt; <strong><code>VAR_SAMP(score) AS 'variance'</code></strong>
    -&gt; <strong><code>FROM testscore;</code></strong>
+----+------+---------+---------+--------+-----------+----------+
| n  | sum  | minimum | maximum | mean   | std. dev. | variance |
+----+------+---------+---------+--------+-----------+----------+
| 20 |  146 |       4 |      10 | 7.3000 |    1.8382 |   3.3789 |
+----+------+---------+---------+--------+-----------+----------+</pre><p>The <code>STDDEV_SAMP()</code> and <code>VAR_SAMP()</code> functions produce sample measures rather than population measures.
      That is, for a set of <em><code>n</code></em> values, they produce
      a result that is based on <em><code>n</code></em>–1 degrees of
      freedom. For the population measures, which are based on
      <em><code>n</code></em> degrees of freedom, use <code>STDDEV_POP()</code> and
      <code>VAR_POP()</code> instead. <code>STDDEV()</code> and <code>VARIANCE()</code> are synonyms for <code>STDDEV_POP()</code> and <code>VAR_POP()</code>.</p><p>Standard deviation can be used to identify outliers—values that are uncharacteristically far from the
      mean. For example, to select values that lie more than
      a standard deviation from the mean, do this:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="k">AVG</code><code class="p">(</code><code class="n">score</code><code class="p">),</code> <code class="n">STDDEV_SAMP</code><code class="p">(</code><code class="n">score</code><code class="p">)</code> <code class="k">INTO</code> <code class="o">@</code><code class="n">mean</code><code class="p">,</code> <code class="o">@</code><code class="n">std</code> <code class="k">FROM</code> <code class="n">testscore</code><code class="p">;</code>
<code class="k">SELECT</code> <code class="n">score</code> <code class="k">FROM</code> <code class="n">testscore</code> <code class="k">WHERE</code> <code class="k">ABS</code><code class="p">(</code><code class="n">score</code><code class="o">-@</code><code class="n">mean</code><code class="p">)</code> <code class="o">&gt;</code> <code class="o">@</code><code class="n">std</code><code class="p">;</code></pre><p>MySQL has no built-in function for computing the mode or median of a set of values, but you can compute
      them yourself. To determine the mode (the value that occurs most
      frequently), count each value and see which is most common:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT score, COUNT(score) AS frequency</code></strong>
    -&gt; <strong><code>FROM testscore GROUP BY score ORDER BY frequency DESC;</code></strong>
+-------+-----------+
| score | frequency |
+-------+-----------+
|     9 |         5 |
|     6 |         4 |
|     7 |         4 |
|     4 |         2 |
|     8 |         2 |
|    10 |         2 |
|     5 |         1 |
+-------+-----------+</pre><p>In this case, 9 is the modal score value.</p><p>The median of a set of ordered values can be calculated like
      this:<sup><a data-type="noteref" id="idm45820338373088-marker" href="ch17.xhtml#idm45820338373088">1</a></sup></p><ul><li><p>If the number of values is odd, the median is the middle
          value.</p></li><li><p>If the number of values is even, the median is the average of
          the two middle values.</p></li></ul><p>Based on that definition, use the following procedure to determine
      the median of a set of observations stored in the database:</p><ol><li><p>Issue a query to count the number of observations. From the
          count, you can determine whether the median calculation requires one
          or two values, and what their indexes are within the ordered set of
          observations.</p></li><li><p>Issue a query that includes an <code>ORDER</code> <code>BY</code> clause to sort the observations and
          a <code>LIMIT</code> clause to
          pull out the middle value or values.</p></li><li><p>If there is a single middle value, it is the median.
          Otherwise, take the average of the middle values.</p></li></ol><p>Suppose that a table <code>t</code> contains
      a <code>score</code> column with 37 values (an odd
      number). To get the median, select a single value using a statement like
      this:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">score</code> <code class="k">FROM</code> <code class="n">t</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">score</code> <code class="k">LIMIT</code> <code class="mi">18</code><code class="p">,</code><code class="mi">1</code><code class="p">;</code></pre><p>If the column contains 38 values (an even number), select two
      values:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">score</code> <code class="k">FROM</code> <code class="n">t</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">score</code> <code class="k">LIMIT</code> <code class="mi">18</code><code class="p">,</code><code class="mi">2</code><code class="p">;</code></pre><p>Then take the values returned by the statement and compute the
      median from their average.</p><p>The following Perl function implements a median calculation. It
      takes a database handle and the names of the database, table, and column
      that contain the set of observations. Then it generates the statement
      that retrieves the relevant values and returns their average:</p><pre data-type="programlisting" data-code-language="perl"><code class="k">sub</code> <code class="nf">median</code>
<code class="p">{</code>
<code class="k">my</code> <code class="p">(</code><code class="nv">$dbh</code><code class="p">,</code> <code class="nv">$db_name</code><code class="p">,</code> <code class="nv">$tbl_name</code><code class="p">,</code> <code class="nv">$col_name</code><code class="p">)</code> <code class="o">=</code> <code class="nv">@_</code><code class="p">;</code>
<code class="k">my</code> <code class="p">(</code><code class="nv">$count</code><code class="p">,</code> <code class="nv">$limit</code><code class="p">);</code>

  <code class="nv">$db_name</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="n">quote_identifier</code> <code class="p">(</code><code class="nv">$db_name</code><code class="p">);</code>
  <code class="nv">$tbl_name</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="n">quote_identifier</code> <code class="p">(</code><code class="nv">$tbl_name</code><code class="p">);</code>
  <code class="nv">$col_name</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="n">quote_identifier</code> <code class="p">(</code><code class="nv">$col_name</code><code class="p">);</code>

  <code class="nv">$count</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="n">selectrow_array</code> <code class="p">(</code><code class="sx">qq{</code>
<code class="sx">    SELECT COUNT($col_name) FROM $db_name.$tbl_name</code>
<code class="sx">  }</code><code class="p">);</code>
  <code class="k">return</code> <code class="nb">undef</code> <code class="k">unless</code> <code class="nv">$count</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">;</code>
  <code class="k">if</code> <code class="p">(</code><code class="nv">$count</code> <code class="nv">%</code> <code class="nv">2</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code>  <code class="c1"># odd number of values; select middle value</code>
  <code class="p">{</code>
    <code class="nv">$limit</code> <code class="o">=</code> <code class="nb">sprintf</code> <code class="p">(</code><code class="s">"LIMIT %d,1"</code><code class="p">,</code> <code class="p">(</code><code class="nv">$count</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="o">/</code><code class="mi">2</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="k">else</code>                  <code class="c1"># even number of values; select middle two values</code>
  <code class="p">{</code>
    <code class="nv">$limit</code> <code class="o">=</code> <code class="nb">sprintf</code> <code class="p">(</code><code class="s">"LIMIT %d,2"</code><code class="p">,</code> <code class="nv">$count</code><code class="o">/</code><code class="mi">2</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
  <code class="p">}</code>

  <code class="k">my</code> <code class="nv">$sth</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="n">prepare</code> <code class="p">(</code><code class="sx">qq{</code>
<code class="sx">    SELECT $col_name FROM $db_name.$tbl_name ORDER BY $col_name $limit</code>
<code class="sx">  }</code><code class="p">);</code>
  <code class="nv">$sth</code><code class="o">-&gt;</code><code class="n">execute</code> <code class="p">();</code>
  <code class="k">my</code> <code class="p">(</code><code class="nv">$n</code><code class="p">,</code> <code class="nv">$sum</code><code class="p">)</code> <code class="o">=</code> <code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
  <code class="k">while</code> <code class="p">(</code><code class="k">my</code> <code class="nv">$ref</code> <code class="o">=</code> <code class="nv">$sth</code><code class="o">-&gt;</code><code class="n">fetchrow_arrayref</code> <code class="p">())</code>
  <code class="p">{</code>
    <code class="o">++</code><code class="nv">$n</code><code class="p">;</code>
    <code class="nv">$sum</code> <code class="o">+=</code> <code class="nv">$ref</code><code class="o">-&gt;</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
  <code class="p">}</code>
  <code class="k">return</code> <code class="nv">$sum</code> <code class="o">/</code> <code class="nv">$n</code><code class="p">;</code>
<code class="p">}</code></pre><p>The preceding technique works for a set of values stored in the
      database. If you have already fetched an ordered set of values into an
      array <code>@val</code>, compute the median like
      this instead:</p><pre data-type="programlisting" data-code-language="perl"><code class="k">if</code> <code class="p">(</code><code class="nv">@val</code> <code class="o">==</code> <code class="mi">0</code><code class="p">)</code>          <code class="c1"># array is empty, median is undefined</code>
<code class="p">{</code>
  <code class="nv">$median</code> <code class="o">=</code> <code class="nb">undef</code><code class="p">;</code>
<code class="p">}</code>
<code class="k">elsif</code> <code class="p">(</code><code class="nv">@val</code> <code class="nv">%</code> <code class="nv">2</code> <code class="o">==</code> <code class="mi">1</code><code class="p">)</code>   <code class="c1"># array size is odd, median is middle number</code>
<code class="p">{</code>
  <code class="nv">$median</code> <code class="o">=</code> <code class="nv">$val</code><code class="p">[(</code><code class="nv">@val</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="o">/</code><code class="mi">2</code><code class="p">];</code>
<code class="p">}</code>
<code class="k">else</code>                    <code class="c1"># array size is even; median is average</code>
<code class="p">{</code>                       <code class="c1"># of two middle numbers</code>
  <code class="nv">$median</code> <code class="o">=</code> <code class="p">(</code><code class="nv">$val</code><code class="p">[</code><code class="nv">@val</code><code class="sr">/2 - 1] + $val[@val/</code><code class="mi">2</code><code class="p">])</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>
<code class="p">}</code></pre><p>The code works for arrays that have an initial subscript of 0; for
      languages that use 1-based array indexes, adjust the algorithm
      accordingly.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.2 Calculating Descriptive Statistics for Groups"><div class="sect1" id="nch-stats-stats-per-group"><h1>17.2 Calculating Descriptive Statistics for Groups</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820338002096"><h2>Problem</h2><p>You want to produce descriptive statistics for each subgroup of a set of
      observations.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820338014656"><h2>Solution</h2><p>Use aggregate functions, but employ a <code>GROUP</code> <code>BY</code> clause to arrange observations into the
      appropriate groups.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820338012944"><h2>Discussion</h2><p><a data-type="xref" href="#nch-stats-stats-descriptive">Recipe 17.1</a> shows how to
      compute descriptive statistics for the entire set of scores in the
      <code>testscore</code> table. To be more specific,
      use <code>GROUP</code> <code>BY</code> to divide the observations into groups and
      calculate statistics for each of them. For example, the subjects in the
      <code>testscore</code> table are listed by age and
      sex, so it’s possible to calculate similar statistics by age or sex (or
      both) by application of appropriate <code>GROUP</code> <code>BY</code>
      clauses.</p><p>Here’s how to calculate by age:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT age, COUNT(score) AS n,</code></strong>
    -&gt; <strong><code>SUM(score) AS sum,</code></strong>
    -&gt; <strong><code>MIN(score) AS minimum,</code></strong>
    -&gt; <strong><code>MAX(score) AS maximum,</code></strong>
    -&gt; <strong><code>AVG(score) AS mean,</code></strong>
    -&gt; <strong><code>STDDEV_SAMP(score) AS 'std. dev.',</code></strong>
    -&gt; <strong><code>VAR_SAMP(score) AS 'variance'</code></strong>
    -&gt; <strong><code>FROM testscore</code></strong>
    -&gt; <strong><code>GROUP BY age;</code></strong>
+-----+---+------+---------+---------+--------+-----------+----------+
| age | n | sum  | minimum | maximum | mean   | std. dev. | variance |
+-----+---+------+---------+---------+--------+-----------+----------+
|   5 | 4 |   22 |       4 |       7 | 5.5000 |    1.2910 |   1.6667 |
|   6 | 4 |   27 |       4 |       9 | 6.7500 |    2.2174 |   4.9167 |
|   7 | 4 |   30 |       6 |       9 | 7.5000 |    1.2910 |   1.6667 |
|   8 | 4 |   32 |       6 |      10 | 8.0000 |    1.8257 |   3.3333 |
|   9 | 4 |   35 |       7 |      10 | 8.7500 |    1.2583 |   1.5833 |
+-----+---+------+---------+---------+--------+-----------+----------+</pre><p>By sex:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT sex, COUNT(score) AS n,</code></strong>
    -&gt; <strong><code>SUM(score) AS sum,</code></strong>
    -&gt; <strong><code>MIN(score) AS minimum,</code></strong>
    -&gt; <strong><code>MAX(score) AS maximum,</code></strong>
    -&gt; <strong><code>AVG(score) AS mean,</code></strong>
    -&gt; <strong><code>STDDEV_SAMP(score) AS 'std. dev.',</code></strong>
    -&gt; <strong><code>VAR_SAMP(score) AS 'variance'</code></strong>
    -&gt; <strong><code>FROM testscore</code></strong>
    -&gt; <strong><code>GROUP BY sex;</code></strong>
+-----+----+------+---------+---------+--------+-----------+----------+
| sex | n  | sum  | minimum | maximum | mean   | std. dev. | variance |
+-----+----+------+---------+---------+--------+-----------+----------+
| M   | 10 |   71 |       4 |       9 | 7.1000 |    1.7920 |   3.2111 |
| F   | 10 |   75 |       4 |      10 | 7.5000 |    1.9579 |   3.8333 |
+-----+----+------+---------+---------+--------+-----------+----------+</pre><p>By age and sex:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT age, sex, COUNT(score) AS n,</code></strong>
    -&gt; <strong><code>SUM(score) AS sum,</code></strong>
    -&gt; <strong><code>MIN(score) AS minimum,</code></strong>
    -&gt; <strong><code>MAX(score) AS maximum,</code></strong>
    -&gt; <strong><code>AVG(score) AS mean,</code></strong>
    -&gt; <strong><code>STDDEV_SAMP(score) AS 'std. dev.',</code></strong>
    -&gt; <strong><code>VAR_SAMP(score) AS 'variance'</code></strong>
    -&gt; <strong><code>FROM testscore</code></strong>
    -&gt; <strong><code>GROUP BY age, sex;</code></strong>
+-----+-----+---+------+---------+---------+--------+-----------+----------+
| age | sex | n | sum  | minimum | maximum | mean   | std. dev. | variance |
+-----+-----+---+------+---------+---------+--------+-----------+----------+
|   5 | M   | 2 |    9 |       4 |       5 | 4.5000 |    0.7071 |   0.5000 |
|   5 | F   | 2 |   13 |       6 |       7 | 6.5000 |    0.7071 |   0.5000 |
|   6 | M   | 2 |   17 |       8 |       9 | 8.5000 |    0.7071 |   0.5000 |
|   6 | F   | 2 |   10 |       4 |       6 | 5.0000 |    1.4142 |   2.0000 |
|   7 | M   | 2 |   14 |       6 |       8 | 7.0000 |    1.4142 |   2.0000 |
|   7 | F   | 2 |   16 |       7 |       9 | 8.0000 |    1.4142 |   2.0000 |
|   8 | M   | 2 |   15 |       6 |       9 | 7.5000 |    2.1213 |   4.5000 |
|   8 | F   | 2 |   17 |       7 |      10 | 8.5000 |    2.1213 |   4.5000 |
|   9 | M   | 2 |   16 |       7 |       9 | 8.0000 |    1.4142 |   2.0000 |
|   9 | F   | 2 |   19 |       9 |      10 | 9.5000 |    0.7071 |   0.5000 |
+-----+-----+---+------+---------+---------+--------+-----------+----------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.3 Generating Frequency Distributions"><div class="sect1" id="nch-stats-stats-freq-dist"><h1>17.3 Generating Frequency Distributions</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337936496"><h2>Problem</h2><p>You want to know the frequency of occurrence for each value in a
      table.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337935616"><h2>Solution</h2><p>Derive a frequency distribution that summarizes the contents of
      your dataset.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337934736"><h2>Discussion</h2><p>A common application for per-group summary techniques is to
      generate a <em>frequency distribution</em> that shows how
      often each value occurs. For the <code>testscore</code> table, the frequency distribution
      looks like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT score, COUNT(score) AS counts</code></strong>
    -&gt; <strong><code>FROM testscore GROUP BY score;</code></strong>
+-------+--------+
| score | counts |
+-------+--------+
|     4 |      2 |
|     5 |      1 |
|     6 |      4 |
|     7 |      4 |
|     8 |      2 |
|     9 |      5 |
|    10 |      2 |
+-------+--------+</pre><p>Expressing the results in percentages rather than counts yields
      relative frequency distribution. To show each count as a percentage of
      the total, use one query to get the total number of observations and
      another to calculate the percentages for each group:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @n = (SELECT COUNT(score) FROM testscore);</code></strong>
mysql&gt; <strong><code>SELECT score, (COUNT(score)*100)/@n AS percent</code></strong>
    -&gt; <strong><code>FROM testscore GROUP BY score;</code></strong>
+-------+---------+
| score | percent |
+-------+---------+
|     4 | 10.0000 |
|     5 |  5.0000 |
|     6 | 20.0000 |
|     7 | 20.0000 |
|     8 | 10.0000 |
|     9 | 25.0000 |
|    10 | 10.0000 |
+-------+---------+</pre><p>The distributions just shown summarize the number of values for
      individual scores. However, if the dataset contains a large number of
      distinct values and you want a distribution that shows only a small
      number of categories, you may want to lump values into categories and
      produce a count for each category. <a data-type="xref" href="ch10.xhtml#nch-sum-sum-noncat">Recipe 10.13</a>
      discusses <q>lumping</q> techniques.</p><p>One typical use of frequency distributions is to export the
      results for use in a graphing program. But MySQL itself can generate a
      simple ASCII chart as a visual representation of the distribution. To
      display an ASCII bar chart of the test score counts, convert the counts
      to strings of <code>*</code> characters:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT score, REPEAT('*',COUNT(score)) AS 'count histogram'</code></strong>
    -&gt; <strong><code>FROM testscore GROUP BY score;</code></strong>
+-------+-----------------+
| score | count histogram |
+-------+-----------------+
|     4 | **              |
|     5 | *               |
|     6 | ****            |
|     7 | ****            |
|     8 | **              |
|     9 | *****           |
|    10 | **              |
+-------+-----------------+</pre><p>To chart the relative frequency distribution instead, use the
      percentage values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @n = (SELECT COUNT(score) FROM testscore);</code></strong>
mysql&gt; <strong><code>SELECT score,</code></strong>
    -&gt; <strong><code>REPEAT('*',(COUNT(score)*100)/@n) AS 'percent histogram'</code></strong>
    -&gt; <strong><code>FROM testscore GROUP BY score;</code></strong>
+-------+---------------------------+
| score | percent histogram         |
+-------+---------------------------+
|     4 | **********                |
|     5 | *****                     |
|     6 | ********************      |
|     7 | ********************      |
|     8 | **********                |
|     9 | ************************* |
|    10 | **********                |
+-------+---------------------------+</pre><p>The ASCII chart method is crude, obviously, but it’s a quick way
      to get a picture of the distribution of observations and requires no
      other tools.</p><p>If you generate a frequency distribution for a range of categories
      where some of the categories are not represented in your observations,
      the missing categories do not appear in the output. To force each
      category to be displayed, use a reference table and a <code>LEFT</code> <code>JOIN</code>
      (a technique discussed in <a data-type="xref" href="ch16.xhtml#nch-multi-multi-fill-hole">Recipe 16.8</a>).
      For the <code>testscore</code> table, the possible
      scores range from 0 to 10, so a reference table should contain each of
      those values:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE ref (score INT);</code></strong>
mysql&gt; <strong><code>INSERT INTO ref (score)</code></strong>
    -&gt; <strong><code>VALUES(0),(1),(2),(3),(4),(5),(6),(7),(8),(9),(10);</code></strong></pre><p>Then join the reference table to the test scores to generate the
      frequency distribution. This query shows the counts as well as the
      histogram:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ref.score, COUNT(testscore.score) AS counts,</code></strong>
    -&gt; <strong><code>REPEAT('*',COUNT(testscore.score)) AS 'count histogram'</code></strong>
    -&gt; <strong><code>FROM ref LEFT JOIN testscore ON ref.score = testscore.score</code></strong>
    -&gt; <strong><code>GROUP BY ref.score;</code></strong>
+-------+--------+-----------+
| score | counts | histogram |
+-------+--------+-----------+
|     0 |      0 |           |
|     1 |      0 |           |
|     2 |      0 |           |
|     3 |      0 |           |
|     4 |      2 | **        |
|     5 |      1 | *         |
|     6 |      4 | ****      |
|     7 |      4 | ****      |
|     8 |      2 | **        |
|     9 |      5 | *****     |
|    10 |      2 | **        |
+-------+--------+-----------+</pre><p>This distribution includes rows for scores 0 through 3, none of
      which appear in the frequency distribution shown earlier.</p><p>The same principle applies to relative frequency distributions:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @n = (SELECT COUNT(score) FROM testscore);</code></strong>
mysql&gt; <strong><code>SELECT ref.score, (COUNT(testscore.score)*100)/@n AS percent,</code></strong>
    -&gt; <strong><code>REPEAT('*',(COUNT(testscore.score)*100)/@n) AS 'percent histogram'</code></strong>
    -&gt; <strong><code>FROM ref LEFT JOIN testscore ON ref.score = testscore.score</code></strong>
    -&gt; <strong><code>GROUP BY ref.score;</code></strong>
+-------+---------+---------------------------+
| score | percent | percent histogram         |
+-------+---------+---------------------------+
|     0 |  0.0000 |                           |
|     1 |  0.0000 |                           |
|     2 |  0.0000 |                           |
|     3 |  0.0000 |                           |
|     4 | 10.0000 | **********                |
|     5 |  5.0000 | *****                     |
|     6 | 20.0000 | ********************      |
|     7 | 20.0000 | ********************      |
|     8 | 10.0000 | **********                |
|     9 | 25.0000 | ************************* |
|    10 | 10.0000 | **********                |
+-------+---------+---------------------------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.4 Counting Missing Values"><div class="sect1" id="nch-stats-stats-missing"><h1>17.4 Counting Missing Values</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337907472"><h2>Problem</h2><p>A set of observations is incomplete. You want to find out how many values are missing.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337906464"><h2>Solution</h2><p>Count the number of <code>NULL</code> values
      in the set.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337904976"><h2>Discussion</h2><p>Values can be missing from a set of observations for any number of
      reasons: a test may not yet have been administered, something may have
      gone wrong during the test that requires invalidating the observation,
      and so forth. You can represent such observations in a dataset as
      <code>NULL</code> values to signify that they’re
      missing or otherwise invalid, then use summary statements to
      characterize the completeness of the dataset.</p><p>If a table <code>testscore_withmisses</code> contains values to
      be summarized along a single dimension, a simple summary suffices to
      characterize the missing values. Suppose that <code>testscore_withmisses</code> looks like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT subject, score FROM testscore_withmisses ORDER BY subject;</code></strong>
+---------+-------+
| subject | score |
+---------+-------+
|       1 |    38 |
|       2 |  NULL |
|       3 |    47 |
|       4 |  NULL |
|       5 |    37 |
|       6 |    45 |
|       7 |    54 |
|       8 |  NULL |
|       9 |    40 |
|      10 |    49 |
+---------+-------+</pre><p><code>COUNT(*)</code> counts the total number of rows, and <code>COUNT(score)</code> counts the number of nonmissing
      scores. The difference between the two values is the number of missing
      scores, and that difference in relation to the total provides the
      percentage of missing scores. Perform these calculations as
      follows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) AS 'n (total)',</code></strong>
    -&gt; <strong><code>COUNT(score) AS 'n (nonmissing)',</code></strong>
    -&gt; <strong><code>COUNT(*) - COUNT(score) AS 'n (missing)',</code></strong>
    -&gt; <strong><code>((COUNT(*) - COUNT(score)) * 100) / COUNT(*) AS '% missing'</code></strong>
    -&gt; <strong><code>FROM testscore_withmisses;</code></strong>
+-----------+----------------+-------------+-----------+
| n (total) | n (nonmissing) | n (missing) | % missing |
+-----------+----------------+-------------+-----------+
|        10 |              7 |           3 |   30.0000 |
+-----------+----------------+-------------+-----------+</pre><p>As an alternative to counting <code>NULL</code> values as the difference between counts,
      count them directly using <code>SUM(ISNULL(score))</code>. The <code>ISNULL()</code> function
      returns 1 if its argument is <code>NULL</code>, zero otherwise:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(*) AS 'n (total)',</code></strong>
    -&gt; <strong><code>COUNT(score) AS 'n (nonmissing)',</code></strong>
    -&gt; <strong><code>SUM(ISNULL(score)) AS 'n (missing)',</code></strong>
    -&gt; <strong><code>(SUM(ISNULL(score)) * 100) / COUNT(*) AS '% missing'</code></strong>
    -&gt; <strong><code>FROM testscore_withmisses;</code></strong>
+-----------+----------------+-------------+-----------+
| n (total) | n (nonmissing) | n (missing) | % missing |
+-----------+----------------+-------------+-----------+
|        10 |              7 |           3 |   30.0000 |
+-----------+----------------+-------------+-----------+</pre><p>If values are arranged in groups, occurrences of <code>NULL</code> values can be assessed on a per-group
      basis. Suppose that <code>testscore_withmisses2</code> contains scores
      for subjects that are distributed among conditions for two factors A and
      B, each of which has two levels:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT subject, A, B, score FROM testscore_withmisses2 ORDER BY subject;</code></strong>
+---------+------+------+-------+
| subject | A    | B    | score |
+---------+------+------+-------+
|       1 |    1 |    1 |    18 |
|       2 |    1 |    1 |  NULL |
|       3 |    1 |    1 |    23 |
|       4 |    1 |    1 |    24 |
|       5 |    1 |    2 |    17 |
|       6 |    1 |    2 |    23 |
|       7 |    1 |    2 |    29 |
|       8 |    1 |    2 |    32 |
|       9 |    2 |    1 |    17 |
|      10 |    2 |    1 |  NULL |
|      11 |    2 |    1 |  NULL |
|      12 |    2 |    1 |    25 |
|      13 |    2 |    2 |  NULL |
|      14 |    2 |    2 |    33 |
|      15 |    2 |    2 |    34 |
|      16 |    2 |    2 |    37 |
+---------+------+------+-------+</pre><p>To produce a summary for each combination of conditions,
      use a <code>GROUP</code> <code>BY</code> clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT A, B, COUNT(*) AS 'n (total)',</code></strong>
    -&gt; <strong><code>COUNT(score) AS 'n (nonmissing)',</code></strong>
    -&gt; <strong><code>COUNT(*) - COUNT(score) AS 'n (missing)',</code></strong>
    -&gt; <strong><code>((COUNT(*) - COUNT(score)) * 100) / COUNT(*) AS '% missing'</code></strong>
    -&gt; <strong><code>FROM testscore_withmisses2</code></strong>
    -&gt; <strong><code>GROUP BY A, B;</code></strong>
+------+------+-----------+----------------+-------------+-----------+
| A    | B    | n (total) | n (nonmissing) | n (missing) | % missing |
+------+------+-----------+----------------+-------------+-----------+
|    1 |    1 |         4 |              3 |           1 |   25.0000 |
|    1 |    2 |         4 |              4 |           0 |    0.0000 |
|    2 |    1 |         4 |              2 |           2 |   50.0000 |
|    2 |    2 |         4 |              3 |           1 |   25.0000 |
+------+------+-----------+----------------+-------------+-----------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.5 Calculating Linear Regressions or Correlation Coefficients"><div class="sect1" id="nch-stats-stats-regress"><h1>17.5 Calculating Linear Regressions or Correlation Coefficients</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337881328"><h2>Problem</h2><p>You want to calculate the least-squares regression line for two
      variables or the correlation coefficient that expresses the strength of
      the relationship between them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337880368"><h2>Solution</h2><p>Apply summary functions to make these calculations.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337879360"><h2>Discussion</h2><p>When the data values for two variables X and Y are stored in a
      database, the least-squares regression for them can be calculated easily
      using aggregate functions. The same is true for the correlation
      coefficient. The two calculations are actually fairly similar, and many
      terms for performing the computations are common to the two
      procedures.</p><p>Suppose that you want to calculate a least-squares regression
      using the age and test score values for the observations in the <code>testscore</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT age, score FROM testscore;</code></strong>
+-----+-------+
| age | score |
+-----+-------+
|   5 |     5 |
|   5 |     4 |
|   5 |     6 |
|   5 |     7 |
|   6 |     8 |
|   6 |     9 |
|   6 |     4 |
|   6 |     6 |
|   7 |     8 |
|   7 |     6 |
|   7 |     9 |
|   7 |     7 |
|   8 |     9 |
|   8 |     6 |
|   8 |     7 |
|   8 |    10 |
|   9 |     9 |
|   9 |     7 |
|   9 |    10 |
|   9 |     9 |
+-----+-------+</pre><p>The following equation expresses the regression line, where
      <code>a</code> and <code>b</code> are the intercept and slope of the
      line:</p><pre data-type="programlisting"><em><code>Y</code></em> = <em><code>bX</code></em> + <em><code>a</code></em></pre><p>Letting <code>age</code> be
      <em><code>X</code></em> and <code>score</code> be <em><code>Y</code></em>, begin
      by computing the terms needed for the regression equation. These include
      the number of observations; the means, sums, and sums of squares for
      each variable; and the sum of the products of each variable:<sup><a data-type="noteref" id="idm45820337870752-marker" href="ch17.xhtml#idm45820337870752">2</a></sup></p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT COUNT(score), AVG(age), SUM(age), SUM(age*age), </code></strong>
    -&gt; <strong><code>AVG(score), SUM(score), SUM(score*score), SUM(age*score)</code></strong>
    -&gt; <strong><code>INTO @n, @meanX, @sumX, @sumXX, @meanY, @sumY, @sumYY, @sumXY</code></strong>
    -&gt; <strong><code>FROM testscore;</code></strong>
Query OK, 1 row affected (0,00 sec)

mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>@n AS N,</code></strong>
    -&gt; <strong><code>@meanX AS 'X mean',</code></strong>
    -&gt; <strong><code>@sumX AS 'X sum',</code></strong>
    -&gt; <strong><code>@sumXX AS 'X sum of squares',</code></strong>
    -&gt; <strong><code>@meanY AS 'Y mean',</code></strong>
    -&gt; <strong><code>@sumY AS 'Y sum',</code></strong>
    -&gt; <strong><code>@sumYY AS 'Y sum of squares',</code></strong>
    -&gt; <strong><code>@sumXY AS 'X*Y sum'</code></strong>
    -&gt; <strong><code>FROM testscore\G</code></strong>
*************************** 1. row ***************************
               N: 20
          X mean: 7.000000000
           X sum: 140
X sum of squares: 1020
          Y mean: 7.300000000
           Y sum: 146
Y sum of squares: 1130
         X*Y sum: 1053</pre><p>From those terms, calculate the regression slope and intercept as
      follows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @b := (@n*@sumXY - @sumX*@sumY) / (@n*@sumXX - @sumX*@sumX);</code></strong>
mysql&gt; <strong><code>SET @a := (@meanY - @b*@meanX);</code></strong>
mysql&gt; <strong><code>SELECT @b AS slope, @a AS intercept;</code></strong>
+-------------+----------------------+
| slope       | intercept            |
+-------------+----------------------+
| 0.775000000 | 1.875000000000000000 |
+-------------+----------------------+</pre><p>The regression equation then is:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CONCAT('Y = ',@b,'X + ',@a) AS 'least-squares regression';</code></strong>
+-----------------------------------------+
| least-squares regression                |
+-----------------------------------------+
| Y = 0.775000000X + 1.875000000000000000 |
+-----------------------------------------+</pre><p>To compute the correlation coefficient, use many of the same terms:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>(@n*@sumXY - @sumX*@sumY)</code></strong>
    -&gt; <strong><code>/ SQRT((@n*@sumXX - @sumX*@sumX) * (@n*@sumYY - @sumY*@sumY))</code></strong>
    -&gt; <strong><code>AS correlation;</code></strong>
+--------------------+
| correlation        |
+--------------------+
| 0.6117362044219903 |
+--------------------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.6 Generating Random Numbers"><div class="sect1" id="nch-stats-stats-rand-num"><h1>17.6 Generating Random Numbers</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337852544"><h2>Problem</h2><p>You need a source of random numbers.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337851552"><h2>Solution</h2><p>Use the <code>RAND()</code> function.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337850160"><h2>Discussion</h2><p>MySQL has a <code>RAND()</code> function
      that produces random numbers between 0 and 1:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT RAND(), RAND(), RAND();</code></strong>
+---------------------+--------------------+---------------------+
| RAND()              | RAND()             | RAND()              |
+---------------------+--------------------+---------------------+
| 0.37415416573561183 | 0.9068914557871329 | 0.41199481246247405 |
+---------------------+--------------------+---------------------+</pre><p>When invoked with an integer argument, <code>RAND()</code> uses that value to seed the random
      number generator. You can use this feature to produce a repeatable
      series of numbers for a column of a query result. The following example
      shows that <code>RAND()</code> without an argument
      produces a different column of values per query, whereas <code>RAND(</code><em><code>N</code></em><code>)</code> produces a repeatable column:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT i, RAND(), RAND(10), RAND(20) FROM numbers;</code></strong>
+------+---------------------+---------------------+---------------------+
| i    | RAND()              | RAND(10)            | RAND(20)            |
+------+---------------------+---------------------+---------------------+
|    1 | 0.00708185882035816 |  0.6570515219653505 | 0.15888261251047497 |
|    2 |  0.5417692908474889 | 0.12820613023657923 |  0.6355305003333189 |
|    3 |  0.6876009085100152 |  0.6698761160204896 |  0.7010046948688149 |
|    4 |  0.8126967007412544 |  0.9647622201263553 |  0.5984320040777623 |
+------+---------------------+---------------------+---------------------+
mysql&gt; <strong><code>SELECT i, RAND(), RAND(10), RAND(20) FROM numbers;</code></strong>
+------+----------------------+---------------------+---------------------+
| i    | RAND()               | RAND(10)            | RAND(20)            |
+------+----------------------+---------------------+---------------------+
|    1 | 0.059957268703689115 |  0.6570515219653505 | 0.15888261251047497 |
|    2 |   0.9068000166740269 | 0.12820613023657923 |  0.6355305003333189 |
|    3 |  0.35412830799271194 |  0.6698761160204896 |  0.7010046948688149 |
|    4 | 0.050241520675124156 |  0.9647622201263553 |  0.5984320040777623 |
+------+----------------------+---------------------+---------------------+</pre><p>To seed <code>RAND()</code> randomly, pick a
      seed value based on a source of entropy. Possible sources are the
      current timestamp or connection identifier, alone or perhaps in
      combination:</p><pre data-type="programlisting">RAND(UNIX_TIMESTAMP())
RAND(CONNECTION_ID())
RAND(UNIX_TIMESTAMP()+CONNECTION_ID())</pre><p>However, it’s probably better to use other seed value sources if
      you have them. For example, if your system has a <em class="filename">/dev/random</em> or <em class="filename">/dev/urandom</em> device, read the device and use
      it to generate a value for seeding <code>RAND()</code>.</p><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820337839504"><h5>How Random Is RAND()?</h5><p>Does the <code>RAND()</code> function
        generate evenly distributed numbers? Check it out for yourself with
        the following Python script, <span class="command"><em>rand_test.py</em></span>, from the <em class="filename">stats</em> directory of the <code>recipes</code> distribution. (That directory also
        contains equivalent scripts in other languages.) The script uses
        <code>RAND()</code> to generate random numbers
        and constructs a frequency distribution from them, using 10 categories
        (<q>buckets</q>). This provides a means of assessing how
        evenly distributed the values are:</p><pre data-type="programlisting" data-code-language="python"><code class="ch">#!/usr/bin/python</code>
<code class="c1"># rand_test.pl: create a frequency distribution of RAND() values.</code>
<code class="c1"># This provides a test of the randomness of RAND().</code>

<code class="c1"># Method: Draw random numbers in the range from 0 to 1.0,</code>
<code class="c1"># and count how many of them occur in .1-sized intervals</code>

<code class="kn">import</code> <code class="nn">cookbook</code>

<code class="n">npicks</code> <code class="o">=</code> <code class="mi">1000</code>     <code class="c1"># number of times to pick a number</code>
<code class="n">bucket</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">*</code> <code class="mi">10</code> <code class="c1"># buckets for counting picks in each interval</code>

<code class="n">conn</code> <code class="o">=</code> <code class="n">cookbook</code><code class="o">.</code><code class="n">connect</code><code class="p">()</code>
<code class="n">cursor</code> <code class="o">=</code> <code class="n">conn</code><code class="o">.</code><code class="n">cursor</code><code class="p">()</code>

<code class="k">for</code> <code class="n">i</code> <code class="ow">in</code> <code class="nb">range</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="n">npicks</code><code class="p">):</code>
  <code class="n">cursor</code><code class="o">.</code><code class="n">execute</code><code class="p">(</code><code class="s2">"SELECT RAND()"</code><code class="p">)</code>
  <code class="p">(</code><code class="n">val</code><code class="p">,)</code> <code class="o">=</code> <code class="n">cursor</code><code class="o">.</code><code class="n">fetchone</code><code class="p">()</code>
  <code class="n">slot</code> <code class="o">=</code> <code class="nb">int</code><code class="p">(</code><code class="n">val</code> <code class="o">*</code> <code class="mi">10</code><code class="p">)</code>
  <code class="k">if</code> <code class="n">slot</code> <code class="o">&gt;</code> <code class="mi">9</code><code class="p">:</code>
    <code class="n">slot</code> <code class="o">=</code> <code class="mi">9</code>    <code class="c1"># put 1.0 in last slot</code>
  <code class="n">bucket</code><code class="p">[</code><code class="n">slot</code><code class="p">]</code> <code class="o">+=</code> <code class="mi">1</code>

<code class="n">cursor</code><code class="o">.</code><code class="n">close</code><code class="p">()</code>
<code class="n">conn</code><code class="o">.</code><code class="n">close</code><code class="p">()</code>

<code class="c1"># Print the resulting frequency distribution</code>

<code class="k">for</code> <code class="n">slot</code><code class="p">,</code> <code class="n">val</code> <code class="ow">in</code> <code class="nb">enumerate</code><code class="p">(</code><code class="n">bucket</code><code class="p">):</code>
  <code class="k">print</code><code class="p">(</code><code class="s2">"</code><code class="si">%2d</code><code class="s2">  </code><code class="si">%d</code><code class="s2">"</code> <code class="o">%</code> <code class="p">(</code><code class="n">slot</code><code class="o">+</code><code class="mi">1</code><code class="p">,</code> <code class="n">val</code><code class="p">))</code></pre></div></aside></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.7 Randomizing a Set of Rows"><div class="sect1" id="nch-stats-stats-rand-rows"><h1>17.7 Randomizing a Set of Rows</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337830640"><h2>Problem</h2><p>You want to randomize a set of rows or values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337829760"><h2>Solution</h2><p>Use <code>ORDER</code> <code>BY</code> <code>RAND()</code>.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337769616"><h2>Discussion</h2><p>MySQL’s <code>RAND()</code> function
      can be used to randomize the order in which a query
      returns its rows. Somewhat paradoxically, this randomization is achieved
      by adding an <code>ORDER</code> <code>BY</code> clause to the query. The technique is
      roughly equivalent to a spreadsheet randomization method. Suppose that a
      spreadsheet contains this set of values:</p><pre data-type="programlisting">Patrick
Penelope
Pertinax
Polly</pre><p>To place these in random order, first add another column that
      contains randomly chosen numbers:</p><pre data-type="programlisting">Patrick            .73
Penelope           .37
Pertinax           .16
Polly              .48</pre><p>Then sort the rows according to the values of the random
      numbers:</p><pre data-type="programlisting">Pertinax           .16
Penelope           .37
Polly              .48
Patrick            .73</pre><p>At this point, the original values have been placed in random
      order; the effect of sorting the random numbers is to randomize the
      values associated with them. To rerandomize the values, choose another
      set of random numbers, and sort the rows again.</p><p>In MySQL, achieve a similar effect by associating a set of random
      numbers with a query result and sorting the result by those numbers. To
      do this, add an <code>ORDER</code> <code>BY</code> <code>RAND()</code>
      clause:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name FROM rand_names ORDER BY RAND();</code></strong>
+----------+
| name     |
+----------+
| Pertinax |
| Patrick  |
| Polly    |
| Penelope |
+----------+
mysql&gt; <strong><code>SELECT name FROM rand_names ORDER BY RAND();</code></strong>
+----------+
| name     |
+----------+
| Polly    |
| Pertinax |
| Penelope |
| Patrick  |
+----------+</pre><p>Applications for randomizing a set of rows include any scenario
      that uses selection without replacement (choosing each item from a set
      of items until there are no more items left). Some examples of this
      are:</p><ul><li><p>Determining the starting order for participants in an event.
          List the participants in a table, and select them in random
          order.</p></li><li><p>Assigning starting lanes or gates to participants in a race.
          List the lanes in a table, and select a random lane order.</p></li><li><p>Choosing the order in which to present a set of quiz
          questions.</p></li><li><p>Shuffling a deck of cards. Represent each card by a row in a
          table, and shuffle the deck by selecting the rows in random order.
          Deal them one by one until the deck is exhausted.</p></li></ul><p>To use the last example as an illustration, let’s implement a card
      deck-shuffling algorithm. Shuffling and dealing cards is randomization
      plus selection without replacement: each card is dealt once before any
      is dealt twice; when the deck is used up, it is reshuffled to
      rerandomize it for a new dealing order. Within a program, this task can
      be performed with MySQL using a table named <code>deck</code> that has 52 rows, assuming a set of cards
      with each combination of 13 face values and 4 suits:</p><ol><li><p>Select the entire table, and store it into an array.</p></li><li><p>Each time a card is needed, take the next element from the
          array.</p></li><li><p>When the array is exhausted, all the cards have been dealt.
          <q>Reshuffle</q> the table to generate a new card
          order.</p></li></ol><p>Setting up the <code>deck</code> table is a
      tedious task if you insert the 52 card records by writing all the
      <code>INSERT</code> statements manually. The
      <code>deck</code> contents can be generated more
      easily in combinatorial fashion within a program by generating each
      pairing of face value with suit. Here’s some PHP code that creates a <code>deck</code> table with <code>face</code> and <code>suit</code> columns, then populates the table using
      nested loops to generate the pairings for the <code>INSERT</code> statements:</p><pre data-type="programlisting" data-code-language="php"><code class="nv">$sth</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="na">exec</code> <code class="p">(</code><code class="s2">"DROP TABLE IF EXISTS deck"</code><code class="p">);</code>

<code class="nv">$sth</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="na">exec</code> <code class="p">(</code><code class="s2">"</code>
<code class="s2">  CREATE TABLE deck</code>
<code class="s2">  (</code>
<code class="s2">    face  ENUM('A', 'K', 'Q', 'J', '10', '9', '8',</code>
<code class="s2">               '7', '6', '5', '4', '3', '2') NOT NULL,</code>
<code class="s2">    suit  ENUM('hearts', 'diamonds', 'clubs', 'spades') NOT NULL</code>
<code class="s2">  )</code>
<code class="s2">"</code><code class="p">);</code>

<code class="nv">$face_array</code> <code class="o">=</code> <code class="k">array</code> <code class="p">(</code><code class="s2">"A"</code><code class="p">,</code> <code class="s2">"K"</code><code class="p">,</code> <code class="s2">"Q"</code><code class="p">,</code> <code class="s2">"J"</code><code class="p">,</code> <code class="s2">"10"</code><code class="p">,</code> <code class="s2">"9"</code><code class="p">,</code> <code class="s2">"8"</code><code class="p">,</code>
                     <code class="s2">"7"</code><code class="p">,</code> <code class="s2">"6"</code><code class="p">,</code> <code class="s2">"5"</code><code class="p">,</code> <code class="s2">"4"</code><code class="p">,</code> <code class="s2">"3"</code><code class="p">,</code> <code class="s2">"2"</code><code class="p">);</code>
<code class="nv">$suit_array</code> <code class="o">=</code> <code class="k">array</code> <code class="p">(</code><code class="s2">"hearts"</code><code class="p">,</code> <code class="s2">"diamonds"</code><code class="p">,</code> <code class="s2">"clubs"</code><code class="p">,</code> <code class="s2">"spades"</code><code class="p">);</code>

<code class="c1"># insert a "card" into the deck for each combination of suit and face</code>

<code class="nv">$sth</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="na">prepare</code> <code class="p">(</code><code class="s2">"INSERT INTO deck (face,suit) VALUES(?,?)"</code><code class="p">);</code>
<code class="k">foreach</code> <code class="p">(</code><code class="nv">$face_array</code> <code class="k">as</code> <code class="nv">$face</code><code class="p">)</code>
  <code class="k">foreach</code> <code class="p">(</code><code class="nv">$suit_array</code> <code class="k">as</code> <code class="nv">$suit</code><code class="p">)</code>
    <code class="nv">$sth</code><code class="o">-&gt;</code><code class="na">execute</code> <code class="p">(</code><code class="k">array</code> <code class="p">(</code><code class="nv">$face</code><code class="p">,</code> <code class="nv">$suit</code><code class="p">));</code></pre><p>Shuffling the cards is a matter of issuing this statement:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="n">face</code><code class="p">,</code> <code class="n">suit</code> <code class="k">FROM</code> <code class="n">deck</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">RAND</code><code class="p">();</code></pre><p>To do that and store the results in an array within a script,
      write a <code>shuffle_deck()</code> function that
      issues the query and returns the resulting values in an array (again
      shown in PHP):</p><pre data-type="programlisting" data-code-language="php"><code class="k">function</code> <code class="nf">shuffle_deck</code> <code class="p">(</code><code class="nv">$dbh</code><code class="p">)</code>
<code class="p">{</code>
  <code class="nv">$sth</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="na">query</code> <code class="p">(</code><code class="s2">"SELECT face, suit FROM deck ORDER BY RAND()"</code><code class="p">);</code>
  <code class="nv">$sth</code><code class="o">-&gt;</code><code class="na">setFetchMode</code> <code class="p">(</code><code class="nx">PDO</code><code class="o">::</code><code class="na">FETCH_OBJ</code><code class="p">);</code>
  <code class="k">return</code> <code class="p">(</code><code class="nv">$sth</code><code class="o">-&gt;</code><code class="na">fetchAll</code> <code class="p">());</code>
<code class="p">}</code></pre><p>Deal the cards by keeping a counter that ranges from 0 to 51 to
      indicate which card to select. When the counter reaches 52, the deck is
      exhausted and should be shuffled again.</p><div data-type="warning" epub:type="warning"><h6>Warning</h6><p>
            Use this method only for tables with small number of rows. Ordering by <code>RAND()</code> does not allow MySQL to use indexes to resolve <code>ORDER BY</code>, therefore such queries will be slow on large tables.
          </p></div></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.8 Selecting Random Items from a Set of Rows"><div class="sect1" id="nch-stats-stats-rand-items"><h1>17.8 Selecting Random Items from a Set of Rows</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337528752"><h2>Problem</h2><p>You want to pick an item or items randomly from a set of values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337527872"><h2>Solution</h2><p>Randomize the values, then pick the first one (or the first few,
      if you need more than one).</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337526816"><h2>Discussion</h2><p>If a set of items is stored in MySQL, choose one at random as
      follows:</p><ol><li><p>Select the items in the set in random order, using <code>ORDER</code>
          <code>BY</code> <code>RAND()</code> as described in <a data-type="xref" href="#nch-stats-stats-rand-rows">Recipe 17.7</a>.</p></li><li><p>Add <code>LIMIT</code> <code>1</code> to the query to pick the first item.</p></li></ol><p>For example, to perform a simple simulation of tossing a die,
      create a <code>die</code> table containing rows
      with values from 1 to 6 corresponding to the six faces of a die
      cube:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">die</code> <code class="p">(</code><code class="n">n</code> <code class="nb">INT</code><code class="err">\</code><code class="p">);</code></pre><p>Then pick rows from the table at random:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT n FROM die ORDER BY RAND() LIMIT 1;</code></strong>
+------+
| n    |
+------+
|    6 |
+------+
mysql&gt; <strong><code>SELECT n FROM die ORDER BY RAND() LIMIT 1;</code></strong>
+------+
| n    |
+------+
|    4 |
+------+
mysql&gt; <strong><code>SELECT n FROM die ORDER BY RAND() LIMIT 1;</code></strong>
+------+
| n    |
+------+
|    5 |
+------+
mysql&gt; <strong><code>SELECT n FROM die ORDER BY RAND() LIMIT 1;</code></strong>
+------+
| n    |
+------+
|    4 |
+------+</pre><p>As you repeat this operation, you pick a random sequence of items
      from the set. This is a form of selection with replacement: an item is
      chosen from a pool of items and then returned to the pool for the next
      pick. Because items are replaced, it’s possible to pick the same item
      multiple times when making successive choices this way. Other examples
      of selection with replacement include:</p><ul><li><p>Selecting a banner ad to display on a web page</p></li><li><p>Picking a row for a <q>quote of the day</q>
          application</p></li><li><p><q>Pick a card, any card</q> magic tricks that begin
          with a full deck of cards each time</p></li></ul><p>To pick more than one item, change the <code>LIMIT</code> argument. For example, to draw five
      winning entries at random from a table named <code>drawing</code> that contains contest entries, use
      <code>RAND()</code> in combination with <code>LIMIT</code>:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">drawing</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">RAND</code><code class="p">()</code> <code class="k">LIMIT</code> <code class="mi">5</code><code class="p">;</code></pre><p>A special case occurs when you pick a single row from a table that
      you know contains a column with values in the range from 1 to
      <em><code>n</code></em> in unbroken sequence. Under these
      circumstances, it’s possible to avoid performing an <code>ORDER</code> <code>BY</code>
      operation on the entire table. Pick a random number in that range and
      select the matching row:</p><pre data-type="programlisting" data-code-language="sql">SET @id = FLOOR(RAND()*<em><code>n</code></em>)+1;
SELECT ... FROM <em><code>tbl_name</code></em> WHERE id = @id;</pre><p>This is much quicker than <code>ORDER</code>
      <code>BY</code> <code>RAND()</code> <code>LIMIT</code> <code>1</code> as
      the table size increases.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.9 Calculating Successive-Row Differences"><div class="sect1" id="nch-stats-stats-abs-to-rel"><h1>17.9 Calculating Successive-Row Differences</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337333936"><h2>Problem</h2><p>A table contains successive cumulative values in its rows, and you want to compute the
      differences between pairs of successive rows.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337332800"><h2>Solution</h2><p>Use a self-join that matches pairs of adjacent rows and calculates the
      differences between members of each pair.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337312400"><h2>Discussion</h2><p>Self-joins are useful when you have a set of absolute (or cumulative) values that you want to convert
      to relative values representing the differences between successive pairs
      of rows. For example, if you take an automobile trip and write down the
      total miles traveled at each stopping point, you can compute the
      difference between successive points to determine the distance from one
      stop to the next. Here is such a table that shows the stops for a trip
      from San Antonio, Texas to Madison, Wisconsin. Each row shows the total
      miles driven as of each stop:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT seq, city, miles FROM trip_log ORDER BY seq;</code></strong>
+-----+------------------+-------+
| seq | city             | miles |
+-----+------------------+-------+
|   1 | San Antonio, TX  |     0 |
|   2 | Dallas, TX       |   263 |
|   3 | Benton, AR       |   566 |
|   4 | Memphis, TN      |   745 |
|   5 | Portageville, MO |   878 |
|   6 | Champaign, IL    |  1164 |
|   7 | Madison, WI      |  1412 |
+-----+------------------+-------+</pre><p>A self-join can convert these cumulative values to successive
      differences that represent the distances from each city to the next. The
      following statement shows how to use the sequence numbers in the rows to
      match pairs of successive rows and compute the differences between each
      pair of mileage values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1.seq AS seq1, t2.seq AS seq2,</code></strong>
    -&gt; <strong><code>t1.city AS city1, t2.city AS city2,</code></strong>
    -&gt; <strong><code>t1.miles AS miles1, t2.miles AS miles2,</code></strong>
    -&gt; <strong><code>t2.miles-t1.miles AS dist</code></strong>
    -&gt; <strong><code>FROM trip_log AS t1 INNER JOIN trip_log AS t2</code></strong>
    -&gt; <strong><code>ON t1.seq+1 = t2.seq</code></strong>
    -&gt; <strong><code>ORDER BY t1.seq;</code></strong>
+------+------+------------------+------------------+--------+--------+------+
| seq1 | seq2 | city1            | city2            | miles1 | miles2 | dist |
+------+------+------------------+------------------+--------+--------+------+
|    1 |    2 | San Antonio, TX  | Dallas, TX       |      0 |    263 |  263 |
|    2 |    3 | Dallas, TX       | Benton, AR       |    263 |    566 |  303 |
|    3 |    4 | Benton, AR       | Memphis, TN      |    566 |    745 |  179 |
|    4 |    5 | Memphis, TN      | Portageville, MO |    745 |    878 |  133 |
|    5 |    6 | Portageville, MO | Champaign, IL    |    878 |   1164 |  286 |
|    6 |    7 | Champaign, IL    | Madison, WI      |   1164 |   1412 |  248 |
+------+------+------------------+------------------+--------+--------+------+</pre><p>The presence of the <code>seq</code> column
      in the <code>trip_log</code> table is important
      for calculating successive difference values. It’s needed for
      establishing which row precedes another and matching each row
      <em><code>n</code></em> with row
      <em><code>n</code></em><code>+1</code>. The
      implication is that to perform relative-difference calculations using a
      table of absolute or cumulative values, it must include a sequence
      column that has no gaps. If the table contains a sequence column but
      there are gaps, renumber it (see <a data-type="xref" href="ch15.xhtml#nch-sequences-seq-reseq">Recipe 15.5</a>). If the table contains no such
      column, add one (see <a data-type="xref" href="ch15.xhtml#nch-sequences-seq-add-seq">Recipe 15.9</a>).</p><p>A more complex situation occurs when you compute successive
      differences for more than one column and use the results in a
      calculation. The following table, <code>player_stats</code>, shows some cumulative numbers
      for a baseball player at the end of each month of his season. <code>ab</code> indicates the total at-bats, and <code>h</code> the total hits the player has had as of a
      given date. (The first row indicates the starting point of the player’s
      season, which is why the <code>ab</code> and
      <code>h</code> values are zero.)</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT id, date, ab, h, TRUNCATE(IFNULL(h/ab,0),3) AS ba</code></strong>
    -&gt; <strong><code>FROM player_stats ORDER BY id;</code></strong>
+----+------------+-----+----+-------+
| id | date       | ab  | h  | ba    |
+----+------------+-----+----+-------+
|  1 | 2013-04-30 |   0 |  0 | 0.000 |
|  2 | 2013-05-31 |  38 | 13 | 0.342 |
|  3 | 2013-06-30 | 109 | 31 | 0.284 |
|  4 | 2013-07-31 | 196 | 49 | 0.250 |
|  5 | 2013-08-31 | 304 | 98 | 0.322 |
+----+------------+-----+----+-------+</pre><p>The last column of the query result also shows the player’s
      batting average as of each date. This column is not stored in the table
      but is easily computed as the ratio of hits to at-bats. The result
      provides a general idea of how the player’s hitting performance changed
      over the course of the season, but it provides no picture of how the
      player did during each individual month. To determine that, calculate
      relative differences between pairs of rows. This is easily done with a
      self-join that matches row <em><code>n</code></em> with row
      <em><code>n</code></em><code>+1</code> to
      calculate differences between pairs of at-bats and hits values. These
      differences enable computation of batting average during each
      month:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>t1.id AS id1, t2.id AS id2,</code></strong>
    -&gt; <strong><code>t2.date,</code></strong>
    -&gt; <strong><code>t1.ab AS ab1, t2.ab AS ab2,</code></strong>
    -&gt; <strong><code>t1.h AS h1, t2.h AS h2,</code></strong>
    -&gt; <strong><code>t2.ab-t1.ab AS abdiff,</code></strong>
    -&gt; <strong><code>t2.h-t1.h AS hdiff,</code></strong>
    -&gt; <strong><code>TRUNCATE(IFNULL((t2.h-t1.h)/(t2.ab-t1.ab),0),3) AS ba</code></strong>
    -&gt; <strong><code>FROM player_stats AS t1 INNER JOIN player_stats AS t2</code></strong>
    -&gt; <strong><code>ON t1.id+1 = t2.id</code></strong>
    -&gt; <strong><code>ORDER BY t1.id;</code></strong>
+-----+-----+------------+-----+-----+----+----+--------+-------+-------+
| id1 | id2 | date       | ab1 | ab2 | h1 | h2 | abdiff | hdiff | ba    |
+-----+-----+------------+-----+-----+----+----+--------+-------+-------+
|   1 |   2 | 2013-05-31 |   0 |  38 |  0 | 13 |     38 |    13 | 0.342 |
|   2 |   3 | 2013-06-30 |  38 | 109 | 13 | 31 |     71 |    18 | 0.253 |
|   3 |   4 | 2013-07-31 | 109 | 196 | 31 | 49 |     87 |    18 | 0.206 |
|   4 |   5 | 2013-08-31 | 196 | 304 | 49 | 98 |    108 |    49 | 0.453 |
+-----+-----+------------+-----+-----+----+----+--------+-------+-------+</pre><p>These results show much more clearly than the original table that
      the player started off well but had a slump in the middle of the season,
      particularly in July. They also indicate just how strong his performance
      was in August.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.10 Finding Cumulative Sums and Running Averages"><div class="sect1" id="nch-stats-stats-rel-to-abs"><h1>17.10 Finding Cumulative Sums and Running Averages</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337285488"><h2>Problem</h2><p>You have a set of observations measured over time and want to compute the
      cumulative sum of the observations at each measurement point. Or you
      want to compute a running average at each point.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337284576"><h2>Solution</h2><p>Use a self-join to produce the sets of successive observations at each
      measurement point, then apply aggregate functions to each set of values
      to compute its sum or average.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337283632"><h2>Discussion</h2><p><a data-type="xref" href="#nch-stats-stats-abs-to-rel">Recipe 17.9</a> illustrates how a
      self-join can produce relative values from absolute values. A self-join can do
      the opposite as well, producing cumulative values at each successive
      stage of a set of observations. The following table shows a set of
      rainfall measurements taken over a series of days. The values in each
      row show the observation date and precipitation in inches:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT date, precip FROM rainfall ORDER BY date;</code></strong>
+------------+--------+
| date       | precip |
+------------+--------+
| 2014-06-01 |   1.50 |
| 2014-06-02 |   0.00 |
| 2014-06-03 |   0.50 |
| 2014-06-04 |   0.00 |
| 2014-06-05 |   1.00 |
+------------+--------+</pre><p>To calculate cumulative rainfall for a given day, add that day’s
      precipitation value to the values for all the previous days. For
      example, determine the cumulative rainfall as of <code>2014-06-03</code> like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT SUM(precip) FROM rainfall WHERE date &lt;= '2014-06-03';</code></strong>
+-------------+
| SUM(precip) |
+-------------+
|        2.00 |
+-------------+</pre><p>To get the cumulative figures for all days represented in the
      table, it’s tedious to compute the value separately for each day. A
      self-join can do this for all days with a single statement. Use one
      instance of the <code>rainfall</code> table as a
      reference, and determine for the date in each row the sum of the
      <code>precip</code> values in all rows occurring
      up through that date in another instance of the table. The following
      statement shows the daily and cumulative precipitation for each
      day:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1.date, t1.precip AS 'daily precip',</code></strong>
    -&gt; <strong><code>SUM(t2.precip) AS 'cum. precip'</code></strong>
    -&gt; <strong><code>FROM rainfall AS t1 INNER JOIN rainfall AS t2</code></strong>
    -&gt; <strong><code>ON t1.date &gt;= t2.date</code></strong>
    -&gt; <strong><code>GROUP BY t1.date;</code></strong>
+------------+--------------+-------------+
| date       | daily precip | cum. precip |
+------------+--------------+-------------+
| 2014-06-01 |         1.50 |        1.50 |
| 2014-06-02 |         0.00 |        1.50 |
| 2014-06-03 |         0.50 |        2.00 |
| 2014-06-04 |         0.00 |        2.00 |
| 2014-06-05 |         1.00 |        3.00 |
+------------+--------------+-------------+</pre><p>The self-join can be extended to display the number of days
      elapsed at each date, as well as the running averages for amount of
      precipitation each day:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1.date, t1.precip AS 'daily precip',</code></strong>
    -&gt; <strong><code>SUM(t2.precip) AS 'cum. precip',</code></strong>
    -&gt; <strong><code>COUNT(t2.precip) AS 'days elapsed',</code></strong>
    -&gt; <strong><code>AVG(t2.precip) AS 'avg. precip'</code></strong>
    -&gt; <strong><code>FROM rainfall AS t1 INNER JOIN rainfall AS t2</code></strong>
    -&gt; <strong><code>ON t1.date &gt;= t2.date</code></strong>
    -&gt; <strong><code>GROUP BY t1.date;</code></strong>
+------------+--------------+-------------+--------------+-------------+
| date       | daily precip | cum. precip | days elapsed | avg. precip |
+------------+--------------+-------------+--------------+-------------+
| 2014-06-01 |         1.50 |        1.50 |            1 |    1.500000 |
| 2014-06-02 |         0.00 |        1.50 |            2 |    0.750000 |
| 2014-06-03 |         0.50 |        2.00 |            3 |    0.666667 |
| 2014-06-04 |         0.00 |        2.00 |            4 |    0.500000 |
| 2014-06-05 |         1.00 |        3.00 |            5 |    0.600000 |
+------------+--------------+-------------+--------------+-------------+</pre><p>In the preceding statement, the number of days elapsed and the
      precipitation running averages can be computed easily using <code>COUNT()</code> and <code>AVG()</code> because there are no missing days in the
      table. If missing days are permitted, the calculation becomes more
      complicated because the number of days elapsed for each calculation is
      no longer the same as the number of rows. You can see this by deleting
      the rows for the days that had no precipitation to produce
      <q>holes</q> in the table:</p><pre data-type="programlisting">mysql&gt; <strong><code>DELETE FROM rainfall WHERE precip = 0;</code></strong>
mysql&gt; <strong><code>SELECT date, precip FROM rainfall ORDER BY date;</code></strong>
+------------+--------+
| date       | precip |
+------------+--------+
| 2014-06-01 |   1.50 |
| 2014-06-03 |   0.50 |
| 2014-06-05 |   1.00 |
+------------+--------+</pre><p>Deleting those rows doesn’t change the cumulative sum or running
      average for the dates that remain, but it does change how they must be
      calculated. If you execute the self-join again, it yields incorrect
      results for the days-elapsed and average precipitation columns:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1.date, t1.precip AS 'daily precip',</code></strong>
    -&gt; <strong><code>SUM(t2.precip) AS 'cum. precip',</code></strong>
    -&gt; <strong><code>COUNT(t2.precip) AS 'days elapsed',</code></strong>
    -&gt; <strong><code>AVG(t2.precip) AS 'avg. precip'</code></strong>
    -&gt; <strong><code>FROM rainfall AS t1 INNER JOIN rainfall AS t2</code></strong>
    -&gt; <strong><code>ON t1.date &gt;= t2.date</code></strong>
    -&gt; <strong><code>GROUP BY t1.date;</code></strong>
+------------+--------------+-------------+--------------+-------------+
| date       | daily precip | cum. precip | days elapsed | avg. precip |
+------------+--------------+-------------+--------------+-------------+
| 2014-06-01 |         1.50 |        1.50 |            1 |    1.500000 |
| 2014-06-03 |         0.50 |        2.00 |            2 |    1.000000 |
| 2014-06-05 |         1.00 |        3.00 |            3 |    1.000000 |
+------------+--------------+-------------+--------------+-------------+</pre><p>To fix the problem, determine the number of days elapsed a
      different way. Take the minimum and maximum date involved in each sum
      and calculate a days-elapsed value from them:</p><pre data-type="programlisting">DATEDIFF(MAX(t2.date),MIN(t2.date)) + 1</pre><p>That value must be used for the days-elapsed column and for
      computing the running averages. The resulting statement is as
      follows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1.date, t1.precip AS 'daily precip',</code></strong>
    -&gt; <strong><code>SUM(t2.precip) AS 'cum. precip',</code></strong>
    -&gt; <strong><code>DATEDIFF(MAX(t2.date),MIN(t2.date)) + 1 AS 'days elapsed',</code></strong>
    -&gt; <strong><code>SUM(t2.precip) / (DATEDIFF(MAX(t2.date),MIN(t2.date)) + 1)</code></strong>
    -&gt; <strong><code>AS 'avg. precip'</code></strong>
    -&gt; <strong><code>FROM rainfall AS t1 INNER JOIN rainfall AS t2</code></strong>
    -&gt; <strong><code>ON t1.date &gt;= t2.date</code></strong>
    -&gt; <strong><code>GROUP BY t1.date;</code></strong>
+------------+--------------+-------------+--------------+-------------+
| date       | daily precip | cum. precip | days elapsed | avg. precip |
+------------+--------------+-------------+--------------+-------------+
| 2014-06-01 |         1.50 |        1.50 |            1 |    1.500000 |
| 2014-06-03 |         0.50 |        2.00 |            3 |    0.666667 |
| 2014-06-05 |         1.00 |        3.00 |            5 |    0.600000 |
+------------+--------------+-------------+--------------+-------------+</pre><p>As this example illustrates, calculation of cumulative values from
      relative values requires only a column that enables rows to be placed
      into the proper order. (For the <code>rainfall</code> table, that’s the <code>date</code> column.) Values in the column need not be
      sequential, or even numeric. This differs from calculations that produce
      difference values from cumulative values (see <a data-type="xref" href="#nch-stats-stats-abs-to-rel">Recipe 17.9</a>), which require a table that has
      a column containing an unbroken sequence.</p><p>The running averages in the rainfall examples are based on
      dividing cumulative precipitation sums by number of days elapsed as of
      each day. When the table has no gaps, the number of days is the same as
      the number of values summed, making it easy to find successive averages.
      When rows are missing, the calculations become more complex. This
      demonstrates that it’s necessary to consider the nature of your data and
      calculate averages appropriately. The next example is conceptually
      similar to the previous ones in that it calculates cumulative sums and
      running averages, but performs the computations yet another way.</p><p>The following table shows a marathon runner’s performance at each
      stage of a 26-kilometer run. The values in each row show the length of
      each stage in kilometers and how long the runner took to complete the
      stage. In other words, the values pertain to intervals within the
      marathon and thus are relative to the whole:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT stage, km, t FROM marathon ORDER BY stage;</code></strong>
+-------+----+----------+
| stage | km | t        |
+-------+----+----------+
|     1 |  5 | 00:15:00 |
|     2 |  7 | 00:19:30 |
|     3 |  9 | 00:29:20 |
|     4 |  5 | 00:17:50 |
+-------+----+----------+</pre><p>To calculate cumulative distance in kilometers at each stage, use
      a self-join like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1.stage, t1.km, SUM(t2.km) AS 'cum. km'</code></strong>
    -&gt; <strong><code>FROM marathon AS t1 INNER JOIN marathon AS t2</code></strong>
    -&gt; <strong><code>ON t1.stage &gt;= t2.stage</code></strong>
    -&gt; <strong><code>GROUP BY t1.stage;</code></strong>
+-------+----+---------+
| stage | km | cum. km |
+-------+----+---------+
|     1 |  5 |       5 |
|     2 |  7 |      12 |
|     3 |  9 |      21 |
|     4 |  5 |      26 |
+-------+----+---------+</pre><p>Cumulative distances are easy to compute because they can be
      summed directly. The calculation for accumulating time values is more
      involved: convert times to seconds, total the resulting values, and
      convert the sum back to a time value. To compute the runner’s average
      speed at the end of each stage, take the ratio of cumulative distance
      over cumulative time. Putting all this together yields the following
      statement:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1.stage, t1.km, t1.t,</code></strong>
    -&gt; <strong><code>SUM(t2.km) AS 'cum. km',</code></strong>
    -&gt; <strong><code>SEC_TO_TIME(SUM(TIME_TO_SEC(t2.t))) AS 'cum. t',</code></strong>
    -&gt; <strong><code>SUM(t2.km)/(SUM(TIME_TO_SEC(t2.t))/(60*60)) AS 'avg. km/hour'</code></strong>
    -&gt; <strong><code>FROM marathon AS t1 INNER JOIN marathon AS t2</code></strong>
    -&gt; <strong><code>ON t1.stage &gt;= t2.stage</code></strong>
    -&gt; <strong><code>GROUP BY t1.stage;</code></strong>
+-------+----+----------+---------+----------+--------------+
| stage | km | t        | cum. km | cum. t   | avg. km/hour |
+-------+----+----------+---------+----------+--------------+
|     1 |  5 | 00:15:00 |       5 | 00:15:00 |      20.0000 |
|     2 |  7 | 00:19:30 |      12 | 00:34:30 |      20.8696 |
|     3 |  9 | 00:29:20 |      21 | 01:03:50 |      19.7389 |
|     4 |  5 | 00:17:50 |      26 | 01:21:40 |      19.1020 |
+-------+----+----------+---------+----------+--------------+</pre><p>We can see from this that the runner’s average pace increased a
      little during the second stage of the race but then decreased
      thereafter, presumably as a result of fatigue.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.11 Assigning Ranks"><div class="sect1" id="nch-stats-stats-ranks"><h1>17.11 Assigning Ranks</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337240064"><h2>Problem</h2><p>You want to assign ranks to a set of values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337239088"><h2>Solution</h2><p>Decide on a ranking method, then put the values in the desired
      order and apply the method to them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337238016"><h2>Discussion</h2><p>Some kinds of statistical tests require assignment of ranks. This
      section describes three ranking methods and shows how each can be
      implemented by using window functions. The examples assume that a
      table <code>ranks</code> contains the following
      scores, which are to be ranked with the values in descending
      order:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT score FROM ranks ORDER BY score DESC;</code></strong>
+-------+
| score |
+-------+
|     5 |
|     4 |
|     4 |
|     3 |
|     2 |
|     2 |
|     2 |
|     1 |
+-------+</pre><p>One type of ranking simply assigns each value its row number
      within the ordered set of values. To produce such rankings, use window function <code>ROW_NUMBER()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ROW_NUMBER() OVER win AS 'rank', </code></strong>
    -&gt; <strong><code>score FROM ranks WINDOW win AS (ORDER BY score DESC);</code></strong>
+------+-------+
| rank | score |
+------+-------+
|    1 |     5 |
|    2 |     4 |
|    3 |     4 |
|    4 |     3 |
|    5 |     2 |
|    6 |     2 |
|    7 |     2 |
|    8 |     1 |
+------+-------+
8 rows in set (0,00 sec)</pre><p>That kind of ranking doesn’t take into account the possibility of
      ties (instances of values that are the same). Window function <code>DENSE_RANK()</code>
      does so by advancing the rank only when values change:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT DENSE_RANK() OVER win AS 'rank', </code></strong>
    &gt; <strong><code>score FROM ranks WINDOW win AS (ORDER BY score DESC);</code></strong>
+------+-------+
| rank | score |
+------+-------+
|    1 |     5 |
|    2 |     4 |
|    2 |     4 |
|    3 |     3 |
|    4 |     2 |
|    4 |     2 |
|    4 |     2 |
|    5 |     1 |
+------+-------+</pre><p>Window function <code>RANK()</code> is something of a combination of the other
      two methods. It ranks values by row number, except when ties occur. In
      that case, the tied values each get a rank equal to the row number of
      the first of the values.</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ROW_NUMBER() OVER win AS 'row', </code></strong>
    -&gt; <strong><code>RANK() OVER win AS 'rank', </code></strong>
    -&gt; <strong><code>score FROM ranks WINDOW win AS (ORDER BY score DESC);</code></strong>
+------+------+-------+
| row  | rank | score |
+------+------+-------+
|    1 |    1 |     5 |
|    2 |    2 |     4 |
|    3 |    2 |     4 |
|    4 |    4 |     3 |
|    5 |    5 |     2 |
|    6 |    5 |     2 |
|    7 |    5 |     2 |
|    8 |    8 |     1 |
+------+------+-------+</pre><p>Ranks are easy to assign within a program as well. For example,
      the following Ruby fragment ranks the scores in <code>ranks</code> using the third ranking method:</p><pre data-type="programlisting" data-code-language="ruby"><code class="n">res</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">query</code><code class="p">(</code><code class="s2">"SELECT score FROM ranks ORDER BY score DESC"</code><code class="p">)</code>
  <code class="n">rownum</code> <code class="o">=</code> <code class="mi">0</code>
  <code class="n">rank</code> <code class="o">=</code> <code class="mi">0</code>
  <code class="n">prev_score</code> <code class="o">=</code> <code class="kp">nil</code>
  <code class="nb">puts</code> <code class="s2">"Row</code><code class="se">\t</code><code class="s2">Rank</code><code class="se">\t</code><code class="s2">Score</code><code class="se">\n</code><code class="s2">"</code>
  <code class="n">res</code><code class="o">.</code><code class="n">each</code> <code class="k">do</code> <code class="o">|</code><code class="n">row</code><code class="o">|</code>
    <code class="n">score</code> <code class="o">=</code> <code class="n">row</code><code class="o">.</code><code class="n">values</code><code class="o">[</code><code class="mi">0</code><code class="o">]</code>
    <code class="n">rownum</code> <code class="o">+=</code> <code class="mi">1</code>
    <code class="n">rank</code> <code class="o">=</code> <code class="n">rownum</code> <code class="k">if</code> <code class="n">rownum</code> <code class="o">==</code> <code class="mi">1</code> <code class="o">||</code> <code class="n">prev_score</code> <code class="o">!=</code> <code class="n">score</code>
    <code class="n">prev_score</code> <code class="o">=</code> <code class="n">score</code>
    <code class="nb">puts</code> <code class="s2">"</code><code class="si">#{</code><code class="n">rownum</code><code class="si">}</code><code class="se">\t</code><code class="si">#{</code><code class="n">rank</code><code class="si">}</code><code class="se">\t</code><code class="si">#{</code><code class="n">score</code><code class="si">}</code><code class="s2">"</code>
  <code class="k">end</code></pre><p>The third type of ranking is commonly used for sporting events.
      The following table contains the American League pitchers who won 15 or
      more games during the 2001 baseball season:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, wins FROM al_winner ORDER BY wins DESC, name;</code></strong>
+----------------+------+
| name           | wins |
+----------------+------+
| Mulder, Mark   |   21 |
| Clemens, Roger |   20 |
| Moyer, Jamie   |   20 |
| Garcia, Freddy |   18 |
| Hudson, Tim    |   18 |
| Abbott, Paul   |   17 |
| Mays, Joe      |   17 |
| Mussina, Mike  |   17 |
| Sabathia, C.C. |   17 |
| Zito, Barry    |   17 |
| Buehrle, Mark  |   16 |
| Milton, Eric   |   15 |
| Pettitte, Andy |   15 |
| Radke, Brad    |   15 |
| Sele, Aaron    |   15 |
+----------------+------+</pre><p>These pitchers can be assigned ranks using the third method as
      follows:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ROW_NUMBER() OVER win AS 'row', </code></strong>
    -&gt; <strong><code>RANK() OVER win AS 'rank', </code></strong>
    -&gt; <strong><code>name, wins </code></strong>
    -&gt; <strong><code>FROM al_winner WINDOW win AS (ORDER BY wins DESC);</code></strong>
+------+------+----------------+------+
| row  | rank | name           | wins |
+------+------+----------------+------+
|    1 |    1 | Mulder, Mark   |   21 |
|    2 |    2 | Clemens, Roger |   20 |
|    3 |    2 | Moyer, Jamie   |   20 |
|    4 |    4 | Garcia, Freddy |   18 |
|    5 |    4 | Hudson, Tim    |   18 |
|    6 |    6 | Zito, Barry    |   17 |
|    7 |    6 | Sabathia, C.C. |   17 |
|    8 |    6 | Mussina, Mike  |   17 |
|    9 |    6 | Mays, Joe      |   17 |
|   10 |    6 | Abbott, Paul   |   17 |
|   11 |   11 | Buehrle, Mark  |   16 |
|   12 |   12 | Milton, Eric   |   15 |
|   13 |   12 | Pettitte, Andy |   15 |
|   14 |   12 | Radke, Brad    |   15 |
|   15 |   12 | Sele, Aaron    |   15 |
+------+------+----------------+------+</pre></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820337237712"><h2>See Also</h2><p>For additional information about window functions, see <a data-type="xref" href="ch15.xhtml#nch-sequences-seq-window-functions">Recipe 15.15</a>.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="17.12 Computing Team Standings"><div class="sect1" id="nch-stats-stats-standings"><h1>17.12 Computing Team Standings</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820337134816"><h2>Problem</h2><p>You want to compute team standings from their win-loss records,
      including the games-behind (GB) values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820337099248"><h2>Solution</h2><p>Determine which team is in first place, then join that result to
      the original rows.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820337098256"><h2>Discussion</h2><p>Standings for sports teams that compete against each other is a
      ranking problem, but ranks are not based on a single measure as in <a data-type="xref" href="#nch-stats-stats-ranks">Recipe 17.11</a>. Standings are based on two values,
      wins and losses. Teams are ranked according to which has the best
      win-loss record, and teams not in first place are assigned a
      <q>games-behind</q> value indicating how many games out of first
      place they are. This section shows how to calculate those values. The
      first example uses a table containing a single set of team records to
      illustrate the logic of the calculations. The second example uses a
      table containing several sets of records (that is, the records for all
      teams in both divisions of a league, for both halves of the season). In
      this case, it’s necessary to use a join to perform the calculations
      independently for each group of teams.</p><p>Consider the following table, <code>standings1</code>, which contains a single set of
      baseball team records representing the final standings for the Northern
      League in the year 1902:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT team, wins, losses FROM standings1</code></strong>
    -&gt; <strong><code>ORDER BY wins-losses DESC;</code></strong>
+-------------+------+--------+
| team        | wins | losses |
+-------------+------+--------+
| Winnipeg    |   37 |     20 |
| Crookston   |   31 |     25 |
| Fargo       |   30 |     26 |
| Grand Forks |   28 |     26 |
| Devils Lake |   19 |     31 |
| Cavalier    |   15 |     32 |
+-------------+------+--------+</pre><p>The rows are sorted by the win-loss differential, which is how to
      place teams in order from first place to last place. But displays of
      team standings typically include each team’s winning percentage and a
      figure indicating how many games behind the leader all the other teams
      are. So let’s add that information to the output. Calculating the
      percentage is easy. It’s the ratio of wins to total games played and can
      be determined using this expression:</p><pre data-type="programlisting">wins / (wins + losses)</pre><p>This expression involves division by zero when a team has not
      played any games yet. For simplicity, I’ll assume a nonzero number of
      games. To handle this condition, you’d use a more general
      expression:</p><pre data-type="programlisting">IF(wins=0,0,wins/(wins+losses))</pre><p>This expression relies on the fact that no division operation is
      necessary unless the team has won at least one game.</p><p>Determining the games-behind value is a little trickier. It’s
      based on the relationship of the win-loss records for two teams,
      calculated as the average of two values:</p><ul><li><p>How many more wins the first-place team has than the
          second-place team</p></li><li><p>How many fewer losses the first-place team has than the
          second-place team</p></li></ul><p>Suppose that two teams A and B have the following win-loss
      records:</p><pre data-type="programlisting">+------+------+--------+
| team | wins | losses |
+------+------+--------+
| A    |   17 |     11 |
| B    |   14 |     12 |
+------+------+--------+</pre><p>Here, team B has to win three more games, and team A has to lose
      one more game for the teams to be even. The average of three and one is
      two, thus B is two games behind A. Mathematically, the games-behind
      calculation for the two teams is:</p><pre data-type="programlisting">((winsA - winsB) + (lossesB - lossesA)) / 2</pre><p>With a little rearrangement of terms, the expression
      becomes:</p><pre data-type="programlisting">((winsA - lossesA) - (winsB - lossesB)) / 2</pre><p>The second expression is equivalent to the first, but it has each
      factor written as a single team’s win-loss differential, rather than as
      a comparison between teams. That makes it easier to work with because
      each factor can be determined independently from a single team record.
      The first factor represents the first-place team’s win-loss
      differential, so if we calculate that value first, the other team GB
      values can be determined in relation to it.</p><p>The first-place team is the one with the largest win-loss
      differential. To find that value and save it in a variable, use this
      statement:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @wl_diff = (SELECT MAX(wins-losses) FROM standings1);</code></strong></pre><p>Then use the differential as follows to produce team standings
      that include winning percentage and GB values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT team, wins AS W, losses AS L,</code></strong>
    -&gt; <strong><code>wins/(wins+losses) AS PCT,</code></strong>
    -&gt; <strong><code>(@wl_diff - (wins-losses)) / 2 AS GB</code></strong>
    -&gt; <strong><code>FROM standings1</code></strong>
    -&gt; <strong><code>ORDER BY wins-losses DESC, PCT DESC;</code></strong>
+-------------+------+------+--------+---------+
| team        | W    | L    | PCT    | GB      |
+-------------+------+------+--------+---------+
| Winnipeg    |   37 |   20 | 0.6491 |  0.0000 |
| Crookston   |   31 |   25 | 0.5536 |  5.5000 |
| Fargo       |   30 |   26 | 0.5357 |  6.5000 |
| Grand Forks |   28 |   26 | 0.5185 |  7.5000 |
| Devils Lake |   19 |   31 | 0.3800 | 14.5000 |
| Cavalier    |   15 |   32 | 0.3191 | 17.0000 |
+-------------+------+------+--------+---------+</pre><p>There are a couple minor formatting issues to address at this
      point. Typically, standings listings display percentages to three
      decimal places, and the GB value to one decimal place (except that the
      GB value for the first-place team is displayed as <code>-</code>). To display <em><code>n</code></em>
      decimal places, use <code>TRUNCATE(</code><em><code>expr</code></em><code>,</code><em><code>n</code></em><code>).</code> To display the GB value for the first-place
      team appropriately, use an <code>IF()</code> expression that
      maps 0 to a dash:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT team, wins AS W, losses AS L,</code></strong>
    -&gt; <strong><code>TRUNCATE(wins/(wins+losses),3) AS PCT,</code></strong>
    -&gt; <strong><code>IF(@wl_diff = wins-losses,</code></strong>
    -&gt;    <strong><code>'-',TRUNCATE((@wl_diff - (wins-losses))/2,1)) AS GB</code></strong>
    -&gt; <strong><code>FROM standings1</code></strong>
    -&gt; <strong><code>ORDER BY wins-losses DESC, PCT DESC;</code></strong>
+-------------+------+------+-------+------+
| team        | W    | L    | PCT   | GB   |
+-------------+------+------+-------+------+
| Winnipeg    |   37 |   20 | 0.649 | -    |
| Crookston   |   31 |   25 | 0.553 | 5.5  |
| Fargo       |   30 |   26 | 0.535 | 6.5  |
| Grand Forks |   28 |   26 | 0.518 | 7.5  |
| Devils Lake |   19 |   31 | 0.380 | 14.5 |
| Cavalier    |   15 |   32 | 0.319 | 17.0 |
+-------------+------+------+-------+------+</pre><p>These statements order the teams by win-loss differential, using
      winning percentage as a tie-breaker in case there are teams with the
      same differential value. It’s simpler to sort by percentage, of course,
      but then you wouldn’t always get the correct ordering. It’s a curious
      fact that a team with a lower winning percentage can actually be higher
      in the standings than a team with a higher percentage. (This generally
      occurs early in the season, when teams may have played highly disparate
      numbers of games, relatively speaking.) Consider the case in which two
      teams, A and B, have the following rows:</p><pre data-type="programlisting">+------+------+--------+
| team | wins | losses |
+------+------+--------+
| A    |    4 |      1 |
| B    |    2 |      0 |
+------+------+--------+</pre><p>Applying the GB and percentage calculations to these team records
      yields the following result, in which the first-place team actually has
      a lower winning percentage than the second-place team:</p><pre data-type="programlisting">+------+------+------+-------+------+
| team | W    | L    | PCT   | GB   |
+------+------+------+-------+------+
| A    |    4 |    1 | 0.800 | -    |
| B    |    2 |    0 | 1.000 | 0.5  |
+------+------+------+-------+------+</pre><p>The standings calculations shown thus far can be done without a
      join. They involve only a single set of team records, so the first-place
      team’s win-loss differential can be stored in a variable. A more complex
      situation occurs when a dataset includes several sets of team records.
      For example, the 1997 Northern League had two divisions (Eastern and
      Western). In addition, separate standings were maintained for the first
      and second halves of the season because season-half winners in each
      division played each other for the right to compete in the league
      championship. The following table, <code>standings2</code>, shows what these rows look like,
      ordered by season half, division, and win-loss differential:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT half, division, team, wins, losses FROM standings2</code></strong>
    -&gt; <strong><code>ORDER BY half, division, wins-losses DESC;</code></strong>
+------+----------+-----------------+------+--------+
| half | division | team            | wins | losses |
+------+----------+-----------------+------+--------+
|    1 | Eastern  | St. Paul        |   24 |     18 |
|    1 | Eastern  | Thunder Bay     |   18 |     24 |
|    1 | Eastern  | Duluth-Superior |   17 |     24 |
|    1 | Eastern  | Madison         |   15 |     27 |
|    1 | Western  | Winnipeg        |   29 |     12 |
|    1 | Western  | Sioux City      |   28 |     14 |
|    1 | Western  | Fargo-Moorhead  |   21 |     21 |
|    1 | Western  | Sioux Falls     |   15 |     27 |
|    2 | Eastern  | Duluth-Superior |   22 |     20 |
|    2 | Eastern  | St. Paul        |   21 |     21 |
|    2 | Eastern  | Madison         |   19 |     23 |
|    2 | Eastern  | Thunder Bay     |   18 |     24 |
|    2 | Western  | Fargo-Moorhead  |   26 |     16 |
|    2 | Western  | Winnipeg        |   24 |     18 |
|    2 | Western  | Sioux City      |   22 |     20 |
|    2 | Western  | Sioux Falls     |   16 |     26 |
+------+----------+-----------------+------+--------+</pre><p>Generating the standings for these rows requires computing the GB
      values separately for each of the four combinations of season half and
      division. First, calculate the win-loss differential for the first-place
      team in each group and save the values into a separate <code>firstplace</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TEMPORARY TABLE firstplace</code></strong>
    -&gt; <strong><code>SELECT half, division, MAX(wins-losses) AS wl_diff</code></strong>
    -&gt; <strong><code>FROM standings2</code></strong>
    -&gt; <strong><code>GROUP BY half, division;</code></strong></pre><p>Then join the <code>firstplace</code> table
      to the original standings, associating each team record with the proper
      win-loss differential to compute its GB value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT wl.half, wl.division, wl.team, wl.wins AS W, wl.losses AS L,</code></strong>
    -&gt; <strong><code>TRUNCATE(wl.wins/(wl.wins+wl.losses),3) AS PCT,</code></strong>
    -&gt; <strong><code>IF(fp.wl_diff = wl.wins-wl.losses,</code></strong>
    -&gt;    <strong><code>'-',TRUNCATE((fp.wl_diff - (wl.wins-wl.losses)) / 2,1)) AS GB</code></strong>
    -&gt; <strong><code>FROM standings2 AS wl INNER JOIN firstplace AS fp</code></strong>
    -&gt; <strong><code>ON wl.half = fp.half AND wl.division = fp.division</code></strong>
    -&gt; <strong><code>ORDER BY wl.half, wl.division, wl.wins-wl.losses DESC, PCT DESC;</code></strong>
+------+----------+-----------------+------+------+-------+------+
| half | division | team            | W    | L    | PCT   | GB   |
+------+----------+-----------------+------+------+-------+------+
|    1 | Eastern  | St. Paul        |   24 |   18 | 0.571 | -    |
|    1 | Eastern  | Thunder Bay     |   18 |   24 | 0.428 | 6.0  |
|    1 | Eastern  | Duluth-Superior |   17 |   24 | 0.414 | 6.5  |
|    1 | Eastern  | Madison         |   15 |   27 | 0.357 | 9.0  |
|    1 | Western  | Winnipeg        |   29 |   12 | 0.707 | -    |
|    1 | Western  | Sioux City      |   28 |   14 | 0.666 | 1.5  |
|    1 | Western  | Fargo-Moorhead  |   21 |   21 | 0.500 | 8.5  |
|    1 | Western  | Sioux Falls     |   15 |   27 | 0.357 | 14.5 |
|    2 | Eastern  | Duluth-Superior |   22 |   20 | 0.523 | -    |
|    2 | Eastern  | St. Paul        |   21 |   21 | 0.500 | 1.0  |
|    2 | Eastern  | Madison         |   19 |   23 | 0.452 | 3.0  |
|    2 | Eastern  | Thunder Bay     |   18 |   24 | 0.428 | 4.0  |
|    2 | Western  | Fargo-Moorhead  |   26 |   16 | 0.619 | -    |
|    2 | Western  | Winnipeg        |   24 |   18 | 0.571 | 2.0  |
|    2 | Western  | Sioux City      |   22 |   20 | 0.523 | 4.0  |
|    2 | Western  | Sioux Falls     |   16 |   26 | 0.380 | 10.0 |
+------+----------+-----------------+------+------+-------+------+</pre><p>That output is difficult to read, however. To make it easier to
      understand, you might execute the statement from within a program and
      reformat its results to display each set of team records separately.
      Here’s some Perl code that does that by beginning a new output group
      each time it encounters a new group of standings. The code assumes that
      the join statement has just been executed and that its results are
      available through the statement handle <code>$sth</code>:</p><pre data-type="programlisting" data-code-language="perl"><code class="k">my</code> <code class="p">(</code><code class="nv">$cur_half</code><code class="p">,</code> <code class="nv">$cur_div</code><code class="p">)</code> <code class="o">=</code> <code class="p">(</code><code class="s">""</code><code class="p">,</code> <code class="s">""</code><code class="p">);</code>
<code class="k">while</code> <code class="p">(</code><code class="k">my</code> <code class="p">(</code><code class="nv">$half</code><code class="p">,</code> <code class="nv">$div</code><code class="p">,</code> <code class="nv">$team</code><code class="p">,</code> <code class="nv">$wins</code><code class="p">,</code> <code class="nv">$losses</code><code class="p">,</code> <code class="nv">$pct</code><code class="p">,</code> <code class="nv">$gb</code><code class="p">)</code>
          <code class="o">=</code> <code class="nv">$sth</code><code class="o">-&gt;</code><code class="n">fetchrow_array</code> <code class="p">())</code>
<code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nv">$cur_half</code> <code class="ow">ne</code> <code class="nv">$half</code> <code class="o">||</code> <code class="nv">$cur_div</code> <code class="ow">ne</code> <code class="nv">$div</code><code class="p">)</code> <code class="c1"># new group of standings?</code>
  <code class="p">{</code>
    <code class="c1"># print standings header and remember new half/division values</code>
    <code class="k">print</code> <code class="s">"\n$div Division, season half $half\n"</code><code class="p">;</code>
    <code class="nb">printf</code> <code class="s">"%-20s  %3s  %3s  %5s  %s\n"</code><code class="p">,</code> <code class="s">"Team"</code><code class="p">,</code> <code class="s">"W"</code><code class="p">,</code> <code class="s">"L"</code><code class="p">,</code> <code class="s">"PCT"</code><code class="p">,</code> <code class="s">"GB"</code><code class="p">;</code>
    <code class="nv">$cur_half</code> <code class="o">=</code> <code class="nv">$half</code><code class="p">;</code>
    <code class="nv">$cur_div</code> <code class="o">=</code> <code class="nv">$div</code><code class="p">;</code>
  <code class="p">}</code>
  <code class="nb">printf</code> <code class="s">"%-20s  %3d  %3d  %5s  %s\n"</code><code class="p">,</code> <code class="nv">$team</code><code class="p">,</code> <code class="nv">$wins</code><code class="p">,</code> <code class="nv">$losses</code><code class="p">,</code> <code class="nv">$pct</code><code class="p">,</code> <code class="nv">$gb</code><code class="p">;</code>
<code class="p">}</code></pre><p>The reformatted output looks like this:</p><pre data-type="programlisting">Eastern Division, season half 1
Team                    W    L    PCT  GB
St. Paul               24   18  0.571  -
Thunder Bay            18   24  0.428  6.0
Duluth-Superior        17   24  0.414  6.5
Madison                15   27  0.357  9.0

Western Division, season half 1
Team                    W    L    PCT  GB
Winnipeg               29   12  0.707  -
Sioux City             28   14  0.666  1.5
Fargo-Moorhead         21   21  0.500  8.5
Sioux Falls            15   27  0.357  14.5

Eastern Division, season half 2
Team                    W    L    PCT  GB
Duluth-Superior        22   20  0.523  -
St. Paul               21   21  0.500  1.0
Madison                19   23  0.452  3.0
Thunder Bay            18   24  0.428  4.0

Western Division, season half 2
Team                    W    L    PCT  GB
Fargo-Moorhead         26   16  0.619  -
Winnipeg               24   18  0.571  2.0
Sioux City             22   20  0.523  4.0
Sioux Falls            16   26  0.380  10.0</pre><p>The code just shown comes from the <span class="command"><em>calc_standings.pl</em></span> script in the <em class="filename">stats</em> directory of the <code>recipes</code> distribution. That directory also
      contains a PHP script, <span class="command"><em>calc_standings.php</em></span>, that produces output in
      the form of HTML tables, which you might prefer for generating standings
      in a web environment.</p></div></section></div></section><div data-type="footnotes"><p data-type="footnote" id="idm45820338373088"><sup><a href="ch17.xhtml#idm45820338373088-marker">1</a></sup> The definition of median given here isn’t fully general; it
          doesn’t address what to do if the middle values in the dataset are
          duplicated.</p><p data-type="footnote" id="idm45820337870752"><sup><a href="ch17.xhtml#idm45820337870752-marker">2</a></sup> To see where these terms come from, consult any standard
          statistics text.</p></div></div></section></div></body></html>