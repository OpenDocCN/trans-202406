<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Deciphering Real Genomics Workflows"><div class="chapter" id="deciphering_real_genomics_workflows">
<h1><span class="label">Chapter 9. </span>Deciphering Real Genomics Workflows</h1>

<p>In <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>, we showed you how to string commands into workflows by using the <a contenteditable="false" data-primary="workflows" data-secondary="deciphering real genomics workflows" data-type="indexterm" id="ix_wkfreal"/>WDL language, and we had you practice running those workflows on your cloud VM using Cromwell. Throughout that chapter, we used fairly simple example workflows in order to focus on the basic syntax and rules of WDL. In this chapter, we switch gears and tackle workflows that are more complex than what you’ve seen so far. Rest assured, we neither expect you to instantly master all of the intricacies involved nor to memorize the various code features that you’ll encounter.</p>

<p>Our main goal is to expose you to the logic, patterns, and strategies used in real genomics workflows and, in the process, present you with a methodology for deciphering new workflows of arbitrary complexity. To that end, we’ve selected two workflows from the <a href="https://oreil.ly/D0Ofp">gatk-workflows</a> collection, but we won’t tell you up front what they do. Instead, for each mystery workflow, we tell you the functionality you’re going to learn about and then walk you through a series of steps to learn what the workflow does and how the functionality that we’re interested in is implemented. This won’t turn you into a WDL developer overnight, but it will equip you with the skills to decipher other people’s workflows and, with a bit of practice, learn to modify them to serve your own purposes if needed.</p>

<section data-type="sect1" data-pdf-bookmark="Mystery Workflow #1: Flexibility Through Conditionals"><div class="sect1" id="mystery_workflow_flexibility_through">
<h1>Mystery Workflow #1: Flexibility Through Conditionals</h1>

<p>Our first mystery workflow<a contenteditable="false" data-primary="workflows" data-secondary="deciphering real genomics workflows" data-tertiary="mystery workflow, flexibility through conditionals" data-type="indexterm" id="ix_wkfrealmys1"/> gives you the opportunity<a contenteditable="false" data-primary="flexibility through conditionals" data-type="indexterm" id="ix_flexcon"/> to learn how to use conditional statements to control which tasks are run and under what conditions. It also shows you how to increase flexibility for controlling the workflow’s parameters and outputs. As we work through this case, you’ll encounter many familiar elements that you encountered in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>. However, unlike in that chapter, here we don’t immediately explain all of the code; in fact, there is some code that we won’t cover at all. Much of this exercise involves focusing on the more important parts and ignoring details that don’t matter for what we’re trying to figure out.<a contenteditable="false" data-primary="conditionals" data-secondary="flexibility through" data-seealso="flexibility through conditionals" data-type="indexterm" id="idm45625617451304"/> </p>

<p>You’re going to work in your VM with the same setup as in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>, running commands from the home directory. <a contenteditable="false" data-primary="virtual machines (VMs)" data-secondary="environment variable in VM shell to make commands shorter" data-type="indexterm" id="idm45625617447976"/>To begin, let’s set up an environment variable in your VM shell to make the commands shorter:</p>

<pre data-type="programlisting">
$ export CASE1=~/book/code/workflows/mystery-1</pre>

<p>Let’s also create <a contenteditable="false" data-primary="sandbox directory" data-secondary="creating to store workflow outputs" data-type="indexterm" id="idm45625617445256"/>a sandbox directory for storing outputs:</p>

<pre data-type="programlisting">
$ mkdir ~/sandbox-9</pre>

<p>And with that, you’re ready to dive in.</p>

<section data-type="sect2" data-pdf-bookmark="Mapping Out the Workflow"><div class="sect2" id="mapping_out_the_workflo">
<h2>Mapping Out the Workflow</h2>

<p>When you encounter a<a contenteditable="false" data-primary="flexibility through conditionals" data-secondary="mapping out the workflow" data-type="indexterm" id="ix_flexconmap"/> new workflow, it can be tempting to dive straight into the WDL file and try to make sense of it by directly reading the code. However, unless you’re very familiar with the language (or the author did an unusually great job of documenting their work), this can end up being frustrating and overwhelming. We propose a two-step approach that can help you to figure out the overall purpose and structure of a workflow. Start by generating a graph diagram of the workflow tasks. Then, identify which parts of the code correspond to each of the main components in the graph. This will provide you with a map of the overall workflow and a starting point for digging deeper into its plumbing.</p>

<section data-type="sect3" data-pdf-bookmark="Generating the graph diagram"><div class="sect3" id="generating_the_graph_diagra">
<h3>Generating the graph diagram</h3>

<p>You may<a contenteditable="false" data-primary="graphs" data-secondary="generating graph diagram for workflow visualization" data-type="indexterm" id="ix_grphgen"/> recall that in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a> we discussed how the various connections between <a contenteditable="false" data-primary="flexibility through conditionals" data-secondary="mapping out the workflow" data-tertiary="generating graph diagram" data-type="indexterm" id="ix_flexconmapgr"/>tasks in a workflow form a directed graph. The workflow execution engine uses that graph to identify the dependencies between tasks and, from there, determine in what order it should run them. The good news is that we can also take advantage of that information, as we already did in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a> when we generated the graph diagram for the <code>HaplotypeCaller</code> workflow.</p>

<p>Let’s do the same thing now for our mystery workflow; run the <code>womtool graph</code> utility<a contenteditable="false" data-primary="Womtool" data-secondary="graph command, generating graph diagram for workflow visualization" data-type="indexterm" id="idm45625617394920"/> on the WDL file:</p>

<pre data-type="programlisting">
$ cat ~/sandbox-9/haplotypecaller-gvcf-gatk4.dot
$ java -jar $BIN/womtool-48.jar graph $CASE1/haplotypecaller-gvcf-gatk4.wdl \
    &gt; ~/sandbox-9/haplotypecaller-gvcf-gatk4.dot</pre>

<p>This produces a <a contenteditable="false" data-primary="DOT file describing workflow structure" data-type="indexterm" id="idm45625617392216"/>DOT file that describes the <a contenteditable="false" data-primary="JSON" data-secondary="DOT file describing workflow structure in JSON" data-type="indexterm" id="idm45625617390984"/>structure of the workflow in JSON syntax. Open the DOT file with <code>cat</code> to see the contents, which should look like this:</p>

<pre class="small" data-type="programlisting" data-code-language="mscgen">
<code class="nv">digraph</code><code class="w"> </code><code class="nv">HaplotypeCallerGvcf_GATK4</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="c1">#rankdir=LR;</code>
<code class="w">  </code><code class="nv">compound</code><code class="o">=</code><code class="nv">true</code><code class="p">;</code><code class="w"/>
<code class="w">  </code><code class="c1"># Links</code>
<code class="w">  </code><code class="nv">CALL_HaplotypeCaller</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_MergeGVCFs</code><code class="w"/>
<code class="w">  </code><code class="nv">SCATTER_1_VARIABLE_interval_file</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_HaplotypeCaller</code><code class="w"/>
<code class="w">  </code><code class="nv">CALL_CramToBamTask</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_HaplotypeCaller</code><code class="w"/>
<code class="w">  </code><code class="c1"># Nodes</code>
<code class="w">  </code><code class="nv">subgraph</code><code class="w"> </code><code class="nv">cluster_0</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nv">style</code><code class="o">=</code><code class="nv">"filled,dashed"</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="nv">fillcolor</code><code class="o">=</code><code class="nv">white</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="nv">CALL_CramToBamTask</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call CramToBamTask"</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="nv">CONDITIONAL_0_EXPRESSION</code><code class="w"> </code><code class="p">[</code><code class="na">shape</code><code class="o">=</code><code class="s">"hexagon"</code><code class="w"> </code><code class="na">label</code><code class="o">=</code><code class="s">"if (is_cram)"</code><code class="w"> </code><code class="na">style</code><code class="o">=</code><code class="s">"dashed"</code><code class="w"> </code><code class="p">]</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="w">  </code><code class="nv">CALL_MergeGVCFs</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call MergeGVCFs"</code><code class="p">]</code><code class="w"/>
<code class="w">  </code><code class="nv">subgraph</code><code class="w"> </code><code class="nv">cluster_1</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nv">style</code><code class="o">=</code><code class="nv">"filled,solid"</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="nv">fillcolor</code><code class="o">=</code><code class="nv">white</code><code class="p">;</code><code class="w"/>
<code class="w">    </code><code class="nv">CALL_HaplotypeCaller</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call HaplotypeCaller"</code><code class="p">]</code><code class="w"/>
<code class="w">    </code><code class="nv">SCATTER_1_VARIABLE_interval_file</code><code class="w"> </code><code class="p">[</code><code class="na">shape</code><code class="o">=</code><code class="s">"hexagon"</code><code class="w"> </code><code class="na">label</code><code class="o">=</code><code class="s">"scatter over File as interval_file"</code><code class="p">]</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>This is a little difficult to directly interpret, so let’s use Graphviz to make a visual representation.<a contenteditable="false" data-primary="GraphViz package" data-secondary="making visual representation of graph diagram" data-type="indexterm" id="idm45625617385832"/> Go to <a href="https://oreil.ly/TpWlW">GraphvizOnline</a> and then copy and paste the contents of the DOT file into the editor panel on the left. The panel on the right should refresh and display the visual rendering of the graph, as shown in <a data-type="xref" href="#graph_description_in_json_left_parenthe">Figure 9-1</a>.</p>

<figure><div id="graph_description_in_json_left_parenthe" class="figure"><img alt="Graph description in JSON (left) and visual rendering (right)." src="Images/gitc_0901.png" width="1441" height="366"/>
<h6><span class="label">Figure 9-1. </span>Graph description in JSON (left) and visual rendering (right).</h6>
</div></figure>

<p>Focus on the<a contenteditable="false" data-primary="MergeGVCFs tool" data-type="indexterm" id="idm45625617353608"/> ovals first because <a contenteditable="false" data-primary="HaplotypeCaller" data-secondary="calls to, under control of scatter function" data-type="indexterm" id="idm45625617185960"/>they <a contenteditable="false" data-primary="CramToBamTask" data-type="indexterm" id="idm45625617184392"/>represent the calls to tasks in the workflow. We see that this workflow involves calls to three tasks: <code>CramToBamTask</code>, <code>HaplotypeCaller</code>, and <code>MergeGVCFs</code>. The first two calls are each in a box, which we know from <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a> means there is some kind of control function that affects the call. Notice that the box around the call to <code>CramToBamTask</code> uses dotted lines, and that it also contains a hexagon labeled <code>if (is_cram)</code>. Feel free to speculate and write down what you think that might do; you’ll find out if you were correct when we unpack that a little further along in the chapter.<a contenteditable="false" data-primary="scatter-gather parallelism" data-secondary="call to HaplotypeCaller under scatter function control" data-type="indexterm" id="idm45625617179608"/> The other boxed call, to <code>HaplotypeCaller</code>, is under the control of a scatter function, which you should recognize from the last workflow we examined in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>. Indeed, if you ignore the <code>CramToBamTask</code> part, this workflow looks like the same scattered <code>HaplotypeCaller</code> example we reviewed then, which parallelized <code>HaplotypeCaller</code> over a list of intervals and then combined the per-interval GVCF outputs using <code>MergeGVCFs</code> to produce the final GVCF.</p>

<p>So, what’s up with that <code>CramToBamTask</code> call? Well, do <a contenteditable="false" data-primary="compression" data-secondary="CRAM format" data-type="indexterm" id="idm45625617173832"/><a contenteditable="false" data-primary="CRAMs" data-type="indexterm" id="idm45625617172424"/>you remember what CRAM is? As we mentioned in the genomics primer in <a data-type="xref" href="ch02.xhtml#genomics_in_a_nutshell_a_primer_for_new">Chapter 2</a>, it’s a compression format for storing sequencing read data in smaller files than BAM format. Some tools like <code>HaplotypeCaller</code> are not yet able to work with CRAM files with absolute reliability, so if your input is in CRAM format, you need to convert it to BAM first.<a contenteditable="false" data-primary="BAMs (Binary Alignment Maps)" data-secondary="converting CRAM to BAM" data-type="indexterm" id="idm45625617169384"/> Based on the name of the task, it sounds like that’s exactly what <code>CramToBamTask</code> does. And we would want to run it only on actual CRAM files, so it makes sense to put it under the control of a conditional switch, <code>if (is_cram)</code>, which asks: “Is this a CRAM file?” and calls the conversion task only if the answer is yes.<a contenteditable="false" data-primary="if (is_cram) conditional switch" data-type="indexterm" id="idm45625617166696"/></p>

<p>To summarize, based on the workflow graph, the names of tasks and variables, and some logical inferences, we can suppose that this mystery workflow is in fact very similar to the parallelized <code>HaplotypeCaller</code> workflow that you became familiar with in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>, but with a file format conversion step added at the beginning to handle CRAM files. That sounds reasonable, right? Let’s see if we can confirm this hypothesis and expand our understanding further.<a contenteditable="false" data-primary="graphs" data-secondary="generating graph diagram for workflow visualization" data-startref="ix_grphgen" data-type="indexterm" id="idm45625617163320"/><a contenteditable="false" data-primary="flexibility through conditionals" data-secondary="mapping out the workflow" data-startref="ix_flexconmapgr" data-tertiary="generating graph diagram" data-type="indexterm" id="idm45625617161608"/></p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Identifying the code that corresponds to the diagram components"><div class="sect3" id="identifying_the_code_that_corresponds">
<h3>Identifying the code that corresponds to the diagram components</h3>

<p>Now we’re <a contenteditable="false" data-primary="graphs" data-secondary="identifying code corresponding to diagram elements" data-type="indexterm" id="ix_grphgenID"/>going to begin<a contenteditable="false" data-primary="flexibility through conditionals" data-secondary="mapping out the workflow" data-tertiary="identifying code corresponding to diagram components" data-type="indexterm" id="ix_flexconmapgrID"/> looking at the code, but in a very directed way.<a contenteditable="false" data-primary="Workflow Description Language (WDL)" data-secondary="code corresponding to workflow diagram elements, identifying" data-type="indexterm" id="ix_WDLcode"/> Rather than scrolling through all of it sequentially, we’re going to look up specific elements of code based on what we see in the graph diagram. Here’s an outline of the method:</p>

<ol>
	<li>
	<p>List all tasks referenced in the graph (in ovals):</p>

	<pre data-type="programlisting">
CramToBamTask
HaplotypeCaller
MergeGVCFs</pre>
	</li>
	<li>
	<p>Open the WDL file in your text editor and search for the <code>call</code> statements for each task:</p>

	<pre data-type="programlisting" data-code-language="wdl">
<code class="k">call</code> <code class="n">CramToBamTask</code> <code class="p">{</code>          <code class="n">line</code> <code class="mi">68</code>
<code class="k">call</code> <code class="n">HaplotypeCaller</code> <code class="p">{</code>        <code class="n">line</code> <code class="mi">84</code> 
<code class="k">call</code> <code class="n">MergeGVCFs</code> <code class="p">{</code>             <code class="n">line</code> <code class="mi">100</code></pre>
	</li>
	<li>
	<p>For each call, capture the <code>call</code> statement and a few lines from the input definitions. If the task reference is shown inside a box in the graph, include the text that’s also in the box, like <code>if (is_cram)</code> in <a data-type="xref" href="#graph_description_in_json_left_parenthe">Figure 9-1</a>. Combine the code<a contenteditable="false" data-primary="MergeGVCFs tool" data-secondary="calls to, in graph and workflow code" data-type="indexterm" id="idm45625617124984"/> you captured into a table with <a contenteditable="false" data-primary="HaplotypeCaller" data-secondary="calls to, under control of scatter function" data-tertiary="in graph and workflow code" data-type="indexterm" id="idm45625617123512"/>screenshot slices of<a contenteditable="false" data-primary="CramToBamTask" data-secondary="calls to, in graph and workflow code" data-type="indexterm" id="idm45625617121672"/> the graph diagram, as shown in <a data-type="xref" href="#calls_to_cramtobamtaskcomma_haplotypeca">Table 9-1</a>.</p>
	</li>
</ol>

<table class="border" id="calls_to_cramtobamtaskcomma_haplotypeca">
	<caption><span class="label">Table 9-1. </span>Calls to CramToBamTask, HaplotypeCaller, and MergeGVCFs</caption>
	<thead>
		<tr>
			<th>Calls in graph</th>
			<th>Calls in workflow code</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="tabletest">
        <img alt="" src="Images/gitc_09in01-1.png" width="528" height="109"/></td>
			<td class="tabletest">
			<pre>
        if ( is cram ) {
          call CramToBamTask {
            input:
              input_cram = input_bam,
              ...
            }
        }
      </pre>
			</td>
		</tr>
		<tr>
			<td class="tabletest"><img alt="" src="Images/gitc_09in01-2.png" width="465" height="217"/></td>
			<td class="tabletest">
			<pre>
          scatter (interval_file in
          scattered_calling_intercals
          ) {
            ...
            call HaplotypeCaller {}
              input:
                input_am = 
          select_first([CramToBamTask.output_bam,
          input_bam]),
                ...
              }
          }
        </pre>
			</td>
		</tr>
		<tr>
			<td class="tabletest"><img class="width-75" alt="" src="Images/gitc_09in01-3.png" width="528" height="205"/></td>
			<td class="tabletest">
			<pre>
          call MergeGVCFs {
            input:
              input_vcfs = 
          HaplotypeCalle.output_vcf,
              ...
          }
        </pre>
			</td>
		</tr>
	</tbody>
</table>

<p>This captures a lot of useful information about the key elements of code that determine how the tasks are connected and how their operation is controlled. In the next section, we dive deeper into these snippets of code as we attempt to reverse engineer how this workflow works.</p>

<p>You might need to tweak this approach and use your judgment regarding how many lines of input definitions or other code to include. For example, you might need to look up the task definitions to guide your choice of which inputs to include given that some are more informative than others. With practice, you will learn to reduce complex workflows to the key parts of their plumbing that matter.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="confirm_what_cramtobamtask_does_for_ext">
<h5>Confirm What CramToBamTask Does for Extra Credit</h5>

<p>In the main text of this section, we’re assuming that the task names are a reliable reflection of the commands that they wrap.<a contenteditable="false" data-primary="CramToBamTask" data-secondary="confirming what it does" data-type="indexterm" id="idm45625617081416"/> If you’d like to check for yourself, scroll down through the workflow (or use text search) to find the task definition for <code>CramToBamTask</code>. You might feel like there’s a lot going on in there that you don’t recognize, and that’s perfectly normal. For now, don’t try to decipher everything; just zoom straight to the most important piece, the <code>command</code> block:</p>

<pre data-type="programlisting" data-code-language="wdl">
 <code class="k">command</code> <code class="p">{</code>
    <code class="n">set</code> <code class="o">-</code><code class="n">e</code>
    <code class="n">set</code> <code class="o">-</code><code class="n">o</code> <code class="n">pipefail</code>

    <code class="nv">$</code><code class="p">{</code><code class="n">samtools_path</code><code class="p">}</code> <code class="n">view</code> <code class="o">-</code><code class="n">h</code> <code class="o">-</code><code class="n">T</code> <code class="nv">$</code><code class="p">{</code><code class="n">ref_fasta</code><code class="p">}</code> <code class="nv">$</code><code class="p">{</code><code class="n">input_cram</code><code class="p">}</code> <code class="o">|</code>
    <code class="nv">$</code><code class="p">{</code><code class="n">samtools_path</code><code class="p">}</code> <code class="n">view</code> <code class="o">-</code><code class="n">b</code> <code class="o">-</code><code class="n">o</code> <code class="nv">$</code><code class="p">{</code><code class="n">sample_name</code><code class="p">}.</code><code class="n">bam</code> <code class="o">-</code>
    <code class="nv">$</code><code class="p">{</code><code class="n">samtools_path</code><code class="p">}</code> <code class="n">index</code> <code class="o">-</code><code class="n">b</code> <code class="nv">$</code><code class="p">{</code><code class="n">sample_name</code><code class="p">}.</code><code class="n">bam</code>
    <code class="n">mv</code> <code class="nv">$</code><code class="p">{</code><code class="n">sample_name</code><code class="p">}.</code><code class="n">bam</code><code class="p">.</code><code class="n">bai</code> <code class="nv">$</code><code class="p">{</code><code class="n">sample_name</code><code class="p">}.</code><code class="n">bai</code>
  <code class="p">}</code></pre>

<p>Again, a <a contenteditable="false" data-primary="samtools package" data-secondary="samtools_path" data-type="indexterm" id="idm45625617076072"/>lot is happening here, so let’s break it down line by line, making a few assumptions along the way based on variable names:</p>

<pre data-type="programlisting">
${samtools_path} view -h -T ${ref_fasta} ${input_cram} |</pre>

<p>We can reasonably infer that <code>samtools_path</code> refers to the popular <code>samtools</code> package, which provides tools for manipulating files in SAM, BAM, and CRAM format. <a contenteditable="false" data-primary="view command" data-type="indexterm" id="idm45625616984680"/>So this line must run the <code>view</code> command<a contenteditable="false" data-primary="samtools package" data-secondary="view command" data-type="indexterm" id="idm45625616983032"/> from the <code>samtools</code> package on <code>${input_cram}</code>, which presumably refers to an input file in CRAM format. Using <code>samtools view</code> is a common way to read in data before applying some transformations to it, and sure enough, there’s a pipe character (<code>|</code>) at the end of the line, so let’s see what we’re going to apply in the next line:</p>

<pre data-type="programlisting">
${samtools_path} view -b -o ${sample_name}.bam -</pre>

<p>It’s a<a contenteditable="false" data-primary="BAMs (Binary Alignment Maps)" data-secondary="output from samtools view command" data-type="indexterm" id="idm45625616978360"/> second invocation of <code>samtools view</code>, but this time the command specifies an output file (<code>-o</code>) preceded by the <code>-b</code> flag and with a <code>.bam</code> extension for the filename. This instructs <code>samtools</code> to write the output in BAM format. Hey, that amounts to converting the original file from CRAM to BAM! But wait, there’s more:</p>

<pre data-type="programlisting">
${samtools_path} index -b ${sample_name}.bam</pre>

<p>This runs "<code>samtools index</code>" on the newly created BAM file, which<a contenteditable="false" data-primary="samtools package" data-secondary="index command" data-type="indexterm" id="idm45625616972728"/> makes sense. <a contenteditable="false" data-primary="indexes" data-secondary="creating index files for output files" data-type="indexterm" id="idm45625616971224"/> GATK<a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="index files for output files" data-type="indexterm" id="idm45625616969720"/> tools are typically able to create index files for output files on the fly, but with <code>samtools</code>, you need to run the indexing command separately. So we do that, and we’re done. Right? No, this is bioinformatics, so of course we’re not done yet. We still need to rename the index because <code>samtools</code> names BAM index files with the pattern <code>${sample_name}.bam.bai,</code> but GATK expects the index filename to follow the pattern <code>${sample_name}.bai</code> (sigh):</p>

<pre data-type="programlisting">
mv ${sample_name}.bam.bai ${sample_name}.bai</pre>

<p>OK, so we use the common Unix <code>mv</code> utility to do that final renaming. <a contenteditable="false" data-primary="mv utility" data-type="indexterm" id="idm45625616964728"/><em>Now</em> we’re done. And we were correct: as <a data-type="xref" href="#calls_to_cramtobamtaskcomma_haplotypeca">Table 9-1</a> shows, this command takes in a CRAM file and converts it to a BAM file with an appropriately named index.</p>

<p>By the way, are you surprised that this <code>command</code> block involves multiple command lines? <a contenteditable="false" data-primary="Workflow Description Language (WDL)" data-secondary="command blocks with multiple command lines" data-type="indexterm" id="idm45625616960888"/>Yes, you can do that in WDL: basically, anything you can stick in<a contenteditable="false" data-primary="Bash shell" data-secondary="scripts in WDL command blocks" data-type="indexterm" id="idm45625616959272"/> a Bash script is OK to include in a WDL <code>command</code> block. At runtime, the system will execute each line in turn as if you were running them manually in your terminal. In fact, the first two lines in this block, <code>set -e</code> and <code>set -o pipefail</code>, instruct the system how to handle errors when you ask it to run multiple commands: stop at the first error or try to keep running the rest? Here we’re telling it to stop at the first error and consider the entire task to have failed.</p>

<p>Finally, if you’re wondering why<a contenteditable="false" data-primary="PrintReads tool" data-type="indexterm" id="idm45625616955752"/> there’s not a way to do all that with a simple one-line command, well, there actually <em>is</em> a way to do that: it’s a GATK4 tool called <code>PrintReads</code>. However, the original author of this workflow chose to use this <code>samtools</code> construct instead. They might or might not have had a good reason to do so; the point is that this is the sort of thing you will encounter all the time in real genomics workflows, so we might as well show you how to make sense of it.</p>

<p>We’re going to trust that the <code>HaplotypeCaller</code> and <code>MergeGVCFs</code> tasks are doing what their names suggest, but feel free to check them, as well—they should look very similar (though not identical) to the analogous tasks we examined in <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>.</p>
</div></aside>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Reverse Engineering the Conditional Switch"><div class="sect2" id="reverse_engineering_the_conditional_swi">
<h2>Reverse Engineering the Conditional Switch</h2>

<p>At  <a contenteditable="false" data-primary="graphs" data-secondary="identifying code corresponding to diagram elements" data-startref="ix_grphgenID" data-type="indexterm" id="idm45625616948344"/><a contenteditable="false" data-primary="Workflow Description Language (WDL)" data-secondary="code corresponding to workflow diagram elements, identifying" data-startref="ix_WDLcode" data-type="indexterm" id="idm45625616946568"/>this<a contenteditable="false" data-primary="graphs" data-secondary="generating graph diagram for workflow visualization" data-startref="ix_grphgen" data-type="indexterm" id="idm45625616944856"/><a contenteditable="false" data-primary="flexibility through conditionals" data-secondary="mapping out the workflow" data-startref="ix_flexconmapgrID" data-tertiary="identifying code corresponding to diagram components" data-type="indexterm" id="idm45625616943144"/> point, we’re<a contenteditable="false" data-primary="flexibility through conditionals" data-secondary="mapping out the workflow" data-startref="ix_flexconmap" data-type="indexterm" id="idm45625616941080"/> reasonably confident that we understand what the workflow is doing overall.<a contenteditable="false" data-primary="flexibility through conditionals" data-secondary="reverse engineering conditional switch" data-type="indexterm" id="ix_flexconcon"/> But we don’t yet understand how the conditional switch works and how the various tasks are wired together in practice. Let’s begin by looking at how the workflow logic is set up in the code.<a contenteditable="false" data-primary="if (is_cram) conditional switch" data-secondary="reverse engineering" data-type="indexterm" id="ix_ifcond"/></p>

<section data-type="sect3" data-pdf-bookmark="How is the conditional logic set up?"><div class="sect3" id="how_is_the_conditional_logic_set_upques">
<h3>How is the conditional logic set up?</h3>

<p>In the match-up diagram in <a data-type="xref" href="#calls_to_cramtobamtaskcomma_haplotypeca">Table 9-1</a>, we saw the box showing the <a contenteditable="false" data-primary="if (is_cram) conditional switch" data-secondary="reverse engineering" data-tertiary="how conditional logic is set up" data-type="indexterm" id="idm45625616932264"/>call to <code>CramToBamTask</code> under the control of the presumed conditional switch. We identified the corresponding code by searching for <code>call CramToBamTask</code> and capturing the lines around it that are likely to be involved:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">if</code> <code class="p">(</code> <code class="n">is_cram</code> <code class="p">)</code> <code class="p">{</code>
    <code class="k">call</code> <code class="n">CramToBamTask</code> <code class="p">{</code>
          <code class="k">input</code><code class="o">:</code>
            <code class="n">input_cram</code> <code class="o">=</code> <code class="n">input_bam</code><code class="p">,</code>
            <code class="p">...</code>
    <code class="p">}</code>
  <code class="p">}</code></pre>

<p>You can read this snippet of code as “If the <code>is_cram</code> condition is verified, call <code>CramToBamTask</code> and give it whatever was provided as <code>input_bam</code>.” This immediately brings up two important questions: how are we testing for that initial condition, and how are we handling the apparent contradiction in the <code>input_cram = input_bam</code> input assignment?</p>

<p>Let’s tackle the first question by scrolling up a bit in the workflow code until we find a reference to this mysterious <code>is_cram</code> variable. <a contenteditable="false" data-primary="is_cram variable" data-type="indexterm" id="idm45625616873448"/>And here it is on line 59:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="cp">#is the input a cram file?</code>
<code class="kt">Boolean</code> <code class="n">is_cram</code> <code class="o">=</code> <code class="n">sub</code><code class="p">(</code><code class="n">basename</code><code class="p">(</code><code class="n">input_bam</code><code class="p">),</code> <code class="s">".*</code><code class="se">\\</code><code class="s">."</code><code class="p">,</code> <code class="s">""</code><code class="p">)</code> <code class="o">==</code> <code class="s">"cram"</code></pre>

<p>Can you believe our luck? There’s a note of documentation that confirms that the purpose of this line of code is to answer the question “Is the input a CRAM file?” All we need to do is determine how that second line is answering it. Let’s look at the left side first, before the equals sign:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="kt">Boolean</code> <code class="n">is_cram</code>      </pre>

<p>This <a contenteditable="false" data-primary="Boolean variables" data-secondary="is_cram" data-type="indexterm" id="idm45625616800408"/>means “I’m declaring the existence of this Boolean variable named <code>is_cram</code>.” <em>Boolean</em> refers to a type of variable that can have only one of two values: True or False. This variable type is named after English mathematician George Boole, who was a big fan of logic. Right there with you, George! Boolean variables are useful for expressing and testing conditions succinctly.</p>

<p>The equals sign is our<a contenteditable="false" data-primary="variables" data-secondary="assigning value to" data-type="indexterm" id="idm45625616820472"/> value assignment statement, so whatever is on the other side is going to determine the value of the variable. Here’s what we see:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="n">sub</code><code class="p">(</code><code class="n">basename</code><code class="p">(</code><code class="n">input_bam</code><code class="p">),</code> <code class="s">".*</code><code class="se">\\</code><code class="s">."</code><code class="p">,</code> <code class="s">""</code><code class="p">)</code> <code class="o">==</code> <code class="s">"cram"</code></pre>

<p>Try to ignore everything that’s in parentheses on the left side and just read this as <code>something == "cram"</code>. The <code>A == B</code> syntax is a compact way of asking a question in code.<a contenteditable="false" data-primary="== (equality) operator" data-type="indexterm" id="idm45625616775336"/> You can ultimately read this as saying, “is A equal to B?” or bringing it back to this specific case, “is <code>something</code> equal to B?” So the full line now reads “My Boolean variable <code>is_cram</code> is True if <code>something</code> equals <code>cram</code>, and is False if <code>something</code> does not equal <code>cram</code>.”</p>

<p>So, what is this <code>something</code> that we’re testing? You might be able to guess it by now, but let’s keep decomposing the code methodically to get to the truth of the matter:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="n">sub</code><code class="p">(</code><code class="n">basename</code><code class="p">(</code><code class="n">input_bam</code><code class="p">),</code> <code class="s">".*</code><code class="se">\\</code><code class="s">."</code><code class="p">,</code> <code class="s">""</code><code class="p">)</code></pre>

<p>Hopefully, you remember the <code>basename()</code> function from <a data-type="xref" href="ch08.xhtml#automating_analysis_execution_with_work">Chapter 8</a>; it’s how we were able to name outputs based on the name of the input files.<a contenteditable="false" data-primary="basename function (WDL)" data-secondary="naming outputs based on name of input files" data-type="indexterm" id="idm45625616739224"/> At some point we’re going to give this workflow some real inputs to run on, and the execution engine will match up the variable and the file path like this:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="kt">File</code> <code class="n">input_bam</code> <code class="o">=</code> <code class="s">"gs://my-bucket/sample.bam"</code></pre>

<p>When we just give the <code>basename()</code> function a file path, as in <code>basename(input_bam)</code>, it produces the string <code>sample.bam</code>. If we also give it a substring, as in <code>basename(input_bam, ".bam")</code>, it will additionally clip that off to produce the string <code>sample</code>. This is convenient for naming an output the same thing as the input, but with a different file extension.</p>

<p>Here the<a contenteditable="false" data-primary="sub function (WDL)" data-type="indexterm" id="idm45625616711896"/> workflow adds another layer of string manipulation by using the <code>sub()</code> function (also from the WDL standard library) to replace part of the string with something else. You use <code>sub()</code> like this:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="n">sub</code><code class="p">(</code><code class="s">"string to modify"</code><code class="p">,</code> <code class="s">"substring or pattern we want to replace"</code><code class="p">,</code> <code class="s">"replacement"</code><code class="p">)</code></pre>

<p>With that information, we <a contenteditable="false" data-primary="basename function (WDL)" data-secondary="using with sub function" data-type="indexterm" id="idm45625616704936"/>can now interpret the full <code>sub()</code> command, as seen in the workflow:</p>

<ol>
	<li>
	<p>Take the basename of our input file:</p>

	<pre data-type="programlisting">
basename(input_bam)     "sample.bam"</pre>
	</li>
	<li>
	<p>Separate the part up to the last period:</p>

	<pre data-type="programlisting">
".*\\."            "sample."+"bam"</pre>
	</li>
	<li>
	<p>Replace that part by nothing:</p>

	<pre data-type="programlisting">
""                ""+"bam"</pre>
	</li>
	<li>
	<p>Output whatever is left:</p>

	<pre data-type="programlisting">
"bam"</pre>
	</li>
</ol>

<p>What is left? It’s the file extension! So finally, we can say for sure that that one line of code means “My Boolean variable <code>is_cram</code> is True if the input file extension equals <code>cram</code>, and is False if the input file extension does not equal <code>cram</code>.”</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You might argue that it would be worth adding a function to the WDL standard library to grab the file extension without having to jump through these string substitution hoops. If you feel very strongly about it, let the WDL maintainers know by posting an issue in the <a href="https://oreil.ly/Td9bp">OpenWDL repository</a>, and maybe they will add it! That’s how a community-driven language evolves: based on feedback from the people who use it.</p>
</div>

<p>Now that we know where the value of the <code>is_cram</code> variable comes from, we understand exactly how the flow is controlled: if we provide a file with a <em>.cram</em> extension as input to the workflow, the call to <code>CramToBamTask</code> will run on the file provided as input. If we provide anything else, that task will be skipped and the workflow will start at the next call, <code>HaplotypeCaller</code>. Switch on, switch off.</p>

<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625616639992">
<h5>What’s in a Name?</h5>

<p>Do you remember the second question we raised when we initially looked at the <code>CramToBamTask</code> call? Isn’t it weird that the code for the input assignments says "<code>input_cram = input_bam</code>“? Indeed, it would be better to use a less specific variable name for the input file in order to reflect that the workflow can’t “know” the file format until it starts running. However, this particular workflow was originally written to run directly on BAM files and then the conversion task was added at a later date by someone who decided not to mess with the existing variable name. That teaches us a lesson about the meaningfulness of task and variable names: you can’t assume they’re always 100% reliable.</p>
</div></aside>

<p>OK, what’s next? Well, before you go running off to the next feature, we have some more work to do to fully understand how the conditional switch affects the rest of the workflow. Conditionals are a really neat way to make workflows more flexible and multipurpose, but they tend to have a few side effects that you need to understand and watch out for. Let’s go over two important questions that we need to ask ourselves when we’re dealing with conditionals.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Does the conditional interfere with any assumptions we’re making anywhere else?"><div class="sect3" id="does_the_conditional_interfere_with_any">
<h3>Does the conditional interfere with any assumptions we’re making anywhere else?</h3>

<p>If we’re using a conditional<a contenteditable="false" data-primary="if (is_cram) conditional switch" data-secondary="reverse engineering" data-tertiary="questioning whether conditional interferes with other assumptions" data-type="indexterm" id="idm45625616634312"/> to allow multiple file types to be used as input, we can’t know ahead of time what the extension might be for any given run. Yet a lot of genomics workflows, including this one, use <code>basename()</code> to name outputs based on the input name. That typically involves specifying what file extension to trim off the end of the input filename.<a contenteditable="false" data-primary="basename function (WDL)" data-secondary="specifying file extension to trim off at end of input filename" data-type="indexterm" id="idm45625616614824"/> The workflow must deal with that ambiguity explicitly.</p>

<p>At this point, you could do a text search for “basename” to find the code we need to investigate, but in our case, what we’re looking for is on the very next line of code, after the <code>is_cram</code> variable assignment:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="kt">String</code> <code class="n">sample_basename</code> <code class="o">=</code> <code class="k">if</code> <code class="n">is_cram</code> <code class="n">then</code> <code class="n">basename</code><code class="p">(</code><code class="n">input_bam</code><code class="p">,</code> <code class="s">".cram"</code><code class="p">)</code> <code class="k">else</code>
<code class="n">basename</code><code class="p">(</code><code class="n">input_bam</code><code class="p">,</code> <code class="s">".bam"</code><code class="p">)</code></pre>

<p>This is another variable declaration, stating the variable’s type (<code>String</code>) and name (<code>sample_basename</code>) on the left side of the equals sign, with a value assignment on the right. Let’s look at that value assignment in more detail:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">if</code> <code class="n">is_cram</code> <code class="n">then</code> <code class="n">basename</code><code class="p">(</code><code class="n">input_bam</code><code class="p">,</code> <code class="s">".cram"</code><code class="p">)</code> <code class="k">else</code> <code class="n">basename</code><code class="p">(</code><code class="n">input_bam</code><code class="p">,</code> <code class="s">".bam"</code><code class="p">)</code></pre>

<p>If you read that out loud, it’s almost reasonable English, and it takes only a few additional words of interpretation to make complete sense:</p>

<p>“If the input is a CRAM file, run the <code>basename</code> function with the <em>.cram</em> extension; otherwise, run it with the <em>.bam</em> extension.”</p>

<p>Problem solved! It’s not the only way to achieve that result in WDL but it’s probably the most readily understandable. In fact, if you look carefully at the next few lines in the workflow, you should be able to find and interpret another (unrelated) conditional variable assignment that’s doing something very similar, though that one comes into play at the other end of the pipeline.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="How does the next task know what to run on?"><div class="sect3" id="how_does_the_next_task_know_what_to_run">
<h3>How does the next task know what to run on?</h3>

<p>Depending on the format of the input file, <code>HaplotypeCaller</code> will be either the first or the second task<a contenteditable="false" data-primary="conditionals" data-secondary="how the next task knows what to run on" data-type="indexterm" id="idm45625616541800"/> called in the workflow. If it’s the first, it should run on the original input file; if it’s the second, it should take the output of the first task. How does the workflow code handle that?</p>

<p>Have another look at <a data-type="xref" href="#calls_to_cramtobamtaskcomma_haplotypeca">Table 9-1</a>, which showed how the code maps to the graph diagram. This was the code we highlighted at the time for the call to <code>HaplotypeCaller</code>:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">scatter</code> <code class="p">(...)</code> <code class="p">{</code>
  <code class="p">...</code>
  <code class="k">call</code> <code class="n">HaplotypeCaller</code> <code class="p">{</code>
      <code class="k">input</code><code class="o">:</code>
        <code class="n">input_bam</code> <code class="o">=</code> <code class="n">select_first</code><code class="p">([</code><code class="n">CramToBamTask</code><code class="p">.</code><code class="n">output_bam</code><code class="p">,</code> <code class="n">input_bam</code><code class="p">]),</code>
        <code class="p">...</code>
   <code class="p">}</code>
<code class="p">}</code></pre>

<p>And there it is: in the input <a contenteditable="false" data-primary="select_first function" data-type="indexterm" id="idm45625616488696"/>section of the call statement, we see that the <code>input_bam</code> is being set with yet another function, <code>select_first()</code>. The name suggests it’s in charge of selecting something that comes first, and we see it’s reading in an array of values, but it’s not super obvious what that means, is it? If we just wanted it to use the first element in the array, why give it that array in the first place?</p>

<p>Yep, this is a bit of an odd one. The subtlety is that <code>select_first()</code> is designed to tolerate missing values, which is necessary when you’re dealing with conditionals: depending on what path you follow, you might generate some outputs but not others. Most WDL functions will choke and fail if you try to give them an output that doesn’t exist. In contrast, <code>select_first()</code> will simply ask: what else do you have that might be available?</p>

<p>So, in light of that information, let’s look at that value assignment again in more detail. Here’s a handy way to represent how the code can be broken into segments of meaning:</p>

<table>
	<tbody>
		<tr>
			<td><code>input_bam = select_first([</code></td>
			<td class="width-40"><code>CramToBamTask.output_bam</code></td>
			<td><code>, input_bam])</code></td>
		</tr>
		<tr>
			<td>The input file for <code>HaplotypeCaller</code> should be...</td>
			<td>...the output from <code>CramToBamTask</code>...</td>
			<td>...but if that doesn’t exist, just use the original input file.</td>
		</tr>
	</tbody>
</table>

<p>At the moment in time when the workflow execution engine is evaluating what tasks need to be run and on what inputs/outputs, the output of the first task doesn’t exist yet. However, that output might be created at a later point, so the engine can’t just start running <code>HaplotypeCaller</code> willy-nilly on what might be a CRAM file. It must check the input file format to resolve the ambiguity, determine what tasks will run, and what outputs to expect. Having done that, the engine is able to evaluate the result of the <code>select_first()</code> function. If it determines that the <code>CramToBamTask</code> will run, it will hold off on running the <code>HaplotypeCaller</code> task until the <em>CramToBamTask.output_bam</em> has been generated. Otherwise, it can go ahead with the original input.</p>

<p>Hopefully, that makes more sense now.<a contenteditable="false" data-primary="if (is_cram) conditional switch" data-secondary="reverse engineering" data-startref="ix_ifcond" data-type="indexterm" id="idm45625616474776"/> Though it might prompt a new question in your mind...</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Can we use conditionals to manage default settings?"><div class="sect3" id="can_we_use_conditionals_to_manage_defau">
<h3>Can we use conditionals to manage default settings?</h3>

<p>Yes, yes you can! <a contenteditable="false" data-primary="conditionals" data-secondary="using to manage default settings" data-type="indexterm" id="idm45625616471176"/>If you skimmed through the workflow-level<a contenteditable="false" data-primary="Workflow Description Language (WDL)" data-secondary="using conditionals to manage default settings" data-type="indexterm" id="idm45625616469560"/> inputs, you might have noticed pairs of lines like this that look unusually complex for what should be straightforward variable declarations:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="kt">String</code><code class="o">?</code> <code class="n">gatk_docker_override</code>
<code class="kt">String</code> <code class="n">gatk_docker</code> <code class="o">=</code> <code class="n">select_first</code><code class="p">([</code><code class="n">gatk_docker_override</code><code class="p">,</code> 
                                  <code class="s">"us.gcr.io/broad-gatk/gatk:4.1.0.0"</code><code class="p">])</code>
</pre>

<p>The first line in the pair simply declares a variable named <code>gatk_docker_override</code>, which was marked as optional<a contenteditable="false" data-primary="optional variables" data-type="indexterm" id="idm45625616437144"/> by adding the question mark (<code>?</code>) after the<a contenteditable="false" data-primary="? (question mark) indicating optional variable" data-type="indexterm" id="idm45625616430472"/> variable type (<code>String</code>).<a contenteditable="false" data-primary="variables" data-secondary="optional" data-type="indexterm" id="idm45625616428696"/> Based on its name, it sounds like this variable would allow us to override the choice of Docker container image used to run GATK tasks, presumably by specifying one in the JSON file we hand to Cromwell at runtime. This implies that there’s a preset value somewhere, but we haven’t seen a variable declaration for that yet.</p>

<p>We find it in the second line<a contenteditable="false" data-primary="select_first function" data-type="indexterm" id="idm45625616426536"/> in the pair, which declares a variable named <code>gatk_docker</code> and assigns it a value using the <code>select_first()</code> function. Let’s try breaking down that line the same way we did earlier, with a few adaptations based on context:</p>

<table>
	<tbody>
		<tr>
			<td><code>String gatk_docker = select_first([</code></td>
			<td><code>gatk_docker_override</code></td>
			<td><code>, "us.gcr.io/broad-gatk/gatk:4.1.0.0"])</code></td>
		</tr>
		<tr>
			<td>The GATK Docker image should be...</td>
			<td>...what we provide in the JSON file of inputs...</td>
			<td>...but if we didn’t provide one, just use <code>us.gcr.io/broad-gatk/gatk:4.1.0.0</code> by default.</td>
		</tr>
	</tbody>
</table>

<p>Isn’t that neat? This is not the only way to set and manage default values in WDL, and it’s admittedly not the most readily understandable if you’re not familiar with the <code>select_first()</code> function. However, it’s a very convenient way for the workflow author to peg their workflow to specific versions of software, environment <span class="keep-together">expectations</span>, resource allocations, and so on, while still allowing a lot of flexibility for using alternative settings without having to modify the code. You will encounter this pattern frequently in most up-to-date GATK workflows produced by the Broad <span class="keep-together">Institute.</span></p>

<p>That wraps up our exploration of Mystery Workflow #1, which turned out to be a rather garden-variety <code>HaplotypeCaller</code> workflow hopped up with a few conditional statements. It had a few twists that mostly had to do with the consequences of using conditionals; but overall, the complexity was moderate. Let’s see if Mystery Workflow #2 can take us a little bit further up<a contenteditable="false" data-primary="flexibility through conditionals" data-secondary="reverse engineering conditional switch" data-startref="ix_flexconcon" data-type="indexterm" id="idm45625616414904"/> the scale of WDL complexity.<a contenteditable="false" data-primary="flexibility through conditionals" data-startref="ix_flexcon" data-type="indexterm" id="idm45625616413048"/><a contenteditable="false" data-primary="workflows" data-secondary="deciphering real genomics workflows" data-startref="ix_wkfrealmys1" data-tertiary="myster workflow, flexibility through conditionals" data-type="indexterm" id="idm45625616391752"/></p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Mystery Workflow #2: Modularity and Code Reuse"><div class="sect1" id="mystery_workflow_modularity_and_code">
<h1>Mystery Workflow #2: Modularity and Code Reuse</h1>

<p>Oh yes, now we’re<a contenteditable="false" data-primary="modularity and code reuse" data-type="indexterm" id="ix_modreu"/> in the big leagues: without<a contenteditable="false" data-primary="workflows" data-secondary="deciphering real genomics workflows" data-tertiary="mystery workflow, modularity and code reuse" data-type="indexterm" id="ix_wkfrealmod"/> spoiling the story, we can tell you that this one is a major pipeline that runs in production at the Broad Institute. It does a ton of work and involves many tools. It’s going to teach us a lot about how to build modular pipelines and minimize duplication of code. Let’s break it down.</p>

<p>First, make an environment variable pointing to the code, just as you did for the first workflow:</p>

<pre data-type="programlisting">
$ export CASE2=~/book/code/workflows/mystery-2</pre>

<p>We can use<a contenteditable="false" data-primary="sandbox directory" data-secondary="creating to store workflow outputs" data-type="indexterm" id="idm45625616382488"/> the same sandbox as the first workflow, <em>~/sandbox-9/</em>.</p>

<section data-type="sect2" data-pdf-bookmark="Mapping Out the Workflow"><div class="sect2" id="mapping_out_the_workflow">
<h2>Mapping Out the Workflow</h2>

<p>Let’s see if we can apply<a contenteditable="false" data-primary="modularity and code reuse" data-secondary="mapping out the workflow" data-type="indexterm" id="ix_modreumap"/> the same approach as for the previous workflow: generate the graph diagram and then map the call statements in the code back to the task bubbles in the diagram.</p>

<section data-type="sect3" data-pdf-bookmark="Generating the graph diagram"><div class="sect3" id="generating_the_graph_diagram">
<h3>Generating the graph diagram</h3>

<p>You know <a contenteditable="false" data-primary="modularity and code reuse" data-secondary="mapping out the workflow" data-tertiary="generating graph diagram" data-type="indexterm" id="ix_modreumapgr"/>the drill: first, let’s<a contenteditable="false" data-primary="graphs" data-secondary="generating graph diagram for workflow visualization" data-type="indexterm" id="ix_grphgenmod"/> whip out <code>womtool graph</code> to make the DOT file:</p>

<pre class="small" data-type="programlisting">
$ java -jar $BIN/womtool-48.jar graph $CASE2/WholeGenomeGermlineSingleSample.wdl  \
    &gt; ~/sandbox-9/WholeGenomeGermlineSingleSample.dot</pre>

<p>Next, open the DOT file; does it look any <a contenteditable="false" data-primary="DOT file describing workflow structure" data-type="indexterm" id="idm45625616368856"/>longer than the other one to you?</p>

<pre data-code-language="msc" data-type="programlisting">
<code class="err">$</code><code class="w"> </code><code class="nv">cat</code><code class="w"> </code><code class="err">~/</code><code class="nv">sandbox</code><code class="err">-</code><code class="nv">9</code><code class="err">/</code><code class="nv">WholeGenomeGermlineSingleSample</code><code class="err">.</code><code class="nv">dot</code><code class="w"/>
<code class="nv">digraph</code><code class="w"> </code><code class="nv">WholeGenomeGermlineSingleSample</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w"> </code><code class="c1">#rankdir=LR;</code>
<code class="w"> </code><code class="nv">compound</code><code class="o">=</code><code class="nv">true</code><code class="p">;</code><code class="w"/>
<code class="w"> </code><code class="c1"># Links</code>
<code class="w"> </code><code class="nv">CALL_UnmappedBamToAlignedBam</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_BamToCram</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_UnmappedBamToAlignedBam</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_CollectRawWgsMetrics</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_UnmappedBamToAlignedBam</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_CollectWgsMetrics</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_UnmappedBamToAlignedBam</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_AggregatedBamQC</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_UnmappedBamToAlignedBam</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_BamToGvcf</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_AggregatedBamQC</code><code class="w"> </code><code class="o">-&gt;</code><code class="w"> </code><code class="nv">CALL_BamToCram</code><code class="w"/>
<code class="w"> </code><code class="c1"># Nodes</code>
<code class="w"> </code><code class="nv">CALL_AggregatedBamQC</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call AggregatedBamQC"</code><code class="err">;</code><code class="na">shape</code><code class="o">=</code><code class="s">"oval"</code><code class="err">;</code><code class="na">peripheries</code><code class="o">=</code><code class="s">2</code><code class="p">]</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_BamToGvcf</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call BamToGvcf"</code><code class="err">;</code><code class="na">shape</code><code class="o">=</code><code class="s">"oval"</code><code class="err">;</code><code class="na">peripheries</code><code class="o">=</code><code class="s">2</code><code class="p">]</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_UnmappedBamToAlignedBam</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call</code>
<code class="s">UnmappedBamToAlignedBam"</code><code class="err">;</code><code class="na">shape</code><code class="o">=</code><code class="s">"oval"</code><code class="err">;</code><code class="na">peripheries</code><code class="o">=</code><code class="s">2</code><code class="p">]</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_BamToCram</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call BamToCram"</code><code class="err">;</code><code class="na">shape</code><code class="o">=</code><code class="s">"oval"</code><code class="err">;</code><code class="na">peripheries</code><code class="o">=</code><code class="s">2</code><code class="p">]</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_CollectRawWgsMetrics</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call CollectRawWgsMetrics"</code><code class="p">]</code><code class="w"/>
<code class="w"> </code><code class="nv">CALL_CollectWgsMetrics</code><code class="w"> </code><code class="p">[</code><code class="na">label</code><code class="o">=</code><code class="s">"call CollectWgsMetrics"</code><code class="p">]</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Hmm, that doesn’t seem all that long. Considering we told you it involves a lot of tools, the graph file seems rather underwhelming. Let’s visualize it: copy the contents of the graph file into the panel on the left side in the <a href="https://oreil.ly/TpWlW">online Graphviz app</a>, as you’ve done before to produce the graph diagram, as depicted in <a data-type="xref" href="#visual_rendering_of_the_workflow_graphd">Figure 9-2</a>.</p>

<figure><div id="visual_rendering_of_the_workflow_graphd" class="figure"><img alt="Visual rendering of the workflow graph." src="Images/gitc_0903.png" width="1429" height="304"/>
<h6><span class="label">Figure 9-2. </span>Visual rendering of the workflow graph.</h6>
</div></figure>

<p>What’s the first thing that is visually different compared to the previous workflow diagrams we’ve looked at?</p>

<p>There are no boxes, and some of the ovals representing the calls to tasks have a double outline. We don’t have any grounding yet for guessing what the double outline signifies, so let’s make a note of that as something to solve. However, we do know from the two previous workflows we looked at that <code>scatter</code> blocks show up as boxes, so the absence of boxes in this diagram suggests that, at the very least, this workflow does not have any parallelized steps. Does that seem likely to you given how much we’ve been talking up the parallelization capabilities of the cloud? (Yes; we know that’s called <a href="https://oreil.ly/zkdiz"><em>leading the witness</em></a>.)</p>

<p>Just as we did for the first workflow, let’s try to form a hypothesis about what the workflow does based on the names of the task calls and their relative positions in the graph diagram.</p>

<p>The very<a contenteditable="false" data-primary="BAMs (Binary Alignment Maps)" data-secondary="UnmappedBamToAlignedBam task" data-type="indexterm" id="idm45625616210152"/> first<a contenteditable="false" data-primary="UnmappedBamToAlignedBam" data-type="indexterm" id="idm45625616208584"/> oval is<a contenteditable="false" data-primary="mapping information for reads" data-secondary="unmapped BAM, converting to mapped BAM" data-type="indexterm" id="idm45625616207320"/> labeled <code>call UnmappedBamToAlignedBam</code>, which suggests a transformation from the unmapped BAM file format that we referenced (ever so briefly) in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.xhtml#genomics_in_a_nutshell_a_primer_for_new">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.xhtml#best_practices_for_germline_short_varia">6</a> to an aligned BAM file—or as we’ll call it for consistency, a mapped BAM file. Based on what you learned of the data preprocessing pipeline in <a data-type="xref" href="ch06.xhtml#best_practices_for_germline_short_varia">Chapter 6</a>, that sounds like it could correspond to the step that applies the mapping to the raw unmapped data.</p>

<p>That first oval then connects to all five other ovals in the diagram, including the last one, which seems mighty strange but OK. Four of those ovals are on the same level, one step down from the first, and seem to be completely independent of one another.<a contenteditable="false" data-primary="whole genome sequencing" data-secondary="collecting metrics on" data-type="indexterm" id="idm45625616200728"/> The two on the left have names that suggest they collect metrics related to WGS data (<code>call CollectWgsMetrics</code> and <code>call CollectRawWgsMetrics</code>), which would make sense as a quality-control step applied to evaluate the mapped BAM produced by the first call. <a contenteditable="false" data-primary="CollectRawWgsMetrics task" data-type="indexterm" id="idm45625616198232"/><a contenteditable="false" data-primary="CollectWgsMetrics task" data-type="indexterm" id="idm45625616197096"/>In addition, they are both end nodes on their respective branches and have a single-line outline, so there’s probably not much more to them than meets the eye.</p>

<p>The third<a contenteditable="false" data-primary="BAMs (Binary Alignment Maps)" data-secondary="AggregatedBamQC task call" data-type="indexterm" id="idm45625616195048"/> oval <a contenteditable="false" data-primary="AggregatedBamQC" data-type="indexterm" id="idm45625616193528"/>from the left, labeled <code>call AggregatedBamQC</code>, also evidently involves quality control, but what is the “aggregated BAM” to which it is applied? If the original data was divided among several read groups as recommended in the GATK Best Practices, it would make sense to have an “aggregated BAM” after the read group data has been merged per sample.<a contenteditable="false" data-primary="read groups" data-secondary="merging per sample" data-type="indexterm" id="idm45625616191496"/> However…do you remember from <a data-type="xref" href="ch06.xhtml#best_practices_for_germline_short_varia">Chapter 6</a> when the merge step happens in the Best Practices pipeline? It happens <em>after</em> the mapping, during the duplicate marking step.<a contenteditable="false" data-primary="duplicate marking" data-type="indexterm" id="idm45625616188488"/> Unless we’re totally off base in our interpretation of these task names, this would suggest that the duplicate marking and merging is happening within the same task as the mapping. That is technically feasible with a WDL workflow but generally not advisable from the point of view of performance: the mapping can be massively parallelized, but the duplicate marking cannot, so it would be a bad idea to bundle both of them for execution within the same task. Hold on to that thought.</p>

<p>Interestingly, the <code>call AggregatedBamQC</code> task does have a child node one more level down; it <a contenteditable="false" data-primary="CRAMs" data-secondary="BamToCram task" data-type="indexterm" id="idm45625616185736"/><a contenteditable="false" data-primary="BamToCram task" data-type="indexterm" id="idm45625616184360"/>links to the oval labeled <code>call BamToCram</code>, which is also dependent on the first oval. <code>BamToCram</code> by itself sounds like the exact opposite of the <code>CramToBamTask</code> that you encountered in the previous workflow, so let’s venture to guess that this one allows you to create a CRAM file for archival purposes based on the mapped BAM created by the first step. Presumably, if the data in that file is considered ready for archival, it must have already been fully preprocessed, which lends further support to the idea that that first step is doing much more than just mapping the reads to the reference. As to the contribution of the <code>AggregatedBamQC</code> task, let’s suppose for now that there is something that affects the cramming step that is decided based on the results of the quality control analysis.</p>

<p>Finally, that<a contenteditable="false" data-primary="BamToGvcf task" data-type="indexterm" id="idm45625616180392"/> just leaves the rightmost oval on the second level, an end node that is labeled <code>call BamToGvcf</code>. That sounds very familiar indeed; would you care to take a guess?<a contenteditable="false" data-primary="GVCF data format" data-secondary="generating GVCF of variant calls" data-type="indexterm" id="idm45625616178712"/> Are you sick of seeing <code>HaplotypeCaller</code> everywhere yet?</p>

<p>So just based on the graph diagram, the names of the calls, and the way they connect to one another, we’ve provisionally deduced that this pipeline takes in raw unmapped sequencing data (which is probably whole genome sequence), maps it, applies some quality control, creates a CRAM archive, and generates a GVCF of variant calls that will be suitable for joint calling. That’s a lot of work for such an apparently minimalistic pipeline; we should probably dig into that.<a contenteditable="false" data-primary="graphs" data-secondary="generating graph diagram for workflow visualization" data-startref="ix_grphgenmod" data-type="indexterm" id="idm45625616175784"/><a contenteditable="false" data-primary="modularity and code reuse" data-secondary="mapping the workflow" data-startref="ix_modreumapgr" data-tertiary="generating graph diagram" data-type="indexterm" id="idm45625616174040"/></p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Identifying the code that corresponds to the diagram components"><div class="sect3" id="identifying_the_code_that_corresponds_t">
<h3>Identifying the code that corresponds to the diagram components</h3>

<p>The book says<a contenteditable="false" data-primary="graphs" data-secondary="identifying code corresponding to  diagram elements" data-type="indexterm" id="ix_grphmodID"/> that we must<a contenteditable="false" data-primary="modularity and code reuse" data-secondary="mapping out the workflow" data-tertiary="identifying code corresponding to diagram components" data-type="indexterm" id="ix_modreumapID"/> match the code with the diagram now, and you can’t argue with a book, so in your text editor, go ahead and open the WDL file and follow the same steps as you did for the first workflow. List all tasks referenced in the graph (in ovals) and then, for each task, search for the call statement. For each call, capture the call statement and a few lines from the input definitions. Combine the code you captured into a table with screenshot slices of the graph diagram, as shown in <a data-type="xref" href="#calls_to_unmappedbamtoalignedbamcomma_a">Table 9-2</a>.</p>

<table class="border" id="calls_to_unmappedbamtoalignedbamcomma_a">
	<caption><span class="label">Table 9-2. </span>Workflow calls in the graph (left) and in WDL code (right)</caption>
	<thead>
		<tr>
			<th>Workflow calls in the graph</th>
			<th>Workflow calls in WDL code</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td class="tabletest">
        <img alt="" src="Images/gitc_09in02-1.png" width="512" height="117"/></td>
			<td class="tabletest">
			<pre>
        call ToBam.UnmappedGamToAlignedBam {
          input:
            sample_and_unmapped_bams =
        sample_and_unmapped_bams,
            ...
        }
      </pre>
			</td>
		</tr>
		<tr>
			<td class="tabletest"><img alt="" src="Images/gitc_09in02-2.png" width="355" height="117"/></td>
			<td class="tabletest">
			<pre>
          call AggregatedQC.AggregatedBamQC {
            input:
              base_recalibrated_bam = 
          UnmappedBamToAlignedBam.output_bam,
              ...
          }
        </pre>
			</td>
		</tr>
		<tr>
			<td class="tabletest"><img alt="" src="Images/gitc_09in02-3.png" width="355" height="117"/></td>
			<td class="tabletest">
			<pre>
          call ToCram.BamToCram as BamToCram {
            input:
              input_bam = 
          UnmappedBamToAlignedBam.output_bam,
              ...
          }
        </pre>
			</td>
		</tr>
		<tr>
			<td class="tabletest"><img alt="" src="Images/gitc_09in02-4.png" width="374" height="117"/></td>
			<td class="tabletest">
			<pre>
          #QC the sample WGS metrics (stringent thresholds)
          call QC.CollectWgsMetrics as 
          CollectWgsMetrics{
            input:
              input_bam =
          UnmappedBamToAlignedBam.output_bam,
          ...
        }
        </pre>
			</td>
		</tr>
		<tr>
			<td class="tabletest"><img alt="" src="Images/gitc_09in02-5.png" width="439" height="117"/></td>
			<td class="tabletest">
			<pre>
          #QC the sample WGS metrics (common thresholds)
          call QC.CollectRawWgsMetrics as 
          CollectWgsMetrics{
            input:
              input_bam =
          UnmappedBamToAlignedBam.output_bam,
          ...
        }
        </pre>
			</td>
		</tr>
		<tr>
			<td class="tabletest"><img alt="" src="Images/gitc_09in02-6.png" width="272" height="117"/></td>
			<td class="tabletest">
			<pre>
          call ToGvcf.VariantCalling as BamToGvcf {
            input:
              ...
              input_bam = 
          UnmappedBamToAlignedBam.output_bam,
              ...
          }
        </pre>
			</td>
		</tr>
	</tbody>
</table>

<p>Looking at the code for these calls, something odd pops right up. The task names look a bit weird. <a contenteditable="false" data-primary="UnmappedBamToAlignedBam" data-type="indexterm" id="idm45625616141944"/>Check out the first one:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">call</code> <code class="n">ToBam</code><code class="p">.</code><code class="n">UnmappedBamToAlignedBam</code></pre>

<p>Did you know periods are allowed in task names in WDL? (Spoiler: they’re not.)</p>

<p>You can try searching for <code>ToBam.UnmappedBamToAlignedBam</code> to find the task definition; usually that can be helpful for figuring what’s going on here. But here’s a twist: you’re not going to find it in this file. Go ahead, scroll down as much as you want; this WDL workflow does not contain any task definitions. (What?)</p>

<p>However, searching for either the first part of the name, <code>ToBam</code>, or the second, <code>UnmappedBamToAlignedBam</code>, does bring up this line in a stack of other similar lines that we ignored when we originally started looking at the workflow:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">import</code> <code class="s">"tasks/UnmappedBamToAlignedBam.wdl"</code> <code class="k">as</code> <code class="n">ToBam</code></pre>

<p>Aha. That’s new; it looks like we’re referencing other WDL files.<a contenteditable="false" data-primary="import statements" data-type="indexterm" id="idm45625616132536"/> In the preceding line, the <code>import</code> part points to another WDL file called <em>UnmappedBamToAlignedBam.wdl</em>, located in a subdirectory called <em>tasks</em>. Now things are starting to make sense: when the workflow engine reads that, it’s going to import whatever code is in that file and consider it part of the overall workflow.  The <code>as ToBam</code> part of this import statement assigns an alias so that we can refer to content from the imported file without having to reference the full file path. For example, this was <a contenteditable="false" data-primary="aliases in WDL" data-secondary="referring to content from imported files" data-type="indexterm" id="idm45625616129000"/>the call we encountered earlier:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">call</code> <code class="n">ToBam</code><code class="p">.</code><code class="n">UnmappedBamToAlignedBam</code></pre>

<p>We can interpret this as saying, “From the <code>ToBam</code> code, call <code>UnmappedBamToAlignedBam.</code>” So what is <code>UnmappedBamToAlignedBam</code>? Is it a task? Have a quick peek inside the WDL file referenced in the <code>import</code> statement and then take a deep breath. It’s a full workflow in its own right, called <code>UnmappedBamToAlignedBam</code>:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="cp"># WORKFLOW DEFINITION</code>
<code class="k">workflow</code> <code class="n">UnmappedBamToAlignedBam</code> <code class="p">{</code></pre>

<p>We’re dealing with a workflow of workflows? Voltron, assemble!</p>

<p>This is actually a happy surprise. <a contenteditable="false" data-primary="workflows" data-secondary="of workflows" data-type="indexterm" id="idm45625615998024"/>We suspected coming in that this was going to be a rather complex pipeline, even though the graph diagram initially gave us the wrong impression. So the discovery that it uses imports to tie together several simpler workflows into a mega-workflow is a good thing because it’s going to allow us to investigate the pipeline in smaller chunks at a time. In effect, the workflow authors have already done the hard work of identifying the individual segments that can be logically and functionally separated from the others.</p>

<p>Now we need to see how the workflow nesting works, beyond just the import statements. Surely there’s some additional wiring that we need to understand, like how are outputs<a contenteditable="false" data-primary="graphs" data-secondary="identifying code corresponding to  diagram elements" data-startref="ix_grphmodID" data-type="indexterm" id="idm45625616095304"/> passed<a contenteditable="false" data-primary="modularity and code reuse" data-secondary="mapping out the workflow" data-startref="ix_modreumapID" data-tertiary="identifying code corresponding to diagram components" data-type="indexterm" id="idm45625616093560"/> around from one subworkflow to the next?<a contenteditable="false" data-primary="modularity and code reuse" data-secondary="mapping out the workflow" data-startref="ix_modreumap" data-type="indexterm" id="idm45625616086824"/></p>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Unpacking the Nesting Dolls"><div class="sect2" id="unpacking_the_nesting_dolls">
<h2>Unpacking the Nesting Dolls</h2>

<p>We begin by<a contenteditable="false" data-primary="modularity and code reuse" data-secondary="unpacking workflow nesting" data-type="indexterm" id="ix_modreunest"/> digging down one level, into one of the subworkflows, to better understand how importing works and how the subworkflow connects to the master workflow.<a contenteditable="false" data-primary="subworkflows" data-type="indexterm" id="ix_subwk"/> Which subworkflow should we pick? <a contenteditable="false" data-primary="VariantCalling subworkflow" data-type="indexterm" id="ix_VarCallsub"/>The <code>VariantCalling</code> workflow is a great option because it’s likely to be the most comfortably familiar. That way we can focus on understanding the wiring rather than a plethora of new tools and operations. But before we delve any further into the code, let’s map this subworkflow at a high level.</p>

<section data-type="sect3" data-pdf-bookmark="What is the structure of a subworkflow?"><div class="sect3" id="what_is_the_structure_of_a_subworkflowq">
<h3>What is the structure of a subworkflow?</h3>

<p>The good news is <a contenteditable="false" data-primary="modularity and code reuse" data-secondary="unpacking workflow nesting" data-tertiary="structure of subworkflows" data-type="indexterm" id="idm45625615968904"/>that subworkflows are, in fact, <a contenteditable="false" data-primary="subworkflows" data-secondary="structure of" data-type="indexterm" id="idm45625615967000"/>perfectly normal in terms of their WDL structure and syntax, so you can run all the usual <code>womtool</code> commands on them, and you can even run them on their own. Once more, <code>womtool graph</code> comes in handy:</p>

<pre data-type="programlisting">
$ java -jar $BIN/womtool-48.jar graph $CASE2/tasks/VariantCalling.wdl \
    &gt; ~/sandbox-9/VariantCalling.dot</pre>

<p>Copy the DOT file contents into the online Graphviz website to generate the graph diagram. As you can see in <a data-type="xref" href="#graph_diagram_of_the_variantcallingdotw">Figure 9-3</a>, this workflow looks a lot like the now-classic scattered <code>HaplotypeCaller</code> workflow that we’ve been exploring from all angles, with a few additions. In particular, it has a few conditional switches that you can investigate in detail if you’d like to get more practice with conditionals.</p>

<figure><div id="graph_diagram_of_the_variantcallingdotw" class="figure"><img alt="Graph diagram of the VariantCalling.wdl workflow." src="Images/gitc_0903.png" width="1429" height="304"/>
<h6><span class="label">Figure 9-3. </span>Graph diagram of the VariantCalling.wdl workflow.</h6>
</div></figure>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45625615943416">
<h5>Switching It Up</h5>

<p>When you scroll through<a contenteditable="false" data-primary="conditionals" data-secondary="conditional switch in VariantCalling.wdl code" data-type="indexterm" id="idm45625615941864"/> the <em>VariantCalling.wdl</em> code, you might notice that one of the conditional switches uses a <a contenteditable="false" data-primary="variables" data-secondary="Boolean" data-type="indexterm" id="idm45625615939784"/>Boolean variable <a contenteditable="false" data-primary="Boolean variables" data-secondary="use_gatk3_haplotype_caller" data-type="indexterm" id="idm45625615938280"/>called <code>use_gatk3_haplotype_caller</code>, which toggles the flow between two calls:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">if</code> <code class="p">(</code><code class="n">use_gatk3_haplotype_caller</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">call</code> <code class="n">Calling</code><code class="p">.</code><code class="n">HaplotypeCaller_GATK35_GVCF</code> <code class="k">as</code> <code class="n">HaplotypeCallerGATK3</code> <code class="p">{</code> <code class="p">...</code> <code class="p">}</code>
<code class="p">}</code>

<code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="n">use_gatk3_haplotype_caller</code><code class="p">)</code> <code class="p">{</code>
      <code class="k">call</code> <code class="n">Calling</code><code class="p">.</code><code class="n">HaplotypeCaller_GATK4_VCF</code> <code class="k">as</code> <code class="n">HaplotypeCallerGATK4</code> <code class="p">{</code> <code class="err">…</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>This <a contenteditable="false" data-primary="HaplotypeCaller" data-secondary="switching between GATK 3.5 and GATK4 versions" data-type="indexterm" id="idm45625615935304"/>makes it possible to switch between using the GATK 3.5 and GATK4 versions of <code>HaplotypeCaller</code>. As of this writing, the Broad Institute’s production pipeline still uses the GATK 3.5 version of <code>HaplotypeCaller</code> for operational reasons (mainly for continuity). However, the GATK4 version has been fully validated and is the recommended choice for new projects, so the conditional switch allows the team to maintain a single pipeline that can be used by everyone, internally and externally.</p>
</div></aside>

<p>Now open up the <em>VariantCalling.wdl</em> file in your text editor and scroll through it briefly. It has a workflow definition section, <code>workflow VariantCalling {...}</code>. If you’re up for it, you can run through the exercise of mapping the code for call statements to their position in the diagram; we won’t do it explicitly here. We’re more interested in the fact that this subworkflow has import statements of its own. Still no task definitions, though, except for one all the way at the bottom. Does that mean there’s going to be yet another level of nested workflows? We’ve got to find out where those task definitions are hiding.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Where are the tasks defined?"><div class="sect3" id="where_are_the_tasks_definedquestion_mar">
<h3>Where are the tasks defined?</h3>

<p>Let’s pick the first call statement<a contenteditable="false" data-primary="modularity and code reuse" data-secondary="unpacking workflow nesting" data-tertiary="tasks" data-type="indexterm" id="idm45625615896808"/> we come across and hunt down whatever it points to. <a contenteditable="false" data-primary="tasks" data-secondary="finding in nested workflow" data-type="indexterm" id="idm45625615894952"/>Scrolling down from the top, we come to this call:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">call</code> <code class="n">Utils</code><code class="p">.</code><code class="n">ScatterIntervalList</code> <code class="k">as</code> <code class="n">ScatterIntervalList</code> </pre>

<p>You should recognize the pattern from the top-level workflow: this means that we need to look for <a contenteditable="false" data-primary="import statements" data-secondary="aliased to Utils" data-type="indexterm" id="idm45625615889832"/>an import statement aliased to <code>Utils</code>. <a contenteditable="false" data-primary="aliases in WDL" data-secondary="import statement aliased to Utils" data-type="indexterm" id="idm45625615833928"/>Sure enough, we find this toward the top of the file:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">import</code> <code class="s">"tasks/Utilities.wdl"</code> <code class="k">as</code> <code class="n">Utils</code></pre>

<p>In your text editor, open the <em>Utilities.wdl</em> file, and <a contenteditable="false" data-primary="Utils.wdl file" data-type="indexterm" id="idm45625615885736"/>you should see the following (some lines omitted):</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">version</code> <code class="mf">1.0</code>

<code class="cp">## Copyright Broad Institute, 2018</code>
<code class="cp">##</code>
<code class="cp">## This WDL defines utility tasks used for processing of sequencing data.</code>
<code class="cp">##</code>
<code class="p">...</code>

<code class="cp"># Generate sets of intervals for scatter-gathering over chromosomes</code>
<code class="k">task</code> <code class="n">CreateSequenceGroupingTSV</code> <code class="p">{</code>
  <code class="k">input</code> <code class="p">{</code>
    <code class="kt">File</code> <code class="n">ref_dict</code>
<code class="p">...</code></pre>

<p>Wait, it’s just a bunch of tasks? No workflow definition at all? That’s…well, kind of a relief.<a contenteditable="false" data-primary="ScatterIntervalList task" data-type="indexterm" id="idm45625615810168"/> We seem to have found the deepest level of our nested structure, at least on this branch. To confirm, search for the <code>ScatterIntervalList</code> task in the <em>Utilities.wdl</em> file, and, sure enough, there is its task definition starting on line 77:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">task</code> <code class="n">ScatterIntervalList</code> <code class="p">{</code>
  <code class="k">input</code> <code class="p">{</code>
    <code class="kt">File</code> <code class="n">interval_list</code>
    <code class="kt">Int</code> <code class="n">scatter_count</code>
    <code class="kt">Int</code> <code class="n">break_bands_at_multiples_of</code>
  <code class="p">}</code>

  <code class="k">command</code> <code class="o">&lt;&lt;&lt;</code>
<code class="p">...</code></pre>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This task’s <code>command</code> block is pretty wild—first it runs a Picard tool via a Java command and then some bulk Python code that generates lists of intervals on the fly. We won’t analyze its syntax in detail; just note that it’s the sort of thing you can do within a WDL task.</p>
</div>

<p>The takeaway here is that this <em>Utilities.wdl</em> file functions as a library of tasks. Think for a moment about the implications: this means that you can store task definitions for commonly used tasks in a library and simply import them into individual workflows with a one-line statement, rather than rewriting or copying the code over each time. Then, when you need to fix or update a task definition, you need to do it only once rather than having to update all the copies that exist in different workflows. To be clear though, you’re not obligated to use subworkflows in order to use imports for tasks. For an example of non-nested workflows that share a task library, have a look at the workflows on <a href="https://oreil.ly/6qVe3">GitHub</a>.</p>

<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="wdl_libraries_can_also_collect_custom_s">
<h5>WDL Libraries Can Also Collect Custom Struct Variables</h5>

<p>You might have <a contenteditable="false" data-primary="Workflow Description Language (WDL)" data-secondary="libraries collecting custom struct variables" data-type="indexterm" id="idm45625615735784"/>noticed that some <a contenteditable="false" data-primary="variables" data-secondary="custom struct variables in WDL libraries" data-type="indexterm" id="idm45625615734248"/>of the inputs<a contenteditable="false" data-primary="structs (WDL)" data-type="indexterm" id="idm45625615732680"/> in the master workflow were declared with unusual variable types. The WDL variable types we’ve used so far have been very generic: <code>String</code>, <code>File</code>, <code>Boolean</code>, and now, <code>SampleAndUnmappedBams</code>? <a contenteditable="false" data-primary="SampleAndUnmappedBams struct" data-type="indexterm" id="idm45625615729512"/>That seems oddly specific for a variable type, right?</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">workflow</code> <code class="n">WholeGenomeGermlineSingleSample</code> <code class="p">{</code>
  <code class="k">input</code> <code class="p">{</code>
    <code class="n">SampleAndUnmappedBams</code> <code class="n">sample_and_unmapped_bams</code>
    <code class="n">GermlineSingleSampleReferences</code> <code class="n">references</code>
    <code class="n">PapiSettings</code> <code class="n">papi_settings</code>
<code class="err">…</code></pre>

<p>These variable types are called <em>structs</em>, short for <em>construct</em>; they’re special in the sense that they’re custom-built by the workflow author. They enable us to bundle groups of variables into a single variable so that it’s easier to pass them around as task inputs or outputs. This is very convenient when you have a set of inputs that always travel together, and you don’t want to have to specify every one of them individually in each call’s input definitions. For example, the aforementioned <span class="keep-together"><code>SampleAndUnmappedBams</code></span> struct bundles metadata like the name of a sample, the name of the final output file, and so on with the actual sequence data files for a given <span class="keep-together">sample:</span></p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">struct</code> <code class="n">SampleAndUnmappedBams</code> <code class="p">{</code>
  <code class="kt">String</code> <code class="n">base_file_name</code>
  <code class="kt">String</code> <code class="n">final_gvcf_base_name</code>
  <code class="kt">Array</code><code class="p">[</code><code class="kt">File</code><code class="p">]</code> <code class="n">flowcell_unmapped_bams</code>
  <code class="kt">String</code> <code class="n">sample_name</code>
  <code class="kt">String</code> <code class="n">unmapped_bam_suffix</code>
<code class="p">}</code></pre>

<p>Just like tasks, structs can be defined within the WDL file that houses your workflow, or in a separate library that contains only structs (or a mix of structs and tasks).</p>
</div></aside>

<p>Hey, look at how far we’ve come; this chapter is almost over. You should feel pretty good about yourself. You’ve worked through almost everything you need in order to understand imports and use them in your own work. But there’s one more thing we want to make sure is really clear, and it has to do with connecting inputs and outputs between subworkflows.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="How is the subworkflow wired up?"><div class="sect3" id="how_is_the_subworkflow_wired_upquestion">
<h3>How is the subworkflow wired up?</h3>

<p>As you might<a contenteditable="false" data-primary="import statements" data-secondary="importing VariantCalling subworkflow" data-type="indexterm" id="idm45625615669320"/> recall, this subworkflow is imported <a contenteditable="false" data-primary="subworkflows" data-secondary="connecting inputs and outputs between" data-type="indexterm" id="idm45625615667816"/>as follows<a contenteditable="false" data-primary="modularity and code reuse" data-secondary="unpacking workflow nesting" data-tertiary="subworkflows, connecting inputs and outputs between" data-type="indexterm" id="idm45625615646792"/> in the master workflow:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">import</code> <code class="s">"tasks/VariantCalling.wdl"</code> <code class="k">as</code> <code class="n">ToGvcf</code></pre>

<p>As noted previously, this makes the code within the imported file available to the workflow interpreter and assigns the <code>ToGvcf</code> alias to that code so that we can refer to it elsewhere. <a contenteditable="false" data-primary="aliases in WDL" data-secondary="referring to content from imported files" data-type="indexterm" id="idm45625615590696"/>We see this in the following call statement:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">call</code> <code class="n">ToGvcf</code><code class="p">.</code><code class="n">VariantCalling</code> <code class="k">as</code> <code class="n">BamToGvcf</code> <code class="p">{</code>
    <code class="k">input</code><code class="o">:</code>
      <code class="p">...</code>
      <code class="n">input_bam</code> <code class="o">=</code> <code class="n">UnmappedBamToAlignedBam</code><code class="p">.</code><code class="n">output_bam</code><code class="p">,</code></pre>

<p>Now that we know <code>VariantCalling</code> is a workflow defined within of the imported WDL, we can read the call like this in plain English:</p>

<blockquote>
<p>From the pile of imported code named ToGvcf, call the workflow defined as VariantCalling, but name it BamToGvcf within the scope of this master workflow. Also, for the input BAM file it expects, give it the output from the UnmappedBamToAlignedBam workflow.</p>
</blockquote>

<p>You might notice that there’s an interesting<a contenteditable="false" data-primary="UnmappedBamToAlignedBam" data-secondary="workflow, no alias assigned to" data-type="indexterm" id="idm45625615569416"/> difference between how the <code>UnmappedBamToAlignedBam</code> workflow  and the <code>VariantCalling</code> workflow are treated: the latter is assigned an alias, whereas the former is not. Instead, <code>UnmappedBamToAlignedBam</code> retains the original name given in the WDL where it is defined. Based on the naming patterns we’ve observed so far, our guess is that the authors of the workflow wanted to identify the high-level segments by the file formats of the main inputs and outputs at each stage. This is a very common pattern in genomics; it’s not the most robust strategy, but it certainly is concise and does not require too much domain understanding to decipher beyond the file formats themselves.</p>

<p>Anyway, the practical consequence is that we point to the outputs of the subworkflow by either its original name or by its alias if it has one. To be clear, however, we can point only to outputs that were declared as workflow-level outputs in the subworkflow. If any tasks in the subworkflow were not declared at the workflow level, but only at the task level, they will be invisible to the master workflow and to any of its other subworkflows.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Aliases are a <a contenteditable="false" data-primary="aliases in WDL" data-secondary="using to call task in different ways within a workflow" data-type="indexterm" id="idm45625615564168"/>convenient feature of WDL that are useful beyond dealing with imports; they can also be used to call the same task in different ways within the same workflow.</p>
</div>

<p>As we’ve already observed, the import wiring system also allows us to call individual tasks from an imported WDL by referring to the alias given to the WDL file, as in this call statement to one of the tasks in the <em>Utility.wdl</em> library:</p>

<pre data-type="programlisting" data-code-language="wdl">
<code class="k">call</code> <code class="n">Utils</code><code class="p">.</code><code class="n">ScatterIntervalList</code> <code class="k">as</code> <code class="n">ScatterIntervalList</code> </pre>

<p>To reprise our model for loose translation to plain English, this reads as follows:</p>

<blockquote>
<p>From the pile of imported code named Utils, call the task defined as ScatterIntervalList, but name it ScatterIntervalList instead of Utils.ScatterIntervalList within the scope of this master workflow.</p>
</blockquote>

<p>The twist here is that if we don’t provide an alias, we must refer to the task as <code>Utils.ScatterIntervalList</code> everywhere. When we define this alias, we can just refer to the task directly as <code>ScatterIntervalList</code>. This is a subtle but important difference compared to the way workflow imports work. Note that we could also use a different name from the original if we wanted, like <code>ScatterList</code> for short, or <code>Samantha</code> if we’re actively trying to mess with anyone who might read our code (but please don’t do that).</p>

<p>Finally, remember that some of the ovals in the top-level workflow have a double outline, including the one labeled <code>UnmappedBamToAlignedBam</code>, which happens to be a workflow—do you think that could possibly be related? Let’s check out the other calls. <a contenteditable="false" data-primary="AggregatedBamQC" data-type="indexterm" id="idm45625615553400"/>The <code>AggregatedBamQC</code> oval had a double outline, so look up the import statement to identify the corresponding WDL file (<em>tasks/AggregatedBamQC.wdl</em>) and peek inside. Sure enough, it’s another workflow. Now look up the import statement for one of the ovals that had a single outline, for example <code>CollectWgsMetrics</code>, and peek inside the file (<em>tasks/Qc.wdl</em>). Ooh, no workflow declaration, just tasks. <a contenteditable="false" data-primary="CollectWgsMetrics task" data-type="indexterm" id="idm45625615550232"/>It seems we’ve identified what the double outline means: it denotes that the call points to a nested workflow, or subworkflow. Now that’s really useful.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It would be great to also be able to recognize in the diagram whether an oval with a single outline is a true task or whether it’s pointing to a library of tasks. Something to request from the Cromwell development team.</p>
</div>

<p>To recap, we elucidated the <a contenteditable="false" data-primary="VariantCalling subworkflow" data-startref="ix_VarCallsub" data-type="indexterm" id="idm45625615523320"/>structure of this complex pipeline, which implements the full GATK Best Practices for germline short variant discovery in whole genome sequencing data. <a contenteditable="false" data-primary="Genome Analysis Toolkit (GATK)" data-secondary="Best Practices for germline short variant discovery" data-type="indexterm" id="idm45625615521624"/>It combines data preprocesssing (read alignment, duplicate marking, and base recalibration) with the scattered <code>HaplotypeCaller</code> we’ve been working with previously, and adds on a layer of quality control.</p>

<p>As it happens, the original form of this pipeline was a massive, single-WDL implementation, but it later was split into multiple WDL files to be more readable and manageable. The current pipeline utilizes import statements with several levels of nesting of both workflows and tasks. The result is a high level of code modularity and reusability that make it a good model for developing new pipelines, especially complex ones.</p>

<p>If you’re looking for more practice analyzing the use of imports with nested workflows and task libraries, try to map out the complete structure of this monster pipeline, including the preprocessing and QC workflows. When you’re done with that, take a look at the <a href="https://oreil.ly/OMrc9">exome version</a> of this pipeline, which follows the same model and, in fact, reuses some of the same code! See if you can combine them into a single codebase that maximizes code reuse.</p>

<div data-type="note" epub:type="note"><h6>Note</h6>
<p>With that, it’s once again time to stop your VM to avoid paying Google Cloud for the privilege of having a reserved machine idling away for nothing.<a contenteditable="false" data-primary="subworkflows" data-startref="ix_subwk" data-type="indexterm" id="idm45625615515912"/><a contenteditable="false" data-primary="modularity and code reuse" data-secondary="unpacking workflow nesting" data-startref="ix_modreunest" data-type="indexterm" id="idm45625615514536"/><a contenteditable="false" data-primary="workflows" data-secondary="deciphering real genomics workflows" data-startref="ix_wkfrealmod" data-tertiary="mystery workflow, modularity and code reuse" data-type="indexterm" id="idm45625615492296"/><a contenteditable="false" data-primary="modularity and code reuse" data-startref="ix_modreu" data-type="indexterm" id="idm45625615490536"/></p>
</div>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Wrap-Up and Next Steps"><div class="sect1" id="wrap_up_and_next_steps-id00006">
<h1>Wrap-Up and Next Steps</h1>

<p>In this chapter, we explored real genomics workflows that apply advanced WDL features to do some seriously interesting things. We began with an exploration of how you can use conditionals to control the flow of a WDL workflow, branching the analysis based on an input file type. We then looked at a rather complex production workflow from the Broad Institute that uses subworkflows, structures, and task libraries to break the workflow into more manageable (and reusable) pieces. Along the way, we focused on the skills and techniques you need to take a complex workflow, pick it apart, and understand it component by component. This will help not only in understanding the complex production Best Practices workflows that we’ve just started to examine, but it will serve you well when building your own workflows. In this chapter, we didn’t actually run the workflows because our focus was on developing your skills as a workflow detective. In <a data-type="xref" href="ch10.xhtml#running_single_workflows_at_scale_with">Chapter 10</a>, we dive into the execution of complex workflows but, this time, we show you how to take advantage of the full power of the cloud instead of just a single VM.<a contenteditable="false" data-primary="workflows" data-secondary="deciphering real genomics workflows" data-startref="ix_wkfreal" data-type="indexterm" id="idm45625615485784"/></p>
</div></section>
</div></section></div>



  </body></html>