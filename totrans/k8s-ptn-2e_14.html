<html><head></head><body><section data-pdf-bookmark="Chapter 11. Stateless Service" data-type="chapter" epub:type="chapter"><div class="chapter" id="StatelessService">&#13;
<h1><span class="label">Chapter 11. </span>Stateless Service</h1>&#13;
&#13;
&#13;
<p>The<a data-primary="Stateless Service" data-type="indexterm" id="statlessserv11"/> <em>Stateless Service</em> pattern describes how to create and operate applications that are composed of identical ephemeral replicas. These applications are best suited for dynamic cloud environments where they can be rapidly scaled and made highly available.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902103486576">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>The<a data-primary="problems" data-secondary="applications, composed of identical ephemeral replicas" data-type="indexterm" id="idm45902103485008"/> microservices architecture style is the dominant choice for implementing<a data-primary="greenfield cloud native applications" data-type="indexterm" id="idm45902103483904"/><a data-primary="cloud native applications" data-type="indexterm" id="idm45902103483216"/> new greenfield cloud native applications. Among the driving principles of this architecture are things such as how it addresses a single concern, how it owns its data, how it has a well-encapsulated deployment boundary, and others. Typically, such applications also follow the <a href="https://12factor.net">twelve-factor app principles</a>, which makes them easy to operate with Kubernetes on dynamic cloud environments.</p>&#13;
&#13;
<p>Applying some of these principles requires understanding the business domain, identifying the service boundary, or applying domain-driven design or a similar methodology during the service implementation. Implementing some of the other principles may involve making the services ephemeral, which means the service can be created, scaled, and destroyed with no side effects. These latter concerns are easier to address when a service is stateless rather than stateful.</p>&#13;
&#13;
<p>A stateless service does not maintain any state internally within the instance across service interactions. In our context, it means a container is stateless if it does not hold any information from requests in its internal storage (memory or temporary filesystem) that is critical for serving future requests. A stateless process has no stored knowledge of or reference to past requests, so each request is made as if from scratch. Instead, if the process needs to store such information, it should store it in an external storage such as a database, message queue, mounted filesystem, or some other data store that can be accessed by other instances. A good thought experiment is to imagine the instances of your services deployed on different nodes and a load-balancer that randomly distributes the requests to the instances without any sticky session (i.e., without an affinity between a client and a specific service instance). If the service can fulfill its purpose in this setup, it is likely a stateless service (or it has a mechanism for state distribution among the instances, such as a data grid).</p>&#13;
&#13;
<p>Stateless services are made of identical, replaceable instances that often offload state to external permanent storage systems and use load-balancers for distributing incoming requests among themselves. In this chapter, we will see specifically which Kubernetes abstractions can help operate such stateless applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902103478800">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>In<a data-primary="Stateless Service" data-secondary="Declarative Deployment" data-type="indexterm" id="idm45902103477008"/><a data-primary="Declarative Deployment" data-type="indexterm" id="idm45902103476000"/><a data-primary="Declarative Deployment" data-secondary="Stateless Service" data-type="indexterm" id="idm45902103475328"/> <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.html#DeclarativeDeployment">Chapter 3, “Declarative Deployment”</a>, you learned how to use the concept of Deployment to control how an application should be updated to the next version, using the <code>RollingUpdate</code> and <code>Recreate</code> strategies. But this is only the upgrading aspect of Deployment. At a broader level, a Deployment represents an application deployed in the cluster. Kubernetes doesn’t have the notion of an <code>Application</code> or a <code>Container</code> as top-level entities. Instead, an application is typically composed of a collection of Pods managed by a controller such as ReplicaSet, Deployment, or StatefulSet, combined with ConfigMap, Secret, Service, PersistentVolumeClaim, etc. The controller that is used for managing stateless Pods is ReplicaSet, but that is a lower-level internal control structure used by a Deployment. Deployment is the recommended user-facing abstraction for creating and updating stateless applications, which creates and manages the ReplicaSets behind the scene. A ReplicaSet should be used when the update strategies provided by Deployment are not suitable, or a custom mechanism is required, or no control over the update process is needed at all.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Instances" data-type="sect2"><div class="sect2" id="idm45902103471088">&#13;
<h2>Instances</h2>&#13;
&#13;
<p>The<a data-primary="Stateless Service" data-secondary="ReplicaSet" data-type="indexterm" id="idm45902103469520"/><a data-primary="ReplicaSet" data-secondary="Stateless Service" data-type="indexterm" id="idm45902103468512"/> primary purpose of a ReplicaSet is to ensure a specified number of identical Pod replicas running at any given time. The main sections of a ReplicaSet definition include the number of replicas indicating how many Pods it should maintain, a selector that specifies how to identify the Pods it manages, and a Pod template for creating new Pod replicas. Then, a ReplicaSet creates and deletes Pods as needed to maintain the desired replica count using the given Pod template, as demonstrated in <a data-type="xref" href="#stateless-service-instances">Example 11-1</a>.</p>&#13;
<div data-type="example" id="stateless-service-instances">&#13;
<h5><span class="label">Example 11-1. </span>ReplicaSet definition for a stateless Pod</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ReplicaSet</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rg</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3</code><code class="w">               </code><a class="co" href="#callout_stateless_service_CO1-1" id="co_stateless_service_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">                 </code><a class="co" href="#callout_stateless_service_CO1-2" id="co_stateless_service_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w">                 </code><a class="co" href="#callout_stateless_service_CO1-3" id="co_stateless_service_CO1-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_stateless_service_CO1-1" id="callout_stateless_service_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Desired number of Pod replicas to maintain running.</p></dd>&#13;
<dt><a class="co" href="#co_stateless_service_CO1-2" id="callout_stateless_service_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Label selector used to identify the Pods to manage.</p></dd>&#13;
<dt><a class="co" href="#co_stateless_service_CO1-3" id="callout_stateless_service_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Template specifying the data for creating new Pods.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The template is used when the ReplicaSet needs to create new Pods to meet the desired number of replicas. But a ReplicaSet is not limited to managing the Pods specified by the template. If a bare Pod has no owner reference (meaning it is not managed by a controller), and it matches the label selector, it will be acquired by setting the owner reference and managed by the ReplicaSet. This setup can lead to a ReplicaSet owning a nonidentical set of Pods created by different means, and terminate existing bare Pods that exceed the declared replica count. To avoid such undesired side effects, it is recommended that you ensure bare Pods do not have labels matching ReplicaSet selectors.</p>&#13;
&#13;
<p>Regardless of whether you create a ReplicaSet directly or through a Deployment, the end result will be that the desired number of identical Pod replicas are created and maintained. The added benefit of using Deployment is that we can control how the replicas are upgraded and rolled back, which we described in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch03.html#DeclarativeDeployment">Chapter 3, “Declarative Deployment”</a>. Next, the<a data-primary="Stateless Service" data-secondary="Automated Placement" data-type="indexterm" id="idm45902103371600"/><a data-primary="Automated Placement" data-secondary="Stateless Service" data-type="indexterm" id="idm45902103370592"/><a data-primary="Automated Placement" data-type="indexterm" id="idm45902103320992"/> replicas are scheduled to the available nodes as per the policies we covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch06.html#AutomatedPlacement">Chapter 6, “Automated Placement”</a>. The ReplicaSet’s job is to restart the containers if needed and scale out or in when the number of replicas is increased or decreased, respectively. With this behavior, Deployment and ReplicaSet can automate the lifecycle management of stateless applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Networking" data-type="sect2"><div class="sect2" id="idm45902103318864">&#13;
<h2>Networking</h2>&#13;
&#13;
<p>Pods<a data-primary="ReplicaSet" data-secondary="creating and managing Pods" data-type="indexterm" id="idm45902103317296"/><a data-primary="Pods" data-secondary="creating and managing" data-type="indexterm" id="idm45902103316320"/> created by ReplicaSet are ephemeral and may disappear at any time, such as when a Pod is evicted because of resource starvation or because the node the Pod is running on fails. In such a situation, the ReplicaSet will create a new Pod that will have a new name, hostname, and IP address. If the application is stateless, as we’ve defined earlier in the chapter, new requests should be handled from the newly created Pod the same way as by any other Pod.</p>&#13;
&#13;
<p>Depending on how the application within the container connects to the other systems to accept requests or poll for messages, for example, you may require a Kubernetes Service. If the application is starting an egress connection to a message broker or database, and that is the only way it exchanges data, then there is no need for a Kubernetes Service. But more often, stateless services are contacted by other services over synchronous request/response-driven protocols such as HTTP and gRPC. Since the Pod IP address changes with every Pod restart, it is better to use a permanent IP address based on a Kubernetes Service that service consumers can use. A Kubernetes Service has a fixed IP address that doesn’t change during the lifetime of the Service, and it ensures the client requests are always load-balanced across instances and routed to the healthy and ready-to-accept-requests Pods. We<a data-primary="Stateless Service" data-secondary="Service Discovery" data-type="indexterm" id="idm45902103314384"/><a data-primary="Service Discovery" data-secondary="Stateless Service" data-type="indexterm" id="idm45902103313408"/><a data-primary="Service Discovery" data-type="indexterm" id="idm45902103312464"/> cover different types of Kubernetes Services in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.html#ServiceDiscovery">Chapter 13, “Service Discovery”</a>. In <a data-type="xref" href="#stateless-service-discovery">Example 11-2</a>, we use a simple Service to expose the Pods internally within the cluster to other Pods.</p>&#13;
<div data-type="example" id="stateless-service-discovery">&#13;
<h5><span class="label">Example 11-2. </span>Exposing a stateless service</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">    </code><a class="co" href="#callout_stateless_service_CO2-1" id="co_stateless_service_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">                 </code><a class="co" href="#callout_stateless_service_CO2-2" id="co_stateless_service_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_stateless_service_CO2-1" id="callout_stateless_service_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Name of the service that can be used to reach the matching Pods.</p></dd>&#13;
<dt><a class="co" href="#co_stateless_service_CO2-2" id="callout_stateless_service_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Selector matching the Pod labels from the ReplicaSet.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The definition in this example will create a Service named <code>random-generator</code> that accepts TCP connections on port 80 and routes them to port 8080 on all the matching Pods with selector <code>app: random-generator</code>. Once a Service is created, it is assigned a <code>clusterIP</code> that is accessible only from within the Kubernetes cluster, and that IP remains unchanged as long as the Service definition exists. This acts as a permanent entrypoint to all matching Pods that are ephemeral and have changing IP addresses.</p>&#13;
&#13;
<p>Notice that Deployment and the resulting ReplicaSet are only responsible for maintaining the desired number of stateless Pods that match the label selector. They are unaware of any Kubernetes Service that might be directing traffic to the same set of Pods or a different combination of Pods.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Storage" data-type="sect2"><div class="sect2" id="idm45902102114416">&#13;
<h2>Storage</h2>&#13;
&#13;
<p>Few stateless services don’t need any state and can process requests based only on the data provided in every request. Most stateless services require state, but they are stateless because they offload the state to some other stateful system or data store, such as a filesystem. Any Pod, whether it is created by a ReplicaSet or not, can declare and use file storage through volumes. Different types of volumes can be used to store state. Some of these are cloud-provider-specific storage, while others allow mounting network storage or even sharing filesystems from the node where the Pod is placed. In this section, we’ll look at the <code>persistentVolumeClaim</code> volume type, which allows you to use manually or dynamically provisioned persistent storage.</p>&#13;
&#13;
<p>A<a data-primary="PersistentVolume (PV)" data-type="indexterm" id="idm45902102074224"/><a data-primary="PV (PersistentVolume)" data-type="indexterm" id="idm45902102073488"/> PersistentVolume (PV) represents a storage resource abstraction in a Kubernetes cluster that has a lifecycle independent of any Pod lifecycle that is using it. A Pod cannot directly refer to a PV; however, a Pod uses<a data-primary="PersistentVolumeClaim (PVC)" data-type="indexterm" id="idm45902102072688"/><a data-primary="PVC (PersistentVolumeClaim)" data-type="indexterm" id="idm45902102072048"/> PersistentVolumeClaim (PVC) to request and bind to the PV, which points to the actual durable storage. This indirect connection allows for a separation of concerns and Pod lifecycle decoupling from PV. A cluster administrator can configure storage provisioning and define PVs. The developer creating Pod definitions can use PVC to use the storage. With this indirection, even if the Pod is deleted, the ownership of the PV remains attached to the PVC and continues to exist. <a data-type="xref" href="#stateless-service-storage">Example 11-3</a> shows a storage claim that can be used in a Pod template.</p>&#13;
<div data-type="example" id="stateless-service-storage">&#13;
<h5><span class="label">Example 11-3. </span>A claim for a PersistentVolume</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">PersistentVolumeClaim</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator-log</code><code class="w">  </code><a class="co" href="#callout_stateless_service_CO3-1" id="co_stateless_service_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">manual</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">   </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">ReadWriteOnce</code><code class="w">            </code><a class="co" href="#callout_stateless_service_CO3-2" id="co_stateless_service_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">   </code><code class="nt">requests</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1Gi</code><code class="w">              </code><a class="co" href="#callout_stateless_service_CO3-3" id="co_stateless_service_CO3-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_stateless_service_CO3-1" id="callout_stateless_service_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Name of the claim that can be referenced from a Pod template.</p></dd>&#13;
<dt><a class="co" href="#co_stateless_service_CO3-2" id="callout_stateless_service_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Indicates that only a single node can mount the volume for reading and writing.</p></dd>&#13;
<dt><a class="co" href="#co_stateless_service_CO3-3" id="callout_stateless_service_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Requesting 1 GiB of storage.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Once a PVC is defined, it can be referenced from a Pod template through the <code>persistentVolumeClaim</code> field. One of the interesting fields of PersistentVolumeClaim is <code>accessModes</code>. It controls how the storage is mounted to the nodes and consumed by the Pods. For example, network filesystems can be mounted to multiple nodes and can allow reading and writing to multiple applications at the same time. Other storage implementations can be mounted to only a single node at a time and can be accessed only by the Pods scheduled on that node. Let’s<a data-primary="Kubernetes" data-secondary="access modes offered by" data-type="indexterm" id="idm45902102010352"/> look at different  <code>accessModes</code> offered by Kubernetes:</p>&#13;
<dl>&#13;
<dt>ReadWriteOnce</dt>&#13;
<dd>&#13;
<p>This represents a volume that can be mounted to a single node at a time. In this mode, one or multiple Pods running on the node could carry out read and write operations.</p>&#13;
</dd>&#13;
<dt>ReadOnlyMany</dt>&#13;
<dd>&#13;
<p>The volume can be mounted to multiple nodes, but it allows read-only operations to all Pods.</p>&#13;
</dd>&#13;
<dt>ReadWriteMany</dt>&#13;
<dd>&#13;
<p>In this mode, the volume can be mounted by many nodes and allows both read and write operations.</p>&#13;
</dd>&#13;
<dt>ReadWriteOncePod</dt>&#13;
<dd>&#13;
<p>Notice that all of the access modes described so far offer per-node granularity. Even <code>ReadWriteOnce</code> allows multiple Pods on the same node to read from and write to the same volume simultaneously. Only <code>ReadWriteOncePod</code> access mode guarantees that only a single Pod has access to a volume. This is invaluable in scenarios where at most one writer application is allowed to access data for data-consistency guarantees. Use this mode with caution as it will turn your services into a singleton and prevent scaling out. If another Pod replica uses the same PVC, the Pod will fail to start because the PVC is already in use by another Pod. As of this writing, <code>ReadWriteOncePod</code> doesn’t honor preemption either, which means a lower-priority Pod will hold on to the storage and not be preempted from the node in favor of a higher-priority Pod waiting on the same <code>ReadWriteOncePod</code> claim.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In a ReplicaSet, all Pods are identical; they share the same PVC and refer to the same PV. This is in contrast to StatefulSets covered in the next chapter, where PVCs are created dynamically for each stateful Pod replica. This is one of the major differences between how stateless and stateful workloads are handled in Kubernetes.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902101961376">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>A complex distributed system is usually composed of multiple services, some of which will be stateful and perform some form of distributed coordination, some of which might be short-lived jobs, and some of which might be highly scalable stateless services. Stateless services are composed of identical, swappable, ephemeral, and replaceable instances. They are ideal for handling short-lived requests and can scale up and down rapidly without having any dependencies among the instances. As shown in <a data-type="xref" href="#img-stateless-service-application">Figure 11-1</a>, Kubernetes offers a number of useful primitives to manage such applications.</p>&#13;
&#13;
<figure class="width-90"><div class="figure" id="img-stateless-service-application">&#13;
<img alt="A Distributed Stateless Application on Kubernetes" src="assets/kup2_1101.png"/>&#13;
<h6><span class="label">Figure 11-1. </span>A distributed stateless application on Kubernetes</h6>&#13;
</div></figure>&#13;
&#13;
<p>At the lowest level, the Pod abstraction ensures that one or more containers are observed with liveness checks and are always up and running. Building on that, the ReplicaSet also ensures that the desired number of stateless Pods are always running on the healthy nodes. Deployments automate the upgrade and rollback mechanism of Pod replicas. When there is incoming traffic, the Service abstraction discovers and distributes traffic to healthy Pod instances with passing readiness probes. When a persistent file storage is required, PVCs can request and mount storage.</p>&#13;
&#13;
<p class="pagebreak-before">Although Kubernetes offers these building blocks, it will not enforce any direct relationship between them. It is your responsibility to combine them to match the application nature. You have to understand how liveness checks and ReplicaSet control Pods’ lifecycles, and how they relate to readiness probes and Service definitions controlling how the traffic is directed to the Pods. You should also understand how PVCs and <code>accessMode</code> control where the storage is mounted and how it is accessed. When Kubernetes primitives are not sufficient, you should know how to combine it with other frameworks such<a data-primary="Knative" data-secondary="autoscaling" data-type="indexterm" id="idm45902101954832"/> as Knative and KEDA and how to autoscale and even turn stateless applications into serverless. The latter frameworks are covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch29.html#ElasticScale">Chapter 29, “Elastic Scale”</a>.<a data-primary="" data-startref="statlessserv11" data-type="indexterm" id="idm45902101952528"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="stateless-service-more-information">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/h0Ytj">Stateless Service Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/XugMo">ReplicaSet</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/HvApe">Persistent Volumes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/qxFrz">Storage Classes</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/iovaa">Access Modes</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>