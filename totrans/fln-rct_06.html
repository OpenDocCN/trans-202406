<html><head></head><body><section data-pdf-bookmark="Chapter 5. Common Questions and Powerful Patterns" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch05">&#13;
<h1><span class="label">Chapter 5. </span>Common Questions and Powerful Patterns</h1>&#13;
&#13;
&#13;
<p>Now that we’re more aware of what React does and how it works under the&#13;
hood, let’s explore its practical applications a little deeper in how we&#13;
write React applications. In this chapter, we’ll explore the answers to&#13;
common React questions to boost our fluency around memoization, lazy&#13;
loading, and performance. Let’s get started by talking about memoization.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Memoization with React.memo" data-type="sect1"><div class="sect1" id="id58">&#13;
<h1>Memoization with React.memo</h1>&#13;
&#13;
<p>Memoization<a data-primary="memoization" data-secondary="with React.memo" data-secondary-sortas="React.memo" data-type="indexterm" id="ix_memoizationwithReactmemo.05.14.12"/><a data-primary="React.memo" data-type="indexterm" id="ix_Reactmemo.05.14.12"/> is a technique used in computer science to optimize the&#13;
performance of functions by caching their previously computed results.&#13;
In simple terms, memoization stores the output of a function based on&#13;
its inputs so that if the function is called again with the same inputs,&#13;
it returns the cached result rather than recomputing the output. This&#13;
significantly reduces the time and resources needed to execute a&#13;
function, especially for functions that are computationally expensive or&#13;
called frequently. Memoization relies on function purity, which is defined as a function&#13;
predictably returning the same outputs for&#13;
given inputs. An example of a pure function is:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">num1</code><code class="p">,</code> <code class="nx">num2</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">num1</code> <code class="o">+</code> <code class="nx">num2</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This <code>add</code> function always returns <code>3</code> when given arguments <code>1</code> and <code>2</code>,&#13;
and therefore can be memoized safely. If the function relies on some&#13;
side effect like network communication, it wouldn’t be memoizable.&#13;
Consider, for example:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">addToNumberOfTheDay</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">todaysNumber</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"https://number-api.com/today"</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">r</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">data</code><code class="p">.</code><code class="nx">number</code><code class="p">);</code>&#13;
  <code class="k">return</code> <code class="nx">num</code> <code class="o">+</code> <code class="nx">todaysNumber</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Given an input <code>2</code>, this function will return a different result every&#13;
day and therefore cannot be memoized. A silly example perhaps, but&#13;
through it we crudely understand basic memoization.</p>&#13;
&#13;
<p>Memoization is particularly useful when dealing with expensive&#13;
calculations or when rendering large lists of items. Consider a function:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">doHardThing</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">result</code><code class="p">)</code> <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// ...do hard stuff</code>&#13;
&#13;
  <code class="nx">result</code> <code class="o">=</code> <code class="nx">hardStuff</code><code class="p">;</code>&#13;
  <code class="k">return</code> <code class="nx">hardStuff</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Calling <code>doHardThing</code> once might take a few minutes to do the hard&#13;
thing, but calling it a second, third, fourth, or <em>nth</em> time doesn’t&#13;
actually do the hard thing but instead returns the stored result. This&#13;
is the gist of memoization.</p>&#13;
&#13;
<p>In the context of React, memoization can be applied to functional&#13;
components using the <code>React.memo</code> component. This function returns a new&#13;
component that only rerenders<a data-primary="rerendering" data-secondary="React’s method" data-type="indexterm" id="ix_rerenderingReactsmethod.05.76.30"/> if its props have changed. Based on <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>, ideally now we know that to “rerender” means to&#13;
reinvoke the function component. If wrapped in <code>React.memo</code>, the&#13;
function is not called again during reconciliation unless its props have&#13;
changed. By memoizing functional components, we can prevent unnecessary&#13;
rerenders<a data-primary="unnecessary rerenders" data-type="indexterm" id="id669"/>, which can improve the overall performance of our React&#13;
application.</p>&#13;
&#13;
<p>We already know that React components are functions that are invoked for&#13;
reconciliation, as discussed in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>. React calls&#13;
function components with their props recursively to create a vDOM tree&#13;
that is then used as the basis of two Fiber trees that are reconciled.&#13;
Sometimes, rendering (that is, invoking a component function) can take a&#13;
long time due to intense computations within the function component, or&#13;
intense computations when applying it to the DOM via placement or update&#13;
effects, as covered in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>. This slows down our&#13;
application and presents a laggy user experience. Memoization<a data-primary="performance" data-secondary="memoization as booster of" data-type="indexterm" id="id670"/> is a way to&#13;
avoid this by storing the results of expensive computations and&#13;
returning them when the same inputs are passed to the function, or the&#13;
same props are passed to the component.</p>&#13;
&#13;
<p>To understand why <code>React.memo</code> is important, let’s consider a common&#13;
scenario where we have a list of items that need to be rendered in a&#13;
component. For example, let’s say we have a to do list that we want&#13;
to display in a component, like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">TodoList</code><code class="p">({</code><code class="w"> </code><code class="nx">todos</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">todos</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">todo</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">todo</code><code class="p">.</code><code class="nx">id</code><code class="p">}&gt;{</code><code class="nx">todo</code><code class="p">.</code><code class="nx">title</code><code class="p">}&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Now, let’s compose this component into another component that rerenders&#13;
on user input:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">todos</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">Array</code><code class="p">.</code><code class="kr">from</code><code class="p">({</code><code class="w"> </code><code class="nx">length</code><code class="o">:</code><code class="w"> </code><code class="mf">1000000</code><code class="w"> </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="nx">setName</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">input</code> <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="na">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setName</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">TodoList</code> <code class="na">todos</code><code class="o">=</code><code class="p">{</code><code class="nx">todos</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In our <code>App</code> component, on every keystroke in the <code>input</code> field,&#13;
<code>TodoList</code> will rerender: the <code>TodoList</code> function component will be&#13;
reinvoked with its props on every keystroke. This can and probably will&#13;
present performance problems, but is central to how React works: when a&#13;
state change occurs in a component, every function component from that&#13;
component down the tree is reinvoked during reconciliation.</p>&#13;
&#13;
<p>If the to do list is large, and the component is rerendered<a data-primary="rerendering" data-secondary="optimizing with memoization" data-type="indexterm" id="id671"/>&#13;
frequently, this can cause a performance bottleneck in the application.&#13;
One way to optimize<a data-primary="performance" data-secondary="memoization as booster of" data-type="indexterm" id="id672"/> this component is to memoize it using <code>React.memo</code>:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MemoizedTodoList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">memo</code><code class="p">(</code><code class="kd">function</code><code class="w"> </code><code class="nx">TodoList</code><code class="p">({</code><code class="w"> </code><code class="nx">todos</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">todos</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">todo</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">todo</code><code class="p">.</code><code class="nx">id</code><code class="p">}&gt;{</code><code class="nx">todo</code><code class="p">.</code><code class="nx">title</code><code class="p">}&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/></pre>&#13;
&#13;
<p>By wrapping the <code>TodoList</code> component with <code>React.memo</code>, React will only&#13;
rerender the component if its props have changed. Surrounding state&#13;
changes will not affect it. This means that if the to do list remains&#13;
the same, the component will not rerender, and its cached output will&#13;
be used instead. This can save significant resources and time,&#13;
especially when the component is complex and the to do list is large.</p>&#13;
&#13;
<p>Let’s consider another example where we have a complex component with&#13;
multiple nested components that are expensive to render:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">Dashboard</code><code class="p">({</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">Dashboard</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">UserStats</code> <code class="na">user</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">.</code><code class="nx">user</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">RecentActivity</code> <code class="na">activity</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">.</code><code class="nx">activity</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ImportantMessages</code> <code class="na">messages</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">.</code><code class="nx">messages</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>If the <code>data</code> prop changes frequently, this component can be expensive&#13;
to render, especially if the nested components are also complex. We can&#13;
optimize this component using <code>React.memo</code> to memoize each nested&#13;
component:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MemoizedUserStats</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">memo</code><code class="p">(</code><code class="kd">function</code><code class="w"> </code><code class="nx">UserStats</code><code class="p">({</code><code class="w"> </code><code class="nx">user</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MemoizedRecentActivity</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">memo</code><code class="p">(</code><code class="kd">function</code><code class="w"> </code><code class="nx">RecentActivity</code><code class="p">({</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">activity</code><code class="p">,</code><code class="w"/>&#13;
<code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MemoizedImportantMessages</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">memo</code><code class="p">(</code><code class="kd">function</code><code class="w"> </code><code class="nx">ImportantMessages</code><code class="p">({</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">messages</code><code class="p">,</code><code class="w"/>&#13;
<code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">Dashboard</code><code class="p">({</code><code class="w"> </code><code class="nx">data</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">Dashboard</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">MemoizedUserStats</code> <code class="na">user</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">.</code><code class="nx">user</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">MemoizedRecentActivity</code> <code class="na">activity</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">.</code><code class="nx">activity</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">MemoizedImportantMessages</code> <code class="na">messages</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">.</code><code class="nx">messages</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>By memoizing each nested component, React will only rerender the&#13;
components that have changed, and the cached outputs will be used for&#13;
the components that have not changed. This can significantly improve the&#13;
performance of the <code>Dashboard</code> component and reduce unnecessary&#13;
rerenders. Thus, we can see that <code>React.memo</code> is an essential tool for&#13;
optimizing the performance of functional components in React. This can&#13;
be particularly useful for components that are expensive to render or&#13;
have complex logic<a data-startref="ix_rerenderingReactsmethod.05.76.30" data-type="indexterm" id="id673"/>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Fluent in React.memo" data-type="sect2"><div class="sect2" id="id59">&#13;
<h2>Getting Fluent in React.memo</h2>&#13;
&#13;
<p>Let’s briefly walk through how <code>React.memo</code> works. When an update&#13;
happens in React, your component is compared with the results of the&#13;
vDOM returned from its previous render. If these results are&#13;
different—i.e., if its props change—the reconciler runs an update effect&#13;
if the element already exists in the host environment (usually the&#13;
browser DOM), or a placement effect if it doesn’t. If its props are the&#13;
same, the component still rerenders and the DOM is still updated.</p>&#13;
&#13;
<p>This is what <code>React.memo</code> is good for: avoiding unnecessary rerenders<a data-primary="unnecessary rerenders" data-type="indexterm" id="id674"/><a data-primary="performance" data-secondary="memoization as booster of" data-type="indexterm" id="id675"/>&#13;
when a component’s props are identical between renders. Since we can do&#13;
this in React, it begs the question: how much and how often should we&#13;
memoize stuff? Surely if we memoize every component, our application&#13;
might be faster overall, no?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Memoized Components That Still Rerender" data-type="sect2"><div class="sect2" id="id60">&#13;
<h2>Memoized Components That Still Rerender</h2>&#13;
&#13;
<p><code>React.memo</code> performs what is called a <em>shallow</em> comparison<a data-primary="React.memo" data-secondary="shallow comparison" data-type="indexterm" id="id676"/><a data-primary="shallow comparison, React.memo" data-type="indexterm" id="id677"/> of the props&#13;
to determine whether they’ve changed or not. The problem with this is&#13;
while scalar types can be compared quite accurately in JavaScript,&#13;
nonscalars cannot. To have a high-quality discussion, let’s break down&#13;
briefly what scalar and nonscalar types are, and how they behave in&#13;
comparison operations.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scalars (primitive types)" data-type="sect3"><div class="sect3" id="id61">&#13;
<h3>Scalars (primitive types)</h3>&#13;
&#13;
<p>Scalar types<a data-primary="React.memo" data-secondary="scalars" data-type="indexterm" id="id678"/><a data-primary="scalars" data-seealso="signals" data-type="indexterm" id="id679"/>, also known as primitive types, are foundational. These&#13;
types represent singular, indivisible values. Unlike more complex data&#13;
structures like arrays and objects, scalars do not possess properties or&#13;
methods, and they are immutable by nature. This means that once a scalar&#13;
value is set, it cannot be altered without creating a completely new&#13;
value. JavaScript has several scalar types, including numbers,&#13;
strings, booleans, and others like symbols, BigInts, undefined, and&#13;
null. Each of these types serves a unique purpose. For instance, while&#13;
numbers are self-explanatory, symbols provide a way to create unique&#13;
identifiers, and undefined and null allow developers to represent the&#13;
absence of a value in different contexts. When comparing scalar values,&#13;
we’re often interested in their actual content or value.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Nonscalars (reference types)" data-type="sect3"><div class="sect3" id="id62">&#13;
<h3>Nonscalars (reference types)</h3>&#13;
&#13;
<p>Moving beyond the simplicity of scalars<a data-primary="React.memo" data-secondary="nonscalars" data-type="indexterm" id="ix_Reactmemononscalars.05.266.40"/><a data-primary="nonscalars, React.memo" data-type="indexterm" id="ix_nonscalarsReactmemo.05.266.40"/><a data-primary="reference types, React.memo" data-type="indexterm" id="ix_referencetypesReactmemo.05.266.40"/>, we encounter nonscalar or&#13;
reference types. These types don’t store data, but rather a&#13;
reference or a pointer to where the data is stored in memory. This&#13;
distinction is crucial because it impacts how these types are compared,&#13;
manipulated, and interacted with in code. In JavaScript, the most common&#13;
nonscalar types are objects and arrays. Objects allow us to store&#13;
structured data with key-value pairs, while arrays provide ordered&#13;
collections. Functions, too, are considered reference types in&#13;
JavaScript. A key characteristic of nonscalars is that multiple&#13;
references can point to the same memory location. This means that&#13;
modifying data through one reference can impact other references&#13;
pointing to the same data. When it comes to comparison, nonscalar types&#13;
are compared by their memory reference, not by their content. This can&#13;
sometimes lead to unexpected results for those not familiar with this&#13;
nuance. For example, two arrays with identical content but different&#13;
memory locations will be considered unequal when compared using the&#13;
strict equality operator.</p>&#13;
&#13;
<p>Consider the following example:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="c1">// Scalar types</code><code class="w"/>&#13;
<code class="s2">"a"</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="s2">"a"</code><code class="p">;</code><code class="w"> </code><code class="c1">// string; true</code><code class="w"/>&#13;
<code class="mf">3</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="mf">3</code><code class="p">;</code><code class="w"> </code><code class="c1">// number; true</code><code class="w"/>&#13;
&#13;
<code class="c1">// Non-scalar types</code><code class="w"/>&#13;
<code class="p">[</code><code class="mf">1</code><code class="p">,</code><code class="w"> </code><code class="mf">2</code><code class="p">,</code><code class="w"> </code><code class="mf">3</code><code class="p">]</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="p">[</code><code class="mf">1</code><code class="p">,</code><code class="w"> </code><code class="mf">2</code><code class="p">,</code><code class="w"> </code><code class="mf">3</code><code class="p">];</code><code class="w"> </code><code class="c1">// array; false</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"> </code><code class="nx">foo</code><code class="o">:</code><code class="w"> </code><code class="s2">"bar"</code><code class="p">}</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">foo</code><code class="o">:</code><code class="w"> </code><code class="s2">"bar"</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="c1">// object; false</code><code class="w"/></pre>&#13;
&#13;
<p>With this array<a data-primary="arrays, memoization of" data-type="indexterm" id="ix_arraysmemoizationof.05.297.16"/><a data-primary="memoization" data-secondary="arrays" data-type="indexterm" id="ix_memoizationarrays.05.297.16"/> comparison, the arrays,&#13;
objects, and other nonscalar types are compared <em>by reference</em>: as in,&#13;
does the lefthand-side array’s reference to its position in the&#13;
computer’s memory equal the righthand-side’s memory location. This is&#13;
why the comparison returns <code>false</code>. The same is true for objects. What&#13;
we’re doing with the object comparison is creating two different objects&#13;
in memory on the lefthand side and the righthand side—of course&#13;
they’re not equal, they’re two different objects that live in two&#13;
different places in memory! They just have the same content.</p>&#13;
&#13;
<p>This is why <code>React.memo</code> can be tricky to use. Consider a functional&#13;
component <code>List</code> that takes in an array of items as a prop and renders&#13;
them:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">List</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">memo</code><code class="p">(</code><code class="kd">function</code><code class="w"> </code><code class="nx">List</code><code class="p">({</code><code class="w"> </code><code class="nx">items</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">}&gt;{</code><code class="nx">item</code><code class="p">}&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/></pre>&#13;
&#13;
<p>Now, imagine using this component within a parent component and passing&#13;
a new array instance each time the parent renders:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">ParentComponent</code><code class="p">({</code><code class="w"> </code><code class="nx">allFruits</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">favoriteFruits</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">allFruits</code><code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">fruit</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">fruit</code><code class="p">.</code><code class="nx">isFavorite</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">List</code> <code class="na">items</code><code class="o">=</code><code class="p">{</code><code class="nx">favoriteFruits</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Every time the <code>Increment</code> button is clicked, the <code>ParentComponent</code>&#13;
rerenders. Even though the items passed to <code>List</code> haven’t changed in&#13;
value, a new array instance is created, with&#13;
<code>['apple', 'banana', 'cherry']</code> each time. Since <code>React.memo</code> performs a&#13;
shallow comparison of props, it will see this new array instance as a&#13;
different prop from the previous render’s array, causing the <code>List</code>&#13;
component to rerender &#13;
<span class="keep-together">unnecessarily.</span></p>&#13;
&#13;
<p>To fix this, we could memoize the array using the <code>useMemo</code> hook:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">ParentComponent</code><code class="p">({</code><code class="w"> </code><code class="nx">allFruits</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">favoriteFruits</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">useMemo</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">allFruits</code><code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">fruit</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">fruit</code><code class="p">.</code><code class="nx">isFavorite</code><code class="p">),</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">[]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">List</code> <code class="na">items</code><code class="o">=</code><code class="p">{</code><code class="nx">favoriteFruits</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Now, the array is only created once and retains the same reference&#13;
across rerenders, preventing unnecessary rerenders of the <code>List</code>&#13;
component.</p>&#13;
&#13;
<p>This example underscores the importance of understanding reference&#13;
comparisons when working with <code>React.memo</code> and nonscalar props. If not&#13;
used cautiously, we could inadvertently introduce performance issues&#13;
instead of optimizations<a data-startref="ix_arraysmemoizationof.05.297.16" data-type="indexterm" id="id680"/><a data-startref="ix_memoizationarrays.05.297.16" data-type="indexterm" id="id681"/>.</p>&#13;
&#13;
<p><code>React.memo</code> often also gets circumvented quite commonly by another&#13;
nonscalar type: functions<a data-primary="functions, memoization of" data-type="indexterm" id="id682"/>. Consider the following case:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">MemoizedAvatar</code>&#13;
  <code class="na">name</code><code class="o">=</code><code class="s">"Tejas"</code>&#13;
  <code class="na">url</code><code class="o">=</code><code class="s">"https://github.com/tejasq.png"</code>&#13;
  <code class="na">onChange</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">save</code><code class="p">()}</code>&#13;
<code class="p">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>While the props don’t appear to change or depend on enclosing state with&#13;
props <code>name</code>, <code>url</code>, and <code>onChange</code> all having constant values, if we&#13;
compare the props we see the following:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="s2">"Tejas"</code> <code class="o">===</code> <code class="s2">"Tejas"</code><code class="p">;</code> <code class="c1">// &lt;- `name` prop; true</code>&#13;
<code class="s2">"https://github.com/tejasq.png"</code> <code class="o">===</code> <code class="s2">"https://github.com/tejasq.png"</code><code class="p">;</code>&#13;
&#13;
<code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">save</code><code class="p">())</code> <code class="o">===</code> <code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">save</code><code class="p">());</code> <code class="c1">// &lt;- `onChange` prop; false</code></pre>&#13;
&#13;
<p>Once again, this is because we’re comparing functions <em>by reference</em>.&#13;
Remember that as long as props differ, our component will not be memoized. We&#13;
can combat this by using the <code>useCallback</code> hook inside&#13;
<code>MemoizedAvatar</code>’s parent:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">Parent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">currentUser</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">onAvatarChange</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useCallback</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">(</code><code class="nx">newAvatarUrl</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">updateUserModel</code><code class="p">({</code><code class="w"> </code><code class="nx">avatarUrl</code><code class="o">:</code><code class="w"> </code><code class="nx">newAvatarUrl</code><code class="p">,</code><code class="w"> </code><code class="nx">id</code><code class="o">:</code><code class="w"> </code><code class="nx">currentUser</code><code class="p">.</code><code class="nx">id</code><code class="w"> </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">[</code><code class="nx">currentUser</code><code class="p">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">MemoizedAvatar</code>&#13;
      <code class="na">name</code><code class="o">=</code><code class="s">"Tejas"</code>&#13;
      <code class="na">url</code><code class="o">=</code><code class="s">"https://github.com/tejasq.png"</code>&#13;
      <code class="na">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">onAvatarChange</code><code class="p">}</code>&#13;
    <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now we can be confident that <code>onAvatarChange</code> will never change unless&#13;
one of the things in its dependency array (second argument) changes,&#13;
like the current user ID. With this, our memoization is fully complete&#13;
and reliable. This is the recommended way to memoize components that&#13;
have functions as props.</p>&#13;
&#13;
<p>Great! This now means that our memoized components will never&#13;
unnecessarily rerender. Right? Wrong! There’s one more thing we need to&#13;
be aware of<a data-startref="ix_Reactmemononscalars.05.266.40" data-type="indexterm" id="id683"/><a data-startref="ix_nonscalarsReactmemo.05.266.40" data-type="indexterm" id="id684"/><a data-startref="ix_referencetypesReactmemo.05.266.40" data-type="indexterm" id="id685"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="It’s a Guideline, Not a Rule" data-type="sect2"><div class="sect2" id="id63">&#13;
<h2>It’s a Guideline, Not a Rule</h2>&#13;
&#13;
<p>React<a data-primary="React.memo" data-secondary="as guideline, not rule" data-secondary-sortas="guideline, not rule" data-type="indexterm" id="ix_Reactmemoasguidelinenotrule.05.440.6"/> uses <code>React.memo</code> as a hint to its reconciler that we don’t want&#13;
our components to rerender if their props stay the same. The function&#13;
just hints to React. Ultimately, what React does is up to React.&#13;
<code>React.memo</code> is consistent about avoiding rerenders that cascade from&#13;
the parent, and that’s its one purpose. It’s not a guarantee that a&#13;
component will never rerender. To echo back to the beginning of this&#13;
book, React is intended to be a declarative<a data-primary="declarative programming" data-secondary="in React" data-secondary-sortas="React" data-type="indexterm" id="id686"/> abstraction of our user&#13;
interface where we describe <em>what</em> we want, and React figures out the&#13;
best way <em>how</em> to do it. <code>React.memo</code> is a part of this.</p>&#13;
&#13;
<p><code>React.memo</code> does not guarantee consistently avoided rerenders<a data-primary="unnecessary rerenders" data-type="indexterm" id="ix_unnecessaryrerenders.05.450.63"/><a data-primary="rerendering" data-secondary="React.memo determination on" data-type="indexterm" id="ix_rerenderingReactmemodeterminationon.05.450.63"/>, because&#13;
React may decide to rerender a memoized component for various reasons,&#13;
such as changes to the component tree or changes to the global state of&#13;
the application.</p>&#13;
&#13;
<p>To understand this more, let’s take a look at some code snippets from&#13;
React’s source code.</p>&#13;
&#13;
<p>First, let’s look at the implementation of <code>React.memo</code>:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">memo</code><code class="p">(</code><code class="nx">type</code><code class="p">,</code><code class="w"> </code><code class="nx">compare</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">$$typeof</code><code class="o">:</code><code class="w"> </code><code class="nx">REACT_MEMO_TYPE</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">type</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">compare</code><code class="o">:</code><code class="w"> </code><code class="nx">compare</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="kc">undefined</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="kc">null</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="nx">compare</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this implementation, <code>React.memo</code> returns a new object that&#13;
represents the memoized component. The object has a <code>$$typeof</code> property&#13;
that identifies it as a memoized component, a <code>type</code> property that&#13;
references the original component, and a <code>compare</code> property that&#13;
specifies the comparison function to use for memoization.</p>&#13;
&#13;
<p>Next, let’s look at how <code>React.memo</code> is used in the reconciler:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">updateMemoComponent</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">current</code><code class="o">:</code><code class="w"> </code><code class="nx">Fiber</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="kc">null</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">workInProgress</code><code class="o">:</code><code class="w"> </code><code class="nx">Fiber</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">Component</code><code class="o">:</code><code class="w"> </code><code class="nx">any</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">nextProps</code><code class="o">:</code><code class="w"> </code><code class="nx">any</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">renderLanes</code><code class="o">:</code><code class="w"> </code><code class="nx">Lanes</code><code class="w"/>&#13;
<code class="p">)</code><code class="o">:</code><code class="w"> </code><code class="kc">null</code><code class="w"> </code><code class="o">|</code><code class="w"> </code><code class="nx">Fiber</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">current</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="kc">null</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">Component</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">isSimpleFunctionComponent</code><code class="p">(</code><code class="nx">type</code><code class="p">)</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">Component</code><code class="p">.</code><code class="nx">compare</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="kc">null</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// SimpleMemoComponent codepath doesn't resolve outer props either.</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">Component</code><code class="p">.</code><code class="nx">defaultProps</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="kc">undefined</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="kd">let</code><code class="w"> </code><code class="nx">resolvedType</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">type</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">__DEV__</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">resolvedType</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">resolveFunctionForHotReloading</code><code class="p">(</code><code class="nx">type</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// If this is a plain function component without default props,</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// and with only the default shallow comparison, we upgrade it</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// to a SimpleMemoComponent to allow fast path updates.</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">tag</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">SimpleMemoComponent</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">resolvedType</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">__DEV__</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">validateFunctionComponentInDev</code><code class="p">(</code><code class="nx">workInProgress</code><code class="p">,</code><code class="w"> </code><code class="nx">type</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nx">updateSimpleMemoComponent</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">current</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">workInProgress</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">resolvedType</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">nextProps</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">renderLanes</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">__DEV__</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="kd">const</code><code class="w"> </code><code class="nx">innerPropTypes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">type</code><code class="p">.</code><code class="nx">propTypes</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">innerPropTypes</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="c1">// Inner memo component props aren't currently validated in createElement</code><code class="w"/>&#13;
<code class="w">        </code><code class="c1">// We could move it there, but we'd still need this for lazy code path.</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">checkPropTypes</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">innerPropTypes</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">nextProps</code><code class="p">,</code><code class="w"> </code><code class="c1">// Resolved props</code><code class="w"/>&#13;
<code class="w">          </code><code class="s2">"prop"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">getComponentNameFromType</code><code class="p">(</code><code class="nx">type</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">Component</code><code class="p">.</code><code class="nx">defaultProps</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="kc">undefined</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="kd">const</code><code class="w"> </code><code class="nx">componentName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">getComponentNameFromType</code><code class="p">(</code><code class="nx">type</code><code class="p">)</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="s2">"Unknown"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="nx">didWarnAboutDefaultPropsOnFunctionComponent</code><code class="p">[</code><code class="nx">componentName</code><code class="p">])</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">            </code><code class="s2">"%s: Support for defaultProps will be removed from components "</code><code class="w"> </code><code class="o">+</code><code class="w"/>&#13;
<code class="w">              </code><code class="s2">"in a future release. Use JavaScript default parameters instead."</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">            </code><code class="nx">componentName</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">didWarnAboutDefaultPropsOnFunctionComponent</code><code class="p">[</code><code class="nx">componentName</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="kc">true</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">child</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">createFiberFromTypeAndProps</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">Component</code><code class="p">.</code><code class="nx">type</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="kc">null</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">nextProps</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="kc">null</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">workInProgress</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">mode</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">renderLanes</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">child</code><code class="p">.</code><code class="nx">ref</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">ref</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">child</code><code class="p">.</code><code class="k">return</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">workInProgress</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">child</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">child</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">child</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">__DEV__</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">type</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">Component</code><code class="p">.</code><code class="nx">type</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">innerPropTypes</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">type</code><code class="p">.</code><code class="nx">propTypes</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">innerPropTypes</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Inner memo component props aren't currently validated in createElement</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// We could move it there, but we'd still need this for lazy code path.</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">checkPropTypes</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">innerPropTypes</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">nextProps</code><code class="p">,</code><code class="w"> </code><code class="c1">// Resolved props</code><code class="w"/>&#13;
<code class="w">        </code><code class="s2">"prop"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">getComponentNameFromType</code><code class="p">(</code><code class="nx">type</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// This is always exactly one child</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">currentChild</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">((</code><code class="nx">current</code><code class="p">.</code><code class="nx">child</code><code class="o">:</code><code class="w"> </code><code class="nx">any</code><code class="p">)</code><code class="o">:</code><code class="w"> </code><code class="nx">Fiber</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">hasScheduledUpdateOrContext</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">checkScheduledUpdateOrContext</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">current</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">renderLanes</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="o">!</code><code class="nx">hasScheduledUpdateOrContext</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// This will be the props with resolved defaultProps,</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// unlike current.memoizedProps which will be the unresolved ones.</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">prevProps</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">currentChild</code><code class="p">.</code><code class="nx">memoizedProps</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Default to shallow comparison</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="nx">compare</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">Component</code><code class="p">.</code><code class="nx">compare</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">compare</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">compare</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="kc">null</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="nx">compare</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="nx">shallowEqual</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">compare</code><code class="p">(</code><code class="nx">prevProps</code><code class="p">,</code><code class="w"> </code><code class="nx">nextProps</code><code class="p">)</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">current</code><code class="p">.</code><code class="nx">ref</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">ref</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nx">bailoutOnAlreadyFinishedWork</code><code class="p">(</code><code class="nx">current</code><code class="p">,</code><code class="w"> </code><code class="nx">workInProgress</code><code class="p">,</code><code class="w"> </code><code class="nx">renderLanes</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// React DevTools reads this flag.</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">flags</code><code class="w"> </code><code class="o">|=</code><code class="w"> </code><code class="nx">PerformedWork</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">newChild</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">createWorkInProgress</code><code class="p">(</code><code class="nx">currentChild</code><code class="p">,</code><code class="w"> </code><code class="nx">nextProps</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">newChild</code><code class="p">.</code><code class="nx">ref</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">ref</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">newChild</code><code class="p">.</code><code class="k">return</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">workInProgress</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">workInProgress</code><code class="p">.</code><code class="nx">child</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">newChild</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nx">newChild</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Here’s a breakdown of what’s happening:</p>&#13;
<dl>&#13;
<dt>1. Initial check</dt>&#13;
<dd>&#13;
<p>The function <code>updateMemoComponent</code> takes several&#13;
parameters, including the current and work-in-progress Fibers, the&#13;
component, new props, and render lanes (which, as discussed, indicate&#13;
priority and timing of updates). The initial check&#13;
(<code>if (current === null)</code>) determines if this is the initial render of&#13;
the component. If <code>current</code> is <code>null</code>, the component is being&#13;
mounted for the first time.</p>&#13;
</dd>&#13;
<dt>2. Type and fast path optimization</dt>&#13;
<dd>&#13;
<p>It then checks if the component is&#13;
a simple function component and eligible for a fast path update by&#13;
checking <code>Component.compare</code> and <code>Component.defaultProps</code>. If these&#13;
conditions are met, it sets the work-in-progress Fiber’s tag to&#13;
<code>SimpleMemoComponent</code>, indicating a simpler component type that can be&#13;
updated more &#13;
<span class="keep-together">efficiently.</span></p>&#13;
</dd>&#13;
<dt>3. Development mode checks</dt>&#13;
<dd>&#13;
<p>In development mode (<code>__DEV__</code>), the&#13;
function performs additional checks, like validating prop types and&#13;
warning about deprecated features (like <code>defaultProps</code> in function&#13;
components).</p>&#13;
</dd>&#13;
<dt>4. Creating new Fiber</dt>&#13;
<dd>&#13;
<p>If it’s the initial render, a new Fiber is&#13;
created with <code>createFiberFromTypeAndProps</code>. This Fiber represents the&#13;
unit of work for React’s renderer. It sets up references and returns the&#13;
child (new Fiber).</p>&#13;
</dd>&#13;
<dt>5. Updating existing Fiber</dt>&#13;
<dd>&#13;
<p>If the component is updating&#13;
(<code>current !== null</code>), it performs similar development mode checks. It&#13;
then checks if the component needs an update by comparing the old props&#13;
with new props using a shallow comparison (<code>shallowEqual</code>) or a custom&#13;
comparison function, if provided.</p>&#13;
</dd>&#13;
<dt>6. Bailing out of update</dt>&#13;
<dd>&#13;
<p>If the props are equal and the ref hasn’t&#13;
changed, it can bail out of the update using&#13;
<code>bailoutOnAlreadyFinishedWork</code>, which means no further rendering work is&#13;
needed for this component.</p>&#13;
</dd>&#13;
<dt>7. Updating work-in-progress Fiber</dt>&#13;
<dd>&#13;
<p>If an update is needed, the&#13;
function flags the work-in-progress Fiber with &#13;
<span class="keep-together"><code>PerformedWork</code></span> and&#13;
creates a new work-in-progress child Fiber based on the current child,&#13;
but with new props.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>To summarize, this function is responsible for determining whether a&#13;
memoized component (a component wrapped with <code>React.memo</code>) needs to be&#13;
updated or if it can skip updating to optimize performance. It handles&#13;
both the initial render and updates, performing different operations&#13;
based on whether it’s creating a new Fiber or updating an existing one.</p>&#13;
&#13;
<p>Here’s what parts of this function tell us about the conditions under&#13;
which a <code>React.memo</code> component would rerender or not:</p>&#13;
<dl>&#13;
<dt>No previous render (initial mount)</dt>&#13;
<dd>&#13;
<p>If <code>current === null</code>, the component<a data-primary="initial mount (no previous rerender), React.memo" data-type="indexterm" id="id687"/> is being mounted for the first time and&#13;
thus it cannot skip rendering. A new Fiber is created and returned for&#13;
the component to render.</p>&#13;
</dd>&#13;
<dt>Simple function component optimization</dt>&#13;
<dd>&#13;
<p>If the component is a simple function component<a data-primary="simple function component optimization, React.memo" data-type="indexterm" id="id688"/> (without default props and without a custom comparison function), React will optimize it to a <code>SimpleMemoComponent</code>. This allows React to use a fast path for updates because it can assume that the component only depends on its props and nothing else, and a shallow comparison is sufficient to determine if it should update.</p>&#13;
</dd>&#13;
<dt>Comparison function</dt>&#13;
<dd>&#13;
<p>If there is a previous render<a data-primary="comparison function situation, React.memo" data-type="indexterm" id="id689"/>, the component&#13;
will only update if the comparison function returns <code>false</code>. This&#13;
comparison function can be custom if supplied or default to a shallow&#13;
equality check (<code>shallowEqual</code>). If the comparison function determines&#13;
that the new props are equal to the previous props and the <code>ref</code> is the&#13;
same, the component will not rerender, and the function will bail out of&#13;
the rendering process.</p>&#13;
</dd>&#13;
<dt>Default props and prop types in development</dt>&#13;
<dd>&#13;
<p>In development mode<a data-primary="development mode, React.memo" data-type="indexterm" id="id690"/><a data-primary="defaultProps, React.memo" data-type="indexterm" id="id691"/><a data-primary="propTypes" data-type="indexterm" id="id692"/>&#13;
(<code>__DEV__</code>), there are checks for <code>defaultProps</code> and <code>propTypes</code>. The&#13;
use of <code>defaultProps</code> will trigger a warning in development mode because&#13;
future versions of React plan to deprecate <code>defaultProps</code> on function&#13;
components. Prop types are checked for validation purposes.</p>&#13;
</dd>&#13;
<dt>Bailout conditions</dt>&#13;
<dd>&#13;
<p>If there are no scheduled updates<a data-primary="bailout conditions for rerendering, React.memo" data-type="indexterm" id="id693"/> or context&#13;
changes (<code>hasScheduledUpdateOr​Con⁠text</code> is <code>false</code>), the comparison&#13;
function deems the old and new props to be equal, and the <code>ref</code> hasn’t&#13;
changed, then the function will return the result of&#13;
<code>bailoutOnAlreadyFinishedWork</code>, effectively skipping the rerender.</p>&#13;
&#13;
<p>However, if there are scheduled context updates<a data-primary="context updates" data-type="indexterm" id="id694"/><a data-primary="updates" data-secondary="context" data-type="indexterm" id="id695"/>, the component will&#13;
rerender—even if its props don’t change. This is because context&#13;
updates are considered to be outside the scope of the component’s props.&#13;
State changes, context changes, and scheduled updates can also trigger&#13;
rerenders.</p>&#13;
</dd>&#13;
<dt>Performed work flag</dt>&#13;
<dd>&#13;
<p>If an update is necessary<a data-primary="workInProgress" data-type="indexterm" id="id696"/><a data-primary="Fiber reconciler" data-secondary="workInProgress in" data-type="indexterm" id="id697"/><a data-primary="reconciliation" data-secondary="Fiber reconciler" data-type="indexterm" id="id698"/>, the <code>PerformedWork</code>&#13;
flag is set on the <code>workInProgress</code> Fiber, indicating that this Fiber&#13;
has performed work during the current render.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Thus, <code>React.memo</code> components will not rerender if the comparison&#13;
between the old and new props (using either the custom provided&#13;
comparison function or the default shallow comparison) determines that&#13;
the props are equal, and there are no updates scheduled due to state or&#13;
context changes. If the props are determined to be different, or if&#13;
there are state or context changes, the component will rerender<a data-startref="ix_memoizationwithReactmemo.05.14.12" data-type="indexterm" id="id699"/><a data-startref="ix_Reactmemo.05.14.12" data-type="indexterm" id="id700"/><a data-startref="ix_Reactmemoasguidelinenotrule.05.440.6" data-type="indexterm" id="id701"/><a data-startref="ix_unnecessaryrerenders.05.450.63" data-type="indexterm" id="id702"/><a data-startref="ix_rerenderingReactmemodeterminationon.05.450.63" data-type="indexterm" id="id703"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Memoization with useMemo" data-type="sect1"><div class="sect1" id="id64">&#13;
<h1>Memoization with useMemo</h1>&#13;
&#13;
<p><code>React.memo</code> and the <code>useMemo</code> hook are both tools for memoization<a data-primary="memoization" data-secondary="with useMemo hook" data-secondary-sortas="useMemo" data-type="indexterm" id="ix_memoizationwithuseMemohook.05.695.67"/><a data-primary="useMemo hook" data-type="indexterm" id="ix_useMemohook.05.695.67"/>, but&#13;
with very different purposes. <code>React.memo</code> memoizes an entire component&#13;
to keep it from rerendering. <code>useMemo</code> memoizes a specific calculation&#13;
inside a component, to avoid expensive recalculations and preserve a&#13;
consistent reference for the result.</p>&#13;
&#13;
<p>Let’s briefly delve into <code>useMemo</code>. Consider a component:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">People</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">unsortedPeople</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">setName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">sortedPeople</code> <code class="o">=</code> <code class="nx">unsortedPeople</code><code class="p">.</code><code class="nx">sort</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">b</code><code class="p">.</code><code class="nx">age</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">age</code><code class="p">);</code>&#13;
&#13;
  <code class="c1">// ... rest of the component</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This component can potentially slow down our application due to its&#13;
sorting operation. The sorting operation has a time complexity that’s&#13;
typically O(n log n) for average and worst-case scenarios. If our list&#13;
has, say, one million people, it can involve significant computational&#13;
overhead on each render. In computer science terms, the sorting&#13;
operation’s efficiency is largely determined by the number of items,&#13;
n, hence the O(n log n) time complexity.</p>&#13;
&#13;
<p>To optimize this, we would use the <code>useMemo</code> hook to avoid sorting the&#13;
people array on every render, especially when the <code>unsortedPeople</code> array&#13;
hasn’t changed.</p>&#13;
&#13;
<p>The current implementation of the component presents a significant&#13;
performance issue. Every time the state updates, which happens on every&#13;
keystroke inside the input field, the component rerenders. If a name is&#13;
entered with 5 characters and our list contains 1,000,000 people, the&#13;
component will rerender 5 times. For each render, it will sort the&#13;
list, which involves on the order of 1,000,000 × log(1,000,000) operations due&#13;
to the time complexity of sorting. This amounts to many millions of&#13;
operations just for entering a five-character name! Fortunately, this&#13;
inefficiency can be mitigated using the <code>useMemo</code> hook, ensuring that&#13;
the sorting operation is only executed when the <code>unsortedPeople</code> array&#13;
changes.</p>&#13;
&#13;
<p>Let’s rewrite that code snippet a little bit:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">People</code> <code class="o">=</code> <code class="p">({</code> <code class="nx">unsortedPeople</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">setName</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">sortedPeople</code> <code class="o">=</code> <code class="nx">useMemo</code><code class="p">(</code>&#13;
    <code class="c1">// Spreading so we don't mutate the original array</code>&#13;
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">[...</code><code class="nx">unsortedPeople</code><code class="p">].</code><code class="nx">sort</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">b</code><code class="p">.</code><code class="nx">age</code> <code class="o">-</code> <code class="nx">a</code><code class="p">.</code><code class="nx">age</code><code class="p">),</code>&#13;
    <code class="p">[</code><code class="nx">unsortedPeople</code><code class="p">]</code>&#13;
  <code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
        <code class="nx">Enter</code> <code class="nx">your</code> <code class="nx">name</code><code class="o">:</code><code class="p">{</code><code class="s2">" "</code><code class="p">}</code>&#13;
        <code class="o">&lt;</code><code class="nx">input</code>&#13;
          <code class="nx">type</code><code class="o">=</code><code class="s2">"text"</code>&#13;
          <code class="nx">placeholder</code><code class="o">=</code><code class="s2">"Obinna Ekwuno"</code>&#13;
          <code class="nx">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">setName</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
        <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Hi</code><code class="p">,</code> <code class="p">{</code><code class="nx">name</code><code class="p">}</code><code class="o">!</code> <code class="nx">Here</code><code class="err">'</code><code class="nx">s</code> <code class="nx">a</code> <code class="nx">list</code> <code class="k">of</code> <code class="nx">people</code> <code class="nx">sorted</code> <code class="nx">by</code> <code class="nx">age</code><code class="o">!&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">ul</code><code class="o">&gt;</code>&#13;
        <code class="p">{</code><code class="nx">sortedPeople</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">p</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code>&#13;
          <code class="o">&lt;</code><code class="nx">li</code> <code class="nx">key</code><code class="o">=</code><code class="p">{</code><code class="nx">p</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code><code class="o">&gt;</code>&#13;
            <code class="p">{</code><code class="nx">p</code><code class="p">.</code><code class="nx">name</code><code class="p">},</code> <code class="nx">age</code> <code class="p">{</code><code class="nx">p</code><code class="p">.</code><code class="nx">age</code><code class="p">}</code>&#13;
          <code class="o">&lt;</code><code class="err">/li&gt;</code>&#13;
        <code class="p">))}</code>&#13;
      <code class="o">&lt;</code><code class="err">/ul&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>There! Much better! We wrapped the value of <code>sortedPeople</code> in a function&#13;
that was passed to the first argument of <code>useMemo</code>. The second argument&#13;
we pass to <code>useMemo</code> represents an array of values that, if changed,&#13;
re-sorts the array. Since the array contains only <code>unsortedPeople</code>, it&#13;
will only sort the array once, and every time the list of people&#13;
changes—not whenever someone types in the name input field. This is a&#13;
great example of how to use <code>useMemo</code> to avoid unnecessary<a data-primary="unnecessary rerenders" data-type="indexterm" id="id704"/> rerenders.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="useMemo Considered Harmful" data-type="sect2"><div class="sect2" id="id65">&#13;
<h2>useMemo Considered Harmful</h2>&#13;
&#13;
<p>While it might be tempting to wrap all variable declarations inside a&#13;
component with <code>useMemo</code>, this isn’t always beneficial<a data-primary="performance" data-secondary="useMemo drawback with scalars" data-type="indexterm" id="ix_performanceuseMemodrawbackwithscalars.05.783.55"/>. <code>useMemo</code> is&#13;
particularly valuable for memoizing computationally expensive operations&#13;
or maintaining stable references to objects and arrays. For scalar&#13;
values, such as strings, numbers, or booleans, using <code>useMemo</code> is&#13;
typically unnecessary. This is because these scalar values are passed&#13;
and compared by their actual value in JavaScript, not by reference. So&#13;
every time you set or compare a scalar value<a data-primary="scalars" data-type="indexterm" id="id705"/>, it’s the actual value&#13;
you’re working with, not a reference to a memory location that might&#13;
change.</p>&#13;
&#13;
<p>In these cases, loading and executing the <code>useMemo</code> function may be more&#13;
expensive than the actual operation it’s trying to optimize. For&#13;
instance, consider the following example:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">doubledCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useMemo</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mf">2</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Doubled</code><code class="w"> </code><code class="nx">count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">doubledCount</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">((</code><code class="nx">oldCount</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">oldCount</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">Increment</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, the <code>doubledCount</code> variable is memoized using the&#13;
<code>useMemo</code> hook. However, since <code>count</code> is a scalar value, it’s not&#13;
necessary to memoize it. Instead, we can simply compute the doubled&#13;
count directly in the JSX:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Doubled</code><code class="w"> </code><code class="nx">count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mf">2</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">((</code><code class="nx">oldCount</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">oldCount</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">Increment</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, <code>doubledCount</code> is no longer memoized, but the component still&#13;
performs the same computation with less memory consumption and overhead&#13;
since we’re not importing and invoking <code>useMemo</code>. This is a good example&#13;
of how to avoid using <code>useMemo</code> when it’s not necessary.</p>&#13;
&#13;
<p>What may present an additional performance problem, however, is that&#13;
we’re re-creating the <code>onClick</code> handler on the button on every render&#13;
since it’s passed by memory reference. But is this really a problem?&#13;
Let’s look closer.</p>&#13;
&#13;
<p>Some suggest that we should memoize the <code>onClick</code> handler using&#13;
<code>useCallback</code>:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">doubledCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useMemo</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">*</code><code class="w"> </code><code class="mf">2</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">]);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">increment</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useCallback</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">((</code><code class="nx">oldCount</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">oldCount</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">),</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">[</code><code class="nx">setCount</code><code class="p">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Doubled</code><code class="w"> </code><code class="nx">count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">doubledCount</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">increment</code><code class="p">}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Should we, though? The answer is no. There is no benefit in having the&#13;
increment function memoized here, since <code>&lt;button&gt;</code> is a browser-native&#13;
element and not a React function component that can be called. Also,&#13;
there are no further components below it that React would continue on to&#13;
render.</p>&#13;
&#13;
<p>Moreover, in React, built-in or “host” components (like <code>div</code>,&#13;
<code>button</code>, <code>input</code>, etc.) are treated slightly differently from custom&#13;
components when it comes to props, including function props.</p>&#13;
&#13;
<p>Here’s what happens with <a data-primary="function props on built-in components, useMemo" data-type="indexterm" id="ix_functionpropsonbuiltincomponentsuseMemo.05.880.26"/>function props on built-in components:</p>&#13;
<dl>&#13;
<dt>Direct pass-through</dt>&#13;
<dd>&#13;
<p>When you pass a function prop<a data-primary="direct pass-through of built-in components" data-type="indexterm" id="id706"/> (such as an&#13;
<code>onClick</code> handler) to a built-in component, React passes it through&#13;
directly to the actual DOM element. It does not create any wrappers or&#13;
perform any additional work on these functions.</p>&#13;
&#13;
<p>However, in the case of <code>onClick</code> and event-based props, React uses&#13;
event delegation<a data-primary="event delegation (event bubbling)" data-type="indexterm" id="id707"/> for handling events, not direct attachment of event&#13;
handlers to DOM elements. This means that when you provide an <code>onClick</code>&#13;
handler to a built-in React element like a <code>&lt;button&gt;</code>, React does not&#13;
attach the <code>onClick</code> handler directly to the button’s DOM node. Instead,&#13;
React listens for all events at the top level using a single event&#13;
listener. This is attached to the root of the document (or the root of&#13;
the React application), and it relies on event bubbling to catch events&#13;
that originate from individual elements. This approach is efficient&#13;
because it reduces the memory footprint and the initial setup time for&#13;
event handlers. Rather than having to attach and manage individual&#13;
handlers for each instance of an event on each element, React can handle&#13;
all events of a particular type (like clicks) with a single real event&#13;
listener. When an event occurs, React maps it to the appropriate&#13;
component and calls the handlers you’ve defined in a way that follows&#13;
the expected propagation path. So even though the events are being&#13;
caught at the top level, they will behave as if they were attached&#13;
directly to the specific elements. This event delegation system is&#13;
mostly transparent when you’re writing a React application; you define&#13;
<code>onClick</code> handlers the same way you would if they were being attached&#13;
directly. Under the hood, however, React is optimizing event handling&#13;
for you.</p>&#13;
</dd>&#13;
<dt>Rerendering behavior</dt>&#13;
<dd>&#13;
<p>Built-in components<a data-primary="rerendering" data-secondary="and changes to function props" data-type="indexterm" id="id708"/> do not rerender due to&#13;
changes in function props unless they are part of a higher component&#13;
that has rerendered. For example, if a parent component rerenders and&#13;
provides a new function as a prop to a built-in component, the built-in&#13;
component will rerender because its props have changed. However, this&#13;
rerender is typically fast and not something you generally need to&#13;
optimize unless profiling shows it to be a problem.</p>&#13;
</dd>&#13;
<dt>No virtual DOM comparison for functions</dt>&#13;
<dd>&#13;
<p>The virtual DOM comparison&#13;
for built-in components<a data-primary="virtual DOM (vDOM)" data-secondary="lack of comparison for functions" data-type="indexterm" id="id709"/> is based on the identity of the function props.&#13;
If you pass an inline function (like <code>onClick={() =&gt; do​Something()}</code>),&#13;
it will be a new function each time the component renders, but React&#13;
doesn’t do a deep comparison on functions to detect changes. The new&#13;
function simply replaces the old one on the DOM element, and thus we get&#13;
performance savings with built-in components.</p>&#13;
</dd>&#13;
<dt>Event pooling</dt>&#13;
<dd>&#13;
<p>React uses event pooling for event handlers to reduce&#13;
memory overhead. The event object that is passed to your event handlers&#13;
is a synthetic event that is pooled, meaning that it is reused for&#13;
different events to reduce the garbage collection overhead.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>This is a strong contrast to custom components<a data-primary="custom React components, rendering" data-type="indexterm" id="ix_customReactcomponentsrendering.05.933.47"/><a data-primary="rendering" data-secondary="custom React components" data-type="indexterm" id="ix_renderingcustomReactcomponents.05.933.47"/>. For custom components,&#13;
if you pass a new function as a prop, the child component may rerender&#13;
if it’s a pure component or if it has memoization applied (such as with&#13;
<code>React.memo</code>), because it detects a change in props. But for host&#13;
components, React doesn’t provide such built-in memoization because it&#13;
would add overhead that isn’t beneficial in most cases. The actual DOM&#13;
elements that React outputs don’t have a memoization concept; they&#13;
simply update with the new function reference when the properties&#13;
change.</p>&#13;
&#13;
<p>In practice, this means that while you should be cautious about passing&#13;
new function instances to custom components that might be expensive to&#13;
rerender, doing so with built-in components is less of a concern.&#13;
However, it’s always good to be mindful of how often you’re creating new&#13;
functions and passing them around, as unnecessary function creation can&#13;
lead to garbage collection churn, which might be a performance issue in&#13;
very high-frequency update scenarios.</p>&#13;
&#13;
<p>Thus, <code>useCallback</code> isn’t helping here at all, and is in fact worse than&#13;
useless: not only does it provide no value, it also adds overhead to our&#13;
application. This is because <code>useCallback</code> has to be imported, invoked,&#13;
and passed the dependencies, and then it has to compare the dependencies&#13;
to see if the function should be recomputed. All of this has runtime&#13;
complexity that can hurt our app more than help it.</p>&#13;
&#13;
<p>What’s a good example<a data-primary="useCallback hook for rerendered components" data-type="indexterm" id="ix_useCallbackhookforrerenderedcomponents.05.958.22"/> for <code>useCallback</code> then? <code>useCallback</code> is&#13;
particularly useful when you have a component that is likely to&#13;
rerender often and you pass a callback down to a child component,&#13;
especially if that child component is optimized with <code>React.memo</code> or&#13;
<code>shouldComponentUpdate</code>. The memoization of the callback ensures that&#13;
the child component does not rerender unnecessarily when the parent&#13;
component renders<a data-startref="ix_functionpropsonbuiltincomponentsuseMemo.05.880.26" data-type="indexterm" id="id710"/>.</p>&#13;
&#13;
<p>Here’s an example where <code>useCallback</code> is beneficial:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="p">,</code><code class="w"> </code><code class="nx">useCallback</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ExpensiveComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">memo</code><code class="p">(({</code><code class="w"> </code><code class="nx">onButtonClick</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// This component is expensive to render and we want</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// to avoid unnecessary renders</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// We're just simulating something expensive here</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">now</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">performance</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nx">performance</code><code class="p">.</code><code class="nx">now</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">now</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">1000</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Artificial delay -- block for 1000ms</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">onButtonClick</code><code class="p">}&gt;</code><code class="nx">Click</code><code class="w"> </code><code class="nx">Me</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;;</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">otherState</code><code class="p">,</code><code class="w"> </code><code class="nx">setOtherState</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="c1">// This callback is memoized and will only change if count changes</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">incrementCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useCallback</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">setCount</code><code class="p">((</code><code class="nx">prevCount</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">prevCount</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"> </code><code class="c1">// Dependency array</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="c1">// This state update will cause MyComponent to rerender</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">doSomethingElse</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">setOtherState</code><code class="p">((</code><code class="nx">s</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">s</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="na">onButtonClick</code><code class="o">=</code><code class="p">{</code><code class="nx">incrementCount</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">doSomethingElse</code><code class="p">}&gt;</code><code class="nx">Do</code><code class="w"> </code><code class="nx">Something</code><code class="w"> </code><code class="nx">Else</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In this example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>ExpensiveComponent</code> is a child component that is wrapped in&#13;
<code>React.memo</code>, which means it will only rerender if its props change.&#13;
This is a case where you want to avoid passing a new function instance&#13;
on each render.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>MyComponent</code> has two pieces of state: <code>count</code> and <code>otherState</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>incrementCount</code> is a callback that updates <code>count</code>. It is memoized&#13;
with <code>use​Call⁠back</code>, which means the <code>ExpensiveComponent</code> will not&#13;
rerender when <code>MyComponent</code> rerenders due to a change in <code>otherState</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>doSomethingElse</code> function changes <code>otherState</code> but doesn’t need&#13;
to be memoized with <code>useCallback</code> because it is not passed down to&#13;
<code>Expensive​Compo⁠nent</code> or any other child.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>By using <code>useCallback</code>, we ensure that <code>ExpensiveComponent</code> does not&#13;
rerender unnecessarily when <code>MyComponent</code> rerenders for reasons&#13;
unrelated to <code>count</code>. This is beneficial in cases where the rendering of&#13;
the child component is a heavy operation and you want to optimize&#13;
performance by reducing the number of renders.</p>&#13;
&#13;
<p>This is a good example of how to use <code>useCallback</code> to avoid unnecessary&#13;
rerenders, ensuring that the function that is passed down to an&#13;
expensive component is only created once, and it retains the same&#13;
reference across rerenders. This prevents unnecessary rerenders of the&#13;
expensive component. <code>useCallback</code> is essentially <code>useMemo</code> for&#13;
functions.</p>&#13;
&#13;
<p>Let’s consider another example:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">dateOfBirth</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"1993-02-19"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">isAdult</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">    </code><code class="ow">new</code><code class="w"> </code><code class="nb">Date</code><code class="p">().</code><code class="nx">getFullYear</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="ow">new</code><code class="w"> </code><code class="nb">Date</code><code class="p">(</code><code class="nx">dateOfBirth</code><code class="p">).</code><code class="nx">getFullYear</code><code class="p">()</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mf">18</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">isAdult</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">You</code><code class="w"> </code><code class="nx">are</code><code class="w"> </code><code class="nx">an</code><code class="w"> </code><code class="nx">adult</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">You</code><code class="w"> </code><code class="nx">are</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="nx">minor</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>We’re not using <code>useMemo</code> here anywhere, mainly because the component is&#13;
stateless. This is good! But what if we have some input that triggers&#13;
rerenders like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">birthYear</code><code class="p">,</code><code class="w"> </code><code class="nx">setBirthYear</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">1993</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">isAdult</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="ow">new</code><code class="w"> </code><code class="nb">Date</code><code class="p">().</code><code class="nx">getFullYear</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">birthYear</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mf">18</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">label</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">Birth</code><code class="w"> </code><code class="nx">year</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">input</code>&#13;
          <code class="na">type</code><code class="o">=</code><code class="s">"number"</code>&#13;
          <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">birthYear</code><code class="p">}</code>&#13;
          <code class="na">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setBirthYear</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
        <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">label</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">isAdult</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">You</code><code class="w"> </code><code class="nx">are</code><code class="w"> </code><code class="nx">an</code><code class="w"> </code><code class="nx">adult</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">You</code><code class="w"> </code><code class="nx">are</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="nx">minor</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now we’re recomputing <code>new Date()</code> on every keystroke. Let’s fix this&#13;
with <code>useMemo</code>:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">birthYear</code><code class="p">,</code><code class="w"> </code><code class="nx">setBirthYear</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">1993</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">today</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useMemo</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="ow">new</code><code class="w"> </code><code class="nb">Date</code><code class="p">(),</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">isAdult</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">today</code><code class="p">.</code><code class="nx">getFullYear</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">birthYear</code><code class="w"> </code><code class="o">&gt;=</code><code class="w"> </code><code class="mf">18</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">label</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">Birth</code><code class="w"> </code><code class="nx">year</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">input</code>&#13;
          <code class="na">type</code><code class="o">=</code><code class="s">"number"</code>&#13;
          <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">birthYear</code><code class="p">}</code>&#13;
          <code class="na">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setBirthYear</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
        <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">label</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">isAdult</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">You</code><code class="w"> </code><code class="nx">are</code><code class="w"> </code><code class="nx">an</code><code class="w"> </code><code class="nx">adult</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">You</code><code class="w"> </code><code class="nx">are</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="nx">minor</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>This is good because <code>today</code> will be a reference to the same object&#13;
every time the component rerenders with the same props, and we assume&#13;
the component will always rerender in the same day.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There’s a slight edge case here if the user’s clock lapses at midnight&#13;
while they’re using this component, but this is a rare edge case that we&#13;
can ignore for now. Of course, we do better when there’s real production&#13;
code involved<a data-startref="ix_useCallbackhookforrerenderedcomponents.05.958.22" data-type="indexterm" id="id711"/>.</p>&#13;
</div>&#13;
&#13;
<p>This example facilitates a bigger question: should we wrap&#13;
<code>isAdult</code>’s value in <code>useMemo</code>? What happens if we do? The answer is&#13;
that we shouldn’t because <code>isAdult</code> is a scalar value that requires no&#13;
computation besides memory allocation. We <em>do</em> call <code>.getFullYear</code> a&#13;
bunch of times, but we trust the JavaScript engine and the React runtime&#13;
to handle the performance for us. It’s a simple assignment with no&#13;
further computation, like sorting, filter, or mapping.</p>&#13;
&#13;
<p>In this case, we should not use <code>useMemo</code> because it is more likely to&#13;
slow our app down than speed it up because of the overhead of&#13;
<code>useMemo</code> itself, including importing it, calling it, passing in the&#13;
dependencies, and then comparing the dependencies to see if the value&#13;
should be recomputed. All of this has runtime complexity that can hurt&#13;
our app more than help it. Instead, we assign and trust React to&#13;
intelligently rerender our component when necessary with its own&#13;
optimizations.</p>&#13;
&#13;
<p>Our applications are now enjoying performance benefits of faster&#13;
rerenders even in the face of heavy computations—but can we do more? In&#13;
the next section, let’s take a look at how all of the stuff we’ve&#13;
covered so far probably will not even matter in a few years based on&#13;
some exciting things the React team is working on to automatically&#13;
consider memoization for us, enabling us to <em>forget</em> about the details&#13;
and instead focus on our applications<a data-startref="ix_performanceuseMemodrawbackwithscalars.05.783.55" data-type="indexterm" id="id712"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Forget About All of This" data-type="sect2"><div class="sect2" id="id66">&#13;
<h2>Forget About All of This</h2>&#13;
&#13;
<p>React Forget<a data-primary="React Forget" data-type="indexterm" id="id713"/><a data-primary="Forget" data-type="indexterm" id="id714"/> is a new toolchain aimed at automating memoization in React&#13;
applications, potentially making hooks like <code>useMemo</code> and <code>useCallback</code>&#13;
redundant. By &#13;
<span class="keep-together">automatically</span> handling memoization, React Forget helps&#13;
optimize component rerendering, improving both user experience (UX) and&#13;
developer experience (DX). This automation shifts React’s rerendering&#13;
behavior from object identity changes to semantic value changes without&#13;
deep comparisons, thereby enhancing performance. Introduced at React&#13;
Conf 2021, React Forget is not yet generally available at the time of&#13;
writing, but is in use in production at Meta across Facebook, Instagram,&#13;
and more, and has “exceeded expectations” internally so far<a data-startref="ix_memoizationwithuseMemohook.05.695.67" data-type="indexterm" id="id715"/><a data-startref="ix_useMemohook.05.695.67" data-type="indexterm" id="id716"/>.</p>&#13;
&#13;
<p>If there is enough interest, we will cover React Forget in a future&#13;
edition of this book. Please let us know by posting about it on social&#13;
media (especially 𝕏, formerly Twitter) and tagging the author,&#13;
<em>@tejaskumar_</em>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lazy Loading" data-type="sect1"><div class="sect1" id="id67">&#13;
<h1>Lazy Loading</h1>&#13;
&#13;
<p>As our applications<a data-primary="lazy loading" data-type="indexterm" id="ix_lazyloading.05.1161.20"/><a data-primary="JavaScript" data-secondary="lazy loading" data-type="indexterm" id="ix_JavaScriptlazyloading.05.1161.20"/><a data-primary="performance" data-secondary="lazy loading" data-type="indexterm" id="ix_performancelazyloading.05.1161.20"/> grow, we accumulate a lot of JavaScript. Our users&#13;
then download these massive JavaScript bundles—sometimes going into the&#13;
double digits on megabytes—only to use a small portion of the code. This&#13;
is a problem because it slows down our users’ initial load time, and it&#13;
also slows down our users’ subsequent page loads because they have to&#13;
download the entire bundle again, especially when we don’t have access&#13;
to the servers that serve these bundles and cannot add the requisite&#13;
headers for caching and so on.</p>&#13;
&#13;
<p>One of the main problems with shipping too much JavaScript is that it&#13;
can slow down page load times. JavaScript files are typically larger&#13;
than other types of web assets, such as HTML and CSS, and require more&#13;
processing time to execute. This can lead to longer page load times,&#13;
especially on slower internet connections or older devices.</p>&#13;
&#13;
<p>For example, consider the following code snippet that loads a large&#13;
JavaScript file on page load:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>My Website<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">script</code> <code class="na">src</code><code class="o">=</code><code class="s">"https://example.com/large.js"</code><code class="p">&gt;&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="cm">&lt;!-- Page content goes here --&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In this example, the <em>large.js</em> file is loaded in the <code>&lt;head&gt;</code> of the&#13;
page, which means that it will be executed before any other content on&#13;
the page. This can lead to slower page load times, especially on slower&#13;
internet connections or older devices. A common solution to this problem&#13;
is to load JavaScript files asynchronously using the <code>async</code> attribute<a data-primary="async attribute, JavaScript" data-type="indexterm" id="id717"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>My Website<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">script</code> <code class="na">async</code> <code class="na">src</code><code class="o">=</code><code class="s">"https://example.com/large.js"</code><code class="p">&gt;&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="cm">&lt;!-- Page content goes here --&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In this example, the <em>large.js</em> file is loaded asynchronously using the&#13;
<code>async</code> attribute. This means that it will be downloaded in parallel with&#13;
other resources on the page, which can help improve page load times.</p>&#13;
&#13;
<p>Another problem with shipping too much JavaScript is that it can&#13;
increase data usage. JavaScript bundles are typically larger than other&#13;
types of web assets, which means that they require more data to be&#13;
transferred over the network. This can be a problem for users with&#13;
limited data plans or slow internet connections, as it can lead to&#13;
increased costs and slower page load times.</p>&#13;
&#13;
<p>To mitigate these issues, we can take several steps to reduce the amount&#13;
of JavaScript that is shipped to users. One approach is to use code&#13;
splitting to load only the JavaScript that is needed for a particular&#13;
page or feature. This can help reduce page load times and data usage by&#13;
only loading the necessary code.</p>&#13;
&#13;
<p>For example, consider the following code snippet that uses code&#13;
splitting to load only the JavaScript that is needed for a particular&#13;
page:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code><code class="p">(</code><code class="s2">"./large.js"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">module</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// Use module here</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>In this example, the <code>import</code> function is used to asynchronously load&#13;
the <em>large.js</em> file only when it is needed. This can help reduce page&#13;
load times and data usage by only loading the necessary code.</p>&#13;
&#13;
<p>Another approach is to use lazy loading to defer the loading of&#13;
noncritical JavaScript until after the page has loaded. This can help&#13;
reduce page load times and data usage by loading noncritical code only&#13;
when it is needed.</p>&#13;
&#13;
<p>For example, consider the following code snippet that uses lazy loading&#13;
to defer the loading of noncritical JavaScript:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>My Website<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="cm">&lt;!-- Page content goes here --&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">button</code> <code class="na">id</code><code class="o">=</code><code class="s">"load-more"</code><code class="p">&gt;</code>Load more content<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">script</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s2">"load-more"</code><code class="p">).</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">import</code><code class="p">(</code><code class="s2">"./non-critical.js"</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">module</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">          </code><code class="c1">// Use module here</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>In this example, the <code>import</code> function is used to asynchronously load&#13;
the <em>non-critical.js</em> file only when the “Load more content” button is&#13;
clicked. This can help reduce page load times and data usage by loading&#13;
noncritical code only when it is needed.</p>&#13;
&#13;
<p>Thankfully, React has a solution that makes this even more&#13;
straightforward: lazy loading<a data-primary="React.lazy" data-type="indexterm" id="id718"/> using <code>React.lazy</code> and <code>Suspense</code>. Let’s&#13;
take a look at how we can use these to improve our application’s&#13;
performance.</p>&#13;
&#13;
<p>Lazy loading is a technique that allows us to load a component only when&#13;
it’s needed, like with the dynamic import in the preceding example. This is useful for&#13;
large applications that have many components that are not needed on the&#13;
initial render. For example, if we have a large application with a&#13;
collapsible sidebar that has a list of links to other pages, we might&#13;
not want to load the full sidebar if it’s collapsed on first load.&#13;
Instead, we can load it only when the user toggles the sidebar.</p>&#13;
&#13;
<p>Let’s explore the following code sample:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">Sidebar</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"./Sidebar"</code><code class="p">;</code><code class="w"> </code><code class="c1">// 22MB to import</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">initialSidebarState</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">showSidebar</code><code class="p">,</code><code class="w"> </code><code class="nx">setShowSidebar</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="nx">initialSidebarState</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setShowSidebar</code><code class="p">(</code><code class="o">!</code><code class="nx">showSidebar</code><code class="p">)}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">Toggle</code><code class="w"> </code><code class="nx">sidebar</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">showSidebar</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">Sidebar</code> <code class="p">/&gt;}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, <code>&lt;Sidebar /&gt;</code> is 22 MB of JavaScript.&#13;
This is a lot of JavaScript to download, parse, and execute, and it’s&#13;
not necessary on the initial render if the sidebar is collapsed.&#13;
Instead, we can use <code>React.lazy</code> to lazy load the component only if&#13;
<code>showSidebar</code> is true. As in, only if we need it:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">lazy</code><code class="p">,</code><code class="w"> </code><code class="nx">Suspense</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">FakeSidebarShell</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"./FakeSidebarShell"</code><code class="p">;</code><code class="w"> </code><code class="c1">// 1kB to import</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">Sidebar</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">lazy</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="k">import</code><code class="p">(</code><code class="s2">"./Sidebar"</code><code class="p">));</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">initialSidebarState</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">showSidebar</code><code class="p">,</code><code class="w"> </code><code class="nx">setShowSidebar</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="nx">initialSidebarState</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setShowSidebar</code><code class="p">(</code><code class="o">!</code><code class="nx">showSidebar</code><code class="p">)}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">Toggle</code><code class="w"> </code><code class="nx">sidebar</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">Suspense</code> <code class="na">fallback</code><code class="o">=</code><code class="p">{&lt;</code><code class="nt">FakeSidebarShell</code> <code class="p">/&gt;}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">{</code><code class="nx">showSidebar</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">Sidebar</code> <code class="p">/&gt;}</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">Suspense</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Instead of <em>statically importing</em> <code>./Sidebar</code>, we <em>dynamically</em> import&#13;
it—that is, we pass a function to <code>lazy</code> that returns a promise that&#13;
resolves to the imported module. A dynamic import returns a promise&#13;
because the module may not be available immediately. It may need to be&#13;
downloaded from the server first. React’s <code>lazy</code> function, which triggers&#13;
the import, is never called unless the underlying component (in this&#13;
case, <code>Sidebar</code>) is to be rendered. This way, we avoid shipping the 22 MB&#13;
sidebar until we actually <em>render</em> <code>&lt;Sidebar /&gt;</code>.</p>&#13;
&#13;
<p>You may have also noticed another new import<a data-primary="Suspense" data-type="indexterm" id="ix_Suspense.05.1350.45"/><a data-primary="React Suspense" data-type="indexterm" id="ix_ReactSuspense.05.1350.45"/>: <code>Suspense</code>. We use&#13;
<code>Suspense</code> to wrap the component in the tree. <code>Suspense</code> is a component&#13;
that allows us to show a fallback component while the promise is&#13;
resolving (read: as the sidebar is downloading). In the snippet,&#13;
we’re showing a fallback component that is a lightweight version of the&#13;
heavy sidebar while the heavy sidebar is downloading. This is a great&#13;
way to provide immediate feedback to the user while the sidebar is&#13;
loading.</p>&#13;
&#13;
<p>Now, when the user clicks the button to toggle the sidebar, they’ll see&#13;
a “skeleton UI” that they can orient themselves around while the&#13;
sidebar is loaded and rendered.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Greater UI Control with Suspense" data-type="sect2"><div class="sect2" id="id68">&#13;
<h2>Greater UI Control with Suspense</h2>&#13;
&#13;
<p>React Suspense works like a try/catch block<a data-primary="try/catch block, and React Suspense" data-type="indexterm" id="id719"/>. You know how you can&#13;
<code>throw</code> an exception from literally anywhere in your code, and then&#13;
catch it with a <code>catch</code> block somewhere else—even in a different module?&#13;
Well, Suspense works in a similar (but not exactly the same) way. You&#13;
can place lazy-loaded and asynchronous primitives anywhere in your&#13;
component tree, and then catch them with a <code>Suspense</code> component anywhere&#13;
above it in the tree, even if your Suspense boundary is in a completely&#13;
different file.</p>&#13;
&#13;
<p>Knowing this, we have the power to choose where we want to show the&#13;
loading state for our 22 MB sidebar. For example, we can hide the entire&#13;
application while the sidebar is loading—which is a pretty bad idea&#13;
because we block our entire app’s information from the user just for a&#13;
sidebar—or we can show a loading state for the sidebar only. Let’s take&#13;
a look at how we can do the former (even though we shouldn’t) just to&#13;
understand <code>Suspense</code>’s capabilities:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">lazy</code><code class="p">,</code><code class="w"> </code><code class="nx">Suspense</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">Sidebar</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">lazy</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="k">import</code><code class="p">(</code><code class="s2">"./Sidebar"</code><code class="p">));</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">showSidebar</code><code class="p">,</code><code class="w"> </code><code class="nx">setShowSidebar</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">Suspense</code> <code class="na">fallback</code><code class="o">=</code><code class="p">{&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Loading</code><code class="p">...&lt;/</code><code class="nt">p</code><code class="p">&gt;}&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setShowSidebar</code><code class="p">(</code><code class="o">!</code><code class="nx">showSidebar</code><code class="p">)}&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">Toggle</code><code class="w"> </code><code class="nx">sidebar</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">{</code><code class="nx">showSidebar</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">Sidebar</code> <code class="p">/&gt;}</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">main</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Hello</code><code class="w"> </code><code class="nx">hello</code><code class="w"> </code><code class="nx">welcome</code><code class="p">,</code><code class="w"> </code><code class="k">this</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="nx">the</code><code class="w"> </code><code class="nx">app</code><code class="err">'</code><code class="nx">s</code><code class="w"> </code><code class="nx">main</code><code class="w"> </code><code class="nx">area</code><code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">main</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">Suspense</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>By wrapping the entire component in <code>Suspense</code>, we render the <code>fallback</code>&#13;
until all asynchronous children (promises) are resolved. This means that&#13;
the entire application is hidden until the sidebar is loaded. This can&#13;
be useful if we want to wait until everything’s ready to reveal the user&#13;
interface to the user, but in this case it might not be the best idea&#13;
because the user is left wondering what’s going on and can’t&#13;
interact with the application at all.</p>&#13;
&#13;
<p>This is why we should only use <code>Suspense</code> to wrap the components that&#13;
need to be lazy loaded, like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">lazy</code><code class="p">,</code><code class="w"> </code><code class="nx">Suspense</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">Sidebar</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">lazy</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="k">import</code><code class="p">(</code><code class="s2">"./Sidebar"</code><code class="p">));</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">showSidebar</code><code class="p">,</code><code class="w"> </code><code class="nx">setShowSidebar</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setShowSidebar</code><code class="p">(</code><code class="o">!</code><code class="nx">showSidebar</code><code class="p">)}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">Toggle</code><code class="w"> </code><code class="nx">sidebar</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">Suspense</code> <code class="na">fallback</code><code class="o">=</code><code class="p">{&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Loading</code><code class="p">...&lt;/</code><code class="nt">p</code><code class="p">&gt;}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">{</code><code class="nx">showSidebar</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">Sidebar</code> <code class="p">/&gt;}</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">Suspense</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">main</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Hello</code><code class="w"> </code><code class="nx">hello</code><code class="w"> </code><code class="nx">welcome</code><code class="p">,</code><code class="w"> </code><code class="k">this</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="nx">the</code><code class="w"> </code><code class="nx">app</code><code class="err">'</code><code class="nx">s</code><code class="w"> </code><code class="nx">main</code><code class="w"> </code><code class="nx">area</code><code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">main</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>The Suspense boundary is a very powerful primitive that can remedy&#13;
layout shift and make user interfaces more responsive and intuitive.&#13;
It’s a great tool to have in your arsenal. Moreover, if high-quality&#13;
skeleton UI is used in the <code>fallback</code>, we can further guide our users to&#13;
understand what’s going on and what to expect while our lazy-loaded&#13;
components load, thereby orienting them to the interface they’re about&#13;
to interact with before it’s ready. Taking advantage of all of this is a&#13;
great way to improve our applications’ performance and fluently get the&#13;
most out of React<a data-startref="ix_lazyloading.05.1161.20" data-type="indexterm" id="id720"/><a data-startref="ix_JavaScriptlazyloading.05.1161.20" data-type="indexterm" id="id721"/><a data-startref="ix_performancelazyloading.05.1161.20" data-type="indexterm" id="id722"/><a data-startref="ix_Suspense.05.1350.45" data-type="indexterm" id="id723"/><a data-startref="ix_ReactSuspense.05.1350.45" data-type="indexterm" id="id724"/>.</p>&#13;
&#13;
<p>Next, we’ll look at another interesting question that many React&#13;
developers ask: when should we use <code>useState</code> versus <code>useReducer</code>?</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="useState Versus useReducer" data-type="sect1"><div class="sect1" id="id69">&#13;
<h1>useState Versus useReducer</h1>&#13;
&#13;
<p>React exposes two hooks for managing state<a data-primary="useState hook" data-type="indexterm" id="ix_useStatehook.05.1458.43"/><a data-primary="state management" data-secondary="useState hook" data-type="indexterm" id="ix_statemanagementuseStatehook.05.1458.43"/>: <code>useState</code> and <code>useReducer</code>.&#13;
Both of these hooks are used to manage state in a component. The&#13;
difference between the two is that <code>useState</code> is a hook that is better&#13;
suited to manage a single piece of state, whereas <code>useReducer</code> is a hook&#13;
that manages more complex state. Let’s take a look at how we can use&#13;
<code>useState</code> to manage state in a component:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">)}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we’re using <code>useState</code> to manage a single piece of&#13;
state: <code>count</code>. But what if our state’s a little more complex?</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">setState</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">({</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">count</code><code class="o">:</code><code class="w"> </code><code class="mf">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">name</code><code class="o">:</code><code class="w"> </code><code class="s2">"Tejumma"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">age</code><code class="o">:</code><code class="w"> </code><code class="mf">30</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Name</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">name</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Age</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">age</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setState</code><code class="p">({</code><code class="w"> </code><code class="p">...</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">count</code><code class="o">:</code><code class="w"> </code><code class="nx">state</code><code class="p">.</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="w"> </code><code class="p">})}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">Increment</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now we can see that our state is a little more complex. We have a&#13;
<code>count</code>, a <code>name</code>, and an <code>age</code>. We can increment the <code>count</code> by&#13;
clicking the button, which sets the state to <em>a new object</em> that has the&#13;
same properties as the previous state, but with the <code>count</code> incremented&#13;
by <code>1</code>. This is a very common pattern in React. The problem with it is&#13;
that it can raise the possibility of bugs. For example, if we don’t&#13;
carefully spread the old state, we might accidentally overwrite some of&#13;
the state’s properties.</p>&#13;
&#13;
<p>Fun fact: <code>useState</code> uses <code>useReducer</code> internally. You can think of&#13;
<code>useState</code> as a higher-level abstraction of <code>useReducer</code>. In fact, you&#13;
can reimplement <code>useState</code> with <code>useReducer</code> if you wish!</p>&#13;
&#13;
<p>Seriously, you’d just do this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useReducer</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="nx">initialState</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">dispatch</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useReducer</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">(</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">newValue</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">newValue</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">initialState</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">[</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">dispatch</code><code class="p">];</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>Let’s look at the same example, but implemented with&#13;
<code>useReducer</code> instead:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useReducer</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">initialState</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">count</code><code class="o">:</code><code class="w"> </code><code class="mf">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">name</code><code class="o">:</code><code class="w"> </code><code class="s2">"Tejumma"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">age</code><code class="o">:</code><code class="w"> </code><code class="mf">30</code><code class="p">,</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">reducer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">action</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">switch</code><code class="w"> </code><code class="p">(</code><code class="nx">action</code><code class="p">.</code><code class="nx">type</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="s2">"increment"</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="p">...</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">count</code><code class="o">:</code><code class="w"> </code><code class="nx">state</code><code class="p">.</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="w"> </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">default</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">return</code><code class="w"> </code><code class="nx">state</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">dispatch</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useReducer</code><code class="p">(</code><code class="nx">reducer</code><code class="p">,</code><code class="w"> </code><code class="nx">initialState</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Name</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">name</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Age</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">age</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">dispatch</code><code class="p">({</code><code class="w"> </code><code class="nx">type</code><code class="o">:</code><code class="w"> </code><code class="s2">"increment"</code><code class="w"> </code><code class="p">})}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, some would say this is a tad more verbose than <code>useState</code>, and many&#13;
would agree, but this is to be expected whenever anyone goes a level&#13;
lower in an abstraction stack: the lower the abstraction, the more&#13;
verbose the code. After all, abstractions are intended to replace&#13;
complex logic with syntax sugar in most cases. So since we can do the&#13;
same thing with <code>useState</code> as we can with <code>useReducer</code>, why don’t we&#13;
just always use <code>useState</code> since it’s simpler?</p>&#13;
&#13;
<p>There are three large benefits to using <code>useReducer</code> to answer this&#13;
question:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It separates the logic of updating state from the component. Its&#13;
accompanying <code>reducer</code> function can be tested in isolation, and it can&#13;
be reused in other components. This is a great way to keep our&#13;
components clean and simple, and embrace<a data-primary="single responsibility principle" data-type="indexterm" id="id725"/> the <em>single responsibility&#13;
principle</em>.</p>&#13;
&#13;
<p>We can test the reducer like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">describe</code><code class="p">(</code><code class="s2">"reducer"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s2">"should increment count when given an increment action"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">initialState</code> <code class="o">=</code> <code class="p">{</code>&#13;
      <code class="nx">count</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
      <code class="nx">name</code><code class="o">:</code> <code class="s2">"Tejumma"</code><code class="p">,</code>&#13;
      <code class="nx">age</code><code class="o">:</code> <code class="mi">30</code><code class="p">,</code>&#13;
    <code class="p">};</code>&#13;
    <code class="kr">const</code> <code class="nx">action</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"increment"</code> <code class="p">};</code>&#13;
    <code class="kr">const</code> <code class="nx">expectedState</code> <code class="o">=</code> <code class="p">{</code>&#13;
      <code class="nx">count</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
      <code class="nx">name</code><code class="o">:</code> <code class="s2">"Tejumma"</code><code class="p">,</code>&#13;
      <code class="nx">age</code><code class="o">:</code> <code class="mi">30</code><code class="p">,</code>&#13;
    <code class="p">};</code>&#13;
    <code class="kr">const</code> <code class="nx">actualState</code> <code class="o">=</code> <code class="nx">reducer</code><code class="p">(</code><code class="nx">initialState</code><code class="p">,</code> <code class="nx">action</code><code class="p">);</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">actualState</code><code class="p">).</code><code class="nx">toEqual</code><code class="p">(</code><code class="nx">expectedState</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="nx">test</code><code class="p">(</code><code class="s2">"should return the same object when given an unknown action"</code><code class="p">,</code>&#13;
    <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">initialState</code> <code class="o">=</code> <code class="p">{</code>&#13;
      <code class="nx">count</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
      <code class="nx">name</code><code class="o">:</code> <code class="s2">"Tejumma"</code><code class="p">,</code>&#13;
      <code class="nx">age</code><code class="o">:</code> <code class="mi">30</code><code class="p">,</code>&#13;
    <code class="p">};</code>&#13;
    <code class="kr">const</code> <code class="nx">action</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"unknown"</code> <code class="p">};</code>&#13;
    <code class="kr">const</code> <code class="nx">expectedState</code> <code class="o">=</code> <code class="nx">initialState</code><code class="p">;</code>&#13;
    <code class="kr">const</code> <code class="nx">actualState</code> <code class="o">=</code> <code class="nx">reducer</code><code class="p">(</code><code class="nx">initialState</code><code class="p">,</code> <code class="nx">action</code><code class="p">);</code>&#13;
    <code class="nx">expect</code><code class="p">(</code><code class="nx">actualState</code><code class="p">).</code><code class="nx">toBe</code><code class="p">(</code><code class="nx">expectedState</code><code class="p">);</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>In this example, we’re testing two scenarios: one where the&#13;
increment action is dispatched to the reducer, and one where an unknown&#13;
action is dispatched.</p>&#13;
&#13;
<p>In the first test, we’re creating an initial state object with a count&#13;
value of <code>0</code>, and an increment action object. We’re then expecting the&#13;
count value in the resulting state object to be incremented to <code>1</code>. We use&#13;
the <code>toEqual</code> matcher to compare the expected and actual state objects.</p>&#13;
&#13;
<p>In the second test, we’re creating an initial state object with a count&#13;
value of <code>0</code>, and an unknown action object. We’re then expecting the&#13;
resulting state object to be the same as the initial state object. We&#13;
use the <code>toBe</code> matcher to compare the expected and actual state objects,&#13;
since we’re testing for reference equality.</p>&#13;
&#13;
<p>By testing our reducer in this way, we can ensure that it behaves&#13;
correctly and produces the expected output when given different input&#13;
scenarios.</p>&#13;
</li>&#13;
<li>&#13;
<p>Our state and the way it changes is always explicit with <code>useReducer</code>,&#13;
and some would argue that <code>useState</code> can obfuscate the overall state&#13;
update flow of a component through layers of JSX trees.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>useReducer</code> is an <em>event sourced</em> model<a data-primary="event-sourced model, useReducer as" data-type="indexterm" id="id726"/>, meaning it can be used to&#13;
model events that happen in our application, which we can then keep track&#13;
of in some type of audit log. This audit log can be used to replay&#13;
events in our application to reproduce bugs or to implement <em>time-travel&#13;
debugging</em>. It also enables some powerful patterns like undo/redo,&#13;
optimistic updates, and analytics tracking of common user actions across&#13;
our interface.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>While <code>useReducer</code> is a great tool to have in your arsenal, it’s not&#13;
always necessary. In fact, it’s often overkill for most use cases. So&#13;
when should we use <code>useState</code> versus <code>useReducer</code>? The answer is that it&#13;
depends on the complexity of your state. But hopefully with all of this&#13;
information, you can make a more informed decision about which one to&#13;
use in your application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Immer and Ergonomics" data-type="sect2"><div class="sect2" id="id70">&#13;
<h2>Immer and Ergonomics</h2>&#13;
&#13;
<p>Immer<a data-primary="use-immer library" data-type="indexterm" id="ix_useimmerlibrary.05.1664.6"/><a data-primary="React Immer" data-type="indexterm" id="ix_ReactImmer.05.1664.6"/><a data-primary="state management" data-secondary="Immer library for" data-type="indexterm" id="ix_statemanagementImmerlibraryfor.05.1664.6"/><a data-primary="Immer library" data-type="indexterm" id="ix_Immerlibrary.05.1664.6"/>, a popular React library, is particularly useful when dealing with&#13;
complex state management in your applications. When your state shape is&#13;
nested or complex, traditional state updating methods can become verbose&#13;
and error prone. Immer helps to manage such complexities by allowing you&#13;
to work with a mutable draft state while ensuring the produced state is&#13;
immutable.</p>&#13;
&#13;
<p>In a React application, state management is commonly handled using the&#13;
<code>useState</code> or <code>useReducer</code> hooks. While <code>useState</code> is suitable for&#13;
simple state, <code>useReducer</code> is more suited for complex state management,&#13;
and that’s where Immer shines the most.</p>&#13;
&#13;
<p>When working with <code>useReducer</code>, the reducer function you provide is&#13;
expected to be pure and always return a new state object. This can lead&#13;
to verbose code when dealing with nested state objects. However, by&#13;
integrating Immer with <code>useReducer</code> through <code>useImmerReducer</code> from the&#13;
use-immer library<a data-primary="useImmerReducer function" data-type="indexterm" id="ix_useImmerReducerfunction.05.1680.20"/>, you can write reducers that appear to mutate the&#13;
state directly, while actually operating on a draft state provided by&#13;
Immer. This way, you get to write simpler and more intuitive reducer&#13;
functions:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useImmerReducer</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"use-immer"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">initialState</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">user</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">name</code><code class="o">:</code><code class="w"> </code><code class="s2">"John Doe"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">age</code><code class="o">:</code><code class="w"> </code><code class="mf">28</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">address</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">city</code><code class="o">:</code><code class="w"> </code><code class="s2">"New York"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">country</code><code class="o">:</code><code class="w"> </code><code class="s2">"USA"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">reducer</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">draft</code><code class="p">,</code><code class="w"> </code><code class="nx">action</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">switch</code><code class="w"> </code><code class="p">(</code><code class="nx">action</code><code class="p">.</code><code class="nx">type</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="s2">"updateName"</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">draft</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">action</code><code class="p">.</code><code class="nx">payload</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">break</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">case</code><code class="w"> </code><code class="s2">"updateCity"</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">draft</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">address</code><code class="p">.</code><code class="nx">city</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">action</code><code class="p">.</code><code class="nx">payload</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">break</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// other cases...</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">default</code><code class="o">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">break</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">dispatch</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useImmerReducer</code><code class="p">(</code><code class="nx">reducer</code><code class="p">,</code><code class="w"> </code><code class="nx">initialState</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, <code>useImmerReducer</code> simplifies the reducer function&#13;
significantly, allowing direct assignments to update the nested state&#13;
properties, which would have required <code>spread</code> or <code>Object.assign</code> operations&#13;
in a traditional reducer.</p>&#13;
&#13;
<p>Furthermore, Immer is not just limited to <code>useReducer</code>. You can also use&#13;
it with <code>useState</code> whenever you have a complex state object and want to&#13;
ensure immutability when updating the state. Immer provides a <code>produce</code>&#13;
function that you can use to create your next state based on the current&#13;
state and a set of instructions:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">produce</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"immer"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">MyComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">state</code><code class="p">,</code><code class="w"> </code><code class="nx">setState</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="nx">initialState</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">updateName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">newName</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">setState</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">produce</code><code class="p">((</code><code class="nx">draft</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">draft</code><code class="p">.</code><code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">newName</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">})</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="c1">// ...</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In the <code>updateName</code> function, Immer’s <code>produce</code> function takes the&#13;
current <code>state</code> and a function that receives a <code>draft</code> of the state.&#13;
Inside this function, you can work with the draft as if it were mutable,&#13;
while Immer ensures that the produced state is a new immutable object<a data-startref="ix_useImmerReducerfunction.05.1680.20" data-type="indexterm" id="id727"/>.</p>&#13;
&#13;
<p>Immer’s ability to simplify state updates, especially in complex or&#13;
nested state structures, makes it a great companion to React’s state&#13;
management hooks, facilitating cleaner, more maintainable, and less&#13;
error-prone code<a data-startref="ix_useStatehook.05.1458.43" data-type="indexterm" id="id728"/><a data-startref="ix_statemanagementuseStatehook.05.1458.43" data-type="indexterm" id="id729"/><a data-startref="ix_useimmerlibrary.05.1664.6" data-type="indexterm" id="id730"/><a data-startref="ix_ReactImmer.05.1664.6" data-type="indexterm" id="id731"/><a data-startref="ix_statemanagementImmerlibraryfor.05.1664.6" data-type="indexterm" id="id732"/><a data-startref="ix_Immerlibrary.05.1664.6" data-type="indexterm" id="id733"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Powerful Patterns" data-type="sect1"><div class="sect1" id="id71">&#13;
<h1>Powerful Patterns</h1>&#13;
&#13;
<p>Software design patterns<a data-primary="software design patterns" data-type="indexterm" id="ix_softwaredesignpatterns.05.1765.25"/> are commonly used solutions to recurring&#13;
problems in software development. They provide a way to solve problems&#13;
that have been encountered and solved by other developers, saving time&#13;
and effort in the software development process. They are often expressed&#13;
as templates or guidelines for creating software that can be used in&#13;
different situations. Software design patterns are typically described&#13;
using a common vocabulary and notation, which makes them easier to&#13;
understand and communicate among developers. They can be used to improve&#13;
the quality, maintainability, and efficiency of software systems.</p>&#13;
&#13;
<p>Software design patterns are important for several reasons:</p>&#13;
<dl>&#13;
<dt>Reusability</dt>&#13;
<dd>&#13;
<p>Design patterns provide reusable solutions to common&#13;
problems, which can save time and effort in software development.</p>&#13;
</dd>&#13;
<dt>Standardization</dt>&#13;
<dd>&#13;
<p>Design patterns provide a standard way of solving&#13;
problems, which makes it easier for developers to understand and&#13;
communicate with each other.</p>&#13;
</dd>&#13;
<dt>Maintainability</dt>&#13;
<dd>&#13;
<p>Design patterns provide a way to structure code&#13;
that is easy to maintain and modify, which can improve the longevity of&#13;
software systems.</p>&#13;
</dd>&#13;
<dt>Efficiency</dt>&#13;
<dd>&#13;
<p>Design patterns provide efficient solutions to common&#13;
problems, which can improve the performance of software systems.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Usually, software design patterns naturally arrive over time in response&#13;
to real-world needs. These patterns solve specific problems that&#13;
engineers experience, and find their way into an “engineer’s arsenal”&#13;
of tools to use in different use cases. <em>One pattern is not inherently&#13;
worse than the other</em>; each has its place.</p>&#13;
&#13;
<p>Most patterns help us identify ideal levels of abstraction: how we can&#13;
write code that ages like fine wine instead of accruing extra state and&#13;
configuration to the point where it becomes unreadable and/or&#13;
unmaintainable. This is why a common consideration when picking a design&#13;
pattern is <em>control</em>: how much of it we give to users versus how much of it&#13;
our program handles.</p>&#13;
&#13;
<p>With that, let’s dive in to some popular React patterns, following a&#13;
rough chronological order of when these patterns emerged.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Presentational/Container Components" data-type="sect2"><div class="sect2" id="id72">&#13;
<h2>Presentational/Container Components</h2>&#13;
&#13;
<p>It’s common to see a React design pattern that is a combination<a data-primary="software design patterns" data-secondary="presentational/container components" data-type="indexterm" id="ix_softwaredesignpatternspresentationalcontainercomponents.05.1811.64"/><a data-primary="presentational/container components patterns" data-type="indexterm" id="ix_presentationalcontainercomponentspatterns.05.1811.64"/><a data-primary="container/presentational components patterns" data-type="indexterm" id="ix_containerpresentationalcomponentspatterns.05.1811.64"/> of two&#13;
components: a <em>presentational component</em> and a <em>container component</em>.&#13;
The presentational component renders the UI, and the&#13;
container component handles the state of the UI.&#13;
Consider a counter. This is how a counter would look when implementing this&#13;
pattern:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">PresentationalCounter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">props</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">section</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">increment</code><code class="p">}&gt;</code><code class="o">+</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">decrement</code><code class="p">}&gt;</code><code class="o">-</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">reset</code><code class="p">}&gt;</code><code class="nx">Reset</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">Current</code><code class="w"> </code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">props</code><code class="p">.</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">section</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ContainerCounter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">increment</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">decrement</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">reset</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setCount</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">PresentationalCounter</code>&#13;
      <code class="na">count</code><code class="o">=</code><code class="p">{</code><code class="nx">count</code><code class="p">}</code>&#13;
      <code class="na">increment</code><code class="o">=</code><code class="p">{</code><code class="nx">increment</code><code class="p">}</code>&#13;
      <code class="na">decrement</code><code class="o">=</code><code class="p">{</code><code class="nx">decrement</code><code class="p">}</code>&#13;
      <code class="na">reset</code><code class="o">=</code><code class="p">{</code><code class="nx">reset</code><code class="p">}</code>&#13;
    <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we have two components: <code>PresentationalCounter</code> (a presentational component) and <code>ContainerCounter</code> (a container component). The presentational component&#13;
renders the UI, and the container component handles the&#13;
state.</p>&#13;
&#13;
<p>Why is this a thing? This pattern is quite useful because of the&#13;
principle<a data-primary="single responsibility principle" data-type="indexterm" id="id734"/> of <em>single responsibility</em>, which highly encourages us to&#13;
separate concerns in our applications, enabling them to scale better by&#13;
being more modular, reusable, and even testable. Instead of having a&#13;
component be responsible for how it should look and how it should work,&#13;
we split these concerns. The result? <code>PresentationalCounter</code> can be&#13;
passed between other stateful containers and preserve the look we want,&#13;
while <code>ContainerCounter</code> can be replaced with another stateful container&#13;
and preserve the functionality we want.</p>&#13;
&#13;
<p>We can also unit test <code>ContainerCounter</code> in isolation, and instead&#13;
visually test (using Storybook or similar) <code>PresentationalCounter</code> in&#13;
isolation. We can also assign engineers or engineering teams more&#13;
comfortable with visual work to <code>PresentationalCounter</code>, while assigning&#13;
engineers who prefer data structures and algorithms to&#13;
<code>ContainerCounter</code>.</p>&#13;
&#13;
<p>We have so many more options because of this decoupled approach. For&#13;
these reasons, the container/presentational component pattern has gained&#13;
quite a lot of popularity and is still in use today. However, the&#13;
introduction of hooks allowed for far more convenience in adding&#13;
statefulness to components without needing a container component to&#13;
provide that state.</p>&#13;
&#13;
<p>Nowadays, in many cases the container/presentational pattern can be&#13;
replaced with hooks. Although we can still leverage this pattern, even&#13;
with React Hooks<a data-primary="React Hooks" data-type="indexterm" id="id735"/>, it can easily be considered overengineering in smaller&#13;
applications<a data-startref="ix_softwaredesignpatternspresentationalcontainercomponents.05.1811.64" data-type="indexterm" id="id736"/><a data-startref="ix_presentationalcontainercomponentspatterns.05.1811.64" data-type="indexterm" id="id737"/><a data-startref="ix_containerpresentationalcomponentspatterns.05.1811.64" data-type="indexterm" id="id738"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Higher-Order Component" data-type="sect2"><div class="sect2" id="id73">&#13;
<h2>Higher-Order Component</h2>&#13;
&#13;
<p>According to <a href="https://oreil.ly/Ywx56">Wikipedia’s definition of a higher-order function</a>:</p>&#13;
<blockquote>&#13;
<p>In mathematics and computer science, a higher-order function (HOF)<a data-primary="software design patterns" data-secondary="higher-order component (HOC)" data-type="indexterm" id="ix_softwaredesignpatternshigherordercomponentHOC.05.1888.67"/><a data-primary="higher-order component (HOC) pattern" data-type="indexterm" id="ix_higherordercomponentHOCpattern.05.1888.67"/> is a function that does at least one of the following: takes one or more functions as arguments (i.e., a procedural parameter, which is a&#13;
parameter of a procedure that is itself a procedure), returns a function&#13;
as its result.</p></blockquote>&#13;
&#13;
<p class="pagebreak-before">In the JSX world, a higher-order component (HOC) is basically this: a component that takes&#13;
another component as an argument and returns a new component that is the&#13;
result of the composition of the two. HOCs are great for <em>shared&#13;
behavior across components that we’d rather not repeat</em>.</p>&#13;
&#13;
<p>For example, many web applications need to request data from some data&#13;
source asynchronously. Loading and error states are often inevitable,&#13;
but we sometimes forget to account for them in our software. If we&#13;
manually add <code>loading</code>, <code>data</code>, and <code>error</code> props to our components, the&#13;
chances that we miss a few get even higher. Let’s consider a basic to do list&#13;
app:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">App</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="nx">setData</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">([]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="nx">useEffect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">fetch</code><code class="p">(</code><code class="s2">"https://mytodolist.com/items"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">setData</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">BasicTodoList</code> <code class="na">data</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">}</code> <code class="p">/&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>This app has a few problems. We don’t account for loading or error&#13;
states. Let’s fix this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">App</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">isLoading</code><code class="p">,</code><code class="w"> </code><code class="nx">setIsLoading</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="nx">setData</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">([]);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">error</code><code class="p">,</code><code class="w"> </code><code class="nx">setError</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">([]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="nx">useEffect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">fetch</code><code class="p">(</code><code class="s2">"https://mytodolist.com/items"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">data</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">setIsLoading</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">setData</code><code class="p">(</code><code class="nx">data</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">})</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">setError</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nx">isLoading</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="s2">"Loading..."</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="nx">error</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">BasicTodoList</code> <code class="na">data</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Yikes. This got pretty unruly, pretty fast. Moreover, <em>this solves the&#13;
problem for just one component</em>. Do we need to add these pieces of state&#13;
(i.e., loading, data, and error) to each component that interacts with a&#13;
foreign data source? This is a <em>cross-cutting concern</em>, and exactly&#13;
where HOCs shine.</p>&#13;
&#13;
<p>Instead of repeating this loading, error, and data pattern for each&#13;
component that talks to a foreign data source asynchronously, we can use&#13;
an HOC factory to deal with these states for us. Let’s&#13;
consider a <code>withAsync</code> HOC factory<a data-primary="withAsync HOC factory" data-type="indexterm" id="id739"/><a data-primary="asynchronous rendering" data-secondary="withAsync HOC factory" data-type="indexterm" id="ix_asynchronousrenderingwithAsyncHOCfactory.05.1961.35"/> that remedies&#13;
this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">TodoList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">withAsync</code><code class="p">(</code><code class="nx">BasicTodoList</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p><code>withAsync</code> will deal with loading and error states, and render any&#13;
component when data is available. Let’s look at its implementation:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">withAsync</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">Component</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="nx">props</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">props</code><code class="p">.</code><code class="nx">loading</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="s2">"Loading..."</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">props</code><code class="p">.</code><code class="nx">error</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">error</code><code class="p">.</code><code class="nx">message</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">Component</code>&#13;
      <code class="err">//</code> <code class="na">Pass</code> <code class="na">through</code> <code class="na">whatever</code> <code class="na">other</code> <code class="na">props</code> <code class="na">we</code> <code class="na">give</code> <code class="err">`</code><code class="na">Component</code><code class="err">`</code><code class="na">.</code>&#13;
      <code class="p">{</code><code class="na">...props</code><code class="p">}</code>&#13;
    <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>So now, when any <code>Component</code> is passed into <code>withAsync</code>, we get a new&#13;
component that renders appropriate pieces of information based on its&#13;
props. This changes our initial component into something more workable:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">TodoList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">withAsync</code><code class="p">(</code><code class="nx">BasicTodoList</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">App</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">isLoading</code><code class="p">,</code><code class="w"> </code><code class="nx">setIsLoading</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="kc">true</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="nx">setData</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">([]);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">error</code><code class="p">,</code><code class="w"> </code><code class="nx">setError</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">([]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="nx">useEffect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">fetch</code><code class="p">(</code><code class="s2">"https://mytodolist.com/items"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">res</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">data</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">setIsLoading</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">setData</code><code class="p">(</code><code class="nx">data</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">})</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">setError</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">TodoList</code> <code class="na">loading</code><code class="o">=</code><code class="p">{</code><code class="nx">isLoading</code><code class="p">}</code> <code class="na">error</code><code class="o">=</code><code class="p">{</code><code class="nx">error</code><code class="p">}</code> <code class="na">data</code><code class="o">=</code><code class="p">{</code><code class="nx">data</code><code class="p">}</code> <code class="p">/&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>No more nested ternaries, and the <code>TodoList</code> itself can show appropriate&#13;
information depending on whether it’s loading, has an error, or has&#13;
data. Since the <code>withAsync</code> HOC factory deals with this cross-cutting&#13;
concern, we can wrap any component that talks to an external data source&#13;
with it and get back a new component that responds to <code>loading</code> and&#13;
<code>error</code> props. Consider a blog:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">Post</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">withAsync</code><code class="p">(</code><code class="nx">BasicPost</code><code class="p">);</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">Comments</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">withAsync</code><code class="p">(</code><code class="nx">BasicComments</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">Blog</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">req</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">loading</code><code class="o">:</code><code class="w"> </code><code class="nx">isPostLoading</code><code class="p">,</code><code class="w"> </code><code class="nx">error</code><code class="o">:</code><code class="w"> </code><code class="nx">postLoadError</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">usePost</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">postId</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">loading</code><code class="o">:</code><code class="w"> </code><code class="nx">areCommentsLoading</code><code class="p">,</code><code class="w"> </code><code class="nx">error</code><code class="o">:</code><code class="w"> </code><code class="nx">commentLoadError</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useComments</code><code class="p">({</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">postId</code><code class="o">:</code><code class="w"> </code><code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">postId</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">Post</code>&#13;
        <code class="na">id</code><code class="o">=</code><code class="p">{</code><code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">postId</code><code class="p">}</code>&#13;
        <code class="na">loading</code><code class="o">=</code><code class="p">{</code><code class="nx">isPostLoading</code><code class="p">}</code>&#13;
        <code class="na">error</code><code class="o">=</code><code class="p">{</code><code class="nx">postLoadError</code><code class="p">}</code>&#13;
      <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">Comments</code>&#13;
        <code class="na">postId</code><code class="o">=</code><code class="p">{</code><code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">postId</code><code class="p">}</code>&#13;
        <code class="na">loading</code><code class="o">=</code><code class="p">{</code><code class="nx">areCommentsLoading</code><code class="p">}</code>&#13;
        <code class="na">error</code><code class="o">=</code><code class="p">{</code><code class="nx">commentLoadError</code><code class="p">}</code>&#13;
      <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="nx">Blog</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, both <code>Post</code> and <code>Comments</code> use the <code>withAsync</code> HOC&#13;
pattern, which returns a newer version of <code>BasicPost</code> and <code>BasicComments</code>, respectively, that now responds to <code>loading</code> and <code>error</code> props. The&#13;
behavior for this cross-cutting concern is centrally managed in&#13;
<code>withAsync</code>’s implementation, so we account for loading and error states&#13;
“for free” just by using the HOC pattern here<a data-startref="ix_asynchronousrenderingwithAsyncHOCfactory.05.1961.35" data-type="indexterm" id="id740"/>.</p>&#13;
&#13;
<p>However, similar to presentational and container components, HOCs are&#13;
often also discarded in favor of hooks, since hooks provide similar benefits&#13;
with added &#13;
<span class="keep-together">convenience.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Composing HOCs" data-type="sect3"><div class="sect3" id="id234">&#13;
<h3>Composing HOCs</h3>&#13;
&#13;
<p>Composing multiple HOCs together is a common&#13;
pattern in React, which allows developers to mix and match&#13;
functionalities and behaviors across components. Here’s an example of&#13;
how you might compose multiple HOCs:</p>&#13;
&#13;
<p>Suppose you have two HOCs, <code>withLogging</code> and <code>withUser</code>:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="c1">// withLogging.js</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">withLogging</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">WrappedComponent</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="nx">props</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Rendered with props:"</code><code class="p">,</code><code class="w"> </code><code class="nx">props</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">WrappedComponent</code> <code class="p">{</code><code class="na">...props</code><code class="p">}</code> <code class="p">/&gt;;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="c1">// withUser.js</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">withUser</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">WrappedComponent</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">user</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">name</code><code class="o">:</code><code class="w"> </code><code class="s2">"John Doe"</code><code class="w"> </code><code class="p">};</code><code class="w"> </code><code class="c1">// Assume this comes from some data source</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="nx">props</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">WrappedComponent</code> <code class="p">{</code><code class="na">...props</code><code class="p">}</code> <code class="na">user</code><code class="o">=</code><code class="p">{</code><code class="nx">user</code><code class="p">}</code> <code class="p">/&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, say you want to compose these two HOCs together. One way to do this&#13;
is to nest them:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">EnhancedComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">withLogging</code><code class="p">(</code><code class="nx">withUser</code><code class="p">(</code><code class="nx">MyComponent</code><code class="p">));</code><code class="w"/></pre>&#13;
&#13;
<p>However, nested HOC calls can be difficult to read and maintain,&#13;
especially as the number of HOCs increases. Imagine this in your&#13;
application over time:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">EnhancedComponent</code> <code class="o">=</code> <code class="nx">withErrorHandler</code><code class="p">(</code>&#13;
  <code class="nx">withLoadingSpinner</code><code class="p">(</code>&#13;
    <code class="nx">withAuthentication</code><code class="p">(</code>&#13;
      <code class="nx">withAuthorization</code><code class="p">(</code>&#13;
        <code class="nx">withPagination</code><code class="p">(</code>&#13;
          <code class="nx">withDataFetching</code><code class="p">(</code>&#13;
            <code class="nx">withLogging</code><code class="p">(</code><code class="nx">withUser</code><code class="p">(</code><code class="nx">withTheme</code><code class="p">(</code><code class="nx">withIntl</code><code class="p">(</code><code class="nx">withRouting</code><code class="p">(</code><code class="nx">MyComponent</code><code class="p">)))))</code>&#13;
          <code class="p">)</code>&#13;
        <code class="p">)</code>&#13;
      <code class="p">)</code>&#13;
    <code class="p">)</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Yuck! A better approach is to create a utility function that composes&#13;
multiple HOCs together into a single HOC. Such a utility function might&#13;
look like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="c1">// compose.js</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">compose</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">(...</code><code class="nx">hocs</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">(</code><code class="nx">WrappedComponent</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">hocs</code><code class="p">.</code><code class="nx">reduceRight</code><code class="p">((</code><code class="nx">acc</code><code class="p">,</code><code class="w"> </code><code class="nx">hoc</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">hoc</code><code class="p">(</code><code class="nx">acc</code><code class="p">),</code><code class="w"> </code><code class="nx">WrappedComponent</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="c1">// Usage:</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">EnhancedComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">compose</code><code class="p">(</code><code class="nx">withLogging</code><code class="p">,</code><code class="w"> </code><code class="nx">withUser</code><code class="p">)(</code><code class="nx">MyComponent</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>In this <code>compose</code> function, <code>reduceRight</code> is used to apply each HOC from&#13;
right to left to the <code>WrappedComponent</code>. This way, you can list your&#13;
HOCs in a flat list, which is easier to read and maintain. The <code>compose</code>&#13;
function is a common utility in functional programming, and libraries&#13;
like Redux provide their own <code>compose</code> utility function for this&#13;
purpose.</p>&#13;
&#13;
<p>To revisit our previous yucky example with our new <code>compose</code> utility,&#13;
it would look more like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">EnhancedComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">compose</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withErrorHandler</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withLoadingSpinner</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withAuthentication</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withAuthorization</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withPagination</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withDataFetching</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withLogging</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withUser</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withTheme</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withIntl</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">withRouting</code><code class="w"/>&#13;
<code class="p">)(</code><code class="nx">MyComponent</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Isn’t that better? Less indentation, more readability, and easier&#13;
maintenance. Each HOC in the chain wraps the component produced by the&#13;
previous HOC, adding its own behavior to the mix. This way, you can&#13;
build up complex components from simpler components and HOCs, each&#13;
focused on a single concern. This makes your code more modular, easier&#13;
to understand, and easier to test.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="HOCs versus hooks" data-type="sect3"><div class="sect3" id="id74">&#13;
<h3>HOCs versus hooks</h3>&#13;
&#13;
<p>Since the introduction of hooks<a data-primary="hooks" data-type="indexterm" id="ix_hooks.05.2175.32"/>, HOCs have become less popular. Hooks&#13;
provide a more convenient way to add functionality to components, and&#13;
they also solve some of the problems that HOCs have. For example, HOCs&#13;
can cause issues with ref forwarding, and they can also cause&#13;
unnecessary rerenders when used incorrectly. <a data-type="xref" href="#table5-1">Table 5-1</a> shows a little bit of a detailed comparison between the two.</p>&#13;
<table id="table5-1">&#13;
<caption><span class="label">Table 5-1. </span>Comparison of HOCs versus hooks</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Feature</th>&#13;
<th>HOCs</th>&#13;
<th>Hooks</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Code reuse</strong></p></td>&#13;
<td><p>Excellent for sharing logic across multiple components.</p></td>&#13;
<td><p>Ideal for extracting and sharing logic within a component or across&#13;
similar components.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Rendering logic</strong></p></td>&#13;
<td><p>Can control rendering of wrapped component.</p></td>&#13;
<td><p>Do not&#13;
affect rendering directly, but can be used within functional components&#13;
to manage side effects related to rendering.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Prop manipulation</strong></p></td>&#13;
<td><p>Can inject and manipulate props, providing&#13;
additional data or functions.</p></td>&#13;
<td><p>Cannot inject or manipulate props&#13;
directly.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>State management</strong></p></td>&#13;
<td><p>Can manage and manipulate state outside of the&#13;
wrapped component.</p></td>&#13;
<td><p>Designed to manage local state within functional&#13;
components.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Lifecycle methods</strong></p></td>&#13;
<td><p>Can encapsulate lifecycle logic related to the&#13;
wrapped component.</p></td>&#13;
<td><p><code>useEffect</code> and other hooks can handle lifecycle&#13;
events within functional components.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Ease of composition</strong></p></td>&#13;
<td><p>Can be composed together, but may result in&#13;
“wrapper hell” if not managed well.</p></td>&#13;
<td><p>Easily composable and can be used&#13;
alongside other hooks without adding layers of components.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Ease of testing</strong></p></td>&#13;
<td><p>Testing can be more complex due to additional&#13;
wrapper components.</p></td>&#13;
<td><p>Generally easier to test as they can be isolated&#13;
easier than HOCs.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Type safety</strong></p></td>&#13;
<td><p>With TypeScript, can be tricky to type correctly,&#13;
especially with deeply nested HOCs.</p></td>&#13;
<td><p>Better type inference and easier to&#13;
type with TypeScript.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p><a data-type="xref" href="#table5-1">Table 5-1</a> provides a side-by-side comparison of HOCs and hooks, showcasing their respective strengths and&#13;
use cases. While HOCs are still a useful pattern, hooks are generally&#13;
preferred for most use cases due to their simplicity and ease of use.</p>&#13;
&#13;
<p>From this table, we can observe that HOCs and hooks are pivotal in React for sharing logic across&#13;
components, yet they cater to slightly different use cases. HOCs excel&#13;
in sharing logic across multiple components and are particularly adept&#13;
at controlling the rendering of the wrapped component and manipulating&#13;
props, providing additional data or functions to components. They can&#13;
manage state outside of the wrapped component and encapsulate lifecycle&#13;
logic related to the wrapped component. However, they can lead to a&#13;
“wrapper hell” if not managed well, especially when many HOCs are&#13;
nested together. This nesting can also make testing<a data-primary="testing of code" data-secondary="nesting complexity and HOCs" data-type="indexterm" id="id741"/> more complex, and&#13;
type safety with TypeScript can become tricky, especially with deeply&#13;
nested HOCs.</p>&#13;
&#13;
<p>On the other hand, hooks are ideal for extracting and sharing logic&#13;
within a component or across similar components without adding extra&#13;
layers of components, thus avoiding the “wrapper hell” scenario.&#13;
Unlike HOCs, hooks do not affect rendering directly and cannot inject or&#13;
manipulate props directly. They are designed to manage local state&#13;
within functional components and handle lifecycle events using the&#13;
<code>useEffect</code> Hook, among others. Hooks promote ease of composition, and&#13;
are generally easier to test as they can be isolated easier than HOCs.&#13;
Moreover, when used with TypeScript, hooks provide better type inference&#13;
and are easier to type, thus potentially reducing bugs related to type&#13;
errors.</p>&#13;
&#13;
<p>While both HOCs and hooks provide mechanisms to reuse logic, hooks offer&#13;
a more direct and less complicated approach to managing state, lifecycle&#13;
events, and other React features within functional components. On the&#13;
flip side, HOCs provide a more structured way to inject behavior into&#13;
components, which can be beneficial in larger codebases or in codebases&#13;
that have not yet adopted hooks. Each has its own set of advantages, and&#13;
the choice between using HOCs or hooks would largely depend on the&#13;
specific requirements of your project and the team’s familiarity with&#13;
these &#13;
<span class="keep-together">patterns.</span></p>&#13;
&#13;
<p>Can we think of any React HOCs that we use fairly frequently? Yes, we&#13;
can! <code>React.memo</code> is one that we just covered in this chapter and is&#13;
indeed an HOC! Let’s look at another one:&#13;
<code>React.forwardRef</code>. This<a data-primary="React.forwardRef" data-type="indexterm" id="id742"/> is an HOC that forwards a ref&#13;
to a child component. Let’s look at an example:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">FancyInput</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">forwardRef</code><code class="p">((</code><code class="nx">props</code><code class="p">,</code><code class="w"> </code><code class="nx">ref</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">input</code> <code class="na">type</code><code class="o">=</code><code class="s">"text"</code> <code class="na">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">ref</code><code class="p">}</code> <code class="p">{</code><code class="na">...props</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="p">));</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">App</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">inputRef</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useRef</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="nx">useEffect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">inputRef</code><code class="p">.</code><code class="nx">current</code><code class="p">.</code><code class="nx">focus</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">FancyInput</code> <code class="na">ref</code><code class="o">=</code><code class="p">{</code><code class="nx">inputRef</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we’re using <code>React.forwardRef</code> to forward a ref to the&#13;
<code>FancyInput</code> component. This allows us to access the input element’s&#13;
<code>focus</code> method in the parent component. This is a common pattern in&#13;
React, and it’s a great example of how HOCs can be&#13;
used to solve problems that are difficult to solve with regular&#13;
components<a data-startref="ix_softwaredesignpatternshigherordercomponentHOC.05.1888.67" data-type="indexterm" id="id743"/><a data-startref="ix_higherordercomponentHOCpattern.05.1888.67" data-type="indexterm" id="id744"/><a data-startref="ix_hooks.05.2175.32" data-type="indexterm" id="id745"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Render Props" data-type="sect2"><div class="sect2" id="id75">&#13;
<h2>Render Props</h2>&#13;
&#13;
<p>Since we’ve already talked about JSX expressions, a common pattern is to&#13;
have props<a data-primary="software design patterns" data-secondary="render props" data-type="indexterm" id="ix_softwaredesignpatternsrenderprops.05.2294.11"/><a data-primary="render props pattern" data-type="indexterm" id="ix_renderpropspattern.05.2294.11"/> that are functions that receive component-scoped state as&#13;
arguments to facilitate code reuse. Here’s a simple example:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">WindowSize</code>&#13;
  <code class="na">render</code><code class="o">=</code><code class="p">{({</code><code class="w"> </code><code class="nx">width</code><code class="p">,</code><code class="w"> </code><code class="nx">height</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">Your</code><code class="w"> </code><code class="nb">window</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="p">{</code><code class="nx">width</code><code class="p">}</code><code class="nx">x</code><code class="p">{</code><code class="nx">height</code><code class="p">}</code><code class="nx">px</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">)}</code>&#13;
<code class="p">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Notice how there’s a prop called <code>render</code> that receives a function as a&#13;
value. This prop even outputs some JSX markup that’s actually rendered.&#13;
But why? Turns out <code>WindowSize</code> does some magic internally to compute&#13;
the size of a user’s window, and then calls <code>props.render</code> to return the&#13;
structure we declare, making use of enclosing state to render the window&#13;
size.</p>&#13;
&#13;
<p>Let’s take a look at <code>WindowSize</code> to understand this a bit more:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">WindowSize</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">props</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">size</code><code class="p">,</code><code class="w"> </code><code class="nx">setSize</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">({</code><code class="w"> </code><code class="nx">width</code><code class="o">:</code><code class="w"> </code><code class="o">-</code><code class="mf">1</code><code class="p">,</code><code class="w"> </code><code class="nx">height</code><code class="o">:</code><code class="w"> </code><code class="o">-</code><code class="mf">1</code><code class="w"> </code><code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="nx">useEffect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">handleResize</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">setSize</code><code class="p">({</code><code class="w"> </code><code class="nx">width</code><code class="o">:</code><code class="w"> </code><code class="nb">window</code><code class="p">.</code><code class="nx">innerWidth</code><code class="p">,</code><code class="w"> </code><code class="nx">height</code><code class="o">:</code><code class="w"> </code><code class="nb">window</code><code class="p">.</code><code class="nx">innerHeight</code><code class="w"> </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">    </code><code class="nb">window</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"resize"</code><code class="p">,</code><code class="w"> </code><code class="nx">handleResize</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nb">window</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s2">"resize"</code><code class="p">,</code><code class="w"> </code><code class="nx">handleResize</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="nx">props</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="nx">size</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>From this example, we can see that <code>WindowSize</code> uses an event&#13;
listener to store some stuff in state on every resize, but the component&#13;
itself is headless: it has no opinions about what UI to present.&#13;
Instead, it yields control to whatever parent is rendering it and calls&#13;
the <em>render prop</em> it’s supplied, effectively inverting control to its&#13;
parent for the rendering job.</p>&#13;
&#13;
<p>This helps a component that depends on the window size for rendering&#13;
receive this information without <a data-primary="useEffect hook" data-type="indexterm" id="id746"/>duplicating the <code>useEffect</code> blocks and&#13;
keeps our code a little bit more DRY (Don’t Repeat Yourself). This&#13;
pattern is no longer as popular and has since been effectively replaced&#13;
with <a data-primary="React Hooks" data-type="indexterm" id="id747"/>React Hooks.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Children as a function" data-type="sect3"><div class="sect3" id="id76">&#13;
<h3>Children as a function</h3>&#13;
&#13;
<p>Since <code>children</code> is a prop, some have preferred to drop the <code>render</code>&#13;
prop name altogether and instead just use <code>children</code>. This would change&#13;
the use of <code>WindowSize</code> to look like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">WindowSize</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">{({</code><code class="w"> </code><code class="nx">width</code><code class="p">,</code><code class="w"> </code><code class="nx">height</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">Your</code><code class="w"> </code><code class="nb">window</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="p">{</code><code class="nx">width</code><code class="p">}</code><code class="nx">x</code><code class="p">{</code><code class="nx">height</code><code class="p">}</code><code class="nx">px</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">)}</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">WindowSize</code><code class="p">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Some React authors prefer this because it’s truer to the intent of the&#13;
code: <code>WindowSize</code> in this case looks a bit like a React Context, and&#13;
whatever we display tends to feel like children that consume this&#13;
context. Still, React Hooks eliminate the need for this pattern&#13;
altogether, so maybe proceed with caution<a data-startref="ix_softwaredesignpatternsrenderprops.05.2294.11" data-type="indexterm" id="id748"/><a data-startref="ix_renderpropspattern.05.2294.11" data-type="indexterm" id="id749"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Control Props" data-type="sect2"><div class="sect2" id="id77">&#13;
<h2>Control Props</h2>&#13;
&#13;
<p>The Control Props<a data-primary="software design patterns" data-secondary="Control Props" data-type="indexterm" id="ix_softwaredesignpatternscontrolprops.05.2372.18"/><a data-primary="Control Props pattern" data-type="indexterm" id="ix_controlpropspattern.05.2372.18"/><a data-primary="state management" data-secondary="Control Props pattern" data-type="indexterm" id="ix_statemanagementcontrolpropspattern.05.2372.18"/> pattern in React is a strategic approach to state&#13;
management that expands upon the concept of controlled components. It&#13;
provides a flexible mechanism for determining how state is managed&#13;
within a component. To understand this, let’s first understand&#13;
controlled components.</p>&#13;
&#13;
<p>Controlled components<a data-primary="controlled components" data-type="indexterm" id="id750"/> are components that do not maintain their own&#13;
internal state. Instead, they receive their current value as a prop from&#13;
a parent component, which is the single source of truth for their state.&#13;
When the state should change, controlled components notify the parent&#13;
using callback functions, typically <code>onChange</code>. The parent is thus&#13;
responsible for managing the state and updating the value of the&#13;
controlled component.</p>&#13;
&#13;
<p>For example, a controlled <code>&lt;input&gt;</code> element looks like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">Form</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">inputValue</code><code class="p">,</code><code class="w"> </code><code class="nx">setInputValue</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">function</code><code class="w"> </code><code class="nx">handleChange</code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">setInputValue</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">input</code> <code class="na">type</code><code class="o">=</code><code class="s">"text"</code> <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">inputValue</code><code class="p">}</code> <code class="na">onChange</code><code class="o">=</code><code class="p">{</code><code class="nx">handleChange</code><code class="p">}</code> <code class="p">/&gt;;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>The Control Props pattern takes the principle of controlled components&#13;
further by allowing a component to either be controlled externally by&#13;
props or manage its own state internally, providing optional external&#13;
control. A component following the Control Props pattern accepts both&#13;
the state value and a function to update that state as props. This dual&#13;
capability enables the parent to exert control over the child&#13;
component’s state if it chooses to do so, but it also allows the child&#13;
component to operate independently if not controlled.</p>&#13;
&#13;
<p>An example of the Control Props pattern is a toggle button that can&#13;
either be controlled by its parent or manage its own state:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">Toggle</code><code class="p">({</code><code class="w"> </code><code class="nx">on</code><code class="p">,</code><code class="w"> </code><code class="nx">onToggle</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">isOn</code><code class="p">,</code><code class="w"> </code><code class="nx">setIsOn</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">useState</code><code class="p">(</code><code class="kc">false</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">handleToggle</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">nextState</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">on</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="kc">undefined</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="o">!</code><code class="nx">isOn</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="nx">on</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">on</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="kc">undefined</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">setIsOn</code><code class="p">(</code><code class="nx">nextState</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">onToggle</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">onToggle</code><code class="p">(</code><code class="nx">nextState</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">handleToggle</code><code class="p">}&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">on</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="kc">undefined</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="nx">on</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="nx">isOn</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="s2">"On"</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="s2">"Off"</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In the <code>Toggle</code> component, <code>isOn</code> represents the internal state, while&#13;
<code>on</code> is the external control prop. The component can operate in a&#13;
controlled mode if the <code>on</code> prop is provided by the parent. If not, it&#13;
falls back to its internal state, <code>isOn</code>. The <code>onToggle</code> prop is a&#13;
callback that allows the parent component to respond to state changes,&#13;
providing the parent with the opportunity to synchronize its own state&#13;
with the state of the &#13;
<span class="keep-together"><code>Toggle</code>.</span></p>&#13;
&#13;
<p>This pattern enhances component flexibility, offering both controlled&#13;
and uncontrolled modes of operation. It allows the parent to be in&#13;
charge when necessary, while also letting the component retain autonomy&#13;
over its own state when not explicitly controlled<a data-startref="ix_softwaredesignpatternscontrolprops.05.2372.18" data-type="indexterm" id="id751"/><a data-startref="ix_controlpropspattern.05.2372.18" data-type="indexterm" id="id752"/><a data-startref="ix_statemanagementcontrolpropspattern.05.2372.18" data-type="indexterm" id="id753"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Prop Collections" data-type="sect2"><div class="sect2" id="id78">&#13;
<h2>Prop Collections</h2>&#13;
&#13;
<p>We often need to bundle a whole bunch of props<a data-primary="software design patterns" data-secondary="prop collections" data-type="indexterm" id="ix_softwaredesignpatternspropcollections.05.2451.47"/><a data-primary="prop collections pattern" data-type="indexterm" id="ix_propcollectionspattern.05.2451.47"/> together. For example,&#13;
when creating drag-and-drop user interfaces<a data-primary="drag-and-drop user interfaces, and prop collections" data-type="indexterm" id="ix_draganddropuserinterfacesandpropcollections.05.2452.44"/>, there are quite a few props&#13;
to manage:</p>&#13;
<dl>&#13;
<dt><code>onDragStart</code></dt>&#13;
<dd>&#13;
<p>To tell the browser what to do when a user starts&#13;
dragging an &#13;
<span class="keep-together">element</span></p>&#13;
</dd>&#13;
<dt><code>onDragOver</code></dt>&#13;
<dd>&#13;
<p>To identify a dropzone</p>&#13;
</dd>&#13;
<dt><code>onDrop</code></dt>&#13;
<dd>&#13;
<p>To execute some code when an element is dropped on this&#13;
element</p>&#13;
</dd>&#13;
<dt><code>onDragEnd</code></dt>&#13;
<dd>&#13;
<p>To tell the browser what to do when an element is done&#13;
being dragged</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Moreover, data/elements cannot be dropped in other elements by default.&#13;
To allow an element to be dropped on another, we must prevent the&#13;
default handling of the element. This is done by calling the&#13;
<code>event.preventDefault</code> method for the <code>onDragOver</code> event for a possible&#13;
dropzone.</p>&#13;
&#13;
<p>Since these props usually go together, and since <code>onDragOver</code> usually&#13;
defaults to <code>event =&gt; { event.preventDefault(); moreStuff(); }</code>, we can&#13;
collect these props together and reuse them in various components, like&#13;
so:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">export</code><code class="w"> </code><code class="kd">const</code><code class="w"> </code><code class="nx">droppableProps</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">onDragOver</code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">event</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">onDrop</code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="kd">const</code><code class="w"> </code><code class="nx">draggableProps</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">onDragStart</code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">onDragEnd</code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, if we have a React component we expect to behave like a dropzone,&#13;
we can use the prop collection on it, like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Dropzone</code> <code class="p">{</code><code class="na">...droppableProps</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This is the prop collection pattern, and it makes a number of props&#13;
reusable. This is often quite widely used in the accessibility space to&#13;
include a number of <code>aria-*</code> props on accessible components. One problem&#13;
that’s still present though is that if we write a custom <code>onDragOver</code>&#13;
prop and override the collection, we lose the <code>event.prevent​De⁠fault</code>&#13;
call that we get out of the box using the collection.</p>&#13;
&#13;
<p>This can cause unexpected behavior, removing the ability to drop a&#13;
component on <code>Dropzone</code>:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Dropzone</code>&#13;
  <code class="p">{</code><code class="na">...droppableProps</code><code class="p">}</code>&#13;
  <code class="na">onDragOver</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">alert</code><code class="p">(</code><code class="s2">"Dragged!"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}}</code>&#13;
<code class="p">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Thankfully, we can fix this using prop getters.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Prop getters" data-type="sect3"><div class="sect3" id="id79">&#13;
<h3>Prop getters</h3>&#13;
&#13;
<p>Prop getters<a data-primary="prop getters" data-type="indexterm" id="id754"/> essentially compose prop collections with custom props and&#13;
merge them. From our example, we’d like to preserve the&#13;
<code>event.preventDefault</code> call in the <code>droppableProps</code> collection’s&#13;
<code>onDragOver</code> handler, while also adding a custom <code>alert("Dragged!");</code>&#13;
call to it. We can do this using prop getters.</p>&#13;
&#13;
<p>First, we’ll change the <code>droppableProps</code> collection to a prop getter:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">export</code><code class="w"> </code><code class="kd">const</code><code class="w"> </code><code class="nx">getDroppableProps</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">onDragOver</code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">event</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">onDrop</code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">At this point, nothing has changed besides where we once exported a prop&#13;
collection, we now export a function that returns a prop collection.&#13;
This is a prop getter. Since this is a function, it can receive&#13;
arguments—like a custom <code>onDragOver</code>. We can compose this custom&#13;
<code>onDragOver</code> with our default one, like so:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">compose</code><code class="w"> </code><code class="o">=</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">(...</code><code class="nx">functions</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">functions</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">fn</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">fn</code><code class="o">?</code><code class="p">.(...</code><code class="nx">args</code><code class="p">));</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="kd">const</code><code class="w"> </code><code class="nx">getDroppableProps</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">onDragOver</code><code class="o">:</code><code class="w"> </code><code class="nx">replacementOnDragOver</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">...</code><code class="nx">replacementProps</code><code class="w"/>&#13;
<code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">defaultOnDragOver</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">event</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">onDragOver</code><code class="o">:</code><code class="w"> </code><code class="nx">compose</code><code class="p">(</code><code class="nx">replacementOnDragOver</code><code class="p">,</code><code class="w"> </code><code class="nx">defaultOnDragOver</code><code class="p">),</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">onDrop</code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">...</code><code class="nx">replacementProps</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, we can use the prop getter like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Dropzone</code>&#13;
  <code class="p">{</code><code class="na">...getDroppableProps</code><code class="err">(</code><code class="p">{</code>&#13;
    <code class="na">onDragOver</code><code class="err">:</code> <code class="err">()</code> <code class="err">=</code><code class="p">&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">alert</code><code class="p">(</code><code class="s2">"Dragged!"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">})}</code><code class="w"/>&#13;
<code class="err">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This custom <code>onDragOver</code> will compose into our default <code>onDragOver</code>, and&#13;
both things will happen: <code>event.preventDefault()</code> and&#13;
<code>alert("Dragged!")</code>. This is the prop getter pattern<a data-startref="ix_softwaredesignpatternspropcollections.05.2451.47" data-type="indexterm" id="id755"/><a data-startref="ix_propcollectionspattern.05.2451.47" data-type="indexterm" id="id756"/><a data-startref="ix_draganddropuserinterfacesandpropcollections.05.2452.44" data-type="indexterm" id="id757"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Compound Components" data-type="sect2"><div class="sect2" id="id80">&#13;
<h2>Compound Components</h2>&#13;
&#13;
<p>Sometimes, we have accordion components<a data-primary="software design patterns" data-secondary="compound components" data-type="indexterm" id="ix_softwaredesignpatternscompoundcomponents.05.2593.40"/><a data-primary="compound components pattern" data-type="indexterm" id="ix_compoundcomponentspattern.05.2593.40"/><a data-primary="accordion components" data-type="indexterm" id="ix_accordioncomponents.05.2593.40"/> like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Accordion</code>&#13;
  <code class="na">items</code><code class="o">=</code><code class="p">{[</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"One"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://one.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"Two"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://two.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"Three"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://three.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">]}</code>&#13;
<code class="p">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This component is intended to render a list similar to this, except&#13;
<em>only one item</em> can be open at a given time:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>One</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Two</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Three</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The inner workings of this component would look something like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">export</code><code class="w"> </code><code class="kd">const</code><code class="w"> </code><code class="nx">Accordion</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">items</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">activeItemIndex</code><code class="p">,</code><code class="w"> </code><code class="nx">setActiveItemIndex</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code><code class="w"> </code><code class="nx">index</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setActiveItemIndex</code><code class="p">(</code><code class="nx">index</code><code class="p">)}</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">}&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">strong</code><code class="p">&gt;{</code><code class="nx">item</code><code class="p">.</code><code class="nx">label</code><code class="p">}&lt;/</code><code class="nt">strong</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">{</code><code class="nx">index</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">activeItemIndex</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">i</code><code class="p">.</code><code class="nx">content</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>But what if we wanted a custom separator between items <code>Two</code> and&#13;
<code>Three</code>? What if we wanted the third link to be red or something? We’d&#13;
probably resort to some type of hack like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Accordion</code>&#13;
  <code class="na">items</code><code class="o">=</code><code class="p">{[</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"One"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://one.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"Two"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://two.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"---"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"Three"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://three.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">]}</code>&#13;
<code class="p">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>But that wouldn’t look the way we want. So we’d probably do more hacks&#13;
on our current hack:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">export</code><code class="w"> </code><code class="kd">const</code><code class="w"> </code><code class="nx">Accordion</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">items</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">activeItemIndex</code><code class="p">,</code><code class="w"> </code><code class="nx">setActiveItemIndex</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code><code class="w"> </code><code class="nx">index</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">item</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="s2">"---"</code><code class="w"> </code><code class="o">?</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">hr</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">)</code><code class="w"> </code><code class="o">:</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setActiveItemIndex</code><code class="p">(</code><code class="nx">index</code><code class="p">)}</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">}&gt;</code><code class="w"/>&#13;
<code class="w">            </code><code class="p">&lt;</code><code class="nt">strong</code><code class="p">&gt;{</code><code class="nx">item</code><code class="p">.</code><code class="nx">label</code><code class="p">}&lt;/</code><code class="nt">strong</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">            </code><code class="p">{</code><code class="nx">index</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">activeItemIndex</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">i</code><code class="p">.</code><code class="nx">content</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">)}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now is that code we’d be proud of? I’m not sure. This is why we need&#13;
<em>compound components</em>: they allow us to have a grouping of&#13;
interconnected, distinct components that share state, but are atomically&#13;
renderable, giving us more control of the element tree.</p>&#13;
&#13;
<p>This accordion, expressed using the compound components pattern, would&#13;
look like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Accordion</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">item</code><code class="o">=</code><code class="p">{{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"One"</code><code class="w"> </code><code class="p">}}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">item</code><code class="o">=</code><code class="p">{{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"Two"</code><code class="w"> </code><code class="p">}}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">item</code><code class="o">=</code><code class="p">{{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"Three"</code><code class="w"> </code><code class="p">}}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">Accordion</code><code class="p">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>If we decide to explore how this pattern can be implemented in React, we&#13;
might consider two ways:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>With <code>React.cloneElement</code> on the children</p>&#13;
</li>&#13;
<li>&#13;
<p>With React Context</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><code>React.cloneElement</code> is considered<a data-primary="React.cloneElement function (legacy)" data-type="indexterm" id="id758"/><a data-primary="React Context" data-type="indexterm" id="ix_ReactContext.05.2697.35"/><a data-primary="context updates" data-type="indexterm" id="ix_contextupdates.05.2697.35"/><a data-primary="updates" data-secondary="context" data-type="indexterm" id="ix_updatescontext.05.2697.35"/> a legacy API, so let’s pursue doing&#13;
this with React Context. First, we’ll start with a context that each part of&#13;
the accordion can read from:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">AccordionContext</code> <code class="o">=</code> <code class="nx">createContext</code><code class="p">({</code>&#13;
  <code class="nx">activeItemIndex</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>&#13;
  <code class="nx">setActiveItemIndex</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">0</code><code class="p">,</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Then, our <code>Accordion</code> component will just provide context to its&#13;
children:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">export</code><code class="w"> </code><code class="kd">const</code><code class="w"> </code><code class="nx">Accordion</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">items</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">activeItemIndex</code><code class="p">,</code><code class="w"> </code><code class="nx">setActiveItemIndex</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">AccordionContext</code><code class="p">.</code><code class="na">Provider</code> <code class="na">value</code><code class="o">=</code><code class="p">{{</code><code class="w"> </code><code class="nx">activeItemIndex</code><code class="p">,</code><code class="w"> </code><code class="nx">setActiveItemIndex</code><code class="w"> </code><code class="p">}}&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;{</code><code class="nx">children</code><code class="p">}&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">AccordionContext</code><code class="p">.</code><code class="na">Provider</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, let’s create discrete <code>AccordionItem</code> components that consume and&#13;
respond to this context as well:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">export</code><code class="w"> </code><code class="kd">const</code><code class="w"> </code><code class="nx">AccordionItem</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">item</code><code class="p">,</code><code class="w"> </code><code class="nx">index</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// Note we're using the context here, not state!</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">activeItemIndex</code><code class="p">,</code><code class="w"> </code><code class="nx">setActiveItemIndex</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useContext</code><code class="p">(</code><code class="nx">AccordionContext</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setActiveItemIndex</code><code class="p">(</code><code class="nx">index</code><code class="p">)}</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">}&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">strong</code><code class="p">&gt;{</code><code class="nx">item</code><code class="p">.</code><code class="nx">label</code><code class="p">}&lt;/</code><code class="nt">strong</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">index</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">activeItemIndex</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">i</code><code class="p">.</code><code class="nx">content</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now that we’ve got multiple parts for our <code>Accordion</code> making it a&#13;
compound component, our usage of the <code>Accordion</code> goes from this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Accordion</code>&#13;
  <code class="na">items</code><code class="o">=</code><code class="p">{[</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"One"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://one.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"Two"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://two.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"> </code><code class="nx">label</code><code class="o">:</code><code class="w"> </code><code class="s2">"Three"</code><code class="p">,</code><code class="w"> </code><code class="nx">content</code><code class="o">:</code><code class="w"> </code><code class="s2">"lorem ipsum for more, see https://three.com"</code><code class="w"> </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">]}</code>&#13;
<code class="p">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>to this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Accordion</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">{</code><code class="nx">items</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code><code class="w"> </code><code class="nx">index</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code> <code class="na">item</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">}</code> <code class="na">index</code><code class="o">=</code><code class="p">{</code><code class="nx">index</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">))}</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">Accordion</code><code class="p">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The benefit of this is that we have far more control, while each&#13;
<code>AccordionItem</code> is aware of the larger state of <code>Accordion</code>. So now, if&#13;
we wanted to include a horizontal line between items <code>Two</code> and <code>Three</code>,&#13;
we could break out of the <code>map</code> and go more manual if we wanted to:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Accordion</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">items</code><code class="p">[</code><code class="mf">0</code><code class="p">].</code><code class="nx">id</code><code class="p">}</code> <code class="na">item</code><code class="o">=</code><code class="p">{</code><code class="nx">items</code><code class="p">[</code><code class="mf">0</code><code class="p">]}</code> <code class="na">index</code><code class="o">=</code><code class="p">{</code><code class="mf">0</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">items</code><code class="p">[</code><code class="mf">1</code><code class="p">].</code><code class="nx">id</code><code class="p">}</code> <code class="na">item</code><code class="o">=</code><code class="p">{</code><code class="nx">items</code><code class="p">[</code><code class="mf">1</code><code class="p">]}</code> <code class="na">index</code><code class="o">=</code><code class="p">{</code><code class="mf">1</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">hr</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">items</code><code class="p">[</code><code class="mf">2</code><code class="p">].</code><code class="nx">id</code><code class="p">}</code> <code class="na">item</code><code class="o">=</code><code class="p">{</code><code class="nx">items</code><code class="p">[</code><code class="mf">2</code><code class="p">]}</code> <code class="na">index</code><code class="o">=</code><code class="p">{</code><code class="mf">2</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">Accordion</code><code class="p">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Or, we could do something more hybrid, like:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="p">&lt;</code><code class="nt">Accordion</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">{</code><code class="nx">items</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mf">0</code><code class="p">,</code><code class="w"> </code><code class="mf">2</code><code class="p">).</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code><code class="w"> </code><code class="nx">index</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code> <code class="na">item</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">}</code> <code class="na">index</code><code class="o">=</code><code class="p">{</code><code class="nx">index</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">hr</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">{</code><code class="nx">items</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mf">2</code><code class="p">).</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">,</code><code class="w"> </code><code class="nx">index</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">AccordionItem</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">}</code> <code class="na">item</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">}</code> <code class="na">index</code><code class="o">=</code><code class="p">{</code><code class="nx">index</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">))}</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">Accordion</code><code class="p">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This is the benefit of compound components: they invert control of&#13;
rendering to the parent, while preserving contextual state awareness&#13;
among children. The same approach could be used for a tab UI, where&#13;
tabs are aware of the current tab state while having varying levels of&#13;
element nesting.</p>&#13;
&#13;
<p>Another benefit is that this pattern promotes <a data-primary="separation of concerns (SoC)" data-secondary="with compound component pattern" data-secondary-sortas="compound component pattern" data-type="indexterm" id="id759"/>separation of concerns,&#13;
which helps applications scale significantly better over time<a data-startref="ix_softwaredesignpatternscompoundcomponents.05.2593.40" data-type="indexterm" id="id760"/><a data-startref="ix_compoundcomponentspattern.05.2593.40" data-type="indexterm" id="id761"/><a data-startref="ix_accordioncomponents.05.2593.40" data-type="indexterm" id="id762"/><a data-startref="ix_ReactContext.05.2697.35" data-type="indexterm" id="id763"/><a data-startref="ix_contextupdates.05.2697.35" data-type="indexterm" id="id764"/><a data-startref="ix_updatescontext.05.2697.35" data-type="indexterm" id="id765"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="State Reducer" data-type="sect2"><div class="sect2" id="id81">&#13;
<h2>State Reducer</h2>&#13;
&#13;
<p>The state reducer<a data-primary="software design patterns" data-secondary="state reducer" data-type="indexterm" id="ix_softwaredesignpatternsstatereducer.05.2809.18"/><a data-primary="state reducer pattern" data-type="indexterm" id="ix_statereducerpattern.05.2809.18"/> pattern in React was invented and popularized by Kent&#13;
C. Dodds<a data-primary="Dodds, Kent C." data-type="indexterm" id="id766"/> (<em>@kentcdodds</em>), one of the most prominent and proficient&#13;
engineers and educators in the React space, and a true world-renowned&#13;
expert in the field. This pattern offers a powerful way to create&#13;
flexible and customizable components. Let’s illustrate this concept with&#13;
a real-world example: a toggle button component. This example will&#13;
demonstrate how a basic toggle component can be enhanced to allow&#13;
consumers to customize its state logic, disabling the toggle on certain&#13;
days of the week for some business reason.</p>&#13;
&#13;
<p>First, we start with a basic toggle component using the <code>useReducer</code>&#13;
hook. The component maintains its own state, determining whether the&#13;
toggle is in an <code>On</code> or <code>Off</code> position. The initial state is set to&#13;
<code>false</code>, indicating the <code>Off</code> state:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useReducer</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">toggleReducer</code><code class="p">(</code><code class="nx">state</code><code class="p">,</code> <code class="nx">action</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">action</code><code class="p">.</code><code class="nx">type</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s2">"TOGGLE"</code><code class="o">:</code>&#13;
      <code class="k">return</code> <code class="p">{</code> <code class="nx">on</code><code class="o">:</code> <code class="o">!</code><code class="nx">state</code><code class="p">.</code><code class="nx">on</code> <code class="p">};</code>&#13;
    <code class="k">default</code><code class="o">:</code>&#13;
      <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`Unhandled action type: </code><code class="si">${</code><code class="nx">action</code><code class="p">.</code><code class="nx">type</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Toggle</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">state</code><code class="p">,</code> <code class="nx">dispatch</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useReducer</code><code class="p">(</code><code class="nx">toggleReducer</code><code class="p">,</code> <code class="p">{</code> <code class="nx">on</code><code class="o">:</code> <code class="kc">false</code> <code class="p">});</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">dispatch</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"TOGGLE"</code> <code class="p">})}</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">on</code> <code class="o">?</code> <code class="s2">"On"</code> <code class="o">:</code> <code class="s2">"Off"</code><code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To implement the state reducer pattern, the <code>Toggle</code> component is&#13;
modified to accept a <code>stateReducer</code> prop. This prop allows the&#13;
component’s internal state logic to be customized or extended. The&#13;
component’s <code>internalDispatch</code> function combines the internal reducer&#13;
logic with the external reducer provided by the <code>stateReducer</code> prop:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">Toggle</code><code class="p">({</code> <code class="nx">stateReducer</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">state</code><code class="p">,</code> <code class="nx">dispatch</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useReducer</code><code class="p">(</code>&#13;
    <code class="p">(</code><code class="nx">state</code><code class="p">,</code> <code class="nx">action</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="kr">const</code> <code class="nx">nextState</code> <code class="o">=</code> <code class="nx">toggleReducer</code><code class="p">(</code><code class="nx">state</code><code class="p">,</code> <code class="nx">action</code><code class="p">);</code>&#13;
      <code class="k">return</code> <code class="nx">stateReducer</code><code class="p">(</code><code class="nx">state</code><code class="p">,</code> <code class="p">{</code> <code class="p">...</code><code class="nx">action</code><code class="p">,</code> <code class="nx">changes</code><code class="o">:</code> <code class="nx">nextState</code> <code class="p">});</code>&#13;
    <code class="p">},</code>&#13;
    <code class="p">{</code> <code class="nx">on</code><code class="o">:</code> <code class="kc">false</code> <code class="p">}</code>&#13;
  <code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">internalDispatch</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"TOGGLE"</code> <code class="p">})}</code><code class="o">&gt;</code>&#13;
      <code class="p">{</code><code class="nx">state</code><code class="p">.</code><code class="nx">on</code> <code class="o">?</code> <code class="s2">"On"</code> <code class="o">:</code> <code class="s2">"Off"</code><code class="p">}</code>&#13;
    <code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">Toggle</code><code class="p">.</code><code class="nx">defaultProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">stateReducer</code><code class="o">:</code> <code class="p">(</code><code class="nx">state</code><code class="p">,</code> <code class="nx">action</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">state</code><code class="p">,</code> <code class="c1">// Default reducer does nothing special</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>From this code snippet, we can see that the <code>stateReducer</code> prop is used&#13;
to customize the component’s internal state logic. The <code>stateReducer</code>&#13;
function is called with the current state and the action object; however,&#13;
we add an extra property of metadata to the action: <code>changes</code>. This&#13;
<code>changes</code> property contains the next state of the component, which is&#13;
calculated by the internal reducer. This allows the external reducer to&#13;
access the next state of the component and make decisions based on that.</p>&#13;
&#13;
<p>Let’s see how the <code>Toggle</code> component can be utilized with custom&#13;
behavior based on this pattern. In the following example, the <code>App</code>&#13;
component uses the <code>Toggle</code> but provides a custom <code>stateReducer</code>. This&#13;
reducer contains logic that prevents the toggle from being turned off on&#13;
Wednesdays because Wednesday in this app’s location is a universal “no&#13;
off” day. This illustrates how the state reducer pattern allows for&#13;
flexible modification of component behavior without changing the&#13;
component itself:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">customReducer</code> <code class="o">=</code> <code class="p">(</code><code class="nx">state</code><code class="p">,</code> <code class="nx">action</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// Custom logic: prevent toggle off on Wednesdays</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">().</code><code class="nx">getDay</code><code class="p">()</code> <code class="o">===</code> <code class="mi">3</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">changes</code><code class="p">.</code><code class="nx">on</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">state</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="nx">action</code><code class="p">.</code><code class="nx">changes</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="k">return</code> <code class="o">&lt;</code><code class="nx">Toggle</code> <code class="nx">stateReducer</code><code class="o">=</code><code class="p">{</code><code class="nx">customReducer</code><code class="p">}</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this example, we see the power of the state reducer pattern in&#13;
creating highly flexible and reusable components. By allowing external&#13;
logic to integrate with the internal state management of a component, we&#13;
can cater to a wide range of behaviors and use cases, enhancing both the&#13;
utility and versatility of the component<a data-startref="ix_softwaredesignpatterns.05.1765.25" data-type="indexterm" id="id767"/><a data-startref="ix_softwaredesignpatternsstatereducer.05.2809.18" data-type="indexterm" id="id768"/><a data-startref="ix_statereducerpattern.05.2809.18" data-type="indexterm" id="id769"/><a data-startref="ix_customReactcomponentsrendering.05.933.47" data-type="indexterm" id="id770"/><a data-startref="ix_renderingcustomReactcomponents.05.933.47" data-type="indexterm" id="id771"/>.</p>&#13;
&#13;
<p>Whew! What a chapter! Let’s wrap things up and summarize what we&#13;
learned.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chapter Review" data-type="sect1"><div class="sect1" id="id235">&#13;
<h1>Chapter Review</h1>&#13;
&#13;
<p>Throughout this chapter, we’ve discussed various aspects of React,&#13;
including memoization, lazy loading, reducers, and state management.&#13;
We’ve explored the advantages and potential drawbacks of different&#13;
approaches to these topics and how they can impact the performance and&#13;
maintainability of React applications.</p>&#13;
&#13;
<p>We started by discussing memoization in React and its benefits for&#13;
optimizing component rendering. We looked at the <code>React.memo</code> function&#13;
and how it can be used to prevent unnecessary rerenders of components.&#13;
We also examined some potential issues with memoization, such as stale&#13;
state and the need to carefully manage &#13;
<span class="keep-together">dependencies.</span></p>&#13;
&#13;
<p>Next, we talked about lazy loading in React and how it can be used to&#13;
defer the loading of certain components or resources until they are&#13;
actually needed. We looked at the <code>React.lazy</code> and <code>Suspense</code> components&#13;
and how they can be used to implement lazy loading in a React&#13;
application. We also discussed the trade-offs of lazy loading, such as&#13;
increased complexity and potential performance issues.</p>&#13;
&#13;
<p>We then moved on to reducers and how they can be used for state&#13;
management in React. We explored the differences between <code>useState</code> and&#13;
<code>useReducer</code>, and discussed the advantages of using a centralized reducer&#13;
function for managing state updates.</p>&#13;
&#13;
<p>Throughout our conversation, we used code examples from our own&#13;
implementations to illustrate the concepts we discussed. We explored how&#13;
these examples work under the hood and how they can impact the&#13;
performance and maintainability of React applications.</p>&#13;
&#13;
<p>Through the use of code examples&#13;
and in-depth explanations, we gained a deeper understanding of these&#13;
topics and how they can be applied in real-world React &#13;
<span class="keep-together">applications.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect1"><div class="sect1" id="id236">&#13;
<h1>Review Questions</h1>&#13;
&#13;
<p>Let’s ask ourselves a few questions to test our understanding of the&#13;
concepts we learned in this chapter:</p>&#13;
<ol>&#13;
<li>&#13;
<p>What is memoization in React, and how can it be used to optimize&#13;
component rendering?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are the advantages of using <code>useReducer</code> for state management in&#13;
React, and how does it differ from <code>useState</code>?</p>&#13;
</li>&#13;
<li>&#13;
<p>How can lazy loading be implemented in a React application using the&#13;
<code>React.lazy</code> and <code>Suspense</code> components?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are some potential issues that can arise when using memoization&#13;
in React, and how can they be mitigated?</p>&#13;
</li>&#13;
<li>&#13;
<p>How can the <code>useCallback</code> hook be used to memoize functions passed as&#13;
props to components in React?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Up Next" data-type="sect1"><div class="sect1" id="id237">&#13;
<h1>Up Next</h1>&#13;
&#13;
<p>In the next chapter, we’ll look at React on the server side—diving&#13;
into serve-side rendering, its benefits and trade-offs, hydration,&#13;
frameworks, and more. See you there!</p>&#13;
</div></section>&#13;
</div></section></body></html>