- en: Chapter 5\. Services and Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications running in a Kubernetes cluster rarely work in isolation. In the
    constellation of a microservices architecture, a set of applications running in
    their corresponding Pods need to work together. Kubernetes enables intracluster
    Pod-to-Service communication and communication with select Services from outside
    of the cluster with the help of various networking concepts. This domain of the
    CKA focuses on Services and networking aspects. You will need to understand the
    concept of a Service and an Ingress, as well as the cluster configuration that
    enables network communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes networking basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connectivity between Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services, service types and their endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ingress controller and Ingress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using and configuring CoreDNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing a container network interface (CNI) plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes Networking Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes is designed as an operating system for managing the complexities
    of distributed data and computing. Workloads can be scheduled on a set of nodes
    to distribute the load. The Kubernetes network model enables networking communication
    and needs to fulfill the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Container-to-container communication](#connectivity_between_containers): Containers
    running in a Pod often need to communicate with each other. Containers within
    the same Pods can send Inter Process Communication (IPC) messages, share files,
    and most often communicate directly through the loopback interface using the `localhost`
    hostname. Because each Pod is assigned a unique virtual IP address, each container
    in the same Pod is given that context and shares the same port space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Pod-to-Pod communication](#connectivity_between_containers): A Pod needs to
    be able to reach another Pod running on the same or on a different node without
    Network Address Translation (NAT). Kubernetes assigns a unique IP address to every
    Pod upon creation from the Pod CIDR range of its node. The IP address is ephemeral
    and therefore cannot be considered stable over time. Every restart of a Pod leases
    a new IP address. It’s recommended to use Pod-to-Service communication over Pod-to-Pod
    communication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Pod-to-Service communication](#understanding_services): Services expose a
    single, stable DNS name for a set of Pods with the capability of load balancing
    the requests across the Pods. Traffic to a Service can be received from within
    the cluster or from the outside.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Node-to-node communication: Nodes registered with a cluster can talk to each
    other. Every node is assigned a node IP address.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The specification for the Kubernetes networking model is called [Container Network
    Interface (CNI)](#cni_spec_implementation). Network plugins that implement the
    CNI specification are widely available and can be configured in a Kubernetes cluster
    by the administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Connectivity Between Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers created by a single Pod share the same IP address and port space.
    Containers can communicate among each other using `localhost`. That’s especially
    useful when creating cloud-native applications that require implementing a multi-container
    pattern, as shown in [Figure 5-1](#container_to_container_communication). Refer
    to the book [*Kubernetes Patterns*](https://oreil.ly/RsTJw) (O’Reilly) for more
    information on common multi-container design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0501](Images/ckas_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Container-to-container communication in a Pod
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The YAML manifest in [Example 5-1](#multi_container_pod) creates a sidecar
    container that calls the main application container via `localhost` on port 80:'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. A multi-container Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Checking the logs of the sidecar container shows that the communication to
    the main application container was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Connectivity Between Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every Pod is assigned an IP address upon creation. You can inspect a Pod’s
    IP address by using the `-o wide` command-line option for the `get pods` command
    or by describing the Pod. The IP address of the Pod in the following console output
    is `172.17.0.4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The IP address assigned to a Pod is unique across all nodes and namespaces.
    This is achieved by assigning a dedicated subnet to each node when registering
    it. When creating a new Pod on a node, the IP address is leased from the assigned
    subnet. This is handled by the networking lifecycle manager kube-proxy along with
    the DNS service and the CNI. The following command queries the assigned subnet
    via the attribute `spec.podCIDR` from the node named `minikube`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Pods on a node can communicate with all other Pods running on any other node
    of the cluster. [Figure 5-2](#pod_to_pod_communication) illustrates the use case.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0502](Images/ckas_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Pod-to-Pod communication
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can easily verify the behavior by creating a temporary Pod that calls the
    IP address of another Pod using the command-line tool `curl` or `wget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It’s important to understand that the IP address is not considered stable over
    time. A Pod restart leases a new IP address. Building a microservices architecture,
    where each of the applications runs in its own Pod with the need to communicate
    between each other with a stable network interface, requires a different concept,
    the Service.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a nutshell, Services provide discoverable names and load balancing to a set
    of Pods. The Services and Pods remain agnostic from IP addresses with the help
    of the Kubernetes DNS control-plane component. Similar to a Deployment, the Service
    determines the Pods it works on with the help of label selection.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-3](#service_traffic_routing) illustrates the functionality. Pod 1
    receives traffic as its assigned labels match with the label selection defined
    in the Service. Pod 2 does not receive traffic as it defines nonmatching labels.
    Note that it is possible to create a Service without a label selector for less-common
    scenarios. Refer to the relevant [Kubernetes documentation](https://oreil.ly/lCzAa)
    for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0503](Images/ckas_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Service traffic routing based on label selection
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Services are a complementary concept to Deployments. Services route network
    traffic to a set of Pods, and Deployments manage a set of Pods, the replicas.
    While you can use both concepts in isolation, it is recommended to use Deployments
    and Services together. The primary reason is the ability to scale the number of
    replicas and at the same time expose an endpoint to control network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Service Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every Service needs to define a type. [Table 5-1](#service_types) lists the
    Service types relevant to the CKA exam.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Service types
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ClusterIP` | Exposes the Service on a cluster-internal IP. Only reachable
    from within the cluster. |'
  prefs: []
  type: TYPE_TB
- en: '| `NodePort` | Exposes the Service on each node’s IP address at a static port.
    Accessible from outside of the cluster. |'
  prefs: []
  type: TYPE_TB
- en: '| `LoadBalancer` | Exposes the Service externally using a cloud provider’s
    load balancer. |'
  prefs: []
  type: TYPE_TB
- en: Other Service types can be defined; however, we’ll not address them in this
    book as they are out of scope for the exam. For more information, refer to the
    [Kubernetes documentation](https://oreil.ly/3jzod).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create Services in a variety of ways, some of which are more conducive
    to the CKA exam as they provide a fast turnaround. Let’s discuss the imperative
    approach first.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Service needs to select a Pod by a matching label. The Pod created by the
    following `run` command is called `echoserver`, which exposes the application
    on the container port 8080\. Internally, it automatically assigns the label key-value
    pair `run: echoserver` to the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create service` command creates the corresponding Service object. You
    need to provide the Service type as a mandatory argument. Here we are using the
    type `clusterip`. The command-line option `--tcp` specifies the port mapping,
    port 80 exposed by the Service for incoming network traffic and port 8080, which
    targets the container port exposed by the Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'An even faster workflow of creating a Pod and Service together can be achieved
    with the option `--expose` for the `run` command. The following command creates
    both objects in one swoop while creating the proper label selection. This command-line
    option is a good choice during the CKA to save time if you were asked to create
    a Pod and a Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s actually more common to use a Deployment and Service that work together.
    The following set of commands creates a Deployment with five replicas and then
    uses the `expose deployment` command to create the Service. The port mapping can
    be provided with the options `--port` and `--target-port`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 5-2](#service_manifest) shows the representation of a Service in the
    form of a YAML manifest. The Service declares the key-value `app: echoserver`
    for label selection and defines the port mapping 80 to 8080.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. A Service defined by a YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Listing Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Listing all Services presents a table view that includes the Service type,
    the cluster IP address, and the incoming port. Here, you can see the output for
    the `echoserver` Pod we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Rendering Service Details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may want to drill into the details of a Service for troubleshooting purposes.
    That might be the case if the incoming traffic to a Service isn’t routed properly
    to the set of Pods you expect to handle the workload.
  prefs: []
  type: TYPE_NORMAL
- en: The `describe` command renders valuable information about the configuration
    of a Service. The configuration relevant to troubleshooting a Service is the value
    of the fields Selector, IP, Port, TargetPort, and Endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the output of the following `describe` command. It’s the details
    for a Service created for five Pods controlled by a Deployment. The Endpoints
    attribute lists a range of endpoints, one for each of the Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubernetes represents endpoints by a dedicated resource that you can query
    for. The endpoint object is created at the same time you create the Service object.
    The following command lists the endpoint for the Service named `echoserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the endpoint give away the full list of IP address and port
    combinations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Port Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Service selects the set of Pods to forward traffic to by the assigned labels.
    Successful routing of network traffic also depends on the proper port mapping.
    In the previous sections, we created different Services and assigned ports to
    them. Here, we’ll want to revisit the port mapping by making its moving parts
    more transparent.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](#service_port_mapping) shows a Service that accepts incoming traffic
    on port 80\. That’s the port defined by the attribute `spec.ports[].port` in the
    manifest. Any incoming traffic is then routed toward the target port, represented
    by `spec.ports[].targetPort`. The target port is the same port as defined by the
    container running inside the label-selected Pod. In this case, that’s port 8080.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0504](Images/ckas_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Service port mapping
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Accessing a Service with Type ClusterIP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ClusterIP` is the default type of Service. It exposes the Service on a cluster-internal
    IP address. That means the Service can be accessed only from a Pod running inside
    of the cluster but not from outside of the cluster (e.g., if you were to make
    call to the Service from your local machine). [Figure 5-5](#service_clusterip)
    illustrates the accessibility of a Service with type `ClusterIP`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0505](Images/ckas_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. Accessibility of a Service with the type `ClusterIP`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We will create a Pod and a corresponding Service to demonstrate the runtime
    behavior of `ClusterIP`. The Pod named `echoserver` exposes the container port
    8080 and specifies the label `app: echoserver`. The Service defines port 5005
    for incoming traffic, which is forwarded to port 8080 for the Pod selected. The
    label selection matches the Pod we set up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The cluster IP that makes the Service available is `10.96.254.0`. Listing the
    Service also renders the port for incoming traffic to the Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You cannot access the Service using the cluster IP and the port from your local
    machine, illustrated by the following `wget` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing the Service from a temporary Pod from within the cluster properly
    routes the request to the Pod matching the label selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Accessing a Service with Type NodePort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Declaring a Service with type `NodePort` exposes access through the node’s IP
    address and can be resolved from outside of the Kubernetes cluster. The node’s
    IP address can be reached in combination with a port number in the range of 30000
    and 32767, assigned automatically upon the creation of the Service. This port
    is opened on every node in the cluster, and its value is global and unique at
    the cluster-scope level. To avoid port conflicts, it’s best to not define the
    exact node port and let Kubernetes find an available port. Keep in mind `NodePort`
    (capital *N*) is the Service type, whereas `nodePort` (lowercase *n*) is the key
    for the value. [Figure 5-6](#service_nodeport) illustrates the routing of traffic
    to Pods via a `NodePort`-typed Service.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0506](Images/ckas_0506.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. Accessibility of a Service with the type NodePort
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The next two commands create a Pod and a Service of type `NodePort`. The only
    difference here is to provide `nodeport` instead of `clusterip` as a command-line
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once they’re created, you can list the Pods and Services. You will find that
    the port representation contains the statically assigned port that makes the Service
    accessible. In our case, that’s port 30158:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'From within the cluster, you can still access the Service using the cluster
    IP address and port number. This Services exposes exactly the same behavior as
    if it were of type `ClusterIP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From outside of the cluster, you need to use the IP address of the node running
    the Pod and the statically assigned port. One way to determine the node’s IP address
    is via `kubectl cluster-info` or by querying the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Service URL in Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minikube offers a shortcut for determining the Service endpoint via the command
    `minikube service --url <service-name>`. For more information, see the [Minikube
    documentation](https://oreil.ly/HGYRp).
  prefs: []
  type: TYPE_NORMAL
- en: 'The node IP address here is `192.168.64.15`. It can be used to call the Service
    from outside of the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Accessing a Service with Type LoadBalancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes cloud providers offer support for configuration from a preexisting
    external load balancer to a Service with the help of the type `LoadBalancer`.
    This Service type exposes a single IP address that distributes incoming requests
    to the cluster nodes. The implementation of the load balancing strategy (e.g.,
    round robin) is up to the cloud provider. [Figure 5-7](#service_loadbalancer)
    shows an architectural overview.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0507](Images/ckas_0507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. Accessibility of a Service with the type LoadBalancer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Setting up a network route in Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minikube is not a cloud provider implementation of Kubernetes; however, you
    can configure a network route to the Service to try out load balancer functionality.
    All you need to do is to run the command `minikube tunnel` in a separate shell.
    For more information, see the [Minikube documentation](https://oreil.ly/O37FF).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Service as a load balancer, set the type to `LoadBalancer` in the
    manifest or by using the `create service loadbalancer` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will find that a Service of type `LoadBalancer` exposes an external IP
    address. List the Service to render the external IP address, which is `10.109.76.157`
    in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To call the Service from outside of the cluster, use the external IP address
    and its incoming port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Ingress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Standard Kubernetes Ingress solutions provide load balancing only at layer 7
    (HTTP or HTTPS traffic) and route transactions from outside of the cluster to
    Services within the cluster, as illustrated in [Figure 5-8](#ingress_traffic_routing).
    It’s not a specific Service type, nor should it be confused with the Service type
    `LoadBalancer`.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0508](Images/ckas_0508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Managing external access to the Services via HTTP(S)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An Ingress cannot work without an Ingress controller. The Ingress controller
    evaluates the collection of rules defined by an Ingress that determine traffic
    routing. One example of a production-grade Ingress controller is the [F5 NGINX
    Ingress Controller](https://oreil.ly/owWZN) or [AKS Application Gateway Ingress
    Controller](https://oreil.ly/8hupA). You can find other options listed in the
    [Kubernetes documentation](https://oreil.ly/wGHWl).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ingress functionality has to be enabled explicitly if you are using Minikube.
    The Ingress controller runs as a Pod in the namespace `ingress-nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Ingress Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rules defined by an Ingress object follow the three criteria listed in [Table 5-2](#ingress_rules).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Ingress rules
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| An optional host | `mycompany.abc.com` | If a host is provided, then the
    rules apply to that host. If no host is defined, then all inbound HTTP(S) traffic
    is handled. |'
  prefs: []
  type: TYPE_TB
- en: '| A list of paths | `/corellian/api` | Incoming traffic must match the host
    and path to correctly forward the traffic to a Service. |'
  prefs: []
  type: TYPE_TB
- en: '| The backend | `corellian:8080` | A combination of Service name and port.
    |'
  prefs: []
  type: TYPE_TB
- en: Creating Ingresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can create an Ingress with the imperative `create ingress` command. The
    main command-line option you will need to provide is `--rule`, which defines the
    rules in a comma-separated fashion. The notation for each key-value pair is `<host>/<path>=<service>:<port>`.
    If you look at the output of the `create ingress --help` command, more fine-grained
    rules can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Port 80 for HTTP traffic is implied as we didn’t specify a reference to a TLS
    Secret object. If you would have specified `tls=mysecret` in the rule definition,
    then the port 443 would be listed here as well. For more information on enabling
    HTTPS traffic, see the [Kubernetes documentation](https://oreil.ly/d2sbY).
  prefs: []
  type: TYPE_NORMAL
- en: The same Ingress defined as a YAML manifest is shown in [Example 5-3](#ingress_manifest).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. An Ingress defined by a YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Defining Path Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous YAML manifest demonstrates one of the options for specifying a
    path type via the attribute `spec.rules[].host[].http.paths[].pathType`. The path
    type defines how an incoming request is evaluated against the declared path. [Table 5-3](#ingress_path_types)
    should give you an indication on the evaluation for incoming requests and their
    paths. See the [Kubernetes documentation](https://oreil.ly/4plCE) for a more comprehensive
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-3\. Ingress path types
  prefs: []
  type: TYPE_NORMAL
- en: '| Path Type | Rule | Incoming Request |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Exact` | `/corellian/api` | Matches `/corellian/api` but does not match
    `/corellian/test` or `/corellian/api/` |'
  prefs: []
  type: TYPE_TB
- en: '| `Prefix` | `/corellian/api` | Matches `/corellian/api` and `/corellian/api/`
    but does not match `/corellian/test` |'
  prefs: []
  type: TYPE_TB
- en: Listing Ingresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Listing Ingresses can be achieved with the `get ingress` command. You will
    see some of the information you specified when creating the Ingress (e.g., the
    hosts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Rendering Ingress Details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The details of an Ingress can be rendered using the `describe ingress` command.
    Each of the rules is listed in a table. For troubleshooting purposes, look out
    for additional messages. In the following output, you can see that the Service
    named `corellian` we mapped here does not exist. Furthermore, the event log shows
    syncing activity of the rules by the Ingress controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With the Service and Pod serving up a request, here are the Ingress details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Accessing an Ingress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The combination of backend and path routes incoming HTTP(S) traffic through
    the Ingress, which in turn propagates the call to the configured Service. To test
    the behavior on a local Kubernetes cluster on your machine, you need to first
    find out the IP address of the load balancer used by the Ingress. Next, you’ll
    need to add the IP address to hostname mapping to your `/etc/hosts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now send HTTP requests to the backend. The first call matches the `Exact`
    path rule. The second call doesn’t go through as the path rule does not match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using and Configuring CoreDNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is geared toward operating a microservices architecture. Individual
    microservices offer distinct, self-contained functionality and communicate with
    one another to complement each other. Earlier in this chapter, we talked about
    the usage of a Service to provide a stable network interface. Many of the examples
    used an IP address and port to talk to a Service.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes runs a DNS server implementation called [CoreDNS](https://coredns.io)
    that maps the name of the Service to its IP address. In turn, microservices can
    easily reference the Service name to communicate with each other. For a deep dive
    on CoreDNS, check out the excellent book [*Learning CoreDNS*](https://oreil.ly/06kPW)
    (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the CoreDNS Pod
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The CoreDNS server is running in a Pod in the namespace `kube-system`. The
    following command renders the CoreDNS Pod for a Minikube cluster installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: CoreDNS uses a so-called `Corefile` to configure the runtime behavior of the
    DNS server. The ConfigMap named `coredns` set up in the same namespace defines
    the contents of the configuration file. The CoreDNS Pod mounts the ConfigMap,
    as shown in [Example 5-4](#coredns_pod).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. YAML manifest of CoreDNS Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inspecting the CoreDNS Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can inspect the ConfigMap with the command `kubectl get configmaps coredns
    -n kube-system -o yaml`. [Example 5-5](#coredns_default_configmap) shows the content
    of the `Corefile`. See the [CoreDNS manual](https://oreil.ly/7AeWG) for more information
    on the syntax and instructions of a `Corefile`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. Default Corefile defined by a ConfigMap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Customizing the CoreDNS Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default configuration of a `Corefile` can be further customized. To do so,
    create a new ConfigMap in the namespace `kube-system` in the format shown in [Example 5-6](#coredns_custom_configmap).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6\. Custom Corefile defined by a ConfigMap
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the new ConfigMap specified by the file `coredsns-custom.yaml` and force
    a reload of the CoreDNS Pod configuration by deleting it. The CoreDNS will start
    up again automatically because the CoreDNS Pod was deployed and managed by the
    state of the Deployment. The Pod’s restart policy defaults to `Always`; deleting
    the Pod is a quick way to force it to restart, and the new Pod instance will be
    mapped to the updated information in the ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: DNS for Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services tie into the DNS service provided by CoreDNS. In this section, we will
    talk about various scenarios that illustrate how to talk to a Service from another
    Pod that lives in the same or a different namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving a Service by Hostname from the Same Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Pod can resolve the Service by hostname if both objects live in the same namespace.
    [Figure 5-9](#dns_service_same_namespace) illustrates a Pod implementing UI frontend
    functionality that makes a call to a backend microservice through a Service.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0509](Images/ckas_0509.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9\. Resolving a Service from the same namespace
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can easily verify the behavior with the following commands. Here, we’ll
    create a Service and a Pod in the namespace `dns` with the name `echoserver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify the correct service discovery by running a Pod in the same namespace
    that makes a call to the Service by using its hostname and incoming port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Resolving a Service by Hostname from a Different Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not uncommon to make a call from a Pod to a Service that lives in a different
    namespace. Referencing just the hostname of the Service does not work across namespaces.
    You need to append the namespace as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-10](#dns_service_different_namespace) illustrates a backend Pod in
    the namespace `business` that calls a Service in the namespace `other`. To communicate
    with the `weather-api` Service from the namespace `business`, you will need to
    reference it via `weather-api.other`. Services that reside in the `default` namespace
    will have to referenced accordingly (e.g., `lottery.default`).'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0510](Images/ckas_0510.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10\. Resolving a Service from a different namespace
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'From a different namespace, in this case called `business`, make a call from
    a temporary Pod to the Service in the namespace `other`. Attempting to call the
    Service without the namespace results in a failure to connect. You can see in
    the following code that the namespace of the Service needs to be spelled out explicitly:
    `echoserver.other`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Corefile` defines a cluster domain. By default, the value of the cluster
    domain is `cluster.local`. You can append the cluster domain to the hostname when
    referencing a Service. In addition, you’ll need to use the type of object you’re
    communicating with. The string `svc` describes the type Service. The full hostname
    for a Service is `echoserver.other.svc.cluster.local`. You can see the calls in
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: DNS for Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pods can talk to each by IP address across namespaces. CoreDNS provides the
    configuration option `pods insecure` in the `Corefile` file to create DNS records
    for Pods. To reference a Pod, use the IP address, but replace the dots with dashes.
    For example, a Pod with the IP address `10.0.0.85` has a corresponding DNS record
    with `10-0-0-85`. [Figure 5-11](#dns_pod) shows Pods that reference each other
    by their DNS records.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0511](Images/ckas_0511.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-11\. Resolving a Pod via DNS records
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Resolving a Pod by Hostname
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll create two Pods to demonstrate the runtime behavior of CoreDNS for Pods.
    Pod 1, named `echoserver1`, runs in the namespace `ns1` with the IP address `172.17.0.8`.
    Pod 2, named `echoserver2`, runs in the namespace `ns2` with the IP address `172.17.0.9`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'For resolving a Pod via DNS, you are required to spell out the namespace and
    object type as part of the hostname independent of where the Pod lives. The following
    two commands use a temporary Pod to make a call to another Pod in the same and
    a different namespace. Adding `cluster.local` is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This option `pods insecure` exists only for backward compatibility reasons with
    `kube-dns`, the original implementation of Kubernetes’ DNS server. You can disable
    the creation of DNS records for Pods by configuring CoreDNS with `pods disabled`
    instead. It is not recommended to rely on the DNS record for a Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing an Appropriate Container Network Interface Plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.xhtml#cluster_architecture_installation_configuration),
    we talked about the mechanics of installing a Container Network Interface plugin.
    The CNI, a Cloud Native Computing Foundation project, consists of a specification
    and libraries for writing plugins to configure network interfaces in Linux containers,
    along with a number of plugins. CNI concerns itself only with network connectivity
    of containers and removing allocated resources when the container is deleted.
    Kubernetes uses CNI as an interface between network providers and Kubernetes Pod
    networking.
  prefs: []
  type: TYPE_NORMAL
- en: The CNI specification defines the Pod networking interface and capabilities.
    Plugins implement the specification and allow a Kubernetes administrator to pick
    and choose a product-specific feature set. [Figure 5-12](#cni_spec_implementation)
    shows a couple of exemplary plugins you can choose from. For a list of plugins,
    see the [Kubernetes documentation](https://oreil.ly/mgnMT).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0512](Images/ckas_0512.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-12\. CNI specification and implementation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Choosing an appropriate CNI plugin depends on your needs. Refer to this [blog
    post](https://oreil.ly/8lCIq) for a decision matrix that can help you make the
    right choice for your Kubernetes cluster. During the CKA exam, you might be asked
    to install a CNI plugin. Many of the plugins mentioned in the Kubernetes documentation
    link to web pages outside of the Kubernetes domain. Remember that you are not
    allowed to navigate to pages outside of the official Kubernetes documentation
    during the exam. Take a look at the link in the browser before opening it by hovering
    over it with the mouse pointer. For example, this [Kubernetes documentation section](https://oreil.ly/ncYMk)
    describes the installation instructions for Weave Net.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes assigns a unique IP address for every Pod in the cluster. Pods can
    communicate with each other using that IP address; however, you cannot rely on
    the IP address to be stable over time. That’s why Kubernetes provides the Service
    resource type.
  prefs: []
  type: TYPE_NORMAL
- en: A Service forwards network traffic to a set of Pods based on label selection
    and port mappings. Every Service needs to assign a type that determines how the
    Service becomes accessible from within or outside of the cluster. The Service
    types relevant to the CKA exam are `ClusterIP`, `NodePort`, and `LoadBalancer`.
    CoreDNS, the DNS server for Kubernetes, allows Pods to access the Service by hostname
    from the same and other namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: The resource type Ingress defines rules for routing incoming, cluster-external
    HTTP(S) traffic to a Service. An Ingress controller periodically evaluates those
    rules and ensures that they apply to the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand the purpose of a Service
  prefs: []
  type: TYPE_NORMAL
- en: Pod-to-Pod communication via their IP address does’nt guarantee a stable network
    interface over time. The purpose of a Service is to provide that stable network
    interface so that you can operate complex microservice architecture that run in
    a Kubernetes cluster. In most cases, Pods call a Service by hostname. The hostname
    is provided by CoreDNS.
  prefs: []
  type: TYPE_NORMAL
- en: Practice how to access a Service for each type
  prefs: []
  type: TYPE_NORMAL
- en: The CKA exam expects you to understand the differences between the Service types
    `ClusterIP`, `NodePort`, and `LoadBalancer`. Depending on the assigned type, a
    Service becomes accessible from inside the cluster or from outside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the difference between a Service and an Ingress
  prefs: []
  type: TYPE_NORMAL
- en: An Ingress is not to be confused with a Service. The Ingress is meant for routing
    cluster-external HTTP(S) traffic to one or many Services based on an optional
    hostname and mandatory path. A Service routes traffic to a set of Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: In the namespace `external`, create a Deployment named `nginx` with the image
    `nginx` for three replicas. The container should expose the port 80\. Within the
    same namespace, create a Service of type `LoadBalancer`. The Service should route
    traffic to the Pods managed by the Deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From your local machine (outside the cluster), make a call to the LoadBalancer
    using `wget` or `curl`. Identify which Pods received the traffic by looking at
    the logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the Service type to `ClusterIP`. Make a call to the Service using `wget`
    or `curl` so that the Pods receive the traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Ingress named `incoming` in the namespace `external`. Define the path
    type `Prefix` to the path `/` to the Service from the previous step. The Ingress
    should be able to handle any incoming HTTP traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a call to the Ingress using `wget` or `curl` from your local machine. Verify
    that the Pods receive traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Service of type `ClusterIP` named `echoserver` in the namespace
    `external`. The selected and to-be-created Pod should use the image `k8s.gcr.io/echoserver:1.10`
    on port 8080\. Add a new rule to the existing Ingress to route traffic to the
    `echoserver` Service with the path `/echo` and type `Exact`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a call to the Service using `wget` or `curl` from your local machine so
    that the `echoserver` can be reached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a [rewrite rule](https://oreil.ly/ZVYkK) for the CoreDNS configuration
    that allows referencing a Service using the cluster domain `cka.example.com`.
    Ensure that the custom CoreDNS configuration takes effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a call to the `nginx` Service using `wget` or `curl` from a temporary Pod
    in a new namespace called `hello` with the appropriate hostname.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
