<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Full Stack Development in the Era of Serverless Computing"><div class="chapter" id="ch1">
<h1><span class="label">Chapter 1. </span>Full Stack Development in the <span class="keep-together">Era of Serverless Computing</span></h1>


<p><a data-type="indexterm" data-primary="Amazon Pinpoint" data-see="analytics" id="idm45364356275512"/><a data-type="indexterm" data-primary="offline apps, building" data-see="Amplify DataStore" id="idm45364356274536"/><a data-type="indexterm" data-primary="FaaS (functions as a service)" id="idm45364356273592"/>People have typically associated cloud computing with backend development and DevOps. However, over the past few years, this has started to change. With the rise of <em>functions as a service</em> (FaaS), combined with powerful abstractions in the form of managed services, cloud providers have lowered the barrier to entry for developers new to cloud computing, and for traditionally frontend developers.</p>

<p><a data-type="indexterm" data-primary="Amplify" data-secondary="about" id="idm45364356271656"/><a data-type="indexterm" data-primary="Firebase" id="idm45364356270680"/><a data-type="indexterm" data-primary="AWS (Amazon Web Service)" data-secondary="about" id="idm45364356270008"/>Using modern tools, frameworks, and services like Amazon Web Services (AWS) Amplify and Firebase (among others), a single developer can leverage their existing skill set and knowledge of a single framework and ecosystem (like JavaScript) to build scalable full stack applications complete with all of the features that would in the past have required teams of highly skilled backend and DevOps engineers to build and maintain.</p>

<p><a data-type="indexterm" data-primary="Amazon API Gateway" id="idm45364356268216"/><a data-type="indexterm" data-primary="Amazon DynamoDB" id="idm45364356267512"/><a data-type="indexterm" data-primary="Amazon S3" data-secondary="about" id="idm45364356266840"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="about" id="idm45364356265896"/><a data-type="indexterm" data-primary="Amazon Cognito" data-secondary="about" id="idm45364356264952"/><a data-type="indexterm" data-primary="Cognito" data-secondary="about" id="idm45364356264008"/>This book focuses on bridging the gap between frontend and backend development by taking advantage of this new generation of tools and services using the Amplify Framework. Here you’ll learn how to build scalable applications in the cloud directly from your frontend environment using the Amplify Command Line Interface (CLI). You’ll create and interact with various APIs and AWS services, such as authentication using Amazon Cognito, cloud storage using Amazon S3, APIs using Amazon API Gateway and AWS AppSync, and databases using Amazon DynamoDB.</p>

<p><a data-type="indexterm" data-primary="React Context" id="idm45364356262104"/>By the final chapter, you will understand how to build real-world full stack applications in the cloud leveraging AWS services on the backend and React on the frontend. You’ll also learn how to use modern APIs from React, like hooks, and functional components, as well as React Context for global state management.</p>






<section data-type="sect1" data-pdf-bookmark="Modern Serverless Philosophy"><div class="sect1" id="idm45364356260808">
<h1>Modern Serverless Philosophy</h1>

<p><a data-type="indexterm" data-primary="serverless" data-secondary="about" id="idm45364356241752"/>The term <em>serverless</em> is commonly associated with FaaS. Though you will find varying definitions as to what it means, the term has recently grown to encompass more of a philosophy than a shared definition.</p>

<p><a data-type="indexterm" data-primary="business logic" id="idm45364356239736"/><a data-type="indexterm" data-primary="business value" id="idm45364356239032"/><a data-type="indexterm" data-primary="abstractions" id="idm45364356238360"/><a data-type="indexterm" data-primary="smart abstractions" id="idm45364356237688"/>Many times when people talk about serverless, they are really describing how to most efficiently deliver business value with a focus on writing business logic, instead of coding supporting infrastructure for your business logic. Adopting a serverless mindset allows you to do this by consciously going out of your way to find and leverage FaaS, managed services, and smart abstractions, while only building custom solutions if an existing service just doesn’t yet exist.</p>

<p>More and more companies and developers are taking this approach, as it  doesn’t make sense to reinvent the wheel. With the increase in popularity of this philosophy, there has also been an explosion of services and tools made available from startups and cloud providers to provide offerings that simplify backend complexity.</p>

<p><a data-type="indexterm" data-primary="&quot;Cloud Programming Simplified: A Berkeley View on Serverless Computing&quot;" data-primary-sortas="cloud" id="idm45364356235384"/>For an academic take on what <em>serverless</em> means, you may wish to read the 2019 paper written by a group at UC Berkeley, “Cloud Programming Simplified: A Berkeley View on Serverless Computing,”<sup><a data-type="noteref" id="idm45364356233672-marker" href="ch01.xhtml#idm45364356233672">1</a></sup>. In this paper, the authors expanded the definition of <span class="keep-together"><em>serverless</em>:</span></p>
<blockquote>
<p>While cloud functions—packaged as FaaS (Function as a Service) offerings—represent the core of serverless computing, cloud platforms also provide specialized serverless frameworks that cater to specific application requirements as BaaS (Backend as a Service) offerings. Put simply, serverless computing = FaaS + BaaS.</p></blockquote>

<p><a data-type="indexterm" data-primary="Firestore" id="idm45364356229400"/><a data-type="indexterm" data-primary="Auth0" id="idm45364356228696"/><a data-type="indexterm" data-primary="BaaS (backend as a service)" id="idm45364356228024"/><em>Backend as a service</em> (BaaS) typically refers to managed services like databases (Firestore, Amazon DynamoDB), authentication services (Auth0, Amazon Cognito), and artificial intelligence services (Amazon Rekognition, Amazon Comprehend), among other managed services. Berkeley’s redefinition of what serverless means underscores what is happening in the broader spectrum of this discussion as cloud providers begin to build more and better-managed services and put them in this bucket of <span class="keep-together">serverless.</span></p>








<section data-type="sect2" data-pdf-bookmark="Characteristics of a Serverless Application"><div class="sect2" id="idm45364356225736">
<h2>Characteristics of a Serverless Application</h2>

<p><a data-type="indexterm" data-primary="applications" data-secondary="serverless" id="idm45364356224568"/><a data-type="indexterm" data-primary="serverless" data-secondary="applications" id="idm45364356223592"/>Now that you understand something about the philosophy around serverless, what are some of the characteristics of a serverless application? Though you may get varying answers as to what serverless is, following are some traits and characteristics that are generally agreed upon by the industry.</p>










<section data-type="sect3" data-pdf-bookmark="Decreased operational responsibilities"><div class="sect3" id="idm45364356222088">
<h3>Decreased operational responsibilities</h3>

<p><a data-type="indexterm" data-primary="operational responsibilities" id="idm45364356220952"/>Serverless architectures typically allow you to shift more of your operational responsibilities to a cloud provider or third party.</p>

<p><a data-type="indexterm" data-primary="business value" id="idm45364356219656"/>When you decide to implement FaaS, the only thing you should have to worry about is the code running in your function. All of the server patching, updating, maintaining, and upgrading is no longer your responsibility. This goes back to the core of what cloud computing, and by extension serverless, attempts to offer: a way to spend less time managing infrastructure and spend more time building features and delivering business value.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Heavy use of managed services"><div class="sect3" id="idm45364356218120">
<h3>Heavy use of managed services</h3>

<p><a data-type="indexterm" data-primary="managed services" id="idm45364356216984"/>Managed services usually assume responsibility for providing a defined set of features. They are serverless in the sense that they scale seamlessly, don’t require any server operations or need to manage uptime, and, most importantly, are essentially codeless.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Benefits of a Serverless Architecture"><div class="sect2" id="idm45364356215496">
<h2>Benefits of a Serverless Architecture</h2>

<p><a data-type="indexterm" data-primary="architect" id="idm45364356214072"/>These days there are many ways to architect an application. The decisions that are made early on will impact not only the application life cycle, but also the development teams and ultimately the company or organization. In this book, I advocate for building your applications using serverless technologies and methodologies and lay out some ways in which you can do this. But what are the advantages of building your application like this, and why is serverless becoming so popular?</p>










<section data-type="sect3" data-pdf-bookmark="Scalability"><div class="sect3" id="idm45364356212616">
<h3>Scalability</h3>

<p><a data-type="indexterm" data-primary="scalability, as a benefit of serverless architecture" id="idm45364356211448"/>One of the primary advantages of going serverless is out-of-the-box scalability. When building your application, you don’t have to worry about what would happen if the application becomes wildly popular and you onboard a large number of new users quickly—the cloud provider will handle this for you.</p>

<p>The cloud provider automatically scales your application, running the code in response to each interaction. In a serverless function, your code runs in parallel and individually processes each trigger (in turn, scaling with the size of the workload).</p>

<p>Not having to worry about scaling your servers and databases is a great advantage. It’s one less thing you have to worry about when architecting your application.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Cost"><div class="sect3" id="idm45364356208824">
<h3>Cost</h3>

<p><a data-type="indexterm" data-primary="cost, as a benefit of serverless architecture" id="idm45364356207384"/>The pricing models of serverless architectures and traditional cloud-based or on-premises infrastructures differ greatly.</p>

<p>With the traditional approach, you often paid for computing resources whether or not they were utilized. This meant that if you wanted to make sure your application would scale, you needed to prepare for the largest workload you thought you might see regardless of whether you actually reached that point. This approach meant you were paying for unused resources for the majority of the life of your application.</p>

<p>With<a data-type="indexterm" data-primary="Amazon Rekognition" id="idm45364356205208"/> serverless technologies, you pay only for what you use. With FaaS, you’re billed based on the number of requests for your functions, the time it takes for your function code to execute, and the reserved memory for each function. With managed services like Amazon Rekognition, you are only charged for the images processed and minutes of video processed, etc.—again paying only for what you use.</p>

<p>This allows you to build features and applications with essentially no up-front infrastructure costs. Only if your application begins seeing increasing adoption and scaling do you begin to have to pay for the service.</p>

<p>The bill from your cloud provider is only one part of the total cost of your cloud infrastructure—there’s also the operations’ salaries. That cost decreases if you have fewer ops resources.</p>

<p>In addition, building applications in this way usually facilitates a faster time to market, decreasing overall development time and, therefore, development costs.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Developer velocity"><div class="sect3" id="idm45364354168680">
<h3>Developer velocity</h3>

<p><a data-type="indexterm" data-primary="business logic" id="idm45364354167592"/><a data-type="indexterm" data-primary="developer velocity, as a benefit of serverless architecture" id="idm45364354166888"/>With fewer features to build, developer velocity increases. Being able to spin up the types of features that are typical for most applications (e.g., databases, authentication, storage, and APIs) allows you to quickly focus on writing the core functionality and business logic for the features that you want to deliver.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Experimentation"><div class="sect3" id="idm45364354165448">
<h3>Experimentation</h3>

<p><a data-type="indexterm" data-primary="experimentation, as a benefit of serverless architecture" id="idm45364354164280"/>If you are not investing a lot of time building out repetitive features, you are able to experiment more easily and with less risk.</p>

<p><a data-type="indexterm" data-primary="risk" id="idm45364354163000"/><a data-type="indexterm" data-primary="ROI (return on investment)" id="idm45364354162296"/>When shipping a new feature, you often assess the risk (time and money involved with building the feature) against the possible return on investment (ROI). As the risk involved in trying out new things decreases, you are free to test out ideas that in the past may not have seen the light of day.</p>

<p><a data-type="indexterm" data-primary="A/B testing" id="idm45364354160856"/><a data-type="indexterm" data-primary="bucket testing" id="idm45364354160152"/><a data-type="indexterm" data-primary="split testing" id="idm45364354159480"/><em>A/B testing</em> (also known as <em>bucket testing</em> or <em>split testing</em>) is a way to compare multiple versions of an application to determine which one performs best. Because of the increase in developer velocity, serverless applications usually enable you to A/B test different ideas much more quickly and easily.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Security and stability"><div class="sect3" id="idm45364354157016">
<h3>Security and stability</h3>

<p><a data-type="indexterm" data-primary="security, as a benefit of serverless architecture" id="idm45364354155816"/><a data-type="indexterm" data-primary="stability, as a benefit of serverless architecture" id="idm45364354155144"/>Because the services that you are subscribing to are the core competency of the service provider maintaining them, you are usually getting something that is much more polished and more secure than you could have built yourself. Imagine that a company’s core business model has been, for many years, the delivery of a pristine authentication service, having fixed issues and edge cases for thousands of companies and customers.</p>

<p>Now, imagine trying to replicate a service like that within your own team or organization. Though this is completely possible, choosing to use a service built and maintained by those whose only job is to build and maintain that exact thing is a safe bet that will ultimately save you time and money.</p>

<p>Another advantage of using these service providers is that they will strive for the least amount of downtime possible. This means that they are taking on the burden of not only building, deploying, and maintaining these services, but also doing everything they can to make sure that they are stable.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Less code"><div class="sect3" id="idm45364354152232">
<h3>Less code</h3>

<p><a data-type="indexterm" data-primary="code" data-secondary="as a benefit of serverless architecture" id="idm45364354151032"/>Most engineers will agree that, at the end of the day, code is a liability. What has value is the feature that the code delivers, not the code itself. When you find ways to deliver these features while simultaneously limiting the amount of code you need to maintain, and even doing away with the code completely, you are reducing overall complexity in your application.</p>

<p>With less complexity comes fewer bugs, easier onboarding for new engineers, and overall less cognitive load for those maintaining and adding new features. A developer can hook into these services and implement features with no knowledge of the actual backend implementation and with little to no backend code at all.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Different Implementations of Serverless"><div class="sect2" id="idm45364354148552">
<h2>Different Implementations of Serverless</h2>

<p><a data-type="indexterm" data-primary="serverless" data-secondary="implementations of" id="idm45364354147144"/>Let’s take a look at the different ways that you can build serverless applications as well as some of the differences between them.</p>










<section data-type="sect3" data-pdf-bookmark="Serverless Framework"><div class="sect3" id="idm45364354145768">
<h3>Serverless Framework</h3>

<p><a data-type="indexterm" data-primary="Microsoft Azure" id="idm45364354144600"/><a data-type="indexterm" data-primary="Serverless Framework" id="idm45364354143896"/><a data-type="indexterm" data-primary="JAWS" id="idm45364354143224"/><a data-type="indexterm" data-primary="Node.js" id="idm45364354142552"/>One of the first serverless implementations, the Serverless Framework, is the most popular. It is a free and open source framework, launched in October 2015 under the name JAWS, and written using Node.js. At first, the Serverless Framework only supported AWS, but then it added support for cloud providers like Google and Microsoft Azure, among others.</p>

<p><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="Serverless Framework and" id="idm45364354141128"/><a data-type="indexterm" data-primary="serverless.yml file" id="idm45364354140136"/><a data-type="indexterm" data-primary="function code, Serverless Framework and" id="idm45364354139464"/>The Serverless Framework utilizes a combination of a configuration file (<em>serverless.yml</em>), CLI, and function code to provide a nice experience for people wanting to deploy serverless functions and other AWS services to the cloud from a local environment. Getting up and running with the Serverless Framework can present a somewhat steep learning curve, especially for developers new to cloud computing. There is much terminology to learn and a lot that goes into understanding how cloud services work in order to build anything more than just a “Hello World” application.</p>

<p>Overall, the Serverless Framework is a good option if you understand to some extent how cloud infrastructure works, and are looking for something that will work with other cloud providers in addition to AWS.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="The AWS Serverless Application Model"><div class="sect3" id="idm45364354136872">
<h3>The AWS Serverless Application Model</h3>

<p><a data-type="indexterm" data-primary="AWS SAM (Serverless Application Model)" id="idm45364354135464"/><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="AWS SAM (Serverless Application Model) and" id="idm45364354134696"/>The <a href="https://oreil.ly/ApIoW">AWS Serverless Application Model</a> (AWS SAM) is an open source framework, released November 18, 2016, and built and maintained by AWS and the community. This framework only supports AWS.</p>

<p><a data-type="indexterm" data-primary="API Gateway" data-secondary="APIs" id="idm45364354132536"/><a data-type="indexterm" data-primary="AWS Lambda functions" id="idm45364354131560"/><a data-type="indexterm" data-primary="Amazon DynamoDB tables" id="idm45364354130888"/><a data-type="indexterm" data-primary="YAML" id="idm45364354130216"/>SAM allows you to build serverless applications by defining the API Gateway APIs, AWS Lambda functions, and Amazon DynamoDB tables needed by your serverless application in YAML files. It uses a combination of YAML configuration and function code and a CLI to create, manage, and deploy serverless applications.</p>

<p><a data-type="indexterm" data-primary="CloudFormation" id="idm45364354128840"/><a data-type="indexterm" data-primary="Amazon CloudFormation" id="idm45364354128136"/>One advantage of SAM is that it is an extension of AWS CloudFormation, which is very powerful and allows you to do almost anything in AWS. This can also be a disadvantage to developers new to cloud computing and not familiar with AWS services, permissions, roles, and terminology, as you have to already be familiar with how the services work, the naming conventions to set them up, and how to wire it all together.</p>

<p>SAM is a good choice if you are familiar with AWS and are only deploying your serverless applications to AWS.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Amplify Framework"><div class="sect3" id="idm45364356788776">
<h3>Amplify Framework</h3>

<p><a data-type="indexterm" data-primary="Amplify Framework" id="idm45364356787688"/>The Amplify Framework is a combination of four things: CLI, client library, toolchain, and web-hosting platform. Amplify’s purpose is to provide an easy way for developers to build and deploy full stack web and mobile applications that leverage the cloud. It enables not only features such as serverless functions and authentication, but also GraphQL APIs, machine learning (ML), storage, analytics, push notifications, and more.</p>

<p><a data-type="indexterm" data-primary="entry point" id="idm45364356786152"/>Amplify provides an easy entry point into the cloud by doing away with terminology and acronyms that may be unfamiliar to newcomers to AWS and instead uses a category-name approach for referring to services. Rather than referring to the authentication service as Amazon Cognito, it’s referred to as <em>auth</em>, and the framework just uses Amazon Cognito under the hood.<a data-type="indexterm" data-primary="client library" id="idm45364356784616"/><a data-type="indexterm" data-primary="Amplify client library" id="idm45364356783832"/><a data-type="indexterm" data-primary="toolchain" id="idm45364356783160"/><a data-type="indexterm" data-primary="hosting platform" id="idm45364356782488"/><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="defined" id="idm45364356781816"/></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45364356780744">
<h5>How Do the Four Pieces Fit Together?</h5>
<ul>
<li>
<p>The CLI allows you to create, configure, and deploy cloud services from the command line.</p>
</li>
<li>
<p>The Client library allows you to connect to and interact with these cloud services from your web or mobile application.</p>
</li>
<li>
<p>The toolchain helps facilitate and speed development by doing things like generating code and serverless function boilerplates.</p>
</li>
<li>
<p>The hosting platform allows you to deploy your application to a live domain complete with atomic deployments, continuous integration (CI), continuous deployment (CD), custom domains, and more.</p>
</li>
</ul>
</div></aside>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Other options"><div class="sect3" id="idm45364356774600">
<h3>Other options</h3>

<p><a data-type="indexterm" data-primary="abstractions" id="idm45364356773400"/><a data-type="indexterm" data-primary="Apex" id="idm45364356772696"/><a data-type="indexterm" data-primary="Vercel" id="idm45364356772024"/><a data-type="indexterm" data-primary="Cloudflare Workers" id="idm45364356771352"/><a data-type="indexterm" data-primary="Netlify Functions" id="idm45364356770680"/>More companies have started providing abstractions over serverless functions, usually intending to improve the negative user experience traditionally associated with working directly with AWS Lambda. A few popular options among these are Apex, Vercel, Cloudflare Workers, and Netlify Functions.</p>

<p>Many of these tools and frameworks still actually use AWS or some other cloud provider under the hood, so you are essentially going to be paying more in exchange for what they argue is a better user experience. <a data-type="indexterm" data-primary="complex object storage" id="idm45364356768968"/>Most of these tools do not offer much of the other suite of services available from AWS or other cloud providers; things like authentication, AI and ML services, complex object storage, and analytics may or may not be part of their offerings.</p>

<p>If you are interested in learning other ways of developing serverless applications, I would recommend checking out these options.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Introduction to AWS"><div class="sect1" id="idm45364356260216">
<h1>Introduction to AWS</h1>

<p><a data-type="indexterm" data-primary="AWS (Amazon Web Service)" data-secondary="about" id="idm45364356765816"/>In this section, I’ll give an overview of AWS and talk about why something like the Amplify Framework exists.</p>








<section data-type="sect2" data-pdf-bookmark="About AWS"><div class="sect2" id="idm45364356764488">
<h2>About AWS</h2>

<p><a data-type="indexterm" data-primary="Amazon SQS (Simple Queue Service)" id="idm45364356763320"/><a data-type="indexterm" data-primary="Amazon S3" data-secondary="about" id="idm45364356762600"/><a data-type="indexterm" data-primary="Amazon EC2" id="idm45364356761656"/>AWS, a subsidiary of Amazon, was the first company to provide on-demand cloud computing platforms to developers. It first launched in 2004 with a single service: Amazon Simple Queue Service (Amazon SQS). In 2006, they officially relaunched with a total of three services: Amazon SQS, Amazon S3, and Amazon EC2. Since 2006, AWS has grown and remains the largest cloud computing provider in the world, continuing to add services every year. AWS now offers more than two hundred services.</p>

<p>With the current state of cloud computing moving more toward serverless technologies, the barrier to entry is being lowered. However, it is still often tough for either a frontend developer or someone new to cloud computing to get started.</p>

<p>With this new serverless paradigm, AWS saw an opportunity to create a framework that focused on enabling these traditionally frontend developers and developers new to cloud computing to get started building cloud applications.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Full Stack Serverless on AWS"><div class="sect2" id="idm45364356758808">
<h2>Full Stack Serverless on AWS</h2>

<p><a data-type="indexterm" data-primary="AWS (Amazon Web Service)" data-secondary="full stack serverless on" id="idm45364356757640"/><a data-type="indexterm" data-primary="full stack" id="idm45364356756584"/><em>Full stack serverless</em> is about providing developers with everything needed on both ends of the stack to accomplish their objective of building scalable applications as quickly as possible. Here, we’ll look at how you can build applications in this way using AWS tools and services.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Amplify CLI"><div class="sect2" id="idm45364356755000">
<h2>Amplify CLI</h2>

<p><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="about" id="idm45364356753560"/>If you’re starting out with AWS, the sheer number of services can be overwhelming. In addition to the many services to sort between, each service often has its own steep learning curve. To help ease this, AWS has created the <em>Amplify CLI</em>.</p>

<p><a data-type="indexterm" data-primary="entry point" id="idm45364356751512"/>The Amplify CLI provides an easy entry point for developers wanting to build applications on AWS. The CLI allows developers to create, configure, update, and delete cloud services directly from their frontend environment.</p>

<p><a data-type="indexterm" data-primary="CloudFormation" id="idm45364356750184"/><a data-type="indexterm" data-primary="storage" data-seealso="Amazon S3" id="idm45364356749320"/><a data-type="indexterm" data-primary="auth" data-seealso="Amazon Cognito" id="idm45364356748376"/><a data-type="indexterm" data-primary="analytics" id="idm45364356379560"/>Instead of a service-name approach (as used by the AWS Console and many other tools, like CloudFormation), the CLI takes a category-name approach. AWS has many service names (for example, Amazon S3, Amazon Cognito, and Amazon Pinpoint), which can be confusing to new developers. Rather than using the service names to create and configure these services, the CLI uses names like <em>storage</em> (Amazon S3), <em>auth</em> (Amazon Cognito), and <em>analytics</em> (Amazon Pinpoint) to give you a way to understand what the service actually does versus simply giving the service name.</p>

<p>The CLI has a host of commands that allow you to create, update, configure, and remove services without having to leave your frontend environment. You can also spin up and deploy new environments using the CLI in order to test out new features without affecting the main environment.</p>

<p>Once you’ve created and deployed features using the CLI, you can then use the Amplify client libraries to begin interacting with the services from your client-side application.</p>










<section data-type="sect3" class="less_space pagebreak-before" data-pdf-bookmark="Amplify client"><div class="sect3" id="idm45364356375608">
<h3>Amplify client</h3>

<p><a data-type="indexterm" data-primary="SDK (software development kit)" id="idm45364356373928"/><a data-type="indexterm" data-primary="Amplify client" id="idm45364356373256"/><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="Amplify client" id="idm45364356372584"/>Building full stack applications requires a combination of both client-side tooling and backend services. In the past, the main way to interact with AWS services was using an AWS software development kit (SDK) such as Java, .NET, Node.js, and Python. These SDKs work well, but none of them are particularly well-suited for client-side development. Before Amplify, there was no simple method for building client-side applications using AWS. If you look at the documentation for the AWS Node.js SDK, you’ll also notice that it presents a steep learning curve for developers new to AWS.</p>

<p><a data-type="indexterm" data-primary="native Android" id="idm45364356370648"/><a data-type="indexterm" data-primary="native iOS" id="idm45364356369944"/>The Amplify client is a library made especially to provide an easy-to-use API for JavaScript applications that need to interact with AWS services. Amplify also has client SDKs for React Native, native iOS, and native Android.</p>

<p><a data-type="indexterm" data-primary="persist" id="idm45364356368648"/><a data-type="indexterm" data-primary="localStorage" id="idm45364356367784"/><a data-type="indexterm" data-primary="security tokens" id="idm45364356367112"/><a data-type="indexterm" data-primary="abstractions" id="idm45364356366440"/><a data-type="indexterm" data-primary="AsyncStorage" id="idm45364356365768"/><a data-type="indexterm" data-primary="IdTokens" id="idm45364356365096"/><a data-type="indexterm" data-primary="AccessTokens" id="idm45364356364424"/><a data-type="indexterm" data-primary="WebSocket" id="idm45364356363752"/><a data-type="indexterm" data-primary="GraphQL" data-secondary="about" id="idm45364356363080"/>The approach that the Amplify client takes is to provide a higher level of abstraction and bake in best practices to provide a declarative, easy-to-use API. At the same time, it gives you full control over the interactions with your backend. It’s also built especially with the client in mind, with features like WebSocket and GraphQL subscription support. It utilizes localStorage for the browser and AsyncStorage for React Native to store security tokens like <code>IdTokens</code> and <code>AccessTokens</code> to persist user authentication.</p>

<p><a data-type="indexterm" data-primary="complex object storage" id="idm45364356360536"/><a data-type="indexterm" data-primary="Angular" id="idm45364356359832"/><a data-type="indexterm" data-primary="Ionic" id="idm45364356359160"/>Amplify also provides UI components for popular frontend and mobile frameworks including React, React Native, Vue, Angular, Ionic, native Android, and native iOS. These framework-specific components allow you to quickly get up and running with common features like authentication and complex object storage and retrieval without having to build out the frontend UI and deal with state.</p>

<p><a data-type="indexterm" data-primary="REST (Representational State Transfer)" id="idm45364356357704"/>The Amplify Framework does not support the entire suite of AWS services; instead, it supports a subset of them with almost all of them falling into the category of serverless. Using Amplify, it wouldn’t make much sense to offer support for interacting with with EC2, but it makes a lot of sense to offer support for working with Representational State Transfer (REST) and GraphQL APIs.</p>

<p>Amplify was created as an end-to-end solution to fill a previously unfilled gap, but it also encompasses a new way to build full stack cloud applications.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="AWS AppSync"><div class="sect3" id="idm45364356355816">
<h3>AWS AppSync</h3>

<p><a data-type="indexterm" data-primary="API layer" id="idm45364356354536"/><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="AWS AppSync" id="idm45364356353832"/><a data-type="indexterm" data-primary="AWS AppSync" data-secondary="about" id="idm45364356352888"/>AWS AppSync is a managed <em>API layer</em> that uses GraphQL to make it easy for applications to interact with any data source, REST API, or microservice.</p>

<p><a data-type="indexterm" data-primary="microservice architecture" id="idm45364356351016"/>The API layer is one of the most important parts of an application. Modern applications typically interact with a large number of backend services and APIs; things like databases, managed services, third-party APIs, and storage solutions, among others. <em>Microservice architecture</em> is the usual term used for a large application built using a combination of modular components or services.</p>

<p>Most services and APIs will have varying implementation details, which creates a challenge when you’re working with a microservice architecture. This leads to inconsistent and sometimes messy code, as well as more cognitive load on the frontend developers making requests to these APIs.</p>

<p>One good approach to working with a microservice architecture is to provide a consistent API gateway layer that then takes all of the requests and forwards them on to the backend services. This allows a consistent interaction layer for your client to interact with, making development easier on the frontend.</p>

<p><a data-type="indexterm" data-primary="Facebook" id="idm45364356347624"/><a data-type="indexterm" data-primary="queries (reads)" id="idm45364356346696"/><a data-type="indexterm" data-primary="mutations (writes/updates)" id="idm45364356346024"/><a data-type="indexterm" data-primary="subscriptions (real-time data)" id="idm45364356345336"/>GraphQL, a technology created and open sourced by Facebook, offers an especially good abstraction for creating an API gateway. GraphQL introduces a defined and consistent specification for interacting with APIs in the form of three operations: <em>queries</em> (reads), <em>mutations</em> (writes/updates), and <em>subscriptions</em> (real-time data). These operations are defined as part of a main <em>schema</em> that also provides a contract between the client and the server in the form of GraphQL types. GraphQL operations are not bound to any specific data source, so you as a developer are free to use them to interact with anything from a database, an HTTP endpoint, a microservice, or even a serverless function.</p>

<p>Typically, when building a GraphQL API, you need to deal with building, deploying, maintaining, and configuring your own API. With AWS AppSync, you can instead offload the server and API management as well as the security to AWS.</p>

<p>Modern applications often also have concerns such as real-time and offline support. Another benefit of AppSync is that it has built-in support for offline (Amplify client SDKs) as well as real time (GraphQL subscriptions) to enable developers to build these types of applications.</p>

<p>In this book, you will be using AWS AppSync along with various data sources (like DynamoDB for NoSQL and AWS Lambda for serverless functions) as the main API layer.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Introduction to the AWS Amplify CLI"><div class="sect1" id="idm45364356340200">
<h1>Introduction to the AWS Amplify CLI</h1>

<p><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="about" id="idm45364356338792"/>You will be using Amplify CLI throughout this book to create and manage your cloud services. To learn how it works, you’ll be creating and deploying a service using the CLI in this section. Once the service is deployed, you’ll also learn how to remove it and then delete any backend resources associated with the deployment. Let’s take a look at how you can create your first service.</p>








<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Installing and Configuring the Amplify CLI"><div class="sect2" id="idm45364356337160">
<h2>Installing and Configuring the Amplify CLI</h2>

<p><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="configuring" id="idm45364356442632"/><a data-type="indexterm" data-primary="configuring" data-secondary="AmplifyCLI" id="idm45364356441656"/><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="installing" id="idm45364356440712"/><a data-type="indexterm" data-primary="installing" data-secondary="Amplify CLI" id="idm45364356439768"/>To get started, you first need to install and configure the Amplify CLI:</p>

<pre data-type="programlisting" data-code-language="shell">~ npm install -g @aws-amplify/cli</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="indexterm" data-primary="Node Version Manager" id="idm45364351281720"/><a data-type="indexterm" data-primary="Node.js" id="idm45364356046200"/><a data-type="indexterm" data-primary="installing" data-secondary="Node.js" id="idm45364349817240"/>To use the CLI, you will first need to have Node.js version 10.x or greater and npm version 5.x or greater installed on your machine. To install Node.js, I recommend either visiting the <a href="https://nodejs.org/en">Node.js installation page</a> and following the installation instructions or using <a href="https://github.com/nvm-sh/nvm">Node Version Manager</a> (NVM).</p>
</div>

<p><a data-type="indexterm" data-primary="IAM (identity and access management)" data-secondary="user" id="idm45364354617032"/>After the CLI has been installed, you next need to configure it with an identity and access management (IAM) user in your AWS account. To do so, you’ll configure the CLI with a reference to a set of user credentials (access key ID and secret access key). Using these credentials, you’ll be able to create AWS services on behalf of this user directly from the CLI.</p>

<p><a data-type="indexterm" data-primary="configure command" id="idm45364360466232"/>To create a new user and configure the CLI, you’ll run the <code>configure</code> command:</p>

<pre data-type="programlisting" data-code-language="shell">~ amplify configure</pre>

<p>This will walk you through the following steps:</p>
<ol>
<li>
<p><em>Specify the AWS region.</em></p>

<p>This will allow you to choose the region in which you’d like to create your user (and, by extension, the services associated with this user). Choose the region closest to you or a preferred region.</p>
</li>
<li>
<p><em>Specify the username.</em></p>

<p>This name will be the local reference of the user that you will be creating in your AWS account. I suggest using a name that you’ll be able to recognize later when referencing it, such as <em>amplify-cli-us-east-1-user</em> or <em>mycompany-cli-admin</em>.</p>
</li>

</ol>

<p>Once you enter your name, the CLI will open up the AWS IAM dashboard. From here, you can accept the defaults by clicking Next: Permissions, Next: Tags, Next: Review, and Create user to create the IAM user.</p>

<p>In the next screen, you will be given the IAM user credentials: the access key ID and secret access key. See <a data-type="xref" href="#fig1a">Figure 1-1</a>.</p>

<figure><div id="fig1a" class="figure">
<img src="Images/fssl_0101.png" alt="AWS IAM Dashboard IAM User" width="1440" height="512"/>
<h6><span class="label">Figure 1-1. </span>AWS IAM dashboard</h6>
</div></figure>

<p>Back in the CLI, paste in the values for the access key ID and secret access key. Now you’ve successfully configured the CLI and you can begin creating new services.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Initializing Your First Amplify Project"><div class="sect2" id="idm45364351468120">
<h2>Initializing Your First Amplify Project</h2>

<p><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="initializing first project" id="idm45364356484696"/><a data-type="indexterm" data-primary="initializing projects" id="idm45364350089720"/><a data-type="indexterm" data-primary="projects" data-secondary="initializing" id="idm45364350929864"/>Now that the CLI has been installed and configured, you can create your first project. This step is usually done within the root of your client application. Since you will be using React for most of this book, we’ll start by initializing a new React project:</p>

<pre data-type="programlisting" data-code-language="shell">~ npx create-react-app amplify-app

<code class="c"># after creating the React app, change into the new directory</code>
~ <code class="nb">cd </code>amplify-app</pre>

<p>Now you need to install the Amplify that you’ll be using on the client. The libraries you’ll be using are AWS Amplify and AWS Amplify React for the React-specific UI components:</p>

<pre data-type="programlisting" data-code-language="shell">~ npm install aws-amplify @aws-amplify/ui-react</pre>

<p><a data-type="indexterm" data-primary="init command" id="idm45364350979672"/>Next, you can create an Amplify project. To do so, you’ll run the <code>init</code> command:</p>

<pre data-type="programlisting" data-code-language="shell">~ amplify init</pre>

<p>This will walk you through the following steps:</p>
<ol>
<li>
<p><em>Enter a name for the project.</em></p>

<p>This will be the local name for the project, usually something that describes what the project is or what it does.</p>
</li>
<li>
<p><em>Enter a name for the environment.</em></p>

<p>This will be a reference to the initial environment that you will be working in. Typical environments in this workflow could be something like <em>dev</em>, <em>local</em>, or <em>prod</em> but could be anything that makes sense to you.</p>
</li>
<li>
<p><em>Choose your default editor.</em></p>

<p>This will set your editor preference. The CLI will later use this preference to open your text editor with files that are part of the current project.</p>
</li>
<li>
<p><em>Choose the type of app that you’re building.</em></p>

<p>This will determine whether the CLI should configure, build, and run commands if you are using JavaScript. For this example, choose <em>javascript</em>.</p>
</li>
<li>
<p><em>What JavaScript framework are you using?</em></p>

<p>This will determine a few base build and start commands. For this example, choose <em>react</em>.</p>
</li>
<li>
<p><em>Choose your source directory path.</em></p>

<p>This allows you to set the directory where your source code will live. For this example, choose <em>src</em>.</p>
</li>
<li>
<p><em>Choose your distribution directory path.</em></p>

<p><a data-type="indexterm" data-primary="favicon" id="idm45364355441240"/>For web projects, this will be the folder containing the complied JavaScript source code as well as your favicon, HTML, and CSS files. For this example, choose <em>build</em>.</p>
</li>
<li>
<p><em>Choose your build command.</em></p>

<p>This specifies the command for compiling and bundling your JavaScript code. For this example, use <em>npm run-script build</em>.</p>
</li>
<li>
<p><em>Choose your start command.</em></p>

<p>This specifies the command to server your application locally. For this example, use <em>npm run-script start</em>.</p>
</li>
<li>
<p><em>Do you want to use an AWS profile?</em></p>

<p>Here, choose <em>Y</em> and then pick the AWS profile you created when you ran <code>amplify configure</code>.</p>
</li>

</ol>

<p>Now, the Amplify CLI will initialize your new Amplify project. When the initialization is complete, you will have two additional resources created for you in your project: a file called <em>aws-exports</em> located in the <em>src</em> directory and a folder named <em>amplify</em> located in your root directory.</p>
<dl>
<dt>The aws-exports file</dt>
<dd>
<p><a data-type="indexterm" data-primary="aws-exports.js file" id="idm45364354619240"/>The <em>aws-exports</em> file is a key-value pairing of the resource categories created for you by the CLI along with their credentials.</p>
</dd>
<dt>The amplify folder</dt>
<dd>
<p><a data-type="indexterm" data-primary="amplify folder" id="idm45364350194872"/>This folder holds all of the code and configuration files for your Amplify project. In this folder you’ll see two subfolders: the <em>backend</em> and <em>#current-cloud-backend</em> folders.</p>
<dl>
<dt>The <em>backend</em> folder</dt>
<dd>
<p><a data-type="indexterm" data-primary="backend folder" id="idm45364354305336"/>This folder contains all of the local code for your project such as the GraphQL schema for an AppSync API, the source code for any serverless functions, and infrastructure as code representing the current local status of the Amplify project.</p>
</dd>
<dt>The <em>#current-cloud-backend</em> folders</dt>
<dd>
<p><a data-type="indexterm" data-primary="#current-cloud-backend folders" data-primary-sortas="current" id="idm45364356434424"/>This folder holds the code and configurations that reflect what resources were deployed in the cloud with your last Amplify <code>push</code> command. It helps the CLI differentiate between the configuration of the resources already provisioned in the cloud and what is currently in your local <em>backend</em> directory (which reflects your local changes).</p>
</dd>
</dl>
</dd>
</dl>

<p>Now that you’ve initialized your project, you can add your first cloud service: <span class="keep-together"><em>authentication</em>.</span></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating and Deploying Your First Service"><div class="sect2" id="idm45364355975704">
<h2>Creating and Deploying Your First Service</h2>

<p><a data-type="indexterm" data-primary="add command" id="idm45364356430840"/><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="creating services" id="idm45364356430104"/><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="deploying services" id="idm45364356429160"/><a data-type="indexterm" data-primary="deploying" data-secondary="services" id="idm45364356428216"/><a data-type="indexterm" data-primary="services" data-secondary="creating" id="idm45364356427272"/><a data-type="indexterm" data-primary="services" data-secondary="deploying" id="idm45364356426328"/>To create a new service, you can use the <code>add</code> command from Amplify:</p>

<pre data-type="programlisting" data-code-language="shell">~ amplify add auth</pre>

<p>This will walk you through the following steps:</p>
<ol>
<li>
<p><em>Do you want to use the default authentication and security configuration?</em></p>

<p>This gives you the option of creating an authentication service using a default configuration (MFA on sign-up, password at sign-in), creating an authentication configuration with social providers, or creating a completely custom authentication configuration. For this example, choose <em>Default configuration</em>.</p>
</li>
<li>
<p><em>How do you want users to be able to sign in?</em></p>

<p>This will allow you to specify the required sign-in property. For this example, accept the default by choosing <em>Username</em>.</p>
</li>
<li>
<p><em>Do you want to configure advanced settings?</em></p>

<p>This will allow you to walk through additional advanced settings for things like additional sign-up attributes and Lambda triggers. You do not need any of these for this example, so accept the default by choosing <em>No, I am done</em>.</p>

<p>Now, you’ve successfully configured the authentication service and are now ready to deploy. To deploy the authentication service, you can run the <code>push</code> command:</p>

<pre data-type="programlisting" data-code-language="shell">~ amplify push</pre>
</li>
<li>
<p><em>Are you sure you want to continue?</em></p>

<p>Choose <em>Y</em>.</p>
</li>

</ol>

<p>After the deployment is complete, your authentication service has successfully been created. Congratulations, you’ve deployed your first feature. Now, let’s test it out.</p>

<p>There are several ways to interact with the authentication service in a React application. You can use the <code>Auth</code> class from Amplify, which has over 30 methods available (methods like <code>signUp</code>, <code>signIn</code>, <code>signOut</code>, etc.), or you can use the framework-specific components like <code>withAuthenticator</code> that will scaffold out an entire authentication flow, complete with preconfigured UI. Let’s try out the <code>withAuthenticator</code> higher-order (HOC) component.</p>

<p>First, configure the React app to work with Amplify. To do so, open <em>src/index.js</em> and add the following code below the last <code>import</code> statement:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">import</code> <code class="nx">Amplify</code> <code class="nx">from</code> <code class="s1">'aws-amplify'</code>
<code class="kr">import</code> <code class="nx">config</code> <code class="nx">from</code> <code class="s1">'./aws-exports'</code>
<code class="nx">Amplify</code><code class="p">.</code><code class="nx">configure</code><code class="p">(</code><code class="nx">config</code><code class="p">)</code></pre>

<p>Now, the app has been configured and you can begin interacting with the authentication service. Next, open <em>src/App.js</em> and update the file with the following code:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s1">'react'</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">withAuthenticator</code><code class="p">,</code> <code class="nx">AmplifySignOut</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'@aws-amplify/ui-react'</code>

<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>
  <code class="k">return</code> <code class="p">(</code>
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="nx">Hello</code> <code class="nx">from</code> <code class="nx">AWS</code> <code class="nx">Amplify</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>
      <code class="o">&lt;</code><code class="nx">AmplifySignOut</code> <code class="o">/&gt;</code>
    <code class="o">&lt;</code><code class="err">/div&gt;</code>
  <code class="p">)</code>
<code class="p">}</code>

<code class="kr">export</code> <code class="k">default</code> <code class="nx">withAuthenticator</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code></pre>

<p>At this point, you can test it out by launching the app:</p>

<pre data-type="programlisting" data-code-language="js"><code class="o">~</code> <code class="nx">npm</code> <code class="nx">start</code></pre>

<p>Now, your app should be launched with the preconfigured authentication flow in front of it. See <a data-type="xref" href="#fig1b">Figure 1-2</a>.</p>

<figure><div id="fig1b" class="figure">
<img src="Images/fssl_0102.png" alt="AWS Amplify withAuthenticator Component" width="780" height="644"/>
<h6><span class="label">Figure 1-2. </span>withAuthenticator HOC component</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Deleting the Resources"><div class="sect2" id="idm45364354964968">
<h2>Deleting the Resources</h2>

<p><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="deleting resources" id="idm45364349365176"/><a data-type="indexterm" data-primary="deleting" data-secondary="resources" id="idm45364349364200"/><a data-type="indexterm" data-primary="resources, deleting" id="idm45364349363256"/>Once you no longer need a feature or a project, you can remove it using the CLI.</p>

<p><a data-type="indexterm" data-primary="remove command" id="idm45364349362200"/>To remove an individual feature, you can run the <code>remove</code> command:</p>

<pre data-type="programlisting">~ amplify remove auth</pre>

<p><a data-type="indexterm" data-primary="delete command" id="idm45364349339928"/>To delete an entire Amplify project along with all of the corresponding resources that have been deployed in your account, you can run the <code>delete</code> command:</p>

<pre data-type="programlisting">~ amplify delete</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45364349337704">
<h1>Summary</h1>

<p><a data-type="indexterm" data-primary="cloud computing, growth of" id="idm45364349336584"/>Cloud computing is growing at a rapid pace as more and more companies have come to rely on the cloud for the majority of their workloads. With this growth in usage, knowledge of cloud computing is becoming a valuable addition to your skill set.</p>

<p>The paradigm of serverless, a subset of cloud computing, is also rapidly growing in popularity among business users, as it offers all of the benefits of cloud computing while also featuring automatic scaling, while needing little to no maintenance.</p>

<p>Tools like the Amplify Framework are making it easier for developers of all backgrounds to get up and running with cloud as well as serverless computing. In the next chapters, you’ll learn how to build real-world full stack serverless applications in the cloud, utilizing cloud services and the Amplify Framework.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45364356233672"><sup><a href="ch01.xhtml#idm45364356233672-marker">1</a></sup> Eric Jonas, Johann Schleier-Smith et al. “Cloud Programming Simplified: A Berkeley View on Serverless Computing” (Feb. 10, 2019), <a href="http://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.html"><em class="hyperlink">http://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.html</em></a>.</p></div></div></section></div>



  </body></html>