- en: Chapter 8\. Helper Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of TypeScript’s strengths is the ability to derive types from other types.
    This allows you to define relationships between types, where updates in one type
    trickle through to all derived types automatically. This reduces maintenance and
    ultimately results in more robust type setups.
  prefs: []
  type: TYPE_NORMAL
- en: When creating derived types, we usually apply the same type modifications but
    in different combinations. TypeScript already has a set of [built-in utility types](https://oreil.ly/inM2y),
    some of which we’ve already seen in this book. But sometimes they are not enough.
    Some situations require you either to apply known techniques differently or to
    dig deep into the inner workings of the type system to produce the desired result.
    You might need your own set of helper types.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduces you to the concept of helper types and shows you some
    use cases where a custom helper type expands your ability to derive types from
    others tremendously. Each type is designed to work in different situations, and
    each type should teach you a new aspect of the type system. Of course, the list
    of types you see here is by no means complete, but they give you a good entry
    point and enough resources to branch out.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, TypeScript’s type system can be seen as its own functional meta-programming
    language, where you combine small, single-purpose helper types with bigger helper
    types to make type derivates as easy as applying a single type to your existing
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Setting Specific Properties Optional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to derive types where you set specific properties optional.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a custom helper type `SetOptional` that intersects two object types:
    one that maps over all selected properties using the optional mapped type modifier
    and one that maps over all remaining properties.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All your models in your TypeScript project are set and defined, and you want
    to refer to them throughout your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: One situation that occurs pretty often is that you need something that looks
    like `Person` but does not require all properties to be set; some of them can
    be *optional*. This will make your API more open to other structures and types
    that are of similar shape but lack one or two fields. You don’t want to maintain
    different types (see [Recipe 12.1](ch12.html#ch12_low_maintenance_types)) but
    rather derive them from the original model, which is still in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript has a built-in helper type called `Partial<T>` that modifies all
    properties to be optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s a *mapped type* that maps out over all keys and uses the *optional mapped
    type modifier* to set each property to optional. The first step in making a `SetOptional`
    type is to reduce the set of keys that can be set as optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *optional mapped type modifier* applies the symbol for an optional property—the
    question mark—to a set of properties. You learned about mapped type modifiers
    in [Recipe 4.5](ch04.html#ch04_new_object_types).
  prefs: []
  type: TYPE_NORMAL
- en: 'In `SelectPartial<T, K extends keyof T>`, we don’t map over all keys, just
    a subset of keys provided. With the `extends keyof T` generic constraint, we make
    sure that we pass only valid property keys. If we apply `SelectPartial` to `Person`
    to select `"age"`, we end up with a type where we see *only* the `age` property,
    which is set to optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first half is done: everything we want to set as optional is optional.
    But the rest of the properties are missing. Let’s get them back to the object
    type.'
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way of extending an existing object type with more properties is
    to create an intersection type with another object type. So in our case, we take
    what we’ve written in `SelectPartial` and intersect it with a type that includes
    all remaining keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get all remaining keys by using the `Exclude` helper type. `Exclude<T,
    U>` is a *conditional type* that compares two sets. If elements from set `T` are
    in `U`, they will be removed using `never`; otherwise, they stay in the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This works in contrast to `Extract<T, U>` which we described in [Recipe 5.3](ch05.html#ch05_grouping_elements).
    `Exclude<T, U>` is a *distributive conditional type* (see [Recipe 5.2](ch05.html#ch05_filtering_never))
    and distributes the conditional type over every element of a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we want! In `SetOptional`, we create one type that *picks*
    all selected keys and makes them optional, then we *exclude* the same keys from
    the bigger set of all of the object’s keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The intersection of both types is the new object type, which we can use with
    any model we like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to make more than one key optional, we need to provide a union type
    with all desired property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript not only allows you to define types like this yourself but also
    has a set of built-in helper types that you can easily combine for similar effect.
    We could write the same type `SetOptional` solely based on helper types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Pick<T, K>` selects keys `K` from object `T`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Omit<T, K>` selects everything but `K` from object `T` (using `Exclude` under
    the hood).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And we already learned what `Partial<T>` does.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on how you like to read types, this combination of helper types can
    be easier to read and understand, especially since the built-in types are much
    better known among developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one problem: if you hover over your newly generated types, TypeScript
    will show you how the type is made, not what the actual properties are. With the
    `Remap` helper type from [Recipe 8.3](#ch08_remapping), we can make our types
    more readable and usable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you think about your type arguments as a function interface, you might want
    to think about your type parameters as well. One optimization you could do is
    to set the second argument—the selected object keys—to a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: With `K extends keyof T = keyof T`, we can make sure that we set all property
    keys as optional, and only select specific ones if we need them. Our helper type
    just became a little bit more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same vein, you can start creating types for other situations, like `SetRequired`,
    where you want to make sure that some keys are definitely required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or `OnlyRequired`, where all keys you provide are required, but the rest are
    optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The best thing: you end up with an arsenal of helper types that can be used
    throughout multiple projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Modifying Nested Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object helper types like `Partial`, `Required`, and `Readonly` modify only the
    first level of an object and won’t touch nested object properties.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create recursive helper types that do the same operation on nested objects.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Say that your application has different settings that can be configured by
    users. To make it easy for you to extend settings over time, you store only the
    difference between a set of defaults and the settings your user configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `applySettings` takes both the defaults and the settings from
    your users. You defined them as `Partial<Settings>`, since the user needs to provide
    only *some* keys; the rest will be taken from the default settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This works really well if you need to set certain properties on the first level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'But this causes problems if you want to modify specific properties deeper down
    in your object, like setting `subtitles` to `active`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript complains that for `subtitles` you need to provide the entire object.
    This is because `Partial<T>`—like its siblings `Required<T>` and `Readonly<T>`—modifies
    only the first level of an object. Nested objects will be treated as simple values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To change this, we need to create a new type called `DeepPartial<T>`, which
    recursively goes through every property and applies the *optional mapped type
    modifier* for each level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first draft already works well, thanks to TypeScript stopping recursion
    at primitive values, but it has the potential to result in unreadable output.
    A simple condition that checks that we go deep only if we are dealing with an
    object makes our type much more robust and the result more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, `DeepPartial<Settings>` results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly what we’ve been aiming for. If we use `DeepPartial<T>` in `ap⁠ply​Set⁠tin⁠gs`,
    we see that the actual usage of `applySettings` works, but TypeScript greets us
    with another error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, TypeScript complains that it can’t merge the two objects into something
    that results in `Settings`, as some of the `DeepPartial` set elements might not
    be assignable to `Settings`. And this is true! Object merge using destructuring
    also works only on the first level, just like `Partial<T>` has defined for us.
    This means that if we called `applySettings` like before, we would get a totally
    different type than for `settings`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`color` is all gone! This is one situation where TypeScript’s type might be
    unintuitive at first: why do object modification types go only one level deep?
    Because JavaScript goes only one level deep! But ultimately, they point out bugs
    you wouldn’t have caught otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To circumvent this situation, you need to apply your settings recursively.
    This can be nasty to implement yourself, so we resort to `lodash` and its `merge`
    function for this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '`merge` defines its interface to produce an intersection of two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Again, exactly what we are looking for. An intersection of `Settings` and `De⁠ep​Par⁠tia⁠l<Set⁠tin⁠gs>`
    also produces an intersection of both, which is—due to the nature of the types—`Settings`
    again.
  prefs: []
  type: TYPE_NORMAL
- en: So we end up with expressive types that tell us exactly what to expect, correct
    results for the output, and another helper type for our arsenal. You can create
    `DeepReadonly` and `DeepRequired` similarly.
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Remapping Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructing types gives you flexible, self-maintaining types, but the editor
    hints leave a lot to be desired.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Remap<T>` and `DeepRemap<T>` helper types to improve editor hints.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you use TypeScript’s type system to construct new types, by using helper
    types, complex conditional types, or even simple intersections, you might end
    up with editor hints that are hard to decipher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at `OnlyRequired` from [Recipe 8.1](#ch08_one_optional). The type
    uses four helper types and one intersection to construct a new type in which all
    keys provided as the second type parameter are set to required, while all others
    are set to optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This way of writing types gives you a good idea of what’s happening. You can
    read the functionality based on how helper types are composed with one another.
    However, when you are actually using the types on your models, you might want
    to know more than the actual construction of the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you hover over `NameRequired`, you see that TypeScript gives you information
    on how the type was constructed based on the parameters you provide, but the editor
    hint won’t show you the result, the final type being constructed with those helper
    types. You can see the editor’s feedback in [Figure 8-1](#img-remap).
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0801](assets/tscb_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. Editor hints on complex types expand very shallowly; without knowing
    the types underneath and their functionality, it becomes hard to understand the
    result
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To make the final result look like an actual type and to spell out all the
    properties, we have to use a simple yet effective type called `Remap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Remap<T>` is just an object type that goes through every property and maps
    it to the value defined. No modifications, no filters, just putting out what’s
    being put in. TypeScript will print out every property of mapped types, so instead
    of seeing the construction, you see the actual type, as shown in [Figure 8-2](#img-remap2).'
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0802](assets/tscb_0802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. With `Remap<T>`, the presentation of `NameRequired` becomes much
    more readable
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Beautiful! This has become a staple in TypeScript utility type libraries. Some
    call it `Debug`; others call it `Simplify`. `Remap` is just another name for the
    same tool and the same effect: getting an idea of what your result will look like.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like other mapped types `Partial<T>`, `Readonly<T>`, and `Required<T>`, `Remap<T>`
    also works on the first level only. A nested type like `Settings` that includes
    the `Subtitles` type will be remapped to the same output, and the editor feedback
    will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But also, as shown in [Recipe 8.2](#ch08_nested_objects), we can create a recursive
    variation that remaps *all* nested object types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying `DeepRemap<T>` to `Settings` will also expand `Subtitles`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using `Remap` is mostly a matter of taste. Sometimes you want to know about
    the implementation, and sometimes the terse view of nested types is more readable
    than the expanded versions. But in other scenarios, you actually care about the
    result itself. In those cases, having a `Remap<T>` helper type handy and available
    is definitely helpful.
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Getting All Required Keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a type that extracts all *required* properties from an object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a mapped helper type `GetRequired<T>` that filters keys based on a subtype
    check against its required counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optional properties have a tremendous effect on type compatibility. A simple
    type modifier, the question mark, widens the original type significantly. They
    allow us to define fields that might be there, but they can be used only if we
    do additional checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we can make our functions and interfaces compatible with types that
    lack certain properties entirely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We see that `age` is defined in `Person` but not at all defined in `Student`.
    Since it’s optional, it doesn’t keep us from using `printPerson` with objects
    of type `Student`. The set of compatible values is wider, as we can use objects
    of types that drop `age` entirely.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript solves that by attaching `undefined` to properties that are optional.
    This is the truest representation of “it might be there.”
  prefs: []
  type: TYPE_NORMAL
- en: 'This fact is important if we want to check if property keys are required or
    not. Let’s start by doing the most basic check. We have an object and want to
    check if all keys are required. We use the helper type `Required<T>`, which modifies
    all properties to be required. The simplest check is to see if an object type—for
    example, `Name`—is a subset of its `Required<T>` counterpart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Test` results in `true`, because if we change all properties to `required`
    using `Required<T>`, we still get the same type. However, things change if we
    introduce an optional property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `Test` results in `false`, because type `Person` with the optional property
    `age` accepts a much broader set of values than `Required<Person>`, where `age`
    needs to be set. Contrary to this check, if we swap `Person` and `Required<Person>`,
    we can see that the narrower type `Required<Person>` is in fact a subset of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What we’ve checked so far is if the entire object has the required keys. But
    what we actually want is to get an object that includes only property keys that
    are set to required. This means we need to do this check with each property key.
    The need to iterate the same check over a set of keys is a good indicator for
    a mapped type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next step is to create a mapped type that does the subset check for each
    property, to see if the resulting values include `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good guess but gives us results that don’t work. Each property resolves
    to `true`, meaning that the subset checks only for the value types *without* `undefined`.
    This is because `Required<T>` works on objects, not on primitive types. Something
    that gets us more robust results is checking if `Person[K]` includes any *nullable*
    values. `NonNullable<T>` removes `undefined` and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That’s better, but still not where we want it to be. `undefined` is back again,
    as it’s being added by the property modifier. Also, the property is still in the
    type, and we want to get rid of it.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we need to do is reduce the set of possible keys. So instead of checking
    for the values, we do a conditional check on each property while we are mapping
    out keys. We check if `Person[K]` is a subset of `Required<Person>[K]`, doing
    a proper check against the bigger subset. If this is the case, we print out the
    key `K`; otherwise, we drop the property using `never` (see [Recipe 5.2](ch05.html#ch05_filtering_never)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us the results we want. Now we substitute `Person` for a generic
    type parameter and our helper type `GetRequired<T>` is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'From here on, we can derive variations like `GetOptional<T>`. However, checking
    if something is optional is not as easy as checking if some property keys are
    required, but we can use `GetRequired<T>` and a `keyof` operator to get all the
    required property keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we use the `RequiredKeys<T>` to *omit* them from our target object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Again, a combination of multiple helper types produces derived, self-maintaining
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Allowing at Least One Property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a type for which you want to make sure that at least one property is
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `Split<T>` helper type that splits an object into a union of one-property
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your application stores a set of URLs—for example, for video formats—in an
    object where each key identifies a different format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You want to create a function `loadVideo` that can load any of those video format
    URLs but needs to load at least one URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `loadVideo` accepts parameters of type `VideoFormatURLs`, you need to provide
    *all* video format URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'But some videos might not exist, so a subset of all available types is actually
    what you’re looking for. `Partial<VideoFormatURLs>` gives you that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But since all keys are optional, you would also allow the empty object as a
    valid parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This results in undefined behavior. You want to have at least one URL so you
    can load that video.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to find a type expressing that we expect at least one of the available
    video formats: a type that allows us to pass all of them and some of them but
    also prevents us from passing none.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the “only one” cases. Instead of finding one type, let’s create
    a union type that combines all situations where there’s only one property set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to pass in objects that only have one property set. Next, let’s
    add the situations where we have two properties set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Wait! That’s the same type! But that’s the way union types work. If they aren’t
    discriminated (see [Recipe 3.2](ch03.html#ch03_item_discriminated_unions)), union
    types will allow for values that are located at all intersections of the original
    set, as shown in [Figure 8-3](#img-split-type).
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0803](assets/tscb_0803.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. The union type `AvailableVideoFormats`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each union member defines a set of possible values. The intersections describe
    the values where both types overlap. All possible combinations can be expressed
    with this union.
  prefs: []
  type: TYPE_NORMAL
- en: So now that we know the type, it would be fantastic to derive it from the original
    type. We want to split an object type into a union of types where each member
    contains exactly one property.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to get a union type related to `VideoFormatURLs` is to use the `keyof`
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields `"format360p" | "format480p" | "format720p" | "format1080p"`, a
    union of the keys. We can use the `keyof` operator to index access the original
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This yields `URL`, which is just one type, but in reality it is a union of the
    types of values. Now we only need to find a way to get proper values that represent
    an actual object type and are related to each property key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read this phrase again: “related to each property key.” This calls for a mapped
    type! We can map through all `VideoFormatURLs` to get the property key to the
    righthand side of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, we can index access the mapped type and get value types for each
    element. But we’re not only setting the key to the righthand side but also creating
    another object type that takes this string as a property key and maps it to the
    respective value type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use index access again to grep each value type from the righthand
    side into a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s what we’ve been looking for! As a next step, we take the concrete
    types and substitute them with generics, resulting in the `Split<T>` helper type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Another helper type in our arsenal. Using it with `loadVideo` gives us exactly
    the behavior we have been aiming for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`Split<T>` is a nice way to see how basic type system functionality can change
    the behavior of your interfaces significantly, and how some simple typing techniques
    like mapped types, index access types, and property keys can be used to get a
    tiny yet powerful helper type.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Allowing Exactly One and All or None
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next to requiring *at least one* like in [Recipe 8.5](#ch08_splitting_types),
    you also want to provide scenarios where users provide *exactly one* or *all or
    none*.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create `ExactlyOne<T>` and `AllOrNone<T, K>`. Both rely on the *optional never*
    technique in combination with a derivate of `Split<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With `Split<T>` from [Recipe 8.5](#ch08_splitting_types) we create a nice helper
    type that makes it possible to describe the scenario where we want *at least one*
    parameter provided. This is something that `Partial<T>` can’t provide for us,
    but regular union types can.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from this idea we, might also run into scenarios where we want our
    users to provide *exactly one*, making sure they don’t add too many options.
  prefs: []
  type: TYPE_NORMAL
- en: One technique that can be used here is optional never, which we learned in [Recipe
    3.8](ch03.html#ch03_item_optional_never). Next to all the properties you want
    to allow, you set all the properties you don’t want to allow to optional and their
    value to `never`. This means the moment you write the property name, TypeScript
    wants you to set its value to something that is compatible with `never`, which
    you can’t, as the `never` has no values.
  prefs: []
  type: TYPE_NORMAL
- en: 'A union type where we put all property names in an *exclusive or* relation
    is the key. We get a union type with each property already with `Split<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'All we need to do is to intersect each element with the remaining keys and
    set them to optional never:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the resulting type is more extensive but tells us exactly which
    properties to exclude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And it works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`ExactlyOne<T>` is so much like `Split<T>` that we could think of extending
    `Split<T>` with the functionality to include the optional never pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We add a new generic type parameter `OptionalNever`, which we default to `false`.
    We then intersect the part where we create new objects with a conditional type
    that checks if the parameter `OptionalNever` is actually false. If so, we intersect
    with the empty object (leaving the original object intact); otherwise, we add
    the optional never part to the object. `ExactlyOne<T>` is refactored to `Split<T,
    true>`, where we activate the `OptionalNever` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another scenario very similar to `Split<T>` or `ExactlyOne<T>` is to provide
    all arguments or no arguments. Think of splitting video formats into standard
    definition (SD: 360p and 480p) and high definition (HD: 720p and 1080p). In your
    app, you want to make sure that if your users provide SD formats, they should
    provide all possible formats. It’s OK to have a single HD format.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also where the optional never technique comes in. We define a type
    that *requires* all selected keys or sets them to `never` if only one is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to make sure that you provide also *all* HD formats, add the rest
    to it via an intersection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Or if HD formats are totally optional, add them via a `Partial<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'But then you run into the same problem as in [Recipe 8.5](#ch08_splitting_types),
    where you can provide values that don’t include any formats at all. Intersecting
    the *all or none* variation with `Split<T>` is the solution we are aiming for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'And it works as intended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look closely at what `AllOrNone` does, we can easily rewrite it with
    built-in helper types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'This is arguably more readable but also more to the point of metaprogramming
    in the type system. You have a set of helper types, and you can combine them to
    create new helper types: almost like a functional programming language, but on
    sets of values, in the type system.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Converting Union to Intersection Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your model is defined as a union type of several variants. To derive other types
    from it, you first need to convert the union type to an intersection type.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `UnionToIntersection<T>` helper type that uses contravariant positions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Recipe 8.5](#ch08_splitting_types) we discussed how we can split a model
    type into a union of its variants. Depending on how your application works, you
    may want to define the model as a union type of several variants right from the
    beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The type `Video` allows you to define several formats but requires you to define
    at least one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'However, putting them in a union has some side effects—for example, when you
    need all available keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'You might expect `FormatKeys` to provide a union type of all keys that are
    nested in `urls`. Index access on a union type, however, tries to find the lowest
    common denominator. And in this case, there is none. To get a union type of all
    format keys, you need to have all keys within one type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: A way to create an object like this is to modify the union type to an intersection
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [Recipe 8.5](#ch08_splitting_types), modeling data in a single type was the
    way to go; in this recipe, we see that modeling data as a union type is more to
    our liking. In reality, there is no single answer to how you define your models.
    Use the representation that best fits your application domain and that doesn’t
    get in your way too much. The important thing is to be able to derive other types
    as you need them. This reduces maintenance and allows you to create more robust
    types. In [Chapter 12](ch12.html#ch12) and especially [Recipe 12.1](ch12.html#ch12_low_maintenance_types)
    we will look at the principle of “low maintenance types.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Converting a union type to an intersection type is a peculiar task in TypeScript
    and requires some deep knowledge of the inner workings of the type system. To
    learn all these concepts, we look at the finished type, and then see what happens
    under the hood:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a *lot* to unpack here:'
  prefs: []
  type: TYPE_NORMAL
- en: We have two conditional types. The first one seems to always result in the `true`
    branch, so why do we need it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first conditional type wraps the type in a function argument, and the second
    conditional type unwraps it again. Why is this necessary?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And how do both conditional types transform a union type to an intersection
    type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s analyze `UnionToIntersection<T>` step by step.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first conditional within `UnionToIntersection<T>`, we use the generic
    type argument as a *naked type*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This means we check if `T` is in a subtype condition without wrapping it in
    some other type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Naked types in conditional types have a certain feature. If `T` is a union,
    they run the conditional type for each constituent of the union. So with a naked
    type, a *conditional of union types becomes a union of conditional types*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As compared to the non-naked version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Subtle, but considerably different for complex types!
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we use the naked type and ask if it extends `any` (which it
    always does; `any` is the allow-it-all top type):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Since this condition is always true, we wrap our generic type in a function,
    where `T` is the type of the function’s parameter. But why are we doing that?
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads to the second condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: As the first condition always yields true, meaning that we wrap our type in
    a function type, the other condition also always yields true. We are basically
    checking if the type we just created is a subtype of itself. But instead of passing
    through `T`, we infer a new type `R`, and return the inferred type.
  prefs: []
  type: TYPE_NORMAL
- en: What we do is wrap and unwrap type `T` via a function type.
  prefs: []
  type: TYPE_NORMAL
- en: Doing this via function arguments brings the new inferred type `R` in a *contravariant
    position*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what does *contravariance* mean? The opposite of *contravariance* is *covariance*,
    and what you would expect from normal subtyping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`string` is a subtype of `string | number`; all elements of `string` appear
    in `string | number`, so we can assign `b` to `c`. `c` still behaves as we originally
    intended. This is covariance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This, on the other hand, won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We can’t assign `f` to `g`, because then we would also be able to call `f` with
    a number! We miss part of the contract of `g`. This is contravariance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting thing is that contravariance effectively works like an intersection:
    if `f` accepts `string` and `g` accepts `string | number`, the type that is accepted
    by both is `(string | number) & string`, which is `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: When we put types in contravariant positions within a conditional type, TypeScript
    creates an *intersection* out of it. Meaning that since we *infer* from a function
    argument, TypeScript knows that we have to fulfill the complete contract, creating
    an intersection of all constituents in the union.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, *union to intersection*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run it through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a naked type; this means we can do a union of conditionals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s expand `UnionToIntersection<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'And evaluate the first conditional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s evaluate conditional two, where we infer `R`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'But wait! `R` is inferred from a contravariant position. We have to make an
    intersection; otherwise, we lose type compatibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s what we have been looking for! So, applied to our original example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '`FormatKeys` is now `"format320p" | "format480p" | "format720p" | "format1080p"#`.
    Whenever we add another format to the original union, the `FormatKeys` type updates
    automatically. Maintain once; use everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Using type-fest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You love your helper types so much that you want to create a utility library
    for easy access.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chances are *type-fest* already has everything you need.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The whole idea of this chapter was to introduce you to a couple of useful helper
    types that are not part of standard Typescript but have proven to be highly flexible
    for many scenarios: single-purpose generic helper types that can be combined and
    composed to derive types based on your existing models. You write your models
    once, and all other types get updated automatically. This idea of having *low
    maintenance types*, by deriving types from others, is unique to TypeScript and
    appreciated by tons of developers who create complex applications or libraries.'
  prefs: []
  type: TYPE_NORMAL
- en: You might end up using your helper types a lot, so you start out combining them
    in a utility library for easy access, but chances are one of the existing libraries
    already has everything you need. Using a well-defined set of helper types is nothing
    new, and plenty out there give you everything you’ve seen in this chapter. Sometimes
    it’s exactly the same but under a different name; other times it’s a similar idea
    but solved differently. The basics are most likely covered by all type libraries,
    but one library, [*type-fest*](https://oreil.ly/Cw4Kc), is not only useful but
    actively maintained, well documented, and widely used.
  prefs: []
  type: TYPE_NORMAL
- en: '*Type-fest* has a few aspects that make it stand out. First, it’s extensively
    documented. Not only does its documentation include the *usage* of a certain helper
    type, but it also includes use cases and scenarios that tell you where you might
    want to use this helper type. One example is `Integer<T>`, which makes sure that
    the number you provide does not have any decimals.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a utility type that almost made it into *TypeScript Cookbook*, but
    I saw that giving you the snippet from *type-fest* tells you everything you need
    to know about the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: import type {Integer} from 'type-fest';
  prefs: []
  type: TYPE_NORMAL
- en: 'declare function setYear<T extends number>(length: Integer<T>): void;'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the file deals with negative integers, non-negative integers, floating
    point numbers, and so on. It’s a real treasure trove of information if you want
    to know more about how types are constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, *type-fest* deals with edge cases. In [Recipe 8.2](#ch08_nested_objects),
    we learned about recursive types and defined `DeepPartial<T>`. Its *type-fest*
    counterpart, `PartialDeep<T>`, is a bit more extensive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: There is no need to go through the entirety of this implementation, but it should
    give you an idea about how hardened their implementations for certain utility
    types are.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`PartialDeep<T>` is extensive and deals with all possible edge cases, but it
    also comes at a cost of being complex and hard to swallow for the TypeScript type-checker.
    Depending on your use case, the simpler version from [Recipe 8.2](#ch08_nested_objects)
    might be the one you’re looking for.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, they don’t add helper types just for the sake of adding them. Their
    *Readme* file has a list of declined types and the reasoning behind the decline:
    either the use cases are limited or better alternatives exist. Just like everything,
    they document their choices really, really well.'
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, *type-fest* educates about existing helper types. Helper types have
    existed in TypeScript forever but barely have been documented in the past. Years
    ago, [my blog](https://oreil.ly/eRtx9) attempted to be a resource on built-in
    helper types, until the [official documentation added a chapter on utility types](https://oreil.ly/K5cXq).
    Utility types are not something that you easily pick up just by using TypeScript.
    You need to understand that they exist and need to read up on them. *type-fest*
    has an entire section dedicated to built-ins, with examples and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Last, but not least, it’s widely adopted and developed by reliable open source
    developers. Its creator, [Sindre Sorhus](https://oreil.ly/thSin), has worked on
    open source projects for decades and has a track record of fantastic projects.
    *type-fest* is just another stroke of genius. Chances are a lot of your work relies
    on his work.
  prefs: []
  type: TYPE_NORMAL
- en: With *type-fest* you get another resource of helper types you can add to your
    project. Decide for yourself if you want to keep a small set of helper types or
    if you rely on the implementations by the community.
  prefs: []
  type: TYPE_NORMAL
