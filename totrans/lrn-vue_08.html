<html><head></head><body><section data-pdf-bookmark="Chapter 8. Routing" data-type="chapter" epub:type="chapter"><div class="chapter" id="unique_chapter_id_07">&#13;
<h1><span class="label">Chapter 8. </span>Routing</h1>&#13;
&#13;
&#13;
<p>In previous chapters, we have learned the fundamentals of Vue components and different approaches to composing a Vue component. We proceeded to create reusable component logic as standalone composable using Composition API. We also learned about more advanced concepts of rendering and custom plugin creation.</p>&#13;
&#13;
<p>This chapter will explore a different aspect of building a Vue application, routing, by introducing you to the concept of a routing system with Vue Router, the official routing management library for the Vue application, and its core API. We then learn how to configure the app’s routes, pass and handle data between the application’s paths using router guards, and build dynamic and nested routes for our application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What is Routing?" data-type="sect1"><div class="sect1" id="id87">&#13;
<h1>What is Routing?</h1>&#13;
&#13;
<p>When users navigate around the web, they enter a Uniform Resource Locator (URL) in the browser’s address bar. A URL is the address of a resource within the web. It contains many parts, which we can divide into the following significant sections (<a data-type="xref" href="#figure_c07_01_url">Figure 8-1</a>)<a data-primary="routing" data-secondary="understanding" data-type="indexterm" id="id1223"/><a data-primary="URLs (Uniform Resource Locators)" data-secondary="routing and" data-type="indexterm" id="id1224"/>:</p>&#13;
<dl>&#13;
<dt>Location</dt>&#13;
<dd>&#13;
<p>Includes the protocol, the application’s domain name (or IP address of the web server), and the port used to access the requested resource<a data-primary="location, in URLs" data-type="indexterm" id="id1225"/>.</p>&#13;
</dd>&#13;
<dt>Path</dt>&#13;
<dd>&#13;
<p>The path to the requested resource. In web development, we use it to determine the page component to render on the browser side based on a predefined path pattern<a data-primary="path section in URLs" data-type="indexterm" id="id1226"/>.</p>&#13;
</dd>&#13;
<dt>Query parameters</dt>&#13;
<dd>&#13;
<p>A set of key-value pairs for passing additional information to the server, separated by an <code>&amp;</code> symbol. We mainly use query parameters to pass data between pages<a data-primary="query parameters in URLs" data-type="indexterm" id="id1227"/>.</p>&#13;
</dd>&#13;
<dt>Anchor</dt>&#13;
<dd>&#13;
<p>Any text after the <code>#</code> symbol. We use anchors to navigate to a specific element on the same page, often with matched <code>id</code> value with the matched id or a time-lapse for a media element<a data-primary="anchor, in URLs" data-type="indexterm" id="id1228"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<figure><div class="figure" id="figure_c07_01_url">&#13;
<img alt="A diagram shows the one-way data flow between components" src="assets/lvue_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>URL structure</h6>&#13;
</div></figure>&#13;
&#13;
<p>Upon receiving the URL from the user, the browser then communicates with the server based on the received URL, which returns the requested resource, if any. The resource can be a static file, such as an image or a video, or a dynamic page, such as a web page or a web application.</p>&#13;
&#13;
<p>With single-page applications (SPAs), we perform the routing mechanism on the browser side instead, thus allowing smooth page navigation without refreshing the browser. As a URL is a page’s address, we use a routing system to connect its path pattern to a specific component representing it in our application<a data-primary="routing" data-secondary="single-page applications and" data-type="indexterm" id="id1229"/><a data-primary="single-page applications (SPAs)" data-secondary="routing with Vue Router" data-type="indexterm" id="id1230"/><a data-primary="Vue Router" data-secondary="single-page applications (SPAs)" data-type="indexterm" id="id1231"/>.</p>&#13;
&#13;
<p>Frontend frameworks like Vue provide the layout for building components for an SPA but not the routing services. To create a complete user navigation experience, we must design and develop the application’s routing ourselves, including solving the SPA’s issues such as history keeping and bookmarking.</p>&#13;
&#13;
<p>Or we can use Vue Router as our primary engine for routing.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Vue Router" data-type="sect1"><div class="sect1" id="id150">&#13;
<h1>Using Vue Router</h1>&#13;
&#13;
<p>As the official routing service for Vue applications, Vue Router offers a control mechanism for handling page navigation in a Vue application. We use Vue Router to set up our application’s routing systems, including configuring the mapping between components and pages, delivering a good user experience on the client side for the SPA’s flow<a data-primary="Vue Router" data-secondary="advantages" data-type="indexterm" id="id1232"/>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The official Vue Router documentation is available at the <a href="https://oreil.ly/AwUZo">Vue Router website</a>, containing information on installation, APIs, and primary use cases for reference.</p>&#13;
</div>&#13;
&#13;
<p>Since Vue Router is a standalone package from the Vue framework, we need to perform additional steps to have it installed and ready to use in our application, which we will discuss next.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing Vue Router" data-type="sect2"><div class="sect2" id="id88">&#13;
<h2>Installing Vue Router</h2>&#13;
&#13;
<p>The most straightforward way to install Vue Router for a new Vue project using Vite is to choose <code>Yes</code> when being asked to install Vue Router during the setup (see <a data-type="xref" href="ch01.html#chapter_01_newVueApp">“Create a New Vue Application”</a>). Vite then will take care of installing the Vue Router package and scaffold your project with related files and folders (<a data-type="xref" href="#figure_c07_01">Figure 8-2</a>), as in the following structure<a data-primary="installing" data-secondary="Vue Router" data-type="indexterm" id="id1233"/><a data-primary="Vue Router" data-secondary="installing" data-type="indexterm" id="id1234"/>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>router</code> folder with one file, <code>index.ts</code>, containing the routes configurations for the app<a data-primary="router folder" data-type="indexterm" id="id1235"/><a data-primary="index.ts file" data-type="indexterm" id="id1236"/>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>views</code> folder has two sample Vue components, <code>AboutView</code> and <code>HomeView</code>. Each component is the view for the related URL paths, which we will discuss shortly<a data-primary="views folder" data-type="indexterm" id="id1237"/><a data-primary="HomeView sample component" data-type="indexterm" id="id1238"/><a data-primary="AboutView sample component" data-type="indexterm" id="id1239"/>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="figure_c07_01">&#13;
<img alt="A diagram shows the one-way data flow between components" src="assets/lvue_0802.png"/>&#13;
<h6><span class="label">Figure 8-2. </span>Project structure after scaffolding with Vite with Vue Router enabled</h6>&#13;
</div></figure>&#13;
&#13;
<p>Vite will also inject some code into the <code>main.ts</code> file to initialize Vue Router. Hence, the created app will enable the primary router enabled and make it ready to use<a data-primary="main.ts file" data-secondary="Vue Router and" data-type="indexterm" id="id1240"/>.</p>&#13;
&#13;
<p>However, to fully understand how Vue Router works, we will skip the scaffolding option and add Vue Router to our existing project manually by using the following command<a data-primary="Vue Router" data-secondary="adding manually" data-type="indexterm" id="id1241"/>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">yarn<code class="w"> </code>add<code class="w"> </code>-D<code class="w"> </code>vue-router@4<code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In this book, we use Vue Router 4.1.6, the latest version at the time of writing. You can replace the version number after <code>@</code> with the latest version from the <a href="https://oreil.ly/h6Q0V">Vue Router NPM page</a>.</p>&#13;
&#13;
<p>For Vue 3 projects, you should use version 4 and above<a data-primary="versions" data-secondary="Vue Router" data-type="indexterm" id="id1242"/><a data-primary="Vue Router" data-secondary="version" data-type="indexterm" id="id1243"/>.</p>&#13;
</div>&#13;
&#13;
<p>To demonstrate the Vue Router’s capabilities, we will build an SPA representing a pizza ordering system. The application header will have the following page links: Home, About, Pizzas, Contact, and Login (see <a data-type="xref" href="#figure_c07_02">Figure 8-3</a>)<a data-primary="single-page applications (SPAs)" data-secondary="routing with Vue Router" data-type="indexterm" id="ix-comp-rout1"/><a data-primary="Vue Router" data-secondary="single-page applications (SPAs)" data-type="indexterm" id="ix-comp-rout1a"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_c07_02">&#13;
<img alt="A screenshot showing the layout of the Pizza House application's header" src="assets/lvue_0803.png"/>&#13;
<h6><span class="label">Figure 8-3. </span>Pizza House application with navigation header</h6>&#13;
</div></figure>&#13;
&#13;
<p>Each application link leads to a page represented by a Vue component. For each application page, we create a placeholder component and keep it under the <code>views</code> folder. Our Pizza House codebase now contains the following view components:</p>&#13;
<dl>&#13;
<dt><code>HomeView</code></dt>&#13;
<dd>&#13;
<p>Our application’s home page contains a welcome message and a list of pizzas.</p>&#13;
</dd>&#13;
<dt><code>AboutView</code></dt>&#13;
<dd>&#13;
<p>The about page, which will contain a short description of the application.</p>&#13;
</dd>&#13;
<dt><code>PizzasView</code></dt>&#13;
<dd>&#13;
<p>Displaying a list of pizzas for ordering.</p>&#13;
</dd>&#13;
<dt><code>ContactView</code></dt>&#13;
<dd>&#13;
<p>Displaying a contact form.</p>&#13;
</dd>&#13;
<dt><code>LoginView</code></dt>&#13;
<dd>&#13;
<p>Displaying the login form for the user.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>We need to map these components to the appropriate page links, demonstrated in <a data-type="xref" href="#table_chap07_01">Table 8-1</a>.</p>&#13;
<table class="pagebreak-before" id="table_chap07_01">&#13;
<caption><span class="label">Table 8-1. </span>Table of the available routes with their corresponding components and page URLs in Pizza House</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Page link</th>&#13;
<th>Component</th>&#13;
<th>Route path pattern</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><em>https://localhost:4000</em></p></td>&#13;
<td><p>HomeView</p></td>&#13;
<td><p><code>/</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>https://localhost:4000/about</em></p></td>&#13;
<td><p>AboutView</p></td>&#13;
<td><p><code>/about</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>https://localhost:4000/pizzas</em></p></td>&#13;
<td><p>PizzasView</p></td>&#13;
<td><p><code>/pizzas</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>https://localhost:4000/contact</em></p></td>&#13;
<td><p>Contact</p></td>&#13;
<td><p><code>/contact</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><em>https://localhost:4000/login</em></p></td>&#13;
<td><p>LoginView</p></td>&#13;
<td><p><code>/login</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p><a data-type="xref" href="#table_chap07_01">Table 8-1</a> also shows the corresponding route patterns for each page link. We will use these patterns to define the routes in our application.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The port <code>4000</code> for <code>localhost</code> is the local port number for the development server by Vite. It can change depending on your Vite configuration and the available ports when you run your project locally<a data-primary="Vite.js" data-secondary="localhost port number" data-type="indexterm" id="id1244"/><a data-primary="localhost port number" data-type="indexterm" id="id1245"/>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Routes" data-type="sect2"><div class="sect2" id="id89">&#13;
<h2>Defining Routes</h2>&#13;
&#13;
<p>A route is a path pattern in response to a page URL. We define a route in Vue Router based on a configuration object using the interface <code>RouteRecordRaw</code>. This configuration object contains the following properties described in <a data-type="xref" href="#table_chap07_02">Table 8-2</a><a data-primary="routing" data-secondary="defining routes" data-type="indexterm" id="ix-comp-rout2"/><a data-primary="Vue Router" data-secondary="defining routes" data-type="indexterm" id="ix-comp-rout2a"/><a data-primary="alias route configuration property" data-type="indexterm" id="id1246"/><a data-primary="beforeEnter" data-secondary="route configuration property" data-type="indexterm" id="id1247"/><a data-primary="children route configuration property" data-type="indexterm" id="id1248"/><a data-primary="component route configuration property" data-type="indexterm" id="id1249"/><a data-primary="meta route configuration property" data-type="indexterm" id="id1250"/><a data-primary="name, route configuration property" data-type="indexterm" id="id1251"/><a data-primary="names" data-secondary="routes" data-type="indexterm" id="id1252"/><a data-primary="path route configuration property" data-type="indexterm" id="id1253"/><a data-primary="paths" data-secondary="route configuration property" data-type="indexterm" id="id1254"/><a data-primary="props, route configuration property" data-type="indexterm" id="id1255"/><a data-primary="redirect route configuration property" data-type="indexterm" id="id1256"/><a data-primary="routing" data-secondary="named routes" data-type="indexterm" id="id1257"/><a data-primary="routing" data-secondary="configuration options" data-type="indexterm" id="id1258"/><a data-primary="configuring" data-secondary="routes" data-type="indexterm" id="id1259"/><a data-primary="sensitive route configuration property" data-type="indexterm" id="id1260"/><a data-primary="strict route configuration property" data-type="indexterm" id="id1261"/>.</p>&#13;
<table id="table_chap07_02">&#13;
<caption><span class="label">Table 8-2. </span>Properties for a route configuration object</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Property</th>&#13;
<th>Type</th>&#13;
<th>Description</th>&#13;
<th>Required?</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>path</code></p></td>&#13;
<td><p><code>string</code></p></td>&#13;
<td><p>The pattern to check against the browser’s location (browser URL)</p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>component</code></p></td>&#13;
<td><p><code>Component</code></p></td>&#13;
<td><p>The component to render when the browser’s location matches the route’s path pattern</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>name</code></p></td>&#13;
<td><p><code>string</code></p></td>&#13;
<td><p>The name of the route. We can use it to avoid hard-coded URLs in the code.</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>components</code></p></td>&#13;
<td><p><code>{ [name: string]: Component }</code></p></td>&#13;
<td><p>A collection of components to render based on the matched route’s name</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>redirect</code></p></td>&#13;
<td><p><code>string</code> or <code>Location</code> or <code>Function</code></p></td>&#13;
<td><p>The redirect path</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>props</code></p></td>&#13;
<td><p><code>boolean</code> or <code>Object</code> or <code>Function</code></p></td>&#13;
<td><p>The props to pass to the component</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>alias</code></p></td>&#13;
<td><p><code>string</code> or <code>Array&lt;string&gt;</code></p></td>&#13;
<td><p>The alias path</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>children</code></p></td>&#13;
<td><p><code>Array&lt;RouteConfig&gt;</code></p></td>&#13;
<td><p>The child routes</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>&#13;
<span class="keep-together"><code>before</code></span><code>Enter</code></p></td>&#13;
<td><p><code>Function</code></p></td>&#13;
<td><p>The navigation guard callback</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>meta</code></p></td>&#13;
<td><p><code>any</code></p></td>&#13;
<td><p>The route’s metadata. We can use this for passing additional information not visible on the URL.</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>sensitive</code></p></td>&#13;
<td><p><code>Boolean</code></p></td>&#13;
<td><p>Whether the route should be case sensitive. By default, all routes are case insensitive; for example, <code>/pizzas</code> and <code>/Pizzas</code> are the same route.</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>strict</code></p></td>&#13;
<td><p><code>Boolean</code></p></td>&#13;
<td><p>Whether we should allow trailing slash (like <code>/about/</code> or <code>/about</code>)</p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>We often don’t use all the available fields to define a route. For instance, take the default application path (<code>/</code>). It’s sufficient to define the following <code>home</code> route object with the <code>path</code> property set to <code>/</code> and the <code>component</code> property set to <code>HomeView</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**router/index.ts */</code>&#13;
<code class="c1">//import the required component modules</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">homeRoute</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">path</code><code class="o">:</code> <code class="s1">'/'</code><code class="p">,</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'home'</code><code class="p">,</code>&#13;
  <code class="nx">component</code><code class="o">:</code> <code class="nx">HomeView</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Vue Router in the previous code maps the default entry URL (such as <em>https://localhost:4000</em>) to the <code>/</code> case unless <code>strict</code> mode is enabled. If there is no indicator after the slash <code>/</code>, Vue Router will render the <code>HomeView</code> component as the default view. This behavior applies in both cases: when a user visits <em>https://localhost:4000</em>, or <em>https://localhost:4000/</em>.</p>&#13;
&#13;
<p>Now we can proceed to configure our app’s <code>routes</code> as an array of <code>RouteRecordRaw</code> configuration objects in the <code>index.ts</code> file under the <code>router</code> folder, as in the following code<a data-primary="index.ts file" data-type="indexterm" id="id1262"/><a data-primary="RouteRecordRaw" data-type="indexterm" id="id1263"/><a data-primary="router folder" data-type="indexterm" id="id1264"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**router/index.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="kr">type</code> <code class="nx">RouteRecordRaw</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"vue-router"</code><code class="p">;</code>&#13;
<code class="c1">//import the required component modules</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">routes</code><code class="o">:</code><code class="nx">RouteRecordRaw</code><code class="p">[]</code>  <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s1">'/'</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s1">'home'</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">HomeView</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s1">'/about'</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s1">'about'</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">AboutView</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s1">'/pizzas'</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s1">'pizzas'</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">PizzasView</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s1">'/contact'</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s1">'contact'</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">ContactView</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s1">'/login'</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s1">'login'</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">LoginView</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">]</code></pre>&#13;
<div data-type="tip"><h1>Using Named Routes</h1>&#13;
<p>This chapter uses the named route with the <code>name</code> property. I recommend using this approach in your application, making the code more readable and maintainable<a data-primary="routing" data-secondary="named routes" data-type="indexterm" id="id1265"/>.</p>&#13;
</div>&#13;
&#13;
<p>That’s straightforward enough. We have defined the necessary routes for our Pizza House. But we need more than this for our route system to work. We must create a router instance from the given routes and plug it into our Vue application on initialization. We will do this next<a data-primary="" data-startref="ix-comp-rout2" data-type="indexterm" id="id1266"/><a data-primary="" data-startref="ix-comp-rout2a" data-type="indexterm" id="id1267"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a Router Instance" data-type="sect2"><div class="sect2" id="id90">&#13;
<h2>Creating a Router Instance</h2>&#13;
&#13;
<p>We can create the router instance using the <code>createRouter</code> method from the <code>vue-router</code> package. This method takes a configuration object of type <code>RouterOptions</code> as an argument, with the following main properties<a data-primary="createRouter()" data-type="indexterm" id="id1268"/><a data-primary="RouterOptions" data-type="indexterm" id="id1269"/><a data-primary="routers" data-secondary="creating router instances" data-type="indexterm" id="id1270"/><a data-primary="Vue Router" data-secondary="creating router instances" data-type="indexterm" id="id1271"/>:</p>&#13;
<dl>&#13;
<dt><code>history</code></dt>&#13;
<dd>&#13;
<p>The history mode object can be hash-based or web-based (HTML history mode). The web-based method utilizes the HTML5 history API to make the URL readable, allowing us to navigate without reloading the page<a data-primary="history, RouterOption property" data-type="indexterm" id="id1272"/><a data-primary="history, web" data-secondary="routing and" data-type="indexterm" id="id1273"/>.</p>&#13;
</dd>&#13;
<dt><code>routes</code></dt>&#13;
<dd>&#13;
<p>The array of routes to use in the router instance<a data-primary="routes, RouterOption property" data-type="indexterm" id="id1274"/>.</p>&#13;
</dd>&#13;
<dt><code>linkActiveClass</code></dt>&#13;
<dd>&#13;
<p>The class name for the active link. By default, it is <code>router-link-active</code><a data-primary="linkActiveClass, RouterOption property" data-type="indexterm" id="id1275"/><a data-primary="linkExactActiveClass, RouterOption property" data-type="indexterm" id="id1276"/><a data-primary="links" data-secondary="RouterOption configuration" data-type="indexterm" id="id1277"/><a data-primary="classes" data-secondary="links" data-type="indexterm" id="id1278"/>.</p>&#13;
</dd>&#13;
<dt><code>linkExactActiveClass</code></dt>&#13;
<dd>&#13;
<p>The class name for the active link. By default, it is <code>router-link-exact-active</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Other less common properties for the <code>RouterOptions</code> interface are available at the <a href="https://oreil.ly/pcSqw">RouterOptions documentation</a>.</p>&#13;
</div>&#13;
&#13;
<p>We use the <code>createWebHistory</code> method from the <code>vue-route</code> package to create a web-based <code>history</code> object. This method takes a string that represents the base URL as its optional argument<a data-primary="createWebHistory" data-type="indexterm" id="id1279"/><a data-primary="base URLs" data-type="indexterm" id="id1280"/><a data-primary="URLs (Uniform Resource Locators)" data-secondary="base URL" data-type="indexterm" id="id1281"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**router/index.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code>&#13;
  <code class="nx">createRouter</code><code class="p">,</code>&#13;
  <code class="nx">createWebHistory</code><code class="p">,</code>&#13;
  <code class="kr">type</code> <code class="nx">RouteRecordRaw</code>&#13;
<code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue-router'</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">routes</code><code class="o">:</code> <code class="nx">RouteRecordRaw</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="cm">/**... */</code><code class="p">]</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">router</code> <code class="o">=</code> <code class="nx">createRouter</code><code class="p">({</code>&#13;
  <code class="nx">history</code><code class="o">:</code> <code class="nx">createWebHistory</code><code class="p">(</code><code class="s2">"https://your-domain-name"</code><code class="p">),</code>&#13;
  <code class="nx">routes</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>However, passing the base URL as a static string is not a good practice. We want to keep the base URL configurable and isolated for different environments like development and production. For this purpose, Vite exposes the environment object <code>import.meta.env</code>, which contains a <code>BASE_URL</code> property. You can set the value for <code>BASE_URL</code> in a dedicated environment file, often denoted by the <code>.env</code> prefix, or through the command line when running the Vite server. Vite then extracts the relevant value for <code>BASE_URL</code> and injects it into the <code>import.meta.env</code> object, and we can use it in our code, as follows<a data-primary="deployment" data-secondary="base URL and" data-type="indexterm" id="id1282"/><a data-primary="env. prefix" data-type="indexterm" id="id1283"/><a data-primary="environment files and base URL" data-type="indexterm" id="id1284"/><a data-primary="import.meta.env and base URL" data-type="indexterm" id="id1285"/><a data-primary="deployment" data-seealso="Continuous Integration/Continuous Deployment (CI/CD)" data-type="indexterm" id="id1286"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**router/index.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code>&#13;
  <code class="nx">createRouter</code><code class="p">,</code>&#13;
  <code class="nx">createWebHistory</code><code class="p">,</code>&#13;
  <code class="kr">type</code> <code class="nx">RouteRecordRaw</code>&#13;
<code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue-router'</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">routes</code><code class="o">:</code> <code class="nx">RouteRecordRaw</code><code class="p">[]</code> <code class="o">=</code> <code class="p">[</code><code class="cm">/**... */</code><code class="p">]</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">router</code> <code class="o">=</code> <code class="nx">createRouter</code><code class="p">({</code>&#13;
  <code class="nx">history</code><code class="o">:</code> <code class="nx">createWebHistory</code><code class="p">(</code><code class="kr">import</code><code class="p">.</code><code class="nx">meta</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">BASE_URL</code><code class="p">),</code>&#13;
  <code class="nx">routes</code>&#13;
<code class="p">})</code></pre>&#13;
<div data-type="tip"><h1>Using BASE_URL from the Environment File</h1>&#13;
<p>You don’t have to set the <code>BASE_URL</code> value in the <code>.env</code> file for development. Vite will map it to the local server URL automatically<a data-primary="hosting platforms" data-secondary="base URLs and" data-type="indexterm" id="id1287"/>.</p>&#13;
&#13;
<p>Most modern hosting platforms, such as Netlify, will set the <code>BASE_URL</code> value for you during deployment, often to your application’s domain name.</p>&#13;
</div>&#13;
&#13;
<p>We have created the router instance from the given <code>routes</code> and the desired <code>history</code> mode. Our next step is to plug this instance into our Vue application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Plugging the Router Instance Into the Vue Application" data-type="sect2"><div class="sect2" id="id151">&#13;
<h2>Plugging the Router Instance Into the Vue Application</h2>&#13;
&#13;
<p>In the <code>main.ts</code> file where we initialize the application instance <code>app</code>, we will import the created <code>router</code> instance and pass it as the argument to the <code>app.use()</code> method<a data-primary="main.ts file" data-secondary="Vue Router and" data-type="indexterm" id="id1288"/><a data-primary="use()" data-secondary="routers" data-type="indexterm" id="id1289"/><a data-primary="routing" data-secondary="adding router instances to application" data-type="indexterm" id="id1290"/><a data-primary="routers" data-secondary="adding router instances to application" data-type="indexterm" id="id1291"/><a data-primary="Vue Router" data-secondary="adding router instances to application" data-type="indexterm" id="id1292"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**main.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
<code class="kr">import</code> <code class="nx">App</code> <code class="nx">from</code> <code class="s1">'./App.vue'</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">router</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./router'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">router</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Our application now has a routing system for the navigation between pages. However, if you run the application now, you will see that the <code>AboutView</code> component is still not rendered when navigating to the <code>/about</code> path. We must modify our <code>App.vue</code> component to display the suitable component that binds to the route’s path in its configurations. Let’s do that next.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rendering the Current Page with the RouterView Component" data-type="sect2"><div class="sect2" id="id91">&#13;
<h2>Rendering the Current Page with the RouterView Component</h2>&#13;
&#13;
<p>To dynamically generate the desired view for a particular URL path, Vue Router provides <code>RouterView</code> (or <code>router-view</code>) as the placeholder component. During running, Vue Router will replace it with the element that matches the current URL pattern based on the configuration provided. We can use this component in our <code>App.vue</code> component to render the current page<a data-primary="rendering" data-secondary="current page with RouterView component" data-type="indexterm" id="id1293"/><a data-primary="RouterView component" data-type="indexterm" id="id1294"/><a data-primary="routing" data-secondary="rendering current page with RouterView component" data-type="indexterm" id="id1295"/><a data-primary="Vue Router" data-secondary="rendering current page with RouterView component" data-type="indexterm" id="id1296"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting">/**App.vue */&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">setup</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">RouterView</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s1">'vue-router'</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">RouterView</code> <code class="p">/&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>When running the application, the default home page is now the <code>HomeView</code> (<a data-type="xref" href="#home-view">Figure 8-4</a>). When navigating to <code>/about</code> using the browser’s location bar, you will see that the <code>AboutView</code> component is rendered (<a data-type="xref" href="#about-view">Figure 8-5</a>).</p>&#13;
&#13;
<figure><div class="figure" id="home-view">&#13;
<img alt="Home View" src="assets/lvue_0804.png"/>&#13;
<h6><span class="label">Figure 8-4. </span>Application displays the HomeView component for the <code>"/"</code> path</h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="about-view">&#13;
<img alt="About View" src="assets/lvue_0805.png"/>&#13;
<h6><span class="label">Figure 8-5. </span>Application displays the AboutView component for the <code>"/about"</code> path</h6>&#13;
</div></figure>&#13;
&#13;
<p>Since <code>RouterView</code> is a Vue component, we can pass props, attributes, and event listeners to it. <code>RouterView</code> will then pass them to the rendered view to handle. For instance, we can add a class using the <code>RouterView</code><a data-primary="classes" data-secondary="adding with RouterView" data-type="indexterm" id="id1297"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting">/**App.vue */&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">RouterView</code> <code class="na">class</code><code class="o">=</code><code class="s">"view"</code> <code class="p">/&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>The rendered component—<code>AboutView</code>, for example—will then receive the <code>class</code> as the primary container element (see <a data-type="xref" href="#figure_ch7_03">Figure 8-6</a>), and we can use it for CSS styling accordingly<a data-primary="style" data-secondary="rendering pages with RouterView" data-type="indexterm" id="id1298"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch7_03">&#13;
<img alt="RouterView class" src="assets/lvue_0806.png"/>&#13;
<h6><span class="label">Figure 8-6. </span><code>AboutView</code> receives the <code>class</code> attribute from the <code>RouterView</code> component</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">At this point, we have seen how to set up the routes for our application and render the current page using the <code>RouterView</code> component. However, navigating by manually setting the URL path on the browser’s address bar does not seem to be very convenient for users. To enhance the user experience for our app, we can compose a header with navigation links using the <code>a</code> element and the full path. Or we can use the built-in <code>RouterLink</code> component to build the links to our routes, which we will discuss next.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Build a Navigation Bar with the RouterLink Component" data-type="sect2"><div class="sect2" id="id92">&#13;
<h2>Build a Navigation Bar with the RouterLink Component</h2>&#13;
&#13;
<p>Vue Router provides the <code>RouterLink</code> (or <code>router-link</code>) component to generate an interactive and navigable element from a set of given props, such as <code>to</code>, for a specific route’s path. The route path can be a string that has the same value as <code>path</code> in the route configuration, as in the following example for the link to navigate to the about page<a data-primary="navigation bar, building with RouterLink component" data-type="indexterm" id="id1299"/><a data-primary="RouterLink component" data-type="indexterm" id="id1300"/><a data-primary="routing" data-secondary="building navigation bar with RouterLink component" data-type="indexterm" id="id1301"/><a data-primary="Vue Router" data-secondary="building navigation bar with RouterLink component" data-type="indexterm" id="id1302"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting">  <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">to</code><code class="o">=</code><code class="s">"/about"</code><code class="p">&gt;</code>About<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Alternatively, we can pass an object representing the route’s location object, including the <code>name</code> and the <code>params</code> for the route parameters:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting">  <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">:to</code><code class="o">=</code><code class="s">"{ name: 'about' }"</code><code class="p">&gt;</code>About<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>By default, this component renders an anchor element (<code>a</code>) with an <code>href</code> and classes for the active link, such as <code>router-link-active</code> and <code>router-link-exact-active</code>. We can change the default element to any other element using the Boolean <code>custom</code> prop and <code>v-slot</code>, usually another interactive element such as <code>button</code>, as in the following example<a data-primary="bindings" data-secondary="props" data-type="indexterm" id="id1303"/><a data-primary="bindings" data-secondary="custom props" data-type="indexterm" id="id1304"/><a data-primary="props" data-secondary="custom props, binding" data-type="indexterm" id="id1305"/><a data-primary="props" data-secondary="navigation bar with RouterLink component" data-type="indexterm" id="id1306"/><a data-primary="href, building navigation bar with RouterLink component" data-type="indexterm" id="id1307"/><a data-primary="event listeners" data-secondary="custom props" data-type="indexterm" id="id1308"/><a data-primary="slots" data-secondary="navigation bar with RouterLink component" data-type="indexterm" id="id1309"/><a data-primary="v-slot" data-secondary="navigation bar with RouterLink component" data-type="indexterm" id="id1310"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting">  <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">custom</code> <code class="na">to</code><code class="o">=</code><code class="s">"/about"</code> <code class="na">v-slot</code><code class="o">=</code><code class="s">"{ navigate }"</code> <code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">button</code> <code class="err">@</code><code class="na">click</code><code class="o">=</code><code class="s">"navigate"</code><code class="p">&gt;</code>About<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>This code will render a <code>button</code> element instead of the default <code>a</code> element, binding with the <code>navigate</code> function to navigate the given route when clicking.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>Using <code>custom</code> Prop</h1>&#13;
<p>If you use the <code>custom</code> prop, you must bind the <code>navigate</code> function as a click handler or the <code>href</code> link to the custom element. Otherwise, the navigation will not work<a data-primary="classes" data-secondary="names" data-type="indexterm" id="id1311"/><a data-primary="names" data-secondary="classes" data-type="indexterm" id="id1312"/>.</p>&#13;
&#13;
<p>Also, no class names such as <code>router-link-active</code> or <code>router-link-exact-active</code> will be added to the custom element when in action.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Let’s build our navigation bar, <code>NavBar</code>, using <code>RouterLink</code> as shown in <a data-type="xref" href="#NavBar_component">Example 8-1</a>.</p>&#13;
<div data-type="example" id="NavBar_component">&#13;
<h5><span class="label">Example 8-1. </span><code>NavBar</code> component</h5>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting">/**NavBar.vue */&#13;
&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">nav</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">:to</code><code class="o">=</code><code class="s">"{ name: 'home' }"</code><code class="p">&gt;</code>Home<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">:to</code><code class="o">=</code><code class="s">"{ name: 'about' }"</code><code class="p">&gt;</code>About<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">:to</code><code class="o">=</code><code class="s">"{ name: 'pizzas' }"</code><code class="p">&gt;</code>Pizzas<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">:to</code><code class="o">=</code><code class="s">"{ name: 'contact' }"</code><code class="p">&gt;</code>Contact<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">:to</code><code class="o">=</code><code class="s">"{ name: 'login' }"</code><code class="p">&gt;</code>Login<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">nav</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre></div>&#13;
&#13;
<p>We also add some CSS styles to the navigation bar and the active link<a data-primary="style" data-secondary="navigation bar" data-type="indexterm" id="id1313"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting">/**NavBar.vue */&#13;
&#13;
<code class="p">&lt;</code><code class="nt">style</code> <code class="na">scoped</code><code class="p">&gt;</code>&#13;
<code class="nt">nav</code> <code class="p">{</code>&#13;
  <code class="k">display</code><code class="o">:</code> <code class="nb">flex</code><code class="p">;</code>&#13;
  <code class="n">gap</code><code class="o">:</code> <code class="m">30px</code><code class="p">;</code>&#13;
  <code class="k">justify-content</code><code class="o">:</code> <code class="nb">center</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nc">.router-link-active</code><code class="o">,</code> <code class="nc">.router-link-exact-active</code> <code class="p">{</code>&#13;
  <code class="k">text-decoration</code><code class="o">:</code> <code class="nb">underline</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">&lt;/style&gt;</code></pre>&#13;
<div data-type="tip"><h1>Using activeClass and exactActiveClass Props</h1>&#13;
<p>You can use the <code>activeClass</code> and <code>exactActiveClass</code> props of &#13;
<span class="keep-together"><code>RouterLink</code></span> to customize the class names for the active link instead of using the default ones<a data-primary="activeClass" data-type="indexterm" id="id1314"/><a data-primary="classes" data-secondary="links" data-type="indexterm" id="id1315"/><a data-primary="exactActiveClass" data-type="indexterm" id="id1316"/><a data-primary="links" data-secondary="custom class names for" data-type="indexterm" id="id1317"/>.</p>&#13;
</div>&#13;
&#13;
<p>Once we add <code>NavBar</code> to the <code>App</code> component, we will see the navigation bar at the top of the page (<a data-type="xref" href="#figure_ch7_04">Figure 8-7</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch7_04">&#13;
<img alt="A screenshot showing the navigation bar with Home link active and underlined" src="assets/lvue_0807.png"/>&#13;
<h6><span class="label">Figure 8-7. </span>Navigation bar of the application</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Now our users can navigate between pages using the navigation bar. However, we still need to handle the data flow between the pages. In the upcoming sections, we will see how to pass data between routes with route parameters<a data-primary="" data-startref="ix-comp-rout1" data-type="indexterm" id="id1318"/><a data-primary="" data-startref="ix-comp-rout1a" data-type="indexterm" id="id1319"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Passing Data Between Routes" data-type="sect1"><div class="sect1" id="passing_data_between_routes">&#13;
<h1>Passing Data Between Routes</h1>&#13;
&#13;
<p>To pass data between routes, we can use the <code>query</code> field in the router object passed to <code>to</code><a data-primary="data" data-secondary="passing between routes" data-type="indexterm" id="ix-comp-rout3"/><a data-primary="query field, passing data between routes" data-type="indexterm" id="ix-comp-rout3a"/><a data-primary="routing" data-secondary="passing data between routes" data-type="indexterm" id="ix-comp-rout3b"/><a data-primary="Vue Router" data-secondary="passing data between routes" data-type="indexterm" id="ix-comp-rout3c"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">:to</code><code class="o">=</code><code class="s">"{ name: 'pizzas', query: { id: 1 } }"</code><code class="p">&gt;</code>Pizza 1<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>The <code>query</code> field is an object that contains the query parameters we want to pass to the route. Vue Router will translate it into a complete <code>href</code> path with query parameters, starting with <code>?</code> syntax<a data-primary="question mark (?) syntax for query field in passing data between routes" data-type="indexterm" id="id1320"/><a data-primary="? (question mark) syntax for query field in passing data between routes" data-type="indexterm" id="id1321"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">a</code> <code class="na">href</code><code class="o">=</code><code class="s">"/pizzas?id=1"</code><code class="p">&gt;</code>Pizza 1<code class="p">&lt;/</code><code class="nt">a</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>We can then access the query parameters in the route component, <code>PizzasView</code>, using the <code>useRoute()</code> function<a data-primary="useRoute()" data-type="indexterm" id="id1322"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>Pizzas<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">p</code> <code class="na">v-if</code><code class="o">=</code><code class="s">"pizzaId"</code><code class="p">&gt;</code>Pizza ID: {{ pizzaId }}<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code> <code class="na">setup</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useRoute</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"vue-router"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">route</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useRoute</code><code class="p">();</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">pizzaId</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">route</code><code class="p">.</code><code class="nx">query</code><code class="o">?</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>This code will render the following page, where the browser’s URL is <em>http://localhost:4000/pizzas?id=1</em> (<a data-type="xref" href="#figure_ch7_05">Figure 8-8</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch7_05">&#13;
<img alt="A screenshot showing the Pizzas page with the query parameter" src="assets/lvue_0808.png"/>&#13;
<h6><span class="label">Figure 8-8. </span>Pizzas page with the query parameter</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">You can also pass the query parameters in the browser’s address bar, and the router instance will decouple it from the <code>route.query</code> object accordingly. This mechanism is handy in many scenarios. Take our <code>PizzasView</code> page, for instance. This page displays a list of pizzas taken from a <code>usePizzas</code> hook, using the <code>PizzaCard</code> component as shown in <a data-type="xref" href="#pizza_view_component">Example 8-2</a><a data-primary="browsers" data-secondary="passing query parameters in address bar" data-type="indexterm" id="id1323"/>.</p>&#13;
<div data-type="example" id="pizza_view_component">&#13;
<h5><span class="label">Example 8-2. </span><code>PizzasView</code> component</h5>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizzas-view--container"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>Pizzas<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">li</code> <code class="na">v-for</code><code class="o">=</code><code class="s">"pizza in searchResults"</code> <code class="na">:key</code><code class="o">=</code><code class="s">"pizza.id"</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">PizzaCard</code> <code class="na">:pizza</code><code class="o">=</code><code class="s">"pizza"</code> <code class="p">/&gt;</code>&#13;
      <code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code> <code class="na">setup</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">PizzaCard</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/components/PizzaCard.vue"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">usePizzas</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/composables/usePizzas"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">pizzas</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">usePizzas</code><code class="p">();</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre></div>&#13;
&#13;
<p>Now we want to add a search feature, where the user can search for a pizza by its title using a query params <code>search</code> and get the filtered list of pizzas. We can add a <code>useSearch</code> hook, which receives the value of <code>route.query.search</code> as its initial value and returns the filtered list of pizzas as well as the reactive <code>search</code> value, as shown in <a data-type="xref" href="#useSearch_hook">Example 8-3</a><a data-primary="search" data-secondary="passing data between routes" data-type="indexterm" id="ix-comp-rout4"/>.</p>&#13;
<div data-type="example" id="useSearch_hook">&#13;
<h5><span class="label">Example 8-3. </span>Implementing <code>useSearch</code> hook</h5>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">computed</code><code class="p">,</code> <code class="nx">ref</code><code class="p">,</code> <code class="kr">type</code> <code class="nx">Ref</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"vue"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">UseSearchProps</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">items</code><code class="o">:</code> <code class="nx">Ref</code><code class="o">&lt;</code><code class="kr">any</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="nx">filter</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="nx">defaultSearch</code><code class="o">?:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">useSearch</code> <code class="o">=</code> <code class="p">({</code>&#13;
  <code class="nx">items</code><code class="p">,</code>&#13;
  <code class="nx">filter</code> <code class="o">=</code> <code class="s2">"title"</code><code class="p">,</code>&#13;
  <code class="nx">defaultSearch</code> <code class="o">=</code> <code class="s2">""</code><code class="p">,</code>&#13;
<code class="p">}</code><code class="o">:</code> <code class="nx">UseSearchProps</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">search</code> <code class="o">=</code> <code class="nx">ref</code><code class="p">(</code><code class="nx">defaultSearch</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">searchResults</code> <code class="o">=</code> <code class="nx">computed</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">searchTerm</code> <code class="o">=</code> <code class="nx">search</code><code class="p">.</code><code class="nx">value</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">();</code>&#13;
&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">searchTerm</code> <code class="o">===</code> <code class="s2">""</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">items</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">return</code> <code class="nx">items</code><code class="p">.</code><code class="nx">value</code><code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">item</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="kr">const</code> <code class="nx">itemValue</code> <code class="o">=</code> <code class="nx">item</code><code class="p">[</code><code class="nx">filter</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">()</code>&#13;
          <code class="k">return</code> <code class="nx">itemValue</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">searchTerm</code><code class="p">);</code>&#13;
        <code class="p">});</code>&#13;
  <code class="p">});</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">{</code> <code class="nx">search</code><code class="p">,</code> <code class="nx">searchResults</code> <code class="p">};</code>&#13;
<code class="p">};</code></pre></div>&#13;
&#13;
<p>Then we use the <code>useSearch</code> hook in the <code>PizzasView</code> component and change the iteration to be over <code>searchResults</code> instead of <code>pizzas</code>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="cm">&lt;!--...other code --&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">li</code> <code class="na">v-for</code><code class="o">=</code><code class="s">"pizza in searchResults"</code> <code class="na">:key</code><code class="o">=</code><code class="s">"pizza.id"</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">PizzaCard</code> <code class="na">:pizza</code><code class="o">=</code><code class="s">"pizza"</code> <code class="p">/&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
  <code class="cm">&lt;!--...other code --&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code> <code class="na">setup</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="cm">/**...other imports */</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useRoute</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"vue-router"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useSearch</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/composables/useSearch"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">type</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">Pizza</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"@/types/Pizza"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="cm">/**...other code */</code><code class="w"/>&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">route</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useRoute</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="nx">type</code><code class="w"> </code><code class="nx">PizzaSearch</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">search</code><code class="o">:</code><code class="w"> </code><code class="nx">Ref</code><code class="p">&lt;</code><code class="nt">string</code><code class="p">&gt;;</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">searchResults</code><code class="o">:</code><code class="w"> </code><code class="nx">Ref</code><code class="p">&lt;</code><code class="nt">Pizza</code><code class="err">[]</code><code class="p">&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">search</code><code class="p">,</code><code class="w"> </code><code class="nx">searchResults</code><code class="w"> </code><code class="p">}</code><code class="o">:</code><code class="w"> </code><code class="nx">PizzaSearch</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useSearch</code><code class="p">({</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">items</code><code class="o">:</code><code class="w"> </code><code class="nx">pizzas</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">defaultSearch</code><code class="o">:</code><code class="w"> </code><code class="nx">route</code><code class="p">.</code><code class="nx">query</code><code class="o">?</code><code class="p">.</code><code class="nx">search</code><code class="w"> </code><code class="kr">as</code><code class="w"> </code><code class="nx">string</code><code class="p">,</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Now when you go to <code>/pizzas?search=hawaii</code>, the list will show only the pizza with the title <code>Hawaii</code> (<a data-type="xref" href="#figure_ch7_06">Figure 8-9</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_ch7_06">&#13;
<img alt="A screenshot showing the Pizzas page with the search query parameter" src="assets/lvue_0809.png"/>&#13;
<h6><span class="label">Figure 8-9. </span>Pizzas page with the search term from query parameter</h6>&#13;
</div></figure>&#13;
&#13;
<p>How about allowing the user to search while on the page and then syncing the updated search term with the query parameter? For that, we need to perform the following changes<a data-primary="search" data-secondary="syncing update and" data-type="indexterm" id="id1324"/>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Add an input field to the <code>template</code> and bind it to the <code>search</code> variable:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="cm">&lt;!--...other code --&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">input</code> <code class="na">v-model</code><code class="o">=</code><code class="s">"search"</code> <code class="na">placeholder</code><code class="o">=</code><code class="s">"Search for a pizza"</code> <code class="p">/&gt;</code>&#13;
  <code class="cm">&lt;!--...other code --&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Get the <code>router</code> instance using the <code>useRouter()</code> method:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**...other imports */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">useRoute</code><code class="p">,</code> <code class="nx">useRouter</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"vue-router"</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/**...other code */</code>&#13;
<code class="kr">const</code> <code class="nx">router</code> <code class="o">=</code> <code class="nx">useRouter</code><code class="p">();</code></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use the <code>watch</code> function to watch for changes in the <code>search</code> value and update the query parameter using <code>router.replace</code><a data-primary="watch()" data-secondary="search and passing data between routes" data-type="indexterm" id="id1325"/><a data-primary="watchers" data-secondary="search and passing data between routes" data-type="indexterm" id="id1326"/>:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**...other imports */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">watch</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code><code class="p">;</code>&#13;
&#13;
<code class="cm">/**...other code */</code>&#13;
<code class="nx">watch</code><code class="p">(</code><code class="nx">search</code><code class="p">,</code> <code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="nx">prevValue</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">value</code> <code class="o">===</code> <code class="nx">prevValue</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>&#13;
  <code class="nx">router</code><code class="p">.</code><code class="nx">replace</code><code class="p">({</code> <code class="nx">query</code><code class="o">:</code> <code class="p">{</code> <code class="nx">search</code><code class="o">:</code> <code class="nx">value</code> <code class="p">}</code> <code class="p">});</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>When you type in the search field, the router instance will update the URL with the new query value.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you use Vue 2.x and below or Options API (without <code>setup()</code>), you can access the <code>router</code> and <code>route</code> instances using <code>this.$router</code> and <code>this.$route</code>, respectively<a data-primary="Options API" data-secondary="routing and" data-type="indexterm" id="id1327"/><a data-primary="this.$router" data-type="indexterm" id="id1328"/><a data-primary="this.$route" data-type="indexterm" id="id1329"/>.</p>&#13;
</div>&#13;
&#13;
<p>At this point, we have learned how to retrieve the query params with the <code>route</code> instance. Using the <code>route</code> instance in every component that needs to access the query params can be tedious. Instead, we can decouple the query params using props, which we will learn next<a data-primary="" data-startref="ix-comp-rout3" data-type="indexterm" id="id1330"/><a data-primary="" data-startref="ix-comp-rout3a" data-type="indexterm" id="id1331"/><a data-primary="" data-startref="ix-comp-rout3b" data-type="indexterm" id="id1332"/><a data-primary="" data-startref="ix-comp-rout3c" data-type="indexterm" id="id1333"/><a data-primary="" data-startref="ix-comp-rout4" data-type="indexterm" id="id1334"/><a data-primary="props" data-secondary="decoupling route parameters" data-type="indexterm" id="id1335"/><a data-primary="routing" data-secondary="decoupling route parameters" data-type="indexterm" id="id1336"/><a data-primary="Vue Router" data-secondary="decoupling route parameters" data-type="indexterm" id="id1337"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Decoupling Route Parameters Using Props" data-type="sect1"><div class="sect1" id="id362">&#13;
<h1>Decoupling Route Parameters Using Props</h1>&#13;
&#13;
<p>In the route configuration object, we can define the static props to pass to the view component as an object with static values or a function that returns the props. For example, in the following code, we change our <code>pizzas</code> route configuration to pass the <code>searchTerm</code> prop, whose value is from <code>route.query.search</code>, to the <code>PizzaView</code> &#13;
<span class="keep-together">component</span>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code>&#13;
  <code class="kr">type</code> <code class="nx">RouteLocationNormalizedLoaded</code><code class="p">,</code>&#13;
  <code class="kr">type</code> <code class="nx">RouteRecordRaw</code><code class="p">,</code>&#13;
<code class="p">}</code> <code class="nx">from</code> <code class="s2">"vue-router"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">routes</code><code class="o">:</code> <code class="nx">RouteRecordRaw</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="cm">/** other routes */</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s2">"/pizzas"</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"pizzas"</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">PizzasView</code><code class="p">,</code>&#13;
    <code class="nx">props</code><code class="o">:</code> <code class="p">(</code><code class="nx">route</code><code class="o">:</code> <code class="nx">RouteLocationNormalizedLoaded</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code>&#13;
      <code class="nx">searchTerm</code><code class="o">:</code> <code class="nx">route</code><code class="p">.</code><code class="nx">query</code><code class="o">?</code><code class="p">.</code><code class="nx">search</code> <code class="o">||</code> <code class="s2">""</code><code class="p">,</code>&#13;
    <code class="p">}),</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">];</code></pre>&#13;
&#13;
<p>In the <code>PizzasView</code> component, we can remove the use of <code>useRoute</code> and access the <code>searchTerm</code> prop using the <code>props</code> object:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">props</code> <code class="o">=</code> <code class="nx">defineProps</code><code class="p">({</code>&#13;
  <code class="nx">searchTerm</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="kr">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
    <code class="nx">required</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
    <code class="k">default</code><code class="o">:</code> <code class="s2">""</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">search</code><code class="p">,</code> <code class="nx">searchResults</code> <code class="p">}</code><code class="o">:</code> <code class="nx">PizzaSearch</code> <code class="o">=</code> <code class="nx">useSearch</code><code class="p">({</code>&#13;
  <code class="nx">items</code><code class="o">:</code> <code class="nx">pizzas</code><code class="p">,</code>&#13;
  <code class="nx">defaultSearch</code><code class="o">:</code> <code class="nx">props</code><code class="p">.</code><code class="nx">searchTerm</code><code class="p">,</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>The behavior of the application stays the same as before.</p>&#13;
&#13;
<p>You can also use <code>props: true</code> to pass the <code>route.params</code> object to the view component as props, without caring about any specific props.  When the route changes, we can combine this approach with navigation guards to perform side effects for the route’s parameters. More about navigation guards in the next section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Understanding Navigation Guards" data-type="sect1"><div class="sect1" id="id94">&#13;
<h1>Understanding Navigation Guards</h1>&#13;
&#13;
<p>Navigation guards are functions to help us control the navigation flow better. We can also use them to perform side effects when the route changes or before the navigation happens. There are three types of navigation guards and hooks: global, component-level, and route-level<a data-primary="navigation guards" data-type="indexterm" id="ix-comp-rout5"/><a data-primary="routing" data-secondary="navigation guards" data-type="indexterm" id="ix-comp-rout5a"/><a data-primary="side effects" data-secondary="navigation guards" data-type="indexterm" id="ix-comp-rout5b"/><a data-primary="Vue Router" data-secondary="navigation guards" data-type="indexterm" id="ix-comp-rout5c"/>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Global Navigation Guards" data-type="sect2"><div class="sect2" id="id95">&#13;
<h2>Global Navigation Guards</h2>&#13;
&#13;
<p>For every router instance, Vue Router exposes a set of global-level navigation guards, including<a data-primary="global navigation guards" data-type="indexterm" id="id1338"/><a data-primary="afterEach hook" data-secondary="navigation guard" data-type="indexterm" id="id1339"/><a data-primary="beforeEach hook" data-secondary="navigation guard" data-type="indexterm" id="id1340"/><a data-primary="beforeResolve navigation guard" data-type="indexterm" id="id1341"/>:</p>&#13;
<dl>&#13;
<dt><code>router.beforeEach</code></dt>&#13;
<dd>&#13;
<p>Called <em>before</em> every navigation</p>&#13;
</dd>&#13;
<dt><code>router.beforeResolve</code></dt>&#13;
<dd>&#13;
<p>Called <em>after</em> Vue Router has resolved all async components in the route and all in-component guards (if any), but <em>before</em> confirming the navigation</p>&#13;
</dd>&#13;
<dt><code>router.afterEach</code></dt>&#13;
<dd>&#13;
<p>Called <em>after</em> confirming the navigation and <em>before</em> the next update of the DOM and the navigation</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The global guards help perform validation before navigating to a specific route. For example, we can use the <code>router.beforeEach</code> to check if the user is authenticated before navigating to the <code>/pizzas</code> route. If not, we can redirect the user to the <code>/login</code> page<a data-primary="validation and navigation guards" data-type="indexterm" id="id1342"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">user</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">isAuthenticated</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">router</code><code class="p">.</code><code class="nx">beforeEach</code><code class="p">((</code><code class="nx">to</code><code class="p">,</code> <code class="nx">from</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">to</code><code class="p">.</code><code class="nx">name</code> <code class="o">===</code> <code class="s2">"pizzas"</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">user</code><code class="p">.</code><code class="nx">isAuthenticated</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">next</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"login"</code> <code class="p">});</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="nx">next</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>In this code, <code>to</code> is the destination route object to navigate to, <code>from</code> is the current route object, and <code>next</code> is a function to call to resolve the hook/guard. We need to trigger <code>next()</code> at the end, either without any argument to continue to the original destination or with a new route object as its argument to redirect the user to a different route. Otherwise, Vue Router will block the navigation flow<a data-primary="next(), navigation guards" data-type="indexterm" id="id1343"/>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Alternatively, we can use the <code>router.beforeResolve</code> to perform the same validation. The critical difference between &#13;
<span class="keep-together"><code>router.before</code></span><code>Each</code> and <code>router.beforeResolve</code> is that Vue Router triggers the latter after resolving all in-component guards. However, invoking the callback after settling everything will be less valuable when you want to avoid loading the suitable async component before confirming the navigation.</p>&#13;
</div>&#13;
&#13;
<p>How about the <code>router.afterEach</code>? We can use this hook to perform actions like saving some page’s data as cache, tracking page analytics, or authenticating our user when navigating away from the login page:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">router</code><code class="p">.</code><code class="nx">afterEach</code><code class="p">((</code><code class="nx">to</code><code class="p">,</code> <code class="nx">from</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">to</code><code class="p">.</code><code class="nx">name</code> <code class="o">===</code> <code class="s2">"login"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">user</code><code class="p">.</code><code class="nx">isAuthenticated</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>While the global guards help perform side effects and control the redirecting of the whole application, in some cases we only want to achieve side effects for a specific route. In this case, using route-level guards is a good option.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Route-Level Navigation Guards" data-type="sect2"><div class="sect2" id="id96">&#13;
<h2>Route-Level Navigation Guards</h2>&#13;
&#13;
<p>For every route, we can define a callback for the <code>beforeEnter</code> guard, which Vue Router triggers when entering a path from a different one. Take our <code>/pizzas</code> route, for instance. Instead of mapping the <code>props</code> field with a function, we can achieve mapping the search query as a prop to the view by manually setting the &#13;
<span class="keep-together"><code>to.params.</code></span><code>searchTerm</code> field to <code>to.query.search</code> before entering the route<a data-primary="route-level navigation guards" data-type="indexterm" id="id1344"/><a data-primary="callbacks" data-secondary="route-level navigation guards" data-type="indexterm" id="id1345"/><a data-primary="search" data-secondary="route-level navigation guards" data-type="indexterm" id="id1346"/><a data-primary="callbacks" data-seealso="lifecycle hooks" data-type="indexterm" id="id1347"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">routes</code><code class="o">:</code> <code class="nx">RouteRecordRaw</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="cm">/** other routes */</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s2">"/pizzas"</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"pizzas"</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">PizzasView</code><code class="p">,</code>&#13;
    <code class="nx">props</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="nx">beforeEnter</code><code class="o">:</code> <code class="kr">async</code> <code class="p">(</code><code class="nx">to</code><code class="p">,</code> <code class="nx">from</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">to</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">searchTerm</code> <code class="o">=</code> <code class="p">(</code><code class="nx">to</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">search</code> <code class="o">||</code> <code class="s2">""</code><code class="p">)</code> <code class="kr">as</code> <code class="kt">string</code><code class="p">;</code>&#13;
&#13;
      <code class="nx">next</code><code class="p">()</code>&#13;
    <code class="p">},</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">];</code></pre>&#13;
&#13;
<p>Note that we have set <code>props: true</code> in the pizzas route. The UI will still display the same list of pizzas as before (<a data-type="xref" href="#figure_07_pizzaslist">Figure 8-10</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_07_pizzaslist">&#13;
<img alt="A screenshot of the Pizzas list page." src="assets/lvue_0810.png"/>&#13;
<h6><span class="label">Figure 8-10. </span>Pizzas list</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can manually modify the <code>to.query.searchTerm</code> within this guard. However, the changes won’t reflect on the URL path in the browser’s address bar. If we want to update the URL path, we can use the <code>next</code> function to redirect the user to a new route object with the desired query parameters.</p>&#13;
<div data-type="tip"><h1>Passing an Array of Callbacks to beforeEnter</h1>&#13;
<p><code>beforeEnter</code> also accepts an array of callbacks, which Vue Router triggers in sequence. Hence we can perform multiple side effects for a specific route before entering it.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">Like other global guards, the <code>beforeEnter</code> guard is handy when you want to perform authentication to specific routes, additional modification to the route parameters before passing them to the view component, etc. Next, we will learn how to leverage the component-level guards to perform side effects for a specific view.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Component-Level Router Guards" data-type="sect2"><div class="sect2" id="id97">&#13;
<h2>Component-Level Router Guards</h2>&#13;
&#13;
<p>From Vue 3.x on, Vue Router also provides composable guards at the component level to help control the flow of route leaving and updating, as <code>onBeforeRouteLeave</code> and <code>onBeforeRouteUpdate</code>. While Vue Router triggers <code>onBeforeRouteLeave</code> when the user navigates away from the current path view, it invokes <code>onBeforeRouteUpdate</code> when the user navigates to the same path view but with different parameters<a data-primary="onBeforeRouteLeave()" data-type="indexterm" id="id1348"/><a data-primary="onBeforeRouteUpdate()" data-type="indexterm" id="id1349"/><a data-primary="composables" data-secondary="component-level navigation guards" data-type="indexterm" id="id1350"/><a data-primary="components" data-secondary="navigation guards, component-level" data-type="indexterm" id="ix-comp-rout6"/>.</p>&#13;
&#13;
<p>We can use <code>onBeforeRouteLeave</code> to display a message to confirm the user’s navigation away from the Contact page with the following code:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">onBeforeRouteLeave</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"vue-router"</code><code class="p">;</code>&#13;
&#13;
<code class="nx">onBeforeRouteLeave</code><code class="p">((</code><code class="nx">to</code><code class="p">,</code> <code class="nx">from</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">answer</code> <code class="o">=</code> <code class="nb">window</code><code class="p">.</code><code class="nx">confirm</code><code class="p">(</code><code class="s2">"Are you sure you want to leave?"</code><code class="p">);</code>&#13;
&#13;
  <code class="nx">next</code><code class="p">(</code><code class="o">!!</code><code class="nx">answer</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Now when you are on the Contact page and try to navigate to another page, you will see a confirmation popup asking you to confirm your navigation, as in <a data-type="xref" href="#figure_07_alert">Figure 8-11</a>. Clicking on the Cancel button will prevent navigation, and clicking the OK button will continue the navigation.</p>&#13;
&#13;
<figure><div class="figure" id="figure_07_alert">&#13;
<img alt="A screenshot of the confirmation popup." src="assets/lvue_0811.png"/>&#13;
<h6><span class="label">Figure 8-11. </span>Confirmation popup</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you use Options API for your components, <code>beforeRouteLeave</code> and <code>beforeRouteUpdate</code> guards would be available on the options object to achieve the same functionality<a data-primary="Options API" data-secondary="navigation guards" data-type="indexterm" id="id1351"/><a data-primary="BeforeRouteEnter hook" data-type="indexterm" id="id1352"/><a data-primary="BeforeRouteLeave navigation guard" data-type="indexterm" id="id1353"/><a data-primary="BeforeRouteUpdate navigation guard" data-type="indexterm" id="id1354"/>.</p>&#13;
&#13;
<p>There is also a <code>beforeRouteEnter</code> hook, which the router triggers before Vue initialize the view component. This guard is similar to the <code>setup()</code> hook; hence, Vue Router’s API has no equivalent composable<a data-primary="order" data-secondary="navigation guards" data-type="indexterm" id="id1355"/>.</p>&#13;
</div>&#13;
&#13;
<p>We have explored the available navigation guards in different levels of a routing system and their order of execution, shown in <a data-type="xref" href="#figure_07_guardflow">Figure 8-12</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_07_guardflow">&#13;
<img alt="A diagram of the navigation guard flow." src="assets/lvue_0812.png"/>&#13;
<h6><span class="label">Figure 8-12. </span>Order of triggering navigation guards and their equivalent composable</h6>&#13;
</div></figure>&#13;
&#13;
<p>Understanding the navigation flow and the order of execution of the guards is crucial to building a robust routing system. Next, we will learn how to create nested routes for our application<a data-primary="" data-startref="ix-comp-rout5" data-type="indexterm" id="id1356"/><a data-primary="" data-startref="ix-comp-rout5a" data-type="indexterm" id="id1357"/><a data-primary="" data-startref="ix-comp-rout5b" data-type="indexterm" id="id1358"/><a data-primary="" data-startref="ix-comp-rout5c" data-type="indexterm" id="id1359"/><a data-primary="" data-startref="ix-comp-rout6" data-type="indexterm" id="id1360"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating Nesting Routes" data-type="sect1"><div class="sect1" id="id98">&#13;
<h1>Creating Nesting Routes</h1>&#13;
&#13;
<p>At this point, we have built a basic one-level routing system for our application. In reality, most routing systems are more complex. Sometimes, we want to create subpages for a specific page, such as a Frequently Asked Questions (FAQs) page, and a Form page for the Contact page<a data-primary="nested routes" data-type="indexterm" id="ix-comp-rout7"/><a data-primary="routing" data-secondary="nested routes" data-type="indexterm" id="ix-comp-rout7a"/><a data-primary="Vue Router" data-secondary="nested routes" data-type="indexterm" id="ix-comp-rout7b"/>:</p>&#13;
&#13;
<pre data-type="programlisting">  /contact/faq&#13;
  /contact/form</pre>&#13;
&#13;
<p class="pagebreak-before">The default UI for the <code>/contact</code> page will be the <code>ContactView</code> page, and the user can navigate to the Form page by clicking on a link presented on this page. In this case, we need to create nested routes for the <code>/contact</code> page using the <code>children</code> field of the route configuration object.</p>&#13;
&#13;
<p>First create the <code>ContactFaqView</code> and <code>ContactFormView</code> components, so the router can render them when matched, and then modify our <code>/contact</code> route:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">routes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="cm">/**...other routes */</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s2">"/contact"</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"contact"</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">ContactView</code><code class="p">,</code>&#13;
    <code class="nx">children</code><code class="o">:</code> <code class="p">[</code>&#13;
      <code class="p">{</code>&#13;
        <code class="nx">path</code><code class="o">:</code> <code class="s2">"faq"</code><code class="p">,</code>&#13;
        <code class="nx">name</code><code class="o">:</code> <code class="s2">"contact-faq"</code><code class="p">,</code>&#13;
        <code class="nx">component</code><code class="o">:</code> <code class="nx">ContactFaqView</code><code class="p">,</code>&#13;
      <code class="p">},</code>&#13;
      <code class="p">{</code>&#13;
        <code class="nx">path</code><code class="o">:</code> <code class="s2">"form"</code><code class="p">,</code>&#13;
        <code class="nx">name</code><code class="o">:</code> <code class="s2">"contact-form"</code><code class="p">,</code>&#13;
        <code class="nx">component</code><code class="o">:</code> <code class="nx">ContactFormView</code><code class="p">,</code>&#13;
      <code class="p">},</code>&#13;
    <code class="p">],</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">];</code></pre>&#13;
&#13;
<p>We must also stub the placeholder component <code>RouterView</code> inside the <code>ContactView</code> to render the nested routes. As an example, let’s add the following code to the <code>ContactView</code>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"contact-view--container"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>This is the contact page<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">nav</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">to</code><code class="o">=</code><code class="s">"/contact/faq"</code><code class="p">&gt;</code>FAQs<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">router-link</code> <code class="na">to</code><code class="o">=</code><code class="s">"/contact/form"</code><code class="p">&gt;</code>Contact Us<code class="p">&lt;/</code><code class="nt">router-link</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">nav</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">router-view</code> <code class="p">/&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Now this Contact component will render <code>ContactFaqView</code> when the user navigates to <em>http://localhost:4000/contact/faq</em> (<a data-type="xref" href="#figure_07_contactfaq_nested">Figure 8-13</a>) and <code>ContactFormView</code> when the user navigates to <em>http://localhost:4000/contact/form</em>, respectively.</p>&#13;
&#13;
<figure><div class="figure" id="figure_07_contactfaq_nested">&#13;
<img alt="Screenshot of the Contact page with FAQ view rendered inside when navigating to http://localhost:4000/contact/faq" src="assets/lvue_0813.png"/>&#13;
<h6><span class="label">Figure 8-13. </span>Example output when navigating to <span class="plain">http://localhost:4000/contact/faq</span></h6>&#13;
</div></figure>&#13;
&#13;
<p>This approach proves beneficial when we want to create a specific UI layout for a page containing nested views with nested routes.</p>&#13;
&#13;
<p>We have seen how to create a nested route within a parent layout. However, in some cases we want to make a nested way without a parent layout, so we must declare the default path for the parent’s route as its nested route object. For example, instead of claiming the parent <code>/contact</code> route’s <code>name</code> and <code>component</code>, we can move it to the nested path with an empty path pattern<a data-primary="nested paths" data-type="indexterm" id="id1361"/><a data-primary="paths" data-secondary="nested" data-type="indexterm" id="id1362"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">routes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="cm">/**...other routes */</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s2">"/contact"</code><code class="p">,</code>&#13;
    <code class="nx">children</code><code class="o">:</code> <code class="p">[</code>&#13;
      <code class="cm">/**... other children */</code><code class="p">,</code>&#13;
      <code class="p">{</code>&#13;
        <code class="nx">path</code><code class="o">:</code> <code class="s2">""</code><code class="p">,</code>&#13;
        <code class="nx">name</code><code class="o">:</code> <code class="s2">"contact"</code><code class="p">,</code>&#13;
        <code class="nx">component</code><code class="o">:</code> <code class="nx">ContactView</code><code class="p">,</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">],</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">];</code></pre>&#13;
&#13;
<p>This way, when the user navigates to <em>http://localhost:4000/contact/faq</em>, only the &#13;
<span class="keep-together"><code>Contact</code></span><code>FaqView</code> component will be rendered as a separate page, without the content of the <code>ContactView</code> (<a data-type="xref" href="#figure_07_contactfaq">Figure 8-14</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_07_contactfaq">&#13;
<img alt="Screenshot of the Contact page with FAQ view rendered inside when navigating to http://localhost:4000/contact/faq" src="assets/lvue_0814.png"/>&#13;
<h6><span class="label">Figure 8-14. </span>Example output when navigating to <span class="plain">http://localhost:4000/contact/faq</span></h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As you can see in the screenshot, the Contact link is still active in the navigation bar. This behavior happens because the link element of the Contact page still has the class <code>router-link-active</code>, but not <code>router-link-exact-active</code>. We can fix this styling issue by defining CSS rules for only the exact active link instead<a data-primary="router-link-active" data-type="indexterm" id="id1363"/><a data-primary="router-link-exact-active" data-type="indexterm" id="id1364"/><a data-primary="style" data-secondary="nested routes" data-type="indexterm" id="id1365"/>.</p>&#13;
</div>&#13;
&#13;
<p>Using nested routes is very common in real-world applications; in fact, our <code>routes</code> array is already nested children for the router instance of the application. Declaring nested routes is a great way to organize routing structure and create dynamic routes, which we will explore next<a data-primary="" data-startref="ix-comp-rout7" data-type="indexterm" id="id1366"/><a data-primary="" data-startref="ix-comp-rout7a" data-type="indexterm" id="id1367"/><a data-primary="" data-startref="ix-comp-rout7b" data-type="indexterm" id="id1368"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating Dynamic Routes" data-type="sect1"><div class="sect1" id="id99">&#13;
<h1>Creating Dynamic Routes</h1>&#13;
&#13;
<p>One of the most beneficial features of Vue Router is the ability to set up dynamic routes with routing parameters (routing params), which are variables extracted from a URL path. Routing params come in handy when we have a dynamic data-driven route structure. Each route shares a typical pattern and differs only by a unique identifier, such as a user or product id<a data-primary="routing" data-secondary="dynamic routes" data-type="indexterm" id="ix-comp-rout8"/><a data-primary="Vue Router" data-secondary="dynamic routes" data-type="indexterm" id="ix-comp-rout8a"/>.</p>&#13;
&#13;
<p>Let’s revise our routes for the Pizza House and add a dynamic path for displaying one pizza at a time. One option is to define a new route, <code>/pizza</code>, and pass the pizza’s id as its query parameter as <code>/pizza?id=my-pizza-id</code> as we learned in <a data-type="xref" href="#passing_data_between_routes">“Passing Data Between Routes”</a>. The better option, however, is to modify the <code>/pizzas</code> route and add a new nested route to it with the path pattern <code>:id</code>, as follows<a data-primary=":id path pattern" data-primary-sortas="id path pattern" data-type="indexterm" id="id1369"/><a data-primary="paths" data-secondary="dynamic routes" data-type="indexterm" id="id1370"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">routes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="cm">/**...other routes */</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s2">"/pizzas"</code><code class="p">,</code>&#13;
    <code class="cm">/**...other configurations */</code>&#13;
    <code class="nx">children</code><code class="o">:</code> <code class="p">[{</code>&#13;
        <code class="nx">path</code><code class="o">:</code> <code class="s1">':id'</code><code class="p">,</code>&#13;
        <code class="nx">name</code><code class="o">:</code> <code class="s1">'pizza'</code><code class="p">,</code>&#13;
        <code class="nx">component</code><code class="o">:</code> <code class="nx">PizzaView</code><code class="p">,</code>&#13;
    <code class="p">},</code> <code class="p">{</code>&#13;
        <code class="nx">path</code><code class="o">:</code> <code class="s1">''</code><code class="p">,</code>&#13;
        <code class="nx">name</code><code class="o">:</code> <code class="s1">'pizzas'</code><code class="p">,</code>&#13;
        <code class="nx">component</code><code class="o">:</code> <code class="nx">PizzasView</code><code class="p">,</code>&#13;
    <code class="p">}]</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>By using <code>:id</code>, Vue Router will match any path that has a similar format, like <em>/pizzas/1234-pizza-id</em>, and save the extracted id (like <code>1234-pizza-id</code>) as the <code>route.params.id</code> field.</p>&#13;
&#13;
<p>Since we learned about the <code>props</code> field in the route configuration object, we can set its value to <code>true</code>, enabling the automatic mapping of route parameters to the <code>PizzaView</code>’s props:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">routes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="cm">/**...other routes */</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s2">"/pizzas"</code><code class="p">,</code>&#13;
    <code class="cm">/**...other configurations */</code>&#13;
    <code class="nx">children</code><code class="o">:</code> <code class="p">[{</code>&#13;
        <code class="nx">path</code><code class="o">:</code> <code class="s1">':id'</code><code class="p">,</code>&#13;
        <code class="nx">name</code><code class="o">:</code> <code class="s1">'pizza'</code><code class="p">,</code>&#13;
        <code class="nx">component</code><code class="o">:</code> <code class="nx">PizzaView</code><code class="p">,</code>&#13;
        <code class="nx">props</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
    <code class="p">},</code>&#13;
    <code class="cm">/**...other nested routes */</code>&#13;
    <code class="p">],</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>In the bound <code>PizzaView</code> component, we declare <code>id</code> as the component’s props with <code>defineProps()</code> and retrieve the pizza’s details from the <code>pizzas</code> array using the <code>useRoute</code> hook and this <code>id</code> prop:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">usePizzas</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@/composables/usePizzas"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">props</code> <code class="o">=</code> <code class="nx">defineProps</code><code class="p">({</code>&#13;
  <code class="nx">id</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="kr">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
    <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">pizzas</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">usePizzas</code><code class="p">();</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">pizza</code> <code class="o">=</code> <code class="nx">pizzas</code><code class="p">.</code><code class="nx">value</code><code class="p">.</code><code class="nx">find</code><code class="p">((</code><code class="nx">pizza</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">pizza</code><code class="p">.</code><code class="nx">id</code> <code class="o">===</code> <code class="nx">props</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code></pre>&#13;
&#13;
<p>We can display the details of <code>pizza</code> in the <code>PizzaView</code> component as follows:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">section</code> <code class="na">v-if</code><code class="o">=</code><code class="s">"pizza"</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza--container"</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">img</code> <code class="na">:src</code><code class="o">=</code><code class="s">"pizza.image"</code> <code class="na">:alt</code><code class="o">=</code><code class="s">"pizza.title"</code> <code class="na">width</code><code class="o">=</code><code class="s">"500"</code> <code class="p">/&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza--details"</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>{{ pizza.title }}<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>{{ pizza.description }}<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"pizza-stock--section"</code><code class="p">&gt;</code>&#13;
          <code class="p">&lt;</code><code class="nt">span</code><code class="p">&gt;</code>Stock: {{ pizza.quantity || 0 }}<code class="p">&lt;/</code><code class="nt">span</code><code class="p">&gt;</code>&#13;
          <code class="p">&lt;</code><code class="nt">span</code><code class="p">&gt;</code>Price: ${{ pizza.price }}<code class="p">&lt;/</code><code class="nt">span</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">section</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">p</code> <code class="na">v-else</code><code class="p">&gt;</code>No pizza found<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Now when you navigate to <code>/pizzas/1</code>, with <code>1</code> as the id of an existing pizza in the list, the <code>PizzaView</code> component will display the pizza’s details, as shown in <a data-type="xref" href="#figure_07_pizza_details">Figure 8-15</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_07_pizza_details">&#13;
<img alt="A screenshot displaying the pizza details page of pizza with id 1" src="assets/lvue_0815.png"/>&#13;
<h6><span class="label">Figure 8-15. </span>Pizza details page</h6>&#13;
</div></figure>&#13;
<div data-type="tip"><h1>Fetching Data from the Server</h1>&#13;
<p>Ideally, you should avoid fetching data again from the server, such as <code>pizzas</code> in the <code>PizzaView</code> component. Instead, you should use data store management such as Pinia (<a data-type="xref" href="ch09.html#unique_chapter_id_08">Chapter 9</a>) to store fetched <code>pizzas</code> and retrieve them from the store whenever needed.</p>&#13;
</div>&#13;
&#13;
<p>Thus far, we have explored how to create nested and dynamic routes and decoupled the route’s parameters into props. In the next section, we will learn how to implement custom back and forward buttons for our application with Vue Router<a data-primary="" data-startref="ix-comp-rout8" data-type="indexterm" id="id1371"/><a data-primary="" data-startref="ix-comp-rout8a" data-type="indexterm" id="id1372"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Going Back and Forward with the Router Instance" data-type="sect1"><div class="sect1" id="id100">&#13;
<h1>Going Back and Forward with the Router Instance</h1>&#13;
&#13;
<p>Implementing a custom back button is a common feature in web applications in addition to using the native browser’s back button. We can use the <code>router.back()</code> method to navigate to the previous page in the history stack, where <code>router</code> is the app’s router instance received from <code>useRouter()</code><a data-primary="forward/back button, adding" data-type="indexterm" id="id1373"/><a data-primary="back()" data-type="indexterm" id="id1374"/><a data-primary="history, web" data-secondary="forward/back button, adding" data-type="indexterm" id="id1375"/><a data-primary="routers" data-secondary="forward/back button, adding" data-type="indexterm" id="id1376"/><a data-primary="routing" data-secondary="forward/back button, adding" data-type="indexterm" id="id1377"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">button</code> <code class="err">@</code><code class="na">click</code><code class="o">=</code><code class="s">"router.back()"</code><code class="p">&gt;</code>Back<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">setup</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useRouter</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"vue-router"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">router</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useRouter</code><code class="p">();</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>To move forward in the history stack, we can use the <code>router.forward()</code> method<a data-primary="forward()" data-type="indexterm" id="id1378"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">button</code> <code class="err">@</code><code class="na">click</code><code class="o">=</code><code class="s">"router.forward()"</code><code class="p">&gt;</code>Forward<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">setup</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useRouter</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"vue-router"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">router</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useRouter</code><code class="p">();</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
<div data-type="tip"><h1>Using router.go() To Navigate to a Specific Page in the History Stack</h1>&#13;
<p>You can also use the <code>router.go()</code> method, which accepts an argument as the number of steps in the history stack to go back or forward. For instance, <code>router.go(-2)</code> will navigate to the page two steps back, while <code>router.go(2)</code> will jump two steps forward (if they exist)<a data-primary="go()" data-type="indexterm" id="id1379"/><a data-primary="history, web" data-secondary="navigating to specific page in stack" data-type="indexterm" id="id1380"/>.</p>&#13;
</div>&#13;
&#13;
<p>We have explored the basics of Vue Router and created a basic routing system for our application with all the pages we need. But there is one thing we need to handle: if you try to navigate a path that doesn’t exist, you will see a blank page. This scenario happens because Vue Router can’t find a matched component to render when the user tries to navigate to a path that doesn’t exist. This will be our next topic.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Handling Unknown Routes" data-type="sect1"><div class="sect1" id="id101">&#13;
<h1>Handling Unknown Routes</h1>&#13;
&#13;
<p>In most scenarios, we can’t control all the paths users will try to navigate while using our application. For instance, a user may attempt to access <em>https://localhost:4000/pineapples</em>, for which we haven’t defined a route. We can display a 404 page to the user in such cases by using the regular expressions (regex) pattern <code>/:pathMatch(.<strong>)</strong></code> as <code>path</code> in a new <code>error</code> route<a data-primary="paths" data-secondary="regular expressions patterns" data-type="indexterm" id="id1381"/><a data-primary="regular expressions and paths" data-type="indexterm" id="id1382"/><a data-primary="routing" data-secondary="error messages" data-type="indexterm" id="ix-comp-rout9"/><a data-primary="errors" data-secondary="error messages and unknown routes" data-type="indexterm" id="ix-comp-rout9a"/><a data-primary="routing" data-secondary="handling unknown routes" data-type="indexterm" id="ix-comp-rout9b"/><a data-primary="Vue Router" data-secondary="handing unknown routes" data-type="indexterm" id="ix-comp-rout9c"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**router/index.ts */</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">routes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="cm">/**... */</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s1">'/:pathMatch(.*)*'</code><code class="p">,</code>&#13;
    <code class="nx">name</code><code class="o">:</code> <code class="s1">'error'</code><code class="p">,</code>&#13;
    <code class="nx">component</code><code class="o">:</code> <code class="nx">ErrorView</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>Vue Router will match the unfound paths against the pattern <code>/:pathMatch(.<strong>)</strong></code> accordingly and then store the matched path value in the <code>pathMatch</code> parameter of the route location object<a data-primary=":pathMatch()" data-primary-sortas="pathMatch()" data-type="indexterm" id="id1383"/><a data-primary="pathMatch parameter" data-type="indexterm" id="id1384"/>.</p>&#13;
<div data-type="tip"><h1>Using Regex to Match Unknown Paths</h1>&#13;
<p>You can replace <code>pathMatch</code> with any other name you want. Its purpose is to let Vue Router knows where to store the matched path value.</p>&#13;
</div>&#13;
&#13;
<p>In the <code>ErrorView</code> component, we can display a message to the user:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cm">&lt;!--ErrorView.vue --&gt;</code>&#13;
&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>404 - Page not found<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Now when we try to visit <em>https://localhost:4000/pineapples</em> or any unknown path, we will see the 404 page rendered.</p>&#13;
&#13;
<p>Furthermore, we can use the <code>useRoute()</code> method of the <code>vue-router</code> package to access the current route location and display its path’s value<a data-primary="useRoute()" data-type="indexterm" id="id1385"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cm">&lt;!--ErrorView.vue --&gt;</code>&#13;
&#13;
<code class="p">&lt;</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>404 - Page not found<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>Path: {{ route.path }}<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">script</code> <code class="na">lang</code><code class="o">=</code><code class="s">"ts"</code> <code class="na">setup</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useRoute</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s1">'vue-router'</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">route</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useRoute</code><code class="p">()</code><code class="w"/>&#13;
<code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>This code will display the path of the current route, which is, in this case, <code>/pineapples</code> (<a data-type="xref" href="#figure_07_error">Figure 8-16</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_07_error">&#13;
<img alt="A screenshot showing the 404 page" src="assets/lvue_0816.png"/>&#13;
<h6><span class="label">Figure 8-16. </span>The 404 page</h6>&#13;
</div></figure>&#13;
&#13;
<p>Alternatively, we can use the <code>redirect</code> property in the route configuration to redirect users to a specific route, such as the home page, when they visit an unknown path. For example, we can rewrite our <code>error</code> route as<a data-primary="redirect property" data-type="indexterm" id="id1386"/>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="cm">/**router/index.ts */</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">routes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="cm">/**... */</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">path</code><code class="o">:</code> <code class="s1">'/:pathMatch(.*)*'</code><code class="p">,</code>&#13;
    <code class="nx">redirect</code><code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s1">'home'</code> <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">]</code></pre>&#13;
&#13;
<p>When we visit an unknown path, the router instance will automatically redirect us to the home page, and we no longer need an <code>ErrorView</code> component<a data-primary="" data-startref="ix-comp-rout9" data-type="indexterm" id="id1387"/><a data-primary="" data-startref="ix-comp-rout9a" data-type="indexterm" id="id1388"/><a data-primary="" data-startref="ix-comp-rout9b" data-type="indexterm" id="id1389"/><a data-primary="" data-startref="ix-comp-rout9c" data-type="indexterm" id="id1390"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id363">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we have explored how we can build a routing system for our Vue application using different APIs provided by Vue Router in our application.</p>&#13;
&#13;
<p>Moving between routes requires the data flow to be consistent, like handling data flow between components that aren’t in a direct parent-children relationship. To solve this challenge, we need an efficient data management system for our application. The next chapter introduces Pinia, the official data management library for Vue, and how we can build an efficient, reusable data management system using Pinia APIs.</p>&#13;
</div></section>&#13;
</div></section></body></html>