<html><head></head><body><section data-pdf-bookmark="Chapter 6. Files" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_files">&#13;
<h1><span class="label">Chapter 6. </span>Files</h1>&#13;
&#13;
&#13;
<p>As a developer, you might want to read, write, or inspect a file for any number of reasons. For example, you might want to modify an image and save it to disk, download a video to your user’s SD card (after determining if one is available), or use a simple indexed JSON flat-file database. File handling logic comes up frequently in application development, so a good grasp of the fundamentals is important for most <span class="keep-together">developers</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177232641400">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="files" data-secondary="task overview" data-type="indexterm" id="idm46177232640040"/> this chapter, you’ll learn to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Get properties from a file like size on disk or last modified date.</p>&#13;
</li>&#13;
<li>&#13;
<p>Read and write data to and from a file.</p>&#13;
</li>&#13;
<li>&#13;
<p>Copy data from one file to another.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177232635640">&#13;
<h1>Android</h1>&#13;
&#13;
<p>In<a data-primary="Android" data-secondary="files" data-tertiary="overview of" data-type="indexterm" id="idm46177232633912"/><a data-primary="files" data-secondary="Android" data-tertiary="overview of" data-type="indexterm" id="idm46177232632632"/> Android, a developer might query the device for the location of an external SD on the device, compress a group of files for upload, write XML to track user preferences, get bitmaps from assets, read a resource file, or log out events in a persistent fashion. Even an SQLite database (the AOSP framework–provided database) exists as a single file, so you’d use the same logic to determine its size, or make a duplicate for export.</p>&#13;
&#13;
<p>Reading and writing files in Java has come a long way, and modern versions of the language include streaming APIs, an updated package called <code>java.nio.file</code> (“nio” means “new input/output”), and some handy helper classes like <code>Files</code> and <code>Paths</code> that offer a variety of approaches to file system access. Unfortunately, these are not <span class="keep-together">available</span> to most Android developers, and at the time of this writing, only the most recent two versions of the Android OS—about 21% of all Android installations—had support<a data-primary="Java" data-secondary="java.nio.file package" data-type="indexterm" id="idm46177232607672"/> for the <code>java.nio.file</code> package. Streaming APIs and the <code>Files</code> helper class are not available in any version of Android at this time.</p>&#13;
&#13;
<p>But fear not! With a little ingenuity we can leverage existing frameworks and standard library APIs to do pretty much everything we need to do. The<a data-primary="files" data-secondary="Android" data-tertiary="java.io" data-type="indexterm" id="idm46177232605064"/><a data-primary="Android" data-secondary="files" data-tertiary="java.io" data-type="indexterm" id="idm46177232603816"/> package we’ll be using most is <code>java.io</code> (you guessed it…"input and output”), and one of the classes we’ll be using frequently is <code>java.io.File</code>. A <code>File</code> instance is an abstract representation of a location on the local file system. Note that a <code>File</code> instance represents either a file or a directory; APIs like <code>isDirectory</code> or <code>isFile</code> exist to differentiate them.</p>&#13;
&#13;
<p>To<a data-primary="files" data-secondary="Android" data-tertiary="referencing existing files" data-type="indexterm" id="idm46177232599208"/><a data-primary="Android" data-secondary="files" data-tertiary="referencing existing files" data-type="indexterm" id="idm46177232597912"/> get a reference to an existing file, you can pass the path to a <code>File</code> constructor: <code>File file = new File("path/to/file.ext");</code>. In Android applications, it’s likely the file system will be restricted, and your app will be assigned a special directory on the device that you’ll be given read and write privileges to—you can get this directory by<a data-primary="Android commands and methods" data-secondary="getFilesDir()" data-type="indexterm" id="idm46177232595480"/> calling <code>getFilesDir()</code> on any <code>Context</code> instance, which will return an already constructed <code>File</code> instance representing that directory the system has created for your app. So,<a data-primary="files" data-secondary="Android" data-tertiary="creating new files" data-type="indexterm" id="idm46177232593112"/><a data-primary="Android" data-secondary="files" data-tertiary="creating new files" data-type="indexterm" id="idm46177232591864"/> in an Android application, you can create a new file by passing that directory as the root:</p>&#13;
&#13;
<pre data-type="programlisting">File file = new File(context.getFilesDir(), "path/to/file.ext");</pre>&#13;
&#13;
<p>If<a data-primary="Android commands and methods" data-secondary="file.createNewFile()" data-type="indexterm" id="idm46177232589240"/> the file does not exist, you’ll need to create it: <code>file.createNewFile();</code>. Make sure the path exists as well; you<a data-primary="files" data-secondary="Android" data-tertiary="creating directories" data-type="indexterm" id="idm46177232587688"/><a data-primary="Android" data-secondary="files" data-tertiary="creating directories" data-type="indexterm" id="idm46177232586440"/> can do that by calling <code>file.getParentFile().mkdirs()</code>, which will create any number of directories between the root and the highest-level directory in the path. That’s to say that, using the preceding<a data-primary="Android commands and methods" data-secondary="file.mkdirs()" data-type="indexterm" id="idm46177232584552"/> example, <code>file.mkdirs()</code> will create a folder called “path” and then inside that another folder called “to.” Note<a data-primary="Android commands and methods" data-secondary="file.mkdir()" data-type="indexterm" id="idm46177232582888"/> the plural; <code>file.mkdir()</code> will only create the single directory specified by the <code>File</code> instance.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Get Properties from the File Like Size or Last Modified Date" data-type="sect2"><div class="sect2" id="idm46177232580936">&#13;
<h2>Get Properties from the File Like Size or Last Modified Date</h2>&#13;
&#13;
<p>So, now<a data-primary="files" data-secondary="Android" data-tertiary="get file properties" data-type="indexterm" id="idm46177232579528"/><a data-primary="Android" data-secondary="files" data-tertiary="get file properties" data-type="indexterm" id="idm46177232578248"/> that you have a handle on a <code>File</code> instance, you can read data from it, write data to it, or inspect its properties, like size or modified<a data-primary="Java" data-secondary="files" data-tertiary="get file properties" data-type="indexterm" id="idm46177232576392"/><a data-primary="Kotlin" data-secondary="files" data-tertiary="get file properties" data-type="indexterm" id="idm46177232575144"/> date:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177232573672">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="smal" data-code-language="java" data-type="programlisting"><code class="n">File</code> <code class="n">file</code> <code class="o">=</code> <code class="k">new</code> <code class="n">File</code><code class="o">(</code><code class="n">context</code><code class="o">.</code><code class="na">getFilesDir</code><code class="o">(),</code> <code class="s">"path/to/file.ext"</code><code class="o">);</code>&#13;
<code class="kt">long</code> <code class="n">sizeInBytes</code> <code class="o">=</code> <code class="n">file</code><code class="o">.</code><code class="na">length</code><code class="o">();</code>&#13;
<code class="kt">long</code> <code class="n">lastModifiedTimestamp</code> <code class="o">=</code> <code class="n">file</code><code class="o">.</code><code class="na">lastModified</code><code class="o">();</code></pre>&#13;
&#13;
<p class="less_space pagebreak-before"><em>Kotlin</em></p>&#13;
&#13;
<pre class="smal" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">file</code> <code class="p">=</code> <code class="n">File</code><code class="p">(</code><code class="n">context</code><code class="p">.</code><code class="n">filesDir</code><code class="p">,</code> <code class="s">"path/to/file.ext"</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">sizeInBytes</code> <code class="p">=</code> <code class="n">file</code><code class="p">.</code><code class="n">length</code><code class="p">()</code>&#13;
<code class="k">val</code> <code class="py">lastModifiedTimestamp</code> <code class="p">=</code> <code class="n">file</code><code class="p">.</code><code class="n">lastModified</code><code class="p">()</code></pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Read and Write Data to and from a File" data-type="sect2"><div class="sect2" id="idm46177232495288">&#13;
<h2>Read and Write Data to and from a File</h2>&#13;
&#13;
<p>While<a data-primary="Android" data-secondary="files" data-tertiary="reading and writing data" data-type="indexterm" id="AFread06"/><a data-primary="files" data-secondary="Android" data-tertiary="reading and writing data" data-type="indexterm" id="FAread06"/> you might immediately think about how to write a <code>String</code> to a <code>File</code>, this is actually not the default operation in Java and Android—consider binary files like images, audio and video, and compressed files like ZIPs and TARs. While there are APIs for reading and writing the <code>Strings</code> directory to and from <code>File</code> instances, like <span class="keep-together"><code>FileReader</code></span> and <code>FileWriter</code>, that offer simplified operations for <code>String</code> reading and writing, we’re going to concentrate on Java’s foundational pattern when it comes to reading and writing data: byte streams. The benefit of relying on byte-level data is that the same operation can be used for anything: writing text files, streaming multimedia, downloading images, etc.</p>&#13;
&#13;
<p>Don’t be intimidated! Everything in your program is already represented by bytes at some level, and we can pretty easily get access to that information with existing APIs in the standard library. For example, we could get the bytes from a <code>String</code> simply by<a data-primary="Android commands and methods" data-secondary="getBytes()" data-type="indexterm" id="idm46177232430920"/> calling <code>getBytes()</code> on that <code>String</code> instance—no sweat.</p>&#13;
&#13;
<p>That said, you might be surprised to learn that there are no specific <code>write</code> or <code>read</code> methods on the <code>java.io.File</code> class, and in fact the process of reading and writing requires another intermediary facilitator class: a stream (an instance of an <code>InputStream</code> or <code>OutputStream</code>, or a subclass, as appropriate). The concept of a stream in Java is simply a piece of data that can be read sequentially, from start to finish. The advantage of this approach is that we don’t need to have all of the information in memory at once. In fact, the object itself might not even have a discernible end! For example, we might want to play video from a live source; using a stream, we just read bytes in as they arrive and buffer or display them as appropriate to our program.</p>&#13;
&#13;
<p>But let’s get back to our practical example. We’ll start by writing to a file. Unsurprisingly, you’ll need an instance of a <code>FileOutputStream</code> to do that. You can get an instance of a <code>FileOutputStream</code> by invoking the constructor and passing the <code>File</code> instance you’ve already got a reference to: <code>OutputStream outputStream</code> <code>=</code> <code>new FileOutputStream(file);</code>. The <code>write</code> method of <code>FileOutputStream</code> has a few different signatures, but let’s stick with one in the pattern of our conversation so far: <code>write(byte[] bytes)</code>. Just pass an array of bytes as the only argument, and those bytes will be written to the <code>File</code> instance referenced by the <code>FileOutputStream</code>.</p>&#13;
&#13;
<p>So,<a data-primary="Java" data-secondary="files" data-tertiary="reading and writing data" data-type="indexterm" id="JFread06"/><a data-primary="Kotlin" data-secondary="files" data-tertiary="reading and writing data" data-type="indexterm" id="KFread06"/> if we wanted to write some text to the file, we could do something like:</p>&#13;
<aside class="java-kotlin less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177232416008">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// outputStream is a valid instance of FileOutputStream</code>&#13;
<code class="n">String</code> <code class="n">message</code> <code class="o">=</code> <code class="s">"Hello world!"</code><code class="o">;</code>&#13;
<code class="n">outputStream</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="n">message</code><code class="o">.</code><code class="na">getBytes</code><code class="o">());</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="c1">// outputStream is a valid instance of FileOutputStream</code>&#13;
<code class="k">val</code> <code class="py">message</code> <code class="p">=</code> <code class="s">"Hello world!"</code>&#13;
<code class="n">outputStream</code><code class="p">.</code><code class="n">write</code><code class="p">(</code><code class="n">message</code><code class="p">.</code><code class="n">toByteArray</code><code class="p">())</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Voila! You’ve just written “Hello world!” to your file! Of course, as with most things Java and Android, there’s a number of caveats that make this fairly straightforward concept a little clunkier. For example, the <code>FileOutputStream</code> constructor throws a <code>FileNotFoundException</code>, and the <code>write</code> method throws an <code>IOException</code>. Further, we have to make sure the stream is closed when we’re done with it, which itself throws an <code>IOException</code>. While the fully expressed block to do all of this work can be a little hard to follow, we can wrap it all in a method with a checked exception and reduce the line count a bit:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177232361928">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Files</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">writeToFile</code><code class="o">(</code><code class="n">File</code> <code class="n">file</code><code class="o">,</code> <code class="kt">byte</code><code class="o">[]</code> <code class="n">data</code><code class="o">)</code>&#13;
      <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="n">OutputStream</code> <code class="n">outputStream</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="k">if</code> <code class="o">(!</code><code class="n">file</code><code class="o">.</code><code class="na">exists</code><code class="o">())</code> <code class="o">{</code>&#13;
        <code class="c1">// we need to create all the parent directories first</code>&#13;
        <code class="n">file</code><code class="o">.</code><code class="na">getParentFile</code><code class="o">().</code><code class="na">mkdirs</code><code class="o">();</code>&#13;
        <code class="c1">// now we can create an empty file</code>&#13;
        <code class="n">file</code><code class="o">.</code><code class="na">createNewFile</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
      <code class="c1">// let's get a stream handle so we can write to it</code>&#13;
      <code class="n">outputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileOutputStream</code><code class="o">(</code><code class="n">file</code><code class="o">);</code>&#13;
      <code class="c1">// and write the data</code>&#13;
      <code class="n">outputStream</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="n">data</code><code class="o">);</code>&#13;
    <code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>&#13;
      <code class="k">if</code> <code class="o">(</code><code class="n">outputStream</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">outputStream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="nd">@Throws</code><code class="o">(</code><code class="nl">IOException:</code><code class="o">:</code><code class="n">class</code><code class="o">)</code>&#13;
<code class="n">fun</code> <code class="nf">writeToFile</code><code class="o">(</code><code class="nl">file:</code> <code class="n">File</code><code class="o">,</code> <code class="nl">data:</code> <code class="n">ByteArray</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">var</code> <code class="nl">outputStream:</code> <code class="n">OutputStream</code><code class="o">?</code> <code class="o">=</code> <code class="kc">null</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
        <code class="k">if</code> <code class="o">(!</code><code class="n">file</code><code class="o">.</code><code class="na">exists</code><code class="o">())</code> <code class="o">{</code>&#13;
            <code class="c1">// we need to create all the parent directories first</code>&#13;
            <code class="n">file</code><code class="o">.</code><code class="na">parentFile</code><code class="o">.</code><code class="na">mkdirs</code><code class="o">()</code>&#13;
            <code class="c1">// now we can create an empty file</code>&#13;
            <code class="n">file</code><code class="o">.</code><code class="na">createNewFile</code><code class="o">()</code>&#13;
        <code class="o">}</code>&#13;
        <code class="c1">// let's get a stream handle so we can write to it</code>&#13;
        <code class="n">outputStream</code> <code class="o">=</code> <code class="n">FileOutputStream</code><code class="o">(</code><code class="n">file</code><code class="o">)</code>&#13;
        <code class="c1">// and write the data</code>&#13;
        <code class="n">outputStream</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="n">data</code><code class="o">)</code>&#13;
    <code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>&#13;
        <code class="n">outputStream</code><code class="o">?.</code><code class="na">close</code><code class="o">()</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>And you could use it like so:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177232207864">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">File</code> <code class="n">file</code> <code class="o">=</code> <code class="k">new</code> <code class="n">File</code><code class="o">(</code><code class="n">context</code><code class="o">.</code><code class="na">getFilesDir</code><code class="o">(),</code> <code class="s">"path/to/file.ext"</code><code class="o">);</code>&#13;
<code class="kt">byte</code><code class="o">[]</code> <code class="n">data</code> <code class="o">=</code> <code class="s">"hello world!"</code><code class="o">.</code><code class="na">toBytes</code><code class="o">();</code>&#13;
<code class="n">Files</code><code class="o">.</code><code class="na">writeToFile</code><code class="o">(</code><code class="n">file</code><code class="o">,</code> <code class="n">data</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">val</code> <code class="n">file</code> <code class="o">=</code> <code class="n">File</code><code class="o">(</code><code class="n">context</code><code class="o">.</code><code class="na">getFilesDir</code><code class="o">(),</code> <code class="s">"path/to/file.ext"</code><code class="o">)</code>&#13;
<code class="n">writeToFile</code><code class="o">(</code><code class="n">file</code><code class="o">,</code> <code class="s">"hello world!"</code><code class="o">.</code><code class="na">toByteArray</code><code class="o">())</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Reading data from files follows a very similar pattern. As you may have guessed, we’ll be using a <code>FileInputStream</code> instead of a <code>FileOutputStream</code>.</p>&#13;
&#13;
<p>Again, since we’re thinking in terms of binary data, we’ll need to do a little more work to get the file contents as human-readable text. If you’re regularly reading and writing plain-text files, there are simpler approaches like <code>FileWriter</code> and <code>FileReader</code>, but as stated, using byte streams is a universal solution, and converting to a <code>String</code> is trivial.</p>&#13;
&#13;
<p>Similar to <code>FileOutputStream</code>, the <code>FileInputStream</code> constructor will also accept a <code>File</code> parameter: <code>InputStream inputStream = new FileInputStream(file);</code>. Once that’s been instantiated, you can read single bytes with the plain <code>read()</code> signature, or large blocks by passing in a byte array buffer. We’ll talk about the single-byte simple <code>read()</code> method now, but keep in mind that using buffers is generally more efficient, especially for large files.</p>&#13;
&#13;
<p>The <code>read</code> method returns an <code>int</code>, which is a representation of either the number of bytes read, or -1 to signify the end of the file (and stream). You can cast this to a <code>char</code> to build up the <code>String</code> representation of the file’s content:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="c1">// inputStream is a valid instance of a FileInputStream</code>&#13;
<code class="n">StringBuilder</code> <code class="n">builder</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">();</code>&#13;
<code class="kt">int</code> <code class="kt">byte</code> <code class="o">=</code> <code class="n">inputStream</code><code class="o">.</code><code class="na">read</code><code class="o">();</code>&#13;
<code class="k">while</code> <code class="o">(</code><code class="kt">byte</code> <code class="o">!=</code> <code class="o">-</code><code class="mi">1</code><code class="o">)</code> <code class="o">{</code>&#13;
  <code class="n">builder</code><code class="o">.</code><code class="na">append</code><code class="o">((</code><code class="kt">char</code><code class="o">)</code> <code class="kt">byte</code><code class="o">);</code>&#13;
  <code class="kt">byte</code> <code class="o">=</code> <code class="n">inputStream</code><code class="o">.</code><code class="na">read</code><code class="o">();</code>&#13;
<code class="o">}</code>&#13;
<code class="n">String</code> <code class="n">message</code> <code class="o">=</code> <code class="n">builder</code><code class="o">.</code><code class="na">toString</code><code class="o">();</code></pre>&#13;
&#13;
<p>Again, several of these methods <code>throw</code> checked exceptions, and again we need to close the stream when we’re done with it, so it can be useful to wrap this all up in a single checked method:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177231912632">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="smal" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Files</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">readStringFromFile</code><code class="o">(</code><code class="n">File</code> <code class="n">file</code><code class="o">)</code>&#13;
      <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="n">InputStream</code> <code class="n">inputStream</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="c1">// let's get a stream handle so we can read from the file</code>&#13;
      <code class="n">inputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileInputStream</code><code class="o">(</code><code class="n">file</code><code class="o">);</code>&#13;
      <code class="c1">// a StringBuilder is an efficient way to build up a String</code>&#13;
      <code class="n">StringBuilder</code> <code class="n">builder</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">();</code>&#13;
      <code class="c1">// For readability, I'll include this on a new line, but this is</code>&#13;
      <code class="c1">// often done within the conditional check of the loop</code>&#13;
      <code class="kt">int</code> <code class="n">b</code> <code class="o">=</code> <code class="n">inputStream</code><code class="o">.</code><code class="na">read</code><code class="o">();</code>&#13;
      <code class="k">while</code> <code class="o">(</code><code class="n">b</code> <code class="o">!=</code> <code class="o">-</code><code class="mi">1</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">builder</code><code class="o">.</code><code class="na">append</code><code class="o">((</code><code class="kt">char</code><code class="o">)</code> <code class="n">b</code><code class="o">);</code>&#13;
        <code class="n">b</code> <code class="o">=</code> <code class="n">inputStream</code><code class="o">.</code><code class="na">read</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
      <code class="c1">// we can return here, since finally blocks will always execute!</code>&#13;
      <code class="k">return</code> <code class="n">builder</code><code class="o">.</code><code class="na">toString</code><code class="o">();</code>&#13;
    <code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>&#13;
      <code class="k">if</code> <code class="o">(</code><code class="n">inputStream</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">inputStream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="smal" data-code-language="kotlin" data-type="programlisting"><code class="n">@Throws</code><code class="p">(</code><code class="n">IOException</code><code class="o">::</code><code class="k">class</code><code class="p">)</code>&#13;
<code class="k">fun</code> <code class="nf">readStringFromFile</code><code class="p">(</code><code class="n">file</code><code class="p">:</code> <code class="n">File</code><code class="p">):</code> <code class="n">String</code> <code class="p">{</code>&#13;
  <code class="k">var</code> <code class="py">inputStream</code><code class="p">:</code> <code class="n">InputStream</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
  <code class="k">try</code> <code class="p">{</code>&#13;
    <code class="c1">// let's get a stream handle so we can read from the file</code>&#13;
    <code class="n">inputStream</code> <code class="p">=</code> <code class="n">FileInputStream</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>&#13;
    <code class="c1">// a StringBuilder is an efficient way to build up a String</code>&#13;
    <code class="k">val</code> <code class="py">builder</code> <code class="p">=</code> <code class="n">StringBuilder</code><code class="p">()</code>&#13;
    <code class="c1">// For readability, I'll include this on a new line, but this is</code>&#13;
    <code class="c1">// often done within the conditional check of the loop</code>&#13;
    <code class="k">var</code> <code class="py">b</code> <code class="p">=</code> <code class="n">inputStream</code><code class="p">.</code><code class="n">read</code><code class="p">()</code>&#13;
    <code class="k">while</code> <code class="p">(</code><code class="n">b</code> <code class="p">!=</code> <code class="p">-</code><code class="m">1</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="n">builder</code><code class="p">.</code><code class="n">append</code><code class="p">(</code><code class="n">b</code><code class="p">.</code><code class="n">toChar</code><code class="p">())</code>&#13;
      <code class="n">b</code> <code class="p">=</code> <code class="n">inputStream</code><code class="p">.</code><code class="n">read</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
    <code class="c1">// note that we can return here, since finally blocks will always execute!</code>&#13;
    <code class="k">return</code> <code class="n">builder</code><code class="p">.</code><code class="n">toString</code><code class="p">()</code>&#13;
  <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>&#13;
    <code class="n">inputStream</code><code class="o">?.</code><code class="n">close</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Since there are other stream sources besides <code>FileInputStream</code>, you may consider abstracting the method to convert a stream to a string, like so:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177231791176">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">readStringFromFile</code><code class="o">(</code><code class="n">File</code> <code class="n">file</code><code class="o">)</code>&#13;
      <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="n">InputStream</code> <code class="n">stream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileInputStream</code><code class="o">(</code><code class="n">file</code><code class="o">);</code>&#13;
    <code class="k">return</code> <code class="nf">getStringFromStream</code><code class="o">(</code><code class="n">stream</code><code class="o">);</code>&#13;
&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">getStringFromStream</code><code class="o">(</code><code class="n">InputStream</code> <code class="n">stream</code><code class="o">)</code> <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="c1">// a StringBuilder is an efficient way to build up a String</code>&#13;
      <code class="n">StringBuilder</code> <code class="n">builder</code> <code class="o">=</code> <code class="k">new</code> <code class="n">StringBuilder</code><code class="o">();</code>&#13;
      <code class="c1">// For readability, I'll include this on a new line, but this is</code>&#13;
      <code class="c1">// often done within the conditional check of the loop</code>&#13;
      <code class="kt">int</code> <code class="n">b</code> <code class="o">=</code> <code class="n">stream</code><code class="o">.</code><code class="na">read</code><code class="o">();</code>&#13;
      <code class="k">while</code> <code class="o">(</code><code class="n">b</code> <code class="o">!=</code> <code class="o">-</code><code class="mi">1</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">builder</code><code class="o">.</code><code class="na">append</code><code class="o">((</code><code class="kt">char</code><code class="o">)</code> <code class="n">b</code><code class="o">);</code>&#13;
        <code class="n">b</code> <code class="o">=</code> <code class="n">stream</code><code class="o">.</code><code class="na">read</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
      <code class="c1">// note that we can return here, since finally blocks will always execute!</code>&#13;
      <code class="k">return</code> <code class="n">builder</code><code class="o">.</code><code class="na">toString</code><code class="o">();</code>&#13;
    <code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>&#13;
      <code class="k">if</code> <code class="o">(</code><code class="n">stream</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">stream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">object</code> <code class="nc">Files</code> <code class="p">{</code>&#13;
&#13;
  <code class="n">@Throws</code><code class="p">(</code><code class="n">IOException</code><code class="o">::</code><code class="k">class</code><code class="p">)</code>&#13;
  <code class="k">fun</code> <code class="nf">readStringFromFile</code><code class="p">(</code><code class="n">file</code><code class="p">:</code> <code class="n">File</code><code class="p">):</code> <code class="n">String</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">stream</code> <code class="p">=</code> <code class="n">FileInputStream</code><code class="p">(</code><code class="n">file</code><code class="p">)</code>&#13;
    <code class="k">return</code> <code class="n">getStringFromStream</code><code class="p">(</code><code class="n">stream</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="n">@Throws</code><code class="p">(</code><code class="n">IOException</code><code class="o">::</code><code class="k">class</code><code class="p">)</code>&#13;
  <code class="k">fun</code> <code class="nf">getStringFromStream</code><code class="p">(</code><code class="n">stream</code><code class="p">:</code> <code class="n">InputStream</code><code class="p">):</code> <code class="n">String</code> <code class="p">{</code>&#13;
    <code class="n">stream</code><code class="p">.</code><code class="n">use</code> <code class="p">{</code> <code class="n">s</code> <code class="p">-&gt;</code>&#13;
      <code class="k">val</code> <code class="py">builder</code> <code class="p">=</code> <code class="n">StringBuilder</code><code class="p">()</code>&#13;
      <code class="k">var</code> <code class="py">b</code> <code class="p">=</code> <code class="n">s</code><code class="p">.</code><code class="n">read</code><code class="p">()</code>&#13;
      <code class="k">while</code> <code class="p">(</code><code class="n">b</code> <code class="p">!=</code> <code class="p">-</code><code class="m">1</code><code class="p">)</code> <code class="p">{</code>&#13;
          <code class="n">builder</code><code class="p">.</code><code class="n">append</code><code class="p">(</code><code class="n">b</code><code class="p">.</code><code class="n">toChar</code><code class="p">())</code>&#13;
          <code class="n">b</code> <code class="p">=</code> <code class="n">s</code><code class="p">.</code><code class="n">read</code><code class="p">()</code>&#13;
      <code class="p">}</code>&#13;
      <code class="k">return</code> <code class="n">builder</code><code class="p">.</code><code class="n">toString</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Copy Data from One File to Another" data-type="sect2"><div class="sect2" id="idm46177232439672">&#13;
<h2>Copy Data from One File to Another</h2>&#13;
&#13;
<p>You<a data-primary="" data-startref="AFread06" data-type="indexterm" id="idm46177231506920"/><a data-primary="" data-startref="FAread06" data-type="indexterm" id="idm46177231342264"/><a data-primary="" data-startref="JFread06" data-type="indexterm" id="idm46177231341320"/><a data-primary="" data-startref="KFread06" data-type="indexterm" id="idm46177231340376"/><a data-primary="files" data-secondary="Android" data-tertiary="copying data" data-type="indexterm" id="idm46177231339432"/><a data-primary="Android" data-secondary="files" data-tertiary="copying data" data-type="indexterm" id="idm46177231338216"/><a data-primary="Java" data-secondary="files" data-tertiary="copying data" data-type="indexterm" id="idm46177231337000"/><a data-primary="Kotlin" data-secondary="files" data-tertiary="copying data" data-type="indexterm" id="idm46177231335784"/> can see how we might easily combine these two operations to copy any file, be it a simple text file or a gig worth of video! Since we neither know nor care if it’s a text file or a binary file, we don’t have to do any convolutions around casting <code>Character</code> instances or pulling bytes from a <code>String</code>—by keeping our logic agnostic, you can see how this operation is actually one of the most readable:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177231333256">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Files</code> <code class="o">{</code>&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">copy</code><code class="o">(</code><code class="n">File</code> <code class="n">source</code><code class="o">,</code> <code class="n">File</code> <code class="n">destination</code><code class="o">)</code>&#13;
      <code class="kd">throws</code> <code class="n">IOException</code> <code class="o">{</code>&#13;
    <code class="n">OutputStream</code> <code class="n">outputStream</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
    <code class="n">InputStream</code> <code class="n">inputStream</code> <code class="o">=</code> <code class="kc">null</code><code class="o">;</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="n">inputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileInputStream</code><code class="o">(</code><code class="n">source</code><code class="o">);</code>&#13;
      <code class="n">outputStream</code> <code class="o">=</code> <code class="k">new</code> <code class="n">FileOutputStream</code><code class="o">(</code><code class="n">destination</code><code class="o">);</code>&#13;
      <code class="kt">int</code> <code class="kt">byte</code> <code class="o">=</code> <code class="n">inputStream</code><code class="o">.</code><code class="na">read</code><code class="o">();</code>&#13;
      <code class="k">while</code> <code class="o">(</code><code class="kt">byte</code> <code class="o">!=</code> <code class="o">-</code><code class="mi">1</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">outputStream</code><code class="o">.</code><code class="na">write</code><code class="o">(</code><code class="kt">byte</code><code class="o">);</code>&#13;
        <code class="kt">byte</code> <code class="o">=</code> <code class="n">inputStream</code><code class="o">.</code><code class="na">read</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>&#13;
      <code class="k">if</code> <code class="o">(</code><code class="n">inputStream</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">inputStream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
      <code class="k">if</code> <code class="o">(</code><code class="n">outputStream</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">outputStream</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">@Throws</code><code class="p">(</code><code class="n">IOException</code><code class="o">::</code><code class="k">class</code><code class="p">)</code>&#13;
<code class="k">fun</code> <code class="nf">copyFile</code><code class="p">(</code><code class="n">source</code><code class="p">:</code> <code class="n">File</code><code class="p">,</code> <code class="n">destination</code><code class="p">:</code> <code class="n">File</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">var</code> <code class="py">outputStream</code><code class="p">:</code> <code class="n">OutputStream</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
  <code class="k">var</code> <code class="py">inputStream</code><code class="p">:</code> <code class="n">InputStream</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code>&#13;
  <code class="k">try</code> <code class="p">{</code>&#13;
    <code class="n">inputStream</code> <code class="p">=</code> <code class="n">FileInputStream</code><code class="p">(</code><code class="n">source</code><code class="p">)</code>&#13;
    <code class="n">outputStream</code> <code class="p">=</code> <code class="n">FileOutputStream</code><code class="p">(</code><code class="n">destination</code><code class="p">)</code>&#13;
    <code class="k">var</code> <code class="py">byteRead</code> <code class="p">=</code> <code class="n">inputStream</code><code class="p">.</code><code class="n">read</code><code class="p">()</code>&#13;
    <code class="k">while</code> <code class="p">(</code><code class="n">byteRead</code> <code class="p">!=</code> <code class="p">-</code><code class="m">1</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="n">outputStream</code><code class="p">.</code><code class="n">write</code><code class="p">(</code><code class="n">byteRead</code><code class="p">)</code>&#13;
      <code class="n">byteRead</code> <code class="p">=</code> <code class="n">inputStream</code><code class="p">.</code><code class="n">read</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>&#13;
    <code class="n">inputStream</code><code class="o">?.</code><code class="n">close</code><code class="p">()</code>&#13;
    <code class="n">outputStream</code><code class="o">?.</code><code class="n">close</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>We<a data-primary="Android commands and methods" data-secondary="InputStream.read" data-type="indexterm" id="idm46177231203976"/> have used the <code>InputStream.read</code> method in these examples for clarity. This method returns a single byte per invocation. You’ll be able to get much improved performance writing chunks of bytes into sized byte arrays generally known as “buffers.” <code>InputStream</code> has <code>read</code> methods for these buffers, and <code>OutputStream</code> has <code>write</code> methods for them as well.</p>&#13;
</div>&#13;
&#13;
<p>That’s it! Now you’ve got the tools you need to read and write to the filesystem in an Android app. Be sure to check out the <code>File</code> API in the dev docs for more!</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The<a data-primary="Java" data-secondary="Apache Commons Java library" data-type="indexterm" id="idm46177231031304"/><a data-primary="Apache Commons Java library" data-type="indexterm" id="idm46177231030328"/> Apache Commons Java library has a well-known and well-regarded file and input/output module <code>apache.commons.io</code>. Of particular use are the <code>IOUtils</code> and <code>FileUtils</code> helper classes.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177232635016">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>In iOS, file operations drive a lot of the underpinnings of some very powerful technologies. Eventually, in any sufficiently complex application, a use case will arise that will require reading and writing files on the filesystem. Due to the sandboxed nature of iOS, there is a little bit of prerequisite knowledge on how data is organized necessary to get started working with files.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Get Properties from the File Like Size or Last Modified Date" data-type="sect2"><div class="sect2" id="idm46177231025928">&#13;
<h2>Get Properties from the File Like Size or Last Modified Date</h2>&#13;
&#13;
<p>There<a data-primary="files" data-secondary="iOS" data-tertiary="get file properties" data-type="indexterm" id="idm46177231024392"/><a data-primary="iOS" data-secondary="files" data-tertiary="get file properties" data-type="indexterm" id="idm46177231023112"/> are really two main areas of focus where file access is allowed: the application bundle container and the app’s data container. Let’s start with the application bundle container.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="App bundles" data-type="sect3"><div class="sect3" id="idm46177231021448">&#13;
<h3>App bundles</h3>&#13;
&#13;
<p>The<a data-primary="application bundle container (app bundles)" data-type="indexterm" id="idm46177231019912"/> app bundle includes the application binary and all resources compiled and delivered with the app. On installation, this directory is code-signed to provide protection from tampering. Because of this, it’s not possible to change the files inside the app bundle or write to the directory (more on that follows).</p>&#13;
&#13;
<p>Access to files within the app bundle is provided via the <code>Bundle</code> class in Swift. An app can have multiple bundles via frameworks, so targeting the application bundle is done with the <code>main</code> class variable. In order to access a file named <em>image.png</em> a file URL is created as shown here:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"> <code class="kd">let</code> <code class="nv">file</code> <code class="p">=</code> <code class="n">Bundle</code><code class="p">.</code><code class="n">main</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="n">forResource</code><code class="p">:</code> <code class="s">"image"</code><code class="p">,</code> <code class="n">withExtension</code><code class="p">:</code> <code class="s">"png"</code><code class="p">)</code></pre>&#13;
&#13;
<p>If that file were in a subdirectory named <em>sample-images</em>, the variable would be instantiated like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"> <code class="kd">let</code> <code class="nv">file</code> <code class="p">=</code>&#13;
   <code class="n">Bundle</code><code class="p">.</code><code class="n">main</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="n">forResource</code><code class="p">:</code> <code class="s">"image"</code><code class="p">,</code> <code class="n">withExtension</code><code class="p">:</code> <code class="s">"png"</code><code class="p">,</code> <code class="n">subdirectory</code><code class="p">:</code>&#13;
   <code class="s">"sample-images"</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data (and documents)" data-type="sect3"><div class="sect3" id="idm46177230983064">&#13;
<h3>Data (and documents)</h3>&#13;
&#13;
<p>Using static and unchangeable files from the application bundle quickly becomes limiting. Eventually the need will arise to read and write user-generated documents and data. There is a set of three directories created for each application that is installed within iOS:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Documents</p>&#13;
</li>&#13;
<li>&#13;
<p>Library</p>&#13;
</li>&#13;
<li>&#13;
<p>tmp</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Each of these directories serves a specific purpose as detailed in the following <span class="keep-together">sections</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Documents" data-type="sect3"><div class="sect3" id="idm46177230973000">&#13;
<h3>Documents</h3>&#13;
&#13;
<p>User-generated content and files that will require access by the user should go here. These files are backed up in iTunes and iCloud by default. File sharing can also be enabled for the app to let users interact with these files directly.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Library" data-type="sect3"><div class="sect3" id="idm46177230971128">&#13;
<h3>Library</h3>&#13;
&#13;
<p>Within the application’s <em>Library</em> folder, there are a few predefined directories where additional files are typically placed. Two of the most important of these are: <em>Application Support</em> and <em>Caches</em>. Data that needs to be persisted for use in the future but isn’t user-facing should be stored in <em>Application Support</em>. Cached data should be stored in <em>Caches</em>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="tmp" data-type="sect3"><div class="sect3" id="idm46177230919240">&#13;
<h3>tmp</h3>&#13;
&#13;
<p>This directory is for writing and reading temporary files. It is the application’s responsibility to clean this directory by deleting unused files. However, the system may occasionally purge this directory when the app is not in use.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Accessing directories" data-type="sect3"><div class="sect3" id="idm46177230917368">&#13;
<h3>Accessing directories</h3>&#13;
&#13;
<p>It’s nearly impossible to directly construct a URL to a file or directory within an application’s data container because of the arcane and opaque path to these files. This is intentional on the part of Apple and requires the developer to resort to a jack-of-all-trades class for file operations called <code>FileManager</code>.</p>&#13;
&#13;
<p>To access a file named <em>image.png</em> in the application’s <em>Documents</em> directory, for example, a URL could be constructed like so:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">file</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code>&#13;
  <code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="k">for</code><code class="p">:</code> <code class="p">.</code><code class="n">documentDirectory</code><code class="p">,</code> <code class="k">in</code><code class="p">:</code> <code class="p">.</code><code class="n">userDomainMask</code><code class="p">,</code> <code class="n">appropriateFor</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">create</code><code class="p">:</code>&#13;
  <code class="kc">false</code><code class="p">).</code><code class="n">appendingPathComponent</code><code class="p">(</code><code class="s">"image.png"</code><code class="p">)</code></pre>&#13;
&#13;
<p>On a simulator, the direct path to this file is <em>~/Library/Developer/CoreSimulator/Devices/CF5BCBA7-C7CA-4484-AB54-7BE938D67ECB/data/Containers/Data/Application/313B2DDD-ABDD-4D14-B6CD-85847F29EF2C/Documents/image.png</em>.</p>&#13;
&#13;
<p>Notice the <code>.documentDirectory</code> enum value used for targeting a specific directory within the app’s data container. The work of trying to determine all of the parent directories was done for you using <code>FileManager</code>. Additionally, there are a few other predefined keys available provided by this class. For example, the path for a flat file named <em>data.json</em> stored in the application’s <em>Application Support</em> directory is created as shown:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">jsonFile</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="k">for</code><code class="p">:</code> <code class="p">.</code><code class="n">applicationSupportDirectory</code><code class="p">,</code> <code class="k">in</code><code class="p">:</code> <code class="p">.</code><code class="n">userDomainMask</code><code class="p">,</code> <code class="n">appropriateFor</code><code class="p">:</code>&#13;
    <code class="kc">nil</code><code class="p">,</code> <code class="n">create</code><code class="p">:</code> <code class="kc">false</code><code class="p">).</code><code class="n">appendingPathComponent</code><code class="p">(</code><code class="s">"data.json"</code><code class="p">)</code></pre>&#13;
&#13;
<p>And, here’s how a path for a file named <em>download.dat</em> stored in the temporary directory could be created to be accessed later on:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">tempFile</code> <code class="p">=</code>&#13;
  <code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">temporaryDirectory</code><code class="p">.</code><code class="n">appendingPathComponent</code><code class="p">(</code><code class="s">"download.dat"</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="File attributes" data-type="sect3"><div class="sect3" id="idm46177230917032">&#13;
<h3>File attributes</h3>&#13;
&#13;
<p>Now that the basics of an application’s file structure have been covered, let’s take a look at file operations themselves. Remarkably, within the<a data-primary="Swift Standard Library" data-type="indexterm" id="idm46177230719576"/> Swift Standard Library, they are fairly trivial and typically require only a few lines to complete.</p>&#13;
&#13;
<p>Using the <em>image.png</em> example for an image included in an application’s main bundle, the file size can be obtained directly on the <code>URL</code> object created to access the file as shown here:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">url</code> <code class="p">=</code> <code class="n">Bundle</code><code class="p">.</code><code class="n">main</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="n">forResource</code><code class="p">:</code> <code class="s">"image"</code><code class="p">,</code> <code class="n">withExtension</code><code class="p">:</code> <code class="s">"png"</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="kd">let</code> <code class="nv">resourceValues</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">url</code><code class="p">.</code><code class="n">resourceValues</code><code class="p">(</code><code class="n">forKeys</code><code class="p">:</code> <code class="p">[.</code><code class="n">fileSizeKey</code><code class="p">])</code> <code class="p">{</code>&#13;
	<code class="bp">print</code><code class="p">(</code><code class="n">resourceValues</code><code class="p">.</code><code class="n">fileSize</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The variable <code>url</code> is a <code>URL</code> object that points to a file named <em>image</em> with the file extension <em>png</em> (i.e., <em>image.png</em>) located in the application bundle. There is a method on <code>URL</code> that synchronously pulls “resource values” (what other operating systems might call “file attributes”) for the specified keys. In this example, we’ve given the key <code>.fileSizeKey</code>, which translates to the file’s size on disk.</p>&#13;
&#13;
<p>Grabbing additional file attributes is possible by including additional keys besides the file size key provided. For example, to grab a file’s last modified date, the <code>.contentModificationDateKey</code> key could be provided instead of <code>.fileSizeKey</code>. In addition, you can pull both of these attributes at the same time as in the example here:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">url</code> <code class="p">=</code> <code class="n">Bundle</code><code class="p">.</code><code class="n">main</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="n">forResource</code><code class="p">:</code> <code class="s">"image"</code><code class="p">,</code> <code class="n">withExtension</code><code class="p">:</code> <code class="s">"png"</code><code class="p">)</code>&#13;
<code class="k">if</code> <code class="kd">let</code> <code class="nv">resourceValues</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">url</code><code class="p">.</code><code class="n">resourceValues</code><code class="p">(</code><code class="n">forKeys</code><code class="p">:</code> <code class="p">[.</code><code class="n">fileSizeKey</code><code class="p">,</code>&#13;
<code class="p">.</code> <code class="n">contentModificationDateKey</code><code class="p">])</code> <code class="p">{</code>&#13;
	<code class="bp">print</code><code class="p">(</code><code class="n">resourceValues</code><code class="p">.</code><code class="n">fileSize</code><code class="p">)</code>&#13;
	<code class="bp">print</code><code class="p">(</code><code class="n">resourceValues</code><code class="p">.</code><code class="n">contentModificationDate</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reading and Writing Data to and from a File" data-type="sect2"><div class="sect2" id="idm46177230638120">&#13;
<h2>Reading and Writing Data to and from a File</h2>&#13;
&#13;
<p>There<a data-primary="files" data-secondary="iOS" data-tertiary="reading and writing data" data-type="indexterm" id="idm46177230599896"/><a data-primary="iOS" data-secondary="files" data-tertiary="reading and writing data" data-type="indexterm" id="idm46177230598680"/> are simple convenience methods for reading and writing files provided for a few objects within the<a data-primary="Foundation framework" data-type="indexterm" id="idm46177230597256"/> Foundation framework and Swift Standard Library—notably <code>String</code> and <code>Data</code>. For example, to read a text file named <em>file.txt</em> from an app’s <em>Documents</em> directory into a string object, use the following code:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">file</code> <code class="p">=</code>&#13;
  <code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="k">for</code><code class="p">:</code> <code class="p">.</code><code class="n">documentDirectory</code><code class="p">,</code> <code class="k">in</code><code class="p">:</code> <code class="p">.</code><code class="n">userDomainMask</code><code class="p">,</code>&#13;
  <code class="n">appropriateFor</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">create</code><code class="p">:</code> <code class="kc">false</code><code class="p">).</code><code class="n">appendingPathComponent</code><code class="p">(</code><code class="s">"file.txt"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Read the file into a string</code>&#13;
<code class="kd">let</code> <code class="nv">contents</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="nb">String</code><code class="p">(</code><code class="n">contentsOf</code><code class="p">:</code> <code class="n">file</code><code class="p">,</code> <code class="n">encoding</code><code class="p">:</code> <code class="p">.</code><code class="n">utf8</code><code class="p">)</code></pre>&#13;
&#13;
<p>Updating the file is similar and requires a call to <code>write(to:atomically:encoding:)</code> as shown here:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">file</code> <code class="p">=</code>&#13;
  <code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="k">for</code><code class="p">:</code> <code class="p">.</code><code class="n">documentDirectory</code><code class="p">,</code> <code class="k">in</code><code class="p">:</code> <code class="p">.</code><code class="n">userDomainMask</code><code class="p">,</code>&#13;
  <code class="n">appropriateFor</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">create</code><code class="p">:</code> <code class="kc">false</code><code class="p">).</code><code class="n">appendingPathComponent</code><code class="p">(</code><code class="s">"file.txt"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Read the file from the Documents directory</code>&#13;
<code class="kd">var</code> <code class="nv">contents</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="nb">String</code><code class="p">(</code><code class="n">contentsOf</code><code class="p">:</code> <code class="n">file</code><code class="p">,</code> <code class="n">encoding</code><code class="p">:</code> <code class="p">.</code><code class="n">utf8</code><code class="p">)</code>&#13;
&#13;
<code class="p">...</code>&#13;
&#13;
<code class="c1">// Write the string back to the same file</code>&#13;
<code class="k">try</code><code class="p">?</code> <code class="n">contents</code><code class="p">.</code><code class="n">write</code><code class="p">(</code><code class="n">to</code><code class="p">:</code> <code class="n">file</code><code class="p">,</code> <code class="n">atomically</code><code class="p">:</code> <code class="kc">false</code><code class="p">,</code> <code class="n">encoding</code><code class="p">:</code> <code class="p">.</code><code class="n">utf8</code><code class="p">)</code></pre>&#13;
&#13;
<p>There isn’t much different with <code>Data</code> objects. These are objects designed to provide raw access to byte data separate from a C-style byte array. For example, let’s say you had an image file URL; you could read the image into memory and write the image to disk as shown here:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// Read the file's data into a Data object</code>&#13;
<code class="kd">var</code> <code class="nv">data</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">Data</code><code class="p">(</code><code class="n">contentsOf</code><code class="p">:</code> <code class="n">imageFileUrl</code><code class="p">)</code>&#13;
&#13;
<code class="p">...</code>&#13;
&#13;
<code class="c1">// Write the data back to the same file</code>&#13;
<code class="k">try</code><code class="p">?</code> <code class="n">data</code><code class="p">?.</code><code class="n">write</code><code class="p">(</code><code class="n">to</code><code class="p">:</code> <code class="n">imageFileUrl</code><code class="p">)</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="All roads lead to FileManager" data-type="sect3"><div class="sect3" id="idm46177230318776">&#13;
<h3>All roads lead to FileManager</h3>&#13;
&#13;
<p>Eventually, in<a data-primary="FileManager class (iOS)" data-type="indexterm" id="idm46177230364808"/> the course of writing iOS applications and performing file operations, more complex operations will be needed. In those instances, there is a versatile class named <code>FileManager</code> that provides a shared, thread-safe instance useful in complex file operations.</p>&#13;
&#13;
<p>Reading the same <em>file.txt</em> using <code>FileManager</code> requires some additional logic:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// Provide a file to read in the user's Documents directory</code>&#13;
<code class="kd">let</code> <code class="nv">file</code> <code class="p">=</code>&#13;
  <code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="k">for</code><code class="p">:</code> <code class="p">.</code><code class="n">documentDirectory</code><code class="p">,</code> <code class="k">in</code><code class="p">:</code> <code class="p">.</code><code class="n">userDomainMask</code><code class="p">,</code>&#13;
  <code class="n">appropriateFor</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">create</code><code class="p">:</code> <code class="kc">false</code><code class="p">).</code><code class="n">appendingPathComponent</code><code class="p">(</code><code class="s">"file.txt"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Get the contents of the file as a Data object</code>&#13;
<code class="k">if</code> <code class="kd">let</code> <code class="nv">contents</code> <code class="p">=</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">contents</code><code class="p">(</code><code class="n">atPath</code><code class="p">:</code> <code class="n">file</code><code class="p">.</code><code class="n">path</code><code class="p">)</code> <code class="p">{</code>&#13;
	<code class="c1">// Create a String from the raw data</code>&#13;
	<code class="kd">let</code> <code class="nv">contentsString</code> <code class="p">=</code> <code class="nb">String</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">contents</code><code class="p">,</code> <code class="n">encoding</code><code class="p">:</code> <code class="p">.</code><code class="n">utf8</code><code class="p">)</code><code class="o">!</code>&#13;
	<code class="bp">print</code><code class="p">(</code><code class="n">contentsString</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>One of the first things to note is the use of <code>file.path</code>. This converts the URL object into a string representation of the file’s absolute path on the filesystem; it’s necessary because of an incomplete support for URLs within <code>FileManager</code>. Next, the <code>if</code> <code>let</code> statement reads the raw contents of the file into a data object. This provides some safety from null values if <code>FileManager</code> cannot find or access the file requested. Finally, assuming the file is accessible, a string is instantiated from the data object using the specified encoding—UTF-8 in this example.</p>&#13;
&#13;
<p>Writing a file is similar. Here is how writing a string directly to a file is done with <code>FileManager</code>:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">example</code> <code class="p">=</code> <code class="s">"I love tacos."</code>&#13;
&#13;
<code class="c1">// Convert the string to a Data object</code>&#13;
<code class="kd">let</code> <code class="nv">exampleData</code> <code class="p">=</code> <code class="n">example</code><code class="p">.</code><code class="n">data</code><code class="p">(</code><code class="n">using</code><code class="p">:</code> <code class="p">.</code><code class="n">utf8</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Create the file using the preceding data object (and overwrite any existing files)</code>&#13;
<code class="n">FileManager</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">createFile</code><code class="p">(</code>&#13;
    <code class="n">atPath</code><code class="p">:</code> <code class="n">sharedFile</code><code class="p">.</code><code class="n">path</code><code class="p">,</code> <code class="n">contents</code><code class="p">:</code> <code class="n">exampleData</code><code class="p">,</code> <code class="n">attributes</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code> <code class="c1">// returns a Bool</code></pre>&#13;
&#13;
<p>The success of the file operation is given with a boolean true or false value from <code>cre<span class="keep-together">ateFile(atPath:contents:attributes:)</span></code>. This is in contrast to the more modern Swift operator <code>throws</code> that operations with <code>String</code> and <code>Data</code> use directly.</p>&#13;
&#13;
<p>So why would one use <code>FileManager</code> when it doesn’t seem to be as modern of an API (it’s in the older<a data-primary="Foundation framework" data-type="indexterm" id="idm46177230116920"/> Foundation framework versus the<a data-primary="Swift Standard Library" data-type="indexterm" id="idm46177230116088"/> Swift Standard Library) and is slightly more cumbersome compared with <code>Data</code> and <code>String</code> instance methods? The answer lies in the intended purpose of <code>FileManager</code>. <code>FileManager</code> is great when more complex interactions with files and directories need completing. <code>FileManager</code> is great at inspecting directory hierarchies, providing feedback on the existence of files, deleting files, overwriting files, updating file attributes, and a lot more. It’s not as great at simple reading and writing of data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Copy Data from One File to Another" data-type="sect2"><div class="sect2" id="idm46177230112936">&#13;
<h2>Copy Data from One File to Another</h2>&#13;
&#13;
<p>Copying<a data-primary="files" data-secondary="iOS" data-tertiary="copying data" data-type="indexterm" id="idm46177230111176"/><a data-primary="iOS" data-secondary="files" data-tertiary="copying data" data-type="indexterm" id="idm46177230109896"/> a file with only <code>String</code>-provided methods would require reading the file into a <code>String</code> instance in memory and then writing that <code>String</code> into a separate<a data-primary="iOS methods" data-secondary="write(to:atomically:encoding:)" data-type="indexterm" id="idm46177230107224"/> file using <code>write(to:atomically:encoding:)</code>. This isn’t the most efficient way of copying a file and might not be easy with a larger file that exceeds the amount of available device memory.</p>&#13;
&#13;
<p>Copying a file within <code>FileManager</code> can be accomplished with the following code snippet:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="c1">// Provide an original file location</code>&#13;
<code class="kd">let</code> <code class="nv">originalFile</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="k">for</code><code class="p">:</code> <code class="p">.</code><code class="n">documentDirectory</code><code class="p">,</code> <code class="k">in</code><code class="p">:</code> <code class="p">.</code><code class="n">userDomainMask</code><code class="p">,</code> <code class="n">appropriateFor</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">create</code><code class="p">:</code> <code class="kc">false</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">appendingPathComponent</code><code class="p">(</code><code class="s">"file.txt"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Provide a location where the copied file should go</code>&#13;
<code class="kd">let</code> <code class="nv">copiedFile</code> <code class="p">=</code> <code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="k">for</code><code class="p">:</code> <code class="p">.</code><code class="n">documentDirectory</code><code class="p">,</code> <code class="k">in</code><code class="p">:</code> <code class="p">.</code><code class="n">userDomainMask</code><code class="p">,</code> <code class="n">appropriateFor</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">create</code><code class="p">:</code> <code class="kc">false</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">appendingPathComponent</code><code class="p">(</code><code class="s">"newFile.txt"</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Copy the file</code>&#13;
<code class="k">try</code><code class="p">?</code> <code class="n">FileManager</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">copyItem</code><code class="p">(</code><code class="n">at</code><code class="p">:</code> <code class="n">originalFile</code><code class="p">,</code> <code class="n">to</code><code class="p">:</code> <code class="n">copiedfile</code><code class="p">)</code></pre>&#13;
&#13;
<p>This is much more efficient than the first example with <code>String</code> because <code>FileManager</code> doesn’t require the file to be read into memory first before being copied. In addition, <code>FileManager</code> takes advantage of<a data-primary="Apple File System (APFS)" data-type="indexterm" id="idm46177229991128"/> Apple File System (APFS), Apple’s proprietary filesystem, by making a clone of the object, which is an incredibly efficient process in comparison.</p>&#13;
&#13;
<p>There are plenty more secrets waiting to be discovered within <code>FileManager</code>. This is enough to get you started with basic file operations in iOS, however. Feel free to check out the Apple-provided documentation to get an idea of all the operations <span class="keep-together">possible</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="URLs versus strings" data-type="sect3"><div class="sect3" id="idm46177229988392">&#13;
<h3>URLs versus strings</h3>&#13;
&#13;
<p>Throughout the code examples in this chapter, URLs were utilized to provide file path information instead of <code>String</code> objects. This is because URL objects are typically better suited to store path information and can do so internally in a more efficient manner. Similarly, they are generally more efficient at mutating, or changing, the file path representation by adding directories, changing names, and much more.</p>&#13;
&#13;
<p>Some methods provided by <code>FileManager</code>, and other Foundation-based APIs, use strings instead of URLs. Converting to a string path is provided with URL objects with the path variable. For example:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">fileURL</code> <code class="p">=</code> <code class="n">Bundle</code><code class="p">.</code><code class="n">main</code><code class="p">.</code><code class="n">url</code><code class="p">(</code><code class="n">forResource</code><code class="p">:</code> <code class="s">"file"</code><code class="p">,</code> <code class="n">withExtension</code><code class="p">:</code> <code class="s">"txt"</code><code class="p">)</code><code class="o">!</code>&#13;
<code class="kd">let</code> <code class="nv">filePath</code> <code class="p">=</code> <code class="n">fileURL</code><code class="p">.</code><code class="n">path</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iCloud and iTunes backups" data-type="sect3"><div class="sect3" id="idm46177229983448">&#13;
<h3>iCloud and iTunes backups</h3>&#13;
&#13;
<p>One<a data-primary="files" data-secondary="iOS" data-tertiary="iCloud and iTunes backups" data-type="indexterm" id="idm46177229972184"/><a data-primary="iOS" data-secondary="files" data-tertiary="iCloud and iTunes backups" data-type="indexterm" id="idm46177229963192"/><a data-primary="iCloud file synchronization" data-type="indexterm" id="idm46177229962008"/> thing we haven’t covered is iCloud file synchronization. Files in iCloud are written to like normal files in a user’s <em>Documents</em> directory; however, a different container is used to target the file directly. All files in a user’s <em>Documents</em> and <em>Application</em> <em>Support</em> directories are automatically backed up with iCloud and iTunes.</p>&#13;
&#13;
<p>It’s possible, and recommended, to exclude certain files from iTunes backups and iCloud synchronization. For example, a large video file from a web service that can be downloaded again in the future might be excluded by setting the file’s <code>isExcludedFromBackupKey</code> directly from a URL with the following code:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">var</code> <code class="nv">values</code> <code class="p">=</code> <code class="n">URLResourceValues</code><code class="p">()</code>&#13;
<code class="n">values</code><code class="p">.</code><code class="n">isExcludedFromBackup</code> <code class="p">=</code> <code class="kc">true</code>&#13;
<code class="k">try</code><code class="p">?</code> <code class="n">fileUrl</code><code class="p">.</code><code class="n">setResourceValues</code><code class="p">(</code><code class="n">values</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177229861928">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>As you might have noticed, files are an interesting intersection between Android and iOS. They are, at the same time, wildly different and fundamentally the same. At the end of the day, we’re dealing in bits and bytes, but how that data is accessed represents two very different paradigms of architecture.</p>&#13;
&#13;
<p>The notion of streams to read and write data in Android is in stark contrast with the more procedural and baked-in approach of iOS. Additionally, there are remnants of UNIX in iOS that permeate through all the way to its file structure.</p>&#13;
&#13;
<p>We hope this overview of both approaches has given you a starting place from which to start understanding how to approach filesystem operations for both platforms. In the next chapter, we talk about persisting data beyond files on the filesystem and move into the realm of databases and object graphs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>