- en: Chapter 1\. A Path to Production
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。通向生产的路径
- en: Over the years, the world has experienced wide adoption of Kubernetes within
    organizations. Its popularity has unquestionably been accelerated by the proliferation
    of containerized workloads and microservices. As operations, infrastructure, and
    development teams arrive at this inflection point of needing to build, run, and
    support these workloads, several are turning to Kubernetes as part of the solution.
    Kubernetes is a fairly young project relative to other, massive, open source projects
    such as Linux. Evidenced by many of the clients we work with, it is still early
    days for most users of Kubernetes. While many organizations have an existing Kubernetes
    footprint, there are far fewer that have reached production and even less operating
    at scale. In this chapter, we are going to set the stage for the journey many
    engineering teams are on with Kubernetes. Specifically, we are going to chart
    out some key considerations we look at when defining a path to production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，全球各组织广泛采用了 Kubernetes。它的流行无疑是由容器化工作负载和微服务的广泛使用加速的。随着运维、基础设施和开发团队达到需要构建、运行和支持这些工作负载的关键时刻，许多团队将
    Kubernetes 视为解决方案的一部分。相对于其他大规模开源项目如 Linux，Kubernetes 是一个相对年轻的项目。根据我们与许多客户的经验，对于大多数
    Kubernetes 用户来说，现在仍处于早期阶段。虽然许多组织已经在使用 Kubernetes，但达到生产环境的组织远远不多，更别提在大规模上运行的了。在本章中，我们将为许多工程团队在
    Kubernetes 上的旅程奠定基础。具体来说，我们将探讨在定义通向生产路径时考虑的一些关键问题。
- en: Defining Kubernetes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 Kubernetes
- en: Is Kubernetes a platform? Infrastructure? An application? There is no shortage
    of thought leaders who can provide you their precise definition of what Kubernetes
    is. Instead of adding to this pile of opinions, let’s put our energy into clarifying
    the problems Kubernetes solves. Once defined, we will explore how to build atop
    this feature set in a way that moves us toward production outcomes. The ideal
    state of “Production Kubernetes” implies that we have reached a state where workloads
    are successfully serving production traffic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个平台吗？基础设施？一个应用程序？有许多思想领袖可以为你提供他们对 Kubernetes 是什么的精确定义。而不是增加这些意见的堆砌，让我们把精力集中在澄清
    Kubernetes 解决的问题上。一旦定义了这些问题，我们将探讨如何在这个特性集的基础上构建，以推动我们朝向生产结果的方向发展。"生产 Kubernetes"
    的理想状态意味着我们已经达到了工作负载成功提供生产流量的状态。
- en: 'The name *Kubernetes* can be a bit of an umbrella term. A quick browse on GitHub
    reveals the `kubernetes` organization contains (at the time of this writing) 69
    repositories. Then there is `kubernetes-sigs`, which holds around 107 projects.
    And don’t get us started on the hundreds of Cloud Native Compute Foundation (CNCF)
    projects that play in this landscape! For the sake of this book, *Kubernetes*
    will refer exclusively to the core project. So, what is the core? The core project
    is contained in the [kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)
    repository. This is the location for the key components we find in most Kubernetes
    clusters. When running a cluster with these components, we can expect the following
    functionality:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*Kubernetes* 这个名称可能有点像一个总称。在 GitHub 上快速浏览可以发现，`kubernetes` 组织（截至本文撰写时）包含了69个仓库。然后还有
    `kubernetes-sigs`，大约有107个项目。更别提数百个云原生计算基金会（CNCF）在这个领域中运作的项目！在本书中，*Kubernetes*
    将专指核心项目。那么，核心是什么？核心项目包含在 [kubernetes/kubernetes](https://github.com/kubernetes/kubernetes)
    仓库中。这是大多数 Kubernetes 集群中的关键组件的所在地。当运行包含这些组件的集群时，我们可以期待以下功能：'
- en: Scheduling workloads across many hosts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在许多主机上调度工作负载
- en: Exposing a declarative, extensible, API for interacting with the system
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个声明式、可扩展的 API，用于与系统进行交互
- en: Providing a CLI, `kubectl`, for humans to interact with the API server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个 CLI，`kubectl`，供人类与 API 服务器进行交互。
- en: Reconciliation from current state of objects to desired state
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从当前对象状态到期望状态的协调
- en: Providing a basic service abstraction to aid in routing requests to and from
    workloads
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供基本的服务抽象以帮助路由请求到工作负载和从工作负载中请求
- en: Exposing multiple interfaces to support pluggable networking, storage, and more
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供多个接口以支持可插拔的网络、存储等
- en: These capabilities create what the project itself claims to be, a *production-grade
    container orchestrator*. In simpler terms, Kubernetes provides a way for us to
    run and schedule containerized workloads on multiple hosts. Keep this primary
    capability in mind as we dive deeper. Over time, we hope to prove how this capability,
    while foundational, is only part of our journey to production.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能创建了项目本身声称的 *生产级容器编排器*。简单来说，Kubernetes 提供了一种方式，让我们在多个主机上运行和调度容器化工作负载。在深入研究过程中，请记住这个主要能力。随着时间的推移，我们希望证明这种能力虽然基础，但只是我们走向生产的一部分旅程。
- en: The Core Components
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心组件
- en: 'What are the components that provide the functionality we have covered? As
    we have mentioned, core components reside in the `kubernetes/kubernetes` repository.
    Many of us consume these components in different ways. For example, those running
    managed services such as Google Kubernetes Engine (GKE) are likely to find each
    component present on hosts. Others may be downloading binaries from repositories
    or getting signed versions from a vendor. Regardless, anyone can download a Kubernetes
    release from the `kubernetes/kubernetes` repository. After downloading and unpacking
    a release, binaries may be retrieved using the `cluster/get-kube-binaries.sh`
    command. This will auto-detect your target architecture and download server and
    client components. Let’s take a look at this in the following code, and then explore
    the key components:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 提供我们讨论过的功能的组件是什么？正如我们所提到的，核心组件驻留在 `kubernetes/kubernetes` 代码库中。我们中的许多人以不同的方式使用这些组件。例如，运行托管服务（如
    Google Kubernetes Engine（GKE））的人可能会在主机上找到每个组件。其他人可能会从仓库下载二进制文件或从供应商那里获取签名版本。无论如何，任何人都可以从
    `kubernetes/kubernetes` 代码库下载 Kubernetes 发行版。下载并解压发行版后，可以使用 `cluster/get-kube-binaries.sh`
    命令检索二进制文件。这将自动检测您的目标架构并下载服务器和客户端组件。让我们在以下代码中查看这一点，然后探索关键组件：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the downloaded server components, likely saved to *server/kubernetes-server-${ARCH}.tar.gz*,
    you’ll find the key items that compose a Kubernetes cluster:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载的服务器组件内，可能保存在 *server/kubernetes-server-${ARCH}.tar.gz* 中，您将找到组成 Kubernetes
    集群的关键项目：
- en: API Server
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: API 服务器
- en: The primary interaction point for all Kubernetes components and users. This
    is where we get, add, delete, and mutate objects. The API server delegates state
    to a backend, which is most commonly etcd.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 Kubernetes 组件和用户的主要交互点。在这里，我们获取、添加、删除和变更对象。API 服务器将状态委托给后端，最常见的是 etcd。
- en: kubelet
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: kubelet
- en: The on-host agent that communicates with the API server to report the status
    of a node and understand what workloads should be scheduled on it. It communicates
    with the host’s container runtime, such as Docker, to ensure workloads scheduled
    for the node are started and healthy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与 API 服务器通信的主机代理，用于报告节点的状态并理解应该在其上调度什么工作负载。它与主机的容器运行时（如 Docker）通信，以确保为节点调度的工作负载已启动并保持健康。
- en: Controller Manager
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器管理器
- en: A set of controllers, bundled in a single binary, that handle reconciliation
    of many core objects in Kubernetes. When desired state is declared, e.g., three
    replicas in a Deployment, a controller within handles the creation of new Pods
    to satisfy this state.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一组控制器，打包在单个二进制文件中，负责协调 Kubernetes 中许多核心对象的调和。当声明所需状态时，例如 Deployment 中的三个副本，控制器会处理创建新
    Pod 来满足此状态。
- en: Scheduler
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器
- en: Determines where workloads should run based on what it thinks is the optimal
    node. It uses filtering and scoring to make this decision.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其认为最佳节点的位置确定工作负载应在何处运行。它使用过滤和评分来做出这些决策。
- en: Kube Proxy
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Kube Proxy
- en: Implements Kubernetes services providing virtual IPs that can route to backend
    Pods. This is accomplished using a packet filtering mechanism on a host such as
    `iptables` or `ipvs`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 Kubernetes 服务，提供可以路由到后端 Pod 的虚拟 IP。这是通过主机上的数据包过滤机制（如 `iptables` 或 `ipvs`）实现的。
- en: While not an exhaustive list, these are the primary components that make up
    the core functionality we have discussed. Architecturally, [Figure 1-1](#the_primary_components_that_make_up_the_kubernetes_cluster)
    shows how these components play together.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是详尽的列表，但这些是构成我们讨论的核心功能的主要组件。从架构上看，[图1-1](#the_primary_components_that_make_up_the_kubernetes_cluster)
    展示了这些组件如何协同工作。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Kubernetes architectures have many variations. For example, many clusters run
    kube-apiserver, kube-scheduler, and kube-controller-manager as containers. This
    means the control-plane may also run a container-runtime, kubelet, and kube-proxy.
    These kinds of deployment considerations will be covered in the next chapter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 架构有许多变体。例如，许多集群将 kube-apiserver、kube-scheduler 和 kube-controller-manager
    作为容器运行。这意味着控制平面也可以运行容器运行时、kubelet 和 kube-proxy。这类部署考虑将在下一章中详细介绍。
- en: '![prku 0101](assets/prku_0101.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0101](assets/prku_0101.png)'
- en: Figure 1-1\. The primary components that make up the Kubernetes cluster. Dashed
    borders represent components that are not part of core Kubernetes.
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-1\. 组成 Kubernetes 集群的主要组件。虚线边框表示非核心 Kubernetes 组件。
- en: Beyond Orchestration—Extended Functionality
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越编排——扩展功能
- en: There are areas where Kubernetes does more than just orchestrate workloads.
    As mentioned, the component kube-proxy programs hosts to provide a virtual IP
    (VIP) experience for workloads. As a result, internal IP addresses are established
    and route to one or many underlying Pods. This concern certainly goes beyond running
    and scheduling containerized workloads. In theory, rather than implementing this
    as part of core Kubernetes, the project could have defined a Service API and required
    a plug-in to implement the Service abstraction. This approach would require users
    to choose between a variety of plug-ins in the ecosystem rather than including
    it as core functionality.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有些地方 Kubernetes 做的不仅仅是工作负载编排。正如提到的，kube-proxy 组件编程主机以为工作负载提供虚拟 IP（VIP）体验。因此，内部
    IP 地址被建立并路由到一个或多个底层的 Pod。这个问题显然超出了运行和调度容器化工作负载的范围。从理论上讲，而不是将其作为核心 Kubernetes 的一部分实现，该项目可以定义一个服务
    API，并要求插件来实现服务抽象。这种方法要求用户在生态系统中选择各种插件。
- en: This is the model many Kubernetes APIs, such as Ingress and NetworkPolicy, take.
    For example, creation of an Ingress object in a Kubernetes cluster does not guarantee
    action is taken. In other words, while the API exists, it is not core functionality.
    Teams must consider what technology they’d like to plug in to implement this API.
    For Ingress, many use a controller such as [ingress-nginx](https://kubernetes.github.io/ingress-nginx),
    which runs in the cluster. It implements the API by reading Ingress objects and
    creating NGINX configurations for NGINX instances pointed at Pods. However, `ingress-nginx`
    is one of many options. [Project Contour](https://projectcontour.io) implements
    the same Ingress API but instead programs instances of envoy, the proxy that underlies
    Contour. Thanks to this pluggable model, there are a variety of options available
    to teams.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Kubernetes API，如 Ingress 和 NetworkPolicy，都采用了这种模型。例如，在 Kubernetes 集群中创建一个
    Ingress 对象并不保证会采取行动。换句话说，虽然 API 存在，但它不是核心功能。团队必须考虑他们希望插入的技术来实现此 API。对于 Ingress，许多人使用像
    [ingress-nginx](https://kubernetes.github.io/ingress-nginx) 这样的控制器，在集群中运行。它通过读取
    Ingress 对象并为指向 Pod 的 NGINX 实例创建 NGINX 配置来实现 API。然而，`ingress-nginx` 只是众多选项之一。[Project
    Contour](https://projectcontour.io) 实现了相同的 Ingress API，但它使用 envoy 这个代理来执行。由于这种可插拔模型，团队有多种选择。
- en: Kubernetes Interfaces
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 接口
- en: Expanding on this idea of adding functionality, we should now explore interfaces.
    Kubernetes interfaces enable us to customize and build on the core functionality.
    We consider an interface to be a definition or contract on how something can be
    interacted with. In software development, this parallels the idea of defining
    functionality, which classes or structs may implement. In systems like Kubernetes,
    we deploy plug-ins that satisfy these interfaces, providing functionality such
    as networking.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展功能的思想上，我们现在应该探讨接口。Kubernetes 接口使我们能够定制和构建核心功能。我们认为接口是如何与某物交互的定义或契约。在软件开发中，这类似于定义类或结构体可以实现的功能。在像
    Kubernetes 这样的系统中，我们部署满足这些接口的插件，提供诸如网络功能等功能。
- en: A specific example of this interface/plug-in relationship is the [Container
    Runtime Interface](https://github.com/kubernetes/cri-api) (CRI). In the early
    days of Kubernetes, there was a single container runtime supported, Docker. While
    Docker is still present in many clusters today, there is growing interest in using
    alternatives such as [containerd](https://containerd.io) or [CRI-O](https://github.com/cri-o/cri-o).
    [Figure 1-2](#two_workloads_nodes_running_two_different_container_runtimes) demonstrates
    this relationship with these two container runtimes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种接口/插件关系的一个具体示例是 [容器运行时接口](https://github.com/kubernetes/cri-api) (CRI)。在 Kubernetes
    初始阶段，只支持单一容器运行时 Docker。虽然今天许多集群仍然使用 Docker，但越来越多的人开始关注使用诸如 [containerd](https://containerd.io)
    或 [CRI-O](https://github.com/cri-o/cri-o) 等替代方案。[图 1-2](#two_workloads_nodes_running_two_different_container_runtimes)
    显示了这两个容器运行时之间的关系。
- en: '![prku 0102](assets/prku_0102.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0102](assets/prku_0102.png)'
- en: Figure 1-2\. Two workload nodes running two different container runtimes. The
    kubelet sends commands defined in the CRI such as `CreateContainer` and expects
    the runtime to satisfy the request and respond.
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-2\. 两个工作负载节点运行两种不同的容器运行时。kubelet 发送在 CRI 中定义的命令，如 `CreateContainer`，并期望运行时满足请求并做出响应。
- en: In many interfaces, commands, such as `CreateContainerRequest` or `PortForwardRequest`,
    are issued as remote procedure calls (RPCs). In the case of CRI, the communication
    happens over GRPC and the kubelet expects responses such as `CreateContainerResponse`
    and `PortForwardResponse`. In [Figure 1-2](#two_workloads_nodes_running_two_different_container_runtimes),
    you’ll also notice two different models for satisfying CRI. CRI-O was built from
    the ground up as an implementation of CRI. Thus the kubelet issues these commands
    directly to it. containerd supports a plug-in that acts as a shim between the
    kubelet and its own interfaces. Regardless of the exact architecture, the key
    is getting the container runtime to execute, without the kubelet needing to have
    operational knowledge of how this occurs for *every possible* runtime. This concept
    is what makes interfaces so powerful in how we architect, build, and deploy Kubernetes
    clusters.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多接口中，例如 `CreateContainerRequest` 或 `PortForwardRequest`，命令都作为远程过程调用 (RPC)
    发出。对于 CRI，通信是通过 GRPC 进行的，kubelet 期望得到诸如 `CreateContainerResponse` 和 `PortForwardResponse`
    的响应。在 [图 1-2](#two_workloads_nodes_running_two_different_container_runtimes) 中，你还会注意到满足
    CRI 的两种不同模型。CRI-O 是从头开始作为 CRI 的实现构建的。因此，kubelet 直接向其发出这些命令。containerd 支持一个插件，作为
    kubelet 和其自身接口之间的桥梁。无论具体的架构如何，关键在于使容器运行时执行，而不需要 kubelet 对每种可能的运行时都具有操作知识。这一概念是我们在架构、构建和部署
    Kubernetes 集群时如何使用接口的强大之处。
- en: Over time, we’ve even seen some functionality removed from the core project
    in favor of this plug-in model. These are things that historically existed “in-tree,”
    meaning within the `kubernetes/kubernetes` code base. An example of this is [cloud-provider
    integrations](https://github.com/kubernetes/cloud-provider) (CPIs). Most CPIs
    were traditionally baked into components such as the kube-controller-manager and
    the kubelet. These integrations typically handled concerns such as provisioning
    load balancers or exposing cloud provider metadata. Sometimes, especially prior
    to the creation of the [Container Storage Interface (CSI)](https://kubernetes-csi.github.io/docs/introduction.html),
    these providers provisioned block storage and made it available to the workloads
    running in Kubernetes. That’s a lot of functionality to live in Kubernetes, not
    to mention it needs to be re-implemented for every possible provider! As a better
    solution, support was moved into its own interface model, e.g., [kubernetes/cloud-provider](https://github.com/kubernetes/cloud-provider),
    that can be implemented by multiple projects or vendors. Along with minimizing
    sprawl in the Kubernetes code base, this enables CPI functionality to be managed
    out of band of the core Kubernetes clusters. This includes common procedures such
    as upgrades or patching vulnerabilities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，我们甚至看到一些功能从核心项目中移除，转而采用插件模型。这些功能历史上存在于“in-tree”内，即在`kubernetes/kubernetes`的代码库中。一个例子是[云提供商集成](https://github.com/kubernetes/cloud-provider)（CPIs）。大多数CPIs传统上被整合到组件中，如kube-controller-manager和kubelet。这些集成通常处理诸如供应负载均衡器或公开云提供商元数据等问题。有时，在创建[容器存储接口（CSI）](https://kubernetes-csi.github.io/docs/introduction.html)之前，这些提供商提供块存储并使其对运行在Kubernetes中的工作负载可用。这么多功能都驻留在Kubernetes中，更不用说它需要为每个可能的提供商重新实现！作为更好的解决方案，支持被移至其自己的接口模型，例如[kubernetes/cloud-provider](https://github.com/kubernetes/cloud-provider)，可以由多个项目或供应商实现。除了在Kubernetes代码库中减少蔓延外，这还使得CPI功能能够在核心Kubernetes集群之外管理。这包括常见的流程，如升级或修补漏洞。
- en: 'Today, there are several interfaces that enable customization and additional
    functionality in Kubernetes. What follows is a high-level list, which we’ll expand
    on throughout chapters in this book:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，有几个接口使得在Kubernetes中进行定制化和附加功能成为可能。以下是一个高层次列表，我们将在本书的各章节中详细展开讨论：
- en: The Container Networking Interface (CNI) enables networking providers to define
    how they do things from IPAM to actual packet routing.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器网络接口（CNI）使网络提供商能够定义从IPAM到实际数据包路由的操作方式。
- en: The Container Storage Interface (CSI) enables storage providers to satisfy intra-cluster
    workload requests. Commonly implemented for technologies such as ceph, vSAN, and
    EBS.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器存储接口（CSI）使得存储提供商能够满足集群内工作负载的请求。通常用于像ceph、vSAN和EBS这样的技术。
- en: The Container Runtime Interface (CRI) enables a variety of runtimes, common
    ones including Docker, containerd, and CRI-O. It also has enabled a proliferation
    of less traditional runtimes, such as firecracker, which leverages KVM to provision
    a minimal VM.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行时接口（CRI）支持各种运行时，常见的包括Docker、containerd和CRI-O。它还促进了非传统运行时的增多，例如利用KVM提供最小化虚拟机的firecracker。
- en: The Service Mesh Interface (SMI) is one of the newer interfaces to hit the Kubernetes
    ecosystem. It hopes to drive consistency when defining things such as traffic
    policy, telemetry, and management.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格接口（SMI）是最新一批涉及Kubernetes生态系统的接口之一。它希望在定义流量策略、遥测和管理等方面推动一致性。
- en: The Cloud Provider Interface (CPI) enables providers such as VMware, AWS, Azure,
    and more to write integration points for their cloud services with Kubernetes
    clusters.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云提供商接口（CPI）使VMware、AWS、Azure等提供商能够为其云服务与Kubernetes集群编写集成点。
- en: The Open Container Initiative Runtime Spec. (OCI) standardizes image formats
    ensuring that a container image built from one tool, when compliant, can be run
    in any OCI-compliant container runtime. This is not directly tied to Kubernetes
    but has been an ancillary help in driving the desire to have pluggable container
    runtimes (CRI).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放容器倡议运行时规范（OCI）标准化了镜像格式，确保从一个工具构建的容器镜像在符合规范时可以在任何符合OCI的容器运行时中运行。虽然与Kubernetes没有直接关联，但它在推动可插拔容器运行时（CRI）的愿望方面提供了辅助。
- en: Summarizing Kubernetes
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes概述
- en: Now we have focused in on the scope of Kubernetes. It is a *container orchestrator*,
    with a couple extra features here and there. It also has the ability to be extended
    and customized by leveraging plug-ins to interfaces. Kubernetes can be foundational
    for many organizations looking for an elegant means of running their applications.
    However, let’s take a step back for a moment. If we were to take the current systems
    used to run applications in your organization and replace them with Kubernetes,
    would that be enough? For many of us, there is much more involved in the components
    and machinery that make up our current “application platform.”
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经聚焦于Kubernetes的范围。它是一个*容器编排器*，还带有一些额外的功能。它还可以通过利用插件到接口来进行扩展和定制。对于许多寻求优雅运行其应用程序手段的组织来说，Kubernetes可能是基础性的。然而，请让我们稍作停顿。如果我们将用于在您的组织中运行应用程序的当前系统替换为Kubernetes，那就足够了吗？对于我们许多人来说，当前“应用平台”组成的部件和机制要复杂得多。
- en: Historically, we have witnessed a lot of pain when organizations hold the view
    of having a “Kubernetes” strategy—or when they assume that Kubernetes will be
    an adequate forcing function for modernizing how they build and run software.
    Kubernetes is a technology, a great one, but it really should not be the focal
    point of where you’re headed in the modern infrastructure, platform, and/or software
    realm. We apologize if this seems obvious, but you’d be surprised how many executive
    or higher-level architects we talk to who believe that Kubernetes, by itself,
    is the answer to problems, when in actuality their problems revolve around application
    delivery, software development, or organizational/people issues. Kubernetes is
    best thought of as a piece of your puzzle, one that enables you to deliver platforms
    for your applications. We have been dancing around this idea of an application
    platform, which we’ll explore next.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，我们看到很多组织在持有“Kubernetes”战略的观点时或者他们认为Kubernetes将是推动他们如何构建和运行软件的充分手段时，经历了很多痛苦。Kubernetes是一种技术，是一种很棒的技术，但它真的不应该成为您在现代基础设施、平台和/或软件领域所追寻的重点。如果这显而易见，我们深感抱歉，但是您会惊讶地发现，有多少高管或更高级别的架构师认为Kubernetes本身就是问题的答案，而实际上他们的问题围绕应用交付、软件开发或组织/人员问题。Kubernetes最好被视为您拼图的一部分，它使您能够为应用程序提供平台。我们一直在围绕应用平台的这个概念打转，接下来我们将深入探讨。
- en: Defining Application Platforms
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用平台
- en: In our path to production, it is key that we consider the idea of an application
    platform. We define an application platform as a viable place to run workloads.
    Like most definitions in this book, how that’s satisfied will vary from organization
    to organization. Targeted outcomes will be vast and desirable to different parts
    of the business—for example, happy developers, reduction of operational costs,
    and quicker feedback loops in delivering software are a few. The application platform
    is often where we find ourselves at the intersection of apps and infrastructure.
    Concerns such as developer experience (devx) are typically a key tenet in this
    area.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的生产路径中，关键是考虑应用平台的概念。我们定义应用平台为运行工作负载的可行场所。就像本书中的大多数定义一样，如何满足这一点将因组织而异。目标结果将对业务的不同部分产生广泛和有吸引力的影响，例如，开发者的满意度、操作成本的降低以及软件交付中更快的反馈循环等。应用平台通常是我们发现自己处于应用程序和基础设施交集的地方。开发者体验（devx）等问题通常是这一领域的关键要素之一。
- en: Application platforms come in many shapes and sizes. Some largely abstract underlying
    concerns such as the IaaS (e.g., AWS) or orchestrator (e.g., Kubernetes). Heroku
    is a great example of this model. With it you can easily take a project written
    in languages like Java, PHP, or Go and, using one command, deploy them to production.
    Alongside your app runs many platform services you’d otherwise need to operate
    yourself. Things like metrics collection, data services, and continuous delivery
    (CD). It also gives you primitives to run highly available workloads that can
    easily scale. Does Heroku use Kubernetes? Does it run its own datacenters or run
    atop AWS? Who cares? For Heroku users, these details aren’t important. What’s
    important is delegating these concerns to a provider or platform that enables
    developers to spend more time solving business problems. This approach is not
    unique to cloud services. RedHat’s OpenShift follows a similar model, where Kubernetes
    is more of an implementation detail and developers and platform operators interact
    with a set of abstractions on top.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应用平台有各种各样的形式和大小。一些主要是抽象的基础问题，如IaaS（例如AWS）或编排器（例如Kubernetes）。Heroku是这种模型的一个很好的例子。使用Heroku，你可以轻松地将使用Java、PHP或Go等语言编写的项目部署到生产环境中，只需一个命令即可。除了您的应用程序之外，还运行着许多平台服务，否则您需要自己操作。这些服务包括指标收集、数据服务和持续交付（CD）。它还为您提供了运行高可用工作负载的基本组件，可以轻松扩展。Heroku是否使用Kubernetes？它是否在自己的数据中心运行，或者在AWS之上运行？这些细节对于Heroku用户来说并不重要。重要的是将这些问题委托给一个提供商或平台，使开发人员能够更多地专注于解决业务问题。这种方法并不局限于云服务。RedHat的OpenShift采用了类似的模型，其中Kubernetes更多是一种实现细节，开发人员和平台运营商与其上的一组抽象交互。
- en: Why not stop here? If platforms like Cloud Foundry, OpenShift, and Heroku have
    solved these problems for us, why bother with Kubernetes? A major trade-off to
    many prebuilt application platforms is the need to conform to their view of the
    world. Delegating ownership of the underlying system takes a significant operational
    weight off your shoulders. At the same time, if how the platform approaches concerns
    like service discovery or secret management does not satisfy your organizational
    requirements, you may not have the control required to work around that issue.
    Additionally, there is the notion of vendor or opinion lock-in. With abstractions
    come opinions on how your applications should be architected, packaged, and deployed.
    This means that moving to another system may not be trivial. For example, it’s
    significantly easier to move workloads between Google Kubernetes Engine (GKE)
    and Amazon Elastic Kubernetes Engine (EKS) than it is between EKS and Cloud Foundry.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在这里停下？如果像Cloud Foundry、OpenShift和Heroku这样的平台已经为我们解决了这些问题，那为什么还要费心使用Kubernetes？许多预构建的应用平台的一个重要权衡是需要遵循它们对世界的看法。将对底层系统的所有权委托给其他人，会显著减轻你的运维负担。同时，如果平台处理诸如服务发现或秘密管理等问题的方式不符合你的组织需求，你可能没有足够的控制权来解决这些问题。此外，还存在供应商或观点锁定的概念。随着抽象的出现，关于应用程序应如何架构、打包和部署的观点也会随之而来。这意味着将工作负载迁移到另一个系统可能并不容易。例如，将工作负载从Google
    Kubernetes Engine（GKE）移动到Amazon Elastic Kubernetes Engine（EKS）比从EKS移动到Cloud Foundry要容易得多。
- en: The Spectrum of Approaches
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法的光谱
- en: At this point, it is clear there are several approaches to establishing a successful
    application platform. Let’s make some big assumptions for the sake of demonstration
    and evaluate theoretical trade-offs between approaches. For the average company
    we work with, say a mid to large enterprise, [Figure 1-3](#the_multitude_of_options_available_to_provider_an_applications)
    shows an arbitrary evaluation of approaches.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在清楚地看到，建立成功的应用平台有几种方法。为了演示起见，让我们做一些大胆的假设，并评估不同方法之间的理论权衡。对于我们合作的平均公司，比如中大型企业，[图 1-3](#the_multitude_of_options_available_to_provider_an_applications)展示了对方法的任意评估。
- en: In the bottom-left quadrant, we see deploying Kubernetes clusters themselves,
    which has a relatively low engineering effort involved, especially when managed
    services such as EKS are handling the control plane for you. These are lower on
    production readiness because most organizations will find that more work needs
    to be done on top of Kubernetes. However, there are use cases, such as teams that
    use dedicated cluster(s) for their workloads, that may suffice with just Kubernetes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在左下方的四分之一中，我们看到部署Kubernetes集群本身，涉及的工程工作相对较少，特别是当像EKS这样的托管服务为您处理控制平面时。这些在生产就绪性方面较低，因为大多数组织会发现，在Kubernetes之上还需要做更多工作。但是，也有使用情况，比如团队为其工作负载使用专用集群，可能仅仅使用Kubernetes就足够了。
- en: '![prku 0103](assets/prku_0103.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0103](assets/prku_0103.png)'
- en: Figure 1-3\. The multitude of options available to provide an application platform
    to developers.
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-3\. 提供应用平台给开发者的多种选择。
- en: In the bottom right, we have the more established platforms, ones that provide
    an end-to-end developer experience out of the box. Cloud Foundry is a great example
    of a project that solves many of the application platform concerns. Running software
    in Cloud Foundry is more about ensuring the software fits within its opinions.
    OpenShift, on the other hand, which for most is far more production-ready than
    just Kubernetes, has more decision points and considerations for how you set it
    up. Is this flexibility a benefit or a nuisance? That’s a key consideration for
    you.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在右下角，我们有更加成熟的平台，这些平台提供了开箱即用的端到端开发者体验。Cloud Foundry 就是解决许多应用平台关注点的一个很好的例子。在 Cloud
    Foundry 中运行软件更多是确保软件符合其观点。另一方面，OpenShift 对于大多数人来说比仅仅 Kubernetes 更加适合生产环境，它有更多的决策点和设置考虑。这种灵活性是一个好处还是一个麻烦？这是您需要考虑的一个关键问题。
- en: Lastly, in the top right, we have building an application platform on top of
    Kubernetes. Relative to the others, this unquestionably requires the most engineering
    effort, at least from a platform perspective. However, taking advantage of Kubernetes
    extensibility means you can create something that lines up with your developer,
    infrastructure, and business needs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在右上角，我们有在 Kubernetes 之上构建应用平台。相对于其他选项，至少从平台角度来看，这无疑需要最大的工程投入。然而，利用 Kubernetes
    的可扩展性意味着你可以创建与开发者、基础设施和业务需求对齐的东西。
- en: Aligning Your Organizational Needs
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐您的组织需求
- en: What’s missing from the graph in [Figure 1-3](#the_multitude_of_options_available_to_provider_an_applications)
    is a third dimension, a z-axis that demonstrates how aligned the approach is with
    your requirements. Let’s examine another visual representation. [Figure 1-4](#the_added_complexity_of_the_alignment_of_these)
    maps out how this might look when considering platform alignment with organizational
    needs.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图表 [Figure 1-3](#the_multitude_of_options_available_to_provider_an_applications)
    中缺少的是第三维度，即展示方法与您需求对齐程度的 z 轴。让我们考虑另一个视觉表现。 [Figure 1-4](#the_added_complexity_of_the_alignment_of_these)
    描绘了考虑平台与组织需求对齐时可能的情况。
- en: '![prku 0104](assets/prku_0104.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0104](assets/prku_0104.png)'
- en: Figure 1-4\. The added complexity of the alignment of these options with your
    organizational needs, the z-axis.
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-4\. 这些选项与您组织需求对齐的增加复杂性，即 z 轴。
- en: 'In terms of requirements, features, and behaviors you’d expect out of a platform,
    building a platform is almost always going to be the most aligned. Or at least
    the most capable of aligning. This is because you can build anything! If you wanted
    to re-implement Heroku in-house, on top of Kubernetes, with minor adjustments
    to its capabilities, it is technically possible. However, the cost/reward should
    be weighed out with the other axes (x and y). Let’s make this exercise more concrete
    by considering the following needs in a next-generation platform:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在平台的需求、特性和行为方面，建设平台几乎总是最为一致的选择。或者至少是最具备一致性的选择。这是因为你可以构建任何东西！如果你想在 Kubernetes
    上内部重新实现 Heroku，并对其能力进行轻微调整，从技术上讲是可行的。然而，成本与回报应该与其他轴（x 和 y）权衡。让我们通过考虑下一代平台的以下需求来使这个练习更具体：
- en: Regulations require you to run mostly on-premise
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 法规要求您主要在本地运行
- en: Need to support your baremetal fleet along with your vSphere-enabled datacenter
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要支持裸金属设备以及您的 vSphere 启用数据中心
- en: Want to support growing demand for developers to package applications in containers
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望支持开发者将应用程序打包成容器的不断增长需求
- en: Need ways to build self-service API mechanisms that move you away from “ticket-based”
    infrastructure provisioning
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要构建自助式 API 机制，摆脱基于“票证”的基础设施供应
- en: Want to ensure APIs you’re building atop of are vendor agnostic and not going
    to cause lock-in because it has cost you millions in the past to migrate off these
    types of systems
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望确保您构建的 API 不依赖于特定供应商，并且不会因为您过去迁移这类系统而花费了数百万。
- en: Are open to paying enterprise support for a variety of products in the stack,
    but unwilling to commit to models where the entire stack is licensed per node,
    core, or application instance
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放以支持多种堆栈产品的企业支持，但不愿承诺对整个堆栈按节点、核心或应用实例授权的模型。
- en: We must understand our engineering maturity, appetite for building and empowering
    teams, and available resources to qualify whether building an application platform
    is a sensible undertaking.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须了解我们的工程成熟度、建立和赋权团队的愿望以及可用资源，以确定构建应用平台是否是一个明智的举措。
- en: Summarizing Application Platforms
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结应用平台
- en: Admittedly, what constitutes an application platform remains fairly gray. We’ve
    focused on a variety of platforms that we believe bring an experience to teams
    far beyond just workload orchestration. We have also articulated that Kubernetes
    can be customized and extended to achieve similar outcomes. By advancing our thinking
    beyond “How do I get a Kubernetes” into concerns such as “What is the current
    developer workflow, pain points, and desires?” platform and infrastructure teams
    will be more successful with what they build. With a focus on the latter, we’d
    argue, you are far more likely to chart a proper path to production and achieve
    nontrivial adoption. At the end of the day, we want to meet infrastructure, security,
    and developer requirements to ensure our customers—typically developers—are provided
    a solution that meets their needs. Often we do not want to simply provide a “powerful”
    engine that every developer must build their own platform atop of, as jokingly
    depicted in [Figure 1-5](#when_developers_desire_an_end_to_end_experience).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，什么构成应用平台仍然相当模糊。我们专注于一系列我们认为可以为团队带来超越工作负载编排的体验的平台。我们还表明，Kubernetes可以定制和扩展以达到类似的结果。通过将我们的思维推进到“我如何获得一个Kubernetes”的问题之外，而是关注“当前的开发者工作流程、痛点和需求”，平台和基础设施团队将更成功地构建他们的产品。专注于后者，我们认为，您更有可能规划出正确的上线路径并实现不平凡的采用。归根结底，我们希望满足基础设施、安全性和开发者的要求，以确保我们的客户——通常是开发者——获得符合其需求的解决方案。通常情况下，我们不希望简单地提供一个“强大”的引擎，让每个开发者都必须在其上构建自己的平台，正如在[图1-5](#when_developers_desire_an_end_to_end_experience)中开玩笑地描述的那样。
- en: '![prku 0105](assets/prku_0105.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0105](assets/prku_0105.png)'
- en: Figure 1-5\. When developers desire an end-to-end experience (e.g., a driveable
    car), do not expect an engine without a frame, wheels, and more to suffice.
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-5\. 当开发者期望一个端到端的体验（例如一辆可驾驶的汽车）时，不要期望一个仅有引擎而没有车架、轮子等的东西足够。
- en: Building Application Platforms on Kubernetes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上构建应用平台
- en: Now we’ve identified Kubernetes as one piece of the puzzle in our path to production.
    With this, it would be reasonable to wonder “Isn’t Kubernetes just missing stuff
    then?” The Unix philosophy’s principle of “make each program do one thing well”
    is a compelling aspiration for the Kubernetes project. We believe its best features
    are largely the ones it does not have! Especially after being burned with one-size-fits-all
    platforms that try to solve the world’s problems for you. Kubernetes has brilliantly
    focused on being a great orchestrator while defining clear interfaces for how
    it can be built on top of. This can be likened to the foundation of a home.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了Kubernetes在我们通往生产路径中的一个部分。因此，人们会合理地问：“那么Kubernetes只是少了一些东西吗？” Unix哲学中“让每个程序做好一件事”这一原则对Kubernetes项目是一个令人向往的追求。我们相信它最好的特性很大程度上是它所没有的！特别是在被那些试图为你解决全球问题的一刀切平台所伤害后。Kubernetes在成为一个出色的编排器的同时，明确了它可以如何在其上构建的清晰接口。这可以类比为家的基础。
- en: A good foundation should be structurally sound, able to be built on top of,
    and provide appropriate interfaces for routing utilities to the home. While important,
    a foundation alone is rarely a habitable place for our applications to live. Typically,
    we need some form of home to exist on top of the foundation. Before discussing
    *building* on top of a foundation such as Kubernetes, let’s consider a pre-furnished
    apartment as shown in [Figure 1-6](#an_apartment_that_is_move_in_ready_similar).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的基础应该在结构上是稳固的，可以在其上建造，并为路由工具提供适当的接口。尽管重要，但仅有一个基础很少能成为我们的应用程序生活的宜居之地。通常情况下，我们需要在基础之上存在某种形式的家。在讨论像Kubernetes这样的基础之上的*构建*之前，让我们考虑一个像预装家具公寓一样的场景，如[图1-6](#an_apartment_that_is_move_in_ready_similar)所示。
- en: '![prku 0106](assets/prku_0106.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0106](assets/prku_0106.png)'
- en: Figure 1-6\. An apartment that is move-in ready. Similar to platform as a service
    options like Heroku. Illustration by Jessica Appelbaum.
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-6\. 一个可以立即入住的公寓。类似于Heroku等平台即服务选项。由Jessica Appelbaum插图。
- en: This option, similar to our examples such as Heroku, is habitable with no additional
    work. There are certainly opportunities to customize the experience inside; however,
    many concerns are solved for us. As long as we are comfortable with the price
    of rent and are willing to conform to the nonnegotiable opinions within, we can
    be successful on day one.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项与我们的示例（如Heroku）类似，无需额外工作即可居住。当然，我们可以在内部定制体验，但是许多问题已经为我们解决了。只要我们对租金的价格感到满意，并愿意遵循其中的不可协商意见，我们就可以在第一天就取得成功。
- en: Circling back to Kubernetes, which we have likened to a foundation, we can now
    look to build that habitable home on top of it, as depicted in [Figure 1-7](#building_a_house_similar_to_establishing_an_application_platform).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Kubernetes，我们将其比作是一个基础，现在可以在其上构建一个适合居住的家，如[图1-7](#building_a_house_similar_to_establishing_an_application_platform)所示。
- en: '![prku 0107](assets/prku_0107.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0107](assets/prku_0107.png)'
- en: Figure 1-7\. Building a house. Similar to establishing an application platform,
    which Kubernetes is foundational to. Illustration by Jessica Appelbaum.
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-7\. 建造一座房子。类似于建立一个应用平台，其中Kubernetes是基础。Jessica Appelbaum插图。
- en: At the cost of planning, engineering, and maintaining, we can build remarkable
    platforms to run workloads throughout organizations. This means we’re in complete
    control of every element in the output. The house can and should be tailored to
    the needs of the future tenants (our applications). Let’s now break down the various
    layers and considerations that make this possible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划、工程和维护的代价下，我们可以构建出色的平台来运行整个组织的工作负载。这意味着我们完全控制输出中的每个元素。房子可以且应该根据未来租户（我们的应用程序）的需求进行定制。现在让我们分解使这一切成为可能的各种层面和考虑因素。
- en: Starting from the Bottom
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从底层开始
- en: First we must start at the bottom, which includes the technology Kubernetes
    expects to run. This is commonly a datacenter or cloud provider, which offers
    compute, storage, and networking. Once established, Kubernetes can be bootstrapped
    on top. Within minutes you can have clusters living atop the underlying infrastructure.
    There are several means of bootstrapping Kubernetes, and we’ll cover them in depth
    in [Chapter 2](ch02.html#deployment_models).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须从底层开始，包括Kubernetes预期运行的技术。通常这是数据中心或云提供商，提供计算、存储和网络。一旦建立，Kubernetes就可以在其上启动。几分钟内，您可以在底层基础设施之上拥有运行的集群。有几种引导Kubernetes的方法，我们将在[第2章](ch02.html#deployment_models)中详细介绍它们。
- en: From the point of Kubernetes clusters existing, we next need to look at a conceptual
    flow to determine what we should build on top. The key junctures are represented
    in [Figure 1-8](#a_flow_our_teams_may_go_through_in_their_path).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes集群存在的角度来看，我们接下来需要查看一个概念流程，以确定我们应该在其上构建什么。关键的关节在[图1-8](#a_flow_our_teams_may_go_through_in_their_path)中表示。
- en: '![prku 0108](assets/prku_0108.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0108](assets/prku_0108.png)'
- en: Figure 1-8\. A flow our teams may go through in their path to production with
    Kubernetes.
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1-8\. 我们的团队可能在使用Kubernetes进行生产路径时经历的流程。
- en: 'From the point of Kubernetes existing, you can expect to quickly be receiving
    questions such as:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kubernetes存在的角度来看，您可以期望迅速收到如下问题：
- en: “How do I ensure workload-to-workload traffic is fully encrypted?”
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如何确保工作负载之间的流量完全加密？”
- en: “How do I ensure egress traffic goes through a gateway guaranteeing a consistent
    source CIDR?”
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如何确保出口流量通过网关，保证一致的源CIDR？”
- en: “How do I provide self-service tracing and dashboards to applications?”
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如何为应用程序提供自助跟踪和仪表盘？”
- en: “How do I let developers onboard without being concerned about them becoming
    Kubernetes experts?”
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “如何让开发人员在不成为Kubernetes专家的情况下上船？”
- en: This list can be endless. It is often incumbent on us to determine which requirements
    to solve at a platform level and which to solve at an application level. The key
    here is to deeply understand exiting workflows to ensure what we build lines up
    with current expectations. If we cannot meet that feature set, what impact will
    it have on the development teams? Next we can start the building of a platform
    on top of Kubernetes. In doing so, it is key we stay paired with development teams
    willing to onboard early and understand the experience to make informed decisions
    based on quick feedback. After reaching production, this flow should not stop.
    Platform teams should not expect what is delivered to be a static environment
    that developers will use for decades. In order to be successful, we must constantly
    be in tune with our development groups to understand where there are issues or
    potential missing features that could increase development velocity. A good place
    to start is considering what level of interaction with Kubernetes we should expect
    from our developers. This is the idea of how much, or how little, we should abstract.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可能是无穷无尽的。通常我们需要确定哪些需求在平台级别解决，哪些在应用级别解决。关键在于深入了解现有工作流程，以确保我们构建的东西符合当前的期望。如果我们无法满足这一功能集，这将对开发团队产生什么影响？接下来我们可以开始在Kubernetes之上构建一个平台。在这样做时，关键是我们要与愿意尽早上手并理解体验的开发团队保持配合，以便基于快速反馈做出明智的决策。在达到生产环境后，这种流程不应该停止。平台团队不应该期望交付的东西是开发者将会使用几十年的静态环境。为了取得成功，我们必须始终与我们的开发团队保持一致，了解存在哪些问题或潜在缺失功能可能会增加开发速度。开始考虑我们应该期望开发人员与Kubernetes互动的程度是一个很好的起点。这就是我们应该期望多大程度上，或者多小程度上抽象的概念。
- en: The Abstraction Spectrum
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象光谱
- en: In the past, we’ve heard posturing like, “If your application developers know
    they’re using Kubernetes, you’ve failed!” This can be a decent way to look at
    interaction with Kubernetes, especially if you’re building products or services
    where the underlying orchestration technology is meaningless to the end user.
    Perhaps you’re building a database management system (DBMS) that supports multiple
    database technologies. Whether shards or instances of a database run via Kubernetes,
    Bosh, or Mesos probably doesn’t matter to your developers! However, taking this
    philosophy wholesale from a tweet into your team’s success criteria is a dangerous
    thing to do. As we layer pieces on top of Kubernetes and build platform services
    to better serve our customers, we’ll be faced with many points of decision to
    determine what appropriate abstractions looks like. [Figure 1-9](#the_various_ends_of_the_spectrum_starting_with_giving)
    provides a visualization of this spectrum.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，我们听过类似“如果你的应用开发人员知道他们在使用Kubernetes，那么你就失败了！”这样的装腔作势。特别是在构建产品或服务时，底层编排技术对最终用户来说可能无关紧要。也许你正在构建一个支持多种数据库技术的数据库管理系统（DBMS）。无论数据库的分片还是实例是通过Kubernetes、Bosh还是Mesos运行，对你的开发人员来说可能并不重要！然而，将这种哲学从推特上整体引入到你团队的成功标准中是一件危险的事情。当我们在Kubernetes上叠加组件并构建平台服务以更好地服务我们的客户时，我们将面临许多决策点，以确定适当的抽象看起来如何。[图 1-9](#the_various_ends_of_the_spectrum_starting_with_giving)
    提供了这一光谱的可视化。
- en: '![prku 0109](assets/prku_0109.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0109](assets/prku_0109.png)'
- en: Figure 1-9\. The various ends of the spectrum. Starting with giving each team
    its own Kubernetes cluster to entirely abstracting Kubernetes from your users,
    via a platform as a service (PaaS) offering.
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-9\. 光谱的各种端点。从为每个团队提供自己的Kubernetes集群开始，到完全将Kubernetes从用户抽象出来，通过平台即服务（PaaS）提供。
- en: This can be a question that keeps platform teams up at night. There’s a lot
    of merit in providing abstractions. Projects like Cloud Foundry provide a fully
    baked developer experience—an example being that in the context of a single `cf
    push` we can take an application, build it, deploy it, and have it serving production
    traffic. With this goal and experience as a primary focus, as Cloud Foundry furthers
    its support for running on top of Kubernetes, we expect to see this transition
    as more of an implementation detail than a change in feature set. Another pattern
    we see is the desire to offer more than Kubernetes at a company, but not make
    developers explicitly choose between technologies. For example, some companies
    have a Mesos footprint alongside a Kubernetes footprint. They then build an abstraction
    enabling transparent selection of where workloads land without putting that onus
    on application developers. It also prevents them from technology lock-in. A trade-off
    to this approach includes building abstractions on top of two systems that operate
    differently. This requires significant engineering effort and maturity. Additionally,
    while developers are eased of the burden around knowing how to interact with Kubernetes
    or Mesos, they instead need to understand how to use an abstracted company-specific
    system. In the modern era of open source, developers from all over the stack are
    less enthused about learning systems that don’t translate between organizations.
    Lastly, a pitfall we’ve seen is an obsession with abstraction causing an inability
    to expose key features of Kubernetes. Over time this can become a cat-and-mouse
    game of trying to keep up with the project and potentially making your abstraction
    as complicated as the system it’s abstracting.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是让平台团队夜不能寐的问题。提供抽象化确实有很多优点。像 Cloud Foundry 这样的项目提供了一个完全成熟的开发者体验——例如，在一个 `cf
    push` 的上下文中，我们可以将一个应用程序构建、部署，并让其提供生产流量服务。以此目标和体验作为主要关注点，随着 Cloud Foundry 在 Kubernetes
    上的进一步支持，我们预计会看到这种过渡更多地成为一个实施细节，而不是功能集的变化。我们还看到的另一个模式是希望在公司内提供不仅仅是 Kubernetes 的选择，但不让开发人员明确选择技术的愿望。例如，一些公司既有
    Mesos 的足迹，又有 Kubernetes 的足迹。然后他们构建了一个抽象化，使得工作负载的落地选择变得透明，而不将这个责任放在应用程序开发者身上。这也防止了技术锁定的发生。这种方法的一个折衷是在两个操作方式不同的系统上构建抽象化需要大量的工程努力和成熟度。此外，虽然开发人员从
    Kubernetes 或 Mesos 交互的负担中得到了缓解，但他们需要理解如何使用一个抽象化的公司特定系统。在开源的现代时代，来自整个堆栈的开发人员对于不在组织之间转化的系统学习并不感兴趣。最后，我们看到的一个陷阱是对抽象化的痴迷导致无法暴露
    Kubernetes 的关键特性。随着时间的推移，这可能会变成一个试图跟上项目并且潜在地使您的抽象化变得和它所抽象的系统一样复杂的猫鼠游戏。
- en: On the other end of the spectrum are platform groups that wish to offer self-service
    clusters to development teams. This can also be a great model. It does put the
    responsibility of Kubernetes maturity on the development teams. Do they understand
    how Deployments, ReplicaSets, Pods, Services, and Ingress APIs work? Do they have
    a sense for setting millicpus and how overcommit of resources works? Do they know
    how to ensure that workloads configured with more than one replica are always
    scheduled on different nodes? If yes, this is a perfect opportunity to avoid over-engineering
    an application platform and instead let application teams take it from the Kubernetes
    layer up.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，希望为开发团队提供自助集群的平台组织也是一个很好的模式。这确实是一个很好的模式。这将把 Kubernetes 成熟性的责任放在开发团队身上。他们是否了解
    Deployments、ReplicaSets、Pods、Services 和 Ingress APIs 的工作原理？他们是否了解如何设置 millicpus
    以及资源过量提交的工作原理？他们是否知道如何确保配置有多个副本的工作负载始终安排在不同的节点上？如果是的话，这是一个完美的机会，可以避免在应用平台上过度设计，而是让应用团队从
    Kubernetes 层面开始处理。
- en: This model of development teams owning their own clusters is a little less common.
    Even with a team of humans that have a Kubernetes background, it’s unlikely that
    they want to take time away from shipping features to determine how to manage
    the life cycle of their Kubernetes cluster when it comes time to upgrade. There’s
    so much power in all the knobs Kubernetes exposes, but for many development teams,
    expecting them to become Kubernetes experts on top of shipping software is unrealistic.
    As you’ll find in the coming chapters, abstraction does not have to be a binary
    decision. At a variety of points we’ll be able to make informed decisions on where
    abstractions make sense. We’ll be determining where we can provide developers
    the right amount of flexibility while still streamlining their ability to get
    things done.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 开发团队拥有自己集群的这种开发模式相对较少见。即使有一支具备 Kubernetes 背景的团队，他们也不太可能希望抽出时间来确定如何管理其 Kubernetes
    集群的生命周期，尤其是在升级时。Kubernetes 提供了很多强大的功能，但对于许多开发团队来说，期望他们成为 Kubernetes 专家并在发布软件的同时处理这些事务是不现实的。正如你将在接下来的章节中发现的那样，抽象化并不是一个二进制的决定。在许多时候，我们可以根据具体情况做出明智的抉择，确定在哪些地方使用抽象化是有意义的。我们将确定在哪些地方我们可以为开发人员提供适当的灵活性，同时简化他们完成工作的能力。
- en: Determining Platform Services
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定平台服务
- en: When building on top of Kubernetes, a key determination is what features should
    be built into the platform relative to solved at the application level. Generally
    this is something that should be evaluated at a case-by-case basis. For example,
    let’s assume every Java microservice implements a library that facilitates mutual
    TLS (mTLS) between services. This provides applications a construct for identity
    of workloads and encryption of data over the network. As a platform team, we need
    to deeply understand this usage to determine whether it is something we should
    offer or implement at a platform level. Many teams look to solve this by potentially
    implementing a technology called a service mesh into the cluster. An exercise
    in trade-offs would reveal the following considerations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 Kubernetes 之上，关键的决定是相对于在应用程序级别解决的功能应该内建到平台中。通常情况下，这是一个需要按情况评估的问题。例如，假设每个
    Java 微服务都实现了一个库，用于在服务之间实现互相认证的互斥 TLS（mTLS），以及在网络上传输数据的加密。作为平台团队，我们需要深入了解这种用法，以确定我们是否应该在平台级别提供或实施这种功能。许多团队希望通过在集群中实施一种称为服务网格的技术来解决这个问题。通过权衡利弊，我们可以得出以下考虑。
- en: 'Pros to introducing a service mesh:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 引入服务网格的优点：
- en: Java apps no longer need to bundle libraries to facilitate mTLS.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 应用程序不再需要捆绑库来实现 mTLS。
- en: Non-Java applications can take part in the same mTLS/encryption system.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非 Java 应用程序可以参与相同的 mTLS/加密系统。
- en: Lessened complexity for application teams to solve for.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用团队减少了解决问题的复杂性。
- en: 'Cons to introducing a service mesh:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 引入服务网格的缺点：
- en: Running a service mesh is not a trivial task. It is another distributed system
    with operational complexity.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行服务网格并非小事。这是另一个具有操作复杂性的分布式系统。
- en: Service meshes often introduce features far beyond identity and encryption.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格通常引入远远超出身份验证和加密的功能。
- en: The mesh’s identity API might not integrate with the same backend system as
    used by the existing applications.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网格的身份验证 API 可能与现有应用程序使用的后端系统不同步。
- en: Weighing these pros and cons, we can come to the conclusion as to whether solving
    this problem at a platform level is worth the effort. The key is we don’t need
    to, and should not strive to, solve every application concern in our new platform.
    This is another balancing act to consider as you proceed through the many chapters
    in this book. Several recommendations, best practices, and guidance will be shared,
    but like anything, you should assess each based on the priorities of your business
    needs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 权衡这些优缺点，我们可以得出结论，决定在平台级别解决这个问题是否值得努力。关键在于我们不需要也不应该在新平台中解决每一个应用程序的问题。这是在你阅读本书中的许多章节时需要考虑的另一个平衡。我们将分享几个建议、最佳实践和指导，但像任何事情一样，你应该根据业务需求的优先级评估每一个。
- en: The Building Blocks
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建基础
- en: Let’s wrap up this chapter by concretely identifying key building blocks you
    will have available as you build a platform. This includes everything from the
    foundational components to optional platform services you may wish to implement.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过明确地识别你在构建平台时将拥有的关键构建块来结束这一章。这包括从基础组件到可选平台服务的一切。
- en: The components in [Figure 1-10](#many_of_the_key_building_blocks_involved_in_establishing)
    have differing importance to differing audiences.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1-10 中的组件对不同的受众具有不同的重要性。
- en: '![prku 0110](assets/prku_0110.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![prku 0110](assets/prku_0110.png)'
- en: Figure 1-10\. Many of the key building blocks involved in establishing an application
    platform.
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 1-10。建立应用平台所涉及的许多关键构建块。
- en: Some components such as container networking and container runtime are required
    for every cluster, considering that a Kubernetes cluster that can’t run workloads
    or allow them to communicate would not be very successful. You are likely to find
    some components to have variance in whether they should be implemented at all.
    For example, secret management might not be a platform service you intend to implement
    if applications already get their secrets from an external secret management solution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件，如容器网络和容器运行时，对于每个集群都是必需的，考虑到一个不能运行工作负载或允许它们通信的 Kubernetes 集群将不会很成功。您可能会发现一些组件在是否应该实现的问题上存在差异。例如，如果应用程序已经从外部秘密管理解决方案获取其密钥，则可能不打算实现秘密管理作为平台服务。
- en: Some areas, such as security, are clearly missing from [Figure 1-10](#many_of_the_key_building_blocks_involved_in_establishing).
    This is because security is not a feature but more so a result of how you implement
    everything from the IAAS layer up. Let’s explore these key areas at a high level,
    with the understanding that we’ll dive much deeper into them throughout this book.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一些领域，如安全性，明显缺失于图 1-10。这是因为安全性不是一个特性，而是从 IAAS 层以上的所有内容如何实现的结果。让我们在高层次上探讨这些关键领域，理解到我们将在本书中更深入地探讨它们。
- en: IAAS/datacenter and Kubernetes
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IAAS/数据中心和 Kubernetes
- en: IAAS/datacenter and Kubernetes form the foundational layer we have called out
    many times in this chapter. We don’t mean to trivialize this layer because its
    stability will directly correlate to that of our platform. However, in modern
    environments, we spend much less time determining the architecture of our racks
    to support Kubernetes and a lot more time deciding between a variety of deployment
    options and topologies. Essentially we need to assess how we are going to provision
    and make available Kubernetes clusters.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: IAAS/数据中心和 Kubernetes 构成了我们在本章中多次提到的基础层。我们并不是要贬低这一层，因为它的稳定性将直接影响我们平台的稳定性。然而，在现代环境中，我们花费的时间远少于确定支持
    Kubernetes 的架构的机架架构，而是更多地花费在选择各种部署选项和拓扑结构之间。基本上，我们需要评估如何提供和使 Kubernetes 集群可用。
- en: Container runtime
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器运行时
- en: The container runtime will faciliate the life cycle management of our workloads
    on each host. This is commonly implemented using a technology that can manage
    containers, such as CRI-O, containerd, and Docker. The ability to choose between
    these different implementations is thanks to the Container Runtime Interface (CRI).
    Along with these common examples, there are specialized runtimes that support
    unique requirements, such as the desire to run a workload in a micro-vm.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行时将在每个主机上管理我们的工作负载的生命周期。这通常使用可以管理容器的技术来实现，例如 CRI-O、containerd 和 Docker。通过容器运行时接口（CRI），我们能够选择这些不同的实现方式。除了这些常见的示例外，还有支持特定要求的专用运行时，例如希望在微型虚拟机中运行工作负载的需求。
- en: Container networking
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器网络
- en: Our choice of container networking will commonly address IP address management
    (IPAM) of workloads and routing protocols to facilitate communication. Common
    technology choices include Calico or Cilium, which is thanks to the Container
    Networking Interface (CNI). By plugging a container networking technology into
    the cluster, the kubelet can request IP addresses for the workloads it starts.
    Some plug-ins go as far as implementing service abstractions on top of the Pod
    network.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择的容器网络通常涉及工作负载的 IP 地址管理（IPAM）和路由协议，以促进通信。常见的技术选择包括 Calico 或 Cilium，这要归功于容器网络接口（CNI）。通过将容器网络技术插入集群，kubelet
    可以请求工作负载的 IP 地址。一些插件甚至进一步在 Pod 网络的顶部实现服务抽象。
- en: Storage integration
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储集成
- en: Storage integration covers what we do when the on-host disk storage just won’t
    cut it. In modern Kubernetes, more and more organizations are shipping stateful
    workloads to their clusters. These workloads require some degree of certainty
    that the state will be resilient to application failure or rescheduling events.
    Storage can be supplied by common systems such as vSAN, EBS, Ceph, and many more.
    The ability to choose between various backends is facilitated by the Container
    Storage Interface (CSI). Similar to CNI and CRI, we are able to deploy a plug-in
    to our cluster that understands how to satisfy the storage needs requested by
    the application.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 存储集成涵盖了当主机磁盘存储无法满足需求时的应对措施。在现代Kubernetes中，越来越多的组织将有状态的工作负载部署到其集群中。这些工作负载需要一定程度的保证，在应用程序故障或重新调度事件中状态将是弹性的。存储可以由常见的系统提供，如vSAN、EBS、Ceph等等。通过容器存储接口（CSI），我们可以选择各种后端以满足应用程序请求的存储需求。类似于CNI和CRI，我们能够在集群中部署插件，理解如何满足应用程序请求的存储需求。
- en: Service routing
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务路由
- en: Service routing is the facilitation of traffic to and from the workloads we
    run in Kubernetes. Kubernetes offers a Service API, but this is typically a stepping
    stone for support of more feature-rich routing capabilities. Service routing builds
    on container networking and creates higher-level features such as layer 7 routing,
    traffic patterns, and much more. Many times these are implemented using a technology
    called an Ingress controller. At the deeper side of service routing comes a variety
    of service meshes. This technology is fully featured with mechanisms such as service-to-service
    mTLS, observability, and support for applications mechanisms such as circuit breaking.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 服务路由是我们在Kubernetes中运行的工作负载之间流量的促进。Kubernetes提供了一个Service API，但这通常只是支持更丰富的路由能力的第一步。服务路由建立在容器网络基础上，并创建了更高级别的功能，如第7层路由、流量模式等。许多时候，这些功能是使用称为Ingress控制器的技术实现的。在服务路由的深层次上，有各种服务网格技术。这种技术具备完整的功能，例如服务到服务的mTLS、可观察性以及支持应用程序机制，如断路器。
- en: Secret management
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 机密管理
- en: Secret management covers the management and distribution of sensitive data needed
    by workloads. Kubernetes offers a Secrets API where sensitive data can be interacted
    with. However, out of the box, many clusters don’t have robust enough secret management
    and encryption capabilities demanded by several enterprises. This is largely a
    conversation around defense in depth. At a simple level, we can ensure data is
    encrypted before it is stored (encryption at rest). At a more advanced level,
    we can provide integration with various technologies focused on secret management,
    such as Vault or Cyberark.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 机密管理涵盖了工作负载所需的敏感数据的管理和分发。Kubernetes提供了一个Secrets API，可以与敏感数据交互。然而，默认情况下，许多集群的机密管理和加密能力不足以满足多个企业的需求。这主要是关于深度防御的讨论。在简单级别上，我们可以确保数据在存储之前进行加密（静态加密）。在更高级别上，我们可以与各种专注于机密管理的技术集成，如Vault或Cyberark。
- en: Identity
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证
- en: Identity covers the authentication of humans and workloads. A common initial
    ask of cluster administrators is how to authenticate users against a system such
    as LDAP or a cloud provider’s IAM system. Beyond humans, workloads may wish to
    identify themselves to support zero-trust networking models where impersonation
    of workloads is far more challenging. This can be facilitated by integrating an
    identity provider and using mechanisms such as mTLS to verify a workload.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证涵盖了对人员和工作负载的身份验证。集群管理员最常见的初始要求之一是如何对用户进行身份验证，例如LDAP或云提供商的IAM系统。除了人类，工作负载可能希望识别自己以支持零信任网络模型，其中工作负载的冒充要困难得多。这可以通过集成身份提供者并使用诸如mTLS之类的机制来实现，以验证工作负载的身份。
- en: Authorization/admission control
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 授权/准入控制
- en: Authorization is the next step after we can verify the identity of a human or
    workload. When users or workloads interact with the API server, how do we grant
    or deny their access to resources? Kubernetes offers an RBAC feature with resource/verb-level
    controls, but what about custom logic specific to authorization inside our organization?
    Admission control is where we can take this a step further by building out validation
    logic that can be as simple as looking over a static list of rules to dynamically
    calling other systems to determine the correct authorization response.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 授权是在我们可以验证人类或工作负载的身份之后的下一步。当用户或工作负载与 API 服务器交互时，我们如何允许或拒绝他们访问资源？Kubernetes 提供了一种基于资源/动作级别控制的
    RBAC 功能，但是在我们组织内部特定于授权的自定义逻辑又如何处理呢？准入控制是我们可以进一步推进的地方，通过构建验证逻辑，这可以简单到查看静态规则列表，也可以动态调用其他系统来确定正确的授权响应。
- en: Software supply chain
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件供应链
- en: The software supply chain covers the entire life cycle of getting software in
    source code to runtime. This involves the common concerns around continuous integration
    (CI) and continuous delivery (CD). Many times, developers’ primary interaction
    point is the pipelines they establish in these systems. Getting the CI/CD systems
    working well with Kubernetes can be paramount to your platform’s success. Beyond
    CI/CD are concerns around the storage of artifacts, their safety from a vulnerability
    standpoint, and ensuring integrity of images that will be run in your cluster.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 软件供应链涵盖了将软件从源代码到运行时的整个生命周期。这涉及到持续集成（CI）和持续交付（CD）周围的常见问题。许多时候，开发人员主要与他们在这些系统中建立的流水线进行交互。确保
    CI/CD 系统与 Kubernetes 良好集成可能对平台的成功至关重要。除了 CI/CD，还涉及到有关工件存储、从漏洞角度的安全性以及确保在集群中运行的镜像完整性的问题。
- en: Observability
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Observability
- en: Observability is the umbrella term for all things that help us understand what’s
    happening with our clusters. This includes at the system and application layers.
    Typically, we think of observability to cover three key areas. These are logs,
    metrics, and tracing. Logging typically involves forwarding log data from workloads
    on the host to a target backend system. From this system we can aggregate and
    analyze logs in a consumable way. Metrics involves capturing data that represents
    some state at a point in time. We often aggregate, or scrape, this data into some
    system for analysis. Tracing has largely grown in popularity out of the need to
    understand the interactions between the various services that make up our application
    stack. As trace data is collected, it can be brought up to an aggregate system
    where the life of a request or response is shown via some form of context or correlation
    ID.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Observability 是一个涵盖所有帮助我们理解集群中发生情况的术语。这包括系统和应用程序层面。通常，我们认为可观察性涵盖三个关键领域。这些领域是日志、指标和追踪。日志通常涉及将工作负载上的日志数据转发到目标后端系统。通过这个系统，我们可以聚合和分析日志，以便消化。指标涉及捕获某个时间点表示状态的数据。我们经常将这些数据聚合或抓取到某个系统进行分析。追踪由于需要理解组成我们应用程序堆栈的各个服务之间的交互而日益普及。当追踪数据被收集时，它可以被提取到一个聚合系统，通过某种上下文或关联
    ID 显示请求或响应的生命周期。
- en: Developer abstractions
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发者抽象化
- en: Developer abstractions are the tools and platform services we put in place to
    make developers successful in our platform. As discussed earlier, abstraction
    approaches live on a spectrum. Some organizations will choose to make the usage
    of Kubernetes completely transparent to the development teams. Other shops will
    choose to expose many of the powerful knobs Kubernetes offers and give significant
    flexibility to every developer. Solutions also tend to focus on the developer
    onboarding experience, ensuring they can be given access and secure control of
    an environment they can utilize in the platform.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者抽象化是我们为了使开发人员在我们的平台上成功而设置的工具和平台服务。正如前面讨论的，抽象化方法存在于一个光谱上。一些组织将选择使 Kubernetes
    的使用对开发团队完全透明化。其他团队则选择暴露 Kubernetes 提供的许多强大控制选项，并为每个开发人员提供显著的灵活性。解决方案还倾向于关注开发者入职体验，确保他们能够获得访问和安全控制他们可以在平台上利用的环境。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored ideas spanning Kubernetes, application platforms,
    and even building application platforms on Kubernetes. Hopefully this has gotten
    you thinking about the variety of areas you can jump into in order to better understand
    how to build on top of this great workload orchestrator. For the remainder of
    the book we are going to dive into these key areas and provide insight, anecdotes,
    and recommendations that will further build your perspective on platform building.
    Let’s jump in and start down this path to production!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了涵盖 Kubernetes、应用平台甚至在 Kubernetes 上构建应用平台的各种想法。希望这让你开始思考，关于如何更好地理解如何在这个强大的工作负载编排器上构建应用的各种领域。在本书的剩余部分中，我们将深入探讨这些关键领域，并提供见解、轶事和建议，进一步拓展你在平台构建方面的视角。让我们开始这条通往生产之路吧！
