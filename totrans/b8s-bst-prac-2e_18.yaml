- en: Chapter 18\. GitOps and Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss GitOps and how it can be used to deploy and
    manage applications on Kubernetes. We will deep dive into best practices of setting
    up a GitOps workflow and how to utilize the different tools available to achieve
    this.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: GitOps is a way to do Kubernetes application deployment. It works by utilizing
    Git as a single source of truth for your Kubernetes resources. With Git at the
    center of your deployment pipelines, developers and operators can make pull requests
    to accelerate and simplify application deployments and operations tasks in Kubernetes.
    This allows you to utilize the same practices for managing Kubernetes resources
    as you do for managing application code. Developers will be very familiar with
    the workflow, as they can utilize the same tools they use to work with application
    code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: What is GitOps?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why utilize GitOps?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps compared to other deployment methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps tooling
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also go through an example GitOps workflow consisting of the following tasks:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a GitOps agent with Flux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting Flux agent to a Git repository
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing resources to a Kubernetes cluster
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application to the cluster
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Is GitOps?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps was popularized by the folks at Weaveworks, and the idea and fundamentals
    were based on their experience of running Kubernetes in production. GitOps takes
    the concepts of the software development life cycle and applies them to operations.
    With GitOps, your Git repository becomes your source of truth, and your cluster
    is synchronized to the configured Git repository. For example, if you update a
    Kubernetes Deployment manifest, those configuration changes are automatically
    reflected in the cluster state in Git.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: By using this method, you can make it easier to maintain multiclusters that
    are consistent and avoid configuration drift across the fleet. GitOps allows you
    to declaratively describe your clusters for multiple environments and drives to
    maintain that state for the cluster. The practice of GitOps can apply to both
    application delivery and operations and provides developers with a common toolchain.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Weaveworks Flux was one of the first tools to enable the GitOps approach, and
    it’s the tool we will use throughout the rest of the chapter. Many new tools that
    have been released into the cloud native ecosystem are worth a look, such as Argo
    CD, from the folks at Intuit, which has also been widely adopted for the GitOps
    approach. We will dive more into the tooling available for GitOps later in the
    chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-1](#GitOps-Workflow) provides a representation of a GitOps workflow.
    We have a Git repository that contains the application code and Kubernetes manifests
    for our application. The Flux agent is configured to watch the repo for any changes.
    When a developer commits a code change, the Flux agent will sync any new changes
    to the Kubernetes clusters.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '![GitOps Workflow](assets/kbp2_1801.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1\. GitOps workflow
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When building your GitOps workflow, you should consider the four core principals
    of GitOps defined by the [OpenGitOps Project](https://oreil.ly/3Rz55):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Declarative configuration
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: All configuration is stored in Git as declarative YAML files. This allows for
    a single source of truth for your cluster configuration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Versioned configuration
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: All configuration is stored in Git, and all changes are tracked and versioned.
    This allows for easy auditing of changes and rollbacks.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Immutable configuration
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: All configuration is immutable. This means that once a change is made, it cannot
    be modified. This allows for a consistent state of the cluster.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Continuous state reconciliation
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The cluster state is continuously reconciled with the state defined in Git.
    This allows for the cluster to be in a consistent state.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Why GitOps?
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps is a excellent way to manage your Kubernetes clusters, and it can be
    used to deploy applications to your cluster as well as manage cluster and application
    configuration. Before we talk about all the benefits, let’s first look at how
    we traditionally deployed and configured applications on Kubernetes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-2](#Traditional-Deployment-Workflow) shows a traditional deployment
    workflow. We have a developer who is working on a new feature for an application.
    The developer will make changes to the application code and then build a new container
    image. Next, the developer will push the new container image to a container registry.
    The developer will then update the Kubernetes manifest to use the new container
    image, and then apply the changes to the cluster. This is a very manual process,
    and it can be very time consuming. Some of these steps can be automated with tools,
    but this can become complex as the number of applications and clusters grow.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![Traditional Deployment Workflow](assets/kbp2_1802.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 18-2\. Traditional deployment workflow
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This workflow can be very error prone, and it can be difficult to track down
    the source of the issue. It can also be difficult to roll back changes, as you
    will need to manually revert the changes to the Kubernetes manifest. It can also
    cause configuration drift, as users may make direct changes to the resources in
    Kubernetes. Controlling security access to the environment can also become complex
    with multiple pipelines and users needing access. Auditing of each interaction
    from change to deployment can also be difficult with multiple pipelines.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve these problems with the following benefits GitOps provides:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Declarative configuration
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: All configuration is stored in Git as declarative YAML files. This allows for
    a single source of truth. It also allows for easy auditing of changes using Git
    history. Developers will be accustomed to working with Git, so they will be familiar
    with the workflow.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Version controlled
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Git repository supports immutability and version history. For example, using
    Git for the previously mentioned configuration will give you a single source from
    which everything for your application is driven. This allows you to easily track
    any changes made at any time. It allows you to look at all changes found in Git
    history and compare those changes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Continuous reconciliation
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: The cluster state is continuously reconciled with the state defined in Git.
    It also allows for easy rollbacks, as you can simply revert the changes in Git.
    The system can automatically sync the same state in Git to your cluster. This
    allows for the cluster to be in a consistent state.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Security
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: When you use Git to manage applications deployed to Kubernetes, you gain a complete
    audit log of all changes to the cluster. All changes are made to the Git repository,
    and the GitOps agent can automatically reconcile any changes made directly to
    a Kubernetes resource. This provides a full audit trail of who changed what. It
    enables consistent operations and enhances security of the environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: While you may have a very automated CI/CD pipeline, you may still have some
    manual steps in your workflow. GitOps aims to solve these challenges by automating
    the workflow and providing a developer-centric workflow.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: GitOps Repo Structure
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first questions about GitOps is how to structure your Git repository.
    There are many different ways to structure your Git repository, but all come with
    their own pros and cons.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Four common strategies for structuring your Git repository are:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Single monorepo
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'All Kubernetes manifests and application code are stored in a single repository.
    This is the simple approach, but it becomes much more difficult as the company
    scales. This approach also does not allow for separation of concerns, as all teams’
    source code and Kubernetes manifests will live in a single repository. This can
    work well for a smaller company, but you’ll quickly outgrow this approach as your
    company grows. Following is a sample of this type of repo layout structure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Repo per team
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Each team has its own repository, and the Kubernetes manifests are stored in
    the same repository. This approach allows for better organization and separation
    of concerns but becomes more difficult to manage as your application portfolio
    grows over time. Following is a sample of this type of repo layout structure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Repo per application
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'Each application has its own repository, and the Kubernetes manifests are stored
    in the same repository. This approach allows for better organization and separation
    of concerns, as it can be locked down to read-only access for the team. The con
    of using this structure is not everything can be seen in one place. Following
    is a sample of this type of repo layout structure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Branch per environment
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Each environment has its own branch in the same repository. This approach allows
    you to promote environments with a simple Git merge. Promoting via a simple Git
    merge can lead to unwanted changes between environments and merge conflicts between
    environments. The downside to this is you will typically have a lot of branches,
    and it can be difficult to manage. This approach also doesn’t fit with templating
    tools such as Kustomize and Helm. Following is a sample of this type of repo layout
    structure:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Typically, you will want to assess your organization and team layout to decide
    which structure works best for you. Starting with a repo per team is a excellent
    starting point, as it’s a good middle ground that provides clear separation of
    concerns and easy repo management.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Managing Secrets
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Secrets management is a common challenge when implementing a GitOps workflow.
    There are many different ways to manage secrets, and the best approach will depend
    on your organization. Next we will dive into the five common approaches you can
    take with managing secrets in a GitOps way:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Store secrets directly in Git
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: This approach is the simplest, but it is not recommended. The problem with this
    approach is that you are storing plain text secrets in a repository that may be
    public. Even if your repository is internal and private, your are still storing
    the secrets in plain text. Multiple users may have access to this repo and will
    then have access to the secrets.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Bake secrets into container image
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: This approach is a little better than storing secrets in plain text in Git.
    The problem with this approach is baking secrets into the image will require you
    to rebuild the image each time secrets are rotated. It also doesn’t address the
    security concerns as multiple users may be able to pull the image and run it.
    This approach is also not recommended due to security concerns.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Use Kubernetes Secrets
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: This approach is available directly in Kubernetes and provides an easy way to
    get started. The problem with this approach is that Kubernetes Secrets are not
    really secret. What we mean here is that Kubernetes Secrets look encrypted, but
    are actually just base64 encoded. This approach is also not recommended due to
    security concerns.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Use Sealed Secrets
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed Secrets is a project by Bitnami. It has two components: a cluster controller
    and a client-side tool call kubeseal. The kubeseal utility uses asymmetric crypto
    to encrypt secrets that only the controller can decrypt. These secrets can then
    be stored in Git encrypted and can only be decrypted by the controller in your
    cluster. This is a recommended approach for managing secrets in a GitOps way.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Store secrets in a secret management tool
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows you to store secrets in a secure location and then access
    them from your cluster. These secrets can be stored in an external secret management
    solution like HashiCorp Vault, Azure Keyvault, Google KMS, etc. This approach
    allows you to use existing solutions you may already have in place and continue
    with the same workflow. This approach is also a recommended approach for managing
    secrets in a GitOps way.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许您将密钥存储在安全位置，并从您的集群访问它们。这些密钥可以存储在像 HashiCorp Vault、Azure Keyvault、Google
    KMS 等外部密钥管理解决方案中。这种方法允许您使用可能已经存在的现有解决方案，并继续使用相同的工作流程。这也是以 GitOps 方式管理密钥的推荐方法之一。
- en: While there are lot of different ways to manage secrets, the best approach will
    depend on your organization. As we discussed, Sealed Secrets and external secret
    management are the recommended approaches for managing secrets.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多不同的方法来管理密钥，但最佳方法将取决于您的组织。正如我们讨论的那样，Sealed Secrets 和外部密钥管理是管理密钥的推荐方法。
- en: Setting Up Flux
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Flux
- en: Flux is a Kubernetes operator that watches your Git repository for changes and
    automatically applies those changes to your cluster. Flux is a mature tool for
    implementing GitOps in your cluster, and it is the tool we will use throughout
    the rest of the chapter.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 是一个 Kubernetes 运算符，它监视您的 Git 仓库的变化，并自动将这些变化应用到您的集群中。Flux 是在您的集群中实施 GitOps
    的成熟工具，并且它是我们将在本章的其余部分中使用的工具。
- en: 'First, we’ll start by getting minikube set up to deploy Flux. You can install
    minikube from the [minikube website](https://oreil.ly/GMPMl). We are using Macs
    so we’ll use `brew` to install minikube:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将开始配置 minikube 以部署 Flux。您可以从 [minikube 网站](https://oreil.ly/GMPMl) 安装 minikube。我们正在使用
    Mac，所以我们将使用 `brew` 安装 minikube：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now we’ll install Flux and prepare our cluster to sync to a Git repository.
    We’ll use the `flux` CLI to install Flux. You can install the `flux` CLI from
    the [flux website](https://oreil.ly/h2_hQ).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将安装 Flux 并准备我们的集群以同步到 Git 仓库。我们将使用 `flux` CLI 安装 Flux。你可以从 [flux 网站](https://oreil.ly/h2_hQ)
    安装 `flux` CLI。
- en: 'Install Flux CLI:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Flux CLI：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Export your GitHub token:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 导出您的 GitHub 令牌：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Check that your cluster can install Flux:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 检查您的集群是否可以安装 Flux：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Bootstrap Flux:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 引导 Flux：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding `bootstrap` command will create a Git repo called kbp-flux in
    your GitHub account. It will also create a `main` branch and a *clusters/prod*
    directory. The *clusters/prod* directory will contain the Flux components that
    will be deployed to your cluster. The *clusters/prod* directory will also contain
    a *gotk-components.yaml* file that will be used to deploy the Flux components
    to your cluster. This also installs the Flux components into the `flux-system`
    namespace.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `bootstrap` 命令将在您的 GitHub 账户中创建一个名为 kbp-flux 的 Git 仓库。它还将创建一个 `main` 分支和一个
    *clusters/prod* 目录。*clusters/prod* 目录将包含将部署到您的集群中的 Flux 组件。*clusters/prod* 目录还将包含一个
    *gotk-components.yaml* 文件，该文件将用于将 Flux 组件部署到您的集群中。这还将把 Flux 组件安装到 `flux-system`
    命名空间中。
- en: 'Now let’s check the `flux-system` namespace to see if the Flux components are
    deployed:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查 `flux-system` 命名空间，看看 Flux 组件是否已部署：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should see the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now let’s clone the repo it created to our local machine:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将它创建的仓库克隆到我们的本地机器上：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Next we’ll add a Flux configuration to our repo and use a public repository
    on GitHub. We’ll use a sample application created by Stefan Prodan from Weaveworks.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的仓库添加一个 Flux 配置，并在 GitHub 上使用一个公共仓库。我们将使用 Weaveworks 的 Stefan Prodan
    创建的示例应用程序。
- en: 'Let’s create a Git repository manifest pointing to the apps repository’s main
    branch:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个指向应用程序仓库主分支的 Git 仓库清单：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we’ll configure Flux to deploy the application and apply a Kustomize configuration
    to the application:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将配置 Flux 来部署该应用程序，并向应用程序应用 Kustomize 配置：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we’ll push the changes to our repo:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将推送更改到我们的仓库：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can seeing this being applied by using the Flux CLI:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Flux CLI 看到这些变化正在应用中：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can see the resources have been deployed to our cluster:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到资源已经部署到我们的集群中：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Any changes made to the podinfo Kubernetes manifests in the main branch are
    now reflected in your cluster automatically.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 主分支中对 podinfo Kubernetes 清单所做的任何更改现在都会自动反映在您的集群中。
- en: We have now set up Flux in our cluster, bootstrapped it to a Git repository,
    and configured Flux to deploy an application. We can now start to use Flux to
    manage our cluster.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在我们的集群中设置了 Flux，并将其引导到一个 Git 仓库，并配置 Flux 来部署一个应用程序。现在我们可以开始使用 Flux 来管理我们的集群。
- en: This is a very basic example of how to get Flux set up, and if you want a deeper
    dive into Flux, you can check out the [Flux documentation](https://oreil.ly/F5D2p).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: GitOps Tooling
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many different tools can be used to implement GitOps in your cluster. In this
    section, we will go over some of the most popular.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'When evaluating tools for GitOps, you should consider ease of use, enterprise
    features, and extensibility. Listed next are both open source and commercial tools
    that can be used to implement GitOps in your cluster:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Flux
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Flux is a Kubernetes operator that watches your Git repository for changes and
    automatically applies those changes to your cluster. Flux is a mature tool for
    implementing GitOps in your cluster. Weaveworks also provides a hosted version
    of Flux. Flux is currently a CNCF graduated project.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: ArgoCD
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD is an open source GitOps continuous delivery tool. It monitors your
    cluster and your declaratively defined infrastructure stored in a Git repository
    and resolves differences between the two—effectively automating an application
    deployment. ArgoCD is currently a CNCF graduated project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Codefresh
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Codefresh is a CI/CD platform that can be used to implement GitOps in your cluster.
    Codefresh provides a hosted platform that provides ArgoCD as a service.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Harness
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Harness is a CI/CD platform that can be used to implement GitOps in your cluster.
    Harness is a mature tool for implementing GitOps in your cluster and provides
    a hosted version. Harness is geared toward enterprise customers and provides a
    full suite of continuous delivery features.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: GitOps Best Practices
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following best practices when using GitOps with Kubernetes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Start with a small application and then scale your efforts for managing everything
    with a GitOps model. This will allow you to build confidence in your GitOps implementation.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate tools that fit your requirements or start with proven OSS tools like
    Flux or ArgoCD.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using branches for your repository layout, as this is the most complex
    and error-prone repository layout.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start with a folder per environment, as this provides flexibility and allows
    you to use tools like Kustomize or Helm for templating.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize Sealed Secrets or an external secrets provider to manage secrets in
    your cluster.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember GitOps is a process and not a tool, and your existing tool set may
    fit your needs.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over what GitOps is and how it can be used to manage
    your Kubernetes cluster. We also went over some of the tools that can be used
    to implement GitOps in your cluster. When looking to see if GitOps is right for
    you, you should consider what problems you are trying to solve and what your requirements
    are. If GitOps help solves these problems for you, then looking at a tool like
    Flux or ArgoCD is a good place to start.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
