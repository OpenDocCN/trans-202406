- en: Chapter 18\. GitOps and Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss GitOps and how it can be used to deploy and
    manage applications on Kubernetes. We will deep dive into best practices of setting
    up a GitOps workflow and how to utilize the different tools available to achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps is a way to do Kubernetes application deployment. It works by utilizing
    Git as a single source of truth for your Kubernetes resources. With Git at the
    center of your deployment pipelines, developers and operators can make pull requests
    to accelerate and simplify application deployments and operations tasks in Kubernetes.
    This allows you to utilize the same practices for managing Kubernetes resources
    as you do for managing application code. Developers will be very familiar with
    the workflow, as they can utilize the same tools they use to work with application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is GitOps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why utilize GitOps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps compared to other deployment methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitOps tooling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also go through an example GitOps workflow consisting of the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a GitOps agent with Flux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting Flux agent to a Git repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing resources to a Kubernetes cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying an application to the cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Is GitOps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps was popularized by the folks at Weaveworks, and the idea and fundamentals
    were based on their experience of running Kubernetes in production. GitOps takes
    the concepts of the software development life cycle and applies them to operations.
    With GitOps, your Git repository becomes your source of truth, and your cluster
    is synchronized to the configured Git repository. For example, if you update a
    Kubernetes Deployment manifest, those configuration changes are automatically
    reflected in the cluster state in Git.
  prefs: []
  type: TYPE_NORMAL
- en: By using this method, you can make it easier to maintain multiclusters that
    are consistent and avoid configuration drift across the fleet. GitOps allows you
    to declaratively describe your clusters for multiple environments and drives to
    maintain that state for the cluster. The practice of GitOps can apply to both
    application delivery and operations and provides developers with a common toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: Weaveworks Flux was one of the first tools to enable the GitOps approach, and
    it’s the tool we will use throughout the rest of the chapter. Many new tools that
    have been released into the cloud native ecosystem are worth a look, such as Argo
    CD, from the folks at Intuit, which has also been widely adopted for the GitOps
    approach. We will dive more into the tooling available for GitOps later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-1](#GitOps-Workflow) provides a representation of a GitOps workflow.
    We have a Git repository that contains the application code and Kubernetes manifests
    for our application. The Flux agent is configured to watch the repo for any changes.
    When a developer commits a code change, the Flux agent will sync any new changes
    to the Kubernetes clusters.'
  prefs: []
  type: TYPE_NORMAL
- en: '![GitOps Workflow](assets/kbp2_1801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1\. GitOps workflow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When building your GitOps workflow, you should consider the four core principals
    of GitOps defined by the [OpenGitOps Project](https://oreil.ly/3Rz55):'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative configuration
  prefs: []
  type: TYPE_NORMAL
- en: All configuration is stored in Git as declarative YAML files. This allows for
    a single source of truth for your cluster configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Versioned configuration
  prefs: []
  type: TYPE_NORMAL
- en: All configuration is stored in Git, and all changes are tracked and versioned.
    This allows for easy auditing of changes and rollbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable configuration
  prefs: []
  type: TYPE_NORMAL
- en: All configuration is immutable. This means that once a change is made, it cannot
    be modified. This allows for a consistent state of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous state reconciliation
  prefs: []
  type: TYPE_NORMAL
- en: The cluster state is continuously reconciled with the state defined in Git.
    This allows for the cluster to be in a consistent state.
  prefs: []
  type: TYPE_NORMAL
- en: Why GitOps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps is a excellent way to manage your Kubernetes clusters, and it can be
    used to deploy applications to your cluster as well as manage cluster and application
    configuration. Before we talk about all the benefits, let’s first look at how
    we traditionally deployed and configured applications on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 18-2](#Traditional-Deployment-Workflow) shows a traditional deployment
    workflow. We have a developer who is working on a new feature for an application.
    The developer will make changes to the application code and then build a new container
    image. Next, the developer will push the new container image to a container registry.
    The developer will then update the Kubernetes manifest to use the new container
    image, and then apply the changes to the cluster. This is a very manual process,
    and it can be very time consuming. Some of these steps can be automated with tools,
    but this can become complex as the number of applications and clusters grow.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Traditional Deployment Workflow](assets/kbp2_1802.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 18-2\. Traditional deployment workflow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This workflow can be very error prone, and it can be difficult to track down
    the source of the issue. It can also be difficult to roll back changes, as you
    will need to manually revert the changes to the Kubernetes manifest. It can also
    cause configuration drift, as users may make direct changes to the resources in
    Kubernetes. Controlling security access to the environment can also become complex
    with multiple pipelines and users needing access. Auditing of each interaction
    from change to deployment can also be difficult with multiple pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve these problems with the following benefits GitOps provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative configuration
  prefs: []
  type: TYPE_NORMAL
- en: All configuration is stored in Git as declarative YAML files. This allows for
    a single source of truth. It also allows for easy auditing of changes using Git
    history. Developers will be accustomed to working with Git, so they will be familiar
    with the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Version controlled
  prefs: []
  type: TYPE_NORMAL
- en: Git repository supports immutability and version history. For example, using
    Git for the previously mentioned configuration will give you a single source from
    which everything for your application is driven. This allows you to easily track
    any changes made at any time. It allows you to look at all changes found in Git
    history and compare those changes.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous reconciliation
  prefs: []
  type: TYPE_NORMAL
- en: The cluster state is continuously reconciled with the state defined in Git.
    It also allows for easy rollbacks, as you can simply revert the changes in Git.
    The system can automatically sync the same state in Git to your cluster. This
    allows for the cluster to be in a consistent state.
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs: []
  type: TYPE_NORMAL
- en: When you use Git to manage applications deployed to Kubernetes, you gain a complete
    audit log of all changes to the cluster. All changes are made to the Git repository,
    and the GitOps agent can automatically reconcile any changes made directly to
    a Kubernetes resource. This provides a full audit trail of who changed what. It
    enables consistent operations and enhances security of the environment.
  prefs: []
  type: TYPE_NORMAL
- en: While you may have a very automated CI/CD pipeline, you may still have some
    manual steps in your workflow. GitOps aims to solve these challenges by automating
    the workflow and providing a developer-centric workflow.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps Repo Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the first questions about GitOps is how to structure your Git repository.
    There are many different ways to structure your Git repository, but all come with
    their own pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Four common strategies for structuring your Git repository are:'
  prefs: []
  type: TYPE_NORMAL
- en: Single monorepo
  prefs: []
  type: TYPE_NORMAL
- en: 'All Kubernetes manifests and application code are stored in a single repository.
    This is the simple approach, but it becomes much more difficult as the company
    scales. This approach also does not allow for separation of concerns, as all teams’
    source code and Kubernetes manifests will live in a single repository. This can
    work well for a smaller company, but you’ll quickly outgrow this approach as your
    company grows. Following is a sample of this type of repo layout structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Repo per team
  prefs: []
  type: TYPE_NORMAL
- en: 'Each team has its own repository, and the Kubernetes manifests are stored in
    the same repository. This approach allows for better organization and separation
    of concerns but becomes more difficult to manage as your application portfolio
    grows over time. Following is a sample of this type of repo layout structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Repo per application
  prefs: []
  type: TYPE_NORMAL
- en: 'Each application has its own repository, and the Kubernetes manifests are stored
    in the same repository. This approach allows for better organization and separation
    of concerns, as it can be locked down to read-only access for the team. The con
    of using this structure is not everything can be seen in one place. Following
    is a sample of this type of repo layout structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Branch per environment
  prefs: []
  type: TYPE_NORMAL
- en: 'Each environment has its own branch in the same repository. This approach allows
    you to promote environments with a simple Git merge. Promoting via a simple Git
    merge can lead to unwanted changes between environments and merge conflicts between
    environments. The downside to this is you will typically have a lot of branches,
    and it can be difficult to manage. This approach also doesn’t fit with templating
    tools such as Kustomize and Helm. Following is a sample of this type of repo layout
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Typically, you will want to assess your organization and team layout to decide
    which structure works best for you. Starting with a repo per team is a excellent
    starting point, as it’s a good middle ground that provides clear separation of
    concerns and easy repo management.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Secrets management is a common challenge when implementing a GitOps workflow.
    There are many different ways to manage secrets, and the best approach will depend
    on your organization. Next we will dive into the five common approaches you can
    take with managing secrets in a GitOps way:'
  prefs: []
  type: TYPE_NORMAL
- en: Store secrets directly in Git
  prefs: []
  type: TYPE_NORMAL
- en: This approach is the simplest, but it is not recommended. The problem with this
    approach is that you are storing plain text secrets in a repository that may be
    public. Even if your repository is internal and private, your are still storing
    the secrets in plain text. Multiple users may have access to this repo and will
    then have access to the secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Bake secrets into container image
  prefs: []
  type: TYPE_NORMAL
- en: This approach is a little better than storing secrets in plain text in Git.
    The problem with this approach is baking secrets into the image will require you
    to rebuild the image each time secrets are rotated. It also doesn’t address the
    security concerns as multiple users may be able to pull the image and run it.
    This approach is also not recommended due to security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Use Kubernetes Secrets
  prefs: []
  type: TYPE_NORMAL
- en: This approach is available directly in Kubernetes and provides an easy way to
    get started. The problem with this approach is that Kubernetes Secrets are not
    really secret. What we mean here is that Kubernetes Secrets look encrypted, but
    are actually just base64 encoded. This approach is also not recommended due to
    security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Use Sealed Secrets
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed Secrets is a project by Bitnami. It has two components: a cluster controller
    and a client-side tool call kubeseal. The kubeseal utility uses asymmetric crypto
    to encrypt secrets that only the controller can decrypt. These secrets can then
    be stored in Git encrypted and can only be decrypted by the controller in your
    cluster. This is a recommended approach for managing secrets in a GitOps way.'
  prefs: []
  type: TYPE_NORMAL
- en: Store secrets in a secret management tool
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows you to store secrets in a secure location and then access
    them from your cluster. These secrets can be stored in an external secret management
    solution like HashiCorp Vault, Azure Keyvault, Google KMS, etc. This approach
    allows you to use existing solutions you may already have in place and continue
    with the same workflow. This approach is also a recommended approach for managing
    secrets in a GitOps way.
  prefs: []
  type: TYPE_NORMAL
- en: While there are lot of different ways to manage secrets, the best approach will
    depend on your organization. As we discussed, Sealed Secrets and external secret
    management are the recommended approaches for managing secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Flux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flux is a Kubernetes operator that watches your Git repository for changes and
    automatically applies those changes to your cluster. Flux is a mature tool for
    implementing GitOps in your cluster, and it is the tool we will use throughout
    the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll start by getting minikube set up to deploy Flux. You can install
    minikube from the [minikube website](https://oreil.ly/GMPMl). We are using Macs
    so we’ll use `brew` to install minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now we’ll install Flux and prepare our cluster to sync to a Git repository.
    We’ll use the `flux` CLI to install Flux. You can install the `flux` CLI from
    the [flux website](https://oreil.ly/h2_hQ).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Flux CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Export your GitHub token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that your cluster can install Flux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Bootstrap Flux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `bootstrap` command will create a Git repo called kbp-flux in
    your GitHub account. It will also create a `main` branch and a *clusters/prod*
    directory. The *clusters/prod* directory will contain the Flux components that
    will be deployed to your cluster. The *clusters/prod* directory will also contain
    a *gotk-components.yaml* file that will be used to deploy the Flux components
    to your cluster. This also installs the Flux components into the `flux-system`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s check the `flux-system` namespace to see if the Flux components are
    deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s clone the repo it created to our local machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Next we’ll add a Flux configuration to our repo and use a public repository
    on GitHub. We’ll use a sample application created by Stefan Prodan from Weaveworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a Git repository manifest pointing to the apps repository’s main
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll configure Flux to deploy the application and apply a Kustomize configuration
    to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we’ll push the changes to our repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can seeing this being applied by using the Flux CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see the resources have been deployed to our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Any changes made to the podinfo Kubernetes manifests in the main branch are
    now reflected in your cluster automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We have now set up Flux in our cluster, bootstrapped it to a Git repository,
    and configured Flux to deploy an application. We can now start to use Flux to
    manage our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very basic example of how to get Flux set up, and if you want a deeper
    dive into Flux, you can check out the [Flux documentation](https://oreil.ly/F5D2p).
  prefs: []
  type: TYPE_NORMAL
- en: GitOps Tooling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many different tools can be used to implement GitOps in your cluster. In this
    section, we will go over some of the most popular.
  prefs: []
  type: TYPE_NORMAL
- en: 'When evaluating tools for GitOps, you should consider ease of use, enterprise
    features, and extensibility. Listed next are both open source and commercial tools
    that can be used to implement GitOps in your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: Flux
  prefs: []
  type: TYPE_NORMAL
- en: Flux is a Kubernetes operator that watches your Git repository for changes and
    automatically applies those changes to your cluster. Flux is a mature tool for
    implementing GitOps in your cluster. Weaveworks also provides a hosted version
    of Flux. Flux is currently a CNCF graduated project.
  prefs: []
  type: TYPE_NORMAL
- en: ArgoCD
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD is an open source GitOps continuous delivery tool. It monitors your
    cluster and your declaratively defined infrastructure stored in a Git repository
    and resolves differences between the two—effectively automating an application
    deployment. ArgoCD is currently a CNCF graduated project.
  prefs: []
  type: TYPE_NORMAL
- en: Codefresh
  prefs: []
  type: TYPE_NORMAL
- en: Codefresh is a CI/CD platform that can be used to implement GitOps in your cluster.
    Codefresh provides a hosted platform that provides ArgoCD as a service.
  prefs: []
  type: TYPE_NORMAL
- en: Harness
  prefs: []
  type: TYPE_NORMAL
- en: Harness is a CI/CD platform that can be used to implement GitOps in your cluster.
    Harness is a mature tool for implementing GitOps in your cluster and provides
    a hosted version. Harness is geared toward enterprise customers and provides a
    full suite of continuous delivery features.
  prefs: []
  type: TYPE_NORMAL
- en: GitOps Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Consider the following best practices when using GitOps with Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a small application and then scale your efforts for managing everything
    with a GitOps model. This will allow you to build confidence in your GitOps implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluate tools that fit your requirements or start with proven OSS tools like
    Flux or ArgoCD.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid using branches for your repository layout, as this is the most complex
    and error-prone repository layout.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start with a folder per environment, as this provides flexibility and allows
    you to use tools like Kustomize or Helm for templating.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize Sealed Secrets or an external secrets provider to manage secrets in
    your cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember GitOps is a process and not a tool, and your existing tool set may
    fit your needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we went over what GitOps is and how it can be used to manage
    your Kubernetes cluster. We also went over some of the tools that can be used
    to implement GitOps in your cluster. When looking to see if GitOps is right for
    you, you should consider what problems you are trying to solve and what your requirements
    are. If GitOps help solves these problems for you, then looking at a tool like
    Flux or ArgoCD is a good place to start.
  prefs: []
  type: TYPE_NORMAL
