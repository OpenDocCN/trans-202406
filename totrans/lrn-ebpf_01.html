<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. What Is eBPF, and Why Is It Important?" data-type="chapter" epub:type="chapter"><div class="chapter" id="what_is_ebpf_and_why_is_it_importantque">&#13;
  <h1><span class="label">Chapter 1. </span>What Is eBPF, and Why Is It Important?</h1>&#13;
  <p><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="basics" data-type="indexterm" id="ch01.html0"/>eBPF is a revolutionary kernel technology that allows developers to write custom code&#13;
    that can be loaded into the kernel dynamically, changing the way the kernel behaves. (Don’t worry if you’re not&#13;
    confident about what the kernel is—we’ll come to that shortly in this chapter.)</p>&#13;
  <p>This enables a new generation of highly performant networking, observability, and security tools. And as you’ll&#13;
    see, if you want to instrument an app with these eBPF-based tools, you don’t need to modify or reconfigure the app&#13;
    in any way, thanks to eBPF’s vantage point within the kernel.</p>&#13;
  <p>Just a few of the things you can do with eBPF include:</p>&#13;
  <ul>&#13;
    <li>&#13;
      <p>Performance tracing of pretty much any aspect of a system</p>&#13;
    </li>&#13;
    <li>&#13;
      <p>High-performance networking, with built-in visibility</p>&#13;
    </li>&#13;
    <li>&#13;
      <p>Detecting and (optionally) preventing malicious activity</p>&#13;
    </li>&#13;
  </ul>&#13;
  <p>Let’s take a brief journey through eBPF’s history, starting with the Berkeley Packet <span class="keep-together">Filter</span>.</p>&#13;
  <section data-pdf-bookmark="eBPF’s Roots: The Berkeley Packet Filter" data-type="sect1"><div class="sect1" id="ebpfapostrophes_roots_the_berkeley_pack">&#13;
    <h1>eBPF’s Roots: The Berkeley Packet Filter</h1>&#13;
    <p><a contenteditable="false" data-primary="Berkeley Packet Filter (BPF)" data-secondary="eBPF origins and" data-type="indexterm" id="idm46123214640560"/><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="Berkeley Packet Filter and" data-type="indexterm" id="idm46123214639168"/>What we call “eBPF” today has its&#13;
      roots in the BSD Packet Filter, first described in 1993 in a paper<sup><a data-type="noteref" href="ch01.html#ch01fn4" id="ch01fn4-marker">1</a></sup> written by Lawrence Berkeley National Laboratory’s <a contenteditable="false" data-primary="Jacobson, Van" data-type="indexterm" id="idm46123214698864"/><a contenteditable="false" data-primary="McCanne, Steven" data-type="indexterm" id="idm46123214697824"/>Steven McCanne and Van Jacobson. This paper&#13;
      discusses a pseudomachine that can run <span class="keep-together"><em>filters</em></span>, which are programs&#13;
      written to determine whether to accept or reject a network packet. These programs were written in the BPF&#13;
      instruction set, a general-purpose set of 32-bit instructions that closely resembles assembly language. Here’s an&#13;
      example taken directly from that paper:</p>&#13;
    <pre data-type="programlisting">ldh     [12] &#13;
jeq     #ETHERTYPE IP, L1, L2 &#13;
L1:     ret     #TRUE &#13;
L2:     ret     #0</pre>&#13;
    <p>This tiny piece of code filters out packets that aren’t Internet Protocol (IP) packets. The input to this filter&#13;
      is an Ethernet packet, and the first instruction (<code>ldh</code>) loads a 2-byte value starting at byte 12 in&#13;
      this packet. In the next instruction (<code>jeq</code>) that value is compared with the value that represents an&#13;
      IP packet. If it matches, execution jumps to the instruction labeled <code>L1</code>, and the packet is accepted&#13;
      by returning a nonzero value (identified here as <code>#TRUE</code>). If it doesn’t match, the packet is not an IP&#13;
      packet and is rejected by returning <code>0</code>.</p>&#13;
    <p>You can imagine (or, indeed, refer to the paper to find examples of) more complex filter programs that make&#13;
      decisions based on other aspects of the packet. Importantly, the author of the filter can write their own custom&#13;
      programs to be executed within the kernel, and this is the heart of what eBPF enables.</p>&#13;
    <p>BPF came to stand for “Berkeley Packet Filter,” and it was first introduced to Linux in 1997, in kernel version&#13;
      2.1.75,<sup><a data-type="noteref" href="ch01.html#ch01fn5" id="ch01fn5-marker">2</a></sup> where it was used&#13;
      in the tcpdump utility as an efficient way to capture the packets to be traced out.</p>&#13;
    <p><a contenteditable="false" data-primary="seccomp" data-secondary="introduction of" data-type="indexterm" id="idm46123214711808"/>Fast-forward to 2012, when seccomp-bpf was introduced in version 3.5 of the&#13;
      kernel. This enabled the use of BPF programs to make decisions about whether to allow or deny user space&#13;
      applications from making system calls. We’ll explore this in more detail in <a data-type="xref" href="ch10.html#ebpf_programming">Chapter 10</a>. This was the first step in evolving BPF from the narrow scope of&#13;
      packet filtering to the general-purpose platform it is today. From this point on, the words <em>packet filter</em>&#13;
      in the name started to make less sense!</p>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="From BPF to eBPF" data-type="sect1"><div class="sect1" id="from_bpf_to_ebpf">&#13;
    <h1>From BPF to eBPF</h1>&#13;
    <p><a contenteditable="false" data-primary="Berkeley Packet Filter (BPF)" data-secondary="evolution to eBPF" data-type="indexterm" id="idm46123214706960"/><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="evolution from BPF" data-type="indexterm" id="idm46123214705520"/>BPF evolved to what we call “extended BPF”&#13;
      or “eBPF” starting in kernel version 3.18 in 2014. This involved several significant changes:</p>&#13;
    <ul>&#13;
      <li>&#13;
        <p>The BPF instruction set was completely overhauled to be more efficient on 64-bit machines, and the&#13;
          interpreter was entirely rewritten.</p>&#13;
      </li>&#13;
      <li>&#13;
        <p>eBPF <em>maps</em> were introduced, which are data structures that can be accessed by BPF programs and by&#13;
          user space applications, allowing information to be shared between them. You’ll learn about maps in <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a>.</p>&#13;
      </li>&#13;
      <li>&#13;
        <p>The <code>bpf()</code> system call was added so that user space programs can interact with eBPF programs in&#13;
          the kernel. You’ll read about this system call in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>.</p>&#13;
      </li>&#13;
      <li>&#13;
        <p>Several BPF helper functions were added. You’ll see a few examples in <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a> and some more&#13;
          details in <a data-type="xref" href="ch06.html#the_ebpf_verifier">Chapter 6</a>.</p>&#13;
      </li>&#13;
      <li>&#13;
        <p>The eBPF verifier was added to ensure that eBPF programs are safe to run. This is discussed in <a data-type="xref" href="ch06.html#the_ebpf_verifier">Chapter 6</a>.</p>&#13;
      </li>&#13;
    </ul>&#13;
    <p>This put the basis for eBPF in place, but development did not slow down! Since then, eBPF has evolved&#13;
      significantly.</p>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="The Evolution of eBPF to Production Systems" data-type="sect1"><div class="sect1" id="the_evolution_of_ebpf_to_production_sys">&#13;
    <h1>The Evolution of eBPF to Production Systems</h1>&#13;
    <p><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="evolution to production systems" data-type="indexterm" id="ch01.html1"/><a contenteditable="false" data-primary="production systems, evolution of eBPF to" data-type="indexterm" id="ch01.html2"/>A <a contenteditable="false" data-primary="kprobes" data-secondary="origins" data-type="indexterm" id="idm46123211306624"/>feature&#13;
      called <em>kprobes</em> (kernel probes) had existed in the Linux kernel since 2005, allowing for traps to be set&#13;
      on almost any instruction in the kernel code. Developers could write kernel modules that attached functions to&#13;
      kprobes for debugging or performance measurement purposes.<sup><a data-type="noteref" href="ch01.html#ch01fn6" id="ch01fn6-marker">3</a></sup></p>&#13;
    <p>The ability to attach eBPF programs to kprobes was added in 2015, and this was the starting point for a&#13;
      revolution in the way tracing is done across Linux systems. At the same time, hooks started to be added within the&#13;
      kernel’s networking stack, allowing eBPF programs to take care of more aspects of networking functionality. We’ll&#13;
      see more of this in <a data-type="xref" href="ch08.html#ebpf_for_networking">Chapter 8</a>.</p>&#13;
    <p><a contenteditable="false" data-primary="Gregg, Brendan" data-type="indexterm" id="idm46123211301456"/>By 2016, eBPF-based&#13;
      tools were being used in production systems. <a href="https://www.brendangregg.com">Brendan Gregg’s</a> work on&#13;
      tracing at Netflix became widely known in infrastructure and operations circles, as did <a href="https://oreil.ly/stV6v">his statement</a> that eBPF “brings superpowers to Linux.” <a contenteditable="false" data-primary="Cilium" data-secondary="origins" data-type="indexterm" id="idm46123211298720"/>In the&#13;
      same year, the Cilium&#13;
      project was announced, being the first networking project to use eBPF to replace the entire datapath in container&#13;
      environments.</p>&#13;
    <p><a contenteditable="false" data-primary="Meta, Katran and" data-type="indexterm" id="idm46123211296928"/><a contenteditable="false" data-primary="Facebook, Katran and" data-type="indexterm" id="idm46123211295632"/><a contenteditable="false" data-primary="Katran" data-type="indexterm" id="idm46123214837152"/>The following year Facebook (now&#13;
      Meta) made <a href="https://oreil.ly/X-WsL">Katran</a> an open source project. Katran, a layer 4 load balancer,&#13;
      met Facebook’s need for a <a href="https://oreil.ly/zl4yX">highly scalable and fast solution</a>. Every single&#13;
      packet to <a href="http://Facebook.com">Facebook.com</a> since 2017 has passed through eBPF/XDP.<sup><a data-type="noteref" href="ch01.html#ch01fn7" id="ch01fn7-marker">4</a></sup> For me personally, this was the year that ignited my excitement about the&#13;
      possibilities enabled by this technology, after seeing <a href="https://oreil.ly/g9ya0">Thomas Graf’s talk</a>&#13;
      about eBPF and the <a href="https://oreil.ly/doKbd">Cilium project</a> at DockerCon in Austin, Texas.</p>&#13;
    <p><a contenteditable="false" data-primary="Borkmann, Daniel" data-type="indexterm" id="idm46123214830288"/><a contenteditable="false" data-primary="Nakryiko, Andrii" data-type="indexterm" id="idm46123214828960"/><a contenteditable="false" data-primary="Starovoitov, Alexei" data-type="indexterm" id="idm46123214827856"/>In 2018, eBPF became&#13;
      a separate subsystem within the Linux kernel, with <a href="http://borkmann.ch">Daniel Borkmann</a> from Isovalent&#13;
      and <a href="https://oreil.ly/K8nXI">Alexei Starovoitov</a> from Meta as its maintainers (they were later joined&#13;
      by <a href="https://nakryiko.com">Andrii Nakryiko</a>, also from Meta). <a contenteditable="false" data-primary="BTF (BPF Type Format)" data-secondary="introduction of" data-type="indexterm" id="idm46123214824560"/>The same&#13;
      year saw the introduction of BPF Type Format (BTF), which makes eBPF programs much more portable. We’ll explore&#13;
      this in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>.</p>&#13;
    <p><a contenteditable="false" data-primary="LSM (Linux Security Module)" data-secondary="LSM BPF" data-type="indexterm" id="idm46123214687568"/>The year 2020 saw the introduction of LSM BPF, allowing eBPF programs to be&#13;
      attached to the Linux Security Module (LSM) kernel interface. This indicated that a third major use case for eBPF&#13;
      had been identified: it became clear that eBPF is a great platform for security tooling, in addition to networking&#13;
      and observability.</p>&#13;
    <p>Over the years, eBPF’s capabilities have grown substantially, thanks to the work of more than 300 kernel&#13;
      developers and many contributors to the associated user space tools (such as <code>bpftool</code>, which we’ll&#13;
      meet in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>), compilers, and&#13;
      programming language libraries. <a contenteditable="false" data-primary="complexity limit" data-type="indexterm" id="idm46123214684064"/><a contenteditable="false" data-primary="instructions" data-secondary="complexity limit" data-type="indexterm" id="idm46123214682992"/>Programs were once limited to 4,096&#13;
      instructions, but that limit has grown to 1 million verified instructions<sup><a data-type="noteref" href="ch01.html#ch01fn9" id="ch01fn9-marker">5</a></sup> and has&#13;
      effectively been rendered irrelevant by support for tail calls and function calls (which you’ll see in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#anatomy_of_an_ebpf_program">3</a>).</p>&#13;
    <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
      <p>For deeper insight into the history of eBPF, who better to refer to than the maintainers who have been working&#13;
        on it from the <span class="keep-together">beginning</span>?</p>&#13;
      <p>Alexei Starovoitov gave a fascinating presentation about the <a href="https://youtu.be/DAvZH13725I">history of&#13;
          BPF</a> from its roots in software-defined networking (SDN). In this talk, he discusses the strategies used to&#13;
        get the early eBPF patches accepted into the kernel and reveals that the official birthday of eBPF is September&#13;
        26, 2014, which marked the acceptance of the first set of patches covering the verifier, BPF system call, and&#13;
        maps.</p>&#13;
      <p>Daniel Borkmann has also discussed the history of BPF and its evolution to support networking and tracing&#13;
        functionality. I highly recommend his talk <a href="https://youtu.be/99jUcLt3rSk">“eBPF and Kubernetes: Little&#13;
          Helper Minions for Scaling Microservices”</a>, which is full of interesting nuggets of information.<a contenteditable="false" data-primary="" data-startref="ch01.html2" data-type="indexterm" id="idm46123214323264"/><a contenteditable="false" data-primary="" data-startref="ch01.html1" data-type="indexterm" id="idm46123214321824"/></p>&#13;
    </div>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="Naming Is Hard" data-type="sect1"><div class="sect1" id="naming_is_hard">&#13;
    <h1>Naming Is Hard</h1>&#13;
    <p><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="terminology" data-type="indexterm" id="idm46123214318240"/>eBPF’s applications range so far beyond packet filtering that the acronym is&#13;
      essentially meaningless now, and it has become a standalone term. And since the Linux kernels in widespread use&#13;
      these days all have support for the “extended” parts, the terms <em>eBPF</em> and <em>BPF</em> are largely used&#13;
      interchangeably. In the kernel source code and in eBPF programming, the common terminology is <em>BPF</em>. For&#13;
      example, as we’ll see in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>, the system call&#13;
      for interacting with eBPF is <code>bpf()</code>, helper functions start with <code>bpf_</code>, and the different&#13;
      types of (e)BPF programs are identified with names that start with <code>BPF_PROG_TYPE</code>. Outside the kernel&#13;
      community, the name “eBPF” seems to have stuck, for example, in the community site <a href="https://ebpf.io">ebpf.io</a> and in the name of the <a href="http://ebpf.foundation">eBPF Foundation</a>.&#13;
    </p>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="The Linux Kernel" data-type="sect1"><div class="sect1" id="the_linux_kernel">&#13;
    <h1>The Linux Kernel</h1>&#13;
    <p><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="Linux kernel and" data-type="indexterm" id="ch01.html3"/><a contenteditable="false" data-primary="kernel" data-secondary="basics" data-type="indexterm" id="ch01.html4"/>To understand eBPF you’ll need a solid&#13;
      grasp of the difference between the kernel and user space in Linux. I covered this in my report “What Is&#13;
      eBPF?”<sup><a data-type="noteref" href="ch01.html#ch01fn10" id="ch01fn10-marker">6</a></sup> and I’ve adapted some of that content for the next few paragraphs.</p>&#13;
    <p><a contenteditable="false" data-primary="kernel" data-secondary="defined" data-type="indexterm" id="idm46123211462848"/>The&#13;
      Linux kernel is the software layer between your applications and the hardware they’re running on. <a contenteditable="false" data-primary="user space" data-secondary="and kernel" data-secondary-sortas="kernel" data-type="indexterm" id="idm46123211461216"/>Applications run in an unprivileged layer called <em>user space</em>,&#13;
      which can’t access hardware directly. <a contenteditable="false" data-primary="system calls" data-secondary="Linux kernel and" data-type="indexterm" id="idm46123211458960"/>Instead, an application makes requests using&#13;
      the system call (syscall) interface to request the kernel to act on its behalf. That hardware access can involve&#13;
      reading and writing to files, sending or receiving network traffic, or even just accessing memory. The kernel is&#13;
      also responsible for coordinating concurrent processes, enabling many applications to run at once. This is&#13;
      illustrated in <a data-type="xref" href="#applications_in_user_space_use_the_sysc">Figure 1-1</a>.</p>&#13;
    <p>As application developers, we typically don’t use the system call interface directly, because programming&#13;
      languages give us high-level abstractions and standard libraries that are easier interfaces to program. As a&#13;
      result, a lot of people are blissfully unaware of how much the kernel is doing while our programs run. If you want&#13;
      to get a sense of how often the kernel is invoked, you can use the <code>strace</code> utility to show all the&#13;
      system calls an application makes.</p>&#13;
    <figure><div class="figure" id="applications_in_user_space_use_the_sysc">&#13;
      <img alt="Applications in user space use the syscall interface to make requests to the kernel" src="assets/lebp_0101.png"/>&#13;
      <h6><span class="label">Figure 1-1. </span>Applications in user space use the syscall interface to make requests to the kernel</h6>&#13;
    </div></figure>&#13;
    <p>Here’s an example, where using <code>cat</code> to echo the word <em>hello</em> to the screen involves more than&#13;
      100 system calls:</p>&#13;
    <pre data-type="programlisting">$ strace -c echo "hello"&#13;
hello&#13;
% time     seconds  usecs/call     calls    errors syscall&#13;
------ ----------- ----------- --------- --------- ----------------&#13;
 24.62    0.001693          56        30        12 openat&#13;
 17.49    0.001203          60        20           mmap&#13;
 15.92    0.001095          57        19           newfstatat&#13;
 15.66    0.001077          53        20           close&#13;
 10.35    0.000712         712         1           execve&#13;
  3.04    0.000209          52         4           mprotect&#13;
  2.52    0.000173          57         3           read&#13;
  2.33    0.000160          53         3           brk&#13;
  2.09    0.000144          48         3           munmap&#13;
  1.11    0.000076          76         1           write&#13;
  0.96    0.000066          66         1         1 faccessat&#13;
  0.76    0.000052          52         1           getrandom&#13;
  0.68    0.000047          47         1           rseq&#13;
  0.65    0.000045          45         1           set_robust_list&#13;
  0.63    0.000043          43         1           prlimit64&#13;
  0.61    0.000042          42         1           set_tid_address&#13;
  0.58    0.000040          40         1           futex&#13;
------ ----------- ----------- --------- --------- ----------------&#13;
100.00    0.006877          61       111        13 total</pre>&#13;
    <p>Because applications rely so heavily on the kernel, it means we can learn a lot about how an application behaves&#13;
      if we can observe its interactions with the kernel. With eBPF we can add instrumentation into the kernel to get&#13;
      these insights.</p>&#13;
    <p>For example, if you are able to intercept the system call for opening files, you can see exactly which files any&#13;
      application accesses. But how could you do that interception? Let’s consider what would be involved if we wanted&#13;
      to modify the kernel, adding new code to create some kind of output whenever that system call is invoked.<a contenteditable="false" data-primary="" data-startref="ch01.html4" data-type="indexterm" id="idm46123214463520"/><a contenteditable="false" data-primary="" data-startref="ch01.html3" data-type="indexterm" id="idm46123214462144"/></p>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="Adding New Functionality to the Kernel" data-type="sect1"><div class="sect1" id="adding_new_functionality_to_the_kernel">&#13;
    <h1>Adding New Functionality to the Kernel</h1>&#13;
    <p><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="adding new functionality to kernel" data-type="indexterm" id="ch01.html5"/><a contenteditable="false" data-primary="kernel" data-secondary="adding new functionality to" data-type="indexterm" id="ch01.html6"/>The Linux kernel is&#13;
      complex, with around 30 million lines of code at the time of this writing.<sup><a data-type="noteref" href="ch01.html#ch01fn11" id="ch01fn11-marker">7</a></sup> Making a change to any codebase requires some familiarity with the&#13;
      existing code, so unless you’re a kernel developer already, this is likely to present a challenge.</p>&#13;
    <p>Additionally, if you want to contribute your change upstream, you’ll be facing a challenge that isn’t purely&#13;
      technical. Linux is a general-purpose operating system, used in all manner of environments and circumstances. This&#13;
      means that if you want your change to become part of an official Linux release, it’s not simply a matter of&#13;
      writing code that works. The code has to be accepted by the community (and more specifically by Linus Torvalds,&#13;
      creator and main developer of Linux) as a change that will be for the greater good of all. This isn’t a given—only&#13;
      one-third of submitted kernel patches are accepted.<sup><a data-type="noteref" href="ch01.html#ch01fn12" id="ch01fn12-marker">8</a></sup></p>&#13;
    <p>Let’s suppose you’ve figured out a good technical approach for intercepting the system call for opening files.&#13;
      After some months of discussion and some hard development work on your part, let’s imagine the change is accepted&#13;
      into the kernel. Great! But how long will it be until it arrives on everyone’s machines?</p>&#13;
    <p>There’s a new release of the Linux kernel every two or three months, but even when a change has made it into one&#13;
      of these releases, it’s still some time away from being available in most people’s production environments. This&#13;
      is because most of us don’t just use the Linux kernel directly—we use Linux distributions like Debian, Red Hat,&#13;
      Alpine, and Ubuntu that package up a version of the Linux kernel with various other components. You may well find&#13;
      that your favorite distribution is using a kernel release that’s several years old.</p>&#13;
    <p><a contenteditable="false" data-primary="Red Hat Enterprise Linux (RHEL)" data-type="indexterm" id="idm46123211569376"/><a contenteditable="false" data-primary="RHEL (Red Hat Enterprise Linux)" data-type="indexterm" id="idm46123211568208"/>For&#13;
      example, a lot of enterprise users employ Red Hat Enterprise Linux (RHEL). At the time of this writing, the&#13;
      current release is RHEL 8.5, dated November 2021, and it uses version 4.18 of the Linux kernel. This kernel was&#13;
      released in August 2018.</p>&#13;
    <p>As illustrated in the cartoon in <a data-type="xref" href="#adding_features_to_the_kernel_left_pare">Figure 1-2</a>, it takes literally&#13;
      years to get new functionality from the idea stage into a production environment Linux kernel.<sup><a data-type="noteref" href="ch01.html#ch01fn13" id="ch01fn13-marker">9</a></sup></p>&#13;
    <figure><div class="figure" id="adding_features_to_the_kernel_left_pare">&#13;
      <img alt="Adding features to the kernel (cartoon by Vadim Shchekoldin, Isovalent)" src="assets/lebp_0102.png"/>&#13;
      <h6><span class="label">Figure 1-2. </span>Adding features to the kernel (cartoon by Vadim Shchekoldin, Isovalent)</h6>&#13;
    </div></figure>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="Kernel Modules" data-type="sect1"><div class="sect1" id="kernel_modules">&#13;
    <h1>Kernel Modules</h1>&#13;
    <p><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="kernel modules" data-type="indexterm" id="idm46123214818368"/><a contenteditable="false" data-primary="kernel modules" data-type="indexterm" id="idm46123214816992"/><a contenteditable="false" data-primary="modules, kernel" data-type="indexterm" id="idm46123214815888"/>If you don’t want to wait years for your change to make it into the kernel,&#13;
      there is another option. The Linux kernel was designed to accept kernel modules, which can be loaded and unloaded&#13;
      on demand. If you want to change or extend kernel behavior, writing a module is certainly one way to do it. A&#13;
      kernel module can be distributed for others to use independent of the official Linux kernel release, so it doesn’t&#13;
      have to be accepted into the main upstream codebase.</p>&#13;
    <p>The biggest challenge here is that this is still full-on kernel programming. Users have historically been very&#13;
      cautious about using kernel modules, for one simple reason: if kernel code crashes, it takes down the machine and&#13;
      everything running on it. How can a user be confident that a kernel module is safe to run?</p>&#13;
    <p class="pagebreak-before">Being “safe to run” doesn’t just mean not crashing—the user wants to know that a kernel&#13;
      module is safe from a security perspective. Does it include vulnerabilities that an attacker could exploit? Do we&#13;
      trust the authors of the module not to put malicious code in it? Because the kernel is privileged code, it has&#13;
      access to everything on the machine, including all the data, so malicious code in the kernel would be a serious&#13;
      cause for concern. This applies to kernel modules too.</p>&#13;
    <p>The safety of the kernel is one important reason why Linux distributions take so long to incorporate new&#13;
      releases. If other people have been running a kernel version in a variety of circumstances for months or years,&#13;
      this should have flushed out issues. The distribution maintainers can have some confidence that the kernel they&#13;
      ship to their users/customers is <em>hardened</em>—that is, it is safe to run.</p>&#13;
    <p>eBPF offers a very different approach to safety: the <em>eBPF verifier</em>, which ensures that an eBPF program&#13;
      is loaded only if it’s safe to run—it won’t crash the machine or lock it up in a hard loop, and it won’t allow&#13;
      data to be compromised. We’ll discuss the verification process in more detail in <a data-type="xref" href="ch06.html#the_ebpf_verifier">Chapter 6</a>.</p>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="Dynamic Loading of eBPF Programs" data-type="sect1"><div class="sect1" id="dynamic_loading_of_ebpf_programs">&#13;
    <h1>Dynamic Loading of eBPF Programs</h1>&#13;
    <p><a contenteditable="false" data-primary="dynamic loading" data-type="indexterm" id="idm46123214809056"/><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="dynamic loading of eBPF programs" data-type="indexterm" id="idm46123214807952"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="dynamic loading" data-type="indexterm" id="idm46123214806512"/>eBPF programs can be loaded into and removed&#13;
      from the kernel dynamically. Once they are attached to an event, they’ll be triggered by that event regardless of&#13;
      what caused that event to occur. For example, if you attach a program to the syscall for opening files, it will be&#13;
      triggered whenever any process tries to open a file. It doesn’t matter whether that process was already running&#13;
      when the program was loaded. This is a huge advantage compared to upgrading the kernel and then having to reboot&#13;
      the machine to use its new functionality.</p>&#13;
    <p>This leads to one of the great strengths of observability or security tooling that uses eBPF—it instantly gets&#13;
      visibility over everything that’s happening on the machine. In environments running containers, that includes&#13;
      visibility over all processes running inside those containers as well as on the host machine. I’ll dig into the&#13;
      consequences of this for cloud native deployments later in this chapter.</p>&#13;
    <p>Additionally, as illustrated in <a data-type="xref" href="#adding_kernel_features_with_ebpf_left_p">Figure 1-3</a>, people can create&#13;
      new kernel functionality very quickly through eBPF without requiring every other Linux user to accept the same&#13;
      changes.</p>&#13;
    <figure class="width-75"><div class="figure" id="adding_kernel_features_with_ebpf_left_p">&#13;
      <img alt="Adding kernel features with eBPF (cartoon by Vadim Shchekoldin, Isovalent)" src="assets/lebp_0103.png"/>&#13;
      <h6><span class="label">Figure 1-3. </span>Adding kernel features with eBPF (cartoon by Vadim Shchekoldin, Isovalent)</h6>&#13;
    </div></figure>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="High Performance of eBPF Programs" data-type="sect1"><div class="sect1" id="high_performance_of_ebpf_programs">&#13;
    <h1>High Performance of eBPF Programs</h1>&#13;
    <p><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="high performance of eBPF programs" data-type="indexterm" id="idm46123214451664"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="high performance of" data-type="indexterm" id="idm46123214450128"/>eBPF programs are a very efficient way to&#13;
      add instrumentation. Once loaded and JIT-compiled (which you’ll see in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>), the program runs as native machine&#13;
      instructions on the CPU. Additionally, there’s no need to incur the cost of transitioning between kernel and user&#13;
      space (which is an expensive operation) to handle each event.</p>&#13;
    <p>The 2018 paper<sup><a data-type="noteref" href="ch01.html#ch01fn14" id="ch01fn14-marker">10</a></sup> that describes the eXpress Data Path (XDP) includes&#13;
      some illustrations of the kinds of performance improvements eBPF enables in networking. For example, implementing&#13;
      routing in XDP “improves performance with a factor of 2.5” compared to the regular Linux kernel implementation,&#13;
      and “XDP offers a performance gain of 4.3x over IPVS” for load balancing.</p>&#13;
    <p>For performance tracing and security observability, another advantage of eBPF is that relevant events can be&#13;
      filtered within the kernel before incurring the costs of sending them to user space. Filtering only certain&#13;
      network packets was, after all, the point of the original BPF implementation. Today eBPF programs can collect&#13;
      information about all manner of events across a system, and they can use complex, customized programmatic filters&#13;
      to send only the relevant subset of information to user space.</p>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="eBPF in Cloud Native Environments" data-type="sect1"><div class="sect1" id="ebpf_in_cloud_native_environments">&#13;
    <h1>eBPF in Cloud Native Environments</h1>&#13;
    <p><a contenteditable="false" data-primary="cloud native environments" data-type="indexterm" id="ch01.html7"/><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="cloud native environments and" data-type="indexterm" id="ch01.html8"/>These days lots&#13;
      of organizations choose not to run applications by executing programs directly on servers. Instead, many use cloud&#13;
      native approaches: containers, orchestrators such as Kubernetes or ECS, or serverless approaches like Lambda,&#13;
      cloud functions, Fargate, and so on. These approaches all use automation to choose the server where each workload&#13;
      will run; in serverless, we’re not even aware what server is running each workload.</p>&#13;
    <p>Nevertheless, there are servers involved, and each of those servers (whether it’s a virtual machine or bare-metal&#13;
      machine) runs a kernel. Where applications run in a container, if they’re running on the same (virtual) machine,&#13;
      they share the same kernel. In a Kubernetes environment, this means all the containers in all the pods on a given&#13;
      node are using the same kernel. When we instrument that kernel with eBPF programs, all the containerized workloads&#13;
      on that node are visible to those eBPF programs, as illustrated in <a data-type="xref" href="#ebpf_programs_in_the_kernel_have_visibi">Figure 1-4</a>.</p>&#13;
    <figure><div class="figure" id="ebpf_programs_in_the_kernel_have_visibi">&#13;
      <img alt="eBPF programs in the kernel have visibility of all applications running on a Kubernetes node" src="assets/lebp_0104.png"/>&#13;
      <h6><span class="label">Figure 1-4. </span>eBPF programs in the kernel have visibility of all applications running on a Kubernetes node&#13;
      </h6>&#13;
    </div></figure>&#13;
    <p>Visibility of all the processes on the node, combined with the ability to load eBPF programs dynamically, gives&#13;
      us the real superpowers of eBPF-based tooling in cloud native computing:</p>&#13;
    <ul>&#13;
      <li>&#13;
        <p>We don’t need to change our applications, or even the way they are configured, to instrument them with eBPF&#13;
          tooling.</p>&#13;
      </li>&#13;
      <li>&#13;
        <p>As soon as it’s loaded into the kernel and attached to an event, an eBPF program can start observing&#13;
          preexisting application processes.</p>&#13;
      </li>&#13;
    </ul>&#13;
    <p><a contenteditable="false" data-primary="sidecar model" data-type="indexterm" id="ch01.html9"/><a contenteditable="false" data-primary="Kubernetes" data-secondary="sidecar model" data-type="indexterm" id="idm46123214668640"/>Contrast this with the <em>sidecar model</em>, which has been used to&#13;
      add functionality like logging, tracing, security, and service mesh functionality into Kubernetes apps. In the&#13;
      sidecar approach, the instrumentation runs as a container that is “injected” into each application pod. This&#13;
      process involves modifying the YAML that defines the application pods, adding in the definition of the sidecar&#13;
      container. This approach is certainly more convenient than adding the instrumentation into the source code of the&#13;
      application (which is what we had to do before the sidecar approach; for example, including a logging library in&#13;
      our application and making calls into that library at appropriate points in the code). Nevertheless, the sidecar&#13;
      approach has a few <span class="keep-together">downsides</span>:</p>&#13;
    <ul>&#13;
      <li>&#13;
        <p>The application pod has to be restarted for the sidecar to be added.</p>&#13;
      </li>&#13;
      <li>&#13;
        <p>Something has to modify the application YAML. This is generally an automated process, but if something goes&#13;
          wrong, the sidecar won’t be added, which means the pod doesn’t get instrumented. For example, a deployment&#13;
          might be annotated to indicate that an admission controller should add the sidecar YAML to the pod spec for&#13;
          that deployment. But if the deployment isn’t labeled correctly, the sidecar won’t get added, and it’s&#13;
          therefore not visible to the instrumentation.</p>&#13;
      </li>&#13;
      <li>&#13;
        <p>When there are multiple containers within a pod, they might reach readiness at different times, the ordering&#13;
          of which may not be predictable. Pod start-up time can be significantly slowed by the injection of sidecars,&#13;
          or worse, it can cause race conditions or other instabilities. For example, the <a href="https://oreil.ly/z80Q5">Open Service Mesh documentation</a> describes how application containers have&#13;
          to be resilient to all traffic being dropped until the Envoy proxy container is ready.</p>&#13;
      </li>&#13;
      <li>&#13;
        <p>Where networking functionality such as service mesh is implemented as a sidecar, it necessarily means that&#13;
          all traffic to and from the application container has to travel through the network stack in the kernel to&#13;
          reach a network proxy container, adding latency to that traffic; this is illustrated in <a data-type="xref" href="#path_of_a_network_packet_using_a_networ">Figure 1-5</a>. We’ll talk&#13;
          about improving network efficiency with eBPF in <a data-type="xref" href="ch09.html#ebpf_for_security">Chapter 9</a>.</p>&#13;
      </li>&#13;
    </ul>&#13;
    <figure><div class="figure" id="path_of_a_network_packet_using_a_networ">&#13;
      <img alt="Path of a network packet using a service mesh proxy sidecar container" src="assets/lebp_0105.png"/>&#13;
      <h6><span class="label">Figure 1-5. </span>Path of a network packet using a service mesh proxy sidecar container</h6>&#13;
    </div></figure>&#13;
    <p>All these issues are inherent problems with the sidecar model. Fortunately, now that eBPF is available as a&#13;
      platform, we have a new model that can avoid these issues. Additionally, because eBPF-based tools can see&#13;
      everything that’s happening on a (virtual) machine, they are harder for bad actors to sidestep. For example, if an&#13;
      attacker manages to deploy a cryptocurrency mining app on one of your hosts, they probably won’t do you the&#13;
      courtesy of instrumenting it with the sidecars you’re using on your application workloads. If you’re relying on a&#13;
      sidecar-based security tool to prevent apps from making unexpected network connections, that tool isn’t going to&#13;
      spot the mining app connecting to its mining pool if the sidecar isn’t injected. In contrast, network security&#13;
      implemented in eBPF can police all traffic on the host machine, so this cryptocurrency mining operation could&#13;
      easily be stopped. The ability to drop network packets for security reasons is something we’ll come back to in <a data-type="xref" href="ch08.html#ebpf_for_networking">Chapter 8</a><a contenteditable="false" data-primary="" data-startref="ch01.html9" data-type="indexterm" id="idm46123213506368"/>.<a contenteditable="false" data-primary="" data-startref="ch01.html8" data-type="indexterm" id="idm46123213504864"/><a contenteditable="false" data-primary="" data-startref="ch01.html7" data-type="indexterm" id="idm46123213503456"/></p>&#13;
  </div></section>&#13;
  <section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000010">&#13;
    <h1>Summary</h1>&#13;
    <p>I hope this chapter has given you some insight into why eBPF as a platform is so powerful. It allows us to change&#13;
      the behavior of the kernel, providing us the flexibility to build bespoke tools or customized policies. eBPF-based&#13;
      tools can observe any event across the kernel, and hence across all applications running on a (virtual) machine,&#13;
      whether they are containerized or not. eBPF programs can also be deployed dynamically, allowing behavior to be&#13;
      changed on the fly.</p>&#13;
    <p>So far we’ve discussed eBPF at a relatively conceptual level. In the next chapter we’ll make it more concrete and&#13;
      explore the constituent parts of an eBPF-based <span class="keep-together">application</span>.<a contenteditable="false" data-primary="" data-startref="ch01.html0" data-type="indexterm" id="idm46123213498704"/><a contenteditable="false" data-primary="BPF Type Format (BTF)" data-see="BTF" data-type="indexterm" id="idm46123213497296"/><a contenteditable="false" data-primary="BSD Packet Filter" data-see="Berkeley Packet Filter" data-type="indexterm" id="idm46123213495920"/><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="programs" data-see="programs, eBPF" data-type="indexterm" id="idm46123213494544"/><a contenteditable="false" data-primary="eBPF (generally)" data-secondary="virtual machine" data-see="virtual machine" data-type="indexterm" id="idm46123213492896"/><a contenteditable="false" data-primary="Linux kernel" data-see="kernel" data-type="indexterm" id="idm46123213491248"/><a contenteditable="false" data-primary="portability" data-see="CO-RE" data-type="indexterm" id="idm46123213489872"/><a contenteditable="false" data-primary="system calls" data-secondary="bpf()" data-see="bpf() system calls" data-type="indexterm" id="idm46123213488496"/><a contenteditable="false" data-primary="TC" data-see="traffic control" data-type="indexterm" id="idm46123210557712"/><a contenteditable="false" data-primary="Tetragon" data-see="Cilium Tetragon" data-type="indexterm" id="idm46123210556336"/></p>&#13;
  </div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch01fn4"><sup><a href="ch01.html#ch01fn4-marker">1</a></sup> <a href="https://oreil.ly/4GpgQ">“The BSD Packet Filter: A New Architecture for User-level Packet Capture”</a> by&#13;
        Steven McCanne and Van Jacobson.</p><p data-type="footnote" id="ch01fn5"><sup><a href="ch01.html#ch01fn5-marker">2</a></sup> These and other details come from Alexei Starovoitov’s 2015 NetDev&#13;
        presentation, <a href="https://oreil.ly/hISe1">“BPF – in-kernel virtual machine”</a>.</p><p data-type="footnote" id="ch01fn6"><sup><a href="ch01.html#ch01fn6-marker">3</a></sup> There is a good&#13;
        description of how kprobes work in <a href="https://oreil.ly/Ue6Ii">the kernel documentation</a>.</p><p data-type="footnote" id="ch01fn7"><sup><a href="ch01.html#ch01fn7-marker">4</a></sup> This wonderful fact comes from Daniel Borkmann’s KubeCon 2020 talk titled <a href="https://oreil.ly/tIR9o">“eBPF and Kubernetes: Little Helper Minions for Scaling&#13;
          Microservices”</a>.</p><p data-type="footnote" id="ch01fn9"><sup><a href="ch01.html#ch01fn9-marker">5</a></sup> For more details on the instruction limit and “complexity limit,” see <a href="https://oreil.ly/0iVer"><em class="hyperlink">https://oreil.ly/0iVer</em></a>.</p><p data-type="footnote" id="ch01fn10"><sup><a href="ch01.html#ch01fn10-marker">6</a></sup> Extract from “What Is eBPF?” by Liz Rice. Copyright © 2022 O’Reilly&#13;
        Media. Used with permission.</p><p data-type="footnote" id="ch01fn11"><sup><a href="ch01.html#ch01fn11-marker">7</a></sup> <a href="https://oreil.ly/9zJP2">“Linux 5.12 Coming In At Around 28.8 Million Lines”</a>.&#13;
        Phoronix, March 2021.</p><p data-type="footnote" id="ch01fn12"><sup><a href="ch01.html#ch01fn12-marker">8</a></sup> Jiang Y, Adams B,&#13;
        German DM. 2013. <a href="https://oreil.ly/rj2P4">“Will My Patch Make It? And How Fast?”</a> (2013). According&#13;
        to this research paper, 33% of patches are accepted, and most take three to six months.</p><p data-type="footnote" id="ch01fn13"><sup><a href="ch01.html#ch01fn13-marker">9</a></sup> Thankfully, security patches to existing functionality are made available&#13;
        more quickly.<a contenteditable="false" data-primary="" data-startref="ch01.html6" data-type="indexterm" id="idm46123211564432"/><a contenteditable="false" data-primary="" data-startref="ch01.html5" data-type="indexterm" id="idm46123211563056"/></p><p data-type="footnote" id="ch01fn14"><sup><a href="ch01.html#ch01fn14-marker">10</a></sup> Høiland-Jørgensen T, Brouer JD, Borkmann D, et al. <a href="https://oreil.ly/qyhLK">“The&#13;
          eXpress data path: fast programmable packet processing in the operating system kernel”</a>. <em>Proceedings of&#13;
          the&#13;
          14th International Conference on emerging Networking EXperiments and Technologies</em> (CoNEXT ’18).&#13;
        Association for&#13;
        Computing Machinery; 2018:54–66.</p></div></div></section></body></html>