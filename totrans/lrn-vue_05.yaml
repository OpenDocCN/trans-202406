- en: Chapter 5\. Composition API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. 组合 API
- en: In the previous chapter, you learned how to compose Vue components using the
    classic Options API. Despite it being the most common API for composing Vue components
    since Vue 2, using Options API can lead to unnecessary code complexity, unreadability
    for large component code, and logic reusability between them. For such use cases,
    this chapter introduces an alternative approach for composing Vue components,
    the Composition API.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您已经学习了如何使用经典的 Options API 组合 Vue 组件。尽管 Options API 自 Vue 2 以来一直是组合 Vue
    组件最常见的 API，但使用 Options API 可能会导致不必要的代码复杂性、大型组件代码的不可读性以及它们之间逻辑重用的问题。针对这些用例，本章介绍了组合
    Vue 组件的另一种方法，即组合 API。
- en: In this chapter, we will explore the different composition hooks to create a
    functional stateful element in Vue. We also will learn how to combine Options
    API and Composition API for better reactive control and to compose our own reusable
    composable for our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索不同的组合挂钩，以创建 Vue 中的功能状态元素。我们还将学习如何结合 Options API 和组合 API，以获得更好的响应控制，并为应用程序组合我们自己可重用的组合物。
- en: Setting Up Components with Composition API
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组合 API 设置组件
- en: Composing components using the Options API is a common practice in Vue. However,
    in many cases, we want to reuse part of the component logic without worrying about
    the overlapping data and methods like in mixins^([1](ch05.html#id998)), or a component
    that is more readable and organized. Composition API can be helpful in such scenarios.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Vue 中，使用 Options API 组合组件是一种常见的实践。然而，在许多情况下，我们希望重用部分组件逻辑，而不必担心数据和方法的重叠，如混入（见
    [第5章](ch05.html#id998)）。组合 API 在这种情况下非常有帮助。
- en: Introduced in Vue 3.0, Composition API provides an alternative way to compose
    stateful and reactive components with the help of the `setup()` hook ([“setup”](ch03.html#setup_hook_03))
    or `<script setup>` tag. The `setup()` hook is part of the component’s options
    object and runs *once* before initializing and creating the component instance
    (before `beforeCreate()` hook).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 组合 API 是在 Vue 3.0 中引入的，它提供了一种用 `setup()` 挂钩（[“setup”](ch03.html#setup_hook_03)）或
    `<script setup>` 标记初始化和创建组件实例之前运行 *一次* 的替代方式，用于组合有状态和响应式组件。
- en: You can *only* use Composition API functions or composables ([“Creating Your
    Reusable Composables”](#reusable_hooks_06)) within this hook or its equivalent
    syntax `<script setup>` tag. This combination creates a stateful functional component
    and provides an excellent place to define the component’s reactive state and methods
    and initialize other lifecycle hooks (see [“Using the Lifecycle Hooks”](#lifecycle_hooks_03))
    with more straightforward code readability.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 您*只能*在此挂钩或其等效语法 `<script setup>` 标记中使用组合 API 函数或可组合物（[“创建可重用的组合物”](#reusable_hooks_06)）。这种组合创建了一个有状态的功能性组件，并提供了一个绝佳的地方来定义组件的响应状态和方法，并初始化其他生命周期挂钩（参见
    [“使用生命周期挂钩”](#lifecycle_hooks_03)），使代码更易读。
- en: Let’s explore the power of Composition API, starting with `ref()` and `reactive()`
    functions to handle your component’s reactive data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索组合 API 的强大之处，从使用 `ref()` 和 `reactive()` 函数处理组件的响应数据开始。
- en: Handling Data with ref() and reactive()
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `ref()` 和 `reactive()` 处理数据
- en: In [Chapter 2](ch02.html#unique_chapter_id_02), you learned about the `data()`
    function property in the Options API for initializing the component’s data ([“Creating
    Local State with Data Properties”](ch02.html#local_state)). All the data properties
    in the returned object from `data()` are reactive, meaning the Vue engine will
    automatically watch for changes on each declared data property. However, this
    default functionality may cause overhead in your component when you have many
    data properties, most of which are static. In such cases, the Vue engine still
    enables watchers for these static values, which is unnecessary. To limit the number
    of excessive data watchers and to have more control over which data properties
    to observe, Vue introduced the `ref()` and `reactive()` functions in the Composition
    API.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第2章](ch02.html#unique_chapter_id_02) 中，您学习了 Options API 中的 `data()` 函数属性，用于初始化组件的数据（[“使用数据属性创建本地状态”](ch02.html#local_state)）。从
    `data()` 返回的所有数据属性都是响应式的，这意味着 Vue 引擎会自动监视每个声明的数据属性的更改。然而，默认功能可能会在组件中造成过多的开销，特别是当您有许多静态数据属性时。在这种情况下，Vue
    引擎仍会为这些静态值启用观察器，这是不必要的。为了限制过多的数据观察器数量并更好地控制要观察的数据属性，Vue 在组合 API 中引入了 `ref()` 和
    `reactive()` 函数。
- en: Using ref()
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `ref()`
- en: '`ref()` is a function that accepts a single argument and returns a reactive
    object with that argument as its initial value. We call this returned object the
    `ref` object:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or in `<script setup>`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We then can access the return object’s current value through its single `value`
    property within the `script` section. For example, the code in [Example 5-1](#example_01_06)
    creates a reactive object with the initial value of 0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Using `ref()` to create a reactive message with an initial value
    of “Hello World”
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use Options API with `setup()` hook, you can access `message` in other
    part of component’s without `.value`, i.e., `message` is sufficient.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: However, in the `template` tag section, you can retrieve its value directly
    without the `value` property. For example, the code in [Example 5-2](#example_02_06)
    will print the same `message` as [Example 5-1](#example_01_06), but to the browser.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. Accessing `message` value in the `template` section
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `ref()` function infers types for the return object from the initial value
    passed. If you explicitly want to define the type of the return object, you can
    use the TypeScript syntax `ref<type>()`, such as `ref<string>()`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Since the ref object is reactive and mutable, we can change its value by assigning
    a new value to its `value` property. The Vue engine then will trigger the relevant
    watchers and update the component.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 5-3](#example_03_06), we will re-create the `MyMessageComponent`
    (from [Example 3-3](ch03.html#example_03_03) with Options API), which accepts
    input from the user and changes the `message` displayed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Using `ref()` to create a reactive `MyMessageComponent`
  id: totrans-27
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When we change the input field’s value, the browser will show the updated `message`
    value accordingly, as shown in [Figure 5-1](#figure_06_03_06).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the browser showing the updated message value](assets/lvue_0501.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. The value displayed changes when we change the input field’s value
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the Vue tab of the browser’s Developer Tools, we can see ref object `message`
    listed under the `setup` section, with the indication `Ref` ([Figure 5-2](#figure_05_06a)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the browser''s Vue tab showing the ref object](assets/lvue_0502.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. The `message` ref object is listed under the `setup` section
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we add another static data `title` to the component ([Example 5-4](#example_05_06)),
    the Vue tab will show the `title` data property without the indication ([Figure 5-3](#figure_05_06)).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. Adding static `title` to `MyMessageComponent`
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![A screenshot of the browser''s Vue tab showing the data property without
    the indication](assets/lvue_0503.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. The `title` data property is listed without the indication
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The previous code ([Example 5-4](#example_05_06)) is equivalent to [Example 5-5](#example_06_06)
    with `setup()` hook.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. Using `setup()` hook to create a reactive `MyMessageComponent`
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can use the `ref()` function to create a reactive object for any primitive
    type (such as `string`, `number`, `boolean`, `null`, `undefined`, etc.) and any
    object type. However, for the object type such as array and object, the `ref()`
    returns an intensely reactive object, meaning both the ref object and its nested
    properties are mutable, as seen in [Example 5-6](#example_07_06).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6\. Using `ref()` to create a deeply reactive object
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In [Example 5-6](#example_07_06), we can replace the property `name` of `user`
    and the entire `user` object with a new value. We consider this case a *bad practice*
    in Vue, which can lead to performance issues for large data structures, and unexpected
    behaviors. To avoid falling into such a situation, I would recommend that you
    use the `shallowRef()` and `reactive()` functions instead, depending on your use
    case:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create a reactive object-type data and *replace it later on with
    new value*, use `shallowRef()`. A good example is integrating the component with
    asynchronous data fetching with the help of lifecycle composition hooks, as seen
    in [Example 5-7](#example_08_06).
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to create a reactive object-type data and *update its properties
    only*, use `reactive()`, which we will cover in the next section.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 5-7\. Using `shallowRef()` to manage external data fetching
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_composition_api_CO1-1)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Create a reactive `user` variable of type `User` with the initial data using
    `shallowRef`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_composition_api_CO1-2)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Create a reactive `error` variable that can be `undefined` or of type `Error`
    using `shallowRef`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_composition_api_CO1-3)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Replace the value of `user` with the response’s data, assuming it is of type
    `User`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_composition_api_CO1-4)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Update the value of `error` when an error occurred.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Using reactive()
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `reactive()` function is similar to the `ref()` function, except:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: It accepts object-type data as its argument.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can directly access the reactive return object without `value` and its properties.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only the return object’s nested properties are mutable, and trying to modify
    the return object’s value directly or using the `value` property will result in
    an error:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'But you can modify `user` object’s properties, such as `name` and `age`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Behind the scenes, `ref()` triggers `reactive()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: One important note is that the `reactive()` function returns a reactive `proxy`
    version of the original passed object. Hence, if we make any change to the reactive
    return object, it would be reflected on the original object, and vice versa, as
    seen in [Example 5-8](#example_08_06_01).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-8\. Modify both the original object and the reactive object
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, the properties of both `defaultValue` and `user` change when
    `user` changes and vice versa. Hence it will be best if you are extra cautious
    when using the `reactive()` function. You should use the spread syntax (`…​`)
    to create a new object before passing to the `reactive()` instead ([Example 5-9](#example_09_06)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9\. Using `reactive()` with spread syntax
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `reactive()` function enables profound reactivity conversion for the initial
    object. Thus, it can lead to undesired performance issues for the large data structure.
    In a scenario where you only want to observe the root object’s properties and
    not their descendant, you should use the `shallowReactive()` function instead.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: You also can combine `ref()` and `reactive()`, though I don’t recommend it due
    to its complexity and the reactivity unwrapping mechanism. If there is a need
    to create a reactive object from another reactive object, you should use `computed()`
    instead (see [“Using computed()”](#computed_hook_06)).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-1](#table_01_06) summarizes the use cases for `ref()`, `reactive()`,
    `shallowRef()`, and `shallow``Reactive()`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Use cases for `ref()`, `reactive()`, `shallowRef()` and `shallowReactive()`
    functions
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '| Hook | When to use |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| `ref()` | Primitive data types for general cases or object-type when there
    is a need for reassigning both the object and its properties. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| `shallowRef()` | Object type only as a placeholder for later reassigning
    and no property observation. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| `reactive()` | For property observation of object-type data, including nested
    properties. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| `shallowReactive()` | For property observation of object-type data, excluding
    nested properties. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: Next, we will look at the lifecycle composition hooks and what they offer.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Using the Lifecycle Hooks
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Component Lifecycle Hooks”](ch03.html#component_lifecycle_03), we learned
    the component’s lifecycle hooks and how they look in the classic Vue’s Options
    API as properties of the component’s options object. With Composition API, the
    lifecycle hooks are separate functions that we need to import from the `vue` package
    before using them to execute logic at specific points in a component’s lifecycle.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: The Composition API’s lifecycle hooks are similar to the ones in the Options
    API, except the syntax now contains the prefix `on` (for example, `mounted` becomes
    `onMounted` in Composition API). [Table 5-2](#table_02_06) shows the mapping from
    Options API to Composition API for some lifecycle hooks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Lifecycle hooks from Options API to Composition API
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '| Options API | Composition API | Description |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| `beforeMount()` | `onBeforeMount()` | Call before the first render of the
    component. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| `mounted()` | `onMounted()` | Call after Vue renders and mounts the component
    to the DOM. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| `beforeUpdate()` | `onBeforeUpdate()` | Call after the component’s update
    process starts. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| `updated()` | `onUpdated()` | Call after Vue renders the updated component
    to the DOM. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| `beforeUnmount()` | `onBeforeUnmount()` | Call before unmounting the component.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| `unmounted()` | `onUnmounted()` | Call after Vue removes and destroys the
    component instance. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: You probably noticed here that not all Options API’s lifecycle hooks have an
    equivalent in Composition API, such as `beforeCreate()` and `created()`. Instead,
    we use `setup()` or `<script setup>` with other Composition API hooks to achieve
    the same result and even define the component’s logic in a more organized way.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the above hooks to register callbacks that Vue will execute when appropriate
    by passing the callback function as its only argument. For example, to register
    a callback to `beforeMount()` hook, we can do this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since Vue triggers `setup()` before creating the component instance, there
    is no access to the `this` instance, both in `setup()` and in the hooks registered
    within it. The following code will print out `undefined` ([Figure 5-4](#figure_11_06))
    when in use:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![A screenshot displaying a console log of undefined when accessing this in
    the Composition lifecycle hook](assets/lvue_0504.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Accessing `this` in the Composition lifecycle hook yields `undefined`
  id: totrans-105
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, you can access the component’s DOM instance (like `this.$el` as in
    Options API) by using the `ref()` hook and `ref` directive, like how we define
    `input``Ref` in this example:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then bind it to the `ref` directive in the template:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we can access the DOM instance in the `onMounted()` or `onUpdated()`
    hook:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: After mounting the component, `inputRef` will refer to the input element’s correct
    DOM instance. Every time the user changes the input field, Vue will trigger the
    `onUpdated()` hook and update the DOM instance accordingly. [Figure 5-5](#figure_12_06)
    shows the console log after mounting and the user typing in the input field.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displaying a console log after mounting and user typing in the
    input field](assets/lvue_0505.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. Console log after mounting and the user making a change to the
    input field
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Composition API’s lifecycle hooks can be helpful in many cases compared to the
    Options API’s lifecycle hooks, especially when you want to keep your functional
    component’s logic concise and organized. You can also combine the lifecycle hooks
    with other Composition API hooks to achieve more complex logic and create your
    reusable custom hooks (see [“Creating Your Reusable Composables”](#reusable_hooks_06)).
    In the next section, we will look at other significant Composition API hooks,
    starting with `watch()`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Watchers in Composition API
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like the Options API’s `watch()`, the Composition API’s `watch()` hook is used
    to observe for changes and invoke the callback in reactive data. `watch()` accepts
    three arguments, as shown in this syntax:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`sources` is the reactive data for Vue to observe. It can be a single piece
    of reactive data, a getter function that returns reactive data, or an array of
    those.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cb` is the callback function that Vue will execute when any of the `sources`
    changes. This function accepts two main arguments: `newValue` and `oldValue`,
    and an optional side effect cleanup function to trigger before the next invoke.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options` are the options for the `watch()` hook, which is optional and contains
    the fields described in [Table 5-3](#watch_options_fields_table).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table 5-3\. The `watch()` options’ fields
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description | Accepted type | Default value | Required? |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `deep` | Indicates whether Vue should observe changes in the nested properties
    of the target data (if any). | boolean | `false` | No |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `immediate` | Indicates whether to trigger the handler immediately after
    mounting the component. | boolean | `false` | No |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `flush` | Indicates the timing order of the handler’s execution. By default,
    Vue triggers the handler before updating the Vue component. | `pre`, `post`, `sync`
    | `pre` | No |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `onTrack` | For debugging when it tracks the reactive data, *only in development
    mode*. | Function | `undefined` | No |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `onTrigger` | For debugging when triggering the callback, *only in development
    mode*. | Function | `undefined` | No |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: And it returns a `WatchStopHandle` function that we can use to stop the watcher
    anytime.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the `UserWatcherComponent` component with the same template presented
    in [Chapter 3](ch03.html#unique_chapter_id_03)’s [Example 3-17](ch03.html#example_03_10),
    where we allow modifying `user.name` and `user.age` based on a default `user`
    object. We will rewrite its `<script>` using Composition API, as in [Example 5-10](#example_11_06).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10\. `UserWatcherComponent` component using `setup()` and `ref()`
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Then, we add a watcher for the `user` object, as in [Example 5-11](#example_12_06).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-11\. Using the `watch()` hook for watching `user` data
  id: totrans-135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By default, Vue will trigger the callback function only when the `user` changes.
    In the previous example, because we use `reactive()` to create `user`, Vue will
    automatically enable `deep` to watch for its properties. In case you want Vue
    to only observe a specific property of `user`, such as `user.name`, we can create
    a getter function that returns that property and pass it as the `sources` argument
    to `watch()`, as in [Example 5-12](#example_13_06).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12\. Using the `watch()` hook for watching a specific property of
    `user`
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you make a change to the `user.name`, the console log will display the
    message shown in [Figure 5-6](#figure_13_06).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displaying a console log after changing user.name](assets/lvue_0506.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. Console log after changing `user.name`
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In case you need to trigger the watcher right after mounting the component,
    you can pass `{ immediate: true }` as the third argument to `watch()`, as in [Example 5-13](#example_14_06).'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-13\. Using the `watch()` hook with `immediate` option
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The console log will display the change of `user.name` from `undefined` to `John`
    right after mounting the component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: You can also pass a `sources` array of reactive data to `watch()`, and Vue will
    trigger the callback function with two collections of new and old values, each
    of which corresponds to the reactive data in the same order as the `sources` array,
    as shown in [Example 5-14](#example_15_06).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-14\. Using the `watch()` hook with an array of reactive data
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The above watcher will be triggered when either `user.name` or `user.age` changes
    and the console log will display the difference accordingly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to observe and trigger side action to multiple data changes, `watchEffect()`
    can be a better option. It will track the reactive dependencies used in the watcher’s
    function, run the function immediately right after the component renders, and
    rerun it whenever any dependencies change their value. However, you should be
    cautious using this API as it can lead to performance issues if the list of dependencies
    is extensive and the updating frequency between them is high.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Using the `watch()` hook is a great way to create a dynamic observation on specific
    reactive data or its properties. But if we want to create new reactive data based
    on the existing ones, we should use `computed()`, which we will look at next.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Using computed()
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to computed properties, we use `computed()` to create a reactive and
    cached data value derived from other reactive data. Unlike `ref()` and `reactive()`,
    `computed()` returns a *read-only* reference object, meaning we can’t manually
    reassign value to it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the reserved message example written in Options API in [Example 3-11](ch03.html#example_03_05)
    and rewrite it using the `computed()` hook as in [Example 5-15](#example_16_06).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-15\. `PalindromeCheck` component using `computed()`
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Within the `script` section, we use the `value` property of the returned object
    (`reversedMessage.value`) to access its value, like `ref()` and `reactive()`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Example 5-16](#example_17_06) shows how we create another computed
    data point to check if the message is a palindrome based on the `reversedMessage`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-16\. Using `computed()` to create new reactive `isPalindrome` data
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice here we declare the types for `reservedMessage` and `isPalindrome` explicitly
    as `string` and `boolean` to avoid type inference errors. You can now use these
    computed data in your template ([Example 5-17](#example_18_06)).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-17\. Using data created from `computed()` in the template
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code results in the output shown in [Figure 5-7](#figure_09_06) when the
    user changes the message input.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the palindrome check for the input message of hello
    world](assets/lvue_0507.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. Palindrome check component for the message using `computed()`
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you open the Vue tab in the browser’s Developer Tools, you can see these
    computed data values available under the `setup` section of the `PalindromeCheck`
    component ([Figure 5-8](#figure_10_06)).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing three data values presented under setup section of the
    component in the Vue tab of the browser developer tools](assets/lvue_0508.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Computed and reactive data shown in the developer tool for the
    `PalindromeCheck` component
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, `computed()` returns a *read-only* reactive data reference. Still,
    you can intentionally declare it as a *writable* object by passing an object of
    `{ get, set }` as the first argument to `computed()`. This mechanism stays consistent
    with `computed` properties in the Options API. However, I don’t recommend using
    this feature. You should combine it with `ref()` or `reactive()` instead.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to use `computed()` and `watch()` to achieve the same result
    as the classic `computed` and `watch` option properties. You can use either of
    them, depending on your preference. You also can use these hooks to create your
    own hooks, called composables, and reuse them in other components, which we will
    explore next.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Reusable Composables
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most exciting features of Vue 3 is the ability to create reusable
    and stateful hooks, called composables,^([2](ch05.html#id1078)) from the available
    Composition API functions. We can divide and compose common logic into readable
    composables, then use them to manage specific data state changes in different
    components. This approach helps separate the state management logic and the component
    logic, reducing our components’ complexity.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: To start composing, you can create a new TypeScript (`.ts`) file and export
    a function that returns a reactive data object as your composable, as shown in
    [Example 5-18](#example_25_06).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-18\. Creating an example composable, `useMyComposable`
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the previous code, we create a new TypeScript file named `useMyComposable.ts`
    under the `src/composables` folder and export a function called `useMyComposable`.
    The function returns a reactive data object named `myComposableData` created using
    the `reactive()` function.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can place the composable file anywhere in your project, but I recommend
    putting it under the `src/composables` folder to keep it organized. Also, it’s
    a good practice to name the composable file with the `use` prefix, followed by
    the concise, descriptive name of the composable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: You can then import and use `useMyComposable` in your component as shown in
    [Example 5-19](#example_19_06).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-19\. Using the `useMyComposable` composable in the a Vue component
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now you can access the `myComposableData` in your component’s template, and
    other parts of the component logic, as its local reactive data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a `useFetch` composable to query data from an external API using
    the `fetch` API, as shown in [Example 5-20](#example_22_06).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-20\. Create `useFetch` composable
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[![1](assets/1.png)](#co_composition_api_CO2-1)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Declare the internal logic for fetching data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_composition_api_CO2-2)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Trigger fetching data during the creation of the component and update the data
    automatically.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_composition_api_CO2-3)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Return the declared reactive variables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: You then can reuse `useFetch` to compose another asynchronous composable, such
    as `useGitHubRepos`, to query and manage user’s repositories data from the GitHub
    API ([Example 5-21](#example_24_06)).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-21\. Create a `useGitHubRepos` composable
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once done, we can use `useGitHubRepos` in a `GitHubRepos.vue` component ([Example 5-22](#example_24_08)).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-22\. Using `useGitHubRepos` in a `GitHubRepos` component
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_composition_api_CO3-1)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Get the `data` and rename it `repos`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_composition_api_CO3-2)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Iterate `repos` and display each `repo`’s information.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: And on the browser, we will see a list of repos displayed after the fetching
    completes ([Figure 5-9](#screenshot_ch04_repos)).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displaying a list of repositories retrieved from Maya Shavin''s
    GitHub account with the dedicated composable](assets/lvue_0509.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9\. Retrieve and display a list of repos using `useGitHubRepos` composable
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Mapping Data Between Composables
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to re-map any reactive data received from another composable, use
    `computed()` or `watch()` to preserve the reactivity. [Example 5-23](#example_24_07)
    demonstrates a *non-working* example of `useFetch` inside `useGitHubRepos`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-23\. Using `useFetch` in the wrong way within `useGitHubRepos`
  id: totrans-211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With composables, you can create your application’s state management logic in
    a modular and composable way. You can even build your library of composables to
    reuse in other Vue projects, such as theming control, data fetching, payment management
    for a store, etc. An excellent resource for composables is [VueUse](https://oreil.ly/pKJmK),
    where you can find many helpful, ready-to-use, and tested Vue composition utilities
    for your needs.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Since all the reactive states get initialized only when using the hook, we can
    avoid data overlapping issues like in mixins. Also, testing components have become
    more straightforward, whereby you can test each composable used in the element
    separately and keep the component’s logic small and maintainable.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: After learning about Composition API and composables, how about creating your
    own composables system and using them in your components?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored how to rewrite our components from the Options API to
    use Composition API functions such as setup function, reactivity, and lifecycle
    hooks. We also learned to create our custom composable based on the existing ones,
    enhancing code reusability. Based on this foundation, we now understand the pros
    and cons of each API, hence their use cases for better development.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了如何从选项 API 重写组件，使用组合 API 的函数，如 setup 函数、响应性和生命周期钩子。我们还学习了如何基于现有的组合函数创建我们自己的自定义组合，增强代码的可重用性。基于这一基础，我们现在理解了每个
    API 的优缺点，因此可以更好地理解它们的使用场景以便于开发。
- en: You are ready to move to the next chapter, where you will learn how to incorporate
    external data from an API or database resource into your Vue application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经准备好进入下一章，学习如何将来自 API 或数据库资源的外部数据整合到你的 Vue 应用程序中。
- en: ^([1](ch05.html#id998-marker)) When you use the mixin, you are writing a new
    component’s configurations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#id998-marker)) 当你使用 mixin 时，你在编写一个新组件的配置。
- en: ^([2](ch05.html#id1078-marker)) In general, a composable is a custom hook.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#id1078-marker)) 一般来说，可组合（composable）是一个自定义的钩子。
