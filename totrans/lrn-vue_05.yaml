- en: Chapter 5\. Composition API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to compose Vue components using the
    classic Options API. Despite it being the most common API for composing Vue components
    since Vue 2, using Options API can lead to unnecessary code complexity, unreadability
    for large component code, and logic reusability between them. For such use cases,
    this chapter introduces an alternative approach for composing Vue components,
    the Composition API.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the different composition hooks to create a
    functional stateful element in Vue. We also will learn how to combine Options
    API and Composition API for better reactive control and to compose our own reusable
    composable for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Components with Composition API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Composing components using the Options API is a common practice in Vue. However,
    in many cases, we want to reuse part of the component logic without worrying about
    the overlapping data and methods like in mixins^([1](ch05.html#id998)), or a component
    that is more readable and organized. Composition API can be helpful in such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Introduced in Vue 3.0, Composition API provides an alternative way to compose
    stateful and reactive components with the help of the `setup()` hook ([“setup”](ch03.html#setup_hook_03))
    or `<script setup>` tag. The `setup()` hook is part of the component’s options
    object and runs *once* before initializing and creating the component instance
    (before `beforeCreate()` hook).
  prefs: []
  type: TYPE_NORMAL
- en: You can *only* use Composition API functions or composables ([“Creating Your
    Reusable Composables”](#reusable_hooks_06)) within this hook or its equivalent
    syntax `<script setup>` tag. This combination creates a stateful functional component
    and provides an excellent place to define the component’s reactive state and methods
    and initialize other lifecycle hooks (see [“Using the Lifecycle Hooks”](#lifecycle_hooks_03))
    with more straightforward code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the power of Composition API, starting with `ref()` and `reactive()`
    functions to handle your component’s reactive data.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Data with ref() and reactive()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](ch02.html#unique_chapter_id_02), you learned about the `data()`
    function property in the Options API for initializing the component’s data ([“Creating
    Local State with Data Properties”](ch02.html#local_state)). All the data properties
    in the returned object from `data()` are reactive, meaning the Vue engine will
    automatically watch for changes on each declared data property. However, this
    default functionality may cause overhead in your component when you have many
    data properties, most of which are static. In such cases, the Vue engine still
    enables watchers for these static values, which is unnecessary. To limit the number
    of excessive data watchers and to have more control over which data properties
    to observe, Vue introduced the `ref()` and `reactive()` functions in the Composition
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Using ref()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ref()` is a function that accepts a single argument and returns a reactive
    object with that argument as its initial value. We call this returned object the
    `ref` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or in `<script setup>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We then can access the return object’s current value through its single `value`
    property within the `script` section. For example, the code in [Example 5-1](#example_01_06)
    creates a reactive object with the initial value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Using `ref()` to create a reactive message with an initial value
    of “Hello World”
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use Options API with `setup()` hook, you can access `message` in other
    part of component’s without `.value`, i.e., `message` is sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the `template` tag section, you can retrieve its value directly
    without the `value` property. For example, the code in [Example 5-2](#example_02_06)
    will print the same `message` as [Example 5-1](#example_01_06), but to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. Accessing `message` value in the `template` section
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `ref()` function infers types for the return object from the initial value
    passed. If you explicitly want to define the type of the return object, you can
    use the TypeScript syntax `ref<type>()`, such as `ref<string>()`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the ref object is reactive and mutable, we can change its value by assigning
    a new value to its `value` property. The Vue engine then will trigger the relevant
    watchers and update the component.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 5-3](#example_03_06), we will re-create the `MyMessageComponent`
    (from [Example 3-3](ch03.html#example_03_03) with Options API), which accepts
    input from the user and changes the `message` displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Using `ref()` to create a reactive `MyMessageComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When we change the input field’s value, the browser will show the updated `message`
    value accordingly, as shown in [Figure 5-1](#figure_06_03_06).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the browser showing the updated message value](assets/lvue_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. The value displayed changes when we change the input field’s value
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the Vue tab of the browser’s Developer Tools, we can see ref object `message`
    listed under the `setup` section, with the indication `Ref` ([Figure 5-2](#figure_05_06a)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the browser''s Vue tab showing the ref object](assets/lvue_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. The `message` ref object is listed under the `setup` section
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If we add another static data `title` to the component ([Example 5-4](#example_05_06)),
    the Vue tab will show the `title` data property without the indication ([Figure 5-3](#figure_05_06)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. Adding static `title` to `MyMessageComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![A screenshot of the browser''s Vue tab showing the data property without
    the indication](assets/lvue_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. The `title` data property is listed without the indication
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The previous code ([Example 5-4](#example_05_06)) is equivalent to [Example 5-5](#example_06_06)
    with `setup()` hook.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. Using `setup()` hook to create a reactive `MyMessageComponent`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can use the `ref()` function to create a reactive object for any primitive
    type (such as `string`, `number`, `boolean`, `null`, `undefined`, etc.) and any
    object type. However, for the object type such as array and object, the `ref()`
    returns an intensely reactive object, meaning both the ref object and its nested
    properties are mutable, as seen in [Example 5-6](#example_07_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6\. Using `ref()` to create a deeply reactive object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Example 5-6](#example_07_06), we can replace the property `name` of `user`
    and the entire `user` object with a new value. We consider this case a *bad practice*
    in Vue, which can lead to performance issues for large data structures, and unexpected
    behaviors. To avoid falling into such a situation, I would recommend that you
    use the `shallowRef()` and `reactive()` functions instead, depending on your use
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to create a reactive object-type data and *replace it later on with
    new value*, use `shallowRef()`. A good example is integrating the component with
    asynchronous data fetching with the help of lifecycle composition hooks, as seen
    in [Example 5-7](#example_08_06).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to create a reactive object-type data and *update its properties
    only*, use `reactive()`, which we will cover in the next section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 5-7\. Using `shallowRef()` to manage external data fetching
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_composition_api_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a reactive `user` variable of type `User` with the initial data using
    `shallowRef`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_composition_api_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a reactive `error` variable that can be `undefined` or of type `Error`
    using `shallowRef`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_composition_api_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the value of `user` with the response’s data, assuming it is of type
    `User`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_composition_api_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Update the value of `error` when an error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Using reactive()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `reactive()` function is similar to the `ref()` function, except:'
  prefs: []
  type: TYPE_NORMAL
- en: It accepts object-type data as its argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can directly access the reactive return object without `value` and its properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Only the return object’s nested properties are mutable, and trying to modify
    the return object’s value directly or using the `value` property will result in
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can modify `user` object’s properties, such as `name` and `age`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Behind the scenes, `ref()` triggers `reactive()`.
  prefs: []
  type: TYPE_NORMAL
- en: One important note is that the `reactive()` function returns a reactive `proxy`
    version of the original passed object. Hence, if we make any change to the reactive
    return object, it would be reflected on the original object, and vice versa, as
    seen in [Example 5-8](#example_08_06_01).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-8\. Modify both the original object and the reactive object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the properties of both `defaultValue` and `user` change when
    `user` changes and vice versa. Hence it will be best if you are extra cautious
    when using the `reactive()` function. You should use the spread syntax (`…​`)
    to create a new object before passing to the `reactive()` instead ([Example 5-9](#example_09_06)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9\. Using `reactive()` with spread syntax
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `reactive()` function enables profound reactivity conversion for the initial
    object. Thus, it can lead to undesired performance issues for the large data structure.
    In a scenario where you only want to observe the root object’s properties and
    not their descendant, you should use the `shallowReactive()` function instead.
  prefs: []
  type: TYPE_NORMAL
- en: You also can combine `ref()` and `reactive()`, though I don’t recommend it due
    to its complexity and the reactivity unwrapping mechanism. If there is a need
    to create a reactive object from another reactive object, you should use `computed()`
    instead (see [“Using computed()”](#computed_hook_06)).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 5-1](#table_01_06) summarizes the use cases for `ref()`, `reactive()`,
    `shallowRef()`, and `shallow``Reactive()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Use cases for `ref()`, `reactive()`, `shallowRef()` and `shallowReactive()`
    functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Hook | When to use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ref()` | Primitive data types for general cases or object-type when there
    is a need for reassigning both the object and its properties. |'
  prefs: []
  type: TYPE_TB
- en: '| `shallowRef()` | Object type only as a placeholder for later reassigning
    and no property observation. |'
  prefs: []
  type: TYPE_TB
- en: '| `reactive()` | For property observation of object-type data, including nested
    properties. |'
  prefs: []
  type: TYPE_TB
- en: '| `shallowReactive()` | For property observation of object-type data, excluding
    nested properties. |'
  prefs: []
  type: TYPE_TB
- en: Next, we will look at the lifecycle composition hooks and what they offer.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Lifecycle Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Component Lifecycle Hooks”](ch03.html#component_lifecycle_03), we learned
    the component’s lifecycle hooks and how they look in the classic Vue’s Options
    API as properties of the component’s options object. With Composition API, the
    lifecycle hooks are separate functions that we need to import from the `vue` package
    before using them to execute logic at specific points in a component’s lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: The Composition API’s lifecycle hooks are similar to the ones in the Options
    API, except the syntax now contains the prefix `on` (for example, `mounted` becomes
    `onMounted` in Composition API). [Table 5-2](#table_02_06) shows the mapping from
    Options API to Composition API for some lifecycle hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Lifecycle hooks from Options API to Composition API
  prefs: []
  type: TYPE_NORMAL
- en: '| Options API | Composition API | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `beforeMount()` | `onBeforeMount()` | Call before the first render of the
    component. |'
  prefs: []
  type: TYPE_TB
- en: '| `mounted()` | `onMounted()` | Call after Vue renders and mounts the component
    to the DOM. |'
  prefs: []
  type: TYPE_TB
- en: '| `beforeUpdate()` | `onBeforeUpdate()` | Call after the component’s update
    process starts. |'
  prefs: []
  type: TYPE_TB
- en: '| `updated()` | `onUpdated()` | Call after Vue renders the updated component
    to the DOM. |'
  prefs: []
  type: TYPE_TB
- en: '| `beforeUnmount()` | `onBeforeUnmount()` | Call before unmounting the component.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `unmounted()` | `onUnmounted()` | Call after Vue removes and destroys the
    component instance. |'
  prefs: []
  type: TYPE_TB
- en: You probably noticed here that not all Options API’s lifecycle hooks have an
    equivalent in Composition API, such as `beforeCreate()` and `created()`. Instead,
    we use `setup()` or `<script setup>` with other Composition API hooks to achieve
    the same result and even define the component’s logic in a more organized way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the above hooks to register callbacks that Vue will execute when appropriate
    by passing the callback function as its only argument. For example, to register
    a callback to `beforeMount()` hook, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Since Vue triggers `setup()` before creating the component instance, there
    is no access to the `this` instance, both in `setup()` and in the hooks registered
    within it. The following code will print out `undefined` ([Figure 5-4](#figure_11_06))
    when in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![A screenshot displaying a console log of undefined when accessing this in
    the Composition lifecycle hook](assets/lvue_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Accessing `this` in the Composition lifecycle hook yields `undefined`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'However, you can access the component’s DOM instance (like `this.$el` as in
    Options API) by using the `ref()` hook and `ref` directive, like how we define
    `input``Ref` in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then bind it to the `ref` directive in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can access the DOM instance in the `onMounted()` or `onUpdated()`
    hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After mounting the component, `inputRef` will refer to the input element’s correct
    DOM instance. Every time the user changes the input field, Vue will trigger the
    `onUpdated()` hook and update the DOM instance accordingly. [Figure 5-5](#figure_12_06)
    shows the console log after mounting and the user typing in the input field.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displaying a console log after mounting and user typing in the
    input field](assets/lvue_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. Console log after mounting and the user making a change to the
    input field
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Composition API’s lifecycle hooks can be helpful in many cases compared to the
    Options API’s lifecycle hooks, especially when you want to keep your functional
    component’s logic concise and organized. You can also combine the lifecycle hooks
    with other Composition API hooks to achieve more complex logic and create your
    reusable custom hooks (see [“Creating Your Reusable Composables”](#reusable_hooks_06)).
    In the next section, we will look at other significant Composition API hooks,
    starting with `watch()`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Watchers in Composition API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like the Options API’s `watch()`, the Composition API’s `watch()` hook is used
    to observe for changes and invoke the callback in reactive data. `watch()` accepts
    three arguments, as shown in this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`sources` is the reactive data for Vue to observe. It can be a single piece
    of reactive data, a getter function that returns reactive data, or an array of
    those.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cb` is the callback function that Vue will execute when any of the `sources`
    changes. This function accepts two main arguments: `newValue` and `oldValue`,
    and an optional side effect cleanup function to trigger before the next invoke.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options` are the options for the `watch()` hook, which is optional and contains
    the fields described in [Table 5-3](#watch_options_fields_table).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Table 5-3\. The `watch()` options’ fields
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description | Accepted type | Default value | Required? |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `deep` | Indicates whether Vue should observe changes in the nested properties
    of the target data (if any). | boolean | `false` | No |'
  prefs: []
  type: TYPE_TB
- en: '| `immediate` | Indicates whether to trigger the handler immediately after
    mounting the component. | boolean | `false` | No |'
  prefs: []
  type: TYPE_TB
- en: '| `flush` | Indicates the timing order of the handler’s execution. By default,
    Vue triggers the handler before updating the Vue component. | `pre`, `post`, `sync`
    | `pre` | No |'
  prefs: []
  type: TYPE_TB
- en: '| `onTrack` | For debugging when it tracks the reactive data, *only in development
    mode*. | Function | `undefined` | No |'
  prefs: []
  type: TYPE_TB
- en: '| `onTrigger` | For debugging when triggering the callback, *only in development
    mode*. | Function | `undefined` | No |'
  prefs: []
  type: TYPE_TB
- en: And it returns a `WatchStopHandle` function that we can use to stop the watcher
    anytime.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at the `UserWatcherComponent` component with the same template presented
    in [Chapter 3](ch03.html#unique_chapter_id_03)’s [Example 3-17](ch03.html#example_03_10),
    where we allow modifying `user.name` and `user.age` based on a default `user`
    object. We will rewrite its `<script>` using Composition API, as in [Example 5-10](#example_11_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10\. `UserWatcherComponent` component using `setup()` and `ref()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Then, we add a watcher for the `user` object, as in [Example 5-11](#example_12_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-11\. Using the `watch()` hook for watching `user` data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By default, Vue will trigger the callback function only when the `user` changes.
    In the previous example, because we use `reactive()` to create `user`, Vue will
    automatically enable `deep` to watch for its properties. In case you want Vue
    to only observe a specific property of `user`, such as `user.name`, we can create
    a getter function that returns that property and pass it as the `sources` argument
    to `watch()`, as in [Example 5-12](#example_13_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12\. Using the `watch()` hook for watching a specific property of
    `user`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When you make a change to the `user.name`, the console log will display the
    message shown in [Figure 5-6](#figure_13_06).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displaying a console log after changing user.name](assets/lvue_0506.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. Console log after changing `user.name`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In case you need to trigger the watcher right after mounting the component,
    you can pass `{ immediate: true }` as the third argument to `watch()`, as in [Example 5-13](#example_14_06).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-13\. Using the `watch()` hook with `immediate` option
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The console log will display the change of `user.name` from `undefined` to `John`
    right after mounting the component.
  prefs: []
  type: TYPE_NORMAL
- en: You can also pass a `sources` array of reactive data to `watch()`, and Vue will
    trigger the callback function with two collections of new and old values, each
    of which corresponds to the reactive data in the same order as the `sources` array,
    as shown in [Example 5-14](#example_15_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-14\. Using the `watch()` hook with an array of reactive data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The above watcher will be triggered when either `user.name` or `user.age` changes
    and the console log will display the difference accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to observe and trigger side action to multiple data changes, `watchEffect()`
    can be a better option. It will track the reactive dependencies used in the watcher’s
    function, run the function immediately right after the component renders, and
    rerun it whenever any dependencies change their value. However, you should be
    cautious using this API as it can lead to performance issues if the list of dependencies
    is extensive and the updating frequency between them is high.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `watch()` hook is a great way to create a dynamic observation on specific
    reactive data or its properties. But if we want to create new reactive data based
    on the existing ones, we should use `computed()`, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Using computed()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to computed properties, we use `computed()` to create a reactive and
    cached data value derived from other reactive data. Unlike `ref()` and `reactive()`,
    `computed()` returns a *read-only* reference object, meaning we can’t manually
    reassign value to it.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the reserved message example written in Options API in [Example 3-11](ch03.html#example_03_05)
    and rewrite it using the `computed()` hook as in [Example 5-15](#example_16_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-15\. `PalindromeCheck` component using `computed()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Within the `script` section, we use the `value` property of the returned object
    (`reversedMessage.value`) to access its value, like `ref()` and `reactive()`.
  prefs: []
  type: TYPE_NORMAL
- en: The code in [Example 5-16](#example_17_06) shows how we create another computed
    data point to check if the message is a palindrome based on the `reversedMessage`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-16\. Using `computed()` to create new reactive `isPalindrome` data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Notice here we declare the types for `reservedMessage` and `isPalindrome` explicitly
    as `string` and `boolean` to avoid type inference errors. You can now use these
    computed data in your template ([Example 5-17](#example_18_06)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-17\. Using data created from `computed()` in the template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This code results in the output shown in [Figure 5-7](#figure_09_06) when the
    user changes the message input.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the palindrome check for the input message of hello
    world](assets/lvue_0507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. Palindrome check component for the message using `computed()`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you open the Vue tab in the browser’s Developer Tools, you can see these
    computed data values available under the `setup` section of the `PalindromeCheck`
    component ([Figure 5-8](#figure_10_06)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing three data values presented under setup section of the
    component in the Vue tab of the browser developer tools](assets/lvue_0508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Computed and reactive data shown in the developer tool for the
    `PalindromeCheck` component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, `computed()` returns a *read-only* reactive data reference. Still,
    you can intentionally declare it as a *writable* object by passing an object of
    `{ get, set }` as the first argument to `computed()`. This mechanism stays consistent
    with `computed` properties in the Options API. However, I don’t recommend using
    this feature. You should combine it with `ref()` or `reactive()` instead.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to use `computed()` and `watch()` to achieve the same result
    as the classic `computed` and `watch` option properties. You can use either of
    them, depending on your preference. You also can use these hooks to create your
    own hooks, called composables, and reuse them in other components, which we will
    explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Reusable Composables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most exciting features of Vue 3 is the ability to create reusable
    and stateful hooks, called composables,^([2](ch05.html#id1078)) from the available
    Composition API functions. We can divide and compose common logic into readable
    composables, then use them to manage specific data state changes in different
    components. This approach helps separate the state management logic and the component
    logic, reducing our components’ complexity.
  prefs: []
  type: TYPE_NORMAL
- en: To start composing, you can create a new TypeScript (`.ts`) file and export
    a function that returns a reactive data object as your composable, as shown in
    [Example 5-18](#example_25_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-18\. Creating an example composable, `useMyComposable`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, we create a new TypeScript file named `useMyComposable.ts`
    under the `src/composables` folder and export a function called `useMyComposable`.
    The function returns a reactive data object named `myComposableData` created using
    the `reactive()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can place the composable file anywhere in your project, but I recommend
    putting it under the `src/composables` folder to keep it organized. Also, it’s
    a good practice to name the composable file with the `use` prefix, followed by
    the concise, descriptive name of the composable.
  prefs: []
  type: TYPE_NORMAL
- en: You can then import and use `useMyComposable` in your component as shown in
    [Example 5-19](#example_19_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-19\. Using the `useMyComposable` composable in the a Vue component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now you can access the `myComposableData` in your component’s template, and
    other parts of the component logic, as its local reactive data.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a `useFetch` composable to query data from an external API using
    the `fetch` API, as shown in [Example 5-20](#example_22_06).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-20\. Create `useFetch` composable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_composition_api_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the internal logic for fetching data.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_composition_api_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Trigger fetching data during the creation of the component and update the data
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_composition_api_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the declared reactive variables.
  prefs: []
  type: TYPE_NORMAL
- en: You then can reuse `useFetch` to compose another asynchronous composable, such
    as `useGitHubRepos`, to query and manage user’s repositories data from the GitHub
    API ([Example 5-21](#example_24_06)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-21\. Create a `useGitHubRepos` composable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once done, we can use `useGitHubRepos` in a `GitHubRepos.vue` component ([Example 5-22](#example_24_08)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-22\. Using `useGitHubRepos` in a `GitHubRepos` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_composition_api_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the `data` and rename it `repos`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_composition_api_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate `repos` and display each `repo`’s information.
  prefs: []
  type: TYPE_NORMAL
- en: And on the browser, we will see a list of repos displayed after the fetching
    completes ([Figure 5-9](#screenshot_ch04_repos)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displaying a list of repositories retrieved from Maya Shavin''s
    GitHub account with the dedicated composable](assets/lvue_0509.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9\. Retrieve and display a list of repos using `useGitHubRepos` composable
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Mapping Data Between Composables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you need to re-map any reactive data received from another composable, use
    `computed()` or `watch()` to preserve the reactivity. [Example 5-23](#example_24_07)
    demonstrates a *non-working* example of `useFetch` inside `useGitHubRepos`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-23\. Using `useFetch` in the wrong way within `useGitHubRepos`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With composables, you can create your application’s state management logic in
    a modular and composable way. You can even build your library of composables to
    reuse in other Vue projects, such as theming control, data fetching, payment management
    for a store, etc. An excellent resource for composables is [VueUse](https://oreil.ly/pKJmK),
    where you can find many helpful, ready-to-use, and tested Vue composition utilities
    for your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Since all the reactive states get initialized only when using the hook, we can
    avoid data overlapping issues like in mixins. Also, testing components have become
    more straightforward, whereby you can test each composable used in the element
    separately and keep the component’s logic small and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: After learning about Composition API and composables, how about creating your
    own composables system and using them in your components?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored how to rewrite our components from the Options API to
    use Composition API functions such as setup function, reactivity, and lifecycle
    hooks. We also learned to create our custom composable based on the existing ones,
    enhancing code reusability. Based on this foundation, we now understand the pros
    and cons of each API, hence their use cases for better development.
  prefs: []
  type: TYPE_NORMAL
- en: You are ready to move to the next chapter, where you will learn how to incorporate
    external data from an API or database resource into your Vue application.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch05.html#id998-marker)) When you use the mixin, you are writing a new
    component’s configurations.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch05.html#id1078-marker)) In general, a composable is a custom hook.
  prefs: []
  type: TYPE_NORMAL
