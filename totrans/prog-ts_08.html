<html><head></head><body><section data-pdf-bookmark="Chapter 8. Asynchronous Programming, Concurrency, and Parallelism" data-type="chapter" epub:type="chapter"><div class="chapter" id="async">&#13;
<h1><span class="label">Chapter 8. </span>Asynchronous Programming, <span class="keep-together">Concurrency, and Parallelism</span></h1>&#13;
&#13;
&#13;
<p>So far in this book, we’ve dealt mostly with synchronous programs—programs that take some input, do some stuff, and run to completion in a single pass.<a data-primary="asynchronous programming" data-type="indexterm" id="ix_async"/> But the really interesting programs—the building blocks of real-world applications that make network requests, interact with databases and filesystems, respond to user interaction, offload CPU-intensive work to separate threads—all make use of asynchronous APIs like callbacks, promises, and streams.</p>&#13;
&#13;
<p>These asynchronous tasks are where JavaScript really shines and sets itself apart from other mainstream multithreaded languages like Java and C++. Popular JavaScript engines like V8 and SpiderMonkey do with one thread what traditionally required many threads, by being clever and multiplexing tasks over a single thread while other tasks are idling. This <em>event loop</em> is the standard threading model for JavaScript engines, and the one that we’ll assume you’re using. From an end user’s perspective, it usually doesn’t matter whether your engine uses an event looped model or a multithreaded one, but it does affect the explanations I’ll be giving for how things work and why we design things the way we do.</p>&#13;
&#13;
<p>This event-looped concurrency model is how JavaScript avoids all the common footguns endemic to multithreaded programming, along with the overhead of synchronized data types, mutexes, semaphores, and all the other bits of multithreading jargon. And when you do run JavaScript over multiple threads, it’s rare to use shared memory; the typical pattern is to use message passing and to serialize data when sending it between threads. It’s a design reminiscent of Erlang, actor systems, and other purely functional concurrency models, and is what makes multithreaded programming in JavaScript foolproof.</p>&#13;
&#13;
<p>That said, asynchronous programming does make programs harder to reason about, because you can no longer mentally trace through a program line by line; you have to know when to pause and move execution elsewhere, and when to resume again.</p>&#13;
&#13;
<p>TypeScript gives us the tools to reason about asynchronous programs: types let us trace through asynchronous work, and built-in support for <code>async</code>/<code>await</code> let us apply <a data-primary="async and await syntax" data-type="indexterm" id="idm46304959698280"/>familiar synchronous thinking to asynchronous programs. We can also use TypeScript to specify strict message-passing protocols for multithreaded programs (it’s a lot simpler than it sounds). If all else fails, TypeScript can give you a back rub when your coworker’s asynchronous code gets too complicated and you have to stay late debugging it (behind a compiler flag, of course).</p>&#13;
&#13;
<p>But before we get to working with asynchronous programs, let’s talk a bit more about how asynchronicity actually works in modern JavaScript engines—how is it that we can suspend and resume execution on what seems to be a single thread?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JavaScript’s Event Loop" data-type="sect1"><div class="sect1" id="idm46304959696248">&#13;
<h1>JavaScript’s Event Loop</h1>&#13;
&#13;
<p>Let’s start with an example.<a data-primary="JavaScript" data-secondary="event loop" data-type="indexterm" id="ix_JSeevlp"/><a data-primary="asynchronous programming" data-secondary="JavaScript's event loop" data-type="indexterm" id="ix_asyncevlp"/><a data-primary="event loop" data-type="indexterm" id="ix_evlp"/> We’ll set a couple of timers, one that fires after one millisecond, and the other after two:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'A'</code><code class="p">),</code> <code class="mi">1</code><code class="p">)</code>&#13;
<code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'B'</code><code class="p">),</code> <code class="mi">2</code><code class="p">)</code>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'C'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Now, what will get logged to the console? Is it <code>A</code>, <code>B</code>, <code>C</code>?</p>&#13;
&#13;
<p>If you’re a JavaScript programmer, you know intuitively the answer is no—the actual firing order is <code>C</code>, <code>A</code>, then <code>B</code>. If you haven’t worked with JavaScript or TypeScript before, this behavior might seem mysterious and unintuitive. In reality, it’s pretty straightforward; it just doesn’t follow the same concurrency model as a <code>sleep</code> would in C, or scheduling work in another thread would in Java.</p>&#13;
&#13;
<p>At a high level, the JavaScript VM simulates concurrency like this (see <a data-type="xref" href="#javascript-loop-fig">Figure 8-1</a>):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The main JavaScript thread calls into native asynchronous APIs like <span class="keep-together"><code>XMLHTTPRequest</code></span> (for AJAX requests), <code>setTimeout</code> (for sleeping), <code>readFile</code> (for reading a file from disk), and so on. These APIs are provided by the JavaScript platform—you can’t create them yourself.<sup><a data-type="noteref" href="ch08.html#idm46304959625896" id="idm46304959625896-marker">1</a></sup></p>&#13;
</li>&#13;
<li>&#13;
<p>Once you call into a native asynchronous API, control returns to the main thread and execution continues as if the API was never called.</p>&#13;
</li>&#13;
<li>&#13;
<p>Once the asynchronous operation is done, the platform puts a <em>task</em> in its <em>event queue</em>.<a data-primary="tasks" data-type="indexterm" id="idm46304959622616"/><a data-primary="event queue" data-type="indexterm" id="idm46304959621880"/> Each thread has its own queue, used for relaying the results of asynchronous operations back to the main thread. A task includes some metainformation about the call, and a reference to a callback function from the main thread.</p>&#13;
</li>&#13;
<li>&#13;
<p>Whenever the main thread’s call stack is emptied, the platform will check its event queue for pending tasks. If there’s a task waiting, the platform runs it; that triggers a function call, and control returns to that main thread function. When the call stack resulting from that function call is once again empty, the platform again checks the event queue for tasks that are ready to go. This loop repeats until both the call stack and the event queue are empty, and all asynchronous native API calls have completed.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<figure><div class="figure" id="javascript-loop-fig">&#13;
<img alt="prts 0801" src="assets/prts_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>JavaScript’s event loop: what happens when you call an asynchronous API</h6>&#13;
</div></figure>&#13;
&#13;
<p>Armed with this information, it’s time to go back to our <code>setTimeout</code> example. Here’s what happens:</p>&#13;
<ol>&#13;
<li>&#13;
<p>We call <code>setTimeout</code>, which calls a native timeout API with a reference to the callback we passed in and the argument <code>1</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>We call <code>setTimeout</code> again, which calls the native timeout API again with a reference to the second callback we passed in and the argument <code>2</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>We log <code>C</code> to the console.</p>&#13;
</li>&#13;
<li>&#13;
<p>In the background, after at least one millisecond, our JavaScript platform adds a task to its event queue indicating that the timeout for the first <code>setTimeout</code> has elapsed, and that its callback is now ready to be called.</p>&#13;
</li>&#13;
<li>&#13;
<p>After another millisecond, the platform adds a second task to the event queue for the second <code>setTimeout</code>’s callback.</p>&#13;
</li>&#13;
<li>&#13;
<p>Since the call stack is empty, after step 3 is done the platform looks at its event queue to see if there are any tasks in it. If steps 4 and/or 5 are done, then it will find some tasks. For each task, it will call the corresponding callback function.</p>&#13;
</li>&#13;
<li>&#13;
<p>Once both timers have elapsed and the event queue and  call stack are empty, the program exits.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>That’s why we logged <code>C</code>, <code>A</code>, <code>B</code>, and not <code>A</code>, <code>B</code>, <code>C</code>. With this baseline out of the way, we can start talking about how to type asynchronous code safely.<a data-primary="JavaScript" data-secondary="event loop" data-startref="ix_JSeevlp" data-type="indexterm" id="idm46304959586504"/><a data-primary="event loop" data-startref="ix_evlp" data-type="indexterm" id="idm46304959585416"/><a data-primary="asynchronous programming" data-secondary="JavaScript's event loop" data-startref="ix_asyncevlp" data-type="indexterm" id="idm46304959584568"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Working with Callbacks" data-type="sect1"><div class="sect1" id="idm46304959695624">&#13;
<h1>Working with Callbacks</h1>&#13;
&#13;
<p>The basic unit of the asynchronous JavaScript program is the <em>callback</em>. A callback is a plain old function that you pass as an argument to another function.<a data-primary="NodeJS" data-secondary="callback-based fs.readFile API" data-type="indexterm" id="ix_NoJScllbk"/><a data-primary="asynchronous programming" data-secondary="callbacks" data-type="indexterm" id="ix_asynccllbk"/><a data-primary="callbacks" data-type="indexterm" id="ix_cllbk"/> As in a synchronous program, that other function invokes your function when it’s done doing whatever it does (making a network request, etc.). Callbacks invoked by asynchronous code are just functions, and there’s no giveaway in their type signatures that they are invoked asynchronously.</p>&#13;
&#13;
<p>For NodeJS native APIs like <code>fs.readFile</code> (used to asynchronously read the contents of a file from disk) and <code>dns.resolveCname</code> (used to asynchronously resolve <code>CNAME</code> records), the convention for callbacks is that the first parameter is an error or <code>null</code>, and the second parameter is a result or <code>null</code>.</p>&#13;
&#13;
<p>Here’s what <code>readFile</code>’s type signature looks like:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">readFile</code><code class="p">(</code>&#13;
  <code class="nx">path</code>: <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">options</code><code class="o">:</code> <code class="p">{</code><code class="nx">encoding</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">flag?</code>: <code class="kt">string</code><code class="p">},</code>&#13;
  <code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">err</code>: <code class="kt">Error</code> <code class="o">|</code> <code class="kc">null</code><code class="p">,</code> <code class="nx">data</code>: <code class="kt">string</code> <code class="o">|</code> <code class="kc">null</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="k">void</code></pre>&#13;
&#13;
<p>Notice that there’s nothing special about either <code>readFile</code>’s type or <code>callback</code>’s type: both are regular JavaScript functions. Looking at the signature, there’s no indication that <code>readFile</code> is asynchronous and that control  will be passed to the next line right after <code>readFile</code> is called (not waiting for its result).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To run the following example yourself, be sure to first install type declarations for NodeJS:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">npm install @types/node --save-dev</pre>&#13;
&#13;
<p>To learn more about third-party type declarations, jump ahead to <a data-type="xref" href="ch11.html#third-party-js-with-dt-typings">“JavaScript That Has Type Declarations on DefinitelyTyped”</a>.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">For example, let’s write a NodeJS program that reads and writes to your Apache access log:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">fs</code> <code class="nx">from</code> <code class="s1">'fs'</code>&#13;
&#13;
<code class="c1">// Read data from an Apache server's access log</code>&#13;
<code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code>&#13;
  <code class="s1">'/var/log/apache2/access_log'</code><code class="p">,</code>&#13;
  <code class="p">{</code><code class="nx">encoding</code><code class="o">:</code> <code class="s1">'utf8'</code><code class="p">},</code>&#13;
  <code class="p">(</code><code class="nx">error</code><code class="p">,</code> <code class="nx">data</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'error reading!'</code><code class="p">,</code> <code class="nx">error</code><code class="p">)</code>&#13;
      <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'success reading!'</code><code class="p">,</code> <code class="nx">data</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// Concurrently, write data to the same access log</code>&#13;
<code class="nx">fs</code><code class="p">.</code><code class="nx">appendFile</code><code class="p">(</code>&#13;
  <code class="s1">'/var/log/apache2/access_log'</code><code class="p">,</code>&#13;
  <code class="s1">'New access log entry'</code><code class="p">,</code>&#13;
  <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'error writing!'</code><code class="p">,</code> <code class="nx">error</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">})</code></pre>&#13;
&#13;
<p>Unless you’re a TypeScript or JavaScript engineer and are familiar with how NodeJS’s built-in APIs work, and know that they’re asynchronous and you can’t rely on the order in which API calls appear in your code to dictate in which order filesystem operations actually happen, you wouldn’t know that we just introduced a subtle bug where the first <code>readFile</code> call may or may not return the access log with our new line appended, depending on how busy the filesystem is at the time this code runs.</p>&#13;
&#13;
<p>You might know that <code>readFile</code> is asynchronous from experience, or because you saw it in NodeJS’s documentation, or because you know that NodeJS generally sticks to the convention that if a function’s last argument is a function that takes two arguments—an <code>Error | null</code> and a <code>T | null</code>, in that order—then the function is usually asynchronous, or because you ran across the hall to your neighbor for a cup of sugar and ended up staying for a while to chit-chat, then you somehow got on the topic of asynchronous programming in NodeJS and they told you about that time they had a similar issue a couple of months ago and how they fixed it.</p>&#13;
&#13;
<p>Whatever it was, the types certainly didn’t help you get there.</p>&#13;
&#13;
<p>Besides the fact that you <a data-primary="sequencing operations" data-secondary="in callbacks" data-type="indexterm" id="idm46304959357192"/>can’t use types to help guide your intuition about the nature of a function’s synchronicity, callbacks are also difficult to sequence—which can lead to what some <a data-primary="callbacks" data-secondary="callback pyramids" data-type="indexterm" id="idm46304959356008"/>people call “callback pyramids”:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">async1</code><code class="p">((</code><code class="nx">err1</code><code class="p">,</code> <code class="nx">res1</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">res1</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">async2</code><code class="p">(</code><code class="nx">res1</code><code class="p">,</code> <code class="p">(</code><code class="nx">err2</code><code class="p">,</code> <code class="nx">res2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="nx">res2</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">async3</code><code class="p">(</code><code class="nx">res2</code><code class="p">,</code> <code class="p">(</code><code class="nx">err3</code><code class="p">,</code> <code class="nx">res3</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
          <code class="c1">// ...</code>&#13;
        <code class="p">})</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">})</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>When sequencing operations, you usually want to continue down the chain when an operation succeeds, bailing out as soon as you hit an error.<a data-primary="errors" data-secondary="in callbacks" data-type="indexterm" id="idm46304959353128"/> With callbacks, you have to do this manually; when you start accounting for synchronous errors too (e.g., the NodeJS convention is to <code>throw</code> when you give it a badly typed argument, rather than calling your provided callback with an <code>Error</code> object), properly sequencing callbacks can get error-prone.</p>&#13;
&#13;
<p>And sequencing is just one kind of operation you might want to run over asynchronous tasks—you might also want to run functions in parallel to know when they’re all done, race them to get the result of the first one that finishes, and so on.</p>&#13;
&#13;
<p>This is a limitation of plain old callbacks. Without more sophisticated abstractions for operating on asynchronous tasks, working with multiple callbacks that depend on each other in some way can get messy fast.<a data-primary="NodeJS" data-secondary="callback-based fs.readFile API" data-startref="ix_NoJScllbk" data-type="indexterm" id="idm46304959257864"/></p>&#13;
&#13;
<p>To recap:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use callbacks to do simple asynchronous tasks.</p>&#13;
</li>&#13;
<li>&#13;
<p>While callbacks are great for modeling simple tasks, they quickly get hairy as you try to do things with <em>lots</em> of asynchronous tasks.<a data-primary="asynchronous programming" data-secondary="callbacks" data-startref="ix_asynccllbk" data-type="indexterm" id="idm46304959253704"/><a data-primary="callbacks" data-startref="ix_cllbk" data-type="indexterm" id="idm46304959252456"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Regaining Sanity with Promises" data-type="sect1"><div class="sect1" id="promises">&#13;
<h1>Regaining Sanity with Promises</h1>&#13;
&#13;
<p>Luckily, we’re not the first programmers to run into these limitations. In this section we’ll develop the concept of <em>promises</em>,<a data-primary="promises" data-type="indexterm" id="ix_prom"/><a data-primary="asynchronous programming" data-secondary="promises" data-type="indexterm" id="ix_asyncprom"/> which are a way to abstract over asynchronous work so that we can compose it, sequence it, and so on. Even if you’ve worked with promises or futures before, this will be a helpful exercise to understand how they work.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Most modern JavaScript platforms include built-in support for promises. In this section we’ll develop our own partial <code>Promise</code> implementation as an exercise, but in practice, you should use a built-in or off-the-shelf implementation instead. Check whether or not your favorite platform supports promises <a href="http://bit.ly/2uMxkk5">here</a>, or jump ahead to <a data-type="xref" href="ch12.html#lib">“lib”</a> to learn more about polyfilling promises on platforms they’re not natively supported on.</p>&#13;
</div>&#13;
&#13;
<p>We’ll start with<a data-primary="promises" data-secondary="Promise implementation" data-type="indexterm" id="idm46304959242040"/> an example of how we want to use <code>Promise</code> to first append to a file, then read back the result:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">appendAndReadPromise</code><code class="p">(</code><code class="nx">path</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">data</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">appendPromise</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="nx">data</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">readPromise</code><code class="p">(</code><code class="nx">path</code><code class="p">))</code>&#13;
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">error</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice how there’s no callback pyramid here—we’ve effectively linearized what we want to do<a data-primary="callbacks" data-secondary="appendAndRead function example" data-type="indexterm" id="idm46304959206824"/> into a single, easy-to-understand chain of asynchronous tasks. When one succeeds, the next one runs; if it fails, we skip to the <code>catch</code> clause. With a callback-based API, this might have looked more like:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">appendAndRead</code><code class="p">(</code>&#13;
  <code class="nx">path</code>: <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">data</code>: <code class="kt">string</code>&#13;
  <code class="nx">cb</code><code class="o">:</code> <code class="p">(</code><code class="nx">error</code>: <code class="kt">Error</code> <code class="o">|</code> <code class="kc">null</code><code class="p">,</code> <code class="nx">result</code>: <code class="kt">string</code> <code class="o">|</code> <code class="kc">null</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">appendFile</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="nx">data</code><code class="p">,</code> <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">cb</code><code class="p">(</code><code class="nx">error</code><code class="p">,</code> <code class="kc">null</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">readFile</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="p">(</code><code class="nx">error</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nx">cb</code><code class="p">(</code><code class="nx">error</code><code class="p">,</code> <code class="kc">null</code><code class="p">)</code>&#13;
      <code class="p">}</code>&#13;
      <code class="nx">cb</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code>&#13;
    <code class="p">})</code>&#13;
  <code class="p">})</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s design a <code>Promise</code> API that lets us do this.</p>&#13;
&#13;
<p><code>Promise</code> starts from humble beginnings:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">class</code> <code class="nx">Promise</code> <code class="p">{</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A <code>new Promise</code> takes a function<a data-primary="executors" data-type="indexterm" id="idm46304959073080"/> we call an <em>executor</em>, which the <code>Promise</code> implementation will call with two arguments, a <code>resolve</code> function and a <code>reject</code> function:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Executor</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="nx">resolve</code>: <code class="kt">Function</code><code class="p">,</code>&#13;
  <code class="nx">reject</code>: <code class="kt">Function</code>&#13;
<code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Promise</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">f</code>: <code class="kt">Executor</code><code class="p">)</code> <code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>How do <code>resolve</code> and <code>reject</code> work? Let’s demonstrate it by thinking about how we would manually wrap a callback-based NodeJS API like <code>fs.readFile</code> in a <code>Promise</code>-based API.<a data-primary="promises" data-secondary="wrapping callback-based NodeJS API fs.readFile  in Promise-based API" data-type="indexterm" id="idm46304959012504"/><a data-primary="NodeJS" data-secondary="wrapping callback-based fs.readFileAPI  in Promise-based API" data-type="indexterm" id="idm46304959011528"/> We use NodeJS’s built-in <code>fs.readFile</code> API like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code><code class="nx">readFile</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'fs'</code>&#13;
&#13;
<code class="nx">readFile</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="p">(</code><code class="nx">error</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>Wrapping that API in our <code>Promise</code> implementation, it now looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code><code class="nx">readFile</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'fs'</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">readFilePromise</code><code class="p">(</code><code class="nx">path</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">readFile</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="p">(</code><code class="nx">error</code><code class="p">,</code> <code class="nx">result</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">if</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="nx">reject</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code>&#13;
      <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="nx">resolve</code><code class="p">(</code><code class="nx">result</code><code class="p">)</code>&#13;
      <code class="p">}</code>&#13;
    <code class="p">})</code>&#13;
  <code class="p">})</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So, the type of <code>resolve</code>’s parameter depends on which specific API we’re using (in this case, its parameter’s type would be whatever <code>result</code>’s type is), and the type of <code>reject</code>’s parameter is always some type of <code>Error</code>.<a data-primary="errors" data-secondary="in Promise implementation" data-type="indexterm" id="idm46304958829400"/> Back to our implementation, let’s update our code by replacing our unsafe <code>Function</code> types with more specific types:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">Executor</code><strong><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code><code> </code><code class="nx">E</code><code> </code><code class="kr">extends</code><code> </code><code class="nb">Error</code><code class="o">&gt;</code></strong><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code>&#13;
  </code><code class="nx">resolve</code><code class="o">:</code><code> </code><strong><code class="p">(</code><code class="nx">result</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code></strong><code class="p">,</code><code>&#13;
  </code><code class="nx">reject</code><code class="o">:</code><code> </code><strong><code class="p">(</code><code class="nx">error</code><code>: </code><code class="kt">E</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code></strong><code>&#13;
</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code>&#13;
</code><em><code class="c1">// ...</code></em><code class="c1">&#13;
</code></pre>&#13;
&#13;
<p>Because we want to be able to get a sense for what type a <code>Promise</code> will resolve to just by looking at the <code>Promise</code> (for example, <code>Promise&lt;number&gt;</code> represents an <a data-primary="generic types" data-secondary="Promise" data-type="indexterm" id="idm46304958762904"/><a data-primary="promises" data-secondary="Promise implementation" data-tertiary="generic type" data-type="indexterm" id="idm46304958762056"/>asynchronous task that results in a <code>number</code>), we’ll make <code>Promise</code> generic, and pass its type parameters down to the <code>Executor</code> type in its constructor:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// ...</code>&#13;
<code class="kr">class</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">E</code> <code class="kr">extends</code> <code class="nb">Error</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">f</code>: <code class="kt">Executor</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">E</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So far, so good. We defined <code>Promise</code>’s constructor API and understand what the types at play are.<a data-primary="promises" data-secondary="Promise implementation" data-tertiary="sequencing Promises with then and catch" data-type="indexterm" id="idm46304958716456"/><a data-primary="sequencing operations" data-secondary="in Promises" data-type="indexterm" id="idm46304958715368"/> Now, let’s think about chaining—what are the operations we want to expose to run a sequence of <code>Promise</code>s, propagate their results, and catch their exceptions? If you look back to the initial code example at the start of this section, that’s what <code>then</code> and <code>catch</code> are for. Let’s add them to our <code>Promise</code> type:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// ...</code></em><code class="c1">&#13;
</code><code class="kr">class</code><code> </code><code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code><code> </code><code class="nx">E</code><code> </code><code class="kr">extends</code><code> </code><code class="nb">Error</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code class="nx">f</code><code>: </code><code class="kt">Executor</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code><code> </code><code class="nx">E</code><code class="o">&gt;</code><code class="p">)</code><code> </code><code class="p">{</code><code class="p">}</code><code>&#13;
  </code><strong><code class="nx">then</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code><code> </code><code class="nx">F</code><code> </code><code class="kr">extends</code><code> </code><code class="nb">Error</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">g</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">result</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code><code> </code><code class="nx">F</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code><code> </code><code class="nx">F</code><code class="o">&gt;</code><code>&#13;
  </code><code class="k">catch</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code><code> </code><code class="nx">F</code><code> </code><code class="kr">extends</code><code> </code><code class="nb">Error</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">g</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">error</code><code>: </code><code class="kt">E</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code><code> </code><code class="nx">F</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">U</code><code class="p">,</code><code> </code><code class="nx">F</code><code class="o">&gt;</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p><code>then</code> and <code>catch</code> are two ways to sequence <code>Promise</code>s: <code>then</code> maps a successful result of a <code>Promise</code> to a new <code>Promise</code>,<sup><a data-type="noteref" href="ch08.html#idm46304958643512" id="idm46304958643512-marker">2</a></sup> and <code>catch</code> recovers from a rejection by mapping an error to a new <code>Promise</code>.</p>&#13;
&#13;
<p>Using <code>then</code> looks<a data-primary="then clause" data-type="indexterm" id="idm46304958709352"/> like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="nx">TypeError</code><code class="o">&gt;</code> <code class="o">=</code> <code class="c1">// ...</code>&#13;
<code class="kd">let</code> <code class="nx">b</code><code class="o">:</code> <code class="p">(</code><code class="nx">s</code>: <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">,</code> <code class="nx">never</code><code class="o">&gt;</code> <code class="o">=</code> <code class="c1">// ...</code>&#13;
<code class="kd">let</code> <code class="nx">c</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kr">boolean</code><code class="p">,</code> <code class="nx">RangeError</code><code class="o">&gt;</code> <code class="o">=</code> <code class="c1">// ...</code>&#13;
&#13;
<code class="nx">a</code><code class="p">()</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">b</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">c</code><code class="p">())</code> <code class="c1">// b won't error, so this is if a errors</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">result</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Done'</code><code class="p">,</code> <code class="nx">result</code><code class="p">))</code>&#13;
  <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'Error'</code><code class="p">,</code> <code class="nx">e</code><code class="p">))</code></pre>&#13;
&#13;
<p>Because the type of <code>b</code>’s second type argument is <code>never</code> (meaning <code>b</code> will never throw an error), the <a data-primary="catch clause" data-type="indexterm" id="idm46304958456216"/>first <code>catch</code> clause will only get called if <code>a</code> errors. But notice that when we use a <code>Promise</code>, we don’t have to care about the fact that <code>a</code> might throw but <code>b</code> won’t—if <code>a</code> succeeds then we map the <code>Promise</code> to <code>b</code>, and otherwise we jump to the first <code>catch</code> clause and map the <code>Promise</code> to <code>c</code>. If <code>c</code> succeeds then we log <code>Done</code>, and if it rejects then we <code>catch</code> again.<a data-primary="try/catch statements" data-type="indexterm" id="idm46304958449128"/> This mimics how regular old <code>try</code>/<code>catch</code> statements work, and does for asynchronous tasks what <code>try</code>/<code>catch</code> does for synchronous ones (see <a data-type="xref" href="#promise-state-fig">Figure 8-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="promise-state-fig">&#13;
<img alt="prts 0802" src="assets/prts_0802.png"/>&#13;
<h6><span class="label">Figure 8-2. </span>The Promise state machine</h6>&#13;
</div></figure>&#13;
&#13;
<p>We also have to handle the case of <code>Promise</code>s that throw actual exceptions (as in, <code>throw Error('foo')</code>).<a data-primary="exceptions" data-secondary="throwing" data-tertiary="in Promises" data-type="indexterm" id="idm46304958442600"/><a data-primary="errors" data-secondary="handling" data-tertiary="in Promises" data-type="indexterm" id="idm46304958441320"/> When we implement <code>then</code> and <code>catch</code>, we’ll do this by wrapping code in <code>try</code>/<code>catch</code>es and rejecting in the <code>catch</code> clause. This does have a few implications, though. It means that:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Every <code>Promise</code> has the potential to reject, and we can’t statically check for this (because TypeScript doesn’t support indicating in a function’s signature which exceptions the function might throw).<a data-primary="promises" data-secondary="Promise implementation" data-tertiary="rejecting Promises with an error" data-type="indexterm" id="idm46304958436152"/></p>&#13;
</li>&#13;
<li>&#13;
<p>A <code>Promise</code> won’t always be rejected with an <code>Error</code>. Because TypeScript has no choice but to inherit JavaScript’s behavior, and in JavaScript when you <code>throw</code> you can throw anything—a string, a function, an array, a <code>Promise</code>, and not necessarily an <code>Error</code>—we can’t assume that a rejection will be a subtype of <code>Error</code>. It’s unfortunate, but this is a sacrifice we’ll make in the name of not having to force consumers to <code>try/catch</code> every promise chain (which might be spread across multiple files or modules!).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Taking that into account, let’s loosen our <code>Promise</code> type a bit by not typing errors:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Executor</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="nx">resolve</code><code class="o">:</code> <code class="p">(</code><code class="nx">result</code>: <code class="kt">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">,</code>&#13;
  <code class="nx">reject</code><code class="o">:</code> <code class="p">(</code><code class="nx">error</code>: <code class="kt">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
<code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code><code class="nx">f</code>: <code class="kt">Executor</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{}</code>&#13;
  <code class="nx">then</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">g</code><code class="o">:</code> <code class="p">(</code><code class="nx">result</code>: <code class="kt">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">catch</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">g</code><code class="o">:</code> <code class="p">(</code><code class="nx">error</code>: <code class="kt">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We now have a fully baked <code>Promise</code> interface.</p>&#13;
&#13;
<p>I’ll leave it as an exercise for you to hook it all together with implementations for <code>then</code> and <code>catch</code>. The implementation for <code>Promise</code> is notoriously tricky to write correctly—if you’re ambitious and have a couple of hours free, head over to the <a href="http://bit.ly/2JT3KUh">ES2015 specification</a> for a walkthrough of how <code>Promise</code>’s state machine should work under the hood.<a data-primary="promises" data-startref="ix_prom" data-type="indexterm" id="idm46304958280232"/><a data-primary="asynchronous programming" data-secondary="promises" data-startref="ix_asyncprom" data-type="indexterm" id="idm46304958279256"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="async and await" data-type="sect1"><div class="sect1" id="idm46304959250344">&#13;
<h1>async and await</h1>&#13;
&#13;
<p>Promises are a really powerful abstraction for working with asynchronous code. They’re such a popular pattern that they even have their own JavaScript (and therefore, TypeScript) syntax: <code>async</code> and <code>await</code>.<a data-primary="asynchronous programming" data-secondary="async and await" data-type="indexterm" id="idm46304958275944"/><a data-primary="async and await syntax" data-type="indexterm" id="idm46304958274968"/><a data-primary="promises" data-secondary="using async and await with" data-type="indexterm" id="idm46304958274296"/> This syntax lets you interact with asynchronous operations the same way you do with synchronous ones.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Think of <code>await</code> as language-level syntax sugar for <code>.then</code>. When you <code>await</code> a <code>Promise</code>, you have to do so in an <code>async</code> block. And instead of <code>.catch</code>, you can wrap your <code>await</code> in a regular <code>try</code>/<code>catch</code> block.<a data-primary="then  clause" data-secondary="using async and await instead of" data-type="indexterm" id="idm46304958267928"/></p>&#13;
</div>&#13;
&#13;
<p>Let’s say you have<a data-primary="finally clause" data-type="indexterm" id="idm46304958266248"/> the following promise (we didn’t cover <code>finally</code> in the previous section, but it behaves the way you think it would, firing after both <code>then</code> and <code>catch</code> have a<a data-primary="catch clause" data-type="indexterm" id="idm46304958264136"/> chance to fire):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">getUser() {</code>&#13;
  <code class="nx">getUserID</code><code class="p">(</code><code class="mi">18</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">user</code> <code class="o">=&gt;</code> <code class="nx">getLocation</code><code class="p">(</code><code class="nx">user</code><code class="p">))</code>&#13;
    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">location</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'got location'</code><code class="p">,</code> <code class="nx">location</code><code class="p">))</code>&#13;
    <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">error</code><code class="p">))</code>&#13;
    <code class="p">.</code><code class="k">finally</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'done getting location'</code><code class="p">))</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To convert this code to <code>async</code> and <code>await</code>, first put it in an <code>async</code> function, then <code>await</code> the promise’s result:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="nx">async</code></strong><code> </code><code class="kd">function</code><code> </code><code class="nx">getUser() {</code><code>&#13;
  </code><code class="k">try</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="kd">let</code><code> </code><code class="nx">user</code><code> </code><code class="o">=</code><code> </code><strong><code class="nx">await</code></strong><code> </code><code class="nx">getUserID</code><code class="p">(</code><code class="mi">18</code><code class="p">)</code><code>&#13;
    </code><code class="kd">let</code><code> </code><code class="nx">location</code><code> </code><code class="o">=</code><code> </code><strong><code class="nx">await</code></strong><code> </code><code class="nx">getLocation</code><code class="p">(</code><code class="nx">user</code><code class="p">)</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'got location'</code><code class="p">,</code><code> </code><code class="nx">user</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code> </code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">error</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code> </code><code class="k">finally</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'done getting location'</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Since <code>async</code> and <code>await</code> are JavaScript features, we won’t go into them in depth here—suffice it to say that TypeScript has full support for them, and they are completely typesafe. Use them whenever you work with promises, to make it easier to reason about chained operations and avoid lots of <code>then</code>s. To learn more about <code>async</code> and <code>await</code>, head over to their documentation on <a href="https://mzl.la/2TJLFYt">MDN</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Async Streams" data-type="sect1"><div class="sect1" id="idm46304958064824">&#13;
<h1>Async Streams</h1>&#13;
&#13;
<p>While promises are fantastic for modeling, sequencing, and composing future values, what if you have multiple values,<a data-primary="asynchronous programming" data-secondary="async streams" data-type="indexterm" id="ix_asyncstrm"/> which will become available at multiple points in the future? This is less exotic than it sounds—think bits of a file being read from the filesystem, pixels of a video streaming over the internet from the Netflix server to your laptop, a bunch of keystrokes as you fill out a form, some friends coming over to your house for a dinner party, or votes being deposited into a ballot box throughout the course of Super Tuesday. While these things may sound pretty different on the surface, you can look at them all as asynchronous streams; they are all lists of things where each thing comes in at some point in the future.<a data-primary="event emitters" data-type="indexterm" id="ix_evem"/></p>&#13;
&#13;
<p>There are a few ways to model this, <a data-primary="NodeJS" data-secondary="EventEmitter" data-type="indexterm" id="idm46304958059720"/><a data-primary="reactive programming libraries" data-type="indexterm" id="idm46304958058744"/><a data-primary="RxJS library" data-type="indexterm" id="idm46304958040104"/>the most common being with an event emitter (like NodeJS’s <code>EventEmitter</code>) or with a reactive programming library like <a href="https://www.npmjs.com/package/@reactivex/rxjs">RxJS</a>.<sup><a data-type="noteref" href="ch08.html#idm46304958038360" id="idm46304958038360-marker">3</a></sup> The difference between the two is like the difference between callbacks and promises: events are quick and lightweight, while reactive programming libraries are more powerful, and give you the ability to compose and sequence streams of events.</p>&#13;
&#13;
<p>We’ll go over event emitters in the following section. To learn more about reactive programming, head over to the documentation for your favorite reactive programming library—for example, <a href="https://www.npmjs.com/package/@reactivex/rxjs">RxJS</a>, <a href="https://github.com/mostjs/core">MostJS</a>, or  <a href="https://www.npmjs.com/package/xstream">xstream</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Event Emitters" data-type="sect2"><div class="sect2" id="event-emitters">&#13;
<h2>Event Emitters</h2>&#13;
&#13;
<p>At a high level, event emitters offer APIs<a data-primary="asynchronous programming" data-secondary="async streams" data-tertiary="event emitters" data-type="indexterm" id="ix_asyncstrmevem"/><a data-primary="channels, emitting events on" data-type="indexterm" id="idm46304958029016"/> that support emitting events on a channel and listening for events on that channel:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nx">Emitter</code> <code class="p">{</code>&#13;
&#13;
  <code class="c1">// Send an event</code>&#13;
  <code class="nx">emit</code><code class="p">(</code><code class="nx">channel</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">value</code>: <code class="kt">unknown</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
&#13;
  <code class="c1">// Do something when an event is sent</code>&#13;
  <code class="nx">on</code><code class="p">(</code><code class="nx">channel</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">value</code>: <code class="kt">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Event emitters are a popular design pattern in JavaScript. You might have encountered them when using DOM events, JQuery events, or NodeJS’s <code>EventEmitter</code> <span class="keep-together">module</span>.</p>&#13;
&#13;
<p>In most languages, event emitters like this one are unsafe. That’s because the type of <code>value</code> depends on the specific <code>channel</code>, and in most languages you can’t use types to represent that relationship. Unless your language supports both overloaded function signatures and literal types, you’re going to have trouble saying “this is the type of event emitted on this channel.” Macros that generate methods to emit events and listen on each channel are a common workaround to this problem, but in TypeScript,  you can express this naturally and safely using the type system.</p>&#13;
&#13;
<p>For example, say we’re using the <a href="https://github.com/NodeRedis/node_redis">NodeRedis client</a>, a Node API for the popular Redis in-memory datastore.<a data-primary="Node API for Redis" data-type="indexterm" id="idm46304957986648"/><a data-primary="Redis library, using" data-type="indexterm" id="idm46304957985944"/> It works like this:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kr">import</code> <code class="nx">Redis</code> <code class="nx">from</code> <code class="s1">'redis'</code>&#13;
&#13;
<code class="c1">// Create a new instance of a Redis client</code>&#13;
<code class="kd">let</code> <code class="nx">client</code> <code class="o">=</code> <code class="nx">redis</code><code class="p">.</code><code class="nx">createClient</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Listen for a few events emitted by the client</code>&#13;
<code class="nx">client</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'ready'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Client is ready'</code><code class="p">))</code>&#13;
<code class="nx">client</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'error'</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'An error occurred!'</code><code class="p">,</code> <code class="nx">e</code><code class="p">))</code>&#13;
<code class="nx">client</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'reconnecting'</code><code class="p">,</code> <code class="nx">params</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Reconnecting...'</code><code class="p">,</code> <code class="nx">params</code><code class="p">))</code>&#13;
</pre>&#13;
&#13;
<p>As programmers using the Redis library, we want to know what types of arguments to expect in our callbacks when we use the <code>on</code> API. But because the type of each argument depends on the channel that Redis emits on, a single type won’t cut it. If we were the authors of this library, the simplest way to achieve safety would be with an overloaded type:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">RedisClient</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">on</code><code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="s1">'ready'</code><code class="p">,</code> <code class="nx">f</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
  <code class="nx">on</code><code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="s1">'error'</code><code class="p">,</code> <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">e</code>: <code class="kt">Error</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
  <code class="nx">on</code><code class="p">(</code><code class="nx">event</code><code class="o">:</code> <code class="s1">'reconnecting'</code><code class="p">,</code>&#13;
     <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">params</code><code class="o">:</code> <code class="p">{</code><code class="nx">attempt</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">delay</code>: <code class="kt">number</code><code class="p">})</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This works pretty well, but it’s a bit wordy.<a data-primary="mapped types" data-secondary="using to build typesafe event emitters" data-type="indexterm" id="idm46304957894184"/> Let’s express it in terms of a mapped type (see <a data-type="xref" href="ch06.html#mapped-types">“Mapped Types”</a>), pulling out the event definitions into their own type, <code>Events</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Events</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO1-1" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">ready</code><code>: </code><code class="kt">void</code><code>&#13;
  </code><code class="nx">error</code><code>: </code><code class="kt">Error</code><code>&#13;
  </code><code class="nx">reconnecting</code><code class="o">:</code><code> </code><code class="p">{</code><code class="nx">attempt</code><code>: </code><code class="kt">number</code><code class="p">,</code><code> </code><code class="nx">delay</code><code>: </code><code class="kt">number</code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="nx">type</code><code> </code><code class="nx">RedisClient</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO1-2" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">on</code><code class="o">&lt;</code><code class="nx">E</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">Events</code><code class="o">&gt;</code><code class="p">(</code><code>&#13;
    </code><code class="nx">event</code><code>: </code><code class="kt">E</code><code class="p">,</code><code>&#13;
    </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">arg</code><code>: </code><code class="kt">Events</code><code class="p">[</code><code class="nx">E</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code>&#13;
  </code><code class="p">)</code><code class="o">:</code><code> </code><code class="k">void</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO1-1" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We start by defining a single object type that enumerates every event the Redis client might emit, along with the arguments for that event.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO1-2" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We map over our <code>Events</code> type, telling TypeScript that <code>on</code> can be called with any of the events we defined.</p></dd>&#13;
</dl>&#13;
&#13;
<p>We can then use this type to make the Node–Redis library safer, by typing both of its methods—<code>emit</code> and <code>on</code>—as safely as possible:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// ...</code>&#13;
<code class="nx">type</code> <code class="nx">RedisClient</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">on</code><code class="o">&lt;</code><code class="nx">E</code> <code class="kr">extends</code> <code class="nx">keyof</code> <code class="nx">Events</code><code class="o">&gt;</code><code class="p">(</code>&#13;
    <code class="nx">event</code>: <code class="kt">E</code><code class="p">,</code>&#13;
    <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">arg</code>: <code class="kt">Events</code><code class="p">[</code><code class="nx">E</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
  <code class="nx">emit</code><code class="o">&lt;</code><code class="nx">E</code> <code class="kr">extends</code> <code class="nx">keyof</code> <code class="nx">Events</code><code class="o">&gt;</code><code class="p">(</code>&#13;
    <code class="nx">event</code>: <code class="kt">E</code><code class="p">,</code>&#13;
    <code class="nx">arg</code>: <code class="kt">Events</code><code class="p">[</code><code class="nx">E</code><code class="p">]</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This pattern of pulling out event names and arguments into a shape and mapping over that shape to generate listeners and emitters<a data-primary="listeners, creating" data-type="indexterm" id="idm46304957632760"/> is common in real-world TypeScript code. It’s also terse, and very safe. When an emitter is typed this way you can’t misspell a key, mistype an argument, or forget to pass in an argument. It also serves as documentation for engineers using your code, as their code editors will suggest to them the possible events they might listen on and the types of parameters in those events’ callbacks.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304957608856">&#13;
<h5>Emitters in the Wild</h5>&#13;
<p>Using mapped types to build typesafe event emitters is a popular pattern. For example, it’s how DOM events are <a data-primary="DOM (Document Object Model)" data-secondary="events, typed in TypeScript standard library" data-type="indexterm" id="idm46304957607272"/>typed in TypeScript’s standard library. <code>WindowEventMap</code> is a mapping <a data-primary="WindowEventMap interface" data-type="indexterm" id="idm46304957605848"/>from event name to event type, which the <code>.addEventListener</code> and <span class="keep-together"><code>.removeEventListener</code></span> APIs map over to produce better, more specific event types than the default <code>Event</code> type:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// lib.dom.ts</code>&#13;
<code class="kr">interface</code> <code class="nx">WindowEventMap</code> <code class="kr">extends</code> <code class="nx">GlobalEventHandlersEventMap</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
  <code class="nx">contextmenu</code>: <code class="kt">PointerEvent</code>&#13;
  <code class="nx">dblclick</code>: <code class="kt">MouseEvent</code>&#13;
  <code class="nx">devicelight</code>: <code class="kt">DeviceLightEvent</code>&#13;
  <code class="nx">devicemotion</code>: <code class="kt">DeviceMotionEvent</code>&#13;
  <code class="nx">deviceorientation</code>: <code class="kt">DeviceOrientationEvent</code>&#13;
  <code class="nx">drag</code>: <code class="kt">DragEvent</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">interface</code> <code class="nx">Window</code> <code class="kr">extends</code> <code class="nx">EventTarget</code><code class="p">,</code> <code class="nx">WindowTimers</code><code class="p">,</code> <code class="nx">WindowSessionStorage</code><code class="p">,</code>&#13;
  <code class="nx">WindowLocalStorage</code><code class="p">,</code> <code class="nx">WindowConsole</code><code class="p">,</code> <code class="nx">GlobalEventHandlers</code><code class="p">,</code> <code class="nx">IDBEnvironment</code><code class="p">,</code>&#13;
  <code class="nx">WindowBase64</code><code class="p">,</code> <code class="nx">GlobalFetch</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
  <code class="nx">addEventListener</code><code class="o">&lt;</code><code class="nx">K</code> <code class="kr">extends</code> <code class="nx">keyof</code> <code class="nx">WindowEventMap</code><code class="o">&gt;</code><code class="p">(</code>&#13;
    <code class="nx">type</code>: <code class="kt">K</code><code class="p">,</code>&#13;
    <code class="nx">listener</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">Window</code><code class="p">,</code> <code class="nx">ev</code>: <code class="kt">WindowEventMap</code><code class="p">[</code><code class="nx">K</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">,</code>&#13;
    <code class="nx">options?</code>: <code class="kt">boolean</code> <code class="o">|</code> <code class="nx">AddEventListenerOptions</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
  <code class="nx">removeEventListener</code><code class="o">&lt;</code><code class="nx">K</code> <code class="kr">extends</code> <code class="nx">keyof</code> <code class="nx">WindowEventMap</code><code class="o">&gt;</code><code class="p">(</code>&#13;
    <code class="nx">type</code>: <code class="kt">K</code><code class="p">,</code>&#13;
    <code class="nx">listener</code><code class="o">:</code> <code class="p">(</code><code class="k">this</code><code class="o">:</code> <code class="nx">Window</code><code class="p">,</code> <code class="nx">ev</code>: <code class="kt">WindowEventMap</code><code class="p">[</code><code class="nx">K</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">,</code>&#13;
    <code class="nx">options?</code>: <code class="kt">boolean</code> <code class="o">|</code> <code class="nx">EventListenerOptions</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Typesafe Multithreading" data-type="sect1"><div class="sect1" id="idm46304958031560">&#13;
<h1>Typesafe Multithreading</h1>&#13;
&#13;
<p>So far, we’ve been talking about asynchronous programs that you might run on a single CPU thread,<a data-primary="asynchronous programming" data-secondary="async streams" data-startref="ix_asyncstrmevem" data-tertiary="event emitters" data-type="indexterm" id="idm46304957600856"/><a data-primary="event emitters" data-type="indexterm" id="idm46304957421064"/><a data-primary="asynchronous programming" data-secondary="asynchronous streams" data-startref="ix_asyncstrm" data-type="indexterm" id="idm46304957420504"/><a data-primary="asynchronous programming" data-startref="ix_async" data-type="indexterm" id="idm46304957419320"/> a class of programs that most JavaScript and TypeScript programs you’ll write will likely fall into. <a data-primary="multithreading" data-type="indexterm" id="ix_mltithr"/>But sometimes, when doing CPU-intensive tasks, you might opt for true parallelism: the ability to split out work across multiple threads, in order to do it faster or to keep your main thread idle and responsive.<a data-primary="parallelism" data-seealso="multithreading" data-type="indexterm" id="idm46304957416856"/> In this section, we’ll explore a few patterns for writing safe, parallel programs in the browser and on the server.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="In the Browser: With Web Workers" data-type="sect2"><div class="sect2" id="web-workers">&#13;
<h2>In the Browser: With Web Workers</h2>&#13;
&#13;
<p>Web Workers are a widely supported way to do multithreading in the browser.<a data-primary="multithreading" data-secondary="in the browser with Web Workers" data-type="indexterm" id="ix_mltithrbrWW"/><a data-primary="browsers" data-secondary="typesafe multithreading with Web Workers" data-type="indexterm" id="ix_brwsmltithr"/><a data-primary="Web Workers, typesafe multithreading with" data-type="indexterm" id="ix_WebWrk"/> You spin up some workers—special restricted background threads—from the main JavaScript thread, and use them to do things that would have otherwise blocked the main thread and made the UI unresponsive (i.e., CPU-bound tasks). Web Workers are a way to run code in the browser in a truly parallel way; while asynchronous APIs like <code>Promise</code> and <code>setTimeout</code> run code concurrently, Workers give you the ability to run code in parallel, on another CPU thread. Web Workers can send network requests, write to the filesystem, and so on, with a few minor restrictions.</p>&#13;
&#13;
<p>Because Web Workers are a browser-provided API, its designers put a lot of emphasis on safety—not type safety like we know and<a data-primary="memory safety" data-type="indexterm" id="idm46304957407880"/> love, but <em>memory safety</em>. Anyone that’s written C, C++, Objective C, or multithreaded Java or Scala knows the pitfalls of concurrently manipulating shared memory. When you have multiple threads reading from and writing to the same piece of memory, it’s really easy to run into all sorts of concurrency issues like nondeterminism, deadlocks, and so on.</p>&#13;
&#13;
<p>Because browser code must be particularly safe, and minimize the chances of crashing the browser and causing a poor user experience, the primary way to communicate between the main thread and Web Workers, and between Web Workers and other Web Workers, is with <em>message passing</em>.<a data-primary="message passing (Web Workers)" data-type="indexterm" id="idm46304957405176"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To follow along with the examples in this section, be sure to tell TSC that you’re planning to run this<a data-primary="dom library for TSC" data-type="indexterm" id="idm46304957403080"/><a data-primary="TSC compiler" data-secondary="enabling dom lib for" data-type="indexterm" id="idm46304957402376"/> code in a browser by enabling the <code>dom</code> lib in your <em>tsconfig.json</em>:</p>&#13;
<pre class="c_less_space" data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"lib"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"dom"</code><code class="p">,</code> <code class="s2">"es2015"</code><code class="p">]</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>And for the code that you’re<a data-primary="TSC compiler" data-secondary="enabling webworker lib for" data-type="indexterm" id="idm46304957389160"/> running in a Web Worker, use the <code>webworker</code> lib:</p>&#13;
<pre class="c_less_space" data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"lib"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"webworker"</code><code class="p">,</code> <code class="s2">"es2015"</code><code class="p">]</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>If you’re using a single <em>tsconfig.json</em> for both your Web Worker script and your main thread, enable both at once.</p>&#13;
</div>&#13;
&#13;
<p>The message passing API works like this.<a data-primary="message passing (Web Workers)" data-secondary="message passing API" data-type="indexterm" id="idm46304957341032"/><a data-primary="Web Workers, typesafe multithreading with" data-secondary="message passing API" data-type="indexterm" id="idm46304957340184"/> You first spawn a web worker from a thread:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// MainThread.ts</code>&#13;
<code class="kd">let</code> <code class="nx">worker</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Worker</code><code class="p">(</code><code class="s1">'WorkerScript.js'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Then, you pass messages to that worker:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="c1">// MainThread.ts</code></em><code class="c1">&#13;
</code><code class="kd">let</code><code> </code><code class="nx">worker</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">Worker</code><code class="p">(</code><code class="s1">'WorkerScript.js'</code><code class="p">)</code><code>&#13;
&#13;
</code><strong><code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="s1">'some data'</code><code class="p">)</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>You can pass almost any kind of data to another thread with the <code>postMessage</code> API.<sup><a data-type="noteref" href="ch08.html#idm46304957247912" id="idm46304957247912-marker">4</a></sup></p>&#13;
&#13;
<p>The main thread will clone the data you pass before handing it off to the worker thread.<sup><a data-type="noteref" href="ch08.html#idm46304957246136" id="idm46304957246136-marker">5</a></sup> On <a data-primary="Web Workers, typesafe multithreading with" data-secondary="onmessage API" data-type="indexterm" id="idm46304957243624"/><a data-primary="message passing (Web Workers)" data-secondary="onmessage API" data-type="indexterm" id="idm46304957242680"/>the Web Worker side, you listen to incoming events with the globally available <code>onmessage</code> API:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// WorkerScript.ts</code>&#13;
<code class="nx">onmessage</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">data</code><code class="p">)</code> <code class="c1">// Logs out 'some data'</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To communicate in the opposite direction—from the worker back to the main thread—you use the globally available <code>postMessage</code> to send a message to the main thread, and the <code>.onmessage</code> method in the main thread to listen for incoming messages.<a data-primary="listeners, creating" data-secondary="onmessage API in Web Workers" data-type="indexterm" id="idm46304957215176"/> To put it all together:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// MainThread.ts</code>&#13;
<code class="kd">let</code> <code class="nx">worker</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Worker</code><code class="p">(</code><code class="s1">'WorkerScript.js'</code><code class="p">)</code>&#13;
<code class="nx">worker</code><code class="p">.</code><code class="nx">onmessage</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">data</code><code class="p">)</code> <code class="c1">// Logs out 'Ack: "some data"'</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="s1">'some data'</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// WorkerScript.ts</code>&#13;
<code class="nx">onmessage</code> <code class="o">=</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">data</code><code class="p">)</code> <code class="c1">// Logs out 'some data'</code>&#13;
  <code class="nx">postMessage</code><code class="p">(</code><code class="nx">Ack</code><code class="o">:</code> <code class="s2">"${e.data}"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This API is a lot like the event emitter API we looked at in <a data-type="xref" href="#event-emitters">“Event Emitters”</a>. It’s a simple way to pass messages around, but without types, we don’t know that we’ve correctly handled all the possible types of messages that might be sent.<a data-primary="event emitters" data-secondary="using in multithreading with Web Workers" data-type="indexterm" id="ix_evemmlti"/></p>&#13;
&#13;
<p>Since this API is really just an event emitter, we can apply the same techniques as for regular event emitters to type it. For example, let’s build a simple messaging layer for a chat client, which we’ll run in a worker thread. The messaging layer will push updates to the main thread, and we won’t worry about things like error handling, permissions, and so on. We’ll start by defining some incoming and outgoing message types (the main thread sends <code>Commands</code> to the worker thread, and the worker thread send <code>Events</code> back to the main thread):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// MainThread.ts</code>&#13;
<code class="nx">type</code> <code class="nx">Message</code> <code class="o">=</code> <code class="kt">string</code>&#13;
<code class="nx">type</code> <code class="nx">ThreadID</code> <code class="o">=</code> <code class="kt">number</code>&#13;
<code class="nx">type</code> <code class="nx">UserID</code> <code class="o">=</code> <code class="kt">number</code>&#13;
<code class="nx">type</code> <code class="nx">Participants</code> <code class="o">=</code> <code class="nx">UserID</code><code class="p">[]</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">Commands</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">sendMessageToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">Message</code><code class="p">]</code>&#13;
  <code class="nx">createThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">Participants</code><code class="p">]</code>&#13;
  <code class="nx">addUserToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
  <code class="nx">removeUserFromThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">Events</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">receivedMessage</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">,</code> <code class="nx">Message</code><code class="p">]</code>&#13;
  <code class="nx">createdThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">Participants</code><code class="p">]</code>&#13;
  <code class="nx">addedUserToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
  <code class="nx">removedUserFromThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>How could we apply these types to the Web Worker messaging API? The simplest way might be to define a union of all possible message types, then switch on the <code>Message</code> type.<a data-primary="| (pipe symbol), for union types" data-type="indexterm" id="idm46304957103512"/> But this can get pretty tedious. For our <code>Command</code> type, it might look something like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// WorkerScript.ts&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Command</code><code> </code><code class="o">=</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-1" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="o">|</code><code> </code><code class="p">{</code><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'sendMessageToThread'</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="o">:</code><code> </code><code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code><code> </code><code class="nx">Message</code><code class="p">]</code><code class="p">}</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-2" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="o">|</code><code> </code><code class="p">{</code><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'createThread'</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="o">:</code><code> </code><code class="p">[</code><code class="nx">Participants</code><code class="p">]</code><code class="p">}</code><code>&#13;
  </code><code class="o">|</code><code> </code><code class="p">{</code><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'addUserToThread'</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="o">:</code><code> </code><code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code><code> </code><code class="nx">UserID</code><code class="p">]</code><code class="p">}</code><code>&#13;
  </code><code class="o">|</code><code> </code><code class="p">{</code><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'removeUserFromThread'</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="o">:</code><code> </code><code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code><code> </code><code class="nx">UserID</code><code class="p">]</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="nx">onmessage</code><code> </code><code class="o">=</code><code> </code><code class="nx">e</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-3" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="nx">processCommandFromMainThread</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">data</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">processCommandFromMainThread</code><code class="p">(</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-4" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="nx">command</code><code>: </code><code class="kt">Command</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">switch</code><code> </code><code class="p">(</code><code class="nx">command</code><code class="p">.</code><code class="nx">type</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-5" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
    </code><code class="k">case</code><code> </code><code class="s1">'sendMessageToThread'</code><code class="o">:</code><code>&#13;
      </code><code class="kd">let</code><code> </code><code class="p">[</code><code class="nx">threadID</code><code class="p">,</code><code> </code><code class="nx">message</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="nx">command</code><code class="p">.</code><code class="nx">data</code><code>&#13;
      </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code>&#13;
    </code><code class="c1">// ...&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-1" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We define a union of all possible commands that the main thread might send to a worker thread, along with the arguments for each command.<a data-primary="union types" data-secondary="defining for communication among threads" data-type="indexterm" id="idm46304956781320"/></p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-2" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This is just a regular union type. When defining long union types, leading with pipes (<code>|</code>) can make those types easier to read.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-3" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>We take messages sent over the untyped <code>onmessage</code> API, and delegate handling them to our typed <code>processCommandFromMainThread</code> API.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-4" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p><code>processCommandFromMainThread</code> takes care of handling all incoming messages from the main thread. It’s a safe, typed wrapper for the untyped <code>onmessage</code> API.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-5" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Since the <code>Command</code> type is a discriminated union type (see [[discriminated unions]]), we use a <code>switch</code> to exhaustively handle every possible type of message the main thread might send our way.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Let’s abstract Web Workers’ snowflake API behind a familiar <code>EventEmitter</code>-based API. That way we can cut down on the verbosity of our incoming and outgoing message types.<a data-primary="Web Workers, typesafe multithreading with" data-secondary="abstracting snowflake API behind EvenEmitter-based API" data-type="indexterm" id="idm46304956752440"/></p>&#13;
&#13;
<p>We’ll start by constructing <a data-primary="NodeJS" data-secondary="EventEmitter" data-type="indexterm" id="idm46304956751208"/>a typesafe wrapper for NodeJS’s <code>EventEmitter</code> API (which is available for the browser under the <a href="https://www.npmjs.com/package/events"><code>events</code> package</a> on NPM):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code><code> </code><code class="nx">EventEmitter</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'events'</code><code>&#13;
&#13;
</code><code class="kr">class</code><code> </code><code class="nx">SafeEmitter</code><code class="o">&lt;</code><code>&#13;
  </code><code class="nx">Events</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Record</code><code class="o">&lt;</code><code class="nx">PropertyKey</code><code class="p">,</code><code> </code><code class="nx">unknown</code><code class="p">[</code><code class="p">]</code><code class="o">&gt;</code><code>  </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-1" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">private</code><code> </code><code class="nx">emitter</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">EventEmitter</code><code>  </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-2" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">emit</code><code class="o">&lt;</code><code class="nx">K</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">Events</code><code class="o">&gt;</code><code class="p">(</code><code>  </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-3" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="nx">channel</code><code>: </code><code class="kt">K</code><code class="p">,</code><code>&#13;
    </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">data</code><code>: </code><code class="kt">Events</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code>&#13;
  </code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">emitter</code><code class="p">.</code><code class="nx">emit</code><code class="p">(</code><code class="nx">channel</code><code class="p">,</code><code> </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">data</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="nx">on</code><code class="o">&lt;</code><code class="nx">K</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">Events</code><code class="o">&gt;</code><code class="p">(</code><code>  </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-4" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><code class="nx">channel</code><code>: </code><code class="kt">K</code><code class="p">,</code><code>&#13;
    </code><code class="nx">listener</code><code class="o">:</code><code> </code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">data</code><code>: </code><code class="kt">Events</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code>&#13;
  </code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">return</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">emitter</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="nx">channel</code><code class="p">,</code><code> </code><code class="nx">listener</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-1" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>SafeEmitter</code> declares a generic type <code>Events</code>, a <code>Record</code> mapping from <code>PropertyKey</code> (TypeScript’s built-in type for valid object keys: <code>string</code>, <code>number</code>, or <code>Symbol</code>) to a list of parameters.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-2" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We declare <code>emitter</code> as a private member on <code>SafeEmitter</code>. We do this instead of extending <code>SafeEmitter</code> because our signatures for <code>emit</code> and <code>on</code> are more restrictive than their overloaded counterparts in <code>EventEmitter</code>, and since functions are contravariant in their parameters (remember, for a function <code>a</code> to be assignable to another function <code>b</code> its parameters have to be supertypes of their counterparts in <code>b</code>) TypeScript won’t let us declare these overloads.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-3" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>emit</code> takes a <code>channel</code> plus arguments corresponding to the list of parameters we defined in the <code>Events</code> type.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-4" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Similarly, <code>on</code> takes a <code>channel</code> and a <code>listener</code>. <code>listener</code> takes a variable number of arguments corresponding to the list of parameters we defined in the <code>Events</code> type.</p></dd>&#13;
</dl>&#13;
&#13;
<p>We can use <code>SafeEmitter</code> to dramatically cut down on the boilerplate it takes to safely implement a listening layer. On the worker side, we delegate all <code>onmessage</code> calls to our emitter and expose a convenient and safe listener API to consumers:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="c1">// WorkerScript.ts</code>&#13;
<code class="nx">type</code> <code class="nx">Commands</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">sendMessageToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">Message</code><code class="p">]</code>&#13;
  <code class="nx">createThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">Participants</code><code class="p">]</code>&#13;
  <code class="nx">addUserToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
  <code class="nx">removeUserFromThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">Events</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">receivedMessage</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">,</code> <code class="nx">Message</code><code class="p">]</code>&#13;
  <code class="nx">createdThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">Participants</code><code class="p">]</code>&#13;
  <code class="nx">addedUserToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
  <code class="nx">removedUserFromThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Listen for events coming from the main thread</code>&#13;
<code class="kd">let</code> <code class="nx">commandEmitter</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SafeEmitter</code>	<code class="o">&lt;</code><code class="nx">Commands</code><code class="o">&gt;</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Emit events back to the main thread</code>&#13;
<code class="kd">let</code> <code class="nx">eventEmitter</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SafeEmitter</code>	<code class="o">&lt;</code><code class="nx">Events</code><code class="o">&gt;</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// Wrap incoming commands from the main thread</code>&#13;
<code class="c1">// using our typesafe event emitter</code>&#13;
<code class="nx">onmessage</code> <code class="o">=</code> <code class="nx">command</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">commandEmitter</code><code class="p">.</code><code class="nx">emit</code><code class="p">(</code>&#13;
    <code class="nx">command</code><code class="p">.</code><code class="nx">data</code><code class="p">.</code><code class="nx">type</code><code class="p">,</code>&#13;
    <code class="p">...</code><code class="nx">command</code><code class="p">.</code><code class="nx">data</code><code class="p">.</code><code class="nx">data</code>&#13;
  <code class="p">)</code>&#13;
&#13;
<code class="c1">// Listen for events issued by the worker, and send them to the main thread</code>&#13;
<code class="nx">eventEmitter</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'receivedMessage'</code><code class="p">,</code> <code class="nx">data</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">postMessage</code><code class="p">({</code><code class="nx">type</code><code class="o">:</code> <code class="s1">'receivedMessage'</code><code class="p">,</code> <code class="nx">data</code><code class="p">})</code>&#13;
<code class="p">)</code>&#13;
<code class="nx">eventEmitter</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'createdThread'</code><code class="p">,</code> <code class="nx">data</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">postMessage</code><code class="p">({</code><code class="nx">type</code><code class="o">:</code> <code class="s1">'createdThread'</code><code class="p">,</code> <code class="nx">data</code><code class="p">})</code>&#13;
<code class="p">)</code>&#13;
<code class="c1">// etc.</code>&#13;
&#13;
<code class="c1">// Respond to a sendMessageToThread command from the main thread</code>&#13;
<code class="nx">commandEmitter</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'sendMessageToThread'</code><code class="p">,</code> <code class="p">(</code><code class="nx">threadID</code><code class="p">,</code> <code class="nx">message</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">OK</code><code class="p">,</code> <code class="nx">I</code> <code class="nx">will</code> <code class="nx">send</code> <code class="nx">a</code> <code class="nx">message</code> <code class="nx">to</code> <code class="nx">threadID</code> <code class="nx">$</code><code class="p">{</code><code class="nx">threadID</code><code class="p">})</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// Send an event back to the main thread</code>&#13;
<code class="nx">eventEmitter</code><code class="p">.</code><code class="nx">emit</code><code class="p">(</code><code class="s1">'createdThread'</code><code class="p">,</code> <code class="mi">123</code><code class="p">,</code> <code class="p">[</code><code class="mi">456</code><code class="p">,</code> <code class="mi">789</code><code class="p">])</code>&#13;
</pre>&#13;
&#13;
<p>On the flip side, we can also use an <code>EventEmitter</code>-based API to send commands back from the main thread to the worker thread. Note that if you use this pattern in your own code, you might consider using a more full-featured emitter (like Paolo Fragomeni’s excellent <a href="https://www.npmjs.com/package/eventemitter2"><code>EventEmitter2</code></a>) that supports wildcard listeners, so you don’t have to manually add a listener for each type of event:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="c1">// MainThread.ts</code>&#13;
<code class="nx">type</code> <code class="nx">Commands</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">sendMessageToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">Message</code><code class="p">]</code>&#13;
  <code class="nx">createThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">Participants</code><code class="p">]</code>&#13;
  <code class="nx">addUserToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
  <code class="nx">removeUserFromThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">Events</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">receivedMessage</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">,</code> <code class="nx">Message</code><code class="p">]</code>&#13;
  <code class="nx">createdThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">Participants</code><code class="p">]</code>&#13;
  <code class="nx">addedUserToThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
  <code class="nx">removedUserFromThread</code><code class="o">:</code> <code class="p">[</code><code class="nx">ThreadID</code><code class="p">,</code> <code class="nx">UserID</code><code class="p">]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">commandEmitter</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SafeEmitter</code>	<code class="o">&lt;</code><code class="nx">Commands</code><code class="o">&gt;</code><code class="p">()</code>&#13;
<code class="kd">let</code> <code class="nx">eventEmitter</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SafeEmitter</code>	<code class="o">&lt;</code><code class="nx">Events</code><code class="o">&gt;</code><code class="p">()</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">worker</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Worker</code><code class="p">(</code><code class="s1">'WorkerScript.js'</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Listen for events coming from our worker,</code>&#13;
<code class="c1">// and re-emit them using our typesafe event emitter</code>&#13;
<code class="nx">worker</code><code class="p">.</code><code class="nx">onmessage</code> <code class="o">=</code> <code class="nx">event</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">eventEmitter</code><code class="p">.</code><code class="nx">emit</code><code class="p">(</code>&#13;
    <code class="nx">event</code><code class="p">.</code><code class="nx">data</code><code class="p">.</code><code class="nx">type</code><code class="p">,</code>&#13;
    <code class="p">...</code><code class="nx">event</code><code class="p">.</code><code class="nx">data</code><code class="p">.</code><code class="nx">data</code>&#13;
  <code class="p">)</code>&#13;
&#13;
<code class="c1">// Listen for commands issues by this thread, and send them to our worker</code>&#13;
<code class="nx">commandEmitter</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'sendMessageToThread'</code><code class="p">,</code> <code class="nx">data</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">({</code><code class="nx">type</code><code class="o">:</code> <code class="s1">'sendMessageToThread'</code><code class="p">,</code> <code class="nx">data</code><code class="p">})</code>&#13;
<code class="p">)</code>&#13;
<code class="nx">commandEmitter</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'createThread'</code><code class="p">,</code> <code class="nx">data</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">({</code><code class="nx">type</code><code class="o">:</code> <code class="s1">'createThread'</code><code class="p">,</code> <code class="nx">data</code><code class="p">})</code>&#13;
<code class="p">)</code>&#13;
<code class="c1">// etc.</code>&#13;
&#13;
<code class="c1">// Do something when the worker tells us a new thread was created</code>&#13;
<code class="nx">eventEmitter</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'createdThread'</code><code class="p">,</code> <code class="p">(</code><code class="nx">threadID</code><code class="p">,</code> <code class="nx">participants</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'Created a new chat thread!'</code><code class="p">,</code> <code class="nx">threadID</code><code class="p">,</code> <code class="nx">participants</code><code class="p">)</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="c1">// Send a command to our worker</code>&#13;
<code class="nx">commandEmitter</code><code class="p">.</code><code class="nx">emit</code><code class="p">(</code><code class="s1">'createThread'</code><code class="p">,</code> <code class="p">[</code><code class="mi">123</code><code class="p">,</code> <code class="mi">456</code><code class="p">])</code>&#13;
</pre>&#13;
&#13;
<p>That’s it! We’ve created a simple typesafe wrapper for the familiar event emitter abstraction that we can use in a variety of settings, from cursor events in a browser to communication across threads, making passing messages between threads safe. This is a common pattern in TypeScript: even if something is unsafe, you can usually wrap it in a typesafe API.<a data-primary="event emitters" data-secondary="using in multithreading with Web Workers" data-startref="ix_evemmlti" data-type="indexterm" id="idm46304956357720"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Typesafe protocols" data-type="sect3"><div class="sect3" id="typesafe-protocols">&#13;
<h3>Typesafe protocols</h3>&#13;
&#13;
<p>So far, we’ve looked at passing messages back and forth between two threads. What would it take to extend the technique to say that a particular command always receives a specific event as a response?<a data-primary="protocols" data-secondary="typesafe" data-type="indexterm" id="idm46304956129528"/><a data-primary="Web Workers, typesafe multithreading with" data-secondary="typesafe protocols" data-type="indexterm" id="idm46304956128552"/><a data-primary="browsers" data-secondary="typesafe multithreading with Web Workers" data-tertiary="typesafe protocols" data-type="indexterm" id="idm46304956127576"/></p>&#13;
&#13;
<p>Let’s build a simple call-response protocol, which we can use to move function evaluation across threads. We can’t easily pass functions between threads, but we can define functions in a worker thread and send arguments to them, then send results back. For example, let’s say we’re building a matrix math engine that supports three operations: finding the determinant of a matrix, computing the dot product of two matrices, and inverting a matrix.</p>&#13;
&#13;
<p>You know the drill—let’s start<a data-primary="MatrixProtocol" data-type="indexterm" id="idm46304956125064"/> by sketching out the types for these three operations:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Matrix</code> <code class="o">=</code> <code class="kt">number</code><code class="p">[][]</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">MatrixProtocol</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">determinant</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="k">in</code><code class="o">:</code> <code class="p">[</code><code class="nx">Matrix</code><code class="p">]</code>&#13;
    <code class="nx">out</code>: <code class="kt">number</code>&#13;
  <code class="p">}</code>&#13;
  <code class="s1">'dot-product'</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="k">in</code><code class="o">:</code> <code class="p">[</code><code class="nx">Matrix</code><code class="p">,</code> <code class="nx">Matrix</code><code class="p">]</code>&#13;
    <code class="nx">out</code>: <code class="kt">Matrix</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">invert</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="k">in</code><code class="o">:</code> <code class="p">[</code><code class="nx">Matrix</code><code class="p">]</code>&#13;
    <code class="nx">out</code>: <code class="kt">Matrix</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We define matrices in our main thread, and run all computations in workers. Once again, the idea is to wrap an unsafe operation (sending and receiving untyped messages from a worker) with a safe one, exposing a well-defined, typed API for consumers to use. In this naive implementation, we start by defining a simple request-response protocol <code>Protocol</code>, which lists out the operations a worker can perform along with their expected input and output types.<sup><a data-type="noteref" href="ch08.html#idm46304956078632" id="idm46304956078632-marker">6</a></sup> We then define a generic <span class="keep-together"><code>createProtocol</code></span> function that takes a <code>Protocol</code> and a file path to a Worker, and returns a function that takes a <code>command</code> in that protocol and returns a final function that we can call to actually evaluate that <code>command</code> for a specific set of arguments. OK, here we go:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Protocol</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-1" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="p">[</code><code class="nx">command</code><code>: </code><code class="kt">string</code><code class="p">]</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">in</code><code class="o">:</code><code> </code><code class="nx">unknown</code><code class="p">[</code><code class="p">]</code><code>&#13;
    </code><code class="nx">out</code><code>: </code><code class="kt">unknown</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">createProtocol</code><code class="o">&lt;</code><code class="nx">P</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">Protocol</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">script</code><code>: </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-2" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
 </code><code class="k">return</code><code> </code><code class="o">&lt;</code><code class="nx">K</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">keyof</code><code> </code><code class="nx">P</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">command</code><code>: </code><code class="kt">K</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-3" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
   </code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code>: </code><code class="kt">P</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="p">[</code><code class="s1">'in'</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-4" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
    </code><code class="k">new</code><code> </code><code class="nx">Promise</code><code class="o">&lt;</code><code class="nx">P</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="p">[</code><code class="s1">'out'</code><code class="p">]</code><code class="o">&gt;</code><code class="p">(</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code><code> </code><code class="nx">reject</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-5" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
      </code><code class="kd">let</code><code> </code><code class="nx">worker</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">Worker</code><code class="p">(</code><code class="nx">script</code><code class="p">)</code><code>&#13;
      </code><code class="nx">worker</code><code class="p">.</code><code class="nx">onerror</code><code> </code><code class="o">=</code><code> </code><code class="nx">reject</code><code>&#13;
      </code><code class="nx">worker</code><code class="p">.</code><code class="nx">onmessage</code><code> </code><code class="o">=</code><code> </code><code class="nx">event</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">resolve</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">data</code><code class="p">.</code><code class="nx">data</code><code class="p">)</code><code>&#13;
      </code><code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="p">{</code><code class="nx">command</code><code class="p">,</code><code> </code><code class="nx">args</code><code class="p">}</code><code class="p">)</code><code>&#13;
    </code><code class="p">}</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-1" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We start by defining a general-purpose <code>Protocol</code> type that is not specific to our <code>MatrixProtocol</code>.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-2" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>When we call <code>createProtocol</code>, we pass in a file path to a worker <code>script</code>, along with a specific <code>Protocol</code>.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-3" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>createProtocol</code> returns an anonymous function that we can then invoke with a <code>command</code>, which is a key in the <code>Protocol</code> we bound in <a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-2"><img alt="2" src="assets/2.png"/></a>.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-4" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>We then call that function with whatever the specific <code>in</code> type is for the command we passed in in <a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-3"><img alt="3" src="assets/3.png"/></a>.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-5" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>This gives us back a <code>Promise</code> for the specific <code>out</code> type for that command, as defined in our particular protocol. Note that we have to explicitly bind a type parameter to <code>Promise</code>, otherwise it defaults to <code>{}</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now let’s apply our <code>MatrixProtocol</code> type plus the path to our Web Worker script to <code>createProtocol</code> (we won’t get into the nitty-gritty of how to compute a determinant, and I’ll assume that you’ve implemented it in <em>MatrixWorkerScript.ts</em>). We’ll get back a function that we can use to run a specific command in that protocol:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">runWithMatrixProtocol</code> <code class="o">=</code> <code class="nx">createProtocol</code><code class="o">&lt;</code><code class="nx">MatrixProtocol</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="s1">'MatrixWorkerScript.js'</code>&#13;
<code class="p">)</code>&#13;
<code class="kd">let</code> <code class="nx">parallelDeterminant</code> <code class="o">=</code> <code class="nx">runWithMatrixProtocol</code><code class="p">(</code><code class="s1">'determinant'</code><code class="p">)</code>&#13;
&#13;
<code class="nx">parallelDeterminant</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">]])</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">determinant</code> <code class="o">=&gt;</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">determinant</code><code class="p">)</code> <code class="c1">// -2</code>&#13;
  <code class="p">)</code></pre>&#13;
&#13;
<p>Cool, huh? We’ve taken something totally unsafe—untyped message passing between threads—and abstracted over it with a fully typesafe request-response protocol. All the commands you can run using that protocol live in one place (<code>MatrixProtocol</code>), and our core logic (<code>createProtocol</code>) lives separately from our concrete protocol implementation (<code>runWithMatrixProtocol</code>).</p>&#13;
&#13;
<p>Anytime you need to communicate between two processes—whether on the same machine or between multiple computers on a network—typesafe protocols are a great tool to make that communication safe. While this section helped develop some intuition for what problems protocols solve, for a real-world application you’ll likely want to reach for an existing tool like Swagger, gRPC, Thrift, or GraphQL—for<a data-primary="Web Workers, typesafe multithreading with" data-startref="ix_WebWrk" data-type="indexterm" id="idm46304955653848"/><a data-primary="browsers" data-secondary="typesafe multithreading with Web Workers" data-startref="ix_brwsmltithr" data-type="indexterm" id="idm46304955652840"/><a data-primary="multithreading" data-secondary="in the browser with Web Workers" data-startref="ix_mltithrbrWW" data-type="indexterm" id="idm46304955651592"/> an overview, head over to <a data-type="xref" href="ch09.html#APIs">“Typesafe APIs”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="In NodeJS: With Child Processes" data-type="sect2"><div class="sect2" id="child-process">&#13;
<h2>In NodeJS: With Child Processes</h2>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To follow along with the examples in this section, be sure to install type declarations <a data-primary="multithreading" data-secondary="typesafe multithreading in NodeJS with child processes" data-type="indexterm" id="ix_mltithrNJS"/><a data-primary="NodeJS" data-secondary="typesafe multihreading with child processes" data-type="indexterm" id="ix_NoJSmltthr"/>for NodeJS from NPM:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">npm install @types/node --save-dev</pre>&#13;
&#13;
<p>To learn more about using type declarations, jump ahead to <a data-type="xref" href="ch11.html#third-party-js-with-dt-typings">“JavaScript That Has Type Declarations on DefinitelyTyped”</a>.</p>&#13;
</div>&#13;
&#13;
<p>Typesafe parallelism in NodeJS works the same way as it does for Web Worker threads in the browser (see <a data-type="xref" href="#typesafe-protocols">“Typesafe protocols”</a>). While the message-passing layer itself is unsafe, it’s easy to build a typesafe API over it. NodeJS’s child process API looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// MainThread.ts&#13;
</code><code class="kr">import</code><code> </code><code class="p">{</code><code class="nx">fork</code><code class="p">}</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'child_process'</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">child</code><code> </code><code class="o">=</code><code> </code><code class="nx">fork</code><code class="p">(</code><code class="s1">'./ChildThread.js'</code><code class="p">)</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-1" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="nx">child</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'message'</code><code class="p">,</code><code> </code><code class="nx">data</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-2" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Child process sent a message'</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="p">)</code><code>&#13;
</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="nx">child</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="p">{</code><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'syn'</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="o">:</code><code> </code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="p">}</code><code class="p">)</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-3" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-1" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We use NodeJS’s <code>fork</code> API to spawn a new child process.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-2" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We listen to incoming messages from a child process using the <code>on</code> API. There are a few messages that a NodeJS child process might send to its parent; here, we just care about the <code>'message'</code> message.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-3" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>We use the <code>send</code> API to send messages to a child process.</p></dd>&#13;
</dl>&#13;
&#13;
<p>In our child thread, we listen to messages coming in from the main thread using the <code>process.on</code> API and send messages back with <code>process.send</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// ChildThread.ts&#13;
</code><code class="nx">process</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'message'</code><code class="p">,</code><code> </code><code class="nx">data</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO6-1" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO6-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'Parent process sent a message'</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="p">)</code><code>&#13;
</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="nx">process</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="p">{</code><code class="nx">type</code><code class="o">:</code><code> </code><code class="s1">'ack'</code><code class="p">,</code><code> </code><code class="nx">data</code><code class="o">:</code><code> </code><code class="p">[</code><code class="mi">3</code><code class="p">]</code><code class="p">}</code><code class="p">)</code><code> </code><a class="co" href="#callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO6-2" id="co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO6-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO6-1" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We use the <code>on</code> API on the globally defined <code>process</code> to listen for incoming messages from a parent thread.</p></dd>&#13;
<dt><a class="co" href="#co_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO6-2" id="callout_asynchronous_programming___span_class__keep_together__concurrency__and_parallelism__span__CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We use the <code>send</code> API on <code>process</code> to send messages to the parent process.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Because the mechanics are so similar to Web Workers, I’ll leave it as an exercise to implement a typesafe protocol to abstract over interprocess communication in NodeJS.<a data-primary="multithreading" data-secondary="typesafe multithreading in NodeJS with child processes" data-startref="ix_mltithrNJS" data-type="indexterm" id="idm46304955445912"/><a data-primary="NodeJS" data-secondary="typesafe multihreading with child processes" data-startref="ix_NoJSmltthr" data-type="indexterm" id="idm46304955444696"/><a data-primary="multithreading" data-startref="ix_mltithr" data-type="indexterm" id="idm46304955415128"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304955414152">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we started with the basics of JavaScript’s event loop, and continued on to a discussion of the building blocks of asynchronous code in JavaScript and how to safely express them in TypeScript: callbacks, promises, <code>async</code>/<code>await</code>, and event emitters. We then covered multithreading, exploring passing messages between threads (in the browser and on the server) and building full protocols for communicating between threads.</p>&#13;
&#13;
<p>As with <a data-type="xref" href="ch07.html#error_handling">Chapter 7</a>, which technique you use is up to you:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>For simple asynchronous tasks, callbacks are as straightforward as it gets.</p>&#13;
</li>&#13;
<li>&#13;
<p>For more complex tasks that need to be sequenced and parallelized, promises and <code>async</code>/<code>await</code> are your friend.</p>&#13;
</li>&#13;
<li>&#13;
<p>When a promise doesn’t cut it (e.g., if you’re firing an event multiple times), reach for event emitters or a reactive streams library like RxJS.</p>&#13;
</li>&#13;
<li>&#13;
<p>To extend these techniques to multiple threads, use event emitters, typesafe protocols, or typesafe APIs (see <a data-type="xref" href="ch09.html#APIs">“Typesafe APIs”</a>).</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46304955405176">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>Implement a general-purpose <code>promisify</code> function, which takes any function that takes exactly one argument and a callback and wraps it in a function that returns a promise. When you’re done, you should be able to use <code>promisify</code> like this (install type declarations for NodeJS first, with <code>npm install @types/node --save-dev</code>):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code><code class="nx">readFile</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'fs'</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">readFilePromise</code> <code class="o">=</code> <code class="nx">promisify</code><code class="p">(</code><code class="nx">readFile</code><code class="p">)</code>&#13;
<code class="nx">readFilePromise</code><code class="p">(</code><code class="s1">'./myfile.ts'</code><code class="p">)</code>&#13;
  <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">result</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'success reading file'</code><code class="p">,</code> <code class="nx">result</code><code class="p">.</code><code class="nx">toString</code><code class="p">()))</code>&#13;
  <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s1">'error reading file'</code><code class="p">,</code> <code class="nx">error</code><code class="p">))</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>In the section on <a data-type="xref" href="#typesafe-protocols">“Typesafe protocols”</a> we derived one half of a protocol for typesafe matrix math. Given this half of the protocol that runs in the main thread, implement the other half that runs in a Web Worker thread.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use a mapped type (as in <a data-type="xref" href="#web-workers">“In the Browser: With Web Workers”</a>) to implement a typesafe message-passing protocol for NodeJS’s <code>child_process</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304959625896"><sup><a href="ch08.html#idm46304959625896-marker">1</a></sup> Well, you can if you fork your browser platform, or build a C++ NodeJS extension.</p><p data-type="footnote" id="idm46304958643512"><sup><a href="ch08.html#idm46304958643512-marker">2</a></sup> Eagle-eyed readers will notice how similar this API is to the <code>flatMap</code> API we developed in <a data-type="xref" href="ch07.html#option">“The Option Type”</a>. That similarity is no accident! Both <code>Promise</code> and <code>Option</code> are inspired by the Monad design pattern popularized by the functional programming language Haskell.</p><p data-type="footnote" id="idm46304958038360"><sup><a href="ch08.html#idm46304958038360-marker">3</a></sup> <code>Observables</code> are the basic building block of reactive programming’s approach to doing things to values over time. There’s an in-progress proposal to standardize <code>Observables</code> in the <a href="https://tc39.github.io/proposal-observable/"><code>Observable</code> proposal</a>. Look forward to a deeper dive into <code>Observables</code> in a future edition of this book, once the proposal<a data-primary="Observables" data-type="indexterm" id="idm46304958035608"/> is more broadly adopted by JavaScript engines.</p><p data-type="footnote" id="idm46304957247912"><sup><a href="ch08.html#idm46304957247912-marker">4</a></sup> Except for functions, errors, DOM nodes, property descriptors, getters and setters, and prototype methods and properties. For more information, head over to the <a href="http://w3c.github.io/html/infrastructure.html#safe-passing-of-structured-data">HTML5 specification</a>.</p><p data-type="footnote" id="idm46304957246136"><sup><a href="ch08.html#idm46304957246136-marker">5</a></sup> You can also use the <code>Transferable</code> API to pass certain types of data (like <code>ArrayBuffer</code>) between threads by reference. In this section we won’t be using <code>Transferable</code> to explicitly transfer object ownership across threads, but that’s an implementation detail. If you use <code>Transferable</code> for your use case, the approach is identical from a type safety point of view.</p><p data-type="footnote" id="idm46304956078632"><sup><a href="ch08.html#idm46304956078632-marker">6</a></sup> This implementation is naive because it spawns a new worker every time we issue a command; in the real world, you probably want to have a pooling mechanism that keeps a warm pool of workers around, and recycles freed workers.</p></div></div></section></body></html>