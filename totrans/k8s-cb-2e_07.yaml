- en: Chapter 7\. Exploring the Kubernetes API and Key Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we present recipes that address basic interactions with Kubernetes
    objects as well as the API. Every [object in Kubernetes](https://oreil.ly/kMcj7),
    no matter if namespaced like a deployment or cluster-wide like a node, has certain
    fields available—​for example, `metadata`, `spec`, and `status`. The `spec` describes
    the desired state for an object (the specification), and the `status` captures
    the actual state of the object, managed by the Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Discovering the Kubernetes API Server’s Endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to discover the various API endpoints available on the Kubernetes API
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we assume you’ve spun up a development cluster like kind or Minikube locally.
    You can run `kubectl proxy` in a separate terminal. The proxy lets you easily
    access the Kubernetes server API with an HTTP client such as `curl`, without needing
    to worry about authentication and certificates. After running `kubectl proxy`,
    you should be able to reach the API server on port 8001, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This lists all the objects exposed by the Kubernetes API. At the top of the
    list you can see an example of an object with `kind` set to `Binding` as well
    as the allowed operations on this object (here, `create`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that another convenient way to discover the API endpoints is to use the
    `kubectl api-resources` command.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can discover all the API groups by calling the following endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Pick some API groups to explore from this list, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/apis/apps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/apis/storage.k8s.io`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/apis/flowcontrol.apiserver.k8s.io`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/apis/autoscaling`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these endpoints corresponds to an API group. The core API objects are
    available in the `v1` group at `/api/v1`, whereas other newer API objects are
    available in named groups under the `/apis/` endpoint, such as `storage.k8s.io/v1`
    and `apps/v1`. Within a group, API objects are versioned (e.g., `v1`, `v2`, `v1alpha`,
    `v1beta1`) to indicate the maturity of the objects. Pods, services, config maps,
    and secrets, for example, are all part of the `/api/v1` API group, whereas the
    `/apis/autoscaling` group has `v1` and `v2` versions.
  prefs: []
  type: TYPE_NORMAL
- en: The group an object is part of is what is referred to as the `apiVersion` in
    the object specification, available via the [API reference](https://oreil.ly/fvO82).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes [API overview](https://oreil.ly/sANzL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes [API conventions](https://oreil.ly/ScJvH)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.2 Understanding the Structure of a Kubernetes Manifest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Kubernetes does have convenient generators like `kubectl run` and `kubectl
    create`, you must to learn how to write Kubernetes manifests to embrace the declarative
    nature of Kubernetes object specifications. To do this, you need to understand
    the general structure of manifests.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Recipe 7.1](#api_endpoints), you learned about the various API groups and
    how to discover which group a particular object is in.
  prefs: []
  type: TYPE_NORMAL
- en: All API resources are either objects or lists. All resources have a `kind` and
    an `ap⁠i​Ve⁠rs⁠ion`. In addition, every object `kind` must have `metadata`. The
    `metadata` contains the name of the object, the namespace it is in (see [Recipe
    7.3](#namespace)), and optionally some labels (see [Recipe 7.6](#labels)) and
    annotations (see [Recipe 7.7](#easy_annotate)).
  prefs: []
  type: TYPE_NORMAL
- en: 'A pod, for example, will be of `kind Pod` and `apiVersion v1`, and the beginning
    of a simple manifest written in YAML will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete a manifest, most objects will have a `spec` and, once created,
    will also return a `status` that describes the current state of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes manifests can be used to define the desired state of your cluster.
    Because manifests are files, they can be stored in a version control system like
    Git. This allows for distributed and asynchronous collaboration among developers
    and operators and also enables the creation of automation pipelines for continuous
    integration and deployment. This is the basic idea behind GitOps, in which any
    changes to a system are made by changing a source of truth in a version control
    system. Because all changes are logged in the system, it is possible to revert
    to previous states or reproduce a given state multiple times. Infrastructure as
    code (IaC) is a term often used when the declarative source of truth is describing
    the state of infrastructure (as opposed to applications).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Objects in Kubernetes](https://oreil.ly/EONxU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.3 Creating Namespaces to Avoid Name Collisions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create two objects with the same name but want to avoid naming collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create two namespaces and create one object in each.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t specify anything, objects are created in the `default` namespace.
    Try creating a second namespace called `my-app`, as shown here, and list the existing
    namespaces. You will see the `default` namespace, other namespaces that were created
    on start-up (`kube-system`, `kube-public`, and `kube-node-lease`), and the `my-app`
    namespace you just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Alternatively, you can write a manifest to create your namespace. If you save
    the following manifest as *app.yaml*, you can then create the namespace with the
    `kubectl apply -f app.yaml` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attempting to start two objects with the same name in the same namespace (e.g.,
    `default`) leads to a collision, and an error is returned by the Kubernetes API
    server. However, if you start the second object in a different namespace, the
    API server will create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `kube-system` namespace is reserved for administrators, whereas the [`kube-public`
    namespace](https://oreil.ly/kQFsq) is meant to store public objects available
    to any users of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Setting Quotas Within a Namespace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to limit the resources available in a namespace—​for example, the overall
    number of pods that can run in the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a `ResourceQuota` object to specify the limitations on a namespace basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a manifest for a resource quota and saving it in a file called
    *resource-quota-pods.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a new namespace and apply the quota to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can set a number of quotas on a per-namespace basis, including but not limited
    to pods, secrets, and config maps.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Configure Quotas for API Objects](https://oreil.ly/jneBT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.5 Labeling an Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to label an object so that you can easily find it later. The label
    can be used for further end-user queries (see [Recipe 7.6](#labels)) or in the
    context of system automation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `kubectl label` command. For example, to label a pod named `foobar`
    with the key/value pair `tier=frontend`, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Check the complete help for the command (`kubectl label --help`). You can use
    it to find out how to remove labels, overwrite existing ones, and even label all
    resources in a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, you use labels to organize objects in a flexible, nonhierarchical
    manner. A label is a key/value pair without any predefined meaning for Kubernetes.
    In other words, the content of the key/value pair is not interpreted by the system.
    You can use labels to express membership (e.g., object X belongs to department
    ABC), environments (e.g., this service runs in production), or really anything
    you need to organize your objects. There are some common useful labels that you
    can read about in the [Kubernetes documentation](https://oreil.ly/SMl_N). Note
    that labels do have restrictions concerning their [length and allowed values](https://oreil.ly/AzeM8).
    However, there is a [community guideline](https://oreil.ly/lTkhW) for naming keys.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Using Labels for Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to query objects efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `kubectl get --selector` command. For example, given the following
    pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'you can select the pods that belong to the NGINX app (`app=nginx`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Labels are part of an object’s metadata. Any object in Kubernetes can be labeled.
    Labels are also used by Kubernetes itself for pod selection by deployments (see
    [Recipe 4.1](ch04.html#kubectl_run)) and services (see [Chapter 5](ch05.html#ch_services)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Labels can be added manually with the `kubectl label` command (see [Recipe
    7.5](#easy_label)), or you can define labels in an object manifest, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once labels are present, you can list them with `kubectl get`, noting the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-l` is the short form of `--selector` and will query objects with a specified
    `*key*``=``*value*` pair.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--show-labels` will show all the labels of each object returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-L` will add a column to the results returned with the value of the specified
    label.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many object kinds support set-based querying, meaning you can state a query
    in a form like “must be labeled with X and/or Y.” For example, `kubectl get pods
    -l 'env in (production, development)'` would give you pods that are in either
    the production or development environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With two pods running, one with label `run=barfoo` and the other with label
    `ru⁠n=​fo⁠oba⁠r`, you would get outputs similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes documentation on [labels and selectors](https://oreil.ly/ku1Sc)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7.7 Annotating a Resource with One Command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to annotate a resource with a generic, nonidentifying key/value pair,
    possibly using non-human-readable data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `kubectl annotate` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Annotations tend to be used for added automation of Kubernetes. For example,
    when you create a deployment with the `kubectl create deployment` command, you
    will notice that the `change-cause` column in your rollout history (see [Recipe
    4.6](ch04.html#updating-deployments)) is empty. As of Kubernetes v1.6.0, to start
    recording the commands that cause changes to the deployment, you can annotate
    it with the `kubernetes.io/change-cause` key. Given a deployment `foobar`, you
    might annotate it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Subsequent changes to the deployment will be recorded.
  prefs: []
  type: TYPE_NORMAL
- en: One of the major differences between annotations and labels is that labels can
    be used as filtering criteria, whereas annotations cannot. Unless you plan to
    use your metadata for filtering, then it is generally preferable to use annotations.
  prefs: []
  type: TYPE_NORMAL
