- en: Chapter 3\. The Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive deep into the concept of virtual DOM, sometimes
    called vDOM, and its significance in React. We’ll also explore how React uses
    the virtual DOM to make web development easier and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: As web applications become more complex, it becomes increasingly difficult to
    manage the “real DOM,” which is a complex and error-prone process as we’ll see
    soon enough, and as we crudely covered in [Chapter 1](ch01.html#ch01). React’s
    virtual DOM provides a solution to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ll explore the workings of React’s virtual DOM,
    its advantages over the real DOM, and how it is implemented. We’ll also cover
    how React optimizes performance around the real DOM using the virtual DOM and
    how it all fits together.
  prefs: []
  type: TYPE_NORMAL
- en: Through a series of code examples and detailed explanations, we’ll understand
    the virtual DOM’s role in React and how to take advantage of its benefits to create
    robust and efficient web applications. Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: An Intro to the Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The virtual DOM, like the DOM, is an HTML document modeled as a JavaScript
    object: this is literally what Document Object Model (DOM) means. The DOM itself
    is the browser runtime’s model of the document. The virtual DOM is a lightweight
    copy of this, with the key difference that while the real DOM is made up of `Node`
    objects, the virtual DOM is made up of plain JS objects that act as descriptions.
    It allows web developers to create user interfaces in a more efficient and performant
    way, as we’ll discover in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: In React, whenever we tell it to make a change to the UI via `setState` or some
    other mechanism, the virtual DOM is updated first, and then the real DOM is updated
    to match the changes in the virtual DOM. This process is called *reconciliation*,
    the subject of [Chapter 4](ch04.html#ch04).
  prefs: []
  type: TYPE_NORMAL
- en: The reason for updating the virtual DOM first is that updates to the real DOM
    can be somewhat slow and expensive. We’ll cover this in the next section, but
    the gist of it is that every time a change is made to the real DOM, the browser
    has to recalculate the layout of the page, repaint the screen, and perform other
    operations that can be time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, just reading an element’s `offsetWidth` can trigger a reflow,
    which is a process where the browser recalculates the layout of all or part of
    the document, potentially affecting performance and making direct DOM interactions
    less efficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, updating the virtual DOM is much faster because it doesn’t
    involve any changes to the actual page layout. Instead, it is a simple JavaScript
    object that can be manipulated quickly and efficiently through various algorithmic
    approaches that can make the best use of the JavaScript engine available and increase
    its efficiency over time, decoupled from the browsers and other host environments.
  prefs: []
  type: TYPE_NORMAL
- en: When updates are made to the virtual DOM, React uses a diffing algorithm to
    identify the differences between the old and new versions of the virtual DOM.
    This algorithm then determines the minimal set of changes required to update the
    real DOM, and these changes are applied in a batched and optimized way to minimize
    the performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the differences between the virtual DOM and
    the real DOM, the pitfalls of the real DOM, and how the virtual DOM helps create
    better user interfaces. We will also dive into React’s implementation of the virtual
    DOM and the algorithms it uses for efficient updates.
  prefs: []
  type: TYPE_NORMAL
- en: The Real DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When an HTML page is loaded into a web browser, it is parsed and converted
    into a tree of nodes and objects—an *object model*—which is the DOM: just a big
    JavaScript object. The DOM is a live representation of the web page, meaning that
    it is constantly being updated as users interact with the page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of the real DOM for a simple HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the real DOM is represented by a tree-like structure that
    consists of nodes for each HTML element in the page. This is what the tree structure
    could look like, though it’s oversimplified for the purposes of understanding.
    The actual DOM has far more properties and methods per node. Still, this should
    help us understand how a document is modeled as an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Each node in the tree represents an HTML element, and it contains properties
    and methods that allow it to be manipulated through JavaScript. For example, we
    can use the `document.querySelector()` method to retrieve a specific node from
    the real DOM and modify its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we retrieve the `h1` element with the `class` of `"heading"`
    using the `document.querySelector()` method. We then modify the contents of the
    element by setting its `innerHTML` property to `"Updated Heading!"`. This changes
    the text displayed on the page from `"Welcome to my page!"` to `"Updated Heading!"`.
  prefs: []
  type: TYPE_NORMAL
- en: That doesn’t seem too complicated, but there are a few things to note here.
    First, we are using the `document.querySelector()` method to retrieve the element
    from the real DOM. This method accepts a CSS selector as an argument and returns
    the first element that matches the selector. In this case, we are passing in the
    class selector `.heading`, which matches the `h1` element with the `class` of
    `"heading"`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a bit of a danger here, because while the `document.querySelector` method
    is a powerful tool for selecting elements in the real DOM based on CSS selectors,
    one potential performance issue with this method is that it can be slow when working
    with large and complex documents. The method has to start at the top of the document
    and traverse downward to find the desired element, which can be a time-consuming
    process.
  prefs: []
  type: TYPE_NORMAL
- en: When we call `document.querySelector()` with a CSS selector, the browser has
    to search the entire document tree for matching elements. This means that the
    search can be slow, especially if the document is large and has a complex structure.
    In addition, the browser has to evaluate the selector itself, which can be a complex
    process, depending on the complexity of the selector.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, `document.getElementById` does not require validation like CSS
    selectors, and has increased specificity since `id` attributes are expected to
    be unique, so it is generally more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of runtime complexity using Big O notation, `getElementById` is often
    approximated as (O(1)) in modern browsers, given that they likely employ hashing
    mechanisms, such as hash tables, for efficient ID→element mapping. While ideal
    hash table lookups are (O(1)) on average, it’s important to consider that worst-case
    scenarios, like hash collisions, can lead to longer lookups. Given that browsers
    don’t really enforce ID uniqueness, these hash collisions can be more than likely.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, with advanced hashing functions and resizing strategies in modern
    browsers, these cases are rare.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For those of us who didn’t go to computer school and maybe don’t understand
    Big O, it’s a handy tool used by developers to gauge how fast or slow a piece
    of code will run, especially as the amount of data the code has to work with increases.
    Essentially, Big O notation gives a high-level understanding of algorithms in
    terms of both time complexity (how the execution time grows with the size of the
    input) and space complexity (how the amount of memory used grows with the size
    of the input). It’s often expressed using terms like (O(1)), (O(n)), (O(n n)),
    or (O(n²) ), where (n) is the size of the input. So when developers talk about
    code being “efficient” or “scalable,” they’re often referring to these Big O values,
    aiming for algorithms with lower time and space complexity to ensure that their
    software remains performant even as it handles more and more data.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since IDs are supposed to be unique, they’re not really well suited to
    having multiple reusable components on a page. This is where `querySelector` shines,
    as it can be used to select multiple elements with the same class name, for example.
  prefs: []
  type: TYPE_NORMAL
- en: That said, `querySelector`, which can accept a broad range of CSS selectors,
    has a variable complexity. In the worst-case scenario, where the method may need
    to traverse the entire DOM to ensure a match or the absence thereof, its complexity
    can be (O(n)), where (n) is the number of elements in the DOM. However, the actual
    runtime can be less than (O(n)) for more specific selectors or if a match is found
    early in the DOM tree. That said, there’s still the added computational cost of
    parsing and validating the selectors themselves.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that the performance difference between `document.getElementById`
    and `document.querySelector` may be negligible in small documents or when searching
    for elements in specific areas of the document tree. However, in larger and more
    complex documents, the difference can become more pronounced.
  prefs: []
  type: TYPE_NORMAL
- en: Some would say that this whole “CPU efficiency” argument is overblown, and that
    it’s not worth worrying about. While this may or may not be true, no one can question
    the additional value that React’s virtual DOM provides with being able to componentize
    logic and avoid worrying about managing state in an environment as volatile as
    the DOM. We say the DOM is volatile because it is affected by so many things,
    including user interactions, network requests, client-side scripts, and other
    events that can cause it to change at any time. React, through the virtual DOM,
    protects us from this environment using the virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: We’re diving deep into these nuanced details because to be truly fluent with
    React, it’s important to understand the overall complexity of the DOM. Working
    intelligently with the DOM is no small feat, and with React, we have a choice
    to either navigate this minefield ourselves and occasionally step on landmines,
    or to use a tool that helps us navigate the DOM safely using the virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve discussed some small nuances in how we select elements here, we
    haven’t had an opportunity to dive deeper into the pitfalls of working with the
    DOM directly. Let’s do this quickly to fully understand the value that React’s
    virtual DOM provides.
  prefs: []
  type: TYPE_NORMAL
- en: Pitfalls of the Real DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The real DOM has several pitfalls that can make it difficult to build a high-performance
    web application. Some of these pitfalls include performance issues, cross-browser
    compatibility, and security vulnerabilities, where manipulating the DOM directly
    could present cross-site scripting (XSS) vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the biggest issues with the real DOM is its performance. Whenever a change
    is made to the DOM, such as adding or removing an element, or changing the text
    or attributes of an element, the browser has to recalculate the layout and repaint
    the affected parts of the page. This can be a slow and resource-intensive process,
    especially for large and complex web pages.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, reading a DOM element’s `offsetWidth` property may seem
    like a simple operation, but it can actually trigger a costly recalculation of
    the layout by the browser. This is because `offsetWidth` is a computed property
    that depends on the layout of the element and its ancestors, which means that
    the browser needs to ensure that the layout information is up-to-date before it
    can return an accurate value.
  prefs: []
  type: TYPE_NORMAL
- en: In the worst-case scenario, reading an element’s `offsetWidth` property with
    Big O notation would be estimated as (O(n)). This is because accessing this property
    can potentially trigger a reflow in the browser, which involves recalculating
    layout positions for a number of elements on the page. In this context, (n) represents
    the number of DOM elements affected by the reflow. Even though the direct property
    access is quick, the associated side effects, like a reflow, can make the operation
    scale with the number of elements on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re looking to avoid the potential reflow triggered by accessing layout
    properties like `offsetWidth`, we can employ certain techniques to make the operation
    more performant. Here’s one approach using the `getBoundingClientRect()` method,
    which can batch layout reads and writes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By using `getBoundingClientRect()`, we retrieve multiple layout properties in
    a single call, reducing the chances of triggering multiple reflows. Additionally,
    by batching reading and writing operations separately, we can further minimize
    *layout thrashing*, which is the repeated and unnecessary recalculations of layout
    caused by frequent interleaved reading and writing of layout properties (see [Figure 3-1](#figure3-1)).
    This thrashing can significantly degrade the performance of a web page, leading
    to a sluggish user experience. By strategically accessing layout properties and
    batching our operations, we can keep our web interactions smooth and responsive.
  prefs: []
  type: TYPE_NORMAL
- en: '![layout thrashing](assets/frea_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Layout thrashing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: However, even `getBoundingClientRect()` can cause a reflow if there are pending
    layout changes. The key to performance here is to minimize the number of times
    you force the browser to recalculate layout, and when you do, try to retrieve
    as much information as you need in one go.
  prefs: []
  type: TYPE_NORMAL
- en: React handles all of this for us out of the box using the virtual DOM as an
    intermediate layer between real DOM operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example, where we have a simple HTML document with a
    single `div` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When we load this document in a browser and open the developer console, we can
    see that the `offsetWidth` property of the `div` element is logged to the console.
    However, what we don’t see is the behind-the-scenes work that the browser has
    to do to compute the value of `offsetWidth`.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this work, we can use the Performance panel in our developer tools
    to record a timeline of the browser’s activities as it loads and renders the page.
    When we do that, we can see that the browser is performing several layout and
    paint operations as it processes the document. In particular, we can see that
    there are two layout operations that correspond to reading `offsetWidth` in the
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these layout operations takes some time to complete (in this case, about
    2 ms), even though they are just reading the value of a property. This is because
    the browser needs to ensure that the layout information is up-to-date before it
    can return an accurate value, which requires it to perform a full layout of the
    document. Although 2 milliseconds might not seem like a big deal, at scale it
    adds up.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we should be careful when reading layout-dependent properties like
    `offsetWidth`, because they can cause unexpected performance problems. If we need
    to read the value of such properties multiple times, we should consider caching
    the value in a variable to avoid triggering unnecessary layout recalculations.
    Alternatively, we can use the `requestAnimationFrame` API to defer the reading
    of the property until the next animation frame, when the browser has already performed
    the necessary layout calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand more about accidental performance issues with the real DOM, let’s
    take a look at some examples. Consider the following HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we want to add a new item to the list using JavaScript. We might write
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we’re using `getElementById` instead of `querySelector` here because:'
  prefs: []
  type: TYPE_NORMAL
- en: We know the ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We know the performance trade-offs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s keep going.
  prefs: []
  type: TYPE_NORMAL
- en: This code selects the `ul` element with the ID `"list"`, creates a new `li`
    element, sets its text content to `"Item 4"`, and appends it to the list. When
    we run this code, the browser has to recalculate the layout and repaint the affected
    parts of the page to display the new item.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process can be slow and resource intensive, especially for larger lists.
    For example, suppose we have a list with 1,000 items, and we want to add a new
    item to the end of the list. We might write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When we run this code, the browser has to recalculate the layout and repaint
    the entire list, even though only one item has been added. This can take a significant
    amount of time and resources, especially on slower devices or with larger lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further illustrate this issue, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have a list with three items and a button that highlights
    the second item when clicked. When the button is clicked, the browser has to recalculate
    the layout and repaint the entire list, even though only one item has changed.
    This can cause a noticeable delay or flicker in the UI, which can be frustrating
    for users.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the performance issues of the real DOM can be a significant challenge
    for us, especially when dealing with large and complex web pages. While there
    are techniques for mitigating these issues, such as optimizing selectors, using
    event delegation, batching read/write DOM operations, or using CSS animations,
    they can be complex and difficult to implement.
  prefs: []
  type: TYPE_NORMAL
- en: As a result, many of us have turned to the virtual DOM as a solution to these
    issues. The virtual DOM allows us to create UIs that are more efficient and performant
    by abstracting away the complexities of the real DOM and providing a more lightweight
    way of representing the UI.
  prefs: []
  type: TYPE_NORMAL
- en: But…is it really necessary to save a few milliseconds? Well, CPU/processing
    performance is a critical factor that can greatly impact the success of an application.
    In today’s digital age, where users expect fast and responsive websites, it’s
    essential for us web developers to prioritize CPU efficiency to ensure that our
    applications run smoothly and responsively. An excellent article titled [“Milliseconds
    make millions”](https://oreil.ly/BtXCh) on the Google web develpment blog adds
    further credibility to these claims.
  prefs: []
  type: TYPE_NORMAL
- en: Direct DOM manipulation that triggers layout recalculation (called reflows)
    and repaints can lead to increased CPU usage and processing times, which can cause
    delays and even crashes for users. This can be particularly problematic for users
    on low-powered devices, such as smartphones or tablets, which may have limited
    processing power and memory. In many parts of the world, users may be accessing
    our web apps on older or less capable devices, which can further compound the
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: By prioritizing CPU efficiency, we can create applications that are accessible
    to users on a wide range of devices, regardless of their processing power or memory.
    This can lead to increased engagement, higher conversion rates, and ultimately,
    a more successful online presence.
  prefs: []
  type: TYPE_NORMAL
- en: React’s virtual DOM has enabled building CPU-efficient web applications; using
    its efficient rendering algorithms can help minimize processing times and improve
    overall performance.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-browser compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another issue with the real DOM is cross-browser compatibility. Different browsers
    model documents differently, which can lead to inconsistencies and bugs in web
    applications. This was far more common when React was released and is far less
    common now. Still, this can and did make it difficult for developers to create
    web applications that work seamlessly across different browsers and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary issues with cross-browser compatibility is that certain DOM
    elements and attributes may not be supported by all browsers. As a result, we
    had to spend additional time and effort implementing workarounds and fallbacks
    to ensure that applications function correctly on all target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is exactly what React solves using its synthetic event system. `SyntheticEvent`
    is a wrapper around browsers’ native events, designed to ensure consistency across
    different browsers. It addresses inconsistencies between browsers using the following
    mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: Unified interface
  prefs: []
  type: TYPE_NORMAL
- en: 'In raw JavaScript, handling browser events can be tricky due to inconsistencies.
    For instance, accessing event properties might differ across browsers. Some might
    use `event.target`, while others use `event.srcElement`. `SyntheticEvent` abstracts
    these differences, providing a consistent way to interact with events and ensuring
    that developers don’t have to write browser-specific code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: By wrapping native events into the `SyntheticEvent` system, React shields developers
    from many of the inconsistencies and quirks of the native browser event systems.
  prefs: []
  type: TYPE_NORMAL
- en: Event delegation
  prefs: []
  type: TYPE_NORMAL
- en: Instead of attaching event listeners directly to elements, React listens for
    events at the root level. This approach sidesteps issues where some events might
    not be available on certain elements in older browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-functional enhancements
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the areas where native browser events exhibit inconsistencies is in
    how they handle certain events across different input elements. A notable example
    is the `onChange` event:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In raw JavaScript, the behavior of the `onChange` event differs between input
    types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `<input type="text">`, the `onChange` event in some browsers might trigger
    only after the input loses focus, rather than immediately upon value change.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `<select>`, it might trigger whenever an option is selected, even if it’s
    the same as the previous one.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In other cases, especially in older browsers, the `onChange` event might not
    trigger reliably for all user interactions on certain form elements.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'React’s `SyntheticEvent` system normalizes the behavior of the `onChange` event
    across these input elements. In React:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `onChange` event for a text input (`<input type="text">`) consistently fires
    with every keystroke, giving real-time feedback.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For `<select>`, it reliably triggers whenever a new option is chosen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: React ensures that `onChange` provides a consistent experience across other
    form elements as well.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: By doing so, React frees developers from dealing with these native inconsistencies,
    allowing them to focus on their application logic without worrying about browser-specific
    quirks.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Access to native events
  prefs: []
  type: TYPE_NORMAL
- en: If developers need the original browser event, it’s available via `event.native​Event`,
    ensuring flexibility without sacrificing the benefits of the abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, `SyntheticEvent` offers a stable event system, ironing out the quirks
    and differences of native browser events. This is just one specific way that React
    uses its virtual DOM to provide conveniences to UI development.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve been discussing how working with the DOM directly can cause performance
    issues and cross-browser compatibility problems. Let’s now explore a way to natively
    get around these issues in a more performant manner using document fragments,
    which can be considered something of a native precursor to understanding React’s
    virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Document Fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen, direct manipulation of the DOM can be performance intensive,
    especially when multiple changes are involved. Every time the DOM is updated,
    the browser may need to perform layout recalculations, repaint the UI, and update
    the view, which can slow down the application. This is where document fragments
    come into play.
  prefs: []
  type: TYPE_NORMAL
- en: A *document fragment* is a lightweight container that holds DOM nodes. It acts
    like a temporary staging area where you can make multiple changes without affecting
    the main DOM. Once you’re done, you can append the document fragment to the DOM,
    triggering a single reflow and repaint. Document fragments are very close to React’s
    virtual DOM in this way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because document fragments are lightweight containers that allow us to batch
    updates, they present a number of performance benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Batched updates
  prefs: []
  type: TYPE_NORMAL
- en: Instead of making multiple individual updates to the live DOM, you can batch
    all your changes in a document fragment. This means only one reflow and repaint
    occurs, regardless of how many elements or changes you’ve made inside the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: Memory efficiency
  prefs: []
  type: TYPE_NORMAL
- en: When nodes are added to a document fragment, they’re removed from their current
    parent in the DOM. This can help in optimizing memory usage, especially when reordering
    large sections of a document.
  prefs: []
  type: TYPE_NORMAL
- en: No redundant rendering
  prefs: []
  type: TYPE_NORMAL
- en: Since the document fragment is not part of the active document tree, changes
    to it don’t affect the live document, and styles and scripts aren’t applied until
    the fragment is appended to the actual DOM. This avoids redundant style recalculations
    and script executions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where you need to add multiple list items to a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the 100 list items are first appended to the document fragment.
    Only when all items are added does the fragment get appended to the main list.
    This results in a single update to the live DOM instead of 100 separate updates.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, document fragments offer a way to efficiently manipulate the DOM
    by batching multiple changes together, thus reducing the number of costly reflows
    and repaints. For developers aiming for optimal performance in their web applications,
    leveraging document fragments can lead to smoother interactions and faster render
    times.
  prefs: []
  type: TYPE_NORMAL
- en: 'React’s virtual DOM can be likened to an advanced implementation of the document
    fragment concept. Here’s a brief connection:'
  prefs: []
  type: TYPE_NORMAL
- en: Batched updates
  prefs: []
  type: TYPE_NORMAL
- en: Similar to document fragments, React’s virtual DOM batches multiple changes
    together. Instead of directly altering the live DOM on every state or prop change,
    React compiles these changes in the virtual DOM first.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient diffs
  prefs: []
  type: TYPE_NORMAL
- en: React then determines the differences (or “diffs”) between the current virtual
    DOM and the real DOM. This diffing process ensures that only the necessary changes
    are made to the real DOM, analogous to how document fragments reduce direct DOM
    manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: Single render
  prefs: []
  type: TYPE_NORMAL
- en: Once the diffs are identified, React updates the actual DOM in a single batch,
    much like appending a fully populated document fragment. This minimizes costly
    reflows and repaints.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, while document fragments offer a way to group and optimize a set
    of changes before updating the live DOM, React’s virtual DOM takes this a step
    further by intelligently diffing and batching updates across the entire application’s
    UI, ensuring maximal efficiency in rendering. Moreover, React turns all of this
    document fragment stuff into an implementation detail that we as everyday developers
    need not concern ourselves with, enabling us to build our products with more focus.
    With that, let’s look at how the virtual DOM works in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How the Virtual DOM Works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The virtual DOM is a technique that helps to mitigate the pitfalls of the real
    DOM. By creating a virtual representation of the DOM in memory, changes can be
    made to the virtual representation without directly modifying the real DOM, similar
    to document fragments. This allows the framework or library to update the real
    DOM in a more efficient and performant way, without causing the browser to do
    any work in recomputing the layout of the page and repainting the elements.
  prefs: []
  type: TYPE_NORMAL
- en: The virtual DOM also helps to improve the authoring experience of elements and
    their updates by providing a consistent API that abstracts away the differences
    between different browser implementations of the real DOM. For example, if `document.appendChild`
    is different in another runtime, it doesn’t matter when using JSX and the virtual
    DOM. This makes it easier for developers to create web applications that work
    seamlessly across different browsers and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: React uses the virtual DOM to build user interfaces. In this section, we will
    explore how React’s implementation of the virtual DOM works.
  prefs: []
  type: TYPE_NORMAL
- en: React Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In React, user interfaces are represented as a tree of *React elements*, which
    are lightweight representations of a component or HTML element. They are created
    using the `React.createElement` function and can be nested to create complex user
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a React element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This creates a React element that represents a `<div>` element with a `className`
    of `my-class` and the text content `Hello, world!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, we can see the actual created element if we use `console.log(element)`.
    It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is a representation of a React element. React elements are the smallest
    building blocks of a React application, and they describe what should appear on
    the screen. Each element is a plain JavaScript object that describes the component
    it represents, along with any relevant props or attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The React element shown in the code block is represented as an object with
    several properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$$typeof`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a symbol used by React to ensure that an object is a valid React element.
    In this case, it is `Symbol(react.element)`. `$$typeof` can have other values,
    depending on the type of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol(react.fragment)`'
  prefs: []
  type: TYPE_NORMAL
- en: When the element represents a React fragment.
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol(react.portal)`'
  prefs: []
  type: TYPE_NORMAL
- en: When the element represents a React portal.
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol(react.profiler)`'
  prefs: []
  type: TYPE_NORMAL
- en: When the element represents a React profiler.
  prefs: []
  type: TYPE_NORMAL
- en: '`Symbol(react.provider)`'
  prefs: []
  type: TYPE_NORMAL
- en: When the element represents a React context provider.
  prefs: []
  type: TYPE_NORMAL
- en: In general, `$$typeof` serves as a type marker that identifies the type of the
    React element. We’ll cover more of these in more detail later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: '`type`'
  prefs: []
  type: TYPE_NORMAL
- en: This property represents the type of the component that the element represents.
    In this case, it is `"div"`, indicating that this is a `<div>` DOM element, called
    a “host component.” The `type` property of a React element can be either a string
    or a function (or a class, but we don’t talk about that because it’s being phased
    out). If it is a string, it represents the HTML tag name, like `"div"`, `"span"`,
    `"button"`, etc. When it is a function, it represents a custom React component,
    which is essentially just a JavaScript function that returns JSX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an element with a custom component type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the type property of `myElement` is `MyComponent`, which is a
    function that defines a custom component. The value of `myElement` as a React
    element object would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that type is set to the `MyComponent` function, which is the type of the
    component that the element represents, and `props` contains the props passed to
    the component, in this case `{ text: "Hello, world!" }`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When React encounters an element with a function type, it will invoke that
    function with the element’s `props`, and the return value will be used as the
    element’s `children`, in this case, a `div`. This is how custom React components
    are rendered: React continually goes deeper and deeper and deeper with elements
    until scalar values are reached, which are then rendered as text nodes, or if
    `null` or `undefined` is reached, nothing is rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of an element with a string type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the type property of `myElement` is `"div"`, which is a string
    that represents an HTML tag name. When React encounters an element with a string
    type, it will create a corresponding HTML element with that tag name and render
    its children within that element.
  prefs: []
  type: TYPE_NORMAL
- en: '`ref`'
  prefs: []
  type: TYPE_NORMAL
- en: This property lets the parent component request a reference to the underlying
    DOM node. It is generally used in cases where direct manipulation of the DOM is
    necessary. In this case, the `ref` is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: '`props`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This property is an object that contains all of the attributes and props that
    were passed to the component. In this case, it has two properties: `className`
    and `children`. `className` specifies the class name of the element, and `children`
    contains the content of the element.'
  prefs: []
  type: TYPE_NORMAL
- en: '`_owner`'
  prefs: []
  type: TYPE_NORMAL
- en: This property, only accessible in nonproduction builds of React, is used internally
    by React to track the component that created this element. This information is
    used to determine which component should be responsible for updating the element
    when its props or state change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that demonstrates how the `_owner` property is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `Child` component creates a React element representing
    a `<div>` element with the text `"Hello, world!"`. The `_owner` property of this
    element is set to the `Parent` component, which is the component that created
    the `Child` component.
  prefs: []
  type: TYPE_NORMAL
- en: React uses this information to determine which component should be responsible
    for updating the element when its props or state change. In this case, if the
    `Parent` component updates its state or receives new props, React will update
    the `Child` component and its associated element.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the `_owner` property is an internal implementation
    detail of React and should not be relied upon in application code.
  prefs: []
  type: TYPE_NORMAL
- en: '`_store`'
  prefs: []
  type: TYPE_NORMAL
- en: The `_store` property of a React element object is an object that is used internally
    by React to store additional data about the element. The specific properties and
    values stored in `_store` are not part of the public API and should not be accessed
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of what the `_store` property might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `_store` includes various properties such as `validation`, `key`,
    `originalProps`, `props`, `_self`, `_source`, `_owner`, `_isStatic`, and `_warned​Abou⁠tRefsInRender`.
    These properties are used by React internally to track various aspects of the
    element’s state and context.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `_source` in development mode is used to track the filename and
    line number where the element was created, which can be helpful for debugging.
    `_owner` is used to track the component that created the element, as discussed
    earlier. And `props` and `originalProps` are used to store the props passed to
    the component.
  prefs: []
  type: TYPE_NORMAL
- en: Again, it’s important to note that `_store` is an internal implementation detail
    of React and should not be accessed directly in application code, and for this
    exact reason, we will refrain from going deeper here.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM Versus Real DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `React.createElement` function and the DOM’s built-in `createElement` method
    are similar in that they both create new elements; however, `React.createElement`
    creates React elements and `document.createElement` creates DOM nodes. They’re
    vastly different in their implementation, but conceptually they’re similar.
  prefs: []
  type: TYPE_NORMAL
- en: '`React.createElement` is a function provided by React that creates a new virtual
    element in memory, whereas `document.createElement` is a method provided by the
    DOM API that creates a new element also in memory until it is attached to the
    DOM with APIs like `document.appendChild` or similar. Both functions take a tag
    name as their first argument, while `React.createElement` takes additional arguments
    to specify props and children.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s compare how we’d create a `<div>` element using both methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The virtual DOM in React is similar in concept to the real DOM in that both
    represent a tree-like structure of elements. When a React component is rendered,
    React creates a new virtual DOM tree, compares it to the previous virtual DOM
    tree, and calculates the minimum number of changes needed to update the old tree
    to match the new. This is known as the *reconciliation process*. Here’s an example
    of how this might work in a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For clarity, this component can also be expressed like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In the `createElement` calls, the first argument is the name of the HTML tag
    or React component, the second argument is an object of properties (or `null`
    if no properties are needed), and any additional arguments represent child elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the component is first rendered, React creates a virtual DOM tree like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When the button is clicked, React creates a new virtual DOM tree that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: React then calculates that only the text content of the `h1` element needs to
    be updated, and updates only that part of the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: The use of a virtual DOM in React allows for efficient updates to the real DOM,
    as well as allowing React to work seamlessly with other libraries that also manipulate
    the DOM directly.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient Updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a React component’s state or props change, React creates a new tree of
    React elements that represents the updated user interface. This new tree is then
    compared to the previous tree to determine the minimal set of changes required
    to update the real DOM using a diffing algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm compares the new tree of React elements with the previous tree
    and identifies the differences between the two. It is a recursive comparison.
    If a node has changed, React updates the corresponding node in the real DOM. If
    a node has been added or removed, React adds or removes the corresponding node
    in the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Diffing involves comparing the new tree with the old one node by node to find
    out which parts of the tree have changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'React’s diffing algorithm is highly optimized and aims to minimize the number
    of changes that need to be made to the real DOM. The algorithm works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the nodes at the root level of the two trees are different, React will replace
    the entire tree with the new one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the nodes at the root level are the same, React will update the attributes
    of the node if they have changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the children of a node are different, React will update only the children
    that have changed. React does not re-create the entire subtree; it only updates
    the nodes that have changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the children of a node are the same, but their order has changed, React will
    reorder the nodes in the real DOM without actually re-creating them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a node is removed from the tree, React will remove it from the real DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a new node has been added to the tree, React will add it to the real DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a node’s type has changed (e.g., from a `div` to a `span`), React will remove
    the old node and create a new node of the new type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the node has a `key` prop, React uses it to know if it should replace the
    node or not. It can be useful when you need to reset the state of the components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React’s diffing algorithm is efficient and allows React to update the real DOM
    quickly and with minimal changes. This helps to improve the performance of React
    applications and makes it easier to build complex, dynamic user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Unnecessary rerenders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While React’s diffing algorithm indeed plays a crucial role in efficiently
    updating the real DOM by minimizing the changes needed, there’s a common challenge
    that developers may encounter: unnecessary rerenders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the way React works by design: when a component’s state changes, React
    rerenders the component and all of its descendants. By rerendering, we mean that
    React calls each function component recursively, passing each function component
    its props as an argument. React does not skip components whose props have not
    changed, but calls all function components that are children of a parent whose
    state or props change. This is because React doesn’t know which components depend
    on the state of the component that changed, so it has to rerender all of them
    to ensure that the UI stays consistent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can present some significant performance challenges, especially when dealing
    with large and complex user interfaces. For example, `ChildComponent` in the following
    snippet will rerender every time the `ParentComponent`’s state changes, even if
    the props passed to `ChildComponent` do not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ParentComponent` has a state variable `count` that is incremented every time
    the button is clicked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ChildComponent` receives a static prop called `message`. Since this prop doesn’t
    change, ideally, we wouldn’t want `ChildComponent` to rerender every time `Parent​Component`’s
    state changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, due to React’s default behavior, `ChildComponent` will rerender every
    time the `ParentComponent` rerenders, which happens on every state change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is inefficient because `ChildComponent` does not depend on the `count`
    state from `ParentComponent`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since `ChildComponent`’s props and state haven’t changed, the render was pointless:
    it presumably returned the same result as last time, so this was wasted effort.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is the problem that we often need to optimize, especially in larger applications
    where many components might be rerendering unnecessarily, leading to potential
    performance issues. Addressing this issue requires a thoughtful approach to managing
    component rerenders, ensuring that changes in state or props at a higher level
    in the component hierarchy do not result in widespread, unnecessary rerenders
    among descendant components. Through mindful structuring of components and judicious
    use of React’s optimization features like `memo` and `useMemo`, developers can
    better manage rerenders and maintain high performance in their applications.
  prefs: []
  type: TYPE_NORMAL
- en: We cover this in more detail in [Chapter 5](ch05.html#ch05).
  prefs: []
  type: TYPE_NORMAL
- en: Chapter Review
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we have explored the differences between the real DOM
    and the virtual DOM in web development, as well as the advantages of using the
    latter in React.
  prefs: []
  type: TYPE_NORMAL
- en: We first talked about the real DOM and its limitations, such as slow rendering
    times and cross-browser compatibility issues, which can make it difficult for
    developers to create web applications that work seamlessly across different browsers
    and platforms. To illustrate this, we examined how to create a simple web page
    using the real DOM APIs, and how these APIs can quickly become unwieldy and difficult
    to manage as the complexity of the page increases.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we dove into the virtual DOM and how it addresses many of the limitations
    of the real DOM. We explored how React leverages the virtual DOM to improve performance
    by minimizing the number of updates needed to the real DOM, which can be expensive
    in terms of rendering time. We also looked at how React uses elements to compare
    the virtual DOM with the previous version and calculate the most efficient way
    to update the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the benefits of the virtual DOM, we examined how to create the
    same simple web page using React components. We compared this approach to the
    real DOM approach and saw how React components were more concise and easier to
    manage, even as the complexity of the page increased.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the differences between `React.createElement` and `document.createElement`,
    and we saw how we could create components using JSX, which provides a syntax similar
    to HTML, making it easier to reason about the structure of the virtual DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at how React’s diffing algorithm can lead to unnecessary
    rerenders, which can be a significant performance challenge, especially when dealing
    with large and complex user interfaces, and alluded to [Chapter 5](ch05.html#ch05),
    where we’ll explore how we can optimize this by using React’s `memo` and `useMemo`
    features.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we have learned about the benefits of using the virtual DOM in web
    development, and how React leverages this concept to make building web applications
    easier and more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Review Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a moment to answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What is the DOM, and how does it compare to the virtual DOM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are document fragments, and how are they similar and different to React’s
    virtual DOM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some issues with the DOM?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does the virtual DOM provide a faster way of performing user interface updates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does React rendering work? What potential problems can arise from this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Up Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](ch04.html#ch04), we will dive deep into React reconciliation
    and its Fiber architecture.
  prefs: []
  type: TYPE_NORMAL
