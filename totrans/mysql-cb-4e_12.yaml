- en: Chapter 12\. Working with Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 12.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the SQL statements used so far have been written to work with the data
    stored in the database. That is, after all, what the database is designed to hold.
    But sometimes you need more than just data values. You need information that characterizes
    or describes those values—that is, the statement metadata. Metadata is used most
    often to process result sets, but also applies to other aspects of your interaction
    with MySQL. This chapter describes how to obtain and use several types of metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: Information about statement results
  prefs: []
  type: TYPE_NORMAL
- en: For statements that delete or update rows, you can determine how many rows were
    changed. For a `SELECT` statement, you can obtain the number of columns in the
    result set, as well as information about each column in the result set, such as
    the column name and its display width. For example, to format a tabular display,
    you can determine how wide to make each column and whether to justify values to
    the left or right.
  prefs: []
  type: TYPE_NORMAL
- en: Information about databases and tables
  prefs: []
  type: TYPE_NORMAL
- en: A MySQL server can be queried to determine which databases and tables it manages.
    This is useful for existence tests or producing lists. For example, an application
    might present a display enabling the user to select one of the available databases.
    Table metadata can be examined to determine column definitions; for example, to
    determine the legal values for `ENUM` or `SET` columns to generate web form elements
    corresponding to the available choices.
  prefs: []
  type: TYPE_NORMAL
- en: Information about the MySQL server
  prefs: []
  type: TYPE_NORMAL
- en: The database server provides information about itself and about the status of
    your current session with it. Knowing the server version can be useful for determining
    whether it supports a given feature, which helps you build adaptive applications.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata is closely tied to the implementation of the database system, so it
    tends to be database system−dependent. This means that if an application uses
    techniques shown in this chapter, it might need some modification if you port
    it to other database systems. For example, lists of tables and databases in MySQL
    are available by executing `SHOW` statements. However, `SHOW` is a MySQL-specific
    extension to SQL, so even for APIs like Perl DBI, PHP PDO, Python DB API, and
    JDBC that give you a database-independent way of executing statements, the SQL
    itself is MySQL-specific and must be changed to work with other database systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more portable source of metadata is `INFORMATION_SCHEMA`, a database that
    contains information about databases, tables, columns, character sets, and so
    forth. `INFORMATION_SCHEMA` has some advantages over `SHOW`:'
  prefs: []
  type: TYPE_NORMAL
- en: Other database systems support `INFORMATION_SCHEMA`, so applications that use
    it are likely to be more portable than those that use `SHOW` statements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFORMATION_SCHEMA` is used with standard `SELECT` syntax, so it’s more similar
    to other data-retrieval operations than `SHOW` statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of those advantages, recipes in this chapter use `INFORMATION_SCHEMA`
    rather than `SHOW` in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of `INFORMATION_SCHEMA` is that statements to access it are more
    verbose than the corresponding `SHOW` statements. That doesn’t matter so much
    when you’re writing programs, but for interactive use, `SHOW` statements can be
    more attractive because they require less typing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The results retrieved from `INFORMATION_SCHEMA` or `SHOW` depend on your privileges.
    You’ll see information only for those databases or tables for which you have some
    privileges. Thus, an existence test for an object returns false if it exists but
    you have no privileges for accessing it. You may need to use a user with administrative
    privileges to be able to repeat all code examples that we provide in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts that create tables used in this chapter are located in the *tables*
    directory of the `recipes` distribution. Scripts containing code for the examples
    are located in the *metadata* directory. (Some of them use utility functions located
    in the *lib* directory.) The distribution often provides implementations in languages
    other than those shown.
  prefs: []
  type: TYPE_NORMAL
- en: 12.1 Determining the Number of Rows Affected by a Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know how many rows have been changed by an SQL statement..
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some APIs return the row count as a return value of the function that executes
    the statement. Others provide a separate function that you call after executing
    the statement. Use the method, available in the programming language you use.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For statements that affect rows (`UPDATE`, `DELETE`, `INSERT`, `REPLACE`),
    each API provides a way to determine the number of rows involved. For MySQL, the
    default meaning of <q>affected by</q> is <q>changed by,</q> not <q>matched by.</q>
    That is, rows not changed by a statement are not counted, even if they match the
    conditions specified in the statement. For example, the following `UPDATE` statement
    results in an <q>affected by</q> value of zero because it changes no columns from
    their current values, no matter how many rows the `WHERE` clause matches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The MySQL server permits a client to set a connect-time flag to indicate that
    it wants rows-matched counts, not rows-changed counts. In this case, the row count
    for the preceding statement would be equal to the number of rows with a `cats`
    value of 0, even though the statement results in no net change to the table. However,
    not all MySQL APIs expose this flag. The following discussion indicates which
    APIs enable you to select the type of count you want and which use the rows-matched
    count by default rather than the rows-changed count.
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Perl DBI scripts, `do()` returns the row count for statements that modify
    rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prepare a statement first and then execute it, `execute()` returns the
    row count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To tell MySQL whether to return rows-changed or rows-matched counts, specify
    `mysql_client_found_rows` in the options part of the data source name (DSN) argument
    of the `connect()` call when you connect to the MySQL server. Set the option to
    0 for rows-changed counts and 1 for rows-matched counts. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`mysql_client_found_rows` changes the row-reporting behavior for the duration
    of the session.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the default behavior for MySQL itself is to return rows-changed counts,
    current versions of the Perl DBI driver for MySQL automatically request rows-matched
    counts unless you specify otherwise. For applications that depend on a particular
    behavior, it’s best to explicitly set the `mysql_client_found_rows` option in
    the DSN to the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Ruby Mysql2 scripts, the `affected_rows` method returns the row count for
    statements that modify rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use prepared statements method `execute` to execute a statement, use
    the statement handle `affected_rows` method to get the count afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ruby driver for MySQL returns rows-changed counts by default, but the driver
    supports a `Mysql2::Client::FOUND_ROWS` option that enables you to control whether
    the server returns rows-changed or rows-matched counts. For example, to request
    rows-matched counts, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In PDO, the database handle `exec()` method returns the rows-affected count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `prepare()` plus `execute()` instead, the rows-affected count is
    available from the statement handle `rowCount()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The PDO driver for MySQL returns rows-changed counts by default, but the driver
    supports a `PDO::MYSQL_ATTR_FOUND_ROWS` attribute that you can specify at connect
    time to control whether the server returns rows-changed or rows-matched counts.
    The `new` `PDO` class constructor takes an optional key/value array following
    the password argument. Pass `PDO::MYSQL_ATTR_FOUND_ROWS` `=>` `1` in this array
    to request rows-matched counts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python’s DB API makes the rows-changed count available as the value of the
    statement cursor’s `rowcount` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain rows-matched counts instead, import the Connector/Python client-flag
    constants and pass the `FOUND_ROWS` flag in the `client_flags` parameter of the
    `connect()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go SQL driver provides method `RowsAffected` of the `Result` type that returns
    number of changed rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve row-matched count instead add a parameter `clientFoundRows=true`
    to the connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For statements that modify rows, the Connector/J driver provides rows-matched
    counts rather than rows-changed counts, for conformance with the Java JDBC specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JDBC interface provides row counts two different ways, depending on the
    method you invoke to execute the statement. If you use `executeUpdate()`, the
    row count is its return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use `execute()`, that method returns true or false to indicate whether
    the statement produces a result set. For statements such as `UPDATE` or `DELETE`
    that return no result set, `execute()` returns false and the row count is available
    by calling the `getUpdateCount()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 12.2 Obtaining Result Set Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After retrieving the rows (see [Recipe 4.4](ch04.xhtml#nch-api-api-statement))
    you want to know other details *about* the result set, such as the column names
    and data types, or how many rows and columns there are.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the capabilities provided by your API.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Statements such as `SELECT` that generate a result set produce several types
    of metadata. This section discusses the information available through each API,
    using programs that show how to display the result set metadata available after
    executing a sample statement (`SELECT` `name,` `birth` `FROM` `profile`). The
    example programs illustrate one of the simplest uses for this information: when
    you retrieve a row from a result set and you want to process the column values
    in a loop, the column count stored in the metadata serves as the upper bound on
    the loop iterator.'
  prefs: []
  type: TYPE_NORMAL
- en: Perl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The scope of result set metadata available from Perl DBI depends on how you
    process queries:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a statement handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, invoke `prepare()` to get the statement handle. This handle has
    an `execute()` method. Invoke it to generate the result set, then fetch the rows
    in a loop. With this approach, access to the metadata is available while the result
    set is active—that is, after the call to `execute()` and until the end of the
    result set is reached. When the row-fetching method finds that there are no more
    rows, it invokes `finish()` implicitly, which causes the metadata to become unavailable.
    (That also happens if you explicitly call `finish()` yourself.) Thus, normally
    it’s best to access the metadata immediately after calling `execute()`, making
    a copy of any values that you’ll need to use beyond the end of the fetch loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using a database-handle method that returns the result set in a single operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this approach, any metadata generated while processing the statement will
    have been disposed of by the time the method returns. You can still determine
    the number of rows and columns from the size of the result set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you use a statement handle to process a query, DBI makes result set metadata
    available after you invoke the handle’s `execute()` method. This information is
    available primarily in the form of references to arrays. For each such type of
    metadata, the array has one element per column in the result set. Access these
    array references as attributes of the statement handle. For example, `$sth->{NAME}`
    points to the column name array, with individual column names available as elements
    of this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Or access the entire array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 12-1](#nch-meta-meta-result-perl) lists the attribute names through
    which you access array-based metadata and the meaning of values in each array.
    Names that begin with uppercase are standard DBI attributes and should be available
    for most database engines. Attribute names that begin with `mysql_` are MySQL-specific
    and nonportable:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1\. Metadata in Perl
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute name | Array element meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `NAME` | Column name |'
  prefs: []
  type: TYPE_TB
- en: '| `NAME_lc` | Column name in lowercase |'
  prefs: []
  type: TYPE_TB
- en: '| `NAME_uc` | Column name in uppercase |'
  prefs: []
  type: TYPE_TB
- en: '| `NULLABLE` | 0 or empty string = column values cannot be `NULL` |'
  prefs: []
  type: TYPE_TB
- en: '|  | 1 = column values can be `NULL` |'
  prefs: []
  type: TYPE_TB
- en: '|  | 2 = unknown |'
  prefs: []
  type: TYPE_TB
- en: '| `PRECISION` | Column width |'
  prefs: []
  type: TYPE_TB
- en: '| `SCALE` | Number of decimal places (for numeric columns) |'
  prefs: []
  type: TYPE_TB
- en: '| `TYPE` | Data type (numeric DBI code) |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql_is_blob` | True if column has a `BLOB` (or `TEXT`) type |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql_is_key` | True if column is part of a key |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql_is_num` | True if column has a numeric type |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql_is_pri_key` | True if column is part of a primary key |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql_max_length` | Actual maximum length of column values in result set
    |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql_table` | Name of table the column is part of |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql_type` | Data type (numeric internal MySQL code) |'
  prefs: []
  type: TYPE_TB
- en: '| `mysql_type_name` | Data type name |'
  prefs: []
  type: TYPE_TB
- en: 'Some types of metadata, listed in [Table 12-2](#nch-meta-meta-result-perl-hash),
    are accessed as references to hashes rather than arrays. These hashes have one
    element per column value. The element key is the column name and its value is
    the position of the column within the result set. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Table 12-2\. Metadata in Perl, accessible as references to hashes
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute name | Hash element meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `NAME_hash` | Column name |'
  prefs: []
  type: TYPE_TB
- en: '| `NAME_hash_lc` | Column name in lowercase |'
  prefs: []
  type: TYPE_TB
- en: '| `NAME_hash_uc` | Column name in uppercase |'
  prefs: []
  type: TYPE_TB
- en: 'The number of columns in a result set is available as a scalar value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This example code shows how to execute a statement and display result set metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To get a row count from a result set generated by calling `execute()`, fetch
    the rows and count them yourself. Using `$sth->rows()` to get a count for `SELECT`
    statements is expressly deprecated in the DBI documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You can also obtain a result set by calling one of the DBI methods that uses
    a database handle rather than a statement handle, such as `selectall_arrayref()`
    or `selectall_hashref()`. These methods provide no access to column metadata.
    That information already will have been disposed of by the time the method returns,
    and is unavailable to your scripts. However, you can derive column and row counts
    by examining the result set itself. [Recipe 4.4](ch04.xhtml#nch-api-api-statement)
    discusses the result set structures produced by several methods and how to use
    them to obtain row and column counts.
  prefs: []
  type: TYPE_NORMAL
- en: Ruby
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ruby Mysql2 gem does not provide own methods to access result set metadata after
    you execute a statement. You can only get column names by calling method `fields`
    of the class `Mysql2::Result`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To obtain other column metadata query Information Schema as we suggest in [Recipe
    12.5](#nch-meta-meta-column-info)
  prefs: []
  type: TYPE_NORMAL
- en: PHP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In PHP, metadata for `SELECT` statements is available from PDO after a successful
    call to `query()`. If you execute a statement using `prepare()` plus `execute()`
    instead (which can be used for `SELECT` or non-`SELECT` statements), metadata
    becomes available after `execute()`.
  prefs: []
  type: TYPE_NORMAL
- en: To determine metadata availability, check whether the statement handle `columnCount()`
    method returns a value greater than zero. If so, the handle’s `getColumnMeta()`
    method returns an associative array containing metadata for a single column. The
    following table shows the elements of this array. (The format of the `flags` value
    might differ for other database systems.)
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-3\. Metadata in PHP
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `pdo_type` | Column type (corresponds to a `PDO::PARAM_`*`XXX`* value) |'
  prefs: []
  type: TYPE_TB
- en: '| `native_type` | PHP native type for the column value |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Column name |'
  prefs: []
  type: TYPE_TB
- en: '| `len` | Column length |'
  prefs: []
  type: TYPE_TB
- en: '| `precision` | Column precision |'
  prefs: []
  type: TYPE_TB
- en: '| `flags` | Array of flags describing the column attributes |'
  prefs: []
  type: TYPE_TB
- en: '| `table` | Name of table the column is part of |'
  prefs: []
  type: TYPE_TB
- en: 'This example code shows how to execute a statement and display result set metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To get a row count from a statement that returns rows, fetch the rows and count
    them yourself. The `rowCount()` method is not guaranteed to work for result sets.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For statements that produce a result set, Python’s DB API makes row and column
    counts available, as well as a few information items about individual columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the row count for a result set, access the cursor’s `rowcount` attribute.
    This requires that the cursor be buffered so that it fetches query results immediately;
    otherwise, you must count the rows as you fetch them. The column count is not
    available directly, but after calling `fetchone()` or `fetchall()`, you can determine
    the count as the length of any result set row tuple. It’s also possible to determine
    the column count without fetching any rows by using `cursor.description`. This
    is a tuple containing one element per column in the result set, so its length
    tells you how many columns are in the set. (If the statement generates no result
    set, such as for `UPDATE`, the value of `description` is `None`.) Each element
    of the `description` tuple is another tuple that represents the metadata for the
    corresponding column of the result. For Connector/Python, only a few `description`
    values are meaningful. The following code shows how to access them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The code uses the `FieldType` class, imported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go provides column metadata as array of `ColumnType` values, returned by the
    method `Rows.ColumnTypes`. You can query each of the array members to obtain specific
    characteristic of the column.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 12-4](#nch-meta-meta-result-go) contains methods that the `ColumnType`
    supports.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-4\. Metadata in Go
  prefs: []
  type: TYPE_NORMAL
- en: '| Method name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `DatabaseTypeName` | Database type, such as `INT` or `VARCHAR`. |'
  prefs: []
  type: TYPE_TB
- en: '| `DecimalSize` | Scale and precision for the decimal type |'
  prefs: []
  type: TYPE_TB
- en: '| `Length` | Column type lenght for the variable length text and binary columns.
    Not supported by the MySQL driver. |'
  prefs: []
  type: TYPE_TB
- en: '| `Name` | The name or the alias of the column. |'
  prefs: []
  type: TYPE_TB
- en: '| `Nullable` | Whenever column is nullable. |'
  prefs: []
  type: TYPE_TB
- en: '| `ScanType` | The native Go type, suitable for scanning into `Rows.Scan`.
    |'
  prefs: []
  type: TYPE_TB
- en: You may also get the list of column names if use method `Rows.Columns`. It returns
    array of strings that contain column names or aliases.
  prefs: []
  type: TYPE_NORMAL
- en: The example code demonstrates how to obtain column names and metadata in the
    Go applicaiton.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JDBC makes result set metadata available through a `ResultSetMetaData` object,
    obtained by calling the `getMetaData()` method of your `ResultSet` object. The
    metadata object provides access to several kinds of information. Its `getColumnCount()`
    method returns the number of columns in the result set. Other types of metadata,
    illustrated by the following code, provide information about individual columns
    and take a column index as their argument. For JDBC, column indexes begin at 1
    rather than 0, unlike our other APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The program produces this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The row count of the result set is not available directly; you must fetch the
    rows and count them.
  prefs: []
  type: TYPE_NORMAL
- en: JDBC has several other result set metadata calls, but many of them provide no
    useful information for MySQL. To try them, consult a JDBC reference to see what
    the calls are and modify the program to see what, if anything, they return.
  prefs: []
  type: TYPE_NORMAL
- en: 12.3 Listing or Checking the Existence of Databases or Tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to list the databases hosted by the MySQL server or the tables in a
    database. Or you want to check whether a particular database or table exists.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `INFORMATION_SCHEMA` to get this information. The `SCHEMATA` table contains
    a row for each database, and the `TABLES` table contains a row for each table
    or view in each database.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To retrieve the list of databases hosted by the server, use this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To sort the result, add an `ORDER` `BY` `SCHEMA_NAME` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether a specific database exists, use a `WHERE` clause with a condition
    that names the database. If you get a row back, the database exists. The following
    Ruby method shows how to perform an existence test for a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain the list of tables in a database, name the database in the `WHERE`
    clause of a statement that selects from the `TABLES` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: To sort the result, add an `ORDER` `BY` `TABLE_NAME` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To obtain a list of tables in the default database, use this statement instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If no database has been selected, `DATABASE()` returns `NULL` and no rows match,
    which is the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether a specific table exists, use a `WHERE` clause with a condition
    that names the table. Here’s a Ruby method that performs an existence test for
    a table in a given database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Some APIs provide a database-independent way to get database or table lists.
    In Perl DBI, the database handle `tables()` method returns a list of tables in
    the default database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'For Java, there are JDBC methods designed to return lists of databases or tables.
    For each method, invoke your connection object’s `getMetaData()` method and use
    the resulting `DatabaseMetaData` object to retrieve the information you want.
    Here’s how to produce a list of databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To list the tables in a database, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 12.4 Listing or Checking the Existence of Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check if your database contains views.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Select only those tables from the table `INFORMATION_SCHEMA.TABLES` that have
    `TABLE_TYPE` equal to `VIEW`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Method, used in the [Recipe 12.3](#nch-meta-meta-table-list) shows both physical
    tables and views. If you need to distinguish them from each other use clause `WHERE
    TABLE_TYPE=''VIEW''` to list only views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want, instead, to list only physical tables, use condition `TABLE_TYPE=''BASE
    TABLE''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 12.5 Accessing Table Column Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find out what columns a table has and how they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several ways to do this. You can obtain column definitions from `INFORMATION_SCHEMA`,
    from `SHOW` statements, or from *mysqldump*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Information about the structure of tables enables you to answer questions such
    as <q>What columns does a table contain and what are their types?</q> or <q>What
    are the legal values for an `ENUM` or `SET` column?</q> Here are some applications
    for that kind of information:'
  prefs: []
  type: TYPE_NORMAL
- en: Displaying column lists
  prefs: []
  type: TYPE_NORMAL
- en: A simple use of table information is presenting a list of the table’s columns.
    This is common in web-based or GUI applications that enable users to construct
    statements interactively by selecting a table column from a list and entering
    a value against which to compare column values.
  prefs: []
  type: TYPE_NORMAL
- en: Interactive record editing
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of a table’s structure can be very useful for applications that modify
    data interactively. Suppose that an application retrieves a record from the database,
    displays a form containing the record’s content so a user can edit it, and then
    updates the record in the database after the user modifies the form and submits
    it. You can use table structure information for validating column values, so you
    would not try to insert invalid values into a database. If a column is an `ENUM`,
    you can find out the valid enumeration values and check the value submitted by
    the user against them to determine whether it’s legal. If the column is an integer
    type, check the submitted value to make sure that it consists entirely of digits,
    possibly preceded by a `+` or `−` sign character. If the column contains dates,
    look for a legal date format.
  prefs: []
  type: TYPE_NORMAL
- en: But what if the user leaves a field empty? If the field corresponds to, say,
    a `CHAR` column in the table, do you set the column value to `NULL` or to the
    empty string? This too is a question that can be answered by checking the table’s
    structure. Determine whether the column can contain `NULL` values. If it can,
    set the column to `NULL`; otherwise, set it to the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping column definitions onto web page elements
  prefs: []
  type: TYPE_NORMAL
- en: 'Some data types such as `ENUM` and `SET` correspond naturally to elements of
    web forms:'
  prefs: []
  type: TYPE_NORMAL
- en: An `ENUM` has a fixed set of values from which you choose a single value. This
    is analogous to a group of radio buttons, a pop-up menu, or a single-pick scrolling
    list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `SET` column is similar, except that you can select multiple values; this
    corresponds to a group of checkboxes or a multiple-pick scrolling list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using table metadata to access definitions for these types of columns, you
    can easily determine a column’s legal values and map them onto an appropriate
    form element. [Recipe 12.6](#nch-meta-meta-enum) discusses how to get definitions
    for these types of columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL provides several ways to find out about a table’s structure:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the information from `INFORMATION_SCHEMA`. The `COLUMNS` table contains
    the column definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `SHOW` `COLUMNS` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `SHOW` `CREATE` `TABLE` statement or the *mysqldump* command-line program
    to obtain a `CREATE` `TABLE` statement that displays the table’s structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following discussion shows how to ask MySQL for table information using
    each method. To try the examples, create an `item` table that lists item IDs,
    names, and colors in which each item is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using INFORMATION_SCHEMA to get table structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To obtain information about a single column in a table, query table `INFORMATION_SCHEMA.COLUMNS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To obtain information about all columns, omit the `COLUMN_NAME` condition from
    the `WHERE` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some `COLUMNS` table columns likely to be of most use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COLUMN_NAME`: The column name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ORDINAL_POSITION`: The position of the column within the table definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLUMN_DEFAULT`: The column’s default value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IS_NULLABLE`: `YES` or `NO` to indicate whether the column can contain `NULL`
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DATA_TYPE`, `COLUMN_TYPE`: Data type information. `DATA_TYPE` is the data-type
    keyword and `COLUMN_TYPE` contains additional information such as type attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CHARACTER_SET_NAME`, `COLLATION_NAME`: The character set and collation for
    string columns. They are `NULL` for nonstring columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COLUMN_KEY`: Information about whether the column is indexed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INFORMATION_SCHEMA` content is easy to use from within programs. Here’s a
    PHP function that illustrates this process. It takes database and table name arguments,
    selects from `INFORMATION_SCHEMA` to obtain a list of the table’s column names,
    and returns the names as an array. The `ORDER` `BY` `ORDINAL_POSITION` clause
    ensures that names in the array are returned in table-definition order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '`get_column_names()` returns an array containing only column names. If you
    require additional column information, it’s possible to write a more general `get_column_info()`
    routine that returns an array of column information structures. For implementations
    of both routines in PHP as well as other languages, check the library files in
    the *lib* directory of the `recipes` distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Using SHOW COLUMNS to get table structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `SHOW` `COLUMNS` statement produces one row of output for each column in
    the table, with each row providing various pieces of information about the corresponding
    column. The following example demonstrates `SHOW` `COLUMNS` output for the `item`
    table `colors` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`SHOW` `COLUMNS` displays information for all columns having a name that matches
    the `LIKE` pattern. To obtain information about all columns, omit the `LIKE` clause.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The values displayed by `SHOW` `COLUMNS` correspond to these columns of the
    `INFORMATION_SCHEMA` `COLUMNS` table: `COLUMN_NAME`, `COLUMN_TYPE`, `COLUMN_KEY`,
    `IS_NULLABLE`, `COLUMN_DEFAULT`, `EXTRA`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SHOW` `FULL` `COLUMNS` displays additional `Collation`, `Privileges`, and
    `Comment` fields for each column. These correspond to the `COLUMNS` table `COLLATION_NAME`,
    `PRIVILEGES`, and `COLUMN_COMMENT` columns.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SHOW` interprets the pattern the same way as for the `LIKE` operator in the
    `WHERE` clause of a `SELECT` statement. (For information about pattern matching,
    see [Recipe 7.10](ch07.xhtml#nch-strings-strings-pat-sql).) If you specify a literal
    column name, the string matches only that name and `SHOW` `COLUMNS` displays information
    only for that column. If your column name contains SQL pattern characters (`%`
    or `_`) that you want to match literally, you must escape them with a backslash
    in the pattern string to avoid matching other names as well.'
  prefs: []
  type: TYPE_NORMAL
- en: The need to escape `%` and `_` characters to match a `LIKE` pattern literally
    also applies to other `SHOW` statements that permit a name pattern in the `LIKE`
    clause, such as `SHOW` `TABLES` and `SHOW` `DATABASES`.
  prefs: []
  type: TYPE_NORMAL
- en: Within a program, you can use your API language’s pattern-matching capabilities
    to escape SQL pattern characters before putting the column name into a `SHOW`
    statement. In Perl, Ruby, and PHP, use the following expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perl:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Ruby:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For Python, import the `re` module, and use its `sub()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'For Go, use methods from the `regexp` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'For Java, use methods from the `java.util.regex` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If these expressions appear to have too many backslashes, remember that the
    API language processor itself interprets backslashes and strips off a level before
    performing the pattern match. To get a literal backslash into the result, it must
    be doubled in the pattern. Another level on top of that is needed if the pattern
    processor strips a set.
  prefs: []
  type: TYPE_NORMAL
- en: Using SHOW CREATE TABLE to get table structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another way to obtain table structure information from MySQL is from the `CREATE`
    `TABLE` statement that defines the table. To get this information, use the `SHOW`
    `CREATE` `TABLE` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: From the command line, the same `CREATE` `TABLE` information is available from
    *mysqldump* if you use the `--no-data` option, which tells *mysqldump* to dump
    only the structure of the table and not its data.
  prefs: []
  type: TYPE_NORMAL
- en: '`CREATE` `TABLE` format is highly informative and easy to read because it shows
    column information in a format similar to the one you used to create the table
    in the first place. It also shows the index structure clearly, whereas the other
    methods do not. However, you’ll probably find this method of checking table structure
    more useful interactively than within programs. The information isn’t provided
    in regular row-and-column format, so it’s more difficult to parse. Also, the format
    is subject to change whenever the `CREATE` `TABLE` statement is enhanced, which
    happens from time to time as MySQL’s capabilities are extended.'
  prefs: []
  type: TYPE_NORMAL
- en: 12.6 Getting ENUM and SET Column Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the members of an `ENUM` or `SET` column.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This problem is a subset of getting table structure metadata. Obtain the column
    definition from the table metadata, then extract the member list from the definition.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s often useful to know the list of allowed values for an `ENUM` or `SET`
    column. Suppose that you want to present a web form containing a pop-up menu that
    has options corresponding to each legal value of an `ENUM` column, such as the
    sizes in which a garment can be ordered, or the available shipping methods for
    delivering a package. You could hardwire the choices into the script that generates
    the form, but if you alter the column later (for example, to add a new enumeration
    value), you introduce a discrepancy between the column and the script that uses
    it. If instead you look up the legal values using the table metadata, the script
    can always produce a pop-up that contains the proper set of values. A similar
    approach applies to `SET` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the permitted values for an `ENUM` or `SET` column, get its definition
    using one of the techniques described in [Recipe 12.5](#nch-meta-meta-column-info).
    For example, if you select from the `INFORMATION_SCHEMA` `COLUMNS` table, the
    `COLUMN_TYPE` value for the `colors` column of the `item` table looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`SET` columns are similar, except that they say `set` rather than `enum`. For
    either data type, extract the permitted values by stripping the initial word and
    the parentheses, splitting at the commas, and removing the enclosing quotes from
    the individual values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a `get_enumorset_info()` routine to extract these values from the
    data-type definition. While we’re at it, we can have the routine return the column’s
    type, its default value, and whether values can be `NULL`. Then the routine can
    be used by scripts that may need more than just the list of values. Here is a
    version in Ruby. Its arguments are a database handle, a database name, a table
    name, and a column name. It returns a hash with entries corresponding to the various
    aspects of the column definition (or `nil` if the column does not exist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The routine uses case-insensitive matching when checking the data type and nullable
    attributes. This guards against future lettercase changes in metadata results.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to access and display each element of the hash
    returned by `get_enumorset_info()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'That code produces the following output for the `profile` table `color` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Equivalent routines for other APIs are similar. You can find implementations
    in the *lib* directory of the `recipes` distribution. Such routines are useful
    for validation of input values (see [Recipe 14.11](ch14.xhtml#nch-format-format-meta)).
  prefs: []
  type: TYPE_NORMAL
- en: 12.7 Getting Server Metadata
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get information about the MySQL server itself, such as its version,
    configuration, and current status of its components.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several SQL functions and `SHOW` statements return information about the server.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL has several SQL functions and statements that provide you with information
    about the server itself and about your current client session. [Table 12-5](#nch-meta-meta-server-funcs)
    shows a few that you may find useful. Both `SHOW` statements permit a `GLOBAL`
    or `SESSION` keyword to select global server values or values specific to your
    session, and a `LIKE` `''`*`pattern`*`''` clause for limiting the results to variable
    names matching the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-5\. SQL Functions and Statements to Obtain Server Metadata
  prefs: []
  type: TYPE_NORMAL
- en: '| Statement | Information produced by statement |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT VERSION()` | Server version string |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT DATABASE()` | Default database name (`NULL` if none) |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT USER()` | Current user as given by client when connecting |'
  prefs: []
  type: TYPE_TB
- en: '| `SELECT CURRENT_USER()` | User used for checking client privileges |'
  prefs: []
  type: TYPE_TB
- en: '| `SHOW [GLOBAL&#124;SESSION] STATUS` | Server global or session status indicators
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SHOW [GLOBAL&#124;SESSION] VARIABLES` | Server global or status configuration
    variables |'
  prefs: []
  type: TYPE_TB
- en: 'To obtain the information provided by any statement in the table, execute it
    and process its result set. For example, `SELECT` `DATABASE()` returns the name
    of the default database or `NULL` if no database has been selected. The following
    Ruby code uses the statement to present a status display containing information
    about the current session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'A given API might provide alternatives to executing SQL statements to access
    these types of information. For example, JDBC has several database-independent
    methods for obtaining server metadata. Use your connection object to obtain the
    database metadata, then invoke the appropriate methods to get the information
    in which you’re interested. Consult a JDBC reference for a complete list, but
    here are a few representative examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more discussion about the use of `SHOW` (and `INFORMATION_SCHEMA`) in the
    context of server monitoring, see [Recipe 23.2](ch23.xhtml#nch-monitoring-monitoring-sources).
  prefs: []
  type: TYPE_NORMAL
- en: 12.8 Writing Applications That Adapt to the MySQL Server Version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use a given feature that is available only as of a particular version
    of MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ask the server for its version number. If the server is too old to support a
    given feature, maybe you can fall back to a workaround, if one exists. Or suggest
    your user to upgrade.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With each new release of MySQL, new features are added. If you’re writing an
    application that requires certain features, check the server version to determine
    whether they are present; if not, you must perform some sort of workaround (assuming
    there is one).
  prefs: []
  type: TYPE_NORMAL
- en: To get the server version, invoke the `VERSION()` function. The result is a
    string that looks something like `5.7.33-debug-log` or `8.0.25`. In other words,
    it returns a string consisting of major, minor, and <q>patch</q> version numbers,
    possibly some nondigits at the end of the <q>patch</q> version, and possibly some
    suffix. The version string can be used as is for presentation purposes, but for
    comparisons, it’s simpler to work with a number—in particular, a five-digit number
    in *`Mmmtt`* format, in which *`M`*, *`mm`*, *`tt`* are the major, minor, and
    patch version numbers. Perform the conversion by splitting the string at the periods,
    stripping from the third piece the suffix that begins with the first nonnumeric
    character, and joining the pieces. For example, `5.7.33-debug-log` becomes `50733`,
    and `8.0.25` becomes `80025`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a Perl DBI function that takes a database-handle argument and returns
    a two-element list that contains both the string and numeric forms of the server
    version. The code assumes that the minor and patch version parts are less than
    100 and thus no more than two digits each. That should be a valid assumption because
    the source code for MySQL itself uses the same format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'To get both forms of the version information at once, call the function like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'To get just one of the values, call it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The following examples demonstrate how to use the numeric version value to
    check whether the server supports certain features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `recipes` distribution *metadata* directory contains `get_server_version()`
    implementations in other API languages, and the *routines* directory contains
    a `server_version()` stored function for use in SQL statements. The latter function
    returns only the numeric value because `VERSION()` already produces the string
    value. The following example shows how to use it to implement a stored procedure
    that enables password locking for *`N`* failed login attempts if the server is
    recent enough to support the `ALTER USER ... FAILED_LOGIN_ATTEMPTS` statement
    (MySQL 8.0.19 or later):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '`expire_password()` requires the `exec_stmt()` helper routine (see [Recipe
    11.6](ch11.xhtml#nch-routines-dynamic-sql-helpers)). Both are available in the
    *routines* directory. For more information about password expiration, see [Recipe
    24.5](ch24.xhtml#nch-security-password-expiration).'
  prefs: []
  type: TYPE_NORMAL
- en: 12.9 Getting Child Tables That Reference a Specific Table via Foreign Key Constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know which other tables refer to your table as parent via foreign
    key constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query the tables `INFORMATION_SCHEMA.TABLE_CONSTRAINTS` and `INFORMATION_SCHEMA.KEY_COLUMN_USAGE`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Foreign key constraints provide integrity checks as we discuss in [“Using Foreign
    Keys to Enforce Referential Integrity and Prevent Mismatches”](ch16.xhtml#nch-multi-multi-fks).
    They do it by preventing statements that modify data, referenced by the linked
    table, to execute if the result of the statement can break integrity. Foreign
    keys help keeping the data correct, but at the same time they can raise SQL errors
    that is hard to troubleshoot. And while it is easy to figure out which table is
    a parent for the particular child, it is not easy to find which table is a child
    of the particular parent. Still it would be good to know if a table is referenced
    by a child in case if you plan to modify it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table `INFORMATION_SCHEMA.TABLE_CONSTRAINTS` contains all the constraints,
    created for your MySQL installation. To select foreign key constraints, narrow
    your search with the clause `WHERE CONSTRAINT_TYPE=''FOREIGN KEY''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The listing above prints foreign keys we created for the example in [Recipe
    11.10](ch11.xhtml#nch-routines-routines-diagnostic-area). However, this output
    still lists only the child table. To find out which table is parent we need to
    join `INFORMATION_SCHEMA.TABLE_CONSTRAINTS` with table `INFORMATION_SCHEMA.KEY_COLUMN_USAGE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: In the listing above columns `TABLE_NAME` and `COLUMN_NAME` refer the child
    table and columns `REFERENCED_TABLE_NAME` and `REFERENCED_COLUMN_NAME` refer the
    parent table.
  prefs: []
  type: TYPE_NORMAL
- en: 'For InnoDB tables you may also query tables `INNODB_FOREIGN` and `INNODB_FOREIGN_COLS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Note that these tables take data from the internal InnoDB data dictionary that
    stores database and table names in one field. Therefore you need to use the operator
    `LIKE` to limit results to the specific database or table.
  prefs: []
  type: TYPE_NORMAL
- en: 12.10 Listing Triggers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to list triggers, defined for your table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query the table `INFORMATION_SCHEMA.TRIGGERS`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Knowing which triggers are defined for the specific tables is very useful when
    you tune performance. Especially in situations when:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple update, affecting a couple of rows, runs much longer than you expect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tables, not participating in the application load and not visible in the processlist,
    wait for or hold the locks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk IO is high.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to list triggers, created for the table `auction` use the following
    query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This way, you can have information such as when a trigger is fired, and its
    body definition. If there are more than one trigger you will see all of them.
  prefs: []
  type: TYPE_NORMAL
- en: 12.11 Listing Stored Routines and Scheduled Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know which stored procedures, functions and scheduled events are
    created in your database.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query the tables `INFORMATION_SCHEMA.ROUTINES` and `INFORMATION_SCHEMA.EVENTS`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To list both stored functions and stored procedures, query the table `INFORMATION_SCHEMA.ROUTINES`.
    If you want to distinguish which kind of routine it is, narrow your search by
    specifying `ROUTINE_TYPE` either `FUNCTION` or `PROCEDURE` by the `WHERE` condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to list all routines that participate in sequence generation as
    we discuss in [Recipe 15.17](ch15.xhtml#nch-sequences-seq-custom) use following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You may additionally select the column `ROUTINE_DEFINITION` to obtain the routine
    body.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get list of scheduled events, query the table `INFORMATION_SCHEMA.EVENTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This table holds not only event definitions, but also such metadata as when
    it was executed last time, it’s scheduled interval and if it is enabled or disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 12.12 Listing installed plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know which plugins are installed for your MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query the table `INFORMATION_SCHEMA.PLUGINS`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL is highly modular system. Many of its parts are pluggable. For example,
    all storage engines are also plugins. Therefore it is important to know which
    are available on your server. To get information about installed plugins, query
    the table `INFORMATION_SCHEMA.PLUGINS`, or run the command `SHOW PLUGINS`. While
    the latter is convenient for the interactive use, the former provides more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'For storage engines you can obtain even more details if query the table `INFORMATION_SCHEMA.ENGINES`,
    or run the command `SHOW ENGINES`. Here is the table content for the InnoDB storage
    engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 12.13 Listing Character Sets and Collations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sort order, defining which letters are equal, does not work for you and you
    want to study which other options you have.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obtain a list of characters sets, their default collation and available collations
    by querying tables `INFORMATION_SCHEMA.CHARACTER_SETS` and `INFORMATION_SCHEMA.COLLATIONS`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Recipe 7.5](ch07.xhtml#nch-strings-strings-charset-checking-changing) we
    discuss how to change or set string’s character set and collation. But how do
    you choose the one that suits your application requirements best?
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, MySQL itself can help you to find the answer. Inside MySQL client,
    select from the `INFORMATION_SCHEMA.CHARACTER_SETS` table to get list of all available
    character sets, their default collations and maximum character lenght they can
    store. For example, to list all Unicode character sets, run the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Each character set may have not only default collation, but other collations
    that allow you to adjust sort order. For example, Turkish capital letters <q>I</q>
    and <q>İ</q>, as well as <q>S</q> and <q>Ş</q> are considered equal by the `utf8mb4`
    character set with the default collation. This leads to a situation when MySQL
    thinks that Turksih words <q>ISSIZ</q> (deserted) and <q>İŞSİZ</q> (unemployed)
    are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: To resolve this situation let’s check the table `INFORMATION_SCHEMA.COLLATIONS`
    for the collations of the character set `utf8mb4`, applicable for the Turkish
    language.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try them we will recieve the correct result: the words <q>deserted</q>
    and <q>unemployed</q> are no longer considered equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Character set `utf8mb4` is default and works well for most of setups. However,
    you may be in a situation when this is not the case. For example, if you store
    the Russian words <q>совершенный</q> (perfect) and <q>совершённый</q> (accomplished)
    in a `utf8mb4` column with default collation, MySQL will consider these two words
    equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]two_words[PRE77]perfect[PRE78]accomplished[PRE79]'
  prefs: []
  type: TYPE_NORMAL
- en: 'An intuitive way to solve this issue is to use available collations for the
    Russian language: `utf8mb4_ru_0900_ai_ci`. Unfortunately, this does not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this is that the collation `utf8mb4_ru_0900_ai_ci` is accent
    insensitive. Its case sensitive and accent sensitive variation `utf8mb4_ru_0900_as_cs`
    solves the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Collations `utf8mb4_ru_0900_ai_ci` and `utf8mb4_ru_0900_as_cs` were added in
    version 8.0\. If you are still using version 5.7 and are working on the application
    where such difference is critical you may also examine the table `INFORMATION_SCHEMA.CHARACTER_SETS`
    for a character set that supports Cyrillic alphabet and try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: We have chosen character set `cp1251` for our example, but all of them resolve
    this comparison issue.
  prefs: []
  type: TYPE_NORMAL
- en: 12.14 Listing CHECK Constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to examine which `CHECK` constraints are defined for your database.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query the tables `INFORMATION_SCHEMA.CHECK_CONSTRAINTS` and `INFORMATION_SCHEMA.TABLE_CONSTRAINTS`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The table `INFORMATION_SCHEMA.CHECK_CONSTRAINTS` contains list of all constraints,
    the schema for which they are definded, and the `CHECK_CLAUSE` that is practically
    the constraint definition. However, the table does not store information about
    for which table the constraint is created. To list both constraints and tables
    for which they are defined join table `INFORMATION_SCHEMA.CHECK_CONSTRAINTS` with
    table `INFORMATION_SCHEMA.TABLE_CONSTRAINTS`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
