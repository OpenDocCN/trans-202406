- en: Chapter 8\. Migrating to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve heard that TypeScript is great. You also know from painful experience
    that maintaining your 15-year-old, 100,000-line JavaScript library isn’t. If only
    it could become a TypeScript library!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter offers some advice about migrating your JavaScript project to TypeScript
    without losing your sanity and abandoning the effort.
  prefs: []
  type: TYPE_NORMAL
- en: Only the smallest codebases can be migrated in one fell swoop. The key for larger
    projects is to migrate gradually. [Item 60](#allowjs) discusses how to do this.
    For a long migration, it’s essential to track your progress and make sure you
    don’t backslide. This creates a sense of momentum and inevitability to the change.
    [Item 61](#convert-up-the-graph) discusses ways to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating a large project to TypeScript won’t necessarily be easy, but it does
    offer a huge potential upside. A 2017 study found that 15% of bugs fixed in JavaScript
    projects on GitHub could have been prevented with TypeScript.^([1](ch08.html#idm45331644007096))
    Even more impressive, a survey of six months’ worth of postmortems at AirBnb found
    that 38% of them could have been prevented by TypeScript.^([2](ch08.html#idm45331644005032))
    If you’re advocating for TypeScript at your organization, stats like these will
    help! So will running some experiments and finding early adopters. [Item 59](#jsdoc-tscheck)
    discusses how to experiment with TypeScript before you begin migration.
  prefs: []
  type: TYPE_NORMAL
- en: Since this chapter is largely about JavaScript, many of the code samples are
    either pure JavaScript (and not expected to pass the type checker) or checked
    with looser settings (e.g., with `noImplicitAny` off).
  prefs: []
  type: TYPE_NORMAL
- en: 'Item 58: Write Modern JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to checking your code for type safety, TypeScript compiles your
    TypeScript code to any version of JavaScript code, all the way back to 1999 vintage
    ES3\. Since TypeScript is a superset of the *latest* version of JavaScript, this
    means that you can use `tsc` as a “transpiler”: something that takes new JavaScript
    and converts it to older, more widely supported JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking a different perspective, this means that when you decide to convert
    an existing JavaScript codebase to TypeScript, there’s no downside to adopting
    all the latest JavaScript features. In fact, there’s quite a bit of upside: because
    TypeScript is designed to work with modern JavaScript, modernizing your JS is
    a great first step toward adopting TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: And because TypeScript is a superset of JavaScript, learning to write more modern
    and idiomatic JavaScript means you’re learning to write better TypeScript, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'This item gives a quick tour of some of the features in modern JavaScript,
    which I’m defining here as everything introduced in ES2015 (aka ES6) and after.
    This material is covered in much greater detail in other books and online. If
    any of the topics mentioned here are unfamiliar, you owe it to yourself to learn
    more about them. TypeScript can be tremendously helpful when you’re learning a
    new language feature like `async`/`await`: it almost certainly understands the
    feature better than you do and can guide you toward correct usage.'
  prefs: []
  type: TYPE_NORMAL
- en: These are all worth understanding, but by far the most important for adopting
    TypeScript are ECMAScript Modules and ES2015 classes.
  prefs: []
  type: TYPE_NORMAL
- en: Use ECMAScript Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the 2015 version of ECMAScript there was no standard way to break your
    code into separate modules. There were many solutions, from multiple `<script>`
    tags, manual concatenation, and Makefiles to node.js-style `require` statements
    or AMD-style `define` callbacks. TypeScript even had its own module system ([Item
    53](ch07.html#avoid-non-ecma)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Today there is one standard: ECMAScript modules, aka `import` and `export`.
    If your JavaScript codebase is still a single file, if you use concatenation or
    one of the other module systems, it’s time to switch to ES modules. This may require
    setting up a tool like webpack or ts-node. TypeScript works best with ES modules,
    and adopting them will facilitate your transition, not least because it will allow
    you to migrate modules one at a time (see [Item 61](#convert-up-the-graph)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The details will vary depending on your setup, but if you’re using CommonJS
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'then the ES module equivalent would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Use Classes Instead of Prototypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has a flexible prototype-based object model. But by and large JS
    developers have ignored this in favor of a more rigid class-based model. This
    was officially enshrined into the language with the introduction of the `class`
    keyword in ES2015.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your code uses prototypes in a straightforward way, switch to using classes.
    That is, instead of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript struggles with the prototype version of `Person` but understands
    the class-based version with minimal annotations. If you’re unfamiliar with the
    syntax, TypeScript will help you get it right.
  prefs: []
  type: TYPE_NORMAL
- en: For code that uses older-style classes, the TypeScript language service offers
    a “Convert function to an ES2015 class” quick fix that can speed this up ([Figure 8-1](#efts-08in01)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 08in01](assets/efts_08in01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. The TypeScript language service offers a quick fix to convert older-style
    classes to ES2015 classes.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use let/const Instead of var
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript’s `var` has some famously quirky scoping rules. If you’re curious
    to learn more about them, read *Effective JavaScript*. But better to avoid `var`
    and not worry! Instead, use `let` and `const`. They’re truly block-scoped and
    work in much more intuitive ways than `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Again, TypeScript will help you here. If changing `var` to `let` results in
    an error, then you’re almost certainly doing something you shouldn’t be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested function statements also have `var`-like scoping rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When you call `foo()`, it logs `hello` because the definition of `bar` is hoisted
    to the top of `foo`. This is surprising! Prefer function expressions (`const bar
    = () => { ... }`) instead.
  prefs: []
  type: TYPE_NORMAL
- en: Use for-of or Array Methods Instead of for(;;)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In classic JavaScript you used a C-style for loop to iterate over an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In modern JavaScript you can use a for-of loop instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is less prone to typos and doesn’t introduce an index variable. If you
    want the index variable, you can use `forEach`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Avoid using the for-in construct to iterate over arrays as it has many surprises
    (see [Item 16](ch02_split_001.html#number-index)).
  prefs: []
  type: TYPE_NORMAL
- en: Prefer Arrow Functions Over Function Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `this` keyword is one of the most famously confusing aspects of JavaScript
    because it has different scoping rules than other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally you want `this` to refer to the relevant instance of whichever class
    you’re in. Arrow functions help you do that by keeping the `this` value from their
    enclosing scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In addition to having simpler semantics, arrow functions are more concise. You
    should use them whenever possible. For more on `this` binding, see [Item 49](ch06.html#this-in-callbacks).
    With the `noImplicitThis` (or `strict`) compiler option, TypeScript will help
    you get your `this`-binding right.
  prefs: []
  type: TYPE_NORMAL
- en: Use Compact Object Literals and Destructuring Assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'you can simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In addition to being more concise, this encourages consistent naming of variables
    and properties, something your human readers will appreciate as well ([Item 36](ch04.html#language-of-domain)).
  prefs: []
  type: TYPE_NORMAL
- en: 'To return an object literal from an arrow function, wrap it in parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also shorthand for properties whose values are functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The inverse of compact object literals is object destructuring. Instead of
    writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'you can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'or even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this last example only `a` and `b` become variables, not `props`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may specify default values when destructuring. Instead of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also destructure arrays. This is particularly useful with tuple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Destructuring can also be used in function parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As with compact object literal syntax, destructuring is concise and encourages
    consistent variable naming. Use it!
  prefs: []
  type: TYPE_NORMAL
- en: Use Default Function Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, all function parameters are optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This is often used to implement default values for parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In modern JavaScript, you can specify the default value directly in the parameter
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to being more concise, this makes it clear that `base` is an optional
    parameter. Default parameters have another benefit when you migrate to TypeScript:
    they help the type checker infer the type of the parameter, removing the need
    for a type annotation. See [Item 19](ch03.html#avoid-inferable).'
  prefs: []
  type: TYPE_NORMAL
- en: Use async/await Instead of Raw Promises or Callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Item 25](ch03.html#use-async-await) explains why `async` and `await` are preferable,
    but the gist is that they’ll simplify your code, prevent bugs, and help types
    flow through your asynchronous code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of either of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Don’t Put use strict in TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ES5 introduced “strict mode” to make some suspect patterns more explicit errors.
    You enable it by putting `''use strict''` in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve never used strict mode in your JavaScript codebase, then give it a
    try. The errors it finds are likely to be ones that the TypeScript compiler will
    find, too.
  prefs: []
  type: TYPE_NORMAL
- en: But as you transition to TypeScript, there’s not much value in keeping `'use
    strict'` in your source code. By and large, the sanity checks that TypeScript
    provides are far stricter than those offered by strict mode.
  prefs: []
  type: TYPE_NORMAL
- en: There is some value in having a `'use strict'` in the JavaScript that `tsc`
    emits. If you set the `alwaysStrict` or `strict` compiler options, TypeScript
    will parse your code in strict mode and put a `'use strict'` in the JavaScript
    output for you.
  prefs: []
  type: TYPE_NORMAL
- en: In short, don’t write `'use strict'` in your TypeScript. Use `alwaysStrict`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: These are just a few of the many new JavaScript features that TypeScript lets
    you use. TC39, the body that governs JS standards, is very active, and new features
    are added year to year. The TypeScript team is currently committed to implementing
    any feature that reaches stage 3 (out of 4) in the standardization process, so
    you don’t even have to wait for the ink to dry. Check out the TC39 GitHub repo^([3](ch08.html#idm45331642441688))
    for the latest. As of this writing, the pipeline and decorators proposals in particular
    have great potential to impact TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript lets you write modern JavaScript whatever your runtime environment.
    Take advantage of this by using the language features it enables. In addition
    to improving your codebase, this will help TypeScript understand your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use TypeScript to learn language features like classes, destructuring, and `async`/`await`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Don’t bother with `''use strict''`: TypeScript is stricter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the TC39 GitHub repo and TypeScript release notes to learn about all the
    latest language features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 59: Use @ts-check and JSDoc to Experiment with TypeScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before you begin the process of converting your source files from JavaScript
    to TypeScript ([Item 60](#allowjs)), you may want to experiment with type checking
    to get an initial read on the sorts of issues that will come up. TypeScript’s
    `@ts-check` directive lets you do exactly this. It directs the type checker to
    analyze a single file and report whatever issues it finds. You can think of it
    as an extremely loose version of type checking: looser even than TypeScript with
    `noImplicitAny` off ([Item 2](ch01.html#which-ts)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript infers the type of `person.first` as `string`, so `2 * person.first`
    is a type error, no type annotations required.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it may surface this sort of blatant type error, or functions called with
    too many arguments, in practice, `// @ts-check` tends to turn up a few specific
    types of errors:'
  prefs: []
  type: TYPE_NORMAL
- en: Undeclared Globals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If these are symbols that you’re defining, then declare them with `let` or `const`.
    If they are “ambient” symbols that are defined elsewhere (in a `<script>` tag
    in an HTML file, for instance), then you can create a type declarations file to
    describe them.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have JavaScript like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'then you could create a file called *types.d.ts*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating this file on its own may fix the issue. If it does not, you may need
    to explicitly import it with a “triple-slash” reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This *types.d.ts* file is a valuable artifact that will become the basis for
    your project’s type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Unknown Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re using a third-party library, TypeScript needs to know about it. For
    example, you might use jQuery to set the size of an HTML element. With `@ts-check`,
    TypeScript will flag an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to install the type declarations for jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the error is specific to jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In fact, it should be `.css`, not `.style`.
  prefs: []
  type: TYPE_NORMAL
- en: '`@ts-check` lets you take advantage of the TypeScript declarations for popular
    JavaScript libraries without migrating to TypeScript yourself. This is one of
    the best reasons to use it.'
  prefs: []
  type: TYPE_NORMAL
- en: DOM Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming you’re writing code that runs in a web browser, TypeScript is likely
    to flag issues around your handling of DOM elements. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue is that only `HTMLInputElement`s have a `value` property, but `document.getElementById`
    returns the more generic `HTMLElement` (see [Item 55](ch07.html#understand-the-dom)).
    If you know that the `#age` element really is an `input` element, then this is
    an appropriate time to use a type assertion ([Item 9](ch02_split_000.html#prefer-declarations-to-assertions)).
    But this is still a JS file, so you can’t write `as HTMLInputElement`. Instead,
    you can assert a type using JSDoc:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you mouse over `ageEl` in your editor, you’ll see that TypeScript now considers
    it an `HTMLInputElement`. Take care as you type the JSDoc `@type` annotation:
    the parentheses after the comment are required.'
  prefs: []
  type: TYPE_NORMAL
- en: This leads to another type of error that comes up with `@ts-check`, inaccurate
    JSDoc, as explained next.
  prefs: []
  type: TYPE_NORMAL
- en: Inaccurate JSDoc
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your project already has JSDoc-style comments, TypeScript will begin checking
    them when you flip on `@ts-check`. If you previously used a system like the Closure
    Compiler that used these comments to enforce type safety, then this shouldn’t
    cause major headaches. But you may be in for some surprises if your comments were
    more like “aspirational JSDoc”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The first issue is a misunderstanding of the DOM: `getBoundingClientRect()`
    is defined on `Element`, not `Node`. So the `@param` tag should be updated. The
    second is a mismatch between proprties specified in the `@return` tag and the
    implementation. Presumably the rest of the project uses the `width` and `height`
    properties, so the `@return` tag should be updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use JSDoc to gradually add type annotations to your project. The TypeScript
    language service will offer to infer type annotations as a quick fix for code
    where it’s clear from usage, as shown here and in [Figure 8-2](#efts-08in02):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![efts 08in02](assets/efts_08in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. The TypeScript Language Services offer a quick fix to infer paramter
    types from usage.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This results in a correct JSDoc annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be helpful to encourage types to flow through your code with `@ts-check`.
    But it doesn’t always work so well. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use the quick fix to annotate `data`, you’ll wind up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is structural typing gone awry ([Item 4](ch01.html#structural)). While
    the function would technically work on any sort of object with a `forEach` method
    with that signature, the intent was most likely for the parameter to be `{files:
    string[]}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get much of the TypeScript experience in a JavaScript project using
    JSDoc annotations and `@ts-check`. This is appealing because it requires no changes
    in your tooling. But it’s best not to go too far in this direction. Comment boilerplate
    has real costs: it’s easy for your logic to get lost in a sea of JSDoc. TypeScript
    works best with *.ts* files, not *.js* files. The goal is ultimately to convert
    your project to TypeScript, not to JavaScript with JSDoc annotations. But `@ts-check`
    can be a useful way to experiment with types and find some initial errors, especially
    for projects that already have extensive JSDoc annotations.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add "`// @ts-check`" to the top of a JavaScript file to enable type checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize common errors. Know how to declare globals and add type declarations
    for third-party libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use JSDoc annotations for type assertions and better type inference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t spend too much time getting your code perfectly typed with JSDoc. Remember
    that the goal is to convert to *.ts*!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 60: Use allowJs to Mix TypeScript and JavaScript'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a small project, you may be able to convert from JavaScript to TypeScript
    in one fell swoop. But for a larger project this “stop the world” approach won’t
    work. You need to be able to transition gradually. That means you need a way for
    TypeScript and JavaScript to coexist.
  prefs: []
  type: TYPE_NORMAL
- en: The key to this is the `allowJs` compiler option. With `allowJs`, TypeScript
    files and JavaScript files may import one another. For JavaScript files this mode
    is extremely permissive. Unless you use `@ts-check` ([Item 59](#jsdoc-tscheck)),
    the only errors you’ll see are syntax errors. This is “TypeScript is a superset
    of JavaScript” in the most trivial sense.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s unlikely to catch errors, `allowJs` does give you an opportunity
    to introduce TypeScript into your build chain before you start making code changes.
    This is a good idea because you’ll want to be able to run your tests as you convert
    modules to TypeScript ([Item 61](#convert-up-the-graph)).
  prefs: []
  type: TYPE_NORMAL
- en: 'If your bundler includes TypeScript integration or has a plug-in available,
    that’s usually the easiest path forward. With `browserify`, for instance, you
    run `npm install --sav-dev tsify` and add it as a plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Most unit testing tools have an option like this as well. With the `jest` tool,
    for instance, you install `ts-jest` and pass TypeScript sources through it by
    specifying a `jest.config.js` like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If your build chain is custom, your task will be more involved. But there’s
    always a good fallback option: when you specify the `outDir` option, TypeScript
    will generate pure JavaScript sources in a directory that parallels your source
    tree. Usually your existing build chain can be run over that. You may need to
    tweak TypeScript’s JavaScript output so that it closely matches your original
    JavaScript source, (e.g., by specifying the `target` and `module` options).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding TypeScript into your build and test process may not be the most enjoyable
    task, but it is an essential one that will let you begin to migrate your code
    with confidence.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `allowJs` compiler option to support mixed JavaScript and TypeScript
    as you transition your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get your tests and build chain working with TypeScript before beginning large-scale
    migration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 61: Convert Module by Module Up Your Dependency Graph'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ve adopted modern JavaScript, converting your project to use ECMAScript
    modules and classes ([Item 58](#write-modern-js)). You’ve integrated TypeScript
    into your build chain and have all your tests passing ([Item 60](#allowjs)). Now
    for the fun part: converting your JavaScript to TypeScript. But where to begin?'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you add types to a module, it’s likely to surface new type errors in all
    the modules that depend on it. Ideally you’d like to convert each module once
    and be done with it. This implies that you should convert modules going *up* the
    dependency graph: starting with the leaves (modules that depend on no others)
    and moving up to the root.'
  prefs: []
  type: TYPE_NORMAL
- en: The very first modules to migrate are your third-party dependencies since, by
    definition, you depend on them but they do not depend on you. Usually this means
    installing `@types` modules. If you use the `lodash` utility library, for example,
    you’d run `npm install --save-dev @types/lodash`. These typings will help types
    flow through your code and surface issues in your use of the libraries.
  prefs: []
  type: TYPE_NORMAL
- en: If your code calls external APIs, you may also want to add type declarations
    for these early on. Although these calls may happen anywhere in your code, this
    is still in the spirit of moving up the dependency graph since you depend on the
    APIs but they do not depend on you. Many types flow from API calls, and these
    are generally difficult to infer from context. If you can find a spec for the
    API, generate types from that (see [Item 35](ch04.html#consider-codegen)).
  prefs: []
  type: TYPE_NORMAL
- en: As you migrate your own modules, it’s helpful to visualize the dependency graph.
    [Figure 8-3](#initial-dag) shows an example graph from a medium-sized JavaScript
    project, made using the excellent `madge` tool.
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 0801](assets/efts_0801.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. The dependency graph for a medium-sized JavaScript project. Arrows
    indicate dependencies. Darker-shaded boxes indicate that a module is involved
    in a circular dependency.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The bottom of this dependency graph is the circular dependency between *utils.js*
    and *tickers.js*. There are many modules that depend on these two, but they only
    depend on one another. This pattern is quite common: most projects will have some
    sort of utility module at the bottom of the dependency graph.'
  prefs: []
  type: TYPE_NORMAL
- en: As you migrate your code, focus on adding types rather than refactoring. If
    this is an old project, you’re likely to notice some strange things and want to
    fix them. Resist this urge! The immediate goal is to convert your project to TypeScript,
    not to improve its design. Instead, write down code smells as you detect them
    and make a list of future refactors.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few common errors you’ll run into as you convert to TypeScript.
    Some of these were covered in [Item 59](#jsdoc-tscheck), but new ones include:'
  prefs: []
  type: TYPE_NORMAL
- en: Undeclared Class Members
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Classes in JavaScript do not need to declare their members, but classes in
    TypeScript do. When you rename a class’s *.js* file to *.ts*, it’s likely to show
    errors for every single property you reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: There’s a helpful quick fix (see [Figure 8-4](#efts-08in03)) for this that you
    should take advantage of.
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 08in03](assets/efts_08in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. The quick fix to add declarations for missing members is particularly
    helpful in converting a class to TypeScript.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This will add declarations for the missing members based on usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript was able to get the type for `greeting` correct, but not the type
    for `name`. After applying this quick fix, you should look through the property
    list and fix the `any` types.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time you’ve seen the full property list for your class,
    you may be in for a shock. When I converted the main class in *dygraph.js* (the
    root module in [Figure 8-3](#initial-dag)), I discovered that it had no fewer
    than 45 member variables! Migrating to TypeScript has a way of surfacing bad designs
    like this that were previously implicit. It’s harder to justify a bad design if
    you have to look at it. But again, resist the urge to refactor now. Note the oddity
    and think about how you’d fix it some other day.
  prefs: []
  type: TYPE_NORMAL
- en: Values with Changing Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript will complain about code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This topic is covered in more depth in [Item 23](ch03.html#all-at-once), so
    you may want to brush up on that item if you run into this error. If the fix is
    trivial, you can build the object all at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If it is not, then this is an appropriate time to use a type assertion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You should fix this eventually (see [Item 9](ch02_split_000.html#prefer-declarations-to-assertions)),
    but this is expedient and will help you keep the migration going.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve been using JSDoc and `@ts-check` ([Item 59](#jsdoc-tscheck)), be
    aware that you can actually *lose* type safety by converting to TypeScript. For
    instance, TypeScript flags an error in this JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When you convert to TypeScript, the `@ts-check` and JSDoc stop being enforced.
    This means the type of `num` is implicitly `any`, so there’s no error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately there’s a quick fix available to move JSDoc types to TypeScript
    types. If you have any JSDoc, you should use what’s shown in [Figure 8-5](#efts-08in04).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 08in04](assets/efts_08in04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. Quick fix to copy JSDoc annotations to TypeScript type annotations
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Once you’ve copied type annotations to TypeScript, make sure to remove them
    from the JSDoc to avoid redundancy (see [Item 30](ch04.html#jsdoc-repeat)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: This issue will also be caught when you turn on `noImplicitAny`, but you may
    as well add the types now.
  prefs: []
  type: TYPE_NORMAL
- en: Migrate your tests last. They should be at the top of your dependency graph
    (since your code doesn’t depend on them), and it’s extremely helpful to know that
    your tests continue to pass during the migration despite your not having changed
    them at all.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start migration by adding `@types` for third-party modules and external API
    calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Begin migrating your modules from the bottom of the dependency graph upwards.
    The first module will usually be some sort of utility code. Consider visualizing
    the dependency graph to help you track progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resist the urge to refactor your code as you uncover odd designs. Keep a list
    of ideas for future refactors, but stay focused on TypeScript conversion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware of common errors that come up during conversion. Copy JSDoc annotations
    if necessary to avoid losing type safety as you convert.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 62: Don’t Consider Migration Complete Until You Enable noImplicitAny'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Converting your whole project to *.ts* is a big accomplishment. But your work
    isn’t done quite yet. Your next goal is to turn on the `noImplicitAny` option
    ([Item 2](ch01.html#which-ts)). TypeScript code without `noImplicitAny` is best
    thought of as transitional because it can mask real errors you’ve made in your
    type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, perhaps you’ve used the “Add all missing members” quick fix to
    add property declarations to a class ([Item 61](#convert-up-the-graph)). You’re
    left with an `any` type and would like to fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '`indices` sounds like it should be an array of numbers, so you plug in that
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'No new errors result, so you then keep moving. Unfortunately, you’ve made a
    mistake: `number[]` is the wrong type. Here’s some code from elsewhere in the
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Clearly `number[][]` or `[number, number][]` would be a more accurate type.
    Does it surprise you that indexing into a `number` is allowed? Take this as an
    indication of just how loose TypeScript can be without `noImplicitAny`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you turn on `noImplicitAny`, this becomes an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: A good strategy for enabling `noImplicitAny` is to set it in your local client
    and start fixing errors. The number of errors you get from the type checker gives
    you a good sense of your progress. You can commit the type corrections without
    committing the *tsconfig.json* change until you get the number of errors down
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many other knobs you can turn to increase the strictness of type
    checking, culminating with `"strict": true`. But `noImplicitAny` is the most important
    one and your project will get most of the benefits of TypeScript even if you don’t
    adopt other settings like `strictNullChecks`. Give everyone on your team a chance
    to get used to TypeScript before you adopt stricter settings.'
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Don’t consider your TypeScript migration done until you adopt `noImplicitAny`.
    Loose type checking can mask real mistakes in type declarations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix type errors gradually before enforcing `noImplicitAny`. Give your team a
    chance to get comfortable with TypeScript before adopting stricter checks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '^([1](ch08.html#idm45331644007096-marker)) Z. Gao, C. Bird, and E. T. Barr,
    “To Type or Not to Type: Quantifying Detectable Bugs in JavaScript,” ICSE 2017,
    [*http://earlbarr.com/publications/typestudy.pdf*](http://earlbarr.com/publications/typestudy.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#idm45331644005032-marker)) Brie Bunge, “Adopting TypeScript
    at Scale,” JSConf Hawaii 2019, [*https://youtu.be/P-J9Eg7hJwE*](https://youtu.be/P-J9Eg7hJwE).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#idm45331642441688-marker)) [*https://github.com/tc39/proposals*](https://github.com/tc39/proposals)
  prefs: []
  type: TYPE_NORMAL
