- en: Chapter 18\. Node Modules
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great aspects of writing Node.js applications is the built-in modularity
    the environment provides. It’s simple to download and install any number of Node
    modules, and using them is equally simple: just include a single `require()` statement
    naming the module, and you’re off and running.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The ease with which the modules can be incorporated is one of the benefits of
    JavaScript *modularization*. Modularizing ensures that external functionality
    is created in such a way that it isn’t dependent on other external functionality,
    a concept known as *loose coupling*. This means I can use a `Foo` module, without
    having to include a `Bar` module, because `Foo` is tightly dependent on having
    `Bar` included.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript modularization is both a discipline and a contract. The discipline
    comes in having to follow certain mandated criteria in order for external code
    to participate in the module system. The contract is between you, me, and other
    JavaScript developers: we’re following an agreed-on path when we produce (or consume)
    external functionality in a module system, and we all have expectations based
    on the module system.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One major dependency on virtually all aspects of application and library management
    and publication is the use of Git, a source control system, and GitHub, an extremely
    popular Git *endpoint*. How Git works and using Git with GitHub are beyond the
    scope of this book. I recommend the *[Git Pocket Guide](http://shop.oreilly.com/product/0636920024972.do)*
    by Richard Silverman (O’Reilly) to get more familiar with Git, and GitHub’s [own
    documentation](https://github.com) for more on using this service.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Searching for a Specific Node Module via npm
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re creating a Node application and want to use existing modules, but you
    don’t know how to discover them.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Downloading a Package with npm”](ch01.html#installing_npm_package) explains
    how to install packages with npm, Node’s popular package manager (and the glue
    that holds the Node universe together). But you haven’t yet considered how to
    *find* the useful packages that you need in npm’s sprawling registry.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, you’ll discover modules via recommendations from your friends
    and codevelopers, but sometimes you need something new. You can search for new
    modules directly at the [npm website](https://www.npmjs.org). You can also use
    the npm command-line interface directly to search for a module. For instance,
    if you’re interested in modules that do something with PDFs, run the following
    search at the command line:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Discussion
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The npm website provides more than just documentation for using npm; it also
    provides an interface for searching for modules. If you access each module’s page
    at npm, you can see how popular the module is, what other modules are dependent
    on it, the license, and other relevant information.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: However, you can also search for modules, directly, using npm. The process can
    take a fair amount of time and when it finishes, you’re likely to get a huge number
    of modules in return, especially with a broader topic such as modules that work
    with PDFs.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'You can refine the results by listing multiple terms:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This query returns a much smaller list of modules, specific to PDF generation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you do find a module that sounds interesting, you can get detailed information
    about it with:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You’ll get useful information from the *package.json* of the module, which can
    tell you what it’s dependent on, who wrote it, and when it was created. We still
    recommend checking out the module’s npm website page and GitHub repository page
    directly. There you’ll be able to determine if the module is being actively maintained,
    get a sense of how popular the module is, review open issues, and look at the
    source code.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Converting Your Library into a Node Module
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use one of your libraries in Node.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Convert the library into a Node module. In Node, each file is treated as a
    module. For example, if the library is a file containing a function stored at
    `/lib/hello.js`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can convert it to work as a Node module with the `exports` keyword:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternately, can also `export` the function directly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can then use the module in your application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node’s default module system is based on CommonJS, which uses three constructs:
    `exports` to define what’s exported from the library, `require()` to include the
    module in the application, and `module`, which includes information about the
    module but also can be used to export a function directly.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'If your library returns an object with several functions and data objects,
    you can assign each to the comparably named property on `module.exports`, or you
    could return an object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'or:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And then access the object properties directly:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because the module isn’t installed using npm, and just resides in the directory
    where the application resides, it’s accessed by the file location and name, not
    just the name.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [“Taking Your Code Across Module Environments”](#creating_compatible_modules),
    we cover how to make sure your library code works in both CommonJS and ECMAScript
    module environments.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: In [“Creating an Installable Node Module”](#creating_installable_node_module),
    we cover how to create an standalone module.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Taking Your Code Across Module Environments
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve written a library that you’d like to share with others, but folks are
    using a variety of Node versions with both CommonJS and ECMAScript modules. How
    can you ensure your library works in all of the various environments?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use CommonJS modules with an ECMAScript module wrapper.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'First, write the library as a CommonJS module, saved with the *.cjs* file extension:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Followed by an ECMAScript wrapper module, which uses the *.mjs* file extension:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And a *package.json* file, which includes the `type`, `main`, and `exports`
    fields:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Users of our module, using CommonJS syntax, can use the `require` syntax to
    import the module:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'or:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While those using ECMAScript modules can specify the `module` version of the
    library to use the ES `import` syntax:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'or:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the time of writing, it is possible to avoid the */module* naming convention
    for ECMAScript modules using the `--experimental-conditional-exports` flag. However,
    due to the current experimental nature and the potential of future changes in
    the syntax, we currently recommend against it. In future versions of Node, this
    will likely become the standard. You can read more about this approach in the
    [Node documentation](https://oreil.ly/Xzkid).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CommonJS modules have been the standard in Node since the beginning, and tools
    such as Browserify brought this syntax out of the Node ecosystem, allowing developers
    to use Node style modules in the browser. The ECMAScript 2015 (also known as ES6)
    standard introduced a native JavaScript module syntax, which was introduced in
    Node 8.5.0 and could be used behind an `--experimental-module` flag. Beginning
    with Node 13.2.0, Node ships with native support for ECMAScript modules.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: A common pattern is to write a module using either the CommonJS or ECMAScript
    module syntax and use a compile tool to ship both as either separate module entry
    points or exported paths. However, this runs the risk of a module being loaded
    twice if it is loaded directly via one syntax by the application and either loaded
    directly or by a dependency using the other syntax.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'In *package.json* there are three key fields:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`"type"`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Specifies that this is a `module`, meaning that this library is using the ECMAScript
    module syntax. For libraries that exclusively use CommonJS, the `"type"` would
    be `"commonjs"`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '`"main"`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the main entry point of the application, for which we will point to
    the CommonJS file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '`"exports"`'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Defines the exported paths of our modules. Through this consumers of the default
    `package` will receive the CommonJS module directly, while those using `package/module`
    will import the file from the ECMAScript module wrapper.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wish to avoid using the *.cjs* and *.mjs* file extensions, we may do
    so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See Also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [“Writing Multiplatform Libraries”](#multiplatform), we cover how to make
    sure your library code works across multiple module environments in both Node
    and the browser by using Webpack as a code bundler.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Installable Node Module
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve either created a Node module from scratch, or converted an existing library
    to one that will work in the browser or in Node. Now, you want to know how to
    modify it into a module that can be installed using npm.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you’ve created your Node module and any supporting functionality (including
    module tests), you can package the entire directory. The key to packaging and
    publishing the Node module is creating a *package.json* file that describes the
    module, any dependencies, the directory structure, what to ignore, and so on.
    You can generate a *package.json* file by running the `npm init` command in the
    root of the project’s directory and following the prompts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a relatively basic *package.json* file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once you’ve created *package.json*, package all the source directories and the
    *package.json* file as a gzipped tarball. Then install the package locally, or
    install it in npm for public access.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *package.json* file is key to packaging up a Node module for local installation
    or uploading to npm for management. At a minimum, it requires a `name` and a `version`.
    The other fields given in the solution are:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '`description`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: A description of what the module is and does
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`main`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Entry file for the module
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '`author`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Author(s) of the module
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`keywords`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: List of keywords that can help others find the module
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`repository`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Place where the code lives, typically GitHub
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '`engines`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Node versions you know your module works with
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '`bugs`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Where to file bugs
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '`licenses`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: License for your module
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`dependencies`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: A list of dependencies required by the module
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '`directories`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: A hash describing the directory structure for your module
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '`scripts`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: A hash of object commands that are run during the module life cycle
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a host of other options that are described at the [npm website](https://oreil.ly/iXynV).
    You can also use a tool to help you fill in many of these fields. Typing the following
    at the command line runs the tool that asks questions and then generates a basic
    *package.json* file:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once you have your source set up and your *package.json* file, you can test
    whether everything works by running the following command in the top-level directory
    of your module:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you have no errors, then you can package the file as a gzipped tarball.
    At this point, if you want to publish the module, you’ll first need to add yourself
    as a user in the npm registry:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To publish the Node module to the npm registry, use the following in the root
    directory of the module, specifying a URL to the tarball, a filename for the tarball,
    or a path:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you have development dependencies for your module, such as using a testing
    framework like Jest, one excellent shortcut to ensure these are added to your
    *package.json* file is to use the following, in the same directory as the *package.json*
    file, when you’re installing the dependent module:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Not only does this install Jest (discussed later, in [“Unit Testing Your Modules”](#unit_testing_node_modules)),
    this command also updates your *package.json* file with the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can also use this same type of option to add a module to `dependencies`
    in *package.json*. The following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'adds the following to the *package.json* file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the module is no longer needed and shouldn’t be listed in *package.json*,
    remove it from the `devDependencies` with:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And remove a module to `dependencies` with:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the module is the last in either `dependencies` or `devDependencies`, the
    property isn’t removed. It’s just set to an empty value:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: npm provides [a decent developer guide for creating and installing a Node module](https://oreil.ly/ifa4e).
    You should consider the use of an *.npmignore* or *.gitignore* file for keeping
    stuff *out* of your module. And though this is beyond the scope of the book, you
    should also become familiar with Git and GitHub, and make use of it for your applications/modules.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: The README File and Markdown Syntax'
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you package your module or library for reuse and upload it to a source
    repository such as GitHub, you’ll need to provide how-to information about installing
    the module/library and basic information about how to use it. For this, you need
    a README file.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: You’ve likely seen files named *README.md* with applications and Node modules.
    They’re text-based with some odd, unobtrusive markup that you’re not sure is useful,
    until you see it in a site like GitHub, where the README file provides all of
    the project page installation and usage information. The markup translates into
    HTML, making for readable web-based help.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The content for the README is marked up with annotation known as Markdown. The
    popular website Daring Fireball calls Markdown easy to read and write, but “Readability,
    however, is emphasized above all else.” Unlike with HTML, the Markdown markup
    doesn’t get in the way of reading the text.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Daring Fireball also provides an [overview of generic Markdown](https://oreil.ly/qkKRT),
    but if you’re working with GitHub files, you might also want to check out [GitHub’s
    Flavored Markdown](https://help.github.com/en/github/writing-on-github).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample *REAMDE.md* file:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Most popular text editors include Markdown syntax highlighting and previewing
    capabilities. There are also desktop Markdown editors available for all platforms.
    I can also use a CLI tool, like [Pandoc](https://oreil.ly/Cc4GX), to covert the
    *README.md* file into readable HTML:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Figure 18-1](#generated_html_from_markdown) displays the generated content.
    It’s not fancy, but it is eminently readable.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 1801](assets/jsc3_1801.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: Figure 18-1\. Generated HTML from README.md text and Markdown annotation
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you host your source code at a site such as GitHub, GitHub uses the *README.md*
    file to generate the cover page for the repository.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Writing Multiplatform Libraries
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve created a library that is useful both in the browser and in Node.js,
    and would like to make it available in both environments.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a bundling tool, such as Webpack, to bundle your library so that it works
    as an ES2015 module, CommonJS module, and AMD module, and can be loaded as a script
    tag in the browser.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'In Webpack’s *webpack.config.js* file, include the `library` and `libraryTarget`
    fields, which signify that the module should be bundled as a library and target
    multiple environments:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `library` field specifies a name for the library that will be used in ECMAScript,
    CommonJS, and AMD module environments. The `libraryTarget` field allows you to
    specify how the module will be exposed. The default is `var`, which will expose
    a variable. Specifying `umd` will utilize the JavaScript [Universal Module Definition
    (UMD)](https://oreil.ly/VSpd0), enabling the ability for multiple module styles
    to consume the library. To make the UMD build available in both browser and Node.js
    environments, you will need to set the `output.globalObject` option to `this`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For more details on using Webpack to bundle code, see [Chapter 17](ch17.html#ch17).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the example, I’ve created a simple math library. Currently, the only function
    is one called `squareIt`, which accepts a number as a parameter and returns the
    value of that number multiplied by itself. This is at *src/index.js*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The *package.json* file contains Webpack and the Webpack command-line interface
    (CLI) as development dependencies. It also points the `main` distribution at the
    bundled version of the library, which Webpack will output to the *dist* folder.
    I’ve also added a build script that will run the Webpack bundler, aptly named
    `build`. This will allow me to generate the bundle by typing `npm run build` (or
    `yarn run build` if using Yarn).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, my project contains a *webpack.config.js*, as described in the recipe:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With this setup, the command `npm run build` will bundle the library and place
    it within the *dist* directory of the project. This bundled file is what consumers
    of the library will use.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To test the package locally, before publishing it to npm, run `npm link` from
    the root of the project directory. Then in a separate project, where you’d like
    to use the module, type `npm link <library name>`. Doing so will create a symbolic
    link to the package, as though it is globally installed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the library
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once your library is complete, you will most likely want to publish it to npm
    for distribution. Make sure that your project is version controlled with Git and
    has been pushed to a public remote repository (such as GitHub or GitLab). From
    the root of your project’s directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Once published to a remote Git repository and the npm registry, the library
    can be consumed by running `npm install`, downloading or cloning the Git repository,
    or directly referencing the library in a web page using *https://unpkg.com/<library-name>*.
    The library can be consumed across the multiple JavaScript library formats.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'As an ES 2015 module:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As a CommonJS module:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As an AMD module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And using a script tag on a web page:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Handling library dependencies
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Oftentimes a library may contain subdependencies. With our current setup, all
    dependencies will be packaged and bundled with the library itself. To limit the
    outputted bundle and to ensure that library consumers are not installing multiple
    instances of a subdependency, it may be best to treat them as a “peer dependency,”
    which must also be installed or referenced on its own. To do so, add an `externals`
    property to your *webpack.config.js*. In the instance below, `moment` is being
    used as a peer dependency:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this configuration, `moment` will be treated as a global variable by our
    library.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing Your Modules
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make sure your module is functioning correctly and ready to be used
    by others.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add *unit tests* as part of your production process.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following module, named `bbarray`, and created in a file named *index.js*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using [Jest](https://jestjs.io), a JavaScript testing framework, the following
    unit test (created as *index.js* and located in the project’s *test* subdirectory)
    should result in the successful pass of six tests:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The result of the test is shown in [Figure 18-2](#result_of_jest_test), run
    using `npm test`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 1802](assets/jsc3_1802.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
- en: Figure 18-2\. Running unit tests based on Jest
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *unit test* is a way that developers test their code to ensure it meets the
    specifications. It involves testing functional behavior, and seeing what happens
    when you send bad arguments—or no arguments at all. It’s called unit testing because
    it’s used with individual units of code, such as testing one module in a Node
    application, as compared to testing the entire Node application. It becomes one
    part of *integration testing*, where all the pieces are plugged together, before
    going to *user acceptance testing*: testing to ensure that the application does
    what users expect it to do (and that they generally don’t hate it when they use
    it).'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is one of those development tasks that may seem like a pain when
    you first start, but can soon become second nature. A good goal is to develop
    both tests and code in parallel to one another. Many developers even practice
    *test-driven development*, where unit tests are written prior to the code itself.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: In the solution, we use Jest, a sophisticated testing framework. The module
    is simple, so we’re not using some of the more complex Jest testing mechanisms.
    However, this provides an example of the building blocks of writing unit tests.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Jest, use the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'I’m using the `--save-dev` flag, because I’m installing Jest into the module’s
    development dependencies. In addition, I modify the module’s *package.json* file
    to add the following section:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The test script is saved as *index.js* in the *tests* subdirectory under the
    project. Jest automatically looks for files in a *tests* directory or files following
    the *filename.test.js* naming pattern. The following command runs the test:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The Jest unit tests makes use of [*expect matchers*](https://oreil.ly/E7RnY)
    to test for the returned values.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
