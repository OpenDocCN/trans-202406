- en: Chapter 19\. Managing Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Node ecosystem reaches far and wide, from running scripts on a laptop to
    managing data on remote servers. The diversity of Node’s core functionality, combined
    with the thousands of user-created modules, provides a rich environment for accomplishing
    nearly any programming task. However, this diversity can also present a challenge
    in navigating the options for accomplishing common tasks. This chapter demonstrates
    some of the common issues that Node developers may face.
  prefs: []
  type: TYPE_NORMAL
- en: Using Environment Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your Node application requires different values in different environments, such
    as on your local machine and in production.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use environment variables to set and read values in different environments.
    The core Node module `process` contains an `env` property, which will provide
    your application with access to any environment variables. In the following example,
    I am reading an environment variable named `NODE_ENV`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To set an environment variable, you can specify a value ahead of running the
    `node` command to start the application. The following will set the `NODE_ENV`
    value to `development` and run the `index.js` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with projects with multiple environment variables, it is typically
    preferable to store those values locally in an *.env* file. Doing so in Node requires
    the `dotenv` package, which can be instaled from npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now in your application code, require the module and initiate its configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With this module, environment variables can be read from a *.env* file, rather
    than being passed as arguments to the command line. The *.env* file can consist
    of a number of environment variable values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `process` object does not need to be imported as a module with a `require`
    statement as it is available globally to all Node programs. It is used to provide
    information about the current operating Node process, including the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reading an environment variable, it is often useful to use an `||` operator
    to specify a default value as a fallback for when a value is not provided in the
    environment. The following example will set the `port` variable to a value specified
    by a `PORT` environment variable, or `8080` if no environment variable value is
    provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dotenv` package is an npm module that allows you to load environment variables
    from a *.env* file. The usage is as straightforward as installing the package,
    combining the `require` statement, and initiating the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once initiated and configured, the module will automatically read the values
    from a file named *.env* in the root of the project’s directory. It is also possible
    to configure the package to read the file from an alternate location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you choose to use ECMAScript modules with your Node project, first import
    the package as module and then separately initiate the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When working in a production environment, it is common for the host to set
    the environment variables. In that instance, you will not want to load the values
    from an *.env* file. A useful pattern is to only load the `dotenv` module in nonproduction
    environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Never commit the *.env* file, and be sure to add it to your version control
    ignore list. These files are often used to store secure environment information,
    such as passwords or keys that should not be shared. A best practice is to instead
    include a file named *.env.example*, which contains blank or dummy values.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Callback Hell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to do something with asynchronous operations, such as read the contents
    of a file and append it to a new file. Node provides this functionality using
    callback functions, but to use it asynchronously, you end up with nested code
    (noted by indentations) that makes the application unreadable and difficult to
    maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Node version 8.0, we can use the `async/await` syntax along with the
    `promisfy` utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Node’s built-in `promisify` utility is incredibly useful as it enables any
    function that follows the common error, values, callback style to return a promise.
    In Node 10+, filesystem operations can be used as promises natively by using the
    `fs.promises` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By design, Node code is asynchronous, or nonblocking, meaning that while the
    code is waiting on an operation, it can do something else. Oftentimes, however,
    we require that these operations happen in a specific order. Traditionally in
    Node, this was accomplished using callback functions. A callback function is a
    function that is called after the execution of a task. In the following example,
    the code reads a file and then performs an operation within the callback function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `async/await` syntax allows you to write asynchronous code in a synchronous
    fashion. We cover `async/await` in detail in [Chapter 10](ch10.html#ch10):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with a function that follows the common error, values, callback
    style, we can use Node’s built-in `promisify` utility to return a promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `async/await`, errors are handled within `try/catch` blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example of how you can refactor existing code, the following example
    uses callbacks to write two lines to a file, read them back, and output the contents
    to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a relatively straightforward operation, but notice how quickly the
    indentation increases for the nested callbacks. We can clean it up using `async/await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is much easier to understand without sacrificing the asynchronous code
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: In each of the examples, I’ve used filesystem operations, but the `async/await`
    syntax is incredibly useful for a wide range of use cases in Node, including database
    interactions, fetching remote resources, hashing strings, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Command-Line Functionality Within a Node Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to access a command-line utility, such as ImageMagick, from within
    a Node application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use Node’s `child_process` module. For example, if you want to use ImageMagick’s
    `identify`, and then print out the data to the console, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `child_process` module provides four methods to run command-line operations
    and process returned data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spawn(command, [args], [options])`'
  prefs: []
  type: TYPE_NORMAL
- en: This launches a given process, with optional command-line arguments, and an
    `options` object specifying additional information, such as `cwd` to change directory
    and `uid` to find the user ID of the process.
  prefs: []
  type: TYPE_NORMAL
- en: '`exec(command, [options], callback)`'
  prefs: []
  type: TYPE_NORMAL
- en: This runs a command in a shell and buffers the result.
  prefs: []
  type: TYPE_NORMAL
- en: '`execFile(file, [args],[options],[callback])`'
  prefs: []
  type: TYPE_NORMAL
- en: This is like `exec()` but executes the file directly.
  prefs: []
  type: TYPE_NORMAL
- en: '`fork(modulePath, [args],[options])`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a special case of `spawn()`, and spawns Node processes, returning an
    object that has a communication channel built in. It also requires a separate
    instance of V8 with each use, so use sparingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `child_process` methods have three streams associated with them: `stdin`,
    `stdout`, and `stderr`. The `spawn()` method is the most widely used of the `child_process`
    methods, and the one used in the solution. From the solution top, the command
    given is the ImageMagick `identify` command-line application, which can return
    a wealth of information about an image. In the *`args`* array, the code passes
    in the `--verbose` flag and the name of the image file. When the `data` event
    happens with the `child_process.stdout` stream, the application prints it to the
    console. The data is a buffer that uses `toString()` implicitly when concatenated
    with another string. If an error happens, it’s also printed out to the console.
    A third event handler just communicates that the child process is exiting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to process the result as an array, modify the input event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now the data is processed into an array of strings, split on the new line within
    the `identify` output.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Instead of using a child process, if you have either GraphicsMagick or ImageMagick
    installed, you can use the [`gm` Node module](http://aheckmann.github.io/gm) for
    accessing the imaging capability.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Using Child Processes with Windows'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The solution demonstrates how to use child processes in a macOS or Linux environment.
    There are similarities and differences between using child processes in Linux/Unix,
    and using them in Windows.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, you can’t explicitly give a command with a child process; you have
    to invoke the Windows `cmd.exe` executable and have it perform the process. In
    addition, the first flag to the command is `/c`, which tells `cmd.exe` to process
    the command and then terminate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Borrowing an example from [*Learning Node*](http://shop.oreilly.com/product/0636920024606.do)
    by Shelley Powers (O’Reilly), in the following code, the `cmd.exe` command is
    used to get a directory listing, using the Windows `dir` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Passing Command-Line Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You would like to be able to pass command-line arguments and read their values
    within your Node application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For simple use cases, utilize the `process.argv` property, which returns an
    array containing any command-line arguments passed to the program when it is run.
    Since these values are an array, we can iterate over them to read (or in this
    example, print) their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if I run my script, I can pass it command-line arguments, which will be
    printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Which will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Node’s `process` is a global object that allows a script to access information
    about the current Node.js process. The `argv` property or the `process` object
    contains the values of the arguments. The first index is always the path to the
    environment’s Node executable, the second value of the array is always the path
    to the script itself, and the remaining items are the arguments in the order that
    they were passed to the script.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Accessing arguments directly from Node’s `process` object provides a straightforward
    way to retrieve command-line properties. However, parsing and making use of these
    values can prove tricky. Thankfully, utilizing the popular module [Yargs](https://oreil.ly/Ue9LF)
    makes working with command-line arguments a more streamlined task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if I rerun my script, passing it command-line arguments, the values will
    be printed to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the Yargs module, you can easily read specific values and act on them
    in your script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: By using command-line arguments, you can utilize information passed at runtime
    and react accordingly. Yargs can handle a lot more than reading input values,
    such as configuring help commands, enabling Boolean input values, limiting values
    to predefined choices, and much more. I recommend consulting the [Yargs documentation](https://github.com/yargs/yargs#documentation)
    for additional resources and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Command-Line Utility with Help from Commander
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to turn your Node module into a Linux command-line utility, including
    support for command-line options/arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert your Node module to a Linux command-line utility, add the following
    line as the first line of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide for command-line arguments/options, including the ever-important
    `--help`, make use of the Commander module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [“Passing Command-Line Arguments”](#command-line) we discuss using the Yargs
    module, which simplifies the use of handling command-line arguments. Yargs is
    a great option for handling command-line argument inputs, while Commander is a
    fully featured module for building command-line-driven applications. We recommend
    taking a look at both options and choosing the one that is right for your use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To convert a Node module to a command-line utility, first add the following
    line to the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the module file’s mode to an executable, using CHMOD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the above example, I would type the following in the terminal, from
    the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The command-line utility I created simply logs the square of a number. Let’s
    look at a more complete example, which would create an image capture of a website
    using the [Puppeteer](https://github.com/puppeteer/puppeteer) library. In a file
    named *snapshot.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then update the *package.json* file so that our command can be named
    and used directly (without the *.js* extension):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now if we run `npm link`, we can use the command directly on our local machine,
    without referencing the file directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use the *long option*, consisting of a double-dash (`--`) followed
    by a complete word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And when you run the utility with either `-h` or `--help`, you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the following returns the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Commander generates all of this automatically, so we can focus on our utility’s
    primary functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Publishing a command-line utility to the `npm` registry is the same as any
    other module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Keeping a Node Instance Up and Running
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re in a production environment and want to start up a Node application,
    keep it running forever, and reload it without downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `pm2` module to ensure the application is restarted if it’s ever shut
    down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`pm2` is a CLI tool that can be used to not only start a Node application,
    but to ensure the application is restarted if, for some reason, it’s shut down.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `pm2` using npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then start your Node application, making use of `pm2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `start` action starts the Node application as a Unix *daemon* or background
    process. The utility can also make use of a number of options, which can all be
    listed with the `pm2 --help` command. A few that are particularly useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-l`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a log file
  prefs: []
  type: TYPE_NORMAL
- en: '`-o`'
  prefs: []
  type: TYPE_NORMAL
- en: Log stdout from the script to the specified output file
  prefs: []
  type: TYPE_NORMAL
- en: '`-e`'
  prefs: []
  type: TYPE_NORMAL
- en: Log stderr from the script to the specified error file
  prefs: []
  type: TYPE_NORMAL
- en: '`-n`'
  prefs: []
  type: TYPE_NORMAL
- en: Name the application
  prefs: []
  type: TYPE_NORMAL
- en: '`--watch`'
  prefs: []
  type: TYPE_NORMAL
- en: Watch for changes and restart the application
  prefs: []
  type: TYPE_NORMAL
- en: 'To start an application that includes these logs, use the flags and specify
    output files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Some other helpful `pm2` actions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`stop`'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the daemon script
  prefs: []
  type: TYPE_NORMAL
- en: '`restart`'
  prefs: []
  type: TYPE_NORMAL
- en: Restart the daemon script
  prefs: []
  type: TYPE_NORMAL
- en: '`delete`'
  prefs: []
  type: TYPE_NORMAL
- en: Delete the daemon script
  prefs: []
  type: TYPE_NORMAL
- en: '`describe`'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the details of a specific application
  prefs: []
  type: TYPE_NORMAL
- en: '`list`'
  prefs: []
  type: TYPE_NORMAL
- en: List all running scripts
  prefs: []
  type: TYPE_NORMAL
- en: '`monitor`'
  prefs: []
  type: TYPE_NORMAL
- en: Monitor logs, metrics, and application information
  prefs: []
  type: TYPE_NORMAL
- en: 'It can be very helpful to add an npm script to a project’s *package.json* file
    to run the `pm2` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With this addition, running `npm start` from the project’s root directory will
    start the application using `pm2`. As an added bonus, this is often the default
    behavior of many Node application cloud hosting platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Application Changes and Restarting During Local Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Development can get rather active, and it can be difficult to remember or time-consuming
    to restart an application each time the code has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `nodemon` utility to watch your source code and restart your application
    when the code changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use, first install `nodemon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of starting the application with `node`, use `nodemon` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `nodemon` utility monitors the files within the directory where it was started.
    If any of the files change, the Node application is automatically restarted. This
    is a handy way of making sure your running Node application reflects the most
    recent code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, `nodemon` is not a tool you want to use in a production system. Instead,
    use a process manager such as `pm2`, as discussed in [“Keeping a Node Instance
    Up and Running”](#keeping_node_up_running).
  prefs: []
  type: TYPE_NORMAL
- en: 'If the application accepts values when started, you can provide these on the
    command line, just as with Node, but precede them with the double dashes (`--`)
    flag, which signals to `nodemon` to ignore anything that follows and pass it to
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'When started, you should get feedback similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If the code changes, you’ll see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you want to manually restart the application, type `rs` into the terminal
    where nodemon is running. You can also use a configuration file or *package.json*
    configuration with the utility, monitor only select files or subdirectories, and
    even use it to run non-Node applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample *package.json* configuration, which will instruct `nodemon`
    to use `verbose` mode and ignore specific directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Scheduling Repeat Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a task that needs to be run repeatedly at specific intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use [`node-cron`](https://oreil.ly/dYQHv), which enables you to schedule tasks
    in Node using the GNU crontab syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will log to the console every minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `node-cron` module, first install it with npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: You can then use the `schedule` method along with the crontab syntax to create
    a scheduled task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The crontab syntax can be a bit confusing if you have never encountered it
    before. In the above example, I’ve used an asterisk for each field, which stands
    for “first-last.” We can replace the asterisks with the following values (in order):'
  prefs: []
  type: TYPE_NORMAL
- en: 'second (optional): 0–59'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'minute: 0–59'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'hour: 0–23'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'day of month: 0–31'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'month: 0–12 (or three-letter names)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'day of week: 0–7 (or three-letter names, 0 or 7 is Sunday )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following will run at five minutes after midnight on the first day of every
    month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also include ranges. The following will run a job at midnight, on each
    weekday from June through September:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '`node-cron` accepts two options: `scheduled` and `timezone`. The following
    will run a job at midnight in the same time zone as New York City:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`scheduled` is a Boolean value that defaults to `true`. Cron jobs will not
    run if the value is set to `false`. `timezone` allows you to set a specific time
    zone for the schedule. For all the time zone names, see the [Moment.js time zone
    page](https://oreil.ly/VhAkl).'
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Performance and Capability of Your WebSockets Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have an application that sends updated information on a frequent basis to
    every connected client, and you’re concerned about performance and how the application
    will handle the load.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ll want to perform both *speed (performance) tests* and *load testing*.
    See the discussion for details.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to Node and WebSockets and other bidirectional communication techniques,
    we no longer have to use timers in web pages to hit servers for new data. The
    server itself can push the data to all the connected clients whenever the data
    is fresh. The animated, scrolling timeline in [Example 17-4](ch17.html#feeding_scrolling_timeline)
    demonstrates this type of application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question then becomes: yes, it’s cool, but what does the coolness cost?
    Is my server going to crash and burn once 10 (100/1,000/10,000) clients connect?
    Will all the clients get the same response? The only answer to these questions
    comes from two types of tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Speed or performance testing, which tests how fast the page loads, especially
    when the server is under stress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load testing that emulates many concurrent clients accessing the page at once
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are services that provide both types of testing, and if you’re a large
    commercial operation and the reliability and performance of your application are
    critical, I definitely recommend taking advantage of them. Some, like [Load Impact](http://loadimpact.com),
    even provide a decent trial of its product before committing. There are also tools
    you can use that will hit a page concurrently and then print out the load responses
    for each (or even graph it). [Selenium](http://seleniumhq.org) is a very popular
    tool for performance testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Node world also provides tools we can install easily and quickly with npm.
    They may not have exactly the same polish as the commercial tools, but they’re
    certainly a lot cheaper. One tool to try is `loadtest`, which is an easier-to-run
    variation of ApacheBench (aka `ab`). You need to install it globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you run it from the command line. The following runs 200 requests
    per second (rps), with a concurrency of 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: There are several other options, and ApacheBench is also an alternative that
    can be good for performance testing. However, the tests don’t test the WebSockets
    connection because the request to the WebSockets server is contained in JavaScript
    that’s never processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is Thor, which is a load tester that’s run directly against
    the WebSocket server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an effective way of hammering (ahem) the WebSockets server with connections,
    but we’re still not getting the back and forth communication to *really* test
    the entire application, front and back. The connections are made, and then dropped
    as quickly, so it’s not really testing the communication as it exists if you and
    I were to access the application from our browsers. However, used with other tests
    that actually access the client page and process the WebSockets connection, they
    can help us determine if performance is going to be an issue with that many demands
    for connections (note: the app held up).'
  prefs: []
  type: TYPE_NORMAL
