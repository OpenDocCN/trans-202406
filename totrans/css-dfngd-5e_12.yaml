- en: Chapter 12\. Grid Layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章\. 网格布局
- en: At its inception, CSS had a layout-shaped hole at its center. Designers bent
    other features to the purposes of layout, most notably `float` and `clear`, and
    generally hacked their way around that hole. Flexbox layout helped to fill it,
    but flexbox is really meant for specific use cases, like navigation bars (navbars),
    as shown in [Chapter 11](ch11.html#flexbox).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 初创时，CSS 的核心存在一个布局上的空白。设计师将其他功能曲解为布局的目的，特别是`float`和`clear`，并通常围绕这个空白进行了各种hack。Flexbox
    布局帮助填补了这个空白，但Flexbox 实际上是为特定用例设计的，比如导航栏（如第11章中所示）。
- en: Grid layout, by contrast, is a *generalized* layout system. With its emphasis
    on rows and columns, it might at first feel like a return to table layout—and
    in certain ways that’s not too far off—but there is far, far more to grid layout
    than table layout. Grid allows pieces of the design to be laid out independently
    of their document source order, and even overlap pieces of the layout, if that’s
    your wish. CSS provides powerfully flexible methods for defining repeating patterns
    of grid lines, attaching elements to those grid lines, and more. You can nest
    grids inside grids, or for that matter, attach tables or flexbox containers to
    a grid. And much, much more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相反，网格布局是一种*广义*的布局系统。通过其对行和列的强调，它可能一开始感觉像是回归到表格布局——在某些方面，这并不算太远——但网格布局比表格布局要丰富得多。网格允许设计的不同部分独立于其文档源顺序布局，甚至可以重叠布局的各个部分，如果您希望如此。CSS
    提供了强大灵活的方法来定义网格线的重复模式，将元素附加到这些网格线上，等等。您可以嵌套网格，或者将表格或flexbox 容器附加到网格上。还有更多更多。
- en: In short, grid layout was the layout system we long waited for, and in 2017,
    it landed in all the major browser engines. It takes many, many layouts that were
    difficult, or even impossible, and invariably fragile, and allows you to create
    them simply, flexibly, and robustly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，网格布局是我们长期等待的布局系统，在2017年，它登陆了所有主要的浏览器引擎。它使许多难以或甚至不可能实现的布局变得简单、灵活且健壮。
- en: Creating a Grid Container
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网格容器
- en: 'The first step to creating a grid is defining a *grid container*. This is much
    like a containing block in positioning, or a flex container in flexible-box layout:
    a grid container is an element that defines a *grid formatting context* for its
    contents.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网格的第一步是定义*网格容器*。这与定位中的包含块或flex 布局中的flex 容器非常相似：网格容器是一个为其内容定义*网格格式化上下文*的元素。
- en: At this basic level, grid layout is quite reminiscent of flexbox. For example,
    the child elements of a grid container become *grid items*, just as the child
    elements of a flex container become flex items. The children of those grid items
    do *not* become grid elements—although any grid item can itself be made a grid
    container, and thus have its child elements become grid items to the nested grid.
    It’s possible to nest grids inside grids, until it’s grids all the way down.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础层面上，网格布局与Flexbox 非常相似。例如，网格容器的子元素成为*网格项*，就像Flex 容器的子元素成为Flex 项一样。这些网格项的子元素*不会*成为网格元素——尽管任何网格项本身都可以成为网格容器，并且其子元素成为嵌套网格的网格项。可以嵌套网格直至到底层都是网格。
- en: 'CSS has two kinds of grids: *regular* grids and *inline* grids. These are created
    with special values for the `display` property: `grid` and `inline-grid`. The
    first generates a block-level box, and the second an inline-level box. [Figure 12-1](#grids_and_inline_grids)
    illustrates the difference.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 有两种网格：*常规*网格和*内联*网格。这些是使用`display`属性的特殊值创建的：`grid`和`inline-grid`。前者生成块级框，后者生成内联级框。[图 12-1](#grids_and_inline_grids)说明了它们的区别。
- en: '![image](assets/css5_1201.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1201.png)'
- en: Figure 12-1\. Grids and inline grids
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-1\. 网格和内联网格
- en: These are very similar to the `block` and `inline-block` values for `display`.
    Most grids you create are likely to be block-level, though the ability to create
    inline grids is always there should you need it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些与`block`和`inline-block`值相似，用于`display`。你创建的大多数网格可能是块级的，尽管在需要时，总是可以创建内联网格。
- en: 'Although `display: grid` creates a block-level grid, the specification is careful
    to explicitly state that “grid containers are not block containers.” Although
    the grid box participates in layout much as a block container does, there are
    differences between them.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然`display: grid`创建一个块级网格，但规范明确指出“网格容器不是块容器”。虽然网格框在布局中的参与方式与块容器类似，但它们之间存在差异。'
- en: First off, floated elements do not intrude into the grid container. What this
    means in practice is that a grid will not slide under a floated element, as a
    block container will. See [Figure 12-2](#floats_interact_differently) for a demonstration
    of the difference.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，浮动元素不会侵入到网格容器中。实际上，这意味着网格不会像块级容器那样滑动到浮动元素下面。参见[图 12-2](#floats_interact_differently)以查看差异的演示。
- en: '![image](assets/css5_1202.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1202.png)'
- en: Figure 12-2\. Floats interact differently with blocks and grids
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-2\. 浮动元素与块和网格的不同交互方式
- en: Furthermore, the margins of a grid container do not collapse with the margins
    of its descendants. Again, this is distinct from block boxes, whose margins do
    (by default) collapse with descendants. For example, the first list item in an
    ordered list may have a top margin, but this margin will collapse with the list
    element’s top margin. The top margin of a grid item will *never* collapse with
    the top margin of its grid container. [Figure 12-3](#margin_collapsing) illustrates
    the difference.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，网格容器的边距不会与其后代的边距折叠。这与块级盒子不同，后者的边距（默认情况下）会与后代的边距折叠。例如，有序列表中的第一项可能具有顶部边距，但此边距将与列表元素的顶部边距折叠。网格项目的顶部边距*永远不会*与其网格容器的顶部边距折叠。参见[图 12-3](#margin_collapsing)以说明差异。
- en: '![image](assets/css5_1203.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1203.png)'
- en: Figure 12-3\. Margin collapsing and the lack thereof
  id: totrans-17
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-3\. 边距折叠与不折叠
- en: 'A few CSS properties and features do not apply to grid containers and grid
    items:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一些CSS属性和功能不适用于网格容器和网格项目：
- en: All `column` properties (e.g., `column-count`, `columns`, etc.) are ignored
    when applied to a grid container. (You can learn more about multicolumn properties
    at [CSS Multi-Column Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns).)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用于网格容器时，所有`column`属性（例如`column-count`、`columns`等）都会被忽略。（您可以在[CSS多列布局](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns)了解更多关于多列属性的信息。）
- en: The `::first-line` and `::first-letter` pseudo-elements do not apply to grid
    containers and are ignored.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`::first-line`和`::first-letter`伪元素不适用于网格容器，会被忽略。'
- en: '`float` and `clear` are effectively ignored for grid items (though not grid
    containers). Despite this, the `float` property still helps determine the computed
    value of the `display` property for children of a grid container, because the
    `display` value of the grid items is resolved *before* they’re made into grid
    items.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于网格项目，`float`和`clear`实际上被忽略（尽管网格容器不会）。尽管如此，`float`属性仍然有助于确定子网格容器的`display`属性的计算值，因为网格项目的`display`值在它们成为网格项目之前就已解析。
- en: 'The `vertical-align` property has no effect on the placement of grid items,
    though it may affect the content inside the grid item. (Don’t worry: we’ll talk
    later about other, more powerful ways to align grid items.)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vertical-align`属性对网格项目的定位没有影响，尽管它可能影响网格项目内部的内容。（不用担心：稍后我们将讨论其他更强大的网格项目对齐方式。）'
- en: Lastly, if a grid container’s declared `display` value is `inline-grid` *and*
    the element is either floated or absolutely positioned, the computed value of
    `display` becomes `grid` (thus dropping `inline-grid`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果网格容器声明的`display`属性值为`inline-grid` *且* 元素被浮动或绝对定位，那么`display`属性的计算值将变为`grid`（因此放弃了`inline-grid`）。
- en: Once you’ve defined a grid container, the next step is to set up the grid within.
    Before we explore how that works, though, it’s necessary to cover some terminology.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你定义了一个网格容器，下一步是设置内部的网格。然而，在探讨其工作原理之前，有必要先了解一些术语。
- en: Understanding Basic Grid Terminology
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解基本网格术语
- en: 'We’ve already talked about grid containers and grid items, but let’s define
    them in a bit more detail. As we said before, a *grid container* is a box that
    establishes a *grid-formatting context*—that is, an area in which a grid is created
    and elements are laid out according to the rules of grid layout instead of block
    layout. You can think of it like the way an element set to `display: table` creates
    a table-formatting context within it. Given the grid-like nature of tables, this
    comparison is fairly apt, though be sure not to make the assumption that grids
    are just tables in another form. Grids are far more powerful than tables ever
    were.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经讨论过网格容器和网格项目，但让我们稍微详细定义它们。正如我们之前所说，*网格容器*是一个创建*网格格式化上下文*的盒子—也就是说，在这个区域内创建网格，并根据网格布局的规则而不是块布局来布局元素。你可以把它想象成设置为`display:
    table`的元素在其中创建表格格式化上下文的方式。考虑到表格的网格性质，这种比较相当合适，但请务必不要假设网格只是另一种形式的表格。网格比表格强大得多。'
- en: 'A *grid item* is a thing that participates in grid layout within a grid-formatting
    context. This is usually a child element of a grid container, but it can also
    be the anonymous (that is, not contained within an element) bits of text that
    are part of an element’s content. Consider the following, which has the result
    shown in [Figure 12-4](#grid_items):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![image](assets/css5_1204.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4\. Grid items
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice how each element, *and* each bit of text between the elements, has become
    a grid item. The image is a grid item, just as much as the elements and text runs—seven
    grid items in all. Each will participate in the grid layout, although the anonymous
    text runs will be much more difficult (or impossible) to affect with the various
    grid properties we’ll discuss.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re wondering about `grid-template-rows` and `grid-template-columns`,
    we’ll tackle them in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In the course of using those properties, you’ll create or reference several
    core components of grid layout. These are summarized in [Figure 12-5](#grid_components).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'The most fundamental unit is the *grid line*. By defining the placement of
    one or more grid lines, you implicitly create the rest of the grid’s components:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Grid track
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: A continuous run between two adjacent grid lines—in other words, a *grid column*
    or a *grid row*. It goes from one edge of the grid container to the other. The
    size of a grid track is dependent on the placement of the grid lines that define
    it. These are analogous to table columns and rows. More generically, these can
    be referred to as *block-axis* and *inline-axis* tracks, where (in Western languages)
    column tracks are on the block axis and row tracks are on the inline axis.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1205.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5\. Grid components
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Grid cell
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Any space bounded by four grid lines, with no grid lines running through it,
    analogous to a table cell. This is the smallest unit of area in grid layout. Grid
    cells cannot be directly addressed with CSS grid properties; that is, no property
    allows you to say a grid item should be associated with a given cell. (But see
    the next point for more details.)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Grid area
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Any rectangular area bounded by four grid lines and made up of one or more grid
    cells. An area can be as small as a single cell or as large as all the cells in
    the grid. Grid areas *are* directly addressable by CSS grid properties, which
    allow you to define the areas and then associate grid items with them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: An important point to note is that these grid tracks, cells, and areas are entirely
    constructed of grid lines—and, more importantly, do not have to correspond to
    grid items. There is no requirement that all grid areas be filled with an item;
    it is perfectly possible to have some or even most of a grid’s cells be empty
    of any content. You can also have grid items overlap each other, either by defining
    overlapping grid areas or by using grid-line references that create overlapping
    situations.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Another fact to keep in mind is that you can define as many or as few grid lines
    as you wish. You could literally define just a set of vertical grid lines, thus
    creating a bunch of columns and only one row. Or you could go the other way, creating
    a bunch of row tracks and no column tracks (though there would be one, stretching
    from one side of the grid container to the other).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要记住的事实是，您可以根据需要定义多少个网格线。您可以只定义一组垂直网格线，从而创建一堆列和仅一个行。或者您可以走另一条路，创建一堆行轨道而没有列轨道（虽然会有一个，从网格容器的一边延伸到另一边）。
- en: The flip side is that if you create a condition preventing a grid item from
    being placed within the column and row tracks you define, or if you explicitly
    place a grid item outside those tracks, new grid lines and tracks will be automatically
    added to the grid to accommodate, creating implicit grid tracks (a subject we’ll
    return to later in the chapter).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，如果您创建了一个条件，阻止网格项放置在您定义的列和行轨道内，或者明确将网格项放置在这些轨道之外，新的网格线和轨道将自动添加到网格中以适应，创建隐式网格轨道（我们将在本章后面返回此主题）。
- en: Creating Grid Lines
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建网格线
- en: It turns out that creating grid lines can get fairly complex. That’s not so
    much because the concept is difficult. CSS just provides many ways to get it done,
    and each uses its own subtly different syntax.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，创建网格线可能会变得相当复杂。这不是因为概念难以理解。CSS只是提供了许多完成任务的方法，每种方法都有其自己微妙不同的语法。
- en: We’ll start by looking at two closely related properties.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看两个密切相关的属性。
- en: With these properties, you can define the grid tracks of your overall *grid
    template*, or what the CSS specification calls the *explicit grid*. Everything
    depends on these grid tracks; fail to place them properly, and the whole layout
    can easily fall apart.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 借助这些属性，您可以定义整体网格模板的网格轨道，或者CSS规范所称的*显式网格*。一切都取决于这些网格轨道；如果未正确放置它们，整个布局很容易就会崩溃。
- en: 'Once you define a grid track, grid lines are created. If you create just one
    track for the whole grid, two lines are created: one at the start of the track
    and one at the end. Two tracks means three lines: one at the start of the first
    track, one between the two, and one at the end of the second track. And so on.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了网格轨道，就会创建网格线。如果您为整个网格创建了一个轨道，将创建两条线：一条在轨道开头，一条在末尾。如果有两个轨道，则意味着有三条线：一条在第一个轨道的开头，一条在两者之间，一条在第二个轨道的末尾。依此类推。
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: When you’re starting out with CSS grid layout, it’s probably a good idea to
    sketch out where the grid tracks need to be on paper first, or in some close digital
    analogue. Having a visual reference for where the lines will land, and how the
    tracks should behave, can make writing your grid CSS a lot easier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用CSS网格布局时，最好先在纸上或某种接近数字的数字中勾画出网格轨道的位置。有一个视觉参考可以确定线条的位置以及轨道应如何行动，这样写网格CSS会更容易些。
- en: The exact syntax patterns for <*`track-list`*> and <*`auto-track-list`*> are
    complex and nest a few layers deep, and unpacking them would take a lot of time
    and space that’s better devoted to just exploring how things work. There are a
    lot of ways to make all this happen, so before we start discussing those patterns,
    we have some basic things to establish.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <*`track-list`*>和<*`auto-track-list`*>的确切语法模式复杂且嵌套几层深，拆开它们需要大量时间和空间，最好专注于探索事物如何运作。有许多方法可以实现所有这些，因此在我们开始讨论这些模式之前，我们有一些基本的事情要建立。
- en: First, grid lines can always be referred to by number, but can also be explicitly
    named by the author. Take the grid shown in [Figure 12-6](#grid_line_numbers_and_names),
    for example. From your CSS, you can use any of the numbers to refer to a grid
    line, or you can use the defined names, or you can mix them together. Thus, you
    could say that a grid item stretches from column line `3` to line `steve`, and
    from row line `skylight` to line `2`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，网格线始终可以通过数字引用，但也可以由作者明确命名。例如，看看[图 12-6](#grid_line_numbers_and_names)中显示的网格。从您的
    CSS 中，您可以使用任何数字来引用网格线，或者您可以使用定义的名称，或者两者混合使用。因此，您可以说一个网格项从列线`3`延伸到线`steve`，从行线`skylight`延伸到线`2`。
- en: Note that a grid line can have more than one name. You can use any of them to
    refer to a given grid line, though you can’t combine them the way you can multiple
    class names. You might think that means it’s a good idea to avoid repeating grid-line
    names, but that’s not always the case, as you’ll soon see.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个网格线可以有多个名称。您可以使用任何一个名称来引用给定的网格线，尽管您不能像多个类名那样将它们组合在一起。您可能会认为这意味着应该避免重复网格线名称，但并非总是如此，很快您就会看到原因。
- en: '![image](assets/css5_1206.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1206.png)'
- en: Figure 12-6\. Grid-line numbers and names
  id: totrans-58
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-6\. 网格线编号和名称
- en: We used intentionally silly grid-line names in [Figure 12-6](#grid_line_numbers_and_names)
    to illustrate that you can pick any name you like, as well as to avoid the implication
    that there are “default” names. If you’d seen `start` for the first line, you
    might have assumed that the first line is always called that. Nope. If you want
    to stretch an element from `start` to `end`, you’ll need to define those names
    yourself. Fortunately, that’s simple to do.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[图 12-6](#grid_line_numbers_and_names)中故意使用了愚蠢的网格线命名，以说明您可以选择任何喜欢的名称，并避免暗示存在“默认”名称的可能性。如果您看到第一行使用了`start`，您可能会认为第一行总是这样命名的。错了。如果您想要将一个元素从`start`拉伸到`end`，您需要自己定义这些名称。幸运的是，这很简单。
- en: As we’ve said, many value patterns can be used to define the grid template.
    We’ll start with the simpler ones and work our way toward the more complex.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，可以使用许多值模式来定义网格模板。我们将从更简单的开始，逐步过渡到更复杂的模式。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll discuss the `subgrid` value in [“Using Subgrids”](#subgrid), after establishing
    how grid tracks and grid areas are defined, named, sized, combined, and so on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论`subgrid`值之前（在[“使用子网格”](#subgrid)一节中），我们需要先定义网格轨道和网格区域的命名、大小、组合等内容。
- en: Using Fixed-Width Grid Tracks
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用固定宽度网格轨道
- en: As our initial step, let’s create a grid whose grid tracks are a fixed width.
    We don’t necessarily mean a fixed length like pixels or ems; percentages also
    count as fixed width here. In this context, *fixed width* means the grid lines
    are placed such that the distance between them does not change because of content
    changes within the grid tracks.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们的初始步骤，让我们创建一个其网格轨道宽度固定的网格。这里的固定宽度并不一定是像素或em单位的固定长度；百分比也可以在这里算作固定宽度。在这个语境下，*固定宽度*
    意味着网格线的间距不会因为网格轨道内内容的变化而改变。
- en: 'So, as an example, this counts as a definition of three fixed-width grid columns:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，这被视为定义三个固定宽度网格列的示例：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That will place a line 200 pixels from the start of the grid container (by default,
    the left side); a second grid line half the width of the grid container away from
    the first; and a third line 100 pixels away from the second. This is illustrated
    in [Figure 12-7](#grid_line_placement).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在距离网格容器起始位置（默认为左侧）200像素处放置一条线；第二条网格线距第一条线的距离为网格容器宽度的一半；第三条线距第二条线100像素。这在[图 12-7](#grid_line_placement)中有示例。
- en: '![image](assets/css5_1207.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1207.png)'
- en: Figure 12-7\. Grid-line placement
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-7\. 网格线放置
- en: While it’s true that the second column can change in size if the grid container’s
    size changes, it will *not* change based on the content of the grid items. However
    wide or narrow the content placed in that second column, the column’s width will
    always be half the width of the grid container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第二列的大小可以随着网格容器的尺寸变化而改变，但它不会根据网格项的内容改变。无论放置在第二列中的内容是多宽或多窄，该列的宽度始终是网格容器宽度的一半。
- en: It’s also true that the last grid line doesn’t reach the right edge of the grid
    container. That’s fine; it doesn’t have to. If you want it to—and you probably
    will—you’ll see various ways to deal with that in just a bit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条网格线确实没有达到网格容器的右边缘。没关系；它不必如此。如果您希望它达到右边缘——您很可能会这样希望——稍后您将看到各种处理方法。
- en: 'This is all lovely, but what if you want to name your grid lines? Just place
    any grid-line name you want, and as many as you want, in the appropriate place
    in the value, surrounded by square brackets. That’s all! Let’s add some names
    to our previous example, with the result shown in [Figure 12-8](#grid_name_placement):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但如果您想要为网格线命名怎么办？只需将任何您想要的网格线名称放在值中的适当位置，用方括号括起来即可。就是这样！让我们在前面的示例中添加一些名称，结果显示在[图 12-8](#grid_name_placement)中：
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![image](assets/css5_1208.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1208.png)'
- en: Figure 12-8\. Grid-line naming
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-8\. 网格线命名
- en: What’s nice is that adding the names makes clear that each value is actually
    specifying a grid track’s width, which means there is always a grid line to either
    side of a width value. Thus, for the three widths we have, four grid lines are
    actually created.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 令人满意的是，添加名称使每个值都清楚地指定了网格轨道的宽度，这意味着宽度值的两侧始终存在网格线。因此，对于我们拥有的三个宽度，实际上创建了四条网格线。
- en: 'Row grid lines are placed in exactly the same way as columns, as [Figure 12-9](#creating_a_grid)
    shows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 行网格线的放置方式与列完全相同，正如[图 12-9](#creating_a_grid)所示：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![image](assets/css5_1209.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1209.png)'
- en: Figure 12-9\. Creating a grid
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-9\. 创建网格
- en: We have a couple of things to point out here. First, both column and row lines
    have the names `start` and `end`. This is perfectly OK. Rows and columns don’t
    share the same namespace, so you can reuse names like these in the two contexts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几件事情需要指出。首先，列和行线都有名称`start`和`end`。这完全没问题。行和列不共享相同的命名空间，因此可以在这两个上下文中重复使用这样的名称。
- en: Second is the percentage value for the `content` row track. This is calculated
    with respect to the height of the grid container; thus, a container 500 pixels
    tall would yield a `content` row that’s 400 pixels tall (because the percentage
    value of this row is `80%`). Doing this generally requires that you know ahead
    of time how tall the grid container will be, which won’t always be the case.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`content`行轨道的百分比值。这是相对于网格容器的高度计算的；因此，一个高度为500像素的容器将产生一个高度为400像素的`content`行（因为此行的百分比值为`80%`）。通常情况下，这要求您预先知道网格容器的高度，但并非总是如此。
- en: 'You might think we could just say `100%` and have it fill out the space, but
    that doesn’t work, as [Figure 12-10](#exceeding_the_grid_container) illustrates:
    the `content` row track will be as tall as the grid container itself, thus pushing
    the `footer` row track out of the container altogether:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会认为我们可以说`100%`并填充空间，但这并不起作用，如[图 12-10](#exceeding_the_grid_container)所示：`content`行轨道将与网格容器本身一样高，从而将`footer`行轨道推出容器外：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![image](assets/css5_1210.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1210.png)'
- en: Figure 12-10\. Exceeding the grid container
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-10\. 超过网格容器
- en: 'One way (not necessarily the best way) to handle this scenario is to *minmax*
    the row’s value, telling the browser that you want the row no shorter than one
    amount and no taller than another, leaving the browser to fill in the exact value.
    This is done with the `minmax(a,b)` pattern, where `a` is the minimum size and
    `b` is the maximum size:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种情况的一种方式（不一定是最佳方式）是*minmax*行的值，告诉浏览器您希望行不低于一定值，也不高于另一定值，留给浏览器填写确切的值。这是使用`minmax(a,b)`模式完成的，其中`a`是最小尺寸，`b`是最大尺寸：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code indicates that the `content` row should never be shorter than 3 ems
    tall, and never taller than the grid container itself. This allows the browser
    to bring up the size until it’s tall enough to fit the space left over from the
    `masthead` and `footer` tracks, and no more. It also allows the browser to make
    it shorter than that, as long as it’s not shorter than `3em`, so this is not a
    guaranteed result. [Figure 12-11](#adapting_to_the_grid_container) shows one possible
    outcome of this approach.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码表示`content`行的高度永远不应小于3个em，并且永远不应比网格容器本身更高。这允许浏览器将其大小增加到足以适应从`masthead`和`footer`轨道剩余空间中获得的大小，但不再增加。它还允许浏览器将其缩短，只要不短于`3em`，因此这并非保证结果。[图 12-11](#adapting_to_the_grid_container)展示了此方法的一种可能结果。
- en: '![image](assets/css5_1211.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1211.png)'
- en: Figure 12-11\. Adapting to the grid container
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-11\. 适应网格容器
- en: In like fashion, with the same caveats, `minmax()` could have been used to help
    the `col-b` column fill out the space across the grid container. The thing to
    remember with `minmax()` is that if the *max* is smaller than the *min*, the *max*
    value is thrown out and the *min* value is used as a fixed-width track length.
    Thus, `minmax(100px, 2em)` would resolve to `100px` for any font-size value smaller
    than `50px`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，带有相同警告的情况下，`minmax()`可以用来帮助`col-b`列充满网格容器中的空间。使用`minmax()`需要记住的是，如果*max*小于*min*，则会舍弃*max*值，并使用*min*值作为固定宽度轨道长度。因此，对于任何小于`50px`的字体大小值，`minmax(100px,
    2em)`将解析为`100px`。
- en: 'If the vagueness of `minmax()`’s behavior unsettles you, CSS offers alternatives
    to this scenario. We could also have used the `calc()` value pattern to come up
    with a track’s height (or width). For example:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`minmax()`的行为不确定使您感到不安，CSS提供了这种情况的替代方案。我们也可以使用`calc()`值模式来计算轨道的高度（或宽度）。例如：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That would yield a `content` row exactly as tall as the grid container minus
    the sum of the `masthead` and `footer` heights, as we saw in the previous figure.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生一个`content`行，其高度正好等于网格容器减去`masthead`和`footer`高度之和，正如我们在上一个图中看到的。
- en: That works as far as it goes, but is a somewhat fragile solution, since any
    changes to the `masthead` or `footer` heights will also require an adjustment
    of the calculation. It also becomes a lot more difficult (or impossible) if you
    want more than one grid track to flex in this fashion. As it happens, CSS has
    much more robust ways to deal with this sort of situation, as you’ll see next.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在某种程度上可行，但却是一种比较脆弱的解决方案，因为任何对`masthead`或`footer`高度的更改也将需要调整计算。如果你希望多个网格轨道以这种方式灵活，那么这种方法就会变得更加困难（或不可能）。恰好，CSS有更加强大的方法来处理这种情况，接下来你会看到。
- en: Using Flexible Grid Tracks
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用灵活的网格轨道
- en: Thus far, all our grid tracks have been *inflexible*—their size determined by
    a length measure or the grid container’s dimensions, but unaffected by any other
    considerations. *Flexible* grid tracks, by contrast, can be based on the amount
    of space in the grid container not consumed by inflexible tracks; or, alternatively,
    can be based on the actual content of the entire grid track.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的网格轨道都是*不灵活*的——它们的大小由长度度量或网格容器的尺寸确定，但不受其他任何考虑的影响。*灵活*的网格轨道则可以基于网格容器中未被不灵活轨道占用的空间量；或者，也可以基于整个网格轨道的实际内容。
- en: Fractional units
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分数单位
- en: If you want to divide up whatever space is available by a certain fraction and
    distribute the fractions to various columns, the `fr` unit is here for you. An
    `fr` is a flexible amount of space, representing a fraction of the *leftover*
    space in a grid.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将可用空间按某个分数分配并将分数分配给各个列，`fr`单位就派上用场了。一个`fr`是一定量的灵活空间，代表网格中*剩余*空间的一部分。
- en: 'In the simplest case, you can divide up the whole container by equal fractions.
    For example, if you want four columns, you could write this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，你可以将整个容器均匀分成若干份。例如，如果你想要四列，可以这样写：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this very specific and limited case, that’s equivalent to saying the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常具体且有限的情况下，这相当于说以下内容：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Figure 12-12](#dividing_the_container) shows the result of either.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12-12](#dividing_the_container)展示了其中任何一个的结果。'
- en: '![image](assets/css5_1212.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/css5_1212.png)'
- en: Figure 12-12\. Dividing the container into four columns
  id: totrans-107
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-12。将容器分成四列
- en: This works because all of the grid container was “leftover space,” so all of
    it is available to be divided up by the `fr` lengths. We’ll get into how that
    plays out with nonflexible grid tracks in just a bit.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为网格容器的所有空间都是“剩余空间”，因此所有这些空间都可以通过`fr`长度来分割。我们稍后会详细介绍非灵活网格轨道的情况。
- en: 'Going back to the previous example, suppose we want to add a fifth column and
    redistribute the column sizes so they’re all still equal. If we used percentage
    values, we’d have to rewrite the entire value to be five instances of `20%`. With
    `fr`, though, we can just add another `1fr` to the value and have everything done
    for us automatically:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 回到前面的例子，假设我们想要添加第五列并重新分配列的大小，使它们仍然相等。如果我们使用百分比值，我们将不得不重写整个值为五个`20%`的实例。不过，使用`fr`，我们只需将值添加另一个`1fr`，所有工作都将自动完成：
- en: '[PRE9]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The way `fr` units work is that all of the `fr` values are added together, and
    all the leftover space in the grid is divided by that total. Then each track gets
    the number of those fractions indicated by its `fr` value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`fr`单位的工作方式是将所有`fr`值相加，并将网格中所有剩余空间除以该总数。然后，每个轨道根据其`fr`值得到相应数量的这些分数。'
- en: In our first example, we had four `1fr` values, so their `1`’s were added together
    to get a total of 4\. The available space was then divided by 4, and each column
    got one of those fourths. When we added a fifth `1fr`, the space was divided by
    5, and each column got one of those fifths.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们有四个`1fr`值，因此它们的`1`被加在一起得到总数4。然后将可用空间除以4，每列都得到其中的四分之一。当我们添加第五个`1fr`时，空间被分成5份，每列得到其中的五分之一。
- en: 'You are not required to always use `1` with your `fr` units! Suppose you want
    to divide up a space into three columns, with the middle column twice as wide
    as the other two. The code would look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必总是将`1`与您的`fr`单位一起使用！假设您想将空间分为三列，其中中间列的宽度是其他两列的两倍。代码将如下所示：
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, these values are added up to get 4, and then we divide that 4 by 1 (representing
    the whole), so the base `fr` in this case is `0.25`. The first and third tracks
    are thus 25% the width of the container, whereas the middle column is half the
    container’s width, because it’s `2fr`, which is twice `0.25`, or `0.5`, or 50%.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这些值相加得到 4，然后我们将这个 4 除以 1（代表整体），所以在这种情况下基础的 `fr` 是 `0.25`。因此，第一和第三条轨道的宽度为容器宽度的
    25%，而中间列是容器宽度的一半，因为它是 `2fr`，即 `0.25` 的两倍，即 `0.5`，或 50%。
- en: 'You aren’t limited to integers, either. A recipe card for apple pie could be
    laid out using these columns:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不仅限于整数。比如，苹果派的食谱卡片可以使用这些列布局：
- en: '[PRE11]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ll leave the math on that one as an exercise for you. (Lucky you! Just remember
    to start with `1 + 3.14159 + 1`, and you’ll have a good head start.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这一点的数学计算就留给你做练习了。（幸运的是！只需记住从`1 + 3.14159 + 1`开始，你就会有一个很好的起步。）
- en: 'This is a convenient way to slice up a container, but there’s more here than
    just replacing percentages with something more intuitive. Fractional units really
    come into their own when we have some fixed tracks and some flexible space. Consider,
    for example, the following, which is illustrated in [Figure 12-13](#giving_the_center_column):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种方便的方式来切割容器，但这里不仅仅是用百分比替换更直观的东西。分数单位在有些固定轨道和某些灵活空间时才能真正发挥作用。例如，考虑以下情况，如[图 12-13](#giving_the_center_column)所示：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![image](assets/css5_1213.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1213.png)'
- en: Figure 12-13\. Giving the center column whatever’s available
  id: totrans-122
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-13\. 给予中间列任何可用的内容
- en: Here, the browser assigns the first and third tracks to their inflexible widths,
    and then gives whatever is left in the grid container to the center track. For
    a 1,000-pixel-wide grid container whose `font-size` is the usual browser default
    of `16px`, the first column will be 240 pixels wide and the third will be 100
    pixels wide. That totals 340 pixels, leaving 660 pixels that aren’t assigned to
    the fixed tracks. The fractional units total 1, so 660 is divided by 1, yielding
    660 pixels, all of which are given to the single `1fr` track. If the grid container’s
    width is increased to 1,400 pixels, the third column will be 140 pixels wide and
    the center column 1,020 pixels wide.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，浏览器为第一和第三条轨道分配了它们的不可变宽度，然后将剩余的网格容器空间给了中间轨道。对于一个宽度为 1000 像素的网格容器，其`font-size`是通常的浏览器默认值`16px`，第一列将宽
    240 像素，第三列将宽 100 像素。总共 340 像素，剩下 660 像素没有分配到固定轨道。分数单位总共为 1，因此 660 除以 1，得到 660
    像素，全部分配给单个的 `1fr` 轨道。如果网格容器的宽度增加到 1400 像素，第三列将宽 140 像素，中间列将宽 1020 像素。
- en: 'Just like that, we have a mixture of fixed and flexible columns. We can keep
    this going, splitting up any flexible space into as many fractions as we like.
    Consider this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这样，我们有了一系列固定和灵活的列。我们可以继续这样做，将任何灵活的空间分割成任意数量的分数。考虑这个例子：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the columns will be sized as shown in [Figure 12-14](#flexible_column_sizing).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，列的大小如[图 12-14](#flexible_column_sizing)所示。
- en: '![image](assets/css5_1214.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1214.png)'
- en: Figure 12-14\. Flexible column sizing
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-14\. 灵活的列宽度
- en: 'The widths of the columns will be, from left to right: 15, 45, 30, and 10 ems.
    The first column gets its fixed width of `15em`. The last column is `10%` of 100
    em, which is 10 em. That leaves 75 ems to distribute among the flexible columns.
    The two added together total 7.5 fr. For the wider column, 4.5 ÷ 7.5 equals 0.6,
    and that times 75 ems equals 45 ems. Similarly, 3 ÷ 7.5 = 0.4, and that times
    75 ems equals 30 ems.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列的宽度从左到右依次为：15, 45, 30 和 10 em。第一列有固定宽度`15em`。最后一列是100 em的`10%`，即10 em。这留下75
    em用于灵活列的分配。两者加起来总共为7.5 fr。对于较宽的列，4.5 ÷ 7.5 等于 0.6，乘以 75 em 等于 45 em。同样地，3 ÷ 7.5
    = 0.4，乘以 75 em 等于 30 em。
- en: 'Yes, admittedly, we put a thumb on the scales for that example: the `fr` total
    and `width` value were engineered to yield nice, round numbers for the various
    columns. This was done purely to aid understanding. If you want to work through
    the process with less tidy numbers, consider using `92.5em` or `1234px` for the
    `width` value in the previous example.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，不可否认，我们在这个例子中进行了一些操作：`fr` 总数和 `width` 值被设计成能够为各个列产生漂亮的整数。这完全是为了帮助理解。如果你想用不那么整洁的数字来进行操作过程，请考虑在上一个例子中使用
    `92.5em` 或 `1234px` 作为 `width` 值。
- en: 'If you want to define a minimum or maximum size for a given track, `minmax()`
    can be quite useful. To extend the previous example, suppose the third column
    should never be less than 5 ems wide, no matter what. The CSS would then be as
    follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想为给定的轨道定义最小或最大大小，`minmax()`会非常有用。延续上一个示例，假设第三列无论如何都不应该少于`5em`宽。那么CSS会如下所示：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now the layout will have two flexible columns at its middle, down to the point
    that the third column reaches `5em` wide. Below that point, the layout will have
    three inflexible columns (`15em`, `5em`, and `10%` wide, respectively) and a single
    flexible column that will get all the leftover space, if there is any. Once you
    run the math, it turns out that up to `30.5556em` wide, the grid will have one
    flexible column. Above that width, there will be two flexible columns.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在布局将在中间有两列灵活列，直到第三列达到`5em`宽。在该点以下，布局将有三个不灵活的列（分别为`15em`，`5em`和`10%`宽），和一个灵活列，它会获得所有剩余的空间（如果有的话）。一旦运行了这个数学计算，发现在宽度达到`30.5556em`之前，网格将有一个灵活列。超过这个宽度，将会有两个灵活列。
- en: You might think this works the other way—for example, if you wanted to make
    a column track flexible up to a certain point, and then become fixed after, you
    would declare a minimum `fr` value. This won’t work, sadly, because `fr` units
    are not allowed in the *min* position of a `minmax()` expression. So any `fr`
    value provided as a minimum will invalidate the entire declaration.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这种方法会反过来—例如，如果你想使列轨道在某一点之前灵活，然后在之后变成固定列，你会声明一个最小的`fr`值。但很遗憾，这不会起作用，因为`minmax()`表达式的最小位置不允许`fr`单位。因此，任何作为最小值提供的`fr`值都会使整个声明无效。
- en: 'Speaking of setting to 0, let’s look at a minimum value explicitly set to `0`,
    like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 说到设置为0，让我们看一下显式设置为`0`的最小值，就像这样：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 12-15](#minmaxed_column_sizing) illustrates the narrowest grid width
    at which the third column can remain 500 pixels wide. Any narrower, and the `minmax`-ed
    column will be narrower than 500 pixels. Any wider, and the second column, the
    `fr` column, will grow beyond zero width while the third column stays at 500 pixels
    wide.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-15](#minmaxed_column_sizing)展示了第三列可以保持500像素宽度的最窄网格宽度。再窄一点，`minmax` 的列将小于500像素。再宽一点，第二列，即`fr`列，会增长到超过零宽度，而第三列保持在500像素宽度。'
- en: '![image](assets/css5_1215.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图像](assets/css5_1215.png)'
- en: Figure 12-15\. Minmaxed column sizing
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-15\. `minmax`列大小调整
- en: If you look closely, you’ll see the `1fr` label next to the boundary between
    the `15em` and `minmax(0,500px)` columns. That’s there because the `1fr` is placed
    with its left edge on the second-column grid line, and has no width, because there
    is no space left to flex. Similarly, the `minmax` is placed on the third-column
    grid line. It’s just that, in this specific situation, the second- and third-column
    grid lines are in the same place (which is why the `1fr` column has zero width).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会看到`1fr`标签位于`15em`和`minmax(0,500px)`列之间的边界上。这是因为`1fr`被放置在其左边缘处于第二列网格线上，并且由于没有剩余空间可以弹性伸缩，它没有宽度。同样地，`minmax`被放置在第三列网格线上。只是在这种特定情况下，第二列和第三列的网格线在同一位置（这就是为什么`1fr`列宽度为零的原因）。
- en: If you ever run into a case where the minimum value is greater than the maximum
    value, the whole thing is replaced with the minimum value. Thus, `minmax(``500px,200px)`
    would be treated as a simple `500px`. You probably wouldn’t do this so obviously,
    but this feature is useful when mixing things like percentages and fractions.
    Thus, you could have a column that’s `minmax(10%,1fr)` that would be flexible
    down to the point where the flexible column was less than 10% of the grid container’s
    size, at which point it would stick at `10%`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遇到最小值大于最大值的情况，整个事情会被替换为最小值。因此，`minmax(``500px,200px)`会被视为简单的`500px`。你可能不会这么明显地这样做，但在混合百分比和分数时，这个特性是很有用的。因此，你可以有一个列是`minmax(10%,1fr)`，它可以灵活地调整到弹性列小于网格容器大小的10%时，它会停留在`10%`。
- en: 'Fractional units and minmaxes are usable on rows just as easily as columns;
    it’s just that rows are rarely sized in this way. You could easily imagine setting
    up a layout in which the masthead and footer are fixed tracks, while the content
    is flexible down to a certain point. That might look something like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 分数单位和`minmax`同样可以在行上使用，就像在列上一样容易。只是行很少以这种方式进行大小设置。你可以轻松地想象设置一个布局，其中页眉和页脚是固定轨道，而内容可以在一定点下灵活调整。可能看起来像这样：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That works OK, but it’s a lot more likely that you’ll want to size that row
    by the height of its content, not some fraction of the grid container’s height.
    The next section shows exactly how to make that happen.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以工作，但更有可能的情况是，你会想要按内容的高度来调整行的大小，而不是网格容器高度的一部分。下一节将详细展示如何实现这一点。
- en: Content-aware tracks
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容感知的轨道
- en: It’s one thing to set up grid tracks that take up fractions of the space available
    to them, or that occupy fixed amounts of space. But what if you want to line up
    a bunch of pieces of a page and can’t guarantee how wide or tall they might get?
    This is where `min-content` and `max-content` come in. (See [Chapter 6](ch06.html#basic-visual-formatting)
    for a detailed explanation of these keywords.)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 设置网格轨道占用可用空间的一部分，或者占用固定的空间是一回事。但是如果你想要对齐页面上的一堆部件，而无法保证它们的宽度或高度，这就是`min-content`和`max-content`发挥作用的地方。（详见[第 6
    章](ch06.html#basic-visual-formatting)关于这些关键词的详细解释。）
- en: 'What’s so powerful about using these sizing keywords in CSS Grid is that they
    apply to the entire grid track they define. For example, if you size a column
    to be `max-content`, the entire column track will be as wide as the widest content
    within it. This is easiest to illustrate with a grid of images (12, in this case)
    with the grid declared as follows and shown in [Figure 12-16](#sizing_grid_tracks_by_content):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CSS Grid 中使用这些尺寸关键词的强大之处在于，它们适用于它们定义的整个网格轨道。例如，如果你将一列设置为`max-content`，整个列轨道将与其内最宽的内容一样宽。这最容易通过一个图像网格（此处为
    12 张）来说明，网格声明如下，并在[图 12-16](#sizing_grid_tracks_by_content)中展示：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![css5 1216](assets/css5_1216.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1216](assets/css5_1216.png)'
- en: Figure 12-16\. Sizing grid tracks by content
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-16\. 按内容调整网格轨道大小
- en: Looking at the columns, we can see that each column track is as wide as the
    widest image within that track. Where a bunch of portrait images happen to line
    up, the column is more narrow; where a landscape image shows up, the column is
    made wide enough to fit it. The same thing happens with the rows. Each row is
    as tall as the tallest image within it, so if a row happens to have all short
    images, the row is also short.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 查看列，我们可以看到每个列轨道的宽度都与该轨道内最宽的图像一样。如果有一堆竖直图片排列在一起，列就会更窄；如果出现横向图片，列就会被扩展足够容纳。同样的情况也发生在行上。每行的高度与其内最高的图像一样高，所以如果一行内全是短图片，那行的高度也会较短。
- en: The advantage here is that this works for any sort of content, no matter what’s
    in there. Say we add captions to the photos. All of the columns and rows will
    resize themselves as needed to handle both text and images, as shown in [Figure 12-17](#sizing_grid_tracks_around_mixed_content).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的优势在于，无论内容是什么，这种方法都适用。比如我们给照片加上标题。所有的列和行都会根据需要调整大小，以处理文本和图片，如[图 12-17](#sizing_grid_tracks_around_mixed_content)所示。
- en: This isn’t a full-fledged design—the images are out of place, and there’s no
    attempt to constrain the caption widths. In fact, that’s exactly what we should
    expect from `max-content` values for the column widths. Since it means “make this
    column wide enough to hold all its content,” that’s what we get.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个成熟的设计——图片摆放错乱，而且没有尝试约束标题的宽度。事实上，这正是我们对于列宽使用`max-content`值所期望的。因为它意味着“使这一列足够宽以容纳其所有内容”，这就是我们得到的结果。
- en: '![image](assets/css5_1217.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1217.png)'
- en: Figure 12-17\. Sizing grid tracks around mixed content
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-17\. 围绕混合内容调整网格轨道大小
- en: 'What’s important to realize is that this will hold even if the grid tracks
    have to spill out of the grid container. Even if we’d assigned something like
    `width: 250px` to the grid container, the images and captions would be laid out
    just the same. That’s why things like `max-content` tend to appear in `minmax()`
    statements. Consider the following, where grids with and without `minmax()` appear
    side by side. In both cases, the grid container is represented by a shaded background
    (see [Figure 12-18](#sizing_grid_tracks_minmax)):'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '重要的是要意识到，即使网格轨道溢出网格容器，这种效果仍然存在。即使我们为网格容器分配了`width: 250px`这样的值，图片和标题的布局也会保持不变。这就是为什么像`max-content`这样的东西经常出现在`minmax()`语句中的原因。考虑以下示例，在这些示例中，使用和不使用`minmax()`的网格并排显示。在两种情况下，网格容器都有一个阴影背景（见[图 12-18](#sizing_grid_tracks_minmax)）。'
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![image](assets/css5_1218.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1218.png)'
- en: Figure 12-18\. Sizing grid tracks with and without `minmax()`
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-18\. 使用和不使用`minmax()`调整网格轨道大小
- en: In the first instance, the grid items completely contain their contents, but
    they spill out of the grid container. In the second, `minmax()` directs the browser
    to keep the columns within the range of `0` and `max-content`, so they’ll all
    be fitted into the grid container if possible. A variant would be to declare `minmax(min-content,
    max-content)`, which can lead to a slightly different result than the `0, max-content`
    approach.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The reason that some images are overflowing their cells in the second example
    is that the tracks have been fitted into the grid container according to `minmax(0,max-content)`.
    They can’t reach `max-content` in every track, but they can get as close as possible
    while all still fitting into the grid container. Where the contents are wider
    than the track, they just stick out of it, overlapping other tracks. This is standard
    grid behavior.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering what happens if you `min-content` both the columns and the
    rows, it’s pretty much the same as applying `min-content` to the columns and leaving
    the rows alone. This happens because the grid specification directs browsers to
    resolve column sizing first, and row sizing after that.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: One more keyword you can use with grid track sizing is `auto`, which also happens
    to be the default value for any grid track’s width. As a minimum, it’s treated
    as the minimum size for the grid item, as defined by `min-width` or `min-height`.
    As a maximum, it’s treated the same as `max-content`. You might think this means
    it can be used only in `minmax()` statements, but this is not the case. You can
    use it anywhere, and it will take on either a minimum or maximum role. Which one
    it takes on depends on the other track values around it, in ways that are frankly
    too complicated to get into here. As with so many other aspects of CSS, using
    `auto` is essentially letting the browser do what it wants. Sometimes that’s fine,
    but in general you’ll probably want to avoid it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is a caveat to that last statement: `auto` values allow grid items to
    be resized by the `align-content` and `justify-content` properties, a topic we’ll
    discuss in [“Setting Alignment in Grids”](#aligning-and-grids). Since `auto` values
    are the only track-sizing values that permit this, there may be very good reasons
    to use `auto` after all.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Fitting Track Contents
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the `min-content` and `max-content` keywords, a `fit-content()`
    function allows you to more compactly express certain types of sizing patterns.
    It’s a bit complicated to decipher, but the effort is worth it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fit-content()` function accepts a <*`length`*> or a <*`percentage`*> as
    its argument, like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before we explore what that means, let’s ponder the pseudo-formula given by
    the specification:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: fit-content(*argument*) => min(max-content, max(min-content, *argument*))
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means, essentially, “figure out which is greater, the `min-content` sizing
    or the supplied argument, and then take that result and choose whichever is smaller,
    that result or the `max-content` size.” Which is probably confusing!.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上意味着，“找出哪个更大，`min-content`大小还是提供的参数，然后取这个结果，再从这个结果和`max-content`大小中选择较小的一个。”这可能会令人困惑！
- en: 'We feel that a better way of phrasing it is “`fit-content(*argument*)` is equivalent
    to `minmax(min-content,max-content)`, except that the value given as an argument
    sets an upper limit, similar to `max-width` or `max-height`.” Let’s consider this
    example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们觉得更好的表达方式是“`fit-content(*argument*)`等同于`minmax(min-content,max-content)`，只是给定的参数设置了一个上限，类似于`max-width`或`max-height`。”让我们考虑这个例子：
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The argument here is `50ch`, or the same width as 50 zero (`0`) characters side
    by side. So we’re setting up a single column that’s having its content fit to
    that measure.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的参数是`50ch`，或者说与50个零(`0`)字符并排的宽度相同。因此我们设置了一个单列，其内容适应这个尺寸。
- en: For the initial case, assume the content is only 29 characters long, measuring
    29 ch (because it’s in a monospace font). That means the value of `max-content`
    is `29ch`, and the column will be only that wide, because it minimizes to that
    measure—`29ch` is smaller than whatever the maximum of `50ch` and `min-content`
    turns out to be.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初始情况，假设内容仅为29个字符长，测量为29 ch（因为它是等宽字体）。这意味着`max-content`的值为`29ch`，列宽度将仅为此大小，因为它最小化到该尺寸——`29ch`比`50ch`和`min-content`的最大值要小。
- en: Now, let’s assume a bunch of text content is added so that there are 256 characters,
    thus measuring `256ch` in width (without any line wrapping). That means `max-content`
    evaluates to `256ch`. This is well beyond the `50ch` argument, so the column is
    constrained to be the larger of `min-content` and `50ch`, which is `50ch`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设添加了一堆文本内容，使得有256个字符，因此宽度为`256ch`（没有换行）。这意味着`max-content`的值为`256ch`。这远远超出了`50ch`的参数，因此列被限制为`min-content`和`50ch`中较大的值，即`50ch`。
- en: 'As further illustration, consider the results of the following, as shown in
    [Figure 12-19](#sizing_grid_tracks_fit_content):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步说明，请考虑以下结果，如[Figure 12-19](#sizing_grid_tracks_fit_content)所示：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![image](assets/css5_1219.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1219.png)'
- en: Figure 12-19\. Sizing grid tracks with `fit-content()`
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 12-19\. 使用 `fit-content()` 调整网格跟踪大小
- en: Notice the first column is narrower than the other two. Its `29ch` content minimizes
    to that size. The other two columns have more content than will fit into `50ch`,
    so they line-wrap, because their width has been limited to `50ch`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第一列比其他两列更窄。它的`29ch`内容被最小化到该大小。其他两列的内容超过了`50ch`，因此它们被限制在`50ch`内换行。
- en: Now let’s consider what happens if an image is added to the second column. We’ll
    make it `500px` wide, which happens to be wider than `50ch` in this instance.
    For that column, the maximum of `min-content` and `50ch` is determined. As we
    said, the larger value there is `min-content`, which is to say `500px` (the width
    of the image). Then the *minimum* of `500px` and `max-content` is determined.
    The text, rendered as a single line, would go on past `500px`, so the minimum
    is `500px`. Thus, the second column is now 500 pixels wide. This is depicted in
    [Figure 12-20](#sizing_grid_tracks_fit_content_wide).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一下，如果将图像添加到第二列会发生什么情况。我们将其设置为`500px`宽，这恰好比本例中的`50ch`更宽。对于该列，将确定`min-content`和`50ch`的最大值。正如我们所说，较大的值是`min-content`，也就是`500px`（图像的宽度）。然后确定`500px`和`max-content`的*最小值*。文本作为单行呈现，会超过`500px`，因此最小值为`500px`。因此，第二列现在宽度为500像素。这在[Figure 12-20](#sizing_grid_tracks_fit_content_wide)中有所描述。
- en: '![image](assets/css5_1220.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1220.png)'
- en: Figure 12-20\. Fitting to wide content
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 12-20\. 适配宽内容
- en: If you compare Figures [12-19](#sizing_grid_tracks_fit_content) to [12-20](#sizing_grid_tracks_fit_content_wide),
    you’ll see that the text in the second column wraps at a different point, due
    to the change in column width. But also compare the text in the third column.
    It, too, has different line wraps.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较Figure [12-19](#sizing_grid_tracks_fit_content) 和 [12-20](#sizing_grid_tracks_fit_content_wide)，你会看到第二列文本在不同宽度下换行的不同点。同时比较第三列文本，它的换行点也不同。
- en: That happens because after the first and second columns are sized, the third
    column has a bit less than `50ch` of space in which to be sized. The `fit-content(50ch)`
    function still does its thing, but here, it does so within the space available
    to it. Remember, the `50ch` argument is an upper bound, not a fixed size.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一列和第二列的大小已确定，第三列的空间略小于`50ch`。`fit-content(50ch)`函数仍然起作用，但在此处，它是在可用空间内进行的。请记住，`50ch`参数是一个上限，而不是固定尺寸。
- en: This is one of the great advantages of `fit-content()` over the less flexible
    `minmax()`. It allows you to shrink tracks to their minimum `content-size` when
    there isn’t much content, while still setting an upper bound on the track size
    when there’s a lot of content.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`fit-content()`相对于不太灵活的`minmax()`的一大优势之一。当内容不多时，它允许您将轨道缩小到其最小的`content-size`，而在有大量内容时仍设置轨道尺寸的上限。
- en: You may have been wondering about the repetitive grid template values in previous
    examples, and what happens if you need more than three or four grid tracks. Will
    you have to write out every single track width individually? Indeed not, as you’ll
    see in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您曾经在之前的示例中对重复的网格模板值感到好奇，以及如果您需要超过三四个网格轨道会发生什么。您是否需要逐个编写每个轨道宽度？实际上不需要，接下来您将看到。
- en: Repeating Grid Tracks
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复网格轨道
- en: If you want to set up a bunch of grid tracks of the same size, you probably
    don’t want to have to type out every single one of them. Fortunately, `repeat()`
    is here to make sure you don’t have to.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想设置一堆相同尺寸的网格轨道，您可能不想逐个输入它们。幸运的是，`repeat()`可以确保您无需这样做。
- en: 'Let’s say we want to set up a column grid line every 5 ems and have 10 column
    tracks. Here’s how to do that:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要设置每5 ems一个列网格线，有10列轨道。这里是如何做到的：
- en: '[PRE22]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That’s it. Done. Ten column tracks, each one `5em` wide, for a total of 50 ems
    of column tracks. It sure beats typing `5em` 10 times!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。完成。十个列轨道，每个轨道宽度为`5em`，总共50 ems的列轨道。这肯定比逐次键入`5em` 10次要方便！
- en: 'Any track-sizing value can be used in a repeat, from `min-content` and `max-content`
    to `fr` values to `auto`, and so on, and you can put together more than one sizing
    value. Suppose we want to define a column structure such that there’s a `2em`
    track, then a `1fr` track, and then another `1fr` track—and, furthermore, we want
    to repeat that pattern three times. Here’s how to do that, with the result shown
    in [Figure 12-21](#repeating_a_track_pattern):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 任何轨道大小的值都可以在重复中使用，从`min-content`和`max-content`到`fr`值再到`auto`等等，您可以组合多个尺寸值。假设我们想要定义一个列结构，有一个`2em`的轨道，然后是一个`1fr`的轨道，然后是另一个`1fr`的轨道，而且我们希望重复这种模式三次。这里是如何做到的，结果显示在[图 12-21](#repeating_a_track_pattern)中：
- en: '[PRE23]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![image](assets/css5_1221.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_1221.png)'
- en: Figure 12-21\. Repeating a track pattern
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-21\. 重复轨道模式
- en: 'Notice that the last-column track is a `1fr` track, whereas the first-column
    track is `2em` wide. This is an effect of the way the `repeat()` was written.
    It’s easy to add another `2em` track at the end, in order to balance things out,
    by adding a `2em` after the `repeat()` expression:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后一列轨道是一个`1fr`轨道，而第一列轨道是`2em`宽。这是`repeat()`写法的效果。如果要在`repeat()`表达式后添加一个`2em`轨道以平衡情况，这样做很容易：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This highlights the fact that `repeat` can be combined with any other track-sizing
    values—even other repeats—in the construction of a grid. The one thing you *can’t*
    do is nest a repeat inside another repeat.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这突显了`repeat`可以与任何其他轨道大小值（甚至其他重复）结合在一起构建网格的事实。您唯一*不能*做的是在另一个`repeat`内部嵌套一个`repeat`。
- en: 'Other than that, just about anything goes within a `repeat()` value. Here’s
    an example taken straight from the grid specification:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，在`repeat()`值中几乎可以放置任何东西。这里有一个直接来自网格规范的例子：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, there are four repetitions of a 10-pixel track, a named grid line,
    a 250-pixel track, and then another named grid line. Then, after the four repetitions,
    a final 10-pixel column track. Yes, that means there will be four column grid
    lines named `col-start`, and another four named `col-end`, as shown in [Figure 12-22](#repeated_columns_w_named_grid_lines).
    This is acceptable; grid-line names are not required to be unique.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有四个重复的10像素轨道，一个命名的网格线，一个250像素轨道，然后另一个命名的网格线。然后，在四次重复之后，还有一个最后的10像素列轨道。是的，这意味着将有四个名为`col-start`的列网格线和另外四个名为`col-end`的网格线，如图 12-22所示。这是可以接受的；网格线名称不需要唯一。
- en: '![image](assets/css5_1222.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_1222.png)'
- en: Figure 12-22\. Repeated columns with named grid lines
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-22\. 带有命名网格线的重复列
- en: 'One thing to remember, if you’re going to repeat named lines, is that if you
    place two named lines next to each other, they’ll be merged into a single, double-named
    grid line. In other words, the following two declarations are equivalent:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事需要记住，如果你要重复命名线条，那么如果将两个命名线条放在一起，它们将合并成一个双重命名的网格线。换句话说，以下两个声明是等效的：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you’re concerned about having the same name applied to multiple grid lines,
    don’t be: there’s nothing preventing it, and it can even be helpful in some cases.
    We’ll explore ways to handle such situations in [“Using Column and Row Lines”](#using-column-and-row-lines).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你担心将同一个名称应用于多个网格线，不用担心：没有任何阻止，甚至在某些情况下还可能有所帮助。我们将在 [“使用列和行线”](#using-column-and-row-lines)
    中探讨处理此类情况的方法。
- en: Autofilling tracks
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动填充轨道
- en: CSS provides a way to set up a simple pattern and repeat it until the grid container
    is filled. This doesn’t have quite the same complexity as regular `repeat()`—at
    least not yet—but it can still be pretty handy.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 提供了一种设置简单模式并重复直到填满网格容器的方法。这不像常规的 `repeat()` 那样复杂——至少目前不是——但仍然非常实用。
- en: 'For example, suppose we want to have the previous row pattern repeat as many
    times as the grid container will comfortably accept:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要先前的行模式在网格容器舒适地接受的情况下重复多次：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That will define a row line every 5 ems until there’s no more room. Thus, for
    a grid container that’s 11 ems tall, the following is equivalent:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义每5 ems一个行线，直到没有更多空间为止。因此，对于一个高度为11 ems的网格容器，以下是等效的：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the grid container’s height is increased past 15 ems, but is less than 20
    ems, then this is an equivalent declaration:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网格容器的高度增加到超过15 ems，但小于20 ems，则以下是等效声明：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See [Figure 12-23](#auto-fill-rows-three-heights) for examples of the autofilled
    rows at three grid container heights.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 见 [图 12-23](#auto-fill-rows-three-heights) 关于三个网格容器高度下自动填充行的示例。
- en: '![image](assets/css5_1223.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1223.png)'
- en: Figure 12-23\. Autofilling rows at three heights
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-23\. 三种高度下的自动填充行
- en: One limitation with auto-repeating is that it can take only an optional grid-line
    name, a fixed track size, and another optional grid-line name. So `[top] 5em [bottom]`
    represents about the maximum value pattern. You can drop the named lines and just
    repeat `5em`, or just drop one of the names.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重复的一个限制是它只能采用可选的网格线名称、固定轨道大小和另一个可选的网格线名称。因此，`[top] 5em [bottom]` 表示大致的最大值模式。你可以省略命名线并只重复
    `5em`，或者只省略一个名称。
- en: It’s not possible to auto-repeat multiple fixed track sizes, nor can you auto-repeat
    flexible track sizes. Similarly, you can’t use intrinsic track sizes with auto-repeated
    tracks, so values such as `min-content` and `max-content` can’t be put into an
    auto-repeated pattern.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 不可能自动重复多个固定轨道大小，也不能自动重复灵活的轨道大小。同样地，你不能在自动重复的模式中使用内在的轨道大小，因此像 `min-content` 和
    `max-content` 这样的值不能放入自动重复的模式中。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You might wish you could auto-repeat multiple track sizes in order to define
    gutters around your content columns. This is usually unnecessary because of the
    properties `row-gap` and `column-gap` and their shorthand `gap`, which are covered
    in [Chapter 11](ch11.html#flexbox) but also apply in CSS Grid.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望能够自动重复多个轨道大小，以定义内容列周围的间距。通常这是不必要的，因为属性 `row-gap` 和 `column-gap` 及其简写 `gap`
    已在 [第11章](ch11.html#flexbox) 中介绍，但它们同样适用于 CSS Grid。
- en: 'Furthermore, you can have only one auto-repeat in a given track template. Thus,
    the following would *not* be permissible:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在给定的轨道模板中只能有一个自动重复。因此，以下情况将*不*被允许：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'However, you *can* combine fixed-repeat tracks with autofill tracks. For example,
    you could start with three wide columns, and then fill the rest of the grid container
    with narrow tracks (assuming there’s space for them). That would look something
    like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你*可以*将固定重复的轨道与自动填充的轨道结合起来。例如，你可以从三个宽列开始，然后用窄轨道填充网格容器的其余部分（假设有空间）。这将看起来像这样：
- en: '[PRE31]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can flip that around too:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以反过来：
- en: '[PRE32]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: That works because the grid layout algorithm assigns space to the fixed tracks
    first, and then fills up whatever space is left with auto-repeated tracks. The
    end result is to have one or more autofilled 2-em tracks, and then three 20-em
    tracks. [Figure 12-24](#auto-fill-columns-with-fixed) shows two examples.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为网格布局算法首先为固定轨道分配空间，然后用自动重复轨道填充剩余空间。最终的结果是有一个或多个自动填充的2 em轨道，然后是三个20 em轨道。[图 12-24](#auto-fill-columns-with-fixed)
    展示了两个示例。
- en: '![image](assets/css5_1224.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1224.png)'
- en: Figure 12-24\. Autofilling columns next to fixed columns
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-24。自动填充列与固定列旁边
- en: With `auto-fill`, you will always get at least one repetition of the track template,
    even if it won’t fit into the grid container for some reason. You’ll also get
    as many tracks as will fit, even if some of the tracks don’t have content. As
    an example, suppose you set up an autofill that places five columns, but only
    the first three actually end up with grid items in them. The other two would remain
    in place, holding open layout space.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`auto-fill`时，即使由于某些原因无法适应网格容器，你仍然会得到至少一个重复的跟踪模板。即使有些跟踪没有内容，你也会得到尽可能多的跟踪。例如，假设你设置了一个自动填充，放置了五列，但实际上只有前三列有网格项。其余两列将保持原位，保持布局空间的开放状态。
- en: 'If you use `auto-fit`, on the other hand, tracks that don’t contain any grid
    items will be compressed to a width of zero, though they (and their associated
    grid lines) remain part of the grid. Otherwise, `auto-fit` acts the same as `auto-fill`.
    Suppose the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果使用`auto-fit`，那些不包含任何网格项的跟踪将被压缩到零宽度，尽管它们（及其相关的网格线）仍然是网格的一部分。否则，`auto-fit`的行为与`auto-fill`相同。假设以下情况：
- en: '[PRE33]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If the grid container has room for five column tracks (i.e., it’s more than
    100 ems wide), but two tracks don’t have any grid items to go into them, those
    empty grid tracks will be dropped, leaving the three column tracks that *do* contain
    grid items. The leftover space is handled in accordance with the values of `align-content`
    and `justify-content` (discussed in [“Setting Alignment in Grids”](#aligning-and-grids)).
    A simple comparison of `auto-fill` and `auto-fit` is shown in [Figure 12-25](#auto-fill-and-auto-fit),
    where the numbers in the colored boxes indicate the grid-column number to which
    they’ve been attached.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网格容器有足够的空间容纳五个列跟踪（即宽度超过100 ems），但有两个跟踪没有任何网格项可放入，那些空的网格跟踪将被丢弃，留下三个包含网格项的列跟踪。剩余的空间根据`align-content`和`justify-content`的值处理（参见“设置网格对齐”中讨论）。图12-25中展示了`auto-fill`和`auto-fit`的简单比较，其中彩色框中的数字表示它们所附加到的网格列编号。
- en: '![image](assets/css5_1225.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1225.png)'
- en: Figure 12-25\. Using `auto-fill` versus `auto-fit`
  id: totrans-240
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-25。使用`auto-fill`与`auto-fit`
- en: Defining Grid Areas
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义网格区域
- en: Maybe you’d rather just “draw a picture” of your grid—both because it’s fun
    to do and because the picture can serve as self-documenting code. It turns out
    you can more or less do exactly that with the `grid-template-areas` property.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你更愿意“画出你的网格图”，因为这样做既有趣又可以作为自解释的代码。事实证明，你可以使用`grid-template-areas`属性几乎完全做到这一点。
- en: 'We could go through a wordy description of how this works, but it’s a lot more
    fun to just show it. The following rule has the result shown in [Figure 12-26](#simple_set_of_grid_areas):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以详细描述它的工作原理，但展示它会更有趣。以下规则的结果显示在[图12-26](#simple_set_of_grid_areas)中：
- en: '[PRE34]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '![image](assets/css5_1226.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1226.png)'
- en: Figure 12-26\. A simple set of grid areas
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-26。一个简单的网格区域设置
- en: 'That’s right: the letters in the string values are used to define how areas
    of the grid are shaped. Really! And you aren’t even restricted to single letters!
    For example, we could expand the previous example like so:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 没错：字符串值中的字母用于定义网格区域的形状。是真的！而且你甚至不限于单个字母！例如，我们可以像这样扩展前面的例子：
- en: '[PRE35]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The grid layout is the same as that shown in [Figure 12-26](#simple_set_of_grid_areas),
    though the name of each area would be different (e.g., `footer` instead of `f`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 网格布局与[图12-26](#simple_set_of_grid_areas)中显示的相同，尽管每个区域的名称可能会不同（例如，`footer`而不是`f`）。
- en: 'In defining template areas, the whitespace is collapsed, so you can use it
    (as was done in the previous example) to visually line up columns of names in
    the value of `grid-template-areas`. You can line up the names with spaces or tabs,
    whichever will annoy your coworkers the most. Or you can just use a single space
    to separate each identifier, and not worry about the names lining up with one
    another. You don’t even have to line-break between strings; the following works
    just as well as a pretty-printed version:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义模板区域时，空白会被折叠，因此你可以使用它（如前面的例子所示），在`grid-template-areas`的值中将列名对齐视觉上的线条。你可以使用空格或制表符来对齐名称，无论哪种方式都会使你的同事感到不适。或者你可以只用一个空格来分隔每个标识符，不必担心名称之间的对齐问题。甚至在字符串之间不换行也可以，以下版本与美观打印版本一样有效：
- en: '[PRE36]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'What you can’t do is merge those separate strings into a single string and
    have it mean the same thing. Every new string (as delimited by the quote marks)
    defines a new row in the grid. Thus the previous example, like the examples before
    it, defines three rows. Say we merge them all into a single string, like so:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将这些独立的字符串合并成一个字符串并具有相同的含义。每个新字符串（由引号分隔）定义网格中的新行。因此，前面的例子和之前的例子一样，定义了三行。假设我们将它们全部合并成一个字符串，如下所示：
- en: '[PRE37]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Then we’d have a single row of 12 columns, starting with the four-column area
    `h` and ending with the three-column area `f`. The line breaks aren’t significant
    in any way, except as whitespace that separates one identifier from another.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们会有一行包含12列，从四列区域`h`开始，到三列区域`f`结束。换行只是作为空格分隔一个标识符与另一个的方式，并没有其他意义。
- en: 'If you look at these values closely, you may come to realize that each individual
    identifier represents a grid cell. Let’s bring back our first example from this
    section, and consider the result shown in [Figure 12-27](#grid_cells_with_ids),
    which uses Firefox’s Grid Inspector to label each cell:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细查看这些值，您可能会意识到每个单独的标识符代表一个网格单元。让我们回顾一下本节中的第一个例子，并考虑[图 12-27](#grid_cells_with_ids)中显示的结果，它使用Firefox的Grid
    Inspector标记每个单元格：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![image](assets/css5_1227.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_1227.png)'
- en: Figure 12-27\. Grid cells with their grid area identifiers
  id: totrans-258
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-27\. 带有其网格区域标识符的网格单元格
- en: 'This is exactly the same layout result as in [Figure 12-26](#simple_set_of_grid_areas),
    but here, we’ve shown how each grid identifier in the `grid-template-areas` value
    corresponds to a grid cell. Once all the cells are identified, the browser merges
    any adjacent cells with the same name into a single area that encloses all of
    them—as long as they describe a rectangular shape! If you try to set up more complicated
    areas, the entire template is invalid. Thus, the following would result in no
    grid areas being defined:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[图 12-26](#simple_set_of_grid_areas)中的布局结果完全相同，但这里我们展示了`grid-template-areas`值中每个网格标识符如何对应一个网格单元。一旦所有单元格被标识，浏览器将合并任何具有相同名称的相邻单元格为一个包含它们所有的区域，只要它们描述的是矩形形状！如果尝试设置更复杂的区域，则整个模板将无效。因此，以下情况将导致未定义任何网格区域：
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See how `l` outlines an *L* shape? That humble change causes the entire `grid-template-areas`
    value to be dropped as invalid. A future version of grid layout may allow for
    nonrectangular shapes, but for now, this limitation exists.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`l`是如何勾勒出一个*L*形状？这个微小的改变导致整个`grid-template-areas`值作废。Grid 布局的未来版本可能允许非矩形形状，但目前存在此限制。
- en: 'If you want to define only some grid cells to be part of grid areas but leave
    others unlabeled, you can use one or more `.` characters to fill in for those
    unnamed cells. Let’s say you just want to define some header, footer, and sidebar
    areas, and leave the rest unnamed. That would look something like this, with the
    result shown in [Figure 12-28](#grid_with_unnamed_cells):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想定义一些网格单元格作为网格区域的一部分，而将其他单元格保留未标记，则可以使用一个或多个`.`字符来填充这些未命名的单元格。假设您只想定义一些标题、页脚和侧边栏区域，并留下其他未命名的区域。那看起来会像这样，结果显示在[图 12-28](#grid_with_unnamed_cells)中：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![image](assets/css5_1228.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_1228.png)'
- en: Figure 12-28\. A grid with some unnamed grid cells
  id: totrans-265
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-28\. 带有一些未命名网格单元格的网格
- en: The two cells in the center of the grid are not part of a named area, having
    been represented in the template by *null cell tokens* (the `.` identifiers).
    Where each of those `...` sequences appears, we could have used one or more null
    tokens—so `left . . right` or `left` `...` `...` `right` would work just as well.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中心的两个单元格不属于命名区域，它们在模板中用*空单元格标记*（`.`标识符）表示。每当出现`...`序列时，我们都可以使用一个或多个空标记——所以`left
    . . right`或`left` `...` `...` `right`同样适用。
- en: 'You can be as simple or creative with your cell names as you like. If you want
    to call your header `ronaldo` and your footer `podiatrist`, go for it. You can
    even use any Unicode character above codepoint U+0080, so `ConHugeCo©®™` and `åwësømë`
    are completely valid area identifiers…as are emoji! ![](assets/joy_1f602.png)
    Now, to size the grid tracks created by these areas, we bring in our old friends
    `grid-template-columns` and `grid-template-rows`. Let’s add both to the previous
    example, with the result shown in [Figure 12-29](#named_areas_and_sized_tracks):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![image](assets/css5_1229.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: Figure 12-29\. Named areas and sized tracks
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Thus, the columns and rows created by naming the grid areas are given track
    sizes. If we give more track sizes than there are area tracks, that will add more
    tracks past the named areas. Therefore, the following CSS will lead to the result
    shown in [Figure 12-30](#adding_more_tracks):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![image](assets/css5_1230.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: Figure 12-30\. Adding more tracks beyond the named areas
  id: totrans-274
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So, given that we’re naming areas, how about mixing in some named grid lines?
    As it happens, we already have: naming a grid area automatically adds names to
    the grid lines at its start and end. For the `header` area, there’s an implicit
    `header-start` name on its first-column grid line *and* its first-row grid line,
    and `header-end` for its second-column and -row grid lines. For the `footer` area,
    the `footer-start` and `footer-end` names were automatically assigned to its grid
    lines.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Grid lines extend throughout the whole grid area, so a lot of these names are
    coincident. [Figure 12-31](#implicit_grid_line_names_explicit) shows the naming
    of the lines created by the following template:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '![image](assets/css5_1231.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
- en: Figure 12-31\. Implicit grid-line names made explicit
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now let’s mix it up even more by adding a couple of explicit grid-line names
    to our CSS. Given the following rules, the first-column grid line in the grid
    would add the name `begin`, and the second-row grid line in the grid would add
    the name `content`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Again: those grid-line names are *added* to the implicit grid-line names created
    by the named areas. Grid-line names never replace other grid-line names. Instead,
    they just keep piling up.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more interesting, this implicit-name mechanism runs in reverse. Suppose
    you don’t use `grid-template-areas` at all, but instead set up some named grid
    lines like so, as illustrated in [Figure 12-32](#implicit_grid_area_names_explicit):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![image](assets/css5_1232.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: Figure 12-32\. Implicit grid-area names made explicit
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because the grid lines use the form of `name-start`/`name-end`, the grid areas
    they define are implicitly named. To be frank, it’s clumsier than doing it the
    other way, but the capability is there in case you ever want it.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that you don’t need all four grid lines to be named in order to
    create a named grid area, though you probably do need them all to create a named
    grid area where you want it to be. Consider the following example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，为了创建一个命名的网格区域，你不需要所有四个网格线都被命名，尽管你可能确实需要它们全部被命名，以便在你希望的位置创建一个命名的网格区域。考虑以下示例：
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will still create a grid area named `content`. It’s just that the named
    area will be placed into a new row after all the defined rows. What’s odd is that
    an extra, empty row will appear after the defined rows but before the row containing
    `content`. This has been confirmed to be the intended behavior. Thus, if you try
    to create a named area by naming the grid lines and miss one or more of them,
    your named area will effectively hang off to one side of the grid instead of being
    a part of the overall grid structure.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然会创建一个名为`content`的网格区域。只是这个命名区域将放置在所有定义的行之后的新行中。奇怪的是，在定义的行之后但在包含`content`的行之前会出现一个额外的空行。这已确认是预期行为。因此，如果你尝试通过命名网格线来创建一个命名区域，并且错过了一个或多个网格线，你的命名区域将有效地悬挂在网格的一侧，而不是成为整体网格结构的一部分。
- en: So, again, if you want to create named grid areas, you should probably stick
    to explicitly naming grid areas and let the `start-` and `end-` grid-line names
    be created implicitly, as opposed to the other way around.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，再次强调，如果你想创建命名的网格区域，最好明确命名网格区域，并让`start-`和`end-`网格线名称隐式创建，而不是反过来。
- en: Placing Elements in the Grid
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将元素放置在网格中
- en: Believe it or not, we’ve gotten this far without talking about how grid items
    are actually placed in a grid, once they’ve been defined.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，我们到现在为止都没有讨论过网格项在网格中实际放置的方式。
- en: Using Column and Row Lines
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用列和行线
- en: There are a couple of ways to go about placing grid items, depending on whether
    you want to refer to grid lines or grid areas. We’ll start with four simple properties
    that attach an element to grid lines.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你是否想引用网格线还是网格区域，放置网格项有几种方法。我们将从四个简单的属性开始，这些属性将元素附加到网格线上。
- en: 'These properties let you say, “I want the edge of the element to be attached
    to grid line such-and-so.” As with so much of CSS Grid, it’s a lot easier to show
    than to describe, so ponder the following styles and their result (see [Figure 12-33](#attaching_elements_to_grid_lines)):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性让你可以说：“我希望元素的边缘连接到这个网格线。”正如CSS Grid的许多内容一样，展示起来比描述起来要容易得多，请考虑以下样式及其结果（参见[图12-33](#attaching_elements_to_grid_lines)）：
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![image](assets/css5_1233.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![图片](assets/css5_1233.png)'
- en: Figure 12-33\. Attaching elements to grid lines
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-33\. 将元素附加到网格线
- en: Here, we’re using grid-line numbers to say where and how the elements should
    be placed within the grid. Column numbers count from left to right, and row numbers
    from top to bottom. If you omit ending grid lines, as was the case for `.three`,
    then the next grid lines in sequence are used for the end lines.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用网格线号来说明元素在网格中应该如何放置。列号从左到右计数，行号从上到下计数。如果省略了结束的网格线，就像`.three`的情况一样，那么序列中的下一个网格线将用作结束线。
- en: 'Thus, the rule for `.three` in the previous example is exactly equivalent to
    this:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面示例中的`.three`规则与此完全相同：
- en: '[PRE48]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'There’s another way to say that same thing, as it happens: you could replace
    the ending values with `span 1`, or even just plain `span`, like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有另一种表达方式：你可以用`span 1`替换结束值，甚至只用`span`，像这样：
- en: '[PRE49]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you supply `span` with a number, you’re saying, “Span across this many grid
    tracks.” So we can rewrite our earlier example like this and get exactly the same
    result:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用一个数字来设置`span`，你是在说：“横跨这么多网格轨道。”因此，我们可以像这样重写我们的早期示例，并得到完全相同的结果：
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If you leave out a number for `span`, it’s set to be `1`. You can’t use 0 or
    negative numbers for `span`; only positive integers.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`span`中省略一个数字，它将被设置为`1`。你不能使用0或负数来设置`span`，只能使用正整数。
- en: An interesting feature of `span` is that you can use it for both ending *and*
    starting grid lines. The precise behavior of `span` is that it counts grid lines
    in the direction “away” from the grid line where it starts. In other words, if
    you define a start grid line and set the ending grid line to be a `span` value,
    it will search toward the end of the grid. Conversely, if you define an ending
    grid line and make the start line a `span` value, it will search toward the start
    of the grid.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`span`的一个有趣特性是，您可以同时用于结束和开始网格线。`span`的精确行为是在网格线开始的方向上“远离”网格线计数。换句话说，如果您定义一个起始网格线并将结束网格线设置为`span`值，它将向网格末端搜索。相反，如果您定义一个结束网格线并使起始线为`span`值，则它将向网格起始端搜索。'
- en: 'That means the following rules will have the result shown in [Figure 12-34](#spanning_grid_lines)
    (the column and row numbers were added for clarity):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下规则将显示为 [图 12-34](#spanning_grid_lines) 所示的结果（为了清晰起见，添加了列和行号）：
- en: '[PRE51]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![image](assets/css5_1234.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1234.png)'
- en: Figure 12-34\. Spanning grid lines
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-34\. 跨越网格线
- en: 'In contrast to `span` numbering, you aren’t restricted to positive integers
    for your actual grid-line values. Negative numbers will count backward from the
    end of explicitly defined grid lines. Thus, to place an element into the bottom-right
    grid cell of a defined grid, regardless of how many columns or rows it might have,
    you can just say this:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 与`span`编号相比，实际网格线值并不限于正整数。负数将从显式定义的网格线末尾向前计数。因此，要将元素放置到定义的网格的右下网格单元中，无论它可能有多少列或行，您只需说这个：
- en: '[PRE52]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that this doesn’t apply to any implicit grid tracks, a concept we’ll get
    to in a bit, but only to the grid lines you explicitly define via one of the `grid-template-*`
    properties (e.g., `grid-template-rows`).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不适用于任何隐式网格轨道，这是我们稍后会讨论的一个概念，只适用于您通过其中一个`grid-template-*`属性显式定义的网格线（例如，`grid-template-rows`）。
- en: 'We aren’t restricted to grid-line numbers, as it happens. If there are named
    grid lines, we can refer to those instead of (or in conjunction with) numbers.
    If you have multiple instances of a grid-line name, you can use numbers to identify
    which instance of the grid-line name you’re talking about. Thus, to start from
    the fourth instance of a row grid named `mast-slice`, you can say `mast-slice
    4`. Take a look at the following, illustrated in [Figure 12-35](#attaching_elements_to_named_grid_lines),
    for an idea of how this works:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并非局限于网格线号码。如果有命名网格线，我们可以引用这些网格线，而不是（或与）号码一起使用。如果您有多个网格线名称的实例，可以使用数字来标识您正在谈论的网格线名称的哪个实例。因此，要从名为`mast-slice`的行网格的第四个实例开始，您可以说`mast-slice
    4`。请查看下面的内容，如 [图 12-35](#attaching_elements_to_named_grid_lines) 所示，了解其工作原理的一些想法：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '![image](assets/css5_1235.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1235.png)'
- en: Figure 12-35\. Attaching elements to named grid lines
  id: totrans-319
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-35\. 将元素附加到命名网格线
- en: 'Notice how `span` changes when we add a name: specifying `span 2 col-A` causes
    the grid item to span from its starting point (the third `col-A`) across another
    `col-A` and end at the `col-A` after that. This means the grid item actually spans
    four column tracks, since `col-A` appears on every other column grid line.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们添加名称时`span`如何变化：指定`span 2 col-A`会导致网格项从其起始点（第三个`col-A`）跨越另一个`col-A`，并在其后的`col-A`结束。这意味着网格项实际上跨越四个列轨道，因为`col-A`出现在每隔一个列网格线上。
- en: 'Again, negative numbers count backward from the end of a sequence, so `col-A
    -2` gets us the second-to-last instance of a grid line named `col-A`. Because
    no end-line values are declared for `.three`, they’re both set to `span 1`. That
    means the following is exactly equivalent to the `.three` in the previous example:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，负数从序列末尾向前计数，因此`col-A -2`获取了名为`col-A`的倒数第二个网格线实例。因为`.three`未声明结束线值，它们都设置为`span
    1`。这意味着以下内容与前面示例中的`.three`完全相同：
- en: '[PRE54]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'There’s an alternative way to use names with named grid lines—specifically,
    the named grid lines that are implicitly created by grid areas. For example, consider
    the following styles, illustrated in [Figure 12-36](#another_way_of_attaching):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有命名网格线的名称的另一种方法——具体来说，是由网格区域隐式创建的命名网格线。例如，请考虑以下样式，如 [图 12-36](#another_way_of_attaching)
    所示：
- en: '[PRE55]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![image](assets/css5_1236.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1236.png)'
- en: Figure 12-36\. Another way of attaching elements to named grid lines
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-36\. 将元素附加到命名网格线的另一种方法
- en: 'If you supply a custom identifier (i.e., a name you defined), the browser looks
    for a grid line with that name *plus* either `-start` or `-end` added on, depending
    on whether you’re assigning a start line or an end line. Thus, the following are
    equivalent:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This works because, as we mentioned with `grid-template-areas`, explicitly creating
    a grid area implicitly creates the named `-start` and `-end` grid lines that surround
    it.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'The final value possibility, `auto`, is kind of interesting. According to the
    Grid Layout specification, if one of the grid-line start/end properties is set
    to `auto`, that indicates “auto-placement, an automatic span, or a default span
    of one.” In practice, this tends to mean that the grid line that gets picked is
    governed by the *grid flow*, a concept we have yet to cover (but will soon!).
    For a start line, `auto` usually means that the next available column or row line
    will be used. For an end line, `auto` usually means a one-cell span. In both cases,
    the word *usually* is used intentionally: as with any automatic mechanism, there
    are no absolutes.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Using Row and Column Shorthands
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two shorthand properties allow you to more compactly attach an element to grid
    lines.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary benefit of these properties is that they make it a lot simpler
    to declare the start and end grid lines to be used for laying out a grid item.
    For example:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That’s a whole lot easier to read than having each start and end value in its
    own property, honestly. Other than being more compact, the behavior of these properties
    is more or less what you’d expect. If you have two bits separated by a forward
    slash (`/`), the first part defines the starting grid line, and the second part
    defines the ending grid line.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have only one value with no forward slash, it defines the starting grid
    line. The ending grid line depends on what you said for the starting line. If
    you supply a name for the starting grid line, the ending grid line is given that
    same name. If a single number is given, the second number (the end line) is set
    to `auto`. That means the following pairs are equivalent:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: A subtle behavior built into the handling of grid-line names in `grid-row` and
    `grid-column` pertains to implicitly named grid lines. As you may recall, defining
    a named grid area creates `-start` and `-end` grid lines. That is, given a grid
    area with a name of `footer`, there are implicitly created `footer-start` grid
    lines to its top and left, and `footer-end` grid lines to its bottom and right.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, if you refer to those grid lines by the area’s name, the element
    will still be placed properly. Thus, the following styles have the result shown
    in [Figure 12-37](#attaching_to_implicit_grid_lines):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '![image](assets/css5_1237.png)'
  id: totrans-341
  prefs: []
  type: TYPE_IMG
- en: Figure 12-37\. Attaching to implicit grid lines via grid-area names
  id: totrans-342
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can always explicitly refer to the implicitly named grid lines, but if
    you just refer to the grid area’s name, things still work out. If you refer to
    a grid-line name that doesn’t correspond to a grid area, it falls back to the
    behavior discussed previously. In detail, it’s the same as saying `line-name 1`,
    so the following two are equivalent:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您始终可以明确引用隐式命名的网格线，但如果只引用网格区域的名称，事情仍能正常进行。如果引用一个与网格区域不对应的网格线名称，它将回退到之前讨论的行为。详细来说，它与`line-name
    1`的说法是一样的，所以下面两者是等价的：
- en: '[PRE60]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is why it’s risky to name grid lines the same as grid areas. Consider
    the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么命名网格线与网格区域相同是有风险的。考虑以下情况：
- en: '[PRE61]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This explicitly sets grid lines named `footer` above the “footer” row and below
    the “legal” row…and now there’s trouble ahead. Suppose we add this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这明确设置了位于“footer”行上方和“legal”行下方的名为`footer`的网格线…现在前面有麻烦了。假设我们添加了这个：
- en: '[PRE62]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: For the column lines, there’s no problem. The name `footer` gets expanded to
    `footer / footer`. The browser looks for a grid area with that name and finds
    it, so it translates `footer / footer` to `footer-start / footer-end`. The `#footer`
    element is attached to those implicit grid lines.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列线来说，没有问题。名称`footer`被扩展为`footer / footer`。浏览器查找具有该名称的网格区域并找到它，因此将`footer /
    footer`翻译为`footer-start / footer-end`。`#footer`元素附加到这些隐式网格线上。
- en: For `grid-row`, everything starts out the same. The `footer` name becomes `footer
    / footer`, which is translated to `footer-start / footer-end`. But that means
    the `#footer` will only be as tall as the “footer” row. It will *not* stretch
    to the second explicitly named `footer` grid line below the “legal” row, because
    the translation of `footer` to `footer-end` (due to the match between the grid-line
    name and the grid-area name) takes precedence.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`grid-row`，一切都是从相同的起点开始的。名称`footer`变成了`footer / footer`，这被翻译为`footer-start
    / footer-end`。但这意味着`#footer`只会与“footer”行一样高。它不会延伸到下面的第二个明确命名的`footer`网格线，因为`footer`到`footer-end`的翻译（由于网格线名称与网格区域名称的匹配）具有优先权。
- en: 'The upshot of all this: it’s generally a bad idea to use the same name for
    grid areas and grid lines. You might be able to get away with it in some scenarios,
    but you’re almost always better off keeping your line and area names distinct,
    so as to avoid tripping over name-resolution conflicts.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切的要点是：通常不建议为网格区域和网格线使用相同的名称。在某些情况下，您可能能够摆脱这种情况，但通常最好保持线和区域名称不同，以避免命名解析冲突。
- en: Working with Implicit Grid
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用隐式网格
- en: 'Up to this point, we’ve concerned ourselves solely with explicitly defined
    grids: we’ve talked about the row and column tracks we define via properties like
    `grid-template-columns`, and how to attach grid items to the cells in those tracks.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们仅关注了明确定义的网格：我们讨论了通过像`grid-template-columns`这样的属性定义的行和列轨道，以及如何将网格项附加到这些轨道中的单元格。
- en: 'But what happens if we try to place a grid item, or even just part of a grid
    item, beyond that explicitly created grid? For example, consider the following
    grid:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们尝试放置一个网格项，甚至只是网格项的一部分，超出明确创建的网格会发生什么？例如，考虑以下网格：
- en: '[PRE63]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Two rows, six columns. Simple enough. But suppose we define a grid item to
    sit in the first column and go from the first-row grid line to the fourth:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 两行，六列。很简单。但假设我们定义一个网格项，它位于第一列，并从第一行网格线延伸到第四行：
- en: '[PRE64]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now what? We have only two rows bounded by three grid lines, and we’ve told
    the browser to go beyond that, from row line 1 to row line 4.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 现在怎么办？我们只有由三条网格线界定的两行，并告诉浏览器超出这些范围，从第一行到第四行。
- en: 'What happens is that another row line is created to handle the situation. This
    grid line, and the new row track it creates, are both part of the *implicit grid*.
    Here are a few examples of grid items that create implicit grid lines (and tracks)
    and how they’re laid out (see [Figure 12-38](#creating_implicit_grid_lines_and_tracks)):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的是，会创建另一行网格线来处理这种情况。这条网格线及其创建的新行轨道都属于隐式网格。以下是创建隐式网格线（和轨道）以及它们如何布局的几个示例（参见[图12-38](#creating_implicit_grid_lines_and_tracks)）。
- en: '[PRE65]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '![image](assets/css5_1238.png)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1238.png)'
- en: Figure 12-38\. Creating implicit grid lines and tracks
  id: totrans-362
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-38。创建隐式网格线和轨道
- en: A lot is going on there, so let’s break it down. First off, the explicit grid
    is represented by the filled-in box behind the various numbered boxes; all the
    dashed lines represent the implicit grid.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 那里发生了很多事情，让我们分解一下。首先，填充在各种编号框后面的盒子代表明确的网格；所有虚线表示隐式网格。
- en: What about those numbered boxes? The first, `box1`, adds an extra grid row line
    after the end of the explicit grid. The second, `box2`, starts on the last row-line
    of the explicit grid, and spans forward two row-lines, so it adds yet another
    implicit row-line. The third, `box3`, ends on the last explicit row-line (line
    3) and spans *back* two lines, thus starting on the first explicit row-line.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 那些编号盒子呢？第一个`box1`在显式网格结束后添加了一个额外的网格行线。第二个`box2`从显式网格的最后一行线开始，跨越两个网格行线，因此添加了另一个隐式网格行线。第三个`box3`在显式网格的最后一行（第
    3 行）结束，并且向后跨越两行，因此从显式网格的第一行开始。
- en: Things really get interesting with `box4`. It ends on the fifth row-line, which
    is to say the second implicit row-line. It spans back three row-lines—and yet,
    it still starts on the same row-line as `box3`. This happens because grid track
    spans have to start counting *within* the explicit grid. Once they start, they
    can continue into the implicit grid (as happened with `box2`), but they *cannot*
    start counting within the implicit grid.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`box4`，情况变得真正有趣。它结束于第五行线，也就是第二个隐式网格行线。它向后跨越三个网格行线，然而，它仍然从`box3`所在的同一行线开始。这是因为网格轨道跨度必须从显式网格内部开始计数。一旦开始，它们可以继续进入隐式网格（就像`box2`发生的那样），但不能从隐式网格内部开始计数。
- en: 'Thus, `box4` ends on row-line 5, but its span starts with row-line 3 and counts
    back two lines (`span 2`) to arrive at row-line 1\. Similarly, `box5` ends on
    row-line 5 and spans back four lines, which means it starts on row-line –2\. Remember:
    span counting must *start* in the explicit grid. It doesn’t have to end there.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`box4`结束于第 5 行线，但其跨度从第 3 行线开始向后计数两行（`span 2`），直到达到第 1 行线。类似地，`box5`结束于第 5
    行线，并向后跨越四行，这意味着它从第 -2 行线开始。记住：跨度计数必须从显式网格开始。它不必在那里结束。
- en: After those, `box6` starts on the last explicit row-line (line 3), and spans
    out to the sixth row-line—adding yet another implicit row-line. The point of having
    it here is to show that negative grid-line references are with respect to the
    explicit grid, and count back from its end. They do *not* refer to negatively
    indexed implicit lines that are placed before the start of the explicit grid.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这之后，`box6`从显式网格的最后一行线（第 3 行）开始，并延伸到第六行线，又添加了一个隐式网格行线。放置在这里的目的是展示负数网格线引用是相对于显式网格的，并且从其末端向前计数。它们不指涉放置在显式网格开始之前的负数索引的隐式线。
- en: 'If you want to start an element on an implicit grid line before the explicit
    grid’s start, the way to do that is shown by `box7`: put its end line somewhere
    in the explicit grid, and span back past the beginning of the explicit grid. And
    you may have noticed: `box7` occupies an implicit column track. The original grid
    was set up to create six columns, which means seven column-lines, the seventh
    being the end of the explicit grid. When `box7` was given `grid-column: 7`, that
    was equivalent to `grid-column: 7 / span 1` (since a missing end line is always
    assumed to be `span 1`). That necessitated the creation of an implicit column-line
    in order to hold the grid item in the implicit seventh column.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你想在显式网格开始之前的隐式网格线上放置一个元素，`box7`展示了如何做到这一点：将其结束线放置在显式网格的某处，并向前跨过显式网格的开始。也许你已经注意到：`box7`占据了一个隐式列轨道。原始网格设置为创建六列，这意味着七个列线，第七个是显式网格的结束。当给`box7`设置`grid-column:
    7`时，这相当于`grid-column: 7 / span 1`（因为缺少的结束线总是被假定为`span 1`）。这需要创建一个隐式列线，以便将网格项放置在隐式的第七列中。'
- en: 'Now let’s take those principles and add named grid lines to the mix. Consider
    the following, illustrated in [Figure 12-39](#named_implicit_grid_lines_and_tracks):'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把这些原则和命名网格线结合起来。考虑下面的情况，如[图 12-39](#named_implicit_grid_lines_and_tracks)所示：
- en: '[PRE66]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'What you can see at work in several of these examples is what happens with
    grid-line names in the implicit grid: every implicitly created line has the name
    that’s being hunted. Take `box2`, for example. It’s given an end line of `final`,
    but there is no line with that name. Thus the span-search goes to the end of the
    explicit grid and, having not found the name it’s looking for, creates a new grid
    line, to which it attaches the name `final`. (In [Figure 12-39](#named_implicit_grid_lines_and_tracks),
    the implicitly created line names are italicized and faded out a bit.)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，你可以看到隐式网格中网格线名称的作用：每个隐式创建的线都具有被追寻的名称。以`box2`为例，它被赋予一个名为`final`的结束线，但实际上没有这样的线。因此，搜索跨度到显式网格的末端，并且在未找到所寻找的名称时创建了一个新的网格线，将其命名为`final`。（在[图 12-39](#named_implicit_grid_lines_and_tracks)中，隐式创建的线条名称是斜体且稍稍淡化了。）
- en: '![image](assets/css5_1239.png)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1239.png)'
- en: Figure 12-39\. Named implicit grid lines and tracks
  id: totrans-373
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-39\. 命名的隐式网格线和轨道
- en: Similarly, `box3` starts on the first explicit row-line, and then needs to span
    three `middle` named lines. It searches forward and finds one, then goes looking
    for the other two. Not finding any, it attaches the name `middle` to the first
    implicit row-line, and then does the same for the second implicit row-line. Thus,
    it ends two implicit row-lines past the end of the explicit grid.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`box3` 从第一个显式行线开始，然后需要跨越三个 `middle` 命名线。它向前搜索并找到一个，然后继续寻找另外两个。找不到任何线后，它将名称
    `middle` 附加到第一个隐式行线，然后对第二个隐式行线执行相同操作。因此，它跨越了显式网格的结束点两个隐式行线。
- en: The same sort of thing happens with `box4` and `box5`, except working backward
    from endpoints. You can see that `box4` ends with the `end` row-line (line 3),
    then spans back to the second `begin` row-line it can find. This causes an implicit
    row-line to be created before the first row-line, named `begin`. Finally, `box5`
    spans back from `begin` (the explicitly labeled `begin`) to the second `middle`
    it can find. Since it can’t find any, it labels two implicit row-line `middle`
    and ends at the one farthest from where it started looking.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `box4` 和 `box5` 发生的情况相同，只是从端点向后工作。你可以看到 `box4` 以 `end` 行线（第 3 行线）结束，然后跨越到它能找到的第二个
    `begin` 行线。这导致在第一个行线之前创建了一个隐式行线，名称为 `begin`。最后，`box5` 从 `begin`（明确标记的 `begin`）向后跨越到它能找到的第二个
    `middle`。由于找不到任何线，它将两个隐式行线标记为 `middle`，并在距离开始搜索位置最远的一个结束。
- en: Handling Errors
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'We need to cover a few cases, as they fall under the general umbrella of “what
    grids do when things go pear-shaped.” First, what if you accidentally put the
    start line after the end line? Say, something like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要涵盖几种情况，因为它们都属于“当事情变得一团糟时网格如何行事”的大框架。首先，如果你不小心将起始线放在结束线之后会怎么样？比如，像这样的情况：
- en: '[PRE67]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'All that happens is probably what was meant in the first place: the values
    are swapped. Thus, you end up with the following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 所有发生的可能就是最初意图的实现：值被交换。因此，你最终得到以下结果：
- en: '[PRE68]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Second, what if both the start and the end lines are declared to be spans of
    some variety? For example:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，如果起始线和结束线都声明为某种跨度呢？例如：
- en: '[PRE69]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If this happens, the end value is dropped and replaced with `auto`. That means
    you’d end up with this:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种情况发生，结束值被丢弃并替换为 `auto`。这意味着你最终会得到这样的结果：
- en: '[PRE70]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: That would cause the grid item to have its ending edge placed automatically,
    according to the current grid flow (a subject we’ll soon explore), and the starting
    edge to be placed one grid line earlier.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致网格项的结束边根据当前网格流（我们很快会探讨这个主题）自动放置，并且起始边会提前一个网格线的位置。
- en: 'Third, what if the only thing directing placement of the grid item is a named
    span? In other words, you’d have this:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，如果唯一指导网格项放置的是一个命名的跨度呢？换句话说，你会有这样一个情况：
- en: '[PRE71]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is not permitted, so the `span footer` in this case is replaced with `span
    1`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不允许的，因此在这种情况下 `span footer` 被替换为 `span 1`。
- en: Using Areas
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用区域
- en: 'Attaching by row lines and column lines is great, but what if you could refer
    to a grid area with a single property? Behold: `grid-area`.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 按行线和列线连接很好，但是如果你可以用一个属性引用网格区域会怎样？瞧：`grid-area`。
- en: 'Let’s start with a simple use of `grid-area`: assigning an element to a previously
    defined grid area. For this, we’ll bring back our old friend `grid-template-areas`,
    put it together with `grid-area` and some markup, and see what magic results (as
    shown in [Figure 12-40](#assigning_elements_to_grid_areas)):'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单使用 `grid-area` 开始：将一个元素分配到先前定义的网格区域。为此，我们将重新使用我们的老朋友 `grid-template-areas`，与
    `grid-area` 和一些标记组合在一起，看看会有什么魔法结果（如 [图 12-40](#assigning_elements_to_grid_areas)
    所示）：
- en: '[PRE72]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![image](assets/css5_1240.png)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1240.png)'
- en: Figure 12-40\. Assigning elements to grid areas
  id: totrans-394
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-40\. 将元素分配到网格区域
- en: 'That’s all it takes: set up some named grid areas to define your layout, and
    then drop grid items into them with `grid-area`. So simple and yet so powerful.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有的事情了：设置一些命名的网格区域来定义你的布局，然后用 `grid-area` 将网格项放入其中。如此简单而又强大。
- en: 'Another way to use `grid-area` refers to grid lines instead of grid areas.
    Fair warning: it’s likely to be confusing at first.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用 `grid-area` 的方式是引用网格线而不是网格区域。公平警告：一开始可能会感到困惑。
- en: 'Here’s an example of a grid template that defines some grid lines, and some
    `grid-area` rules that reference the lines, as illustrated in [Figure 12-41](#assigning_elements_to_grid_lines):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个定义了一些网格线和一些引用这些线的 `grid-area` 规则的网格模板示例，如 [图 12-41](#assigning_elements_to_grid_lines)
    所示：
- en: '[PRE73]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '![image](assets/css5_1241.png)'
  id: totrans-399
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1241.png)'
- en: Figure 12-41\. Assigning elements to grid lines
  id: totrans-400
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-41。将元素分配到网格线
- en: These elements were placed as directed. Note the ordering of the grid-line values,
    however. They’re listed in the order `row-start`, `column-start`, `row-end`, `column-end`.
    If you diagram that in your head, you’ll quickly realize that the values go counterclockwise
    (also called anticlockwise) around the grid item—the exact opposite of the TRBL
    pattern we’re used to from margins, padding, borders, and so on. Furthermore,
    this means the column and row references are not grouped together but are instead
    split up.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元素按照指示进行了放置。请注意网格线值的排序顺序。它们按照`row-start`，`column-start`，`row-end`，`column-end`的顺序列出。如果您在脑海中进行图解，您很快就会意识到这些值是逆时针（也称为逆时针）绕过网格项的，与我们从边距、填充、边框等方面熟悉的TRBL模式完全相反。此外，这意味着列和行引用并未分组在一起，而是分开处理。
- en: If you supply fewer than four values, then the missing values are taken from
    those you do supply. If you use only three values, then the missing `grid-column-end`
    is the same as `grid-column-start` if it’s a name; if the start line is a number,
    the end line is set to `auto`. The same holds true if you give only two values,
    except that the now-missing `grid-row-end` is copied from `grid-row-start` if
    it’s a name; otherwise, it’s set to `auto`.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您提供少于四个值，则缺失的值将从您提供的值中获取。如果您只使用三个值，则缺失的`grid-column-end`与`grid-column-start`相同（如果它是一个名称）；如果起始行是一个数字，则结束行设置为`auto`。如果只提供两个值，则缺失的`grid-row-end`从`grid-row-start`复制（如果它是一个名称）；否则，它被设置为`auto`。
- en: 'From that, you can probably guess what happens if only one value is supplied:
    if it’s a name, use it for all four values; if it’s a number, the rest are set
    to `auto`.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 从此，您可能已经猜到如果只提供一个值会发生什么：如果它是一个名称，则将其用于所有四个值；如果它是一个数字，则其余的值设置为`auto`。
- en: 'This one-to-four replication pattern is actually how giving a single grid-area
    name translates into having the grid item fill that area. The following are equivalent:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这种一对四的复制模式实际上是将单个网格区域名称转换为使网格项填充该区域的方法。以下是等效的：
- en: '[PRE74]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now recall the behavior discussed in the previous section about `grid-column`
    and `grid-row`: if a grid line’s name matches the name of a grid area, it’s translated
    into a `-start` or `-end` variant, as appropriate. That means the previous example
    is translated to the following:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回想一下上一节讨论的`grid-column`和`grid-row`的行为：如果网格线的名称与网格区域的名称匹配，它会根据需要转换为`-start`或`-end`变体。这意味着前面的例子被翻译为以下内容：
- en: '[PRE75]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: And that’s how a single grid-area name causes an element to be placed into the
    corresponding grid area.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是单个网格区域名称导致元素放置到相应网格区域的方式。
- en: Understanding Grid-Item Overlap
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解网格项重叠
- en: 'One thing we’ve been very careful to do in our grid layouts thus far is to
    avoid overlap. Rather like positioning, it’s absolutely (get it?) possible to
    make grid items overlap each other. Let’s take a simple case, illustrated in [Figure 12-42](#overlapping_grid_items):'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，在我们的网格布局中，我们非常小心地避免重叠。就像定位一样，绝对（懂了吗？）可以使网格项彼此重叠。让我们来看一个简单的例子，如图[12-42](#overlapping_grid_items)所示：
- en: '[PRE76]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![image](assets/css5_1242.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1242.png)'
- en: Figure 12-42\. Overlapping grid items
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-42。重叠的网格项
- en: Thanks to the grid numbers that were supplied in the last two lines of the CSS,
    the two grid items overlap in the upper-right grid cell. Which is on top of the
    other depends on the layering behavior we’ll discuss later, but for now, just
    take it as a given that they do layer when overlapping.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了上述CSS中提供的网格数字，两个网格项在右上角的网格单元格中重叠。哪一个在上面取决于我们稍后将讨论的层叠行为，但现在，就当它们确实是层叠的事实而言。
- en: There may well be times when you want grid items to overlap. A photo’s caption
    might partially overlap the photo, for example. Or you might want to assign a
    few items to the same grid area so they combine, or set them to be shown one at
    a time by script or user interaction.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能希望网格项重叠。例如，照片的标题可能部分重叠在照片上。或者您可能希望将几个项目分配给同一个网格区域，以便它们合并，或者通过脚本或用户交互逐个显示。
- en: Overlap isn’t restricted to situations involving raw grid numbers. In the following
    case, the sidebar and the footer will overlap, as shown in [Figure 12-43](#overlapping_sidebar_and_footer).
    (Assuming the footer comes later than the sidebar in the markup, then in the absence
    of other styles, the footer will be on top of the sidebar.)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 重叠不仅限于涉及原始网格数的情况。在以下情况中，侧边栏和页脚将会重叠，如[图 12-43](#overlapping_sidebar_and_footer)所示。（假设页脚在标记中位于侧边栏之后，则在没有其他样式的情况下，页脚将覆盖在侧边栏之上。）
- en: '[PRE77]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '![image](assets/css5_1243.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1243.png)'
- en: Figure 12-43\. Overlapping sidebar and footer
  id: totrans-419
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-43\. 侧边栏和页脚重叠
- en: 'We bring this up in part to warn you about the possibility of overlap, and
    also to serve as a transition to the next topic. It’s a feature that sets grid
    layout apart from positioning, in that it can sometimes help avoid overlap: the
    concept of *grid flow*.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到这一点部分是为了警告您可能出现重叠的可能性，同时也是为了过渡到下一个主题。这是一个使网格布局与定位分开的特性，因为它有时可以帮助避免重叠：*网格流*的概念。
- en: Specifying Grid Flow
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定网格流
- en: For the most part, we’ve been explicitly placing grid items on the grid. If
    items aren’t explicitly placed, they’re automatically placed into the grid. Following
    the grid-flow direction that’s in effect, an item is placed in the first area
    that will fit it. The simplest case is just filling a grid track in sequence,
    one grid item after another, but things can get a lot more complex than that,
    especially if there is a mixture of explicitly and automatically placed grid items.
    The latter must work around the former.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分情况下，我们都是在网格上显式放置网格项。如果未显式放置项，则将自动放置到网格中。根据生效的网格流方向，将项放置在第一个适合其的区域中。最简单的情况就是依次填充网格轨道，一个接一个地放置网格项，但情况可能比这复杂得多，尤其是在显式和自动放置的网格项混合存在时。后者必须围绕前者工作。
- en: CSS has primarily two grid-flow models, *row-first* and *column-first*, though
    you can enhance either by specifying a *dense* flow. All this is done with the
    property called `grid-auto-flow`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 主要有两种网格流模型，即*行优先*和*列优先*，尽管你可以通过指定*密集*流来增强任何一种流。所有这些都是通过名为`grid-auto-flow`的属性完成的。
- en: 'To see how these values work, consider the following markup:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这些值如何工作，请考虑以下标记：
- en: '[PRE78]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To that markup, let’s apply the following styles:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个标记，让我们应用以下样式：
- en: '[PRE79]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Assuming a grid with a column line every 15 ems and a row line every 4 ems,
    we get the result shown in [Figure 12-44](#row-oriented_grid_flow).
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 假设网格每隔 15 em 设置一列线，每隔 4 em 设置一行线，我们得到如[图 12-44](#row-oriented_grid_flow)所示的结果。
- en: '![image](assets/css5_1244.png)'
  id: totrans-429
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1244.png)'
- en: Figure 12-44\. Row-oriented grid flow
  id: totrans-430
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-44\. 行导向的网格流
- en: 'This probably seems pretty normal, the same sort of thing you’d get if you
    floated all the boxes, or if all of them were inline blocks. That familiarity
    is why `row` is the default value. Now, let’s try switching the `grid-auto-flow`
    value to `column`, as shown in [Figure 12-45](#column-oriented_grid_flow):'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很正常，就像你将所有框都浮动或者都设置为内联块一样。正是这种熟悉感，使得`row`成为默认值。现在，让我们尝试将`grid-auto-flow`的值切换为`column`，如[图 12-45](#column-oriented_grid_flow)所示：
- en: '[PRE80]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'So with `grid-auto-flow: row`, each row is filled in before starting on the
    next row. With `grid-auto-flow: column`, each column is filled first.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，使用`grid-auto-flow: row`时，每行都会先填满，然后再开始下一行。而使用`grid-auto-flow: column`时，每列会先填满。'
- en: '![image](assets/css5_1245.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1245.png)'
- en: Figure 12-45\. Column-oriented grid flow
  id: totrans-435
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-45\. 列导向的网格流
- en: 'What needs to be stressed here is that the list items weren’t explicitly sized.
    By default, they were resized to attach to the defined grid lines. This can be
    overridden by assigning explicit sizing to the elements. For example, if we make
    the list items 7 ems wide and 1.5 ems tall, we’ll get the result shown in [Figure 12-46](#explicitly_sized_grid_items):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要强调的是，列表项并未显式设置大小。默认情况下，它们被调整大小以连接到定义的网格线。可以通过为元素分配显式大小来覆盖此行为。例如，如果我们将列表项设置为宽
    7 em 高 1.5 em，则会得到如[图 12-46](#explicitly_sized_grid_items)所示的结果：
- en: '[PRE81]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '![image](assets/css5_1246.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1246.png)'
- en: Figure 12-46\. Explicitly sized grid items
  id: totrans-439
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-46\. 显式大小的网格项
- en: If you compare that to the previous figure, you’ll see that the corresponding
    grid items start in the same place; they just don’t end in the same places. This
    illustrates that what’s really placed in grid flow is grid areas, to which the
    grid items are then attached.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将其与之前的图进行比较，会发现对应的网格项起始位置相同；只是终止位置不同。这说明，真正放置在网格流中的是网格区域，然后将网格项连接到这些区域。
- en: 'This is important to keep in mind if you auto-flow elements that are wider
    than their assigned column or taller than their assigned row, as can very easily
    happen when turning images or other intrinsically sized elements into grid items.
    Let’s say we want to put a bunch of images, each a different size, into a grid
    that’s set up to have a column line every 50 horizontal pixels, and a row line
    every 50 vertical pixels. This grid is illustrated in [Figure 12-47](#flowing_images_in_grids),
    along with the results of flowing a series of images into that grid by either
    row or column:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '![image](assets/css5_1247.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: Figure 12-47\. Flowing images in grids
  id: totrans-444
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that some of the images overlap others? That’s because each image is
    attached to the next grid line in the flow, without taking into account the presence
    of other grid items. We didn’t set up images to span more than one grid track
    when they needed it, so overlap occurred.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be managed with class names or other identifiers. We could class images
    as `tall` or `wide` (or both) and specify that they get more grid tracks. Here’s
    some CSS to add to the previous example, with the result shown in [Figure 12-48](#giving_images_more_track_space):'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '![css5 1248](assets/css5_1248.png)'
  id: totrans-448
  prefs: []
  type: TYPE_IMG
- en: Figure 12-48\. Giving images more track space
  id: totrans-449
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This does cause the images to keep spilling down the page, but no overlapping
    occurs.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: However, notice the gaps in this grid? That happens because the placement of
    some grid items across grid lines doesn’t leave enough room for other items in
    the flow. To illustrate this, and the two flow patterns, more clearly, let’s try
    an example with numbered boxes ([Figure 12-49](#illustrating_flow_patterns)).
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1249.png)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
- en: Figure 12-49\. Illustrating flow patterns
  id: totrans-453
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Follow across the rows of the first grid, counting along with the numbers.
    In this particular flow, the grid items are laid out almost as if they were leftward
    floats. Almost, but not quite: notice that grid item 13 is actually to the left
    of grid item 11\. That would never happen with floats, but it can with grid flow.
    The way row flow (if we may call it that) works is that you go across each row
    from left to right, and if there’s room for a grid item, you put it there. If
    a grid cell has been occupied by another grid item, you skip over it. So the cell
    next to item 10 didn’t get filled, because there wasn’t room for item 11\. Item
    13 went to the left of item 11 because there was room for it there when the row
    was reached.'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: As shown by the second example in [Figure 12-49](#illustrating_flow_patterns),
    the same basic mechanisms hold true for column flow, except in this case you work
    from top to bottom. Thus, the cell below item 9 is empty because item 10 wouldn’t
    fit there. Instead, item 10 went into the next column and covered four grid cells
    (two in each direction). The items after it, since they were just one grid cell
    in size, filled in the cells after it in column order.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-456
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Grid flow works left to right, top to bottom in languages that have that writing
    pattern. In RTL languages, such as Arabic and Hebrew, the row-oriented flow would
    be right to left, not left to right.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were just now wishing for a way to pack grid items as densely as possible,
    regardless of how that affected the ordering, good news: you can! Just add the
    keyword `dense` to your `grid-auto-flow` value, and that’s exactly what will happen.
    We can see the result in [Figure 12-50](#illustrating_dense_flow_patterns), which
    shows the results of `grid-auto-flow: row dense` and `grid-auto-flow: dense column`
    side by side.'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1250.png)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
- en: Figure 12-50\. Illustrating dense flow patterns
  id: totrans-460
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first grid, item 12 appears in the row above item 11 because there was
    a cell that fit it. For the same reason, item 11 appears to the left of item 10
    in the second grid.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: In effect, what happens with `dense` grid flow is that for each grid item, the
    browser scans through the *entire* grid in the given flow direction (`row` or
    `column`), starting from the flow’s starting point (the top-left corner in LTR
    languages), until it finds a place where that grid item will fit. This can make
    things like photo galleries more compact, and works great as long as you don’t
    have a specific order in which the grid items need to appear.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve explored grid flow, we have a confession to make: to make the
    last couple of grid items look right, we included some CSS that we didn’t show
    you. Without it, the items hanging off the edge of the grid would have looked
    quite a bit different from the other items—much shorter in row-oriented flow,
    and much narrower in column-oriented flow. You’ll see why, and the CSS we used,
    in the next section.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: Defining Automatic Grid Tracks
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve almost entirely seen grid items placed into a grid that was explicitly
    defined. But in the preceding section we had grid items running off the edge of
    the explicitly defined grid. What happens when a grid item goes off the edge?
    Rows or columns are added as needed to satisfy the layout directives of the items
    in question (see [“Working with Implicit Grid”](#the-implicit-grid)). So, if an
    item with a row span of `3` is added after the end of a row-oriented grid, three
    new rows are added after the explicit grid.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: By default, these automatically added grid tracks are the absolute minimum size
    needed. If you want to exert a little more control over their sizing, `grid-auto-rows`
    and `grid-auto-columns` are for you.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: 'For any automatically created row or column tracks, you can provide a single
    track size or a minmaxed pair of track sizes. Let’s take a look at a reduced version
    of the grid-flow example from the previous section: we’ll set up a 2 × 2 grid
    and try to put five items into it. In fact, let’s do it twice: once with `grid-auto-rows`
    and once without, as illustrated in [Figure 12-51](#grids_auto-row_sizing):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: As the second grid shows, without assigning a size to the automatically created
    row, the overflowing grid items are placed in a row that’s exactly as tall as
    the grid items’ content, and not a pixel more. Each is still just as wide as the
    column into which it’s placed, because the columns have a size (`80px`). The row,
    lacking an explicit height, defaults to `auto`, with the result shown.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如第二个网格所示，如果没有为自动创建的行指定大小，则溢出的网格项将放置在与网格项内容完全相同高度的行中，而不多一像素。每个项仍然与放置它们的列一样宽（`80px`），因为列已经定义了大小。行，由于缺乏显式高度，默认为`auto`，结果如图所示。
- en: '![css5 1251](assets/css5_1251.png)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1251](assets/css5_1251.png)'
- en: Figure 12-51\. Grids with and without auto-row sizing
  id: totrans-471
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 12-51\. 具有自动行大小和无自动行大小的网格
- en: 'If we flip things to a column-oriented flow, the same basic principles apply
    (see [Figure 12-52](#grids_auto-column_sizing)):'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将事物转换为基于列的流，则相同的基本原则适用（参见[图 12-52](#grids_auto-column_sizing)）：
- en: '[PRE85]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '![image](assets/css5_1252.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1252.png)'
- en: Figure 12-52\. Grids with and without auto-column sizing
  id: totrans-475
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 12-52\. 具有自动列大小和无自动列大小的网格
- en: In this case, because the flow is column oriented, the last grid items are placed
    into a new column past the end of the explicit grid. In the second grid, where
    there’s no `grid-auto-columns`, those fifth and sixth items are each as tall as
    their rows (`80px`), but have an `auto` width, so they’re just as wide as they
    need to be, and no wider.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为流是基于列的，所以最后的网格项被放置到明确网格末端之外的新列中。在第二个网格中，没有`grid-auto-columns`，第五和第六个项的每个都与它们的行一样高（`80px`），但宽度为`auto`，因此它们的宽度正好适合它们所需的宽度，不再宽。
- en: 'Now you know what we used in the `grid-auto-flow` figures in the previous section:
    we silently made the auto-rows and auto-columns the same size as the explicitly
    sized columns, in order to not have the last few grid items look weird. Let’s
    bring back one of those figures, only this time the `grid-auto-rows` and `grid-auto-columns`
    styles will be removed. As shown in [Figure 12-53](#auto-track_sizing_removed),
    the last few items in each grid are shorter or narrower than the rest, because
    of the lack of auto-track sizing.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道我们在前一节中使用`grid-auto-flow`图表中使用了什么：我们悄悄地使自动行和自动列的大小与明确指定的列相同，以避免最后几个网格项看起来奇怪。让我们重新带回其中一个图表，只是这次将删除`grid-auto-rows`和`grid-auto-columns`样式。如[图 12-53](#auto-track_sizing_removed)所示，每个网格中的最后几个项比其余的短或窄，因为缺乏自动跟踪大小。
- en: '![image](assets/css5_1253.png)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1253.png)'
- en: Figure 12-53\. A previous figure with auto-track sizing removed
  id: totrans-479
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 12-53\. 移除了自动跟踪大小的前一个图表
- en: And now you know…the rest of the story.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了……剩下的故事。
- en: Using the grid Shorthand
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用网格简写
- en: At long last, we’ve come to the shorthand property `grid`. It might just surprise
    you, though, because it’s not like other shorthand properties.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 终于，我们来到了`grid`的简写属性。它可能会让你感到意外，因为它不像其他简写属性。
- en: The syntax is a little bit migraine-inducing, yes, but we’ll step through it
    a piece at a time.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 语法有点令人头痛，没错，但我们将逐步解释它。
- en: 'Let’s get to the elephant in the room right away: `grid` allows you to either
    define a grid template *or* to set the grid’s flow and auto-track sizing in a
    compact syntax. You can’t do both at the same time.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接谈谈房间里的大象：`grid`允许你定义网格模板*或*使用紧凑语法设置网格的流和自动跟踪大小。你不能同时做这两件事。
- en: Furthermore, whichever you don’t define is reset to its defaults, as is normal
    for a shorthand property. So if you define the grid template, the flow and auto
    tracks will be returned to their default values.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你不定义的部分将被重置为默认值，这对于缩写属性是正常的。因此，如果你定义了网格模板，流和自动跟踪将返回到它们的默认值。
- en: 'Now let’s talk about creating a grid template by using `grid`. The values can
    get fiendishly complex and take on some fascinating patterns, but can be very
    handy in some situations. As an example, the following rule is equivalent to the
    set of rules that follows it:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论如何通过使用`grid`创建网格模板。值可以变得非常复杂，并采用一些有趣的模式，但在某些情况下非常有用。例如，以下规则等同于随后的一组规则：
- en: '[PRE86]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Notice how the value of `grid-template-rows` is broken up and scattered around
    the strings of `grid-template-areas`. That’s how row sizing is handled in `grid`
    when you have grid-area strings present. Take those strings out, and you end up
    with the following:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`grid-template-rows`的值是如何在`grid-template-areas`字符串中分散并散布的。这就是在`grid`中处理行大小时处理网格区域字符串时的方式。去掉这些字符串，你会得到以下结果：
- en: '[PRE87]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: In other words, the row tracks are separated by a forward slash (`/`) from the
    column tracks.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，行轨道与列轨道之间由斜线（`/`）分隔。
- en: 'Remember that with `grid`, undeclared shorthands are reset to their defaults.
    That means the following two rules are equivalent:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，使用`grid`时，未声明的简写会重置为它们的默认值。这意味着以下两条规则是等效的：
- en: '[PRE88]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Therefore, make sure your `grid` declaration comes before anything else related
    to defining the grid. If we want a dense column flow, we’d write something like
    this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请确保您的`grid`声明出现在与定义网格相关的任何其他内容之前。如果我们想要密集的列流，则应编写类似于这样的内容：
- en: '[PRE89]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, let’s bring the named grid areas back, *and* add some extra row grid-line
    names to the mix. A named grid line that goes *above* a row track is written *before*
    the string, and a grid line that goes *below* the row track comes *after* the
    string and any track sizing. So let’s say we want to add `main-start` and `main-stop`
    above and below the middle row, and `page-end` at the very bottom:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新引入命名网格区域，并*同时*添加一些额外的行网格线名称。一个位于行轨道*上方*的命名网格线在字符串*之前*写入，而位于行轨道*下方*的网格线在字符串和任何轨道大小之后写入。因此，假设我们想在中间行上方和下方添加`main-start`和`main-stop`，并在底部添加`page-end`：
- en: '[PRE90]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: That creates the grid shown in [Figure 12-54](#creating_grid_w_grid), with the
    implicitly created named grid lines (e.g., `footer-start`), along with the explicitly
    named grid lines we wrote into the CSS.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建图12-54所示的网格，包括隐式创建的命名网格线（例如，`footer-start`），以及我们写入CSS中的显式命名网格线。
- en: '![image](assets/css5_1254.png)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1254.png)'
- en: Figure 12-54\. Creating a grid with the `grid` shorthand
  id: totrans-499
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-54\. 使用`grid`简写创建网格
- en: You can see how `grid` values can get very complicated very quickly. It’s a
    powerful syntax, and it’s surprisingly easy to get used to once you’ve had just
    a bit of practice. On the other hand, it’s also incredibly easy to get things
    wrong and have the entire value be invalid, thus preventing the appearance of
    any grid at all.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`grid`值可以非常快速地变得非常复杂。这是一种强大的语法，一旦您稍微练习一下，就会惊讶地发现很容易上手。另一方面，如果操作有误，整个值可能会无效，从而导致没有任何网格出现。
- en: 'For the other use of `grid`, it’s a merging of `grid-auto-flow`, `grid-auto-rows`,
    and `grid-auto-columns`. The following rules are equivalent:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`grid`的另一种用法，它是`grid-auto-flow`、`grid-auto-rows`和`grid-auto-columns`的合并。以下规则是等效的：
- en: '[PRE91]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'That’s certainly a lot less typing for the same result! But once again, we
    have to remind you: if you write this, all the column and row track properties
    will be set to their defaults. Thus, the following rules are equivalent:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于获得相同结果来说，确实是少打了很多字！但我们再次必须提醒您：如果您编写这个，所有列和行轨道属性将被设置为它们的默认值。因此，以下规则是等效的：
- en: '[PRE92]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: So once again, it’s important to make sure your shorthand comes before any properties
    it might otherwise override.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次强调，确保您的简写出现在可能覆盖的任何属性之前是很重要的。
- en: Using Subgrids
  id: totrans-506
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用子网格
- en: We promised many, many pages ago to talk about `subgrid`, and at last the time
    has come. The basic summary is that *subgrids* are grids that use the grid tracks
    of an ancestor grid to align their grid items, instead of a pattern unique to
    themselves. A crude example is setting a number of columns on the `<body>` element,
    and then having all of the layout components use that grid, no matter how far
    down they are in the markup.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们许诺很久以前要讨论`subgrid`，现在终于到了时候。基本总结是，*子网格* 是使用祖先网格的网格轨道来对齐其网格项的网格，而不是使用独特于自身的模式。一个简单的例子是在`<body>`元素上设置一些列，然后让所有布局组件都使用该网格，无论它们在标记中的深度如何。
- en: 'Let’s see how that works. We’ll start with a simple markup structure like this:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它是如何工作的。我们将从类似这样的简单标记结构开始：
- en: '[PRE93]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: A real home page would have a lot more elements, but we’re keeping this brief
    for clarity’s sake.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真实的主页会有更多元素，但为了清晰起见，我们保持这样的简洁。
- en: 'First, we add the following CSS:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加以下CSS：
- en: '[PRE94]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: At this point, the body has 15 columns, each equally sized thanks to the `1fr`
    value. Those columns are separated by 14 gutters, each 1% the width of the viewport.
    (These are almost certainly desktop styles and not intended for mobile devices.)
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，主体具有15列，每列大小均等，这要归功于`1fr`的值。这些列由14个沟槽分隔，每个沟槽宽度为视口宽度的1%。（这几乎肯定是桌面样式，而非移动设备的样式。）
- en: 'At the moment, the three children of the `<body>` element are trying to jam
    themselves into the first 3 of those 15 columns. We don’t want that: we want them
    to span the width of the layout. Well, we want the header and footer to do that.
    The `<main>` element should actually stand away from the edges of the viewport
    by, say, one column on each side.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`<body>` 元素的三个子元素正试图塞进这15列中的前3列。我们不希望这样：我们希望它们跨越整个布局的宽度。嗯，我们希望头部和尾部这样做。`<main>`
    元素实际上应该从视口边缘向外部分开一列。
- en: 'So we add the following CSS:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 因此我们添加以下 CSS：
- en: '[PRE95]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: What we have so far is illustrated in [Figure 12-55](#subgrid_simple_setup),
    with dashed lines added to represent the grid-column tracks set for the `<body>`
    element, and some extra content that wasn’t present in the initial markup code.
    (You’ll see it in more detail soon.)
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的在图12-55中有所体现（增加了虚线来表示为 `<body>` 元素设置的网格列轨道），还有一些在最初的标记代码中不存在的额外内容。（您很快会看到更详细的内容。）
- en: '![css5 1255](assets/css5_1255.png)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1255](assets/css5_1255.png)'
- en: Figure 12-55\. The initial setup of a page layout
  id: totrans-519
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-55. 页面布局的初始设置
- en: This might look like an entirely pointless exercise in defining and then ignoring
    a bunch of grid columns, but just wait. It’s about to get good.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能是一个完全无意义的定义和忽略一堆网格列的练习，但请稍等。情况即将变得很有趣。
- en: 'Let’s take a closer look at the site header. Here’s its full markup structure,
    minus the link URLs:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地查看网站的头部。这里是它完整的标记结构，去掉链接 URL：
- en: '[PRE96]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Again, a real site would probably have a bit more to it, but this is enough
    to get the point across. What we’re going to do now is turn the `<header>` element
    into a grid container that uses the `<body>` element’s grid tracks for itself:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，一个真实的网站可能会有更多内容，但这已足以阐明观点。现在我们要做的是将 `<header>` 元素转变为一个网格容器，它使用 `<body>`
    元素的网格轨道来自己布局：
- en: '[PRE97]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'In the first rule, we make the element into a grid container with `display:
    grid` and then says its column template is a `subgrid`. At this point, the browser
    looks up through the markup tree to the closest grid container and uses the `grid-template-columns`
    of that ancestor (in this case, the `<body>`). But this isn’t just a copy of the
    value. The `<header>` element is literally using the body’s grid tracks for its
    column-oriented layout.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '在第一条规则中，我们使用 `display: grid` 将元素设为网格容器，然后指定它的列模板为 `subgrid`。此时，浏览器会沿着标记树向上查找最近的网格容器，并使用那个祖先元素（在本例中是
    `<body>`）的 `grid-template-columns`。但这并不仅仅是值的复制。`<header>` 元素实际上是在使用 body 的网格轨道来进行列向布局。'
- en: Thus, when the second rule says the `<h1>` should start on column line 2 and
    span five column tracks, it starts on the body’s second column line and spans
    five of the body’s column lines. Similarly, the `<nav>` element is set to span
    seven tracks back from the second-to-last column line of the `<body>`. [Figure 12-56](#subgrid_header)
    shows the results, along with the self-alignment and text alignment of the `<nav>`
    element and some shaded backgrounds to clearly indicate where the header’s pieces
    are being gridded.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当第二条规则指定 `<h1>` 应从第2列线开始并跨越五个列轨道时，它实际上是从 body 的第二列线开始，并跨越 body 的五个列轨道。类似地，`<nav>`
    元素被设置为跨越从 body 倒数第二列线开始的七个轨道。图12-56展示了结果，同时展示了 `<nav>` 元素的自对齐和文本对齐，以及一些阴影背景来清楚地指示头部的部件是如何进行网格化的。
- en: '![css5 1256](assets/css5_1256.png)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1256](assets/css5_1256.png)'
- en: Figure 12-56\. Placing the `header`’s pieces on the `body`’s columns
  id: totrans-528
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-56. 将 `header` 的部件放置在 `body` 的列上
- en: Notice that the pieces inside the header line up perfectly with the edges of
    the `<main>` element. That’s because they’re all being placed on the exact same
    grid lines. Not separate grid lines that just happen to coincide, but the actual
    grid lines. This means that if, for example, the `<body>` element’s column template
    is changed to add a couple more columns, or to resize some of the columns to be
    wider or narrower, we just edit the `grid-template-columns` value for the `<body>`,
    and everything using those column lines will move along with the lines.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在头部内部的各个部件与 `<main>` 元素的边缘完美对齐。这是因为它们都放置在完全相同的网格线上。不是偶然重合的分离网格线，而是实际的网格线。这意味着，例如，如果将
    `<body>` 元素的列模板更改为添加几列，或者调整某些列的宽度变窄或变宽，我们只需编辑 `<body>` 的 `grid-template-columns`
    值，那些使用这些列线的所有内容都将随着线移动。
- en: 'We can do similar things with the footer. Take this CSS, for example:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 footer 做类似的事情。例如，看看这个 CSS：
- en: '[PRE98]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Now the logo in the footer is placed right alongside the fifth column line,
    the `<nav>` starts from the column line at the center of the layout and spans
    over a few tracks, and the `<div>` containing the legal bits ends at the very
    last column line and spans back two tracks. [Figure 12-57](#subgrid_footer) shows
    the result.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 现在页脚中的徽标被放置在第五列线旁边，`<nav>` 从布局中心的列线开始，并跨越几个轨道，包含法律内容的 `<div>` 则结束于最后一列线，并跨越两个轨道。[图 12-57](#subgrid_footer)
    显示了结果。
- en: '![css5 1257](assets/css5_1257.png)'
  id: totrans-533
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1257](assets/css5_1257.png)'
- en: Figure 12-57\. Placing the `<footer>`’s pieces on the `<body>`’s columns
  id: totrans-534
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-57\. 将 `<footer>` 的部分放置在 `<body>` 的列上
- en: Looking at it, maybe we’d prefer the legal stuff to be underneath the navlinks.
    The usual solution in cases like this is to wrap the navlinks and legalese into
    a container such as a `<div>`, and then place that container on the grid columns.
    But thanks to how `subgrid` works, this isn’t at all necessary!
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，也许我们希望法律条款放在导航链接下面。在这种情况下通常的解决方案是将导航链接和法律条文包装到 `<div>` 等容器中，然后将该容器放置在网格列上。但由于
    `subgrid` 的工作方式，这一点并不必要！
- en: Defining Explicit Tracks
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义显式轨道
- en: 'A more grid-like solution to the problem of placing footer pieces below others
    is to put them on their own rows. So let’s do that:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 放置页脚部分在其他内容下方的更类似于网格的解决方案是将它们放在自己的行上。所以让我们这样做：
- en: '[PRE99]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: This code has only three new things as compared to the last time we looked at
    it. First, the `<footer>` itself is given a `grid-template-rows` value. Second,
    the logo image is set to span the two rows defined in the first rule. Third, the
    `grid-column` value of the `<div>` is changed so it spans the same column tracks
    the `<nav>` does. It’s just expressed differently. The `<div>` is also set to
    an explicit grid row.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 与上次查看相比，此代码只有三个新内容。首先，`<footer>` 本身被赋予了 `grid-template-rows` 值。其次，徽标图像设置为跨越第一条规则定义的两行。第三，`<div>`
    的 `grid-column` 值被更改，使其跨越与 `<nav>` 相同的列轨道。只是表达方式不同。`<div>` 也被设置为显式网格行。
- en: So while the `<footer>` continues to subgrid the column template of the `body`
    element, it also defines its own private row template. Just two rows, in this
    case, but that’s all we need. [Figure 12-58](#subgrid_footer_own_rows) shows the
    result, with a dashed line added to show the boundary between the `<footer>`’s
    two rows.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然 `<footer>` 继续对 `body` 元素的列模板进行子网格化，但它也定义了自己的私有行模板。在这种情况下只有两行，但这已经足够了。[图 12-58](#subgrid_footer_own_rows)
    显示了结果，并添加了虚线以显示 `<footer>` 的两行之间的边界。
- en: '![css5 1258](assets/css5_1258.png)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1258](assets/css5_1258.png)'
- en: Figure 12-58\. Placing the `<footer>`’s pieces on the `<body>`’s columns
  id: totrans-542
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-58\. 将 `<footer>` 的部分放置在 `<body>` 的列上
- en: Dealing with Offsets
  id: totrans-543
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理偏移
- en: 'Let’s turn to the `<main>` element in this document, which contains this basic
    markup:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看文档中的 `<main>` 元素，它包含了这个基本的标记：
- en: '[PRE100]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'As you saw previously, the `<main>` element is placed on the `<body>`’s grid
    as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前看到的，`<main>` 元素如下放置在 `<body>` 的网格上：
- en: '[PRE101]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This causes it to stretch from the `<body>`’s second grid column line to the
    second-to-last grid column line. This pushes its sides inward by one column on
    either side.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致它从 `<body>` 的第二列网格线延伸到倒数第二列网格线。这将使其两侧向内推进一列。
- en: The contents within the `<main>` element are not participating in the `<body>`
    grid, because `<main>` isn’t a subgrid. Well, not yet. Let’s fix that by changing
    the rule to the following, with the result shown in [Figure 12-59](#subgrid_main_placement).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`<main>` 元素内的内容不参与 `<body>` 的网格，因为 `<main>` 不是子网格。好吧，还不是。让我们通过将规则更改为以下内容来解决这个问题，并且结果如
    [图 12-59](#subgrid_main_placement) 所示。'
- en: '![css5 1259](assets/css5_1259.png)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1259](assets/css5_1259.png)'
- en: Figure 12-59\. Placing the `<main>` element’s children on the `<body>`’s grid
  id: totrans-551
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-59\. 将 `<main>` 元素的子项放置在 `<body>` 的网格上
- en: Again, this element is a subgrid of the body’s subgrid, but this time it isn’t
    stretched from one edge of the grid to the other. The gallery `<div>` is taking
    up only one column, because it’s a grid item that hasn’t been assigned any grid
    column values.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个元素是 body 的子网格，但这次它没有从网格的一边拉伸到另一边。画廊 `<div>` 只占据了一列，因为它是一个没有分配任何网格列值的网格项。
- en: 'So here’s the question: what if we want move it one column track away from
    the edge of the `<main>` element? That’s the third column line of the `<body>`,
    but the second inside the `<main>` element’s container. Should it be `grid-column:
    3` or `grid-column: 2`?'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '所以问题是：如果我们想把它移动到离 `<main>` 元素边缘一列的地方，怎么办？那就是 `<body>` 的第三列线，但在 `<main>` 元素的容器内部是第二个。应该是
    `grid-column: 3` 还是 `grid-column: 2`？'
- en: 'The answer is `2`. When counting grid lines within a subgrid, you account for
    only those grid lines inside it. Thus, the following would have the result shown
    in [Figure 12-60](#subgrid_main_column_count):'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 `2`。在计算子网格内的网格线时，只计算其中的网格线。因此，以下将显示 [图 12-60](#subgrid_main_column_count)
    中的结果：
- en: '[PRE102]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Now the gallery fills all but the start and end columns within the `<main>`’s
    container, by starting at the second grid line within the `<main>` and ending
    at the second-to-last grid line. If we were to change the value to `3 / -3`, the
    gallery would stretch from the third column line with the `<main>` to the third-last,
    thus leaving two empty columns to either side. But let’s not do that.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，该图库填充了除 `<main>` 容器的起始列和结束列之外的所有列，从 `<main>` 的第二个网格线开始，到倒数第二个网格线结束。如果我们将值更改为
    `3 / -3`，则图库将从 `<main>` 的第三列线延伸到倒数第三列线，因此在两侧留下两个空列。但我们不要这样做。
- en: '![css5 1260](assets/css5_1260.png)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1260](assets/css5_1260.png)'
- en: Figure 12-60\. Placing the gallery inward by a column on each side, and spanning
    several columns
  id: totrans-558
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-60\. 在每侧向内移动图库，并跨越多列
- en: Instead, let’s now suppose we add five more cards to the gallery, for a total
    of six, and we’ll add some filler text rather than have each one just titled “Title” and
    so on. If we do that and don’t change any of the CSS, we’ll just have six `<div>`s
    stacked on top of each other, because while the gallery is stretched across the
    `<main>`’s subgrid, it isn’t a subgrid (or even a not-subgrid), so its interior
    is a normal-flow environment.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，现在假设我们向图库添加五张额外的卡片，总共六张，并添加一些填充文本，而不是每张都只有标题“标题”等。如果我们这样做并且不更改任何 CSS，我们将只是有六个
    `<div>` 叠在彼此上，因为虽然图库跨越了 `<main>` 的子网格，但它不是子网格（甚至不是非子网格），因此其内部是正常流环境。
- en: We can fix that with—yes—more subgridding!
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过——是的——更多的子网格化来解决这个问题！
- en: '[PRE103]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now the gallery is a subgrid of its nearest ancestor element that defines a
    not-subgridded column template, which is the `<body>` element, and thus the cards
    within the gallery will use the column template of the `<body>`. We want them
    to fill out the gallery, which has 12 tracks within it, so we’ll have them each
    span 2 tracks, with the results shown in [Figure 12-61](#subgrid_gallery_cards):'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，该图库是其最近的祖先元素的子网格，该元素定义了非子网格化列模板，即 `<body>` 元素，因此图库内的卡片将使用 `<body>` 的列模板。我们希望它们填满包含
    12 个轨道的图库，因此我们将使它们每个都跨越 2 个轨道，结果显示在 [图 12-61](#subgrid_gallery_cards) 中：
- en: '[PRE104]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '![css5 1261](assets/css5_1261.png)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1261](assets/css5_1261.png)'
- en: Figure 12-61\. Adding multiple cards to the subgridded gallery
  id: totrans-565
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-61\. 向子网格化的图库添加多张卡片
- en: 'Not bad, but it could be better. That last card has a longer title, and it’s
    wrapped to two lines. That means all the descriptive text paragraphs don’t line
    up with one another. How do we fix that? The same way we did for the footer: by
    defining a row template for the gallery, and making the cards subgrid to that
    row template!'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 不错，但还有改进的空间。最后一张卡片的标题较长，跨两行显示。这意味着所有描述性文本段落的对齐不一致。我们如何解决这个问题呢？与页脚一样：通过为图库定义行模板，并使卡片子网格化到该行模板！
- en: 'We start by defining the row template with some named lines and track sizes:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过定义一些命名行和轨道大小来定义行模板：
- en: '[PRE105]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, each card needs to span the row template so that the row lines will be
    available to it:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每张卡片都需要跨越行模板，以便行线对其可用：
- en: '[PRE106]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now that the cards span from the gallery’s first row line to its last, we’re
    ready to have the cards become grid containers with a single column and a subgrid
    of the gallery’s row template:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，卡片从图库的第一行线延伸到最后一行，我们准备将卡片变成具有单列和图库行模板子网格的网格容器：
- en: '[PRE107]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We didn’t really need to add the `grid-template-columns` declaration, because
    it would default to a single column, but sometimes it’s nice to explicitly say
    what it is you want to happen, so anyone responsible for the CSS after you write
    it (including you in six months) doesn’t have to guess at what you meant to do.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们其实并不需要添加 `grid-template-columns` 声明，因为它默认为单列，但有时明确说明你想要发生的事情是很好的，这样在你之后负责
    CSS 的人（包括六个月后的你）就不必猜测你打算做什么。
- en: 'At the moment, the elements inside each card will automatically fall into the
    row tracks: the images into the `pic` track, the titles into the `title` track,
    and the paragraphs into the `desc` track. But since we’re trying to be self-documenting,
    let’s explicitly assign each element to its named track, and while we’re at it,
    vertically align the titles:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，每个卡片内部的元素将自动落入行轨道：图像落入`pic`轨道，标题落入`title`轨道，段落落入`desc`轨道。但由于我们正在尝试自文档化，让我们明确地将每个元素分配给其命名轨道，并顺便垂直对齐标题。
- en: '[PRE108]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[Figure 12-62](#subgrid_gallery_card_rows) shows the final result, with the
    titles vertically centered with respect to one another, the descriptive paragraphs
    all lined up along their top edges, and all the cards sharing the same height.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12-62](#subgrid_gallery_card_rows)显示了最终结果，标题在垂直方向上相对于彼此居中，描述段落都沿其顶边对齐，并且所有卡片都具有相同的高度。'
- en: A big advantage here is that with the pieces of the cards explicitly assigned
    to the named grid row lines, rearranging the cards is now merely a question of
    editing the `grid-row-template` value set on the gallery.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要优势是，通过明确地将卡片的部件分配给命名网格行线，现在重新排列卡片只是编辑设置在图库上的`grid-row-template`值的问题。
- en: '![css5 1262](assets/css5_1262.png)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1262](assets/css5_1262.png)'
- en: Figure 12-62\. Placing card items on subgridded rows
  id: totrans-579
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-62\. 将卡片项放置在子网格行上
- en: We could also have made the cards’ column template a subgrid, which would have
    meant they’d use the `<body>` element’s column template, because the body is the
    nearest ancestor element with a column template that isn’t a subgrid. In that
    case, the cards would use the gallery’s row template and the body’s column template.
    And they’d all influence the sizing of those ancestors’ grid tracks, and thus
    influence the layout of everything else that uses those same templates.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将卡片的列模板设置为子网格，这意味着它们将使用`<body>`元素的列模板，因为`body`是最近的祖先元素，其列模板不是子网格。在这种情况下，卡片将使用图库的行模板和`body`的列模板。它们将影响那些祖先网格轨道的尺寸，并因此影响使用相同模板的其他所有内容的布局。
- en: 'If you have more cards than will fit into a single row, you’ll run into a problem:
    subgrids do *not* create implicit grid tracks. Instead, you need to use the auto-track
    properties like `grid-auto-rows`, which will add as many rows as needed.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的卡片超过了可以容纳的单行，则会遇到问题：子网格不会创建隐式网格轨道。相反，您需要使用`grid-auto-rows`等自动跟踪属性，这将添加所需的行数。
- en: 'Thus, we’ll need to remove the line names and rework the CSS we’ve built to
    read as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要删除线名，并重新构建我们已经建立的CSS，如下所示：
- en: '[PRE109]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The problem now is that we have the picture, title, and description text each
    assigned to a named grid line, but `grid-auto-rows` doesn’t allow line names.
    It might look like we have to change the grid row assignments, but that’s not
    the case, as you’re about to see.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题是，图片、标题和描述文本各自分配到一个命名网格线，但`grid-auto-rows`不允许线名。看起来我们需要更改网格行分配，但事实并非如此，接下来您将看到。
- en: Naming Subgridded Lines
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名子网格行
- en: In addition to using the names of any grid lines in the ancestor template, you
    can assign names to the subgrid, which is a real help if you’re using auto-tracks
    like those created in the previous section.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在祖先模板中使用任何网格行的名称外，还可以为子网格分配名称，如果您使用了前一节中创建的自动跟踪，则这真的很有帮助。
- en: 'In this case, since we used to have row lines named `pic`, `title`, and `desc`
    in the parent grid but had to remove them in order to set up auto-rows, we take
    those same labels and put them after the `subgrid` keyword for `grid-template-rows`:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，因为我们曾在父网格中使用`pic`、`title`和`desc`作为行线名称，但必须删除它们以设置自动行，现在我们将这些相同的标签放在`grid-template-rows`的`subgrid`关键字之后：
- en: '[PRE110]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here’s what that looks like in context with the rest of the CSS for these cards,
    which are laid out as shown in [Figure 12-63](#gallery-cards-rows-repeat):'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这些卡片的其余CSS的上下文示例，其布局如[图 12-63](#gallery-cards-rows-repeat)所示：
- en: '[PRE111]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '![css5 1263](assets/css5_1263.png)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1263](assets/css5_1263.png)'
- en: Figure 12-63\. Placing cards onto auto-rows with named lines
  id: totrans-592
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-63\. 将卡片放置到具有命名行的自动行上
- en: 'It’s also possible to assign names to just a few lines while not naming the
    rest. To see this in action, let’s add a couple of paragraphs of text below the
    gallery, something like this (with ellipsis-enclosed text in place of the actual
    content):'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以仅对几行分配名称，而不对其余行进行命名。为了看到它的作用，让我们在图库下方添加几段文本，类似于以下内容（省略号包围的文本替代了实际内容）：
- en: '[PRE112]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'To span the paragraphs across various column tracks, we could count and use
    numbers, but let’s name some lines and use those instead. In this case, since
    these paragraphs are children of the `<main>` element, we’ll need to modify its
    subgridded column template. Here’s how we’ll do it:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要跨越各种列轨道来扩展段落，我们可以计算并使用数字，但让我们命名一些行并使用它们代替。在这种情况下，由于这些段落是`<main>`元素的子元素，我们需要修改其子网格列模板。这是我们将要做的：
- en: '[PRE113]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: OK, whoa. What just happened?
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，哇。刚刚发生了什么？
- en: 'Here’s how it breaks down: after the `subgrid` keyword, we have a bunch of
    name assignments. The first is just `[]`, which means “don’t add a name to this
    grid line.” Then we have `[leadin-start]`, which assigns the name `leadin-start`
    to the second grid column line in the subgrid. After that is a repetition that
    means the next five grid column lines get no subgrid name assigned.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它的详细过程：在`subgrid`关键字之后，我们有一堆名称分配。首先是`[]`，这意味着“不要向此网格线添加名称”。然后是`[leadin-start]`，它将名称`leadin-start`分配给子网格的第二个网格列线。之后是一次重复，表示接下来的五个网格列线没有子网格名称分配。
- en: Next up is what happens to be the line running down the middle of the grid,
    which is given both the name `leadin-end` and `explore-start`. This means the
    lead-in paragraph should stop spanning at this line, and the explore paragraph
    should start spanning at the same line. After another five no-name-assigned lines,
    we assign `explore-end` to a line, and that’s it. Any lines that weren’t addressed
    will be left alone.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是在网格中间运行的线，它被赋予了`leadin-end`和`explore-start`的名称。这意味着引导段落应该在这条线停止跨越，并且探索段落应该从同一条线开始跨越。再经过另外五条未命名的线后，我们将`explore-end`分配给一条线，就这样。任何未被解决的线都将被保留。
- en: 'Now all we have to do is set the paragraphs’ start and end column lines like
    so, and get the result shown in [Figure 12-64](#subgrid_main_named_lines), where
    the two cards on the second line of cards have been removed for clarity:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所要做的就是设置段落的起始和结束列线，如此一来，我们得到的结果将显示在[图 12-64](#subgrid_main_named_lines)中，其中第二行卡片上的两张卡片已经被移除以便清晰地展示：
- en: '[PRE114]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '![css5 1264](assets/css5_1264.png)'
  id: totrans-602
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1264](assets/css5_1264.png)'
- en: Figure 12-64\. Placing elements using subgrid-named grid lines
  id: totrans-603
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-64\. 使用子网格命名网格线放置元素
- en: And there they are, using their custom-named start and end grid lines to span
    across many grid tracks. As promised, the first ends where the second starts,
    right on that grid line that happens to be in the middle of the layout.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它们就在那里了，使用它们自定义命名的起始和结束网格线跨越多个网格轨道。正如承诺的那样，第一个在第二个开始的地方结束，正好在布局中间的那条网格线上。
- en: Having the cards jam right up next to each other doesn’t look great, though.
    We could push the actual text apart by using padding on the paragraphs, but some
    gaps would be nice, wouldn’t they?
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 将卡片紧紧靠在一起看起来不太好，尽管如此。我们可以在段落上使用填充将实际文本分开，但某些间隙会更好，不是吗？
- en: Giving Subgrids Their Own Gaps
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给子网格设置它们自己的间隙
- en: 'It’s possible to set gaps on subgrids that are separate from any gaps on their
    ancestor grids. Thus, for example, we could extend our previous example like this:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在子网格上设置与其祖先网格上的任何间隙分开的间隙。因此，例如，我们可以像这样扩展我们之前的示例：
- en: '[PRE115]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: With this change, the `<main>` element is setting no row gaps but 2-em column
    gaps. This has the result shown in [Figure 12-65](#subgrid_grid_gaps).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个变化，`<main>`元素设置了没有行间隙但有2em列间隙。这就是在[图 12-65](#subgrid_grid_gaps)中显示的结果。
- en: '![css5 1265](assets/css5_1265.png)'
  id: totrans-610
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1265](assets/css5_1265.png)'
- en: Figure 12-65\. The effect of adding gaps to a subgrid
  id: totrans-611
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-65\. 向子网格添加间隙的效果
- en: Notice that not only are the two paragraphs pushed apart, but so are the cards
    in the gallery. That’s because they’re all participating in the same subgrid,
    and that subgrid just had some gaps added to it. This means the sides of the cards
    and the side of the paragraphs are still lined up precisely with each other, which
    is pretty nice.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不仅两个段落被分开，画廊中的卡片也是如此。这是因为它们都参与同一个子网格，并且该子网格刚刚添加了一些间隙。这意味着卡片的边缘和段落的边缘仍然精确地对齐，这非常好。
- en: 'Note also that these gaps don’t apply to the content in ancestor grids: the
    boxes in the header and footer still come right up to the center column line.
    It’s only the elements in the `<main>` element’s subgrid, and any subgrids of
    that subgrid, that will know about and make use of these gaps.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这些间隙不适用于祖先网格中的内容：页眉和页脚中的框框仍然直接到达中心列线。只有`<main>`元素的子网格以及该子网格的任何子网格会知道并利用这些间隙。
- en: Note
  id: totrans-614
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If gaps aren’t familiar to you, the properties `row-gap`, `column-gap`, and
    `gap` are covered in [Chapter 11](ch11.html#flexbox).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对间隙不熟悉，那么`row-gap`、`column-gap`和`gap`的属性在[第11章](ch11.html#flexbox)有详细介绍。
- en: Grid Items and the Box Model
  id: totrans-616
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网格项目和盒子模型
- en: Now we can create a grid, attach items to the grid, create gutters between the
    grid tracks, and even use the track templates of ancestor elements. But what happens
    if we style a grid item with, say, margins? Or if it’s absolutely positioned?
    How do these things interact with the grid lines?
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个网格，将项目附加到网格上，创建网格跟踪之间的间隙，甚至使用祖先元素的跟踪模板。但是，如果我们用边距样式化网格项目，或者如果它被绝对定位了，会发生什么？这些情况如何与网格线互动？
- en: 'Let’s take margins first. The basic principle at work is that an element is
    attached to the grid by its margin edges. That means you can push the visible
    parts of the element inward from the grid area it occupies by setting positive
    margins—and pull it outward with negative margins. For example, these styles will
    have the result shown in [Figure 12-66](#grid_items_with_margins):'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下边距。工作的基本原则是元素通过其边距边缘连接到网格。这意味着您可以通过设置正边距将元素的可见部分从其占据的网格区域向内推移，并通过负边距向外拉。例如，这些样式将产生[图12-66](#grid_items_with_margins)中显示的结果：
- en: '[PRE116]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '![css5 1266](assets/css5_1266.png)'
  id: totrans-620
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1266](assets/css5_1266.png)'
- en: Figure 12-66\. Grid items with margins
  id: totrans-621
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图12-66\. 带有边距的网格项目
- en: 'This works as it does because the items have both their `width` and `height`
    set to `auto`, so they can be stretched as needed to make everything work out.
    If `width` and/or `height` have non-`auto` values, they’ll end up overriding margins
    to make all the math work out. This is much like what happens with inline margins
    when element sizing is overconstrained: eventually, one of the margins gets overridden.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是项目的`width`和`height`都设置为`auto`，因此它们可以根据需要拉伸以使所有计算正确。如果`width`和/或`height`有非`auto`的值，它们将覆盖边距以使所有数学计算正确。这很像内联边距在元素大小超出约束时发生的情况：最终，其中一个边距会被覆盖。
- en: 'Consider an element with the following styles placed into a 200-pixel-wide
    by 100-pixel-tall grid area:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有以下样式的元素放置在一个200像素宽、100像素高的网格区域内：
- en: '[PRE117]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Going across the element first, it has 10 pixels of margin to either side, and
    its `width` is `150px`, giving a total of 170 pixels. Something’s gotta give,
    and in this case it’s the right margin (in LTR languages), which is changed to
    `40px` to make everything work—10 pixels on the left margin, 150 pixels on the
    content box, and 40 pixels on the right margin equals the 200 pixels of the grid
    area’s width.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 首先沿着元素走，它的两侧有10像素的边距，其`width`为`150px`，总共是170像素。总得有个妥协，这种情况下是右边距（在从左到右的语言中），它被更改为`40px`以使一切正常——左边距为10像素，内容框为150像素，右边距为40像素，总宽度为网格区域的200像素。
- en: On the vertical axis, the bottom margin is reset to `-10px`. This compensates
    for the top margin and content height totaling 110 pixels, when the grid area
    is only 100 pixels tall.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在垂直轴上，将底边距重置为`-10px`。这样做是为了抵消顶部边距和内容高度总计110像素，而网格区域只有100像素高。
- en: Note
  id: totrans-627
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Margins on grid items are ignored when calculating grid-track sizes. Therefore,
    no matter how big or small you make a grid item’s margins, it won’t change the
    sizing of a `min-content` column, for example, nor will increasing the margins
    on a grid item cause `fr`-sized grid tracks to change size.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算网格跟踪大小时，将忽略网格项目上的边距。因此，无论您将网格项目的边距设置多大或多小，都不会更改`min-content`列的大小，例如，增加网格项目的边距也不会导致`fr`大小的网格跟踪大小发生变化。
- en: 'As with block layout, you can selectively use `auto` margins to decide which
    margin will have its value changed to fit. Suppose we wanted the grid item to
    align to the right of its grid area. By setting the item’s left margin to `auto`,
    that would happen:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 与块布局一样，您可以选择使用`auto`边距来决定哪个边距将其值更改以适应。假设我们希望网格项目与其网格区域右对齐。通过将项目的左边距设置为`auto`，可以实现这一点：
- en: '[PRE118]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Now the element will add up 160 pixels for the right margin and content box,
    and then give the difference between that and the grid area’s width to the left
    margin, since it’s been explicitly set to `auto`. This results in [Figure 12-67](#using_auto_margins_to_align_items),
    with 10 pixels of margin on each side of the `exel` item, except the left margin,
    which is (as we just calculated) 40 pixels.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 现在元素将为右边距和内容框累加160像素，然后将这个值与网格区域宽度之差给左边距，因为它已经明确设置为`auto`。这导致[图12-67](#using_auto_margins_to_align_items)的结果，`exel`项目的每侧有10像素的边距，除了我们刚刚计算的左边距40像素。
- en: '![image](assets/css5_1267.png)'
  id: totrans-632
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1267.png)'
- en: Figure 12-67\. Using auto margins to align items
  id: totrans-633
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-67\. 使用自动边距对齐项目
- en: 'That alignment process might seem familiar from block-level layout, where you
    can use `auto` inline margins to center an element in its containing block, as
    long as you’ve given it an explicit `width`. Grid layout differs in that you can
    do the same thing on the vertical axis; that is, given an element with an absolute
    height, you can vertically center it by setting the top and bottom margins to
    `auto`. [Figure 12-68](#various_auto-margin_alignments) shows a variety of `auto`
    margin effects on images, which inherently have explicit heights and widths:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对齐过程可能在块级布局中看起来很熟悉，其中可以使用`auto`内联边距将元素居中放置在其包含块中，只要给定了显式的`width`。网格布局不同之处在于你可以在垂直轴上做同样的事情；也就是说，给定具有绝对高度的元素，你可以通过将顶部和底部边距设置为`auto`来垂直居中它。[图 12-68](#various_auto-margin_alignments)展示了对图片应用`auto`边距的各种效果，这些图片本身具有显式的高度和宽度：
- en: '[PRE119]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '![image](assets/css5_1268.png)'
  id: totrans-636
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1268.png)'
- en: Figure 12-68\. Various auto-margin alignments
  id: totrans-637
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-68\. 各种自动边距对齐方式
- en: Tip
  id: totrans-638
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: CSS has other ways to align grid items, notably with properties like `justify-self`,
    which don’t depend on having explicit element sizes or auto margins. These are
    covered in the next section.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 还有其他方法来对齐网格项，特别是使用诸如`justify-self`之类的属性，这些属性不依赖于具有显式元素大小或自动边距。这些内容将在下一节介绍。
- en: 'This auto-margin behavior is a lot like the way margins and element sizes operate
    when elements are absolutely positioned—which leads us to the next question: what
    if a grid item is *also* absolutely positioned? For example:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动边距行为与元素绝对定位时边距和元素大小操作的方式非常相似，这就引出了下一个问题：如果网格项*也*是绝对定位怎么办？例如：
- en: '[PRE120]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The answer is actually pretty elegant: if you’ve defined grid-line starts and
    ends *and* the grid container establishes a positioning content (e.g., using `position:
    relative`), that grid area is used as the containing block and positioning context
    for the grid, and so the grid item is positioned *within* that context. That means
    the offset properties (`top` et al.) are calculated in relation to the declared
    grid area. Thus, the previous CSS would have the result shown in [Figure 12-69](#absolutely_positioning_a_grid_item),
    with the lightly shaded area denoting grid area used as the positioning context,
    and the thick-bordered box denoting the absolutely positioned grid item.'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '答案实际上非常优雅：如果你已定义了网格线的起始和结束*并且*网格容器建立了定位内容（例如使用`position: relative`），那么该网格区域将被用作包含块和网格的定位上下文，因此网格项被定位*在*该上下文中。这意味着偏移属性（如`top`等）是相对于声明的网格区域计算的。因此，前面的CSS将会有结果显示在[图 12-69](#absolutely_positioning_a_grid_item)，浅色阴影区域表示用作定位上下文的网格区域，而粗边框框表示绝对定位的网格项。'
- en: '![css5 1269](assets/css5_1269.png)'
  id: totrans-643
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1269](assets/css5_1269.png)'
- en: Figure 12-69\. Absolutely positioning a grid item
  id: totrans-644
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-69\. 绝对定位网格项
- en: 'Everything you know about absolutely positioned elements regarding offsets,
    margins, element sizing, and so on applies within this formatting context. It’s
    just that in this case, the formatting context is defined by a grid area. Absolute
    positioning introduces a wrinkle: it changes the behavior of the `auto` value
    for grid-line properties. If, for example, you set `grid-column-end: auto` for
    an absolutely positioned grid item, the ending grid line will actually create
    a new and special grid line that corresponds to the padding edge of the grid container
    itself. This is true even if the explicit grid is smaller than the grid container,
    as can happen. To see this in action, we’ll modify the previous example as follows,
    with the result shown in [Figure 12-70](#auto_values_and_absolute_positioning):'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种格式化上下文中，关于偏移、边距、元素大小等所有关于绝对定位元素的知识都适用。只是在这种情况下，格式化上下文由网格区域定义。绝对定位引入了一个变化：它改变了网格线属性中`auto`值的行为。例如，如果你为一个绝对定位的网格项设置了`grid-column-end:
    auto`，那么结束网格线实际上会创建一个新的特殊网格线，该网格线对应于网格容器本身的填充边缘。即使显式网格小于网格容器，也会发生这种情况。为了看到这一过程，我们将修改前面的例子如下，结果显示在[图 12-70](#auto_values_and_absolute_positioning)中：'
- en: '[PRE121]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '![css5 1270](assets/css5_1270.png)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1270](assets/css5_1270.png)'
- en: Figure 12-70\. Auto values and absolute positioning
  id: totrans-648
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-70\. 自动值和绝对定位
- en: Notice how the positioning context now starts at the top of the grid container
    (the thin black line around the outside of the figure), and stretches all the
    way to the right edge of the grid container, even though the grid itself ends
    short of that edge.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，定位上下文现在从网格容器的顶部开始（围绕图表外部的细黑线），并且延伸到网格容器的右边缘，尽管网格本身未延伸到该边缘。
- en: 'One implication of this behavior is that if you absolutely position an element
    that’s a grid item, but you don’t give it any grid-line start or end values, then
    it will use the inner padding edge of the grid container as its positioning context.
    It does this without having to set the grid container to `position: relative`,
    or any of the other usual tricks to establish a positioning context.'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '这种行为的一个影响是，如果你绝对定位一个作为网格项的元素，但不给它任何网格线的起始或结束值，那么它将使用网格容器的内部填充边缘作为其定位上下文。它可以在不必设置网格容器为
    `position: relative` 或其他通常用于建立定位上下文的技巧的情况下完成这一点。'
- en: Also note that absolutely positioned grid items do *not* participate in figuring
    out grid cell and track sizing. As far as the grid layout is concerned, the positioned
    grid item doesn’t exist. Once the grid is set up, the grid item is positioned
    with respect to the grid lines that define its positioning context.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，绝对定位的网格项 *不会* 参与计算网格单元和跟踪大小。就网格布局而言，定位的网格项不存在。一旦设置了网格，网格项就相对于定义其定位上下文的网格线进行定位。
- en: Setting Alignment in Grids
  id: totrans-652
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置网格中的对齐
- en: If you have any familiarity with flexbox (see [Chapter 11](ch11.html#flexbox)),
    you’re probably aware of the various alignment properties and their values. Those
    same properties are also available in grid layout and have very similar effects.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 flexbox 有所了解（参见[第 11 章](ch11.html#flexbox)），你可能已经了解各种对齐属性及其值。这些相同的属性也适用于网格布局，并且具有非常相似的效果。
- en: First, a quick refresher. [Table 12-1](#grid_layout_properties) summarizes the
    alignment properties that are available and what they affect. Note there are a
    few more than you might have expected from flexbox.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，快速回顾。[表格 12-1](#grid_layout_properties) 总结了可用的对齐属性及其影响范围。请注意，这些属性的数量可能比 flexbox
    中的预期更多。
- en: Table 12-1\. Justify and align values
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 12-1\. 对齐和对齐值
- en: '| Property | Aligns | Applies to |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 对齐 | 适用于 |'
- en: '| --- | --- | --- |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `align-content` | The entire grid in the block direction | Grid container
    |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| `align-content` | 整个网格在块方向上 | 网格容器 |'
- en: '| `align-items` | All grid items in the block direction | Grid container |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| `align-items` | 所有网格项在块方向上 | 网格容器 |'
- en: '| `align-self` | A grid item in the block direction | Grid items |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| `align-self` | 网格项在块方向上 | 网格项 |'
- en: '| `justify-content` | The entire grid in the inline direction | Grid container
    |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| `justify-content` | 整个网格在内联方向上 | 网格容器 |'
- en: '| `justify-items` | All grid items in the inline direction | Grid container
    |'
  id: totrans-662
  prefs: []
  type: TYPE_TB
  zh: '| `justify-items` | 所有网格项在内联方向上 | 网格容器 |'
- en: '| `justify-self` | A grid item in the inline direction | Grid items |'
  id: totrans-663
  prefs: []
  type: TYPE_TB
  zh: '| `justify-self` | 网格项在内联方向上 | 网格项 |'
- en: '| `place-content` | The entire grid in both the block and inline directions
    | Grid container |'
  id: totrans-664
  prefs: []
  type: TYPE_TB
  zh: '| `place-content` | 整个网格在块和内联方向上 | 网格容器 |'
- en: '| `place-items` | All grid items in both the block and inline directions |
    Grid container |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| `place-items` | 所有网格项在块和内联方向上 | 网格容器 |'
- en: '| `place-self` | A grid item in both the block and inline directions | Grid
    items |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| `place-self` | 网格项在块和内联方向上 | 网格项 |'
- en: As [Table 12-1](#grid_layout_properties) shows, the various `justify-*` properties
    change alignment along the inline axis—in English, this will be the horizontal
    direction. The difference is whether a property applies to a single grid item,
    all the grid items in a grid, or the entire grid. Similarly, the `align-*` properties
    affect alignment along the block axis; in English, this is the vertical direction.
    The `place-*` properties, on the other hand, are shorthands that apply in both
    the block and inline directions.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[表格 12-1](#grid_layout_properties) 所示，各种 `justify-*` 属性改变了内联轴上的对齐方式——用英语描述，这是水平方向。区别在于属性是应用于单个网格项、整个网格中的所有网格项，还是整个网格。类似地，`align-*`
    属性影响块轴上的对齐——用英语描述，这是垂直方向。另一方面，`place-*` 属性是两个方向上都适用的简写。
- en: Aligning and Justifying Individual Items
  id: totrans-668
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐和对齐单个项
- en: It’s easiest to start with the `*-self` properties, because we can have one
    grid show various `justify-self` property values, while a second grid shows the
    effects of those same values when used by `align-self`. (See [Figure 12-71](#self_alignment_in_the_inline_and_block_directions).)
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易从 `*-self` 属性开始，因为我们可以在一个网格中展示各种 `justify-self` 属性值，而第二个网格展示这些值在 `align-self`
    中使用时的效果（参见[图 12-71](#self_alignment_in_the_inline_and_block_directions)）。
- en: '![image](assets/css5_1271.png)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
  zh: '![image](assets/css5_1271.png)'
- en: Figure 12-71\. Self-alignment in the inline and block directions
  id: totrans-671
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 12-71\. 行内和块方向的自对齐
- en: Each grid item in [Figure 12-71](#self_alignment_in_the_inline_and_block_directions)
    is shown with its grid area (the dashed line) and a label identifying the property
    value that’s applied to it. Each deserves a bit of commentary.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 每个网格项目在[图 12-71](#self_alignment_in_the_inline_and_block_directions)中显示其网格区域（虚线）和标签，标识应用于它的属性值。每个都值得一点评论。
- en: First, though, realize that for all of these values, any element that doesn’t
    have an explicit `width` or `height` will “shrink-wrap” its content, instead of
    using the default grid-item behavior of filling out the entire grid area.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要意识到，对于所有这些值，任何没有显式 `width` 或 `height` 的元素都将“收缩包裹”其内容，而不是使用默认的网格项行为填充整个网格区域。
- en: The `start` and `end` values cause the grid item to be aligned to the start
    or end edge of its grid area, which makes sense. Similarly, `center` centers the
    grid item within its area along the alignment axis, *without* the need to declare
    margins or any other properties, including `height` and `width`.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '`start` 和 `end` 值使网格项与其网格区域的开始或结束边对齐，这是有道理的。类似地，`center` 将网格项沿对齐轴在其区域内居中，*无需*声明边距或任何其他属性，包括
    `height` 和 `width`。'
- en: 'The `left` and `right` values cause the item to be aligned to the left or right
    edge of the grid area when the inline axis is horizontal, as shown in [Figure 12-71](#self_alignment_in_the_inline_and_block_directions).
    If the inline axis is vertical, as in `writing-mode: vertical-rl`, items are aligned
    along the inline axis as if the inline axis were still horizontal; thus, in a
    top-to-bottom inline axis, `left` will align to the top of the grid area when
    `direction` is `ltr`, and to its bottom when `direction` is `rtl`. When applied
    to `align-self`, `left` and `right` are treated as if they were `stretch`.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '`left` 和 `right` 值使项目在行内轴水平时对齐到网格区域的左侧或右侧，如[图 12-71](#self_alignment_in_the_inline_and_block_directions)所示。如果行内轴是垂直的，例如
    `writing-mode: vertical-rl`，项目沿行内轴对齐，就像行内轴仍然是水平的一样；因此，在从上到下的行内轴中，当 `direction`
    为 `ltr` 时，`left` 将对齐到网格区域的顶部，并且在 `rtl` 时对齐到底部。当应用于 `align-self` 时，`left` 和 `right`
    被视为 `stretch`。'
- en: 'The `self-start` and `self-end` values are more interesting. The `self-start`
    option aligns a grid item with the grid-area edge that corresponds to the grid
    *item’s* start edge. So in [Figure 12-71](#self_alignment_in_the_inline_and_block_directions),
    the `self-start` and `self-end` boxes are set to `direction: rtl`. That sets them
    to use RTL language direction, meaning their start edges are their right edges,
    and their end edges their left. You can see in the first grid this right-aligned
    `self-start` and left-aligned `self-end`. In the second grid, however, the RTL
    direction is irrelevant to block-axis alignment. Thus, `self-start` is treated
    as `start`, and `self-end` is treated as `end`.'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '`self-start` 和 `self-end` 值更有趣。`self-start` 选项将网格项与对应于其开始边的网格区域边缘对齐。因此，在[图 12-71](#self_alignment_in_the_inline_and_block_directions)中，`self-start`
    和 `self-end` 盒子设置为 `direction: rtl`。这设置它们使用右到左语言方向，意味着它们的起始边是右边缘，结束边是左边缘。您可以在第一个网格中看到这个右对齐的
    `self-start` 和左对齐的 `self-end`。然而，在第二个网格中，RTL 方向对于块轴对齐是无关紧要的。因此，`self-start` 被视为
    `start`，`self-end` 被视为 `end`。'
- en: 'The last value, `stretch`, is also interesting. To understand it, notice how
    the other boxes in each grid “shrink-wrap” themselves to their content, as if
    set to `max-content`. The `stretch` value, by contrast, directs the element to
    stretch from edge to edge in the given direction—`align-self: stretch` causes
    the grid item to stretch along the block axis, and `justify-self: stretch` causes
    inline-axis stretching. This is as you might expect, but bear in mind that it
    works only if the element’s size properties are set to `auto`. Thus, given the
    following styles, the first example will stretch vertically, but the second will
    not:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Because the second example sets a `block-size` value that isn’t `auto` (which
    is the default value), that grid item cannot be resized by `stretch`. The same
    holds true for `justify-self` and `inline-size`.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: 'Two more values that can be used to align grid items are sufficiently interesting
    to merit their own explanation. These permit the alignment of a grid item’s first
    or last baseline with the highest or lowest baseline in the grid track. For example,
    suppose you want a grid item to be aligned so the baseline of its last line is
    aligned with the last baseline in the tallest grid item sharing its row track.
    That would look like the following:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Conversely, to align its first baseline with the lowest first baseline in the
    same row track, you’d say this:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: If a grid element doesn’t have a baseline, or it’s asked to baseline-align itself
    in a direction where baselines can’t be compared, `baseline` is treated as `start`,
    and `last-baseline` is treated as `end`.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-685
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This section intentionally skips two values: `flex-start` and `flex-end`. These
    values are supposed to be used only in flexbox layout, and are defined to be equivalent
    to `start` and `end` in any other layout context, including grid layout.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed explanation of the values just discussed and how they cause
    items to interact, see [Chapter 11](ch11.html#flexbox).
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: The shorthand property `place-self` combines the two self-placement properties
    just discussed.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: 'Supplying one value for `place-self` means it’s copied to the second value
    as well. Thus, in each of the following pairs of declarations, the first declaration
    is equivalent to the second:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Because both of the individual properties `place-self` shorthands can accept
    baseline alignment values, supplying only one value causes both individual properties
    to be set to the same value. In other words, the following are equivalent:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'You can also supply two values, one for each of the individual properties the
    shorthand represents. So the following CSS shows rules that are equivalent to
    each other:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Aligning and Justifying All Items
  id: totrans-695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s consider `align-items` and `justify-items`. These properties accept
    all the same values you saw in the previous section plus a few more, and have
    the same effect, except they apply to all grid items in a given grid container,
    and must be applied to the grid container instead of to individual grid items.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, you could set all of the grid items in a grid to be center-aligned
    within their grid areas as follows, with a result like that depicted in [Figure 12-72](#centering_all_the_grid_items):'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '![image](assets/css5_1272.png)'
  id: totrans-699
  prefs: []
  type: TYPE_IMG
- en: Figure 12-72\. Centering all the grid items
  id: totrans-700
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, that rule horizontally *and* vertically centers every grid item
    within its given grid area. Furthermore, it causes any grid item without an explicit
    width and height to “shrink-wrap” its content rather than stretch out to fill
    its grid area, because of the way `center` is handled. If a grid item has an explicit
    inline or block size, those are honored instead of “shrink-wrapping” the content,
    and the item is still centered within its grid area.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: For an overview of the effects of the various keyword values in the context
    of both `justify-items` and `align-items`, see [Figure 12-73](#grid-alignment-justify-items-both);
    the grid areas are represented with dashed lines, and the grid items are placed
    according to their alignment values.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1273.png)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
- en: Figure 12-73\. The alignment of grid items within their grid cells
  id: totrans-704
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Not illustrated in [Figure 12-73](#grid-alignment-justify-items-both), the `legacy`
    value is a new addition to grid alignment, and is essentially treated as `start`.
    (It exists to re-create the behaviors of HTML’s ancient `<CENTER>` element and
    `align` attribute, neither of which is relevant in a grid context.)
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-706
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For an exploration of what `safe` and `unsafe` mean in terms of items overflowing
    their container, see [Chapter 11](ch11.html#flexbox).
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: The shorthand property `place-items` combines the two item-placement properties
    just discussed.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: 'The way `place-items` works is very similar to the `place-self` property discussed
    previously in the chapter. If one value is given, it’s applied to both `align-items`
    and `justify-items`. If two values are given, the first is applied to `align-items`
    and the second to `justify-items`. Thus, the following rules are equivalent:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Distributing Grid Items and Tracks
  id: totrans-711
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond aligning and justifying every grid item, it’s possible to distribute
    the grid items, or even to justify or align the entire grid, using `align-content`
    and `justify-content`. A small set of distributive values is used for these properties.
    [Figure 12-74](#distributing_grid_items_horizontally) illustrates the effects
    of each value as applied to `justify-content`, with each grid sharing the following
    styles:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '![image](assets/css5_1274.png)'
  id: totrans-714
  prefs: []
  type: TYPE_IMG
- en: Figure 12-74\. Distributing grid items along the inline axis
  id: totrans-715
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In these cases, the set of grid tracks is taken as a single unit, and the items
    are then justified by the value of `justify-content`. That alignment does not
    affect the alignment of individual grid items; thus, you could end-justify the
    whole grid with `justify-content: end` while having individual grid items be left-,
    center-, or start-justified (among other options) within their grid areas.'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: 'This works just as well in column tracks as it does in row tracks, as [Figure 12-75](#distributing_grid_items_vertically)
    illustrates, as long as you switch to `align-content`. This time, the grids all
    share these styles:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '![image](assets/css5_1275.png)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
- en: Figure 12-75\. Distributing grid items along the block axis
  id: totrans-720
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The way these distributions work is that the grid tracks, including any gutters,
    are all sized as usual. Then, if any space is left over beyond the grid tracks
    and gutters—that is, if the grid tracks don’t reach all the way from one edge
    of the grid container to the other—then the remaining space is distributed according
    to the value of `justify-content` (in the inline axis) or `align-content` (in
    the block axis).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
- en: This space distribution is carried out by resizing the grid gutters. If no gutters
    are declared, they will be created. If gutters already exist, their sizes are
    altered as required to distribute the grid tracks as specified.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: Note that because space is distributed only when the tracks don’t fill out the
    grid container, the gutters can only increase in size. If the tracks are larger
    than the container, which can easily happen, there is no leftover space to distribute
    (negative space turns out to be indivisible).
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
- en: 'One more distribution value wasn’t shown in the previous figures: `stretch`.
    This value takes any leftover space and applies it equally to the grid tracks,
    not the gutters. So if we have 400 pixels of leftover space and 8 grid tracks,
    each grid track is increased by 50 pixels. The grid tracks are *not* increased
    proportionally, but equally. As of late 2022, there is no browser support for
    this value in terms of grid distribution.'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: Layering and Ordering
  id: totrans-725
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in a previous section, it’s entirely possible to have grid
    items overlap each other, whether because negative margins are used to pull a
    grid item beyond the edges of its grid area, or because the grid areas of two
    different grid items share grid cells. By default, the grid items will visually
    overlap in document source order: grid items later in the document source will
    appear above (or “in front of”) grid items earlier in the document source. Thus
    the following results in [Figure 12-76](#grid_items_overlapping) (assume the number
    in each class name represents the grid item’s source order):'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '![image](assets/css5_1276.png)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
- en: Figure 12-76\. Grid items overlapping in source order
  id: totrans-729
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to assert your own stacking order, `z-index` is here to help. Just
    as in positioning, `z-index` places elements relative to one another on the z-axis,
    which is perpendicular to the display surface. Positive values are closer to you,
    and negative values further away. So to bring the second box to the “top,” as
    it were, all you need is to give it a `z-index` value higher than any other (with
    the result shown in [Figure 12-77](#elevating_a_grid_item)):'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '![image](assets/css5_1277.png)'
  id: totrans-732
  prefs: []
  type: TYPE_IMG
- en: Figure 12-77\. Elevating a grid item
  id: totrans-733
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another way you can affect the ordering of grid items is by using the `order`
    property. Its effect is essentially the same as it is in flexbox—you can change
    the order of grid items within a grid track by giving them `order` values. This
    affects not only placement within the track, but also *paint order* if they should
    overlap. For example, we could change the previous example from `z-index` to `order`,
    as shown here, and get the same result shown in [Figure 12-77](#elevating_a_grid_item):'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: In this case, `box02` appears “on top of” the other grid items because its order
    places it after the rest of them. Thus, it’s drawn last. Similarly, if those grid
    items were all placed in sequence in a grid track, the `order` value for `box02`
    would put it at the end of the sequence. This is depicted in [Figure 12-78](#changing_grid_item_order).
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1278.png)'
  id: totrans-737
  prefs: []
  type: TYPE_IMG
- en: Figure 12-78\. Changing grid-item order
  id: totrans-738
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember that just because you *can* rearrange the order of grid items this
    way doesn’t necessarily mean you *should*. As the [Grid Layout specification](https://www.w3.org/TR/css-grid-1/#order-property)
    says:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
- en: As with reordering flex items, the `order` property must only be used when the
    visual order needs to be *out-of-sync* with the speech and navigation order; otherwise
    the underlying document source should be reordered instead.
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So the only reason to use `order` to rearrange grid-item layout is if you need
    to have the document source in one order and layout in the other. This is already
    easily possible by assigning grid items to areas that don’t match source order.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that `order` is useless and should always be shunned; there
    may well be times it makes sense. But unless you find yourself nearly forced into
    using it by specific circumstances, think very hard about whether it’s the best
    solution.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-743
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For a formal definition of the `order` property, see [Chapter 11](ch11.html#flexbox).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-745
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grid layout is complex and powerful, so don’t be discouraged if you feel overwhelmed
    at first. It takes some time to get used to the way grid operates, especially
    because so many of its features are nothing like what we’ve dealt with before.
    Much of those features’ power comes directly from their novelty—but like any powerful
    tool, grid layout can be difficult and frustrating to learn to use.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: 'We hope we were able to steer you past some of those pitfalls, but still, remember
    the wisdom of Master Yoda: “You must unlearn what you have learned.” When coming
    to grid layout, there has never been greater need to put aside what you think
    you know about layout and learn anew. Over time, your patience and persistence
    will be rewarded.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们能帮助你避开一些陷阱，但是，请记住尤达大师的智慧：“你必须忘记你所学过的。”当涉及到网格布局时，从来没有比现在更需要抛开你对布局的既有认知，重新学习的时刻。随着时间的推移，你的耐心和坚持将会得到回报。
