- en: Chapter 12\. Grid Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its inception, CSS had a layout-shaped hole at its center. Designers bent
    other features to the purposes of layout, most notably `float` and `clear`, and
    generally hacked their way around that hole. Flexbox layout helped to fill it,
    but flexbox is really meant for specific use cases, like navigation bars (navbars),
    as shown in [Chapter 11](ch11.html#flexbox).
  prefs: []
  type: TYPE_NORMAL
- en: Grid layout, by contrast, is a *generalized* layout system. With its emphasis
    on rows and columns, it might at first feel like a return to table layout—and
    in certain ways that’s not too far off—but there is far, far more to grid layout
    than table layout. Grid allows pieces of the design to be laid out independently
    of their document source order, and even overlap pieces of the layout, if that’s
    your wish. CSS provides powerfully flexible methods for defining repeating patterns
    of grid lines, attaching elements to those grid lines, and more. You can nest
    grids inside grids, or for that matter, attach tables or flexbox containers to
    a grid. And much, much more.
  prefs: []
  type: TYPE_NORMAL
- en: In short, grid layout was the layout system we long waited for, and in 2017,
    it landed in all the major browser engines. It takes many, many layouts that were
    difficult, or even impossible, and invariably fragile, and allows you to create
    them simply, flexibly, and robustly.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Grid Container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first step to creating a grid is defining a *grid container*. This is much
    like a containing block in positioning, or a flex container in flexible-box layout:
    a grid container is an element that defines a *grid formatting context* for its
    contents.'
  prefs: []
  type: TYPE_NORMAL
- en: At this basic level, grid layout is quite reminiscent of flexbox. For example,
    the child elements of a grid container become *grid items*, just as the child
    elements of a flex container become flex items. The children of those grid items
    do *not* become grid elements—although any grid item can itself be made a grid
    container, and thus have its child elements become grid items to the nested grid.
    It’s possible to nest grids inside grids, until it’s grids all the way down.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS has two kinds of grids: *regular* grids and *inline* grids. These are created
    with special values for the `display` property: `grid` and `inline-grid`. The
    first generates a block-level box, and the second an inline-level box. [Figure 12-1](#grids_and_inline_grids)
    illustrates the difference.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. Grids and inline grids
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These are very similar to the `block` and `inline-block` values for `display`.
    Most grids you create are likely to be block-level, though the ability to create
    inline grids is always there should you need it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although `display: grid` creates a block-level grid, the specification is careful
    to explicitly state that “grid containers are not block containers.” Although
    the grid box participates in layout much as a block container does, there are
    differences between them.'
  prefs: []
  type: TYPE_NORMAL
- en: First off, floated elements do not intrude into the grid container. What this
    means in practice is that a grid will not slide under a floated element, as a
    block container will. See [Figure 12-2](#floats_interact_differently) for a demonstration
    of the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. Floats interact differently with blocks and grids
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Furthermore, the margins of a grid container do not collapse with the margins
    of its descendants. Again, this is distinct from block boxes, whose margins do
    (by default) collapse with descendants. For example, the first list item in an
    ordered list may have a top margin, but this margin will collapse with the list
    element’s top margin. The top margin of a grid item will *never* collapse with
    the top margin of its grid container. [Figure 12-3](#margin_collapsing) illustrates
    the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-3\. Margin collapsing and the lack thereof
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A few CSS properties and features do not apply to grid containers and grid
    items:'
  prefs: []
  type: TYPE_NORMAL
- en: All `column` properties (e.g., `column-count`, `columns`, etc.) are ignored
    when applied to a grid container. (You can learn more about multicolumn properties
    at [CSS Multi-Column Layout](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Columns).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `::first-line` and `::first-letter` pseudo-elements do not apply to grid
    containers and are ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float` and `clear` are effectively ignored for grid items (though not grid
    containers). Despite this, the `float` property still helps determine the computed
    value of the `display` property for children of a grid container, because the
    `display` value of the grid items is resolved *before* they’re made into grid
    items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `vertical-align` property has no effect on the placement of grid items,
    though it may affect the content inside the grid item. (Don’t worry: we’ll talk
    later about other, more powerful ways to align grid items.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, if a grid container’s declared `display` value is `inline-grid` *and*
    the element is either floated or absolutely positioned, the computed value of
    `display` becomes `grid` (thus dropping `inline-grid`).
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve defined a grid container, the next step is to set up the grid within.
    Before we explore how that works, though, it’s necessary to cover some terminology.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Basic Grid Terminology
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve already talked about grid containers and grid items, but let’s define
    them in a bit more detail. As we said before, a *grid container* is a box that
    establishes a *grid-formatting context*—that is, an area in which a grid is created
    and elements are laid out according to the rules of grid layout instead of block
    layout. You can think of it like the way an element set to `display: table` creates
    a table-formatting context within it. Given the grid-like nature of tables, this
    comparison is fairly apt, though be sure not to make the assumption that grids
    are just tables in another form. Grids are far more powerful than tables ever
    were.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *grid item* is a thing that participates in grid layout within a grid-formatting
    context. This is usually a child element of a grid container, but it can also
    be the anonymous (that is, not contained within an element) bits of text that
    are part of an element’s content. Consider the following, which has the result
    shown in [Figure 12-4](#grid_items):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4\. Grid items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice how each element, *and* each bit of text between the elements, has become
    a grid item. The image is a grid item, just as much as the elements and text runs—seven
    grid items in all. Each will participate in the grid layout, although the anonymous
    text runs will be much more difficult (or impossible) to affect with the various
    grid properties we’ll discuss.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re wondering about `grid-template-rows` and `grid-template-columns`,
    we’ll tackle them in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: In the course of using those properties, you’ll create or reference several
    core components of grid layout. These are summarized in [Figure 12-5](#grid_components).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most fundamental unit is the *grid line*. By defining the placement of
    one or more grid lines, you implicitly create the rest of the grid’s components:'
  prefs: []
  type: TYPE_NORMAL
- en: Grid track
  prefs: []
  type: TYPE_NORMAL
- en: A continuous run between two adjacent grid lines—in other words, a *grid column*
    or a *grid row*. It goes from one edge of the grid container to the other. The
    size of a grid track is dependent on the placement of the grid lines that define
    it. These are analogous to table columns and rows. More generically, these can
    be referred to as *block-axis* and *inline-axis* tracks, where (in Western languages)
    column tracks are on the block axis and row tracks are on the inline axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5\. Grid components
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Grid cell
  prefs: []
  type: TYPE_NORMAL
- en: Any space bounded by four grid lines, with no grid lines running through it,
    analogous to a table cell. This is the smallest unit of area in grid layout. Grid
    cells cannot be directly addressed with CSS grid properties; that is, no property
    allows you to say a grid item should be associated with a given cell. (But see
    the next point for more details.)
  prefs: []
  type: TYPE_NORMAL
- en: Grid area
  prefs: []
  type: TYPE_NORMAL
- en: Any rectangular area bounded by four grid lines and made up of one or more grid
    cells. An area can be as small as a single cell or as large as all the cells in
    the grid. Grid areas *are* directly addressable by CSS grid properties, which
    allow you to define the areas and then associate grid items with them.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to note is that these grid tracks, cells, and areas are entirely
    constructed of grid lines—and, more importantly, do not have to correspond to
    grid items. There is no requirement that all grid areas be filled with an item;
    it is perfectly possible to have some or even most of a grid’s cells be empty
    of any content. You can also have grid items overlap each other, either by defining
    overlapping grid areas or by using grid-line references that create overlapping
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: Another fact to keep in mind is that you can define as many or as few grid lines
    as you wish. You could literally define just a set of vertical grid lines, thus
    creating a bunch of columns and only one row. Or you could go the other way, creating
    a bunch of row tracks and no column tracks (though there would be one, stretching
    from one side of the grid container to the other).
  prefs: []
  type: TYPE_NORMAL
- en: The flip side is that if you create a condition preventing a grid item from
    being placed within the column and row tracks you define, or if you explicitly
    place a grid item outside those tracks, new grid lines and tracks will be automatically
    added to the grid to accommodate, creating implicit grid tracks (a subject we’ll
    return to later in the chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Grid Lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It turns out that creating grid lines can get fairly complex. That’s not so
    much because the concept is difficult. CSS just provides many ways to get it done,
    and each uses its own subtly different syntax.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by looking at two closely related properties.
  prefs: []
  type: TYPE_NORMAL
- en: With these properties, you can define the grid tracks of your overall *grid
    template*, or what the CSS specification calls the *explicit grid*. Everything
    depends on these grid tracks; fail to place them properly, and the whole layout
    can easily fall apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you define a grid track, grid lines are created. If you create just one
    track for the whole grid, two lines are created: one at the start of the track
    and one at the end. Two tracks means three lines: one at the start of the first
    track, one between the two, and one at the end of the second track. And so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you’re starting out with CSS grid layout, it’s probably a good idea to
    sketch out where the grid tracks need to be on paper first, or in some close digital
    analogue. Having a visual reference for where the lines will land, and how the
    tracks should behave, can make writing your grid CSS a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: The exact syntax patterns for <*`track-list`*> and <*`auto-track-list`*> are
    complex and nest a few layers deep, and unpacking them would take a lot of time
    and space that’s better devoted to just exploring how things work. There are a
    lot of ways to make all this happen, so before we start discussing those patterns,
    we have some basic things to establish.
  prefs: []
  type: TYPE_NORMAL
- en: First, grid lines can always be referred to by number, but can also be explicitly
    named by the author. Take the grid shown in [Figure 12-6](#grid_line_numbers_and_names),
    for example. From your CSS, you can use any of the numbers to refer to a grid
    line, or you can use the defined names, or you can mix them together. Thus, you
    could say that a grid item stretches from column line `3` to line `steve`, and
    from row line `skylight` to line `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that a grid line can have more than one name. You can use any of them to
    refer to a given grid line, though you can’t combine them the way you can multiple
    class names. You might think that means it’s a good idea to avoid repeating grid-line
    names, but that’s not always the case, as you’ll soon see.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1206.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-6\. Grid-line numbers and names
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We used intentionally silly grid-line names in [Figure 12-6](#grid_line_numbers_and_names)
    to illustrate that you can pick any name you like, as well as to avoid the implication
    that there are “default” names. If you’d seen `start` for the first line, you
    might have assumed that the first line is always called that. Nope. If you want
    to stretch an element from `start` to `end`, you’ll need to define those names
    yourself. Fortunately, that’s simple to do.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve said, many value patterns can be used to define the grid template.
    We’ll start with the simpler ones and work our way toward the more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll discuss the `subgrid` value in [“Using Subgrids”](#subgrid), after establishing
    how grid tracks and grid areas are defined, named, sized, combined, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using Fixed-Width Grid Tracks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our initial step, let’s create a grid whose grid tracks are a fixed width.
    We don’t necessarily mean a fixed length like pixels or ems; percentages also
    count as fixed width here. In this context, *fixed width* means the grid lines
    are placed such that the distance between them does not change because of content
    changes within the grid tracks.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, as an example, this counts as a definition of three fixed-width grid columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That will place a line 200 pixels from the start of the grid container (by default,
    the left side); a second grid line half the width of the grid container away from
    the first; and a third line 100 pixels away from the second. This is illustrated
    in [Figure 12-7](#grid_line_placement).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1207.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-7\. Grid-line placement
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While it’s true that the second column can change in size if the grid container’s
    size changes, it will *not* change based on the content of the grid items. However
    wide or narrow the content placed in that second column, the column’s width will
    always be half the width of the grid container.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also true that the last grid line doesn’t reach the right edge of the grid
    container. That’s fine; it doesn’t have to. If you want it to—and you probably
    will—you’ll see various ways to deal with that in just a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all lovely, but what if you want to name your grid lines? Just place
    any grid-line name you want, and as many as you want, in the appropriate place
    in the value, surrounded by square brackets. That’s all! Let’s add some names
    to our previous example, with the result shown in [Figure 12-8](#grid_name_placement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1208.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-8\. Grid-line naming
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What’s nice is that adding the names makes clear that each value is actually
    specifying a grid track’s width, which means there is always a grid line to either
    side of a width value. Thus, for the three widths we have, four grid lines are
    actually created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Row grid lines are placed in exactly the same way as columns, as [Figure 12-9](#creating_a_grid)
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1209.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-9\. Creating a grid
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have a couple of things to point out here. First, both column and row lines
    have the names `start` and `end`. This is perfectly OK. Rows and columns don’t
    share the same namespace, so you can reuse names like these in the two contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Second is the percentage value for the `content` row track. This is calculated
    with respect to the height of the grid container; thus, a container 500 pixels
    tall would yield a `content` row that’s 400 pixels tall (because the percentage
    value of this row is `80%`). Doing this generally requires that you know ahead
    of time how tall the grid container will be, which won’t always be the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think we could just say `100%` and have it fill out the space, but
    that doesn’t work, as [Figure 12-10](#exceeding_the_grid_container) illustrates:
    the `content` row track will be as tall as the grid container itself, thus pushing
    the `footer` row track out of the container altogether:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1210.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-10\. Exceeding the grid container
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One way (not necessarily the best way) to handle this scenario is to *minmax*
    the row’s value, telling the browser that you want the row no shorter than one
    amount and no taller than another, leaving the browser to fill in the exact value.
    This is done with the `minmax(a,b)` pattern, where `a` is the minimum size and
    `b` is the maximum size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This code indicates that the `content` row should never be shorter than 3 ems
    tall, and never taller than the grid container itself. This allows the browser
    to bring up the size until it’s tall enough to fit the space left over from the
    `masthead` and `footer` tracks, and no more. It also allows the browser to make
    it shorter than that, as long as it’s not shorter than `3em`, so this is not a
    guaranteed result. [Figure 12-11](#adapting_to_the_grid_container) shows one possible
    outcome of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1211.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-11\. Adapting to the grid container
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In like fashion, with the same caveats, `minmax()` could have been used to help
    the `col-b` column fill out the space across the grid container. The thing to
    remember with `minmax()` is that if the *max* is smaller than the *min*, the *max*
    value is thrown out and the *min* value is used as a fixed-width track length.
    Thus, `minmax(100px, 2em)` would resolve to `100px` for any font-size value smaller
    than `50px`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the vagueness of `minmax()`’s behavior unsettles you, CSS offers alternatives
    to this scenario. We could also have used the `calc()` value pattern to come up
    with a track’s height (or width). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That would yield a `content` row exactly as tall as the grid container minus
    the sum of the `masthead` and `footer` heights, as we saw in the previous figure.
  prefs: []
  type: TYPE_NORMAL
- en: That works as far as it goes, but is a somewhat fragile solution, since any
    changes to the `masthead` or `footer` heights will also require an adjustment
    of the calculation. It also becomes a lot more difficult (or impossible) if you
    want more than one grid track to flex in this fashion. As it happens, CSS has
    much more robust ways to deal with this sort of situation, as you’ll see next.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flexible Grid Tracks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thus far, all our grid tracks have been *inflexible*—their size determined by
    a length measure or the grid container’s dimensions, but unaffected by any other
    considerations. *Flexible* grid tracks, by contrast, can be based on the amount
    of space in the grid container not consumed by inflexible tracks; or, alternatively,
    can be based on the actual content of the entire grid track.
  prefs: []
  type: TYPE_NORMAL
- en: Fractional units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to divide up whatever space is available by a certain fraction and
    distribute the fractions to various columns, the `fr` unit is here for you. An
    `fr` is a flexible amount of space, representing a fraction of the *leftover*
    space in a grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the simplest case, you can divide up the whole container by equal fractions.
    For example, if you want four columns, you could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In this very specific and limited case, that’s equivalent to saying the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-12](#dividing_the_container) shows the result of either.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1212.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-12\. Dividing the container into four columns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This works because all of the grid container was “leftover space,” so all of
    it is available to be divided up by the `fr` lengths. We’ll get into how that
    plays out with nonflexible grid tracks in just a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the previous example, suppose we want to add a fifth column and
    redistribute the column sizes so they’re all still equal. If we used percentage
    values, we’d have to rewrite the entire value to be five instances of `20%`. With
    `fr`, though, we can just add another `1fr` to the value and have everything done
    for us automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The way `fr` units work is that all of the `fr` values are added together, and
    all the leftover space in the grid is divided by that total. Then each track gets
    the number of those fractions indicated by its `fr` value.
  prefs: []
  type: TYPE_NORMAL
- en: In our first example, we had four `1fr` values, so their `1`’s were added together
    to get a total of 4\. The available space was then divided by 4, and each column
    got one of those fourths. When we added a fifth `1fr`, the space was divided by
    5, and each column got one of those fifths.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are not required to always use `1` with your `fr` units! Suppose you want
    to divide up a space into three columns, with the middle column twice as wide
    as the other two. The code would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, these values are added up to get 4, and then we divide that 4 by 1 (representing
    the whole), so the base `fr` in this case is `0.25`. The first and third tracks
    are thus 25% the width of the container, whereas the middle column is half the
    container’s width, because it’s `2fr`, which is twice `0.25`, or `0.5`, or 50%.
  prefs: []
  type: TYPE_NORMAL
- en: 'You aren’t limited to integers, either. A recipe card for apple pie could be
    laid out using these columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ll leave the math on that one as an exercise for you. (Lucky you! Just remember
    to start with `1 + 3.14159 + 1`, and you’ll have a good head start.)
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a convenient way to slice up a container, but there’s more here than
    just replacing percentages with something more intuitive. Fractional units really
    come into their own when we have some fixed tracks and some flexible space. Consider,
    for example, the following, which is illustrated in [Figure 12-13](#giving_the_center_column):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1213.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-13\. Giving the center column whatever’s available
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, the browser assigns the first and third tracks to their inflexible widths,
    and then gives whatever is left in the grid container to the center track. For
    a 1,000-pixel-wide grid container whose `font-size` is the usual browser default
    of `16px`, the first column will be 240 pixels wide and the third will be 100
    pixels wide. That totals 340 pixels, leaving 660 pixels that aren’t assigned to
    the fixed tracks. The fractional units total 1, so 660 is divided by 1, yielding
    660 pixels, all of which are given to the single `1fr` track. If the grid container’s
    width is increased to 1,400 pixels, the third column will be 140 pixels wide and
    the center column 1,020 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like that, we have a mixture of fixed and flexible columns. We can keep
    this going, splitting up any flexible space into as many fractions as we like.
    Consider this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the columns will be sized as shown in [Figure 12-14](#flexible_column_sizing).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1214.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-14\. Flexible column sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The widths of the columns will be, from left to right: 15, 45, 30, and 10 ems.
    The first column gets its fixed width of `15em`. The last column is `10%` of 100
    em, which is 10 em. That leaves 75 ems to distribute among the flexible columns.
    The two added together total 7.5 fr. For the wider column, 4.5 ÷ 7.5 equals 0.6,
    and that times 75 ems equals 45 ems. Similarly, 3 ÷ 7.5 = 0.4, and that times
    75 ems equals 30 ems.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, admittedly, we put a thumb on the scales for that example: the `fr` total
    and `width` value were engineered to yield nice, round numbers for the various
    columns. This was done purely to aid understanding. If you want to work through
    the process with less tidy numbers, consider using `92.5em` or `1234px` for the
    `width` value in the previous example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to define a minimum or maximum size for a given track, `minmax()`
    can be quite useful. To extend the previous example, suppose the third column
    should never be less than 5 ems wide, no matter what. The CSS would then be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now the layout will have two flexible columns at its middle, down to the point
    that the third column reaches `5em` wide. Below that point, the layout will have
    three inflexible columns (`15em`, `5em`, and `10%` wide, respectively) and a single
    flexible column that will get all the leftover space, if there is any. Once you
    run the math, it turns out that up to `30.5556em` wide, the grid will have one
    flexible column. Above that width, there will be two flexible columns.
  prefs: []
  type: TYPE_NORMAL
- en: You might think this works the other way—for example, if you wanted to make
    a column track flexible up to a certain point, and then become fixed after, you
    would declare a minimum `fr` value. This won’t work, sadly, because `fr` units
    are not allowed in the *min* position of a `minmax()` expression. So any `fr`
    value provided as a minimum will invalidate the entire declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of setting to 0, let’s look at a minimum value explicitly set to `0`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-15](#minmaxed_column_sizing) illustrates the narrowest grid width
    at which the third column can remain 500 pixels wide. Any narrower, and the `minmax`-ed
    column will be narrower than 500 pixels. Any wider, and the second column, the
    `fr` column, will grow beyond zero width while the third column stays at 500 pixels
    wide.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1215.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-15\. Minmaxed column sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you look closely, you’ll see the `1fr` label next to the boundary between
    the `15em` and `minmax(0,500px)` columns. That’s there because the `1fr` is placed
    with its left edge on the second-column grid line, and has no width, because there
    is no space left to flex. Similarly, the `minmax` is placed on the third-column
    grid line. It’s just that, in this specific situation, the second- and third-column
    grid lines are in the same place (which is why the `1fr` column has zero width).
  prefs: []
  type: TYPE_NORMAL
- en: If you ever run into a case where the minimum value is greater than the maximum
    value, the whole thing is replaced with the minimum value. Thus, `minmax(``500px,200px)`
    would be treated as a simple `500px`. You probably wouldn’t do this so obviously,
    but this feature is useful when mixing things like percentages and fractions.
    Thus, you could have a column that’s `minmax(10%,1fr)` that would be flexible
    down to the point where the flexible column was less than 10% of the grid container’s
    size, at which point it would stick at `10%`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fractional units and minmaxes are usable on rows just as easily as columns;
    it’s just that rows are rarely sized in this way. You could easily imagine setting
    up a layout in which the masthead and footer are fixed tracks, while the content
    is flexible down to a certain point. That might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That works OK, but it’s a lot more likely that you’ll want to size that row
    by the height of its content, not some fraction of the grid container’s height.
    The next section shows exactly how to make that happen.
  prefs: []
  type: TYPE_NORMAL
- en: Content-aware tracks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s one thing to set up grid tracks that take up fractions of the space available
    to them, or that occupy fixed amounts of space. But what if you want to line up
    a bunch of pieces of a page and can’t guarantee how wide or tall they might get?
    This is where `min-content` and `max-content` come in. (See [Chapter 6](ch06.html#basic-visual-formatting)
    for a detailed explanation of these keywords.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s so powerful about using these sizing keywords in CSS Grid is that they
    apply to the entire grid track they define. For example, if you size a column
    to be `max-content`, the entire column track will be as wide as the widest content
    within it. This is easiest to illustrate with a grid of images (12, in this case)
    with the grid declared as follows and shown in [Figure 12-16](#sizing_grid_tracks_by_content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1216](assets/css5_1216.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-16\. Sizing grid tracks by content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Looking at the columns, we can see that each column track is as wide as the
    widest image within that track. Where a bunch of portrait images happen to line
    up, the column is more narrow; where a landscape image shows up, the column is
    made wide enough to fit it. The same thing happens with the rows. Each row is
    as tall as the tallest image within it, so if a row happens to have all short
    images, the row is also short.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage here is that this works for any sort of content, no matter what’s
    in there. Say we add captions to the photos. All of the columns and rows will
    resize themselves as needed to handle both text and images, as shown in [Figure 12-17](#sizing_grid_tracks_around_mixed_content).
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t a full-fledged design—the images are out of place, and there’s no
    attempt to constrain the caption widths. In fact, that’s exactly what we should
    expect from `max-content` values for the column widths. Since it means “make this
    column wide enough to hold all its content,” that’s what we get.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1217.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-17\. Sizing grid tracks around mixed content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'What’s important to realize is that this will hold even if the grid tracks
    have to spill out of the grid container. Even if we’d assigned something like
    `width: 250px` to the grid container, the images and captions would be laid out
    just the same. That’s why things like `max-content` tend to appear in `minmax()`
    statements. Consider the following, where grids with and without `minmax()` appear
    side by side. In both cases, the grid container is represented by a shaded background
    (see [Figure 12-18](#sizing_grid_tracks_minmax)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1218.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-18\. Sizing grid tracks with and without `minmax()`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first instance, the grid items completely contain their contents, but
    they spill out of the grid container. In the second, `minmax()` directs the browser
    to keep the columns within the range of `0` and `max-content`, so they’ll all
    be fitted into the grid container if possible. A variant would be to declare `minmax(min-content,
    max-content)`, which can lead to a slightly different result than the `0, max-content`
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: The reason that some images are overflowing their cells in the second example
    is that the tracks have been fitted into the grid container according to `minmax(0,max-content)`.
    They can’t reach `max-content` in every track, but they can get as close as possible
    while all still fitting into the grid container. Where the contents are wider
    than the track, they just stick out of it, overlapping other tracks. This is standard
    grid behavior.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering what happens if you `min-content` both the columns and the
    rows, it’s pretty much the same as applying `min-content` to the columns and leaving
    the rows alone. This happens because the grid specification directs browsers to
    resolve column sizing first, and row sizing after that.
  prefs: []
  type: TYPE_NORMAL
- en: One more keyword you can use with grid track sizing is `auto`, which also happens
    to be the default value for any grid track’s width. As a minimum, it’s treated
    as the minimum size for the grid item, as defined by `min-width` or `min-height`.
    As a maximum, it’s treated the same as `max-content`. You might think this means
    it can be used only in `minmax()` statements, but this is not the case. You can
    use it anywhere, and it will take on either a minimum or maximum role. Which one
    it takes on depends on the other track values around it, in ways that are frankly
    too complicated to get into here. As with so many other aspects of CSS, using
    `auto` is essentially letting the browser do what it wants. Sometimes that’s fine,
    but in general you’ll probably want to avoid it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is a caveat to that last statement: `auto` values allow grid items to
    be resized by the `align-content` and `justify-content` properties, a topic we’ll
    discuss in [“Setting Alignment in Grids”](#aligning-and-grids). Since `auto` values
    are the only track-sizing values that permit this, there may be very good reasons
    to use `auto` after all.'
  prefs: []
  type: TYPE_NORMAL
- en: Fitting Track Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the `min-content` and `max-content` keywords, a `fit-content()`
    function allows you to more compactly express certain types of sizing patterns.
    It’s a bit complicated to decipher, but the effort is worth it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `fit-content()` function accepts a <*`length`*> or a <*`percentage`*> as
    its argument, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we explore what that means, let’s ponder the pseudo-formula given by
    the specification:'
  prefs: []
  type: TYPE_NORMAL
- en: fit-content(*argument*) => min(max-content, max(min-content, *argument*))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means, essentially, “figure out which is greater, the `min-content` sizing
    or the supplied argument, and then take that result and choose whichever is smaller,
    that result or the `max-content` size.” Which is probably confusing!.
  prefs: []
  type: TYPE_NORMAL
- en: 'We feel that a better way of phrasing it is “`fit-content(*argument*)` is equivalent
    to `minmax(min-content,max-content)`, except that the value given as an argument
    sets an upper limit, similar to `max-width` or `max-height`.” Let’s consider this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The argument here is `50ch`, or the same width as 50 zero (`0`) characters side
    by side. So we’re setting up a single column that’s having its content fit to
    that measure.
  prefs: []
  type: TYPE_NORMAL
- en: For the initial case, assume the content is only 29 characters long, measuring
    29 ch (because it’s in a monospace font). That means the value of `max-content`
    is `29ch`, and the column will be only that wide, because it minimizes to that
    measure—`29ch` is smaller than whatever the maximum of `50ch` and `min-content`
    turns out to be.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s assume a bunch of text content is added so that there are 256 characters,
    thus measuring `256ch` in width (without any line wrapping). That means `max-content`
    evaluates to `256ch`. This is well beyond the `50ch` argument, so the column is
    constrained to be the larger of `min-content` and `50ch`, which is `50ch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As further illustration, consider the results of the following, as shown in
    [Figure 12-19](#sizing_grid_tracks_fit_content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1219.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-19\. Sizing grid tracks with `fit-content()`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice the first column is narrower than the other two. Its `29ch` content minimizes
    to that size. The other two columns have more content than will fit into `50ch`,
    so they line-wrap, because their width has been limited to `50ch`.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s consider what happens if an image is added to the second column. We’ll
    make it `500px` wide, which happens to be wider than `50ch` in this instance.
    For that column, the maximum of `min-content` and `50ch` is determined. As we
    said, the larger value there is `min-content`, which is to say `500px` (the width
    of the image). Then the *minimum* of `500px` and `max-content` is determined.
    The text, rendered as a single line, would go on past `500px`, so the minimum
    is `500px`. Thus, the second column is now 500 pixels wide. This is depicted in
    [Figure 12-20](#sizing_grid_tracks_fit_content_wide).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1220.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-20\. Fitting to wide content
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you compare Figures [12-19](#sizing_grid_tracks_fit_content) to [12-20](#sizing_grid_tracks_fit_content_wide),
    you’ll see that the text in the second column wraps at a different point, due
    to the change in column width. But also compare the text in the third column.
    It, too, has different line wraps.
  prefs: []
  type: TYPE_NORMAL
- en: That happens because after the first and second columns are sized, the third
    column has a bit less than `50ch` of space in which to be sized. The `fit-content(50ch)`
    function still does its thing, but here, it does so within the space available
    to it. Remember, the `50ch` argument is an upper bound, not a fixed size.
  prefs: []
  type: TYPE_NORMAL
- en: This is one of the great advantages of `fit-content()` over the less flexible
    `minmax()`. It allows you to shrink tracks to their minimum `content-size` when
    there isn’t much content, while still setting an upper bound on the track size
    when there’s a lot of content.
  prefs: []
  type: TYPE_NORMAL
- en: You may have been wondering about the repetitive grid template values in previous
    examples, and what happens if you need more than three or four grid tracks. Will
    you have to write out every single track width individually? Indeed not, as you’ll
    see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating Grid Tracks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to set up a bunch of grid tracks of the same size, you probably
    don’t want to have to type out every single one of them. Fortunately, `repeat()`
    is here to make sure you don’t have to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we want to set up a column grid line every 5 ems and have 10 column
    tracks. Here’s how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: That’s it. Done. Ten column tracks, each one `5em` wide, for a total of 50 ems
    of column tracks. It sure beats typing `5em` 10 times!
  prefs: []
  type: TYPE_NORMAL
- en: 'Any track-sizing value can be used in a repeat, from `min-content` and `max-content`
    to `fr` values to `auto`, and so on, and you can put together more than one sizing
    value. Suppose we want to define a column structure such that there’s a `2em`
    track, then a `1fr` track, and then another `1fr` track—and, furthermore, we want
    to repeat that pattern three times. Here’s how to do that, with the result shown
    in [Figure 12-21](#repeating_a_track_pattern):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1221.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-21\. Repeating a track pattern
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice that the last-column track is a `1fr` track, whereas the first-column
    track is `2em` wide. This is an effect of the way the `repeat()` was written.
    It’s easy to add another `2em` track at the end, in order to balance things out,
    by adding a `2em` after the `repeat()` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This highlights the fact that `repeat` can be combined with any other track-sizing
    values—even other repeats—in the construction of a grid. The one thing you *can’t*
    do is nest a repeat inside another repeat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than that, just about anything goes within a `repeat()` value. Here’s
    an example taken straight from the grid specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, there are four repetitions of a 10-pixel track, a named grid line,
    a 250-pixel track, and then another named grid line. Then, after the four repetitions,
    a final 10-pixel column track. Yes, that means there will be four column grid
    lines named `col-start`, and another four named `col-end`, as shown in [Figure 12-22](#repeated_columns_w_named_grid_lines).
    This is acceptable; grid-line names are not required to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1222.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-22\. Repeated columns with named grid lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'One thing to remember, if you’re going to repeat named lines, is that if you
    place two named lines next to each other, they’ll be merged into a single, double-named
    grid line. In other words, the following two declarations are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you’re concerned about having the same name applied to multiple grid lines,
    don’t be: there’s nothing preventing it, and it can even be helpful in some cases.
    We’ll explore ways to handle such situations in [“Using Column and Row Lines”](#using-column-and-row-lines).'
  prefs: []
  type: TYPE_NORMAL
- en: Autofilling tracks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS provides a way to set up a simple pattern and repeat it until the grid container
    is filled. This doesn’t have quite the same complexity as regular `repeat()`—at
    least not yet—but it can still be pretty handy.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we want to have the previous row pattern repeat as many
    times as the grid container will comfortably accept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'That will define a row line every 5 ems until there’s no more room. Thus, for
    a grid container that’s 11 ems tall, the following is equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the grid container’s height is increased past 15 ems, but is less than 20
    ems, then this is an equivalent declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See [Figure 12-23](#auto-fill-rows-three-heights) for examples of the autofilled
    rows at three grid container heights.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1223.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-23\. Autofilling rows at three heights
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One limitation with auto-repeating is that it can take only an optional grid-line
    name, a fixed track size, and another optional grid-line name. So `[top] 5em [bottom]`
    represents about the maximum value pattern. You can drop the named lines and just
    repeat `5em`, or just drop one of the names.
  prefs: []
  type: TYPE_NORMAL
- en: It’s not possible to auto-repeat multiple fixed track sizes, nor can you auto-repeat
    flexible track sizes. Similarly, you can’t use intrinsic track sizes with auto-repeated
    tracks, so values such as `min-content` and `max-content` can’t be put into an
    auto-repeated pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might wish you could auto-repeat multiple track sizes in order to define
    gutters around your content columns. This is usually unnecessary because of the
    properties `row-gap` and `column-gap` and their shorthand `gap`, which are covered
    in [Chapter 11](ch11.html#flexbox) but also apply in CSS Grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, you can have only one auto-repeat in a given track template. Thus,
    the following would *not* be permissible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you *can* combine fixed-repeat tracks with autofill tracks. For example,
    you could start with three wide columns, and then fill the rest of the grid container
    with narrow tracks (assuming there’s space for them). That would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can flip that around too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That works because the grid layout algorithm assigns space to the fixed tracks
    first, and then fills up whatever space is left with auto-repeated tracks. The
    end result is to have one or more autofilled 2-em tracks, and then three 20-em
    tracks. [Figure 12-24](#auto-fill-columns-with-fixed) shows two examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1224.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-24\. Autofilling columns next to fixed columns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With `auto-fill`, you will always get at least one repetition of the track template,
    even if it won’t fit into the grid container for some reason. You’ll also get
    as many tracks as will fit, even if some of the tracks don’t have content. As
    an example, suppose you set up an autofill that places five columns, but only
    the first three actually end up with grid items in them. The other two would remain
    in place, holding open layout space.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `auto-fit`, on the other hand, tracks that don’t contain any grid
    items will be compressed to a width of zero, though they (and their associated
    grid lines) remain part of the grid. Otherwise, `auto-fit` acts the same as `auto-fill`.
    Suppose the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If the grid container has room for five column tracks (i.e., it’s more than
    100 ems wide), but two tracks don’t have any grid items to go into them, those
    empty grid tracks will be dropped, leaving the three column tracks that *do* contain
    grid items. The leftover space is handled in accordance with the values of `align-content`
    and `justify-content` (discussed in [“Setting Alignment in Grids”](#aligning-and-grids)).
    A simple comparison of `auto-fill` and `auto-fit` is shown in [Figure 12-25](#auto-fill-and-auto-fit),
    where the numbers in the colored boxes indicate the grid-column number to which
    they’ve been attached.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1225.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-25\. Using `auto-fill` versus `auto-fit`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Defining Grid Areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maybe you’d rather just “draw a picture” of your grid—both because it’s fun
    to do and because the picture can serve as self-documenting code. It turns out
    you can more or less do exactly that with the `grid-template-areas` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could go through a wordy description of how this works, but it’s a lot more
    fun to just show it. The following rule has the result shown in [Figure 12-26](#simple_set_of_grid_areas):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1226.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-26\. A simple set of grid areas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'That’s right: the letters in the string values are used to define how areas
    of the grid are shaped. Really! And you aren’t even restricted to single letters!
    For example, we could expand the previous example like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The grid layout is the same as that shown in [Figure 12-26](#simple_set_of_grid_areas),
    though the name of each area would be different (e.g., `footer` instead of `f`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In defining template areas, the whitespace is collapsed, so you can use it
    (as was done in the previous example) to visually line up columns of names in
    the value of `grid-template-areas`. You can line up the names with spaces or tabs,
    whichever will annoy your coworkers the most. Or you can just use a single space
    to separate each identifier, and not worry about the names lining up with one
    another. You don’t even have to line-break between strings; the following works
    just as well as a pretty-printed version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'What you can’t do is merge those separate strings into a single string and
    have it mean the same thing. Every new string (as delimited by the quote marks)
    defines a new row in the grid. Thus the previous example, like the examples before
    it, defines three rows. Say we merge them all into a single string, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Then we’d have a single row of 12 columns, starting with the four-column area
    `h` and ending with the three-column area `f`. The line breaks aren’t significant
    in any way, except as whitespace that separates one identifier from another.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at these values closely, you may come to realize that each individual
    identifier represents a grid cell. Let’s bring back our first example from this
    section, and consider the result shown in [Figure 12-27](#grid_cells_with_ids),
    which uses Firefox’s Grid Inspector to label each cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1227.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-27\. Grid cells with their grid area identifiers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This is exactly the same layout result as in [Figure 12-26](#simple_set_of_grid_areas),
    but here, we’ve shown how each grid identifier in the `grid-template-areas` value
    corresponds to a grid cell. Once all the cells are identified, the browser merges
    any adjacent cells with the same name into a single area that encloses all of
    them—as long as they describe a rectangular shape! If you try to set up more complicated
    areas, the entire template is invalid. Thus, the following would result in no
    grid areas being defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See how `l` outlines an *L* shape? That humble change causes the entire `grid-template-areas`
    value to be dropped as invalid. A future version of grid layout may allow for
    nonrectangular shapes, but for now, this limitation exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to define only some grid cells to be part of grid areas but leave
    others unlabeled, you can use one or more `.` characters to fill in for those
    unnamed cells. Let’s say you just want to define some header, footer, and sidebar
    areas, and leave the rest unnamed. That would look something like this, with the
    result shown in [Figure 12-28](#grid_with_unnamed_cells):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1228.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-28\. A grid with some unnamed grid cells
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The two cells in the center of the grid are not part of a named area, having
    been represented in the template by *null cell tokens* (the `.` identifiers).
    Where each of those `...` sequences appears, we could have used one or more null
    tokens—so `left . . right` or `left` `...` `...` `right` would work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can be as simple or creative with your cell names as you like. If you want
    to call your header `ronaldo` and your footer `podiatrist`, go for it. You can
    even use any Unicode character above codepoint U+0080, so `ConHugeCo©®™` and `åwësømë`
    are completely valid area identifiers…as are emoji! ![](assets/joy_1f602.png)
    Now, to size the grid tracks created by these areas, we bring in our old friends
    `grid-template-columns` and `grid-template-rows`. Let’s add both to the previous
    example, with the result shown in [Figure 12-29](#named_areas_and_sized_tracks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1229.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-29\. Named areas and sized tracks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Thus, the columns and rows created by naming the grid areas are given track
    sizes. If we give more track sizes than there are area tracks, that will add more
    tracks past the named areas. Therefore, the following CSS will lead to the result
    shown in [Figure 12-30](#adding_more_tracks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1230.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-30\. Adding more tracks beyond the named areas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'So, given that we’re naming areas, how about mixing in some named grid lines?
    As it happens, we already have: naming a grid area automatically adds names to
    the grid lines at its start and end. For the `header` area, there’s an implicit
    `header-start` name on its first-column grid line *and* its first-row grid line,
    and `header-end` for its second-column and -row grid lines. For the `footer` area,
    the `footer-start` and `footer-end` names were automatically assigned to its grid
    lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Grid lines extend throughout the whole grid area, so a lot of these names are
    coincident. [Figure 12-31](#implicit_grid_line_names_explicit) shows the naming
    of the lines created by the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1231.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-31\. Implicit grid-line names made explicit
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now let’s mix it up even more by adding a couple of explicit grid-line names
    to our CSS. Given the following rules, the first-column grid line in the grid
    would add the name `begin`, and the second-row grid line in the grid would add
    the name `content`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Again: those grid-line names are *added* to the implicit grid-line names created
    by the named areas. Grid-line names never replace other grid-line names. Instead,
    they just keep piling up.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more interesting, this implicit-name mechanism runs in reverse. Suppose
    you don’t use `grid-template-areas` at all, but instead set up some named grid
    lines like so, as illustrated in [Figure 12-32](#implicit_grid_area_names_explicit):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1232.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-32\. Implicit grid-area names made explicit
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because the grid lines use the form of `name-start`/`name-end`, the grid areas
    they define are implicitly named. To be frank, it’s clumsier than doing it the
    other way, but the capability is there in case you ever want it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bear in mind that you don’t need all four grid lines to be named in order to
    create a named grid area, though you probably do need them all to create a named
    grid area where you want it to be. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This will still create a grid area named `content`. It’s just that the named
    area will be placed into a new row after all the defined rows. What’s odd is that
    an extra, empty row will appear after the defined rows but before the row containing
    `content`. This has been confirmed to be the intended behavior. Thus, if you try
    to create a named area by naming the grid lines and miss one or more of them,
    your named area will effectively hang off to one side of the grid instead of being
    a part of the overall grid structure.
  prefs: []
  type: TYPE_NORMAL
- en: So, again, if you want to create named grid areas, you should probably stick
    to explicitly naming grid areas and let the `start-` and `end-` grid-line names
    be created implicitly, as opposed to the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: Placing Elements in the Grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Believe it or not, we’ve gotten this far without talking about how grid items
    are actually placed in a grid, once they’ve been defined.
  prefs: []
  type: TYPE_NORMAL
- en: Using Column and Row Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a couple of ways to go about placing grid items, depending on whether
    you want to refer to grid lines or grid areas. We’ll start with four simple properties
    that attach an element to grid lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'These properties let you say, “I want the edge of the element to be attached
    to grid line such-and-so.” As with so much of CSS Grid, it’s a lot easier to show
    than to describe, so ponder the following styles and their result (see [Figure 12-33](#attaching_elements_to_grid_lines)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1233.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-33\. Attaching elements to grid lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, we’re using grid-line numbers to say where and how the elements should
    be placed within the grid. Column numbers count from left to right, and row numbers
    from top to bottom. If you omit ending grid lines, as was the case for `.three`,
    then the next grid lines in sequence are used for the end lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the rule for `.three` in the previous example is exactly equivalent to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s another way to say that same thing, as it happens: you could replace
    the ending values with `span 1`, or even just plain `span`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you supply `span` with a number, you’re saying, “Span across this many grid
    tracks.” So we can rewrite our earlier example like this and get exactly the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If you leave out a number for `span`, it’s set to be `1`. You can’t use 0 or
    negative numbers for `span`; only positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: An interesting feature of `span` is that you can use it for both ending *and*
    starting grid lines. The precise behavior of `span` is that it counts grid lines
    in the direction “away” from the grid line where it starts. In other words, if
    you define a start grid line and set the ending grid line to be a `span` value,
    it will search toward the end of the grid. Conversely, if you define an ending
    grid line and make the start line a `span` value, it will search toward the start
    of the grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'That means the following rules will have the result shown in [Figure 12-34](#spanning_grid_lines)
    (the column and row numbers were added for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1234.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-34\. Spanning grid lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In contrast to `span` numbering, you aren’t restricted to positive integers
    for your actual grid-line values. Negative numbers will count backward from the
    end of explicitly defined grid lines. Thus, to place an element into the bottom-right
    grid cell of a defined grid, regardless of how many columns or rows it might have,
    you can just say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that this doesn’t apply to any implicit grid tracks, a concept we’ll get
    to in a bit, but only to the grid lines you explicitly define via one of the `grid-template-*`
    properties (e.g., `grid-template-rows`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We aren’t restricted to grid-line numbers, as it happens. If there are named
    grid lines, we can refer to those instead of (or in conjunction with) numbers.
    If you have multiple instances of a grid-line name, you can use numbers to identify
    which instance of the grid-line name you’re talking about. Thus, to start from
    the fourth instance of a row grid named `mast-slice`, you can say `mast-slice
    4`. Take a look at the following, illustrated in [Figure 12-35](#attaching_elements_to_named_grid_lines),
    for an idea of how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1235.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-35\. Attaching elements to named grid lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Notice how `span` changes when we add a name: specifying `span 2 col-A` causes
    the grid item to span from its starting point (the third `col-A`) across another
    `col-A` and end at the `col-A` after that. This means the grid item actually spans
    four column tracks, since `col-A` appears on every other column grid line.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, negative numbers count backward from the end of a sequence, so `col-A
    -2` gets us the second-to-last instance of a grid line named `col-A`. Because
    no end-line values are declared for `.three`, they’re both set to `span 1`. That
    means the following is exactly equivalent to the `.three` in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s an alternative way to use names with named grid lines—specifically,
    the named grid lines that are implicitly created by grid areas. For example, consider
    the following styles, illustrated in [Figure 12-36](#another_way_of_attaching):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1236.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-36\. Another way of attaching elements to named grid lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you supply a custom identifier (i.e., a name you defined), the browser looks
    for a grid line with that name *plus* either `-start` or `-end` added on, depending
    on whether you’re assigning a start line or an end line. Thus, the following are
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This works because, as we mentioned with `grid-template-areas`, explicitly creating
    a grid area implicitly creates the named `-start` and `-end` grid lines that surround
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final value possibility, `auto`, is kind of interesting. According to the
    Grid Layout specification, if one of the grid-line start/end properties is set
    to `auto`, that indicates “auto-placement, an automatic span, or a default span
    of one.” In practice, this tends to mean that the grid line that gets picked is
    governed by the *grid flow*, a concept we have yet to cover (but will soon!).
    For a start line, `auto` usually means that the next available column or row line
    will be used. For an end line, `auto` usually means a one-cell span. In both cases,
    the word *usually* is used intentionally: as with any automatic mechanism, there
    are no absolutes.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Row and Column Shorthands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two shorthand properties allow you to more compactly attach an element to grid
    lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The primary benefit of these properties is that they make it a lot simpler
    to declare the start and end grid lines to be used for laying out a grid item.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: That’s a whole lot easier to read than having each start and end value in its
    own property, honestly. Other than being more compact, the behavior of these properties
    is more or less what you’d expect. If you have two bits separated by a forward
    slash (`/`), the first part defines the starting grid line, and the second part
    defines the ending grid line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have only one value with no forward slash, it defines the starting grid
    line. The ending grid line depends on what you said for the starting line. If
    you supply a name for the starting grid line, the ending grid line is given that
    same name. If a single number is given, the second number (the end line) is set
    to `auto`. That means the following pairs are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: A subtle behavior built into the handling of grid-line names in `grid-row` and
    `grid-column` pertains to implicitly named grid lines. As you may recall, defining
    a named grid area creates `-start` and `-end` grid lines. That is, given a grid
    area with a name of `footer`, there are implicitly created `footer-start` grid
    lines to its top and left, and `footer-end` grid lines to its bottom and right.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, if you refer to those grid lines by the area’s name, the element
    will still be placed properly. Thus, the following styles have the result shown
    in [Figure 12-37](#attaching_to_implicit_grid_lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1237.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-37\. Attaching to implicit grid lines via grid-area names
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can always explicitly refer to the implicitly named grid lines, but if
    you just refer to the grid area’s name, things still work out. If you refer to
    a grid-line name that doesn’t correspond to a grid area, it falls back to the
    behavior discussed previously. In detail, it’s the same as saying `line-name 1`,
    so the following two are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This is why it’s risky to name grid lines the same as grid areas. Consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'This explicitly sets grid lines named `footer` above the “footer” row and below
    the “legal” row…and now there’s trouble ahead. Suppose we add this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: For the column lines, there’s no problem. The name `footer` gets expanded to
    `footer / footer`. The browser looks for a grid area with that name and finds
    it, so it translates `footer / footer` to `footer-start / footer-end`. The `#footer`
    element is attached to those implicit grid lines.
  prefs: []
  type: TYPE_NORMAL
- en: For `grid-row`, everything starts out the same. The `footer` name becomes `footer
    / footer`, which is translated to `footer-start / footer-end`. But that means
    the `#footer` will only be as tall as the “footer” row. It will *not* stretch
    to the second explicitly named `footer` grid line below the “legal” row, because
    the translation of `footer` to `footer-end` (due to the match between the grid-line
    name and the grid-area name) takes precedence.
  prefs: []
  type: TYPE_NORMAL
- en: 'The upshot of all this: it’s generally a bad idea to use the same name for
    grid areas and grid lines. You might be able to get away with it in some scenarios,
    but you’re almost always better off keeping your line and area names distinct,
    so as to avoid tripping over name-resolution conflicts.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Implicit Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to this point, we’ve concerned ourselves solely with explicitly defined
    grids: we’ve talked about the row and column tracks we define via properties like
    `grid-template-columns`, and how to attach grid items to the cells in those tracks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But what happens if we try to place a grid item, or even just part of a grid
    item, beyond that explicitly created grid? For example, consider the following
    grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Two rows, six columns. Simple enough. But suppose we define a grid item to
    sit in the first column and go from the first-row grid line to the fourth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now what? We have only two rows bounded by three grid lines, and we’ve told
    the browser to go beyond that, from row line 1 to row line 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens is that another row line is created to handle the situation. This
    grid line, and the new row track it creates, are both part of the *implicit grid*.
    Here are a few examples of grid items that create implicit grid lines (and tracks)
    and how they’re laid out (see [Figure 12-38](#creating_implicit_grid_lines_and_tracks)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1238.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-38\. Creating implicit grid lines and tracks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A lot is going on there, so let’s break it down. First off, the explicit grid
    is represented by the filled-in box behind the various numbered boxes; all the
    dashed lines represent the implicit grid.
  prefs: []
  type: TYPE_NORMAL
- en: What about those numbered boxes? The first, `box1`, adds an extra grid row line
    after the end of the explicit grid. The second, `box2`, starts on the last row-line
    of the explicit grid, and spans forward two row-lines, so it adds yet another
    implicit row-line. The third, `box3`, ends on the last explicit row-line (line
    3) and spans *back* two lines, thus starting on the first explicit row-line.
  prefs: []
  type: TYPE_NORMAL
- en: Things really get interesting with `box4`. It ends on the fifth row-line, which
    is to say the second implicit row-line. It spans back three row-lines—and yet,
    it still starts on the same row-line as `box3`. This happens because grid track
    spans have to start counting *within* the explicit grid. Once they start, they
    can continue into the implicit grid (as happened with `box2`), but they *cannot*
    start counting within the implicit grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, `box4` ends on row-line 5, but its span starts with row-line 3 and counts
    back two lines (`span 2`) to arrive at row-line 1\. Similarly, `box5` ends on
    row-line 5 and spans back four lines, which means it starts on row-line –2\. Remember:
    span counting must *start* in the explicit grid. It doesn’t have to end there.'
  prefs: []
  type: TYPE_NORMAL
- en: After those, `box6` starts on the last explicit row-line (line 3), and spans
    out to the sixth row-line—adding yet another implicit row-line. The point of having
    it here is to show that negative grid-line references are with respect to the
    explicit grid, and count back from its end. They do *not* refer to negatively
    indexed implicit lines that are placed before the start of the explicit grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to start an element on an implicit grid line before the explicit
    grid’s start, the way to do that is shown by `box7`: put its end line somewhere
    in the explicit grid, and span back past the beginning of the explicit grid. And
    you may have noticed: `box7` occupies an implicit column track. The original grid
    was set up to create six columns, which means seven column-lines, the seventh
    being the end of the explicit grid. When `box7` was given `grid-column: 7`, that
    was equivalent to `grid-column: 7 / span 1` (since a missing end line is always
    assumed to be `span 1`). That necessitated the creation of an implicit column-line
    in order to hold the grid item in the implicit seventh column.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take those principles and add named grid lines to the mix. Consider
    the following, illustrated in [Figure 12-39](#named_implicit_grid_lines_and_tracks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'What you can see at work in several of these examples is what happens with
    grid-line names in the implicit grid: every implicitly created line has the name
    that’s being hunted. Take `box2`, for example. It’s given an end line of `final`,
    but there is no line with that name. Thus the span-search goes to the end of the
    explicit grid and, having not found the name it’s looking for, creates a new grid
    line, to which it attaches the name `final`. (In [Figure 12-39](#named_implicit_grid_lines_and_tracks),
    the implicitly created line names are italicized and faded out a bit.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1239.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-39\. Named implicit grid lines and tracks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Similarly, `box3` starts on the first explicit row-line, and then needs to span
    three `middle` named lines. It searches forward and finds one, then goes looking
    for the other two. Not finding any, it attaches the name `middle` to the first
    implicit row-line, and then does the same for the second implicit row-line. Thus,
    it ends two implicit row-lines past the end of the explicit grid.
  prefs: []
  type: TYPE_NORMAL
- en: The same sort of thing happens with `box4` and `box5`, except working backward
    from endpoints. You can see that `box4` ends with the `end` row-line (line 3),
    then spans back to the second `begin` row-line it can find. This causes an implicit
    row-line to be created before the first row-line, named `begin`. Finally, `box5`
    spans back from `begin` (the explicitly labeled `begin`) to the second `middle`
    it can find. Since it can’t find any, it labels two implicit row-line `middle`
    and ends at the one farthest from where it started looking.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to cover a few cases, as they fall under the general umbrella of “what
    grids do when things go pear-shaped.” First, what if you accidentally put the
    start line after the end line? Say, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'All that happens is probably what was meant in the first place: the values
    are swapped. Thus, you end up with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, what if both the start and the end lines are declared to be spans of
    some variety? For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If this happens, the end value is dropped and replaced with `auto`. That means
    you’d end up with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: That would cause the grid item to have its ending edge placed automatically,
    according to the current grid flow (a subject we’ll soon explore), and the starting
    edge to be placed one grid line earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, what if the only thing directing placement of the grid item is a named
    span? In other words, you’d have this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is not permitted, so the `span footer` in this case is replaced with `span
    1`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Areas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attaching by row lines and column lines is great, but what if you could refer
    to a grid area with a single property? Behold: `grid-area`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple use of `grid-area`: assigning an element to a previously
    defined grid area. For this, we’ll bring back our old friend `grid-template-areas`,
    put it together with `grid-area` and some markup, and see what magic results (as
    shown in [Figure 12-40](#assigning_elements_to_grid_areas)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1240.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-40\. Assigning elements to grid areas
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'That’s all it takes: set up some named grid areas to define your layout, and
    then drop grid items into them with `grid-area`. So simple and yet so powerful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to use `grid-area` refers to grid lines instead of grid areas.
    Fair warning: it’s likely to be confusing at first.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a grid template that defines some grid lines, and some
    `grid-area` rules that reference the lines, as illustrated in [Figure 12-41](#assigning_elements_to_grid_lines):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1241.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-41\. Assigning elements to grid lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These elements were placed as directed. Note the ordering of the grid-line values,
    however. They’re listed in the order `row-start`, `column-start`, `row-end`, `column-end`.
    If you diagram that in your head, you’ll quickly realize that the values go counterclockwise
    (also called anticlockwise) around the grid item—the exact opposite of the TRBL
    pattern we’re used to from margins, padding, borders, and so on. Furthermore,
    this means the column and row references are not grouped together but are instead
    split up.
  prefs: []
  type: TYPE_NORMAL
- en: If you supply fewer than four values, then the missing values are taken from
    those you do supply. If you use only three values, then the missing `grid-column-end`
    is the same as `grid-column-start` if it’s a name; if the start line is a number,
    the end line is set to `auto`. The same holds true if you give only two values,
    except that the now-missing `grid-row-end` is copied from `grid-row-start` if
    it’s a name; otherwise, it’s set to `auto`.
  prefs: []
  type: TYPE_NORMAL
- en: 'From that, you can probably guess what happens if only one value is supplied:
    if it’s a name, use it for all four values; if it’s a number, the rest are set
    to `auto`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This one-to-four replication pattern is actually how giving a single grid-area
    name translates into having the grid item fill that area. The following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Now recall the behavior discussed in the previous section about `grid-column`
    and `grid-row`: if a grid line’s name matches the name of a grid area, it’s translated
    into a `-start` or `-end` variant, as appropriate. That means the previous example
    is translated to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: And that’s how a single grid-area name causes an element to be placed into the
    corresponding grid area.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Grid-Item Overlap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One thing we’ve been very careful to do in our grid layouts thus far is to
    avoid overlap. Rather like positioning, it’s absolutely (get it?) possible to
    make grid items overlap each other. Let’s take a simple case, illustrated in [Figure 12-42](#overlapping_grid_items):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1242.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-42\. Overlapping grid items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Thanks to the grid numbers that were supplied in the last two lines of the CSS,
    the two grid items overlap in the upper-right grid cell. Which is on top of the
    other depends on the layering behavior we’ll discuss later, but for now, just
    take it as a given that they do layer when overlapping.
  prefs: []
  type: TYPE_NORMAL
- en: There may well be times when you want grid items to overlap. A photo’s caption
    might partially overlap the photo, for example. Or you might want to assign a
    few items to the same grid area so they combine, or set them to be shown one at
    a time by script or user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Overlap isn’t restricted to situations involving raw grid numbers. In the following
    case, the sidebar and the footer will overlap, as shown in [Figure 12-43](#overlapping_sidebar_and_footer).
    (Assuming the footer comes later than the sidebar in the markup, then in the absence
    of other styles, the footer will be on top of the sidebar.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1243.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-43\. Overlapping sidebar and footer
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We bring this up in part to warn you about the possibility of overlap, and
    also to serve as a transition to the next topic. It’s a feature that sets grid
    layout apart from positioning, in that it can sometimes help avoid overlap: the
    concept of *grid flow*.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Grid Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the most part, we’ve been explicitly placing grid items on the grid. If
    items aren’t explicitly placed, they’re automatically placed into the grid. Following
    the grid-flow direction that’s in effect, an item is placed in the first area
    that will fit it. The simplest case is just filling a grid track in sequence,
    one grid item after another, but things can get a lot more complex than that,
    especially if there is a mixture of explicitly and automatically placed grid items.
    The latter must work around the former.
  prefs: []
  type: TYPE_NORMAL
- en: CSS has primarily two grid-flow models, *row-first* and *column-first*, though
    you can enhance either by specifying a *dense* flow. All this is done with the
    property called `grid-auto-flow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how these values work, consider the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To that markup, let’s apply the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Assuming a grid with a column line every 15 ems and a row line every 4 ems,
    we get the result shown in [Figure 12-44](#row-oriented_grid_flow).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1244.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-44\. Row-oriented grid flow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This probably seems pretty normal, the same sort of thing you’d get if you
    floated all the boxes, or if all of them were inline blocks. That familiarity
    is why `row` is the default value. Now, let’s try switching the `grid-auto-flow`
    value to `column`, as shown in [Figure 12-45](#column-oriented_grid_flow):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'So with `grid-auto-flow: row`, each row is filled in before starting on the
    next row. With `grid-auto-flow: column`, each column is filled first.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1245.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-45\. Column-oriented grid flow
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'What needs to be stressed here is that the list items weren’t explicitly sized.
    By default, they were resized to attach to the defined grid lines. This can be
    overridden by assigning explicit sizing to the elements. For example, if we make
    the list items 7 ems wide and 1.5 ems tall, we’ll get the result shown in [Figure 12-46](#explicitly_sized_grid_items):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1246.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-46\. Explicitly sized grid items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you compare that to the previous figure, you’ll see that the corresponding
    grid items start in the same place; they just don’t end in the same places. This
    illustrates that what’s really placed in grid flow is grid areas, to which the
    grid items are then attached.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important to keep in mind if you auto-flow elements that are wider
    than their assigned column or taller than their assigned row, as can very easily
    happen when turning images or other intrinsically sized elements into grid items.
    Let’s say we want to put a bunch of images, each a different size, into a grid
    that’s set up to have a column line every 50 horizontal pixels, and a row line
    every 50 vertical pixels. This grid is illustrated in [Figure 12-47](#flowing_images_in_grids),
    along with the results of flowing a series of images into that grid by either
    row or column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1247.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-47\. Flowing images in grids
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that some of the images overlap others? That’s because each image is
    attached to the next grid line in the flow, without taking into account the presence
    of other grid items. We didn’t set up images to span more than one grid track
    when they needed it, so overlap occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be managed with class names or other identifiers. We could class images
    as `tall` or `wide` (or both) and specify that they get more grid tracks. Here’s
    some CSS to add to the previous example, with the result shown in [Figure 12-48](#giving_images_more_track_space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1248](assets/css5_1248.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-48\. Giving images more track space
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This does cause the images to keep spilling down the page, but no overlapping
    occurs.
  prefs: []
  type: TYPE_NORMAL
- en: However, notice the gaps in this grid? That happens because the placement of
    some grid items across grid lines doesn’t leave enough room for other items in
    the flow. To illustrate this, and the two flow patterns, more clearly, let’s try
    an example with numbered boxes ([Figure 12-49](#illustrating_flow_patterns)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1249.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-49\. Illustrating flow patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Follow across the rows of the first grid, counting along with the numbers.
    In this particular flow, the grid items are laid out almost as if they were leftward
    floats. Almost, but not quite: notice that grid item 13 is actually to the left
    of grid item 11\. That would never happen with floats, but it can with grid flow.
    The way row flow (if we may call it that) works is that you go across each row
    from left to right, and if there’s room for a grid item, you put it there. If
    a grid cell has been occupied by another grid item, you skip over it. So the cell
    next to item 10 didn’t get filled, because there wasn’t room for item 11\. Item
    13 went to the left of item 11 because there was room for it there when the row
    was reached.'
  prefs: []
  type: TYPE_NORMAL
- en: As shown by the second example in [Figure 12-49](#illustrating_flow_patterns),
    the same basic mechanisms hold true for column flow, except in this case you work
    from top to bottom. Thus, the cell below item 9 is empty because item 10 wouldn’t
    fit there. Instead, item 10 went into the next column and covered four grid cells
    (two in each direction). The items after it, since they were just one grid cell
    in size, filled in the cells after it in column order.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Grid flow works left to right, top to bottom in languages that have that writing
    pattern. In RTL languages, such as Arabic and Hebrew, the row-oriented flow would
    be right to left, not left to right.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were just now wishing for a way to pack grid items as densely as possible,
    regardless of how that affected the ordering, good news: you can! Just add the
    keyword `dense` to your `grid-auto-flow` value, and that’s exactly what will happen.
    We can see the result in [Figure 12-50](#illustrating_dense_flow_patterns), which
    shows the results of `grid-auto-flow: row dense` and `grid-auto-flow: dense column`
    side by side.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1250.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-50\. Illustrating dense flow patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first grid, item 12 appears in the row above item 11 because there was
    a cell that fit it. For the same reason, item 11 appears to the left of item 10
    in the second grid.
  prefs: []
  type: TYPE_NORMAL
- en: In effect, what happens with `dense` grid flow is that for each grid item, the
    browser scans through the *entire* grid in the given flow direction (`row` or
    `column`), starting from the flow’s starting point (the top-left corner in LTR
    languages), until it finds a place where that grid item will fit. This can make
    things like photo galleries more compact, and works great as long as you don’t
    have a specific order in which the grid items need to appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve explored grid flow, we have a confession to make: to make the
    last couple of grid items look right, we included some CSS that we didn’t show
    you. Without it, the items hanging off the edge of the grid would have looked
    quite a bit different from the other items—much shorter in row-oriented flow,
    and much narrower in column-oriented flow. You’ll see why, and the CSS we used,
    in the next section.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Automatic Grid Tracks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve almost entirely seen grid items placed into a grid that was explicitly
    defined. But in the preceding section we had grid items running off the edge of
    the explicitly defined grid. What happens when a grid item goes off the edge?
    Rows or columns are added as needed to satisfy the layout directives of the items
    in question (see [“Working with Implicit Grid”](#the-implicit-grid)). So, if an
    item with a row span of `3` is added after the end of a row-oriented grid, three
    new rows are added after the explicit grid.
  prefs: []
  type: TYPE_NORMAL
- en: By default, these automatically added grid tracks are the absolute minimum size
    needed. If you want to exert a little more control over their sizing, `grid-auto-rows`
    and `grid-auto-columns` are for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'For any automatically created row or column tracks, you can provide a single
    track size or a minmaxed pair of track sizes. Let’s take a look at a reduced version
    of the grid-flow example from the previous section: we’ll set up a 2 × 2 grid
    and try to put five items into it. In fact, let’s do it twice: once with `grid-auto-rows`
    and once without, as illustrated in [Figure 12-51](#grids_auto-row_sizing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: As the second grid shows, without assigning a size to the automatically created
    row, the overflowing grid items are placed in a row that’s exactly as tall as
    the grid items’ content, and not a pixel more. Each is still just as wide as the
    column into which it’s placed, because the columns have a size (`80px`). The row,
    lacking an explicit height, defaults to `auto`, with the result shown.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1251](assets/css5_1251.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-51\. Grids with and without auto-row sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If we flip things to a column-oriented flow, the same basic principles apply
    (see [Figure 12-52](#grids_auto-column_sizing)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1252.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-52\. Grids with and without auto-column sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this case, because the flow is column oriented, the last grid items are placed
    into a new column past the end of the explicit grid. In the second grid, where
    there’s no `grid-auto-columns`, those fifth and sixth items are each as tall as
    their rows (`80px`), but have an `auto` width, so they’re just as wide as they
    need to be, and no wider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know what we used in the `grid-auto-flow` figures in the previous section:
    we silently made the auto-rows and auto-columns the same size as the explicitly
    sized columns, in order to not have the last few grid items look weird. Let’s
    bring back one of those figures, only this time the `grid-auto-rows` and `grid-auto-columns`
    styles will be removed. As shown in [Figure 12-53](#auto-track_sizing_removed),
    the last few items in each grid are shorter or narrower than the rest, because
    of the lack of auto-track sizing.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1253.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-53\. A previous figure with auto-track sizing removed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And now you know…the rest of the story.
  prefs: []
  type: TYPE_NORMAL
- en: Using the grid Shorthand
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At long last, we’ve come to the shorthand property `grid`. It might just surprise
    you, though, because it’s not like other shorthand properties.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is a little bit migraine-inducing, yes, but we’ll step through it
    a piece at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get to the elephant in the room right away: `grid` allows you to either
    define a grid template *or* to set the grid’s flow and auto-track sizing in a
    compact syntax. You can’t do both at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, whichever you don’t define is reset to its defaults, as is normal
    for a shorthand property. So if you define the grid template, the flow and auto
    tracks will be returned to their default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s talk about creating a grid template by using `grid`. The values can
    get fiendishly complex and take on some fascinating patterns, but can be very
    handy in some situations. As an example, the following rule is equivalent to the
    set of rules that follows it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the value of `grid-template-rows` is broken up and scattered around
    the strings of `grid-template-areas`. That’s how row sizing is handled in `grid`
    when you have grid-area strings present. Take those strings out, and you end up
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: In other words, the row tracks are separated by a forward slash (`/`) from the
    column tracks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that with `grid`, undeclared shorthands are reset to their defaults.
    That means the following two rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, make sure your `grid` declaration comes before anything else related
    to defining the grid. If we want a dense column flow, we’d write something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s bring the named grid areas back, *and* add some extra row grid-line
    names to the mix. A named grid line that goes *above* a row track is written *before*
    the string, and a grid line that goes *below* the row track comes *after* the
    string and any track sizing. So let’s say we want to add `main-start` and `main-stop`
    above and below the middle row, and `page-end` at the very bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: That creates the grid shown in [Figure 12-54](#creating_grid_w_grid), with the
    implicitly created named grid lines (e.g., `footer-start`), along with the explicitly
    named grid lines we wrote into the CSS.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1254.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-54\. Creating a grid with the `grid` shorthand
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can see how `grid` values can get very complicated very quickly. It’s a
    powerful syntax, and it’s surprisingly easy to get used to once you’ve had just
    a bit of practice. On the other hand, it’s also incredibly easy to get things
    wrong and have the entire value be invalid, thus preventing the appearance of
    any grid at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the other use of `grid`, it’s a merging of `grid-auto-flow`, `grid-auto-rows`,
    and `grid-auto-columns`. The following rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s certainly a lot less typing for the same result! But once again, we
    have to remind you: if you write this, all the column and row track properties
    will be set to their defaults. Thus, the following rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: So once again, it’s important to make sure your shorthand comes before any properties
    it might otherwise override.
  prefs: []
  type: TYPE_NORMAL
- en: Using Subgrids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We promised many, many pages ago to talk about `subgrid`, and at last the time
    has come. The basic summary is that *subgrids* are grids that use the grid tracks
    of an ancestor grid to align their grid items, instead of a pattern unique to
    themselves. A crude example is setting a number of columns on the `<body>` element,
    and then having all of the layout components use that grid, no matter how far
    down they are in the markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how that works. We’ll start with a simple markup structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: A real home page would have a lot more elements, but we’re keeping this brief
    for clarity’s sake.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the body has 15 columns, each equally sized thanks to the `1fr`
    value. Those columns are separated by 14 gutters, each 1% the width of the viewport.
    (These are almost certainly desktop styles and not intended for mobile devices.)
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, the three children of the `<body>` element are trying to jam
    themselves into the first 3 of those 15 columns. We don’t want that: we want them
    to span the width of the layout. Well, we want the header and footer to do that.
    The `<main>` element should actually stand away from the edges of the viewport
    by, say, one column on each side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So we add the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: What we have so far is illustrated in [Figure 12-55](#subgrid_simple_setup),
    with dashed lines added to represent the grid-column tracks set for the `<body>`
    element, and some extra content that wasn’t present in the initial markup code.
    (You’ll see it in more detail soon.)
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1255](assets/css5_1255.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-55\. The initial setup of a page layout
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This might look like an entirely pointless exercise in defining and then ignoring
    a bunch of grid columns, but just wait. It’s about to get good.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a closer look at the site header. Here’s its full markup structure,
    minus the link URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, a real site would probably have a bit more to it, but this is enough
    to get the point across. What we’re going to do now is turn the `<header>` element
    into a grid container that uses the `<body>` element’s grid tracks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first rule, we make the element into a grid container with `display:
    grid` and then says its column template is a `subgrid`. At this point, the browser
    looks up through the markup tree to the closest grid container and uses the `grid-template-columns`
    of that ancestor (in this case, the `<body>`). But this isn’t just a copy of the
    value. The `<header>` element is literally using the body’s grid tracks for its
    column-oriented layout.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when the second rule says the `<h1>` should start on column line 2 and
    span five column tracks, it starts on the body’s second column line and spans
    five of the body’s column lines. Similarly, the `<nav>` element is set to span
    seven tracks back from the second-to-last column line of the `<body>`. [Figure 12-56](#subgrid_header)
    shows the results, along with the self-alignment and text alignment of the `<nav>`
    element and some shaded backgrounds to clearly indicate where the header’s pieces
    are being gridded.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1256](assets/css5_1256.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-56\. Placing the `header`’s pieces on the `body`’s columns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the pieces inside the header line up perfectly with the edges of
    the `<main>` element. That’s because they’re all being placed on the exact same
    grid lines. Not separate grid lines that just happen to coincide, but the actual
    grid lines. This means that if, for example, the `<body>` element’s column template
    is changed to add a couple more columns, or to resize some of the columns to be
    wider or narrower, we just edit the `grid-template-columns` value for the `<body>`,
    and everything using those column lines will move along with the lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do similar things with the footer. Take this CSS, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Now the logo in the footer is placed right alongside the fifth column line,
    the `<nav>` starts from the column line at the center of the layout and spans
    over a few tracks, and the `<div>` containing the legal bits ends at the very
    last column line and spans back two tracks. [Figure 12-57](#subgrid_footer) shows
    the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1257](assets/css5_1257.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-57\. Placing the `<footer>`’s pieces on the `<body>`’s columns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Looking at it, maybe we’d prefer the legal stuff to be underneath the navlinks.
    The usual solution in cases like this is to wrap the navlinks and legalese into
    a container such as a `<div>`, and then place that container on the grid columns.
    But thanks to how `subgrid` works, this isn’t at all necessary!
  prefs: []
  type: TYPE_NORMAL
- en: Defining Explicit Tracks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A more grid-like solution to the problem of placing footer pieces below others
    is to put them on their own rows. So let’s do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: This code has only three new things as compared to the last time we looked at
    it. First, the `<footer>` itself is given a `grid-template-rows` value. Second,
    the logo image is set to span the two rows defined in the first rule. Third, the
    `grid-column` value of the `<div>` is changed so it spans the same column tracks
    the `<nav>` does. It’s just expressed differently. The `<div>` is also set to
    an explicit grid row.
  prefs: []
  type: TYPE_NORMAL
- en: So while the `<footer>` continues to subgrid the column template of the `body`
    element, it also defines its own private row template. Just two rows, in this
    case, but that’s all we need. [Figure 12-58](#subgrid_footer_own_rows) shows the
    result, with a dashed line added to show the boundary between the `<footer>`’s
    two rows.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1258](assets/css5_1258.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-58\. Placing the `<footer>`’s pieces on the `<body>`’s columns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Dealing with Offsets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s turn to the `<main>` element in this document, which contains this basic
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'As you saw previously, the `<main>` element is placed on the `<body>`’s grid
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This causes it to stretch from the `<body>`’s second grid column line to the
    second-to-last grid column line. This pushes its sides inward by one column on
    either side.
  prefs: []
  type: TYPE_NORMAL
- en: The contents within the `<main>` element are not participating in the `<body>`
    grid, because `<main>` isn’t a subgrid. Well, not yet. Let’s fix that by changing
    the rule to the following, with the result shown in [Figure 12-59](#subgrid_main_placement).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1259](assets/css5_1259.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-59\. Placing the `<main>` element’s children on the `<body>`’s grid
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Again, this element is a subgrid of the body’s subgrid, but this time it isn’t
    stretched from one edge of the grid to the other. The gallery `<div>` is taking
    up only one column, because it’s a grid item that hasn’t been assigned any grid
    column values.
  prefs: []
  type: TYPE_NORMAL
- en: 'So here’s the question: what if we want move it one column track away from
    the edge of the `<main>` element? That’s the third column line of the `<body>`,
    but the second inside the `<main>` element’s container. Should it be `grid-column:
    3` or `grid-column: 2`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is `2`. When counting grid lines within a subgrid, you account for
    only those grid lines inside it. Thus, the following would have the result shown
    in [Figure 12-60](#subgrid_main_column_count):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Now the gallery fills all but the start and end columns within the `<main>`’s
    container, by starting at the second grid line within the `<main>` and ending
    at the second-to-last grid line. If we were to change the value to `3 / -3`, the
    gallery would stretch from the third column line with the `<main>` to the third-last,
    thus leaving two empty columns to either side. But let’s not do that.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1260](assets/css5_1260.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-60\. Placing the gallery inward by a column on each side, and spanning
    several columns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Instead, let’s now suppose we add five more cards to the gallery, for a total
    of six, and we’ll add some filler text rather than have each one just titled “Title” and
    so on. If we do that and don’t change any of the CSS, we’ll just have six `<div>`s
    stacked on top of each other, because while the gallery is stretched across the
    `<main>`’s subgrid, it isn’t a subgrid (or even a not-subgrid), so its interior
    is a normal-flow environment.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix that with—yes—more subgridding!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the gallery is a subgrid of its nearest ancestor element that defines a
    not-subgridded column template, which is the `<body>` element, and thus the cards
    within the gallery will use the column template of the `<body>`. We want them
    to fill out the gallery, which has 12 tracks within it, so we’ll have them each
    span 2 tracks, with the results shown in [Figure 12-61](#subgrid_gallery_cards):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1261](assets/css5_1261.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-61\. Adding multiple cards to the subgridded gallery
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Not bad, but it could be better. That last card has a longer title, and it’s
    wrapped to two lines. That means all the descriptive text paragraphs don’t line
    up with one another. How do we fix that? The same way we did for the footer: by
    defining a row template for the gallery, and making the cards subgrid to that
    row template!'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the row template with some named lines and track sizes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, each card needs to span the row template so that the row lines will be
    available to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the cards span from the gallery’s first row line to its last, we’re
    ready to have the cards become grid containers with a single column and a subgrid
    of the gallery’s row template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: We didn’t really need to add the `grid-template-columns` declaration, because
    it would default to a single column, but sometimes it’s nice to explicitly say
    what it is you want to happen, so anyone responsible for the CSS after you write
    it (including you in six months) doesn’t have to guess at what you meant to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, the elements inside each card will automatically fall into the
    row tracks: the images into the `pic` track, the titles into the `title` track,
    and the paragraphs into the `desc` track. But since we’re trying to be self-documenting,
    let’s explicitly assign each element to its named track, and while we’re at it,
    vertically align the titles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 12-62](#subgrid_gallery_card_rows) shows the final result, with the
    titles vertically centered with respect to one another, the descriptive paragraphs
    all lined up along their top edges, and all the cards sharing the same height.'
  prefs: []
  type: TYPE_NORMAL
- en: A big advantage here is that with the pieces of the cards explicitly assigned
    to the named grid row lines, rearranging the cards is now merely a question of
    editing the `grid-row-template` value set on the gallery.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1262](assets/css5_1262.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-62\. Placing card items on subgridded rows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We could also have made the cards’ column template a subgrid, which would have
    meant they’d use the `<body>` element’s column template, because the body is the
    nearest ancestor element with a column template that isn’t a subgrid. In that
    case, the cards would use the gallery’s row template and the body’s column template.
    And they’d all influence the sizing of those ancestors’ grid tracks, and thus
    influence the layout of everything else that uses those same templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have more cards than will fit into a single row, you’ll run into a problem:
    subgrids do *not* create implicit grid tracks. Instead, you need to use the auto-track
    properties like `grid-auto-rows`, which will add as many rows as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we’ll need to remove the line names and rework the CSS we’ve built to
    read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The problem now is that we have the picture, title, and description text each
    assigned to a named grid line, but `grid-auto-rows` doesn’t allow line names.
    It might look like we have to change the grid row assignments, but that’s not
    the case, as you’re about to see.
  prefs: []
  type: TYPE_NORMAL
- en: Naming Subgridded Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to using the names of any grid lines in the ancestor template, you
    can assign names to the subgrid, which is a real help if you’re using auto-tracks
    like those created in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, since we used to have row lines named `pic`, `title`, and `desc`
    in the parent grid but had to remove them in order to set up auto-rows, we take
    those same labels and put them after the `subgrid` keyword for `grid-template-rows`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s what that looks like in context with the rest of the CSS for these cards,
    which are laid out as shown in [Figure 12-63](#gallery-cards-rows-repeat):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1263](assets/css5_1263.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-63\. Placing cards onto auto-rows with named lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It’s also possible to assign names to just a few lines while not naming the
    rest. To see this in action, let’s add a couple of paragraphs of text below the
    gallery, something like this (with ellipsis-enclosed text in place of the actual
    content):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'To span the paragraphs across various column tracks, we could count and use
    numbers, but let’s name some lines and use those instead. In this case, since
    these paragraphs are children of the `<main>` element, we’ll need to modify its
    subgridded column template. Here’s how we’ll do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: OK, whoa. What just happened?
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it breaks down: after the `subgrid` keyword, we have a bunch of
    name assignments. The first is just `[]`, which means “don’t add a name to this
    grid line.” Then we have `[leadin-start]`, which assigns the name `leadin-start`
    to the second grid column line in the subgrid. After that is a repetition that
    means the next five grid column lines get no subgrid name assigned.'
  prefs: []
  type: TYPE_NORMAL
- en: Next up is what happens to be the line running down the middle of the grid,
    which is given both the name `leadin-end` and `explore-start`. This means the
    lead-in paragraph should stop spanning at this line, and the explore paragraph
    should start spanning at the same line. After another five no-name-assigned lines,
    we assign `explore-end` to a line, and that’s it. Any lines that weren’t addressed
    will be left alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is set the paragraphs’ start and end column lines like
    so, and get the result shown in [Figure 12-64](#subgrid_main_named_lines), where
    the two cards on the second line of cards have been removed for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1264](assets/css5_1264.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-64\. Placing elements using subgrid-named grid lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: And there they are, using their custom-named start and end grid lines to span
    across many grid tracks. As promised, the first ends where the second starts,
    right on that grid line that happens to be in the middle of the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Having the cards jam right up next to each other doesn’t look great, though.
    We could push the actual text apart by using padding on the paragraphs, but some
    gaps would be nice, wouldn’t they?
  prefs: []
  type: TYPE_NORMAL
- en: Giving Subgrids Their Own Gaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s possible to set gaps on subgrids that are separate from any gaps on their
    ancestor grids. Thus, for example, we could extend our previous example like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: With this change, the `<main>` element is setting no row gaps but 2-em column
    gaps. This has the result shown in [Figure 12-65](#subgrid_grid_gaps).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1265](assets/css5_1265.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-65\. The effect of adding gaps to a subgrid
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that not only are the two paragraphs pushed apart, but so are the cards
    in the gallery. That’s because they’re all participating in the same subgrid,
    and that subgrid just had some gaps added to it. This means the sides of the cards
    and the side of the paragraphs are still lined up precisely with each other, which
    is pretty nice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also that these gaps don’t apply to the content in ancestor grids: the
    boxes in the header and footer still come right up to the center column line.
    It’s only the elements in the `<main>` element’s subgrid, and any subgrids of
    that subgrid, that will know about and make use of these gaps.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If gaps aren’t familiar to you, the properties `row-gap`, `column-gap`, and
    `gap` are covered in [Chapter 11](ch11.html#flexbox).
  prefs: []
  type: TYPE_NORMAL
- en: Grid Items and the Box Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we can create a grid, attach items to the grid, create gutters between the
    grid tracks, and even use the track templates of ancestor elements. But what happens
    if we style a grid item with, say, margins? Or if it’s absolutely positioned?
    How do these things interact with the grid lines?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take margins first. The basic principle at work is that an element is
    attached to the grid by its margin edges. That means you can push the visible
    parts of the element inward from the grid area it occupies by setting positive
    margins—and pull it outward with negative margins. For example, these styles will
    have the result shown in [Figure 12-66](#grid_items_with_margins):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1266](assets/css5_1266.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-66\. Grid items with margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This works as it does because the items have both their `width` and `height`
    set to `auto`, so they can be stretched as needed to make everything work out.
    If `width` and/or `height` have non-`auto` values, they’ll end up overriding margins
    to make all the math work out. This is much like what happens with inline margins
    when element sizing is overconstrained: eventually, one of the margins gets overridden.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an element with the following styles placed into a 200-pixel-wide
    by 100-pixel-tall grid area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Going across the element first, it has 10 pixels of margin to either side, and
    its `width` is `150px`, giving a total of 170 pixels. Something’s gotta give,
    and in this case it’s the right margin (in LTR languages), which is changed to
    `40px` to make everything work—10 pixels on the left margin, 150 pixels on the
    content box, and 40 pixels on the right margin equals the 200 pixels of the grid
    area’s width.
  prefs: []
  type: TYPE_NORMAL
- en: On the vertical axis, the bottom margin is reset to `-10px`. This compensates
    for the top margin and content height totaling 110 pixels, when the grid area
    is only 100 pixels tall.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Margins on grid items are ignored when calculating grid-track sizes. Therefore,
    no matter how big or small you make a grid item’s margins, it won’t change the
    sizing of a `min-content` column, for example, nor will increasing the margins
    on a grid item cause `fr`-sized grid tracks to change size.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with block layout, you can selectively use `auto` margins to decide which
    margin will have its value changed to fit. Suppose we wanted the grid item to
    align to the right of its grid area. By setting the item’s left margin to `auto`,
    that would happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Now the element will add up 160 pixels for the right margin and content box,
    and then give the difference between that and the grid area’s width to the left
    margin, since it’s been explicitly set to `auto`. This results in [Figure 12-67](#using_auto_margins_to_align_items),
    with 10 pixels of margin on each side of the `exel` item, except the left margin,
    which is (as we just calculated) 40 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1267.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-67\. Using auto margins to align items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'That alignment process might seem familiar from block-level layout, where you
    can use `auto` inline margins to center an element in its containing block, as
    long as you’ve given it an explicit `width`. Grid layout differs in that you can
    do the same thing on the vertical axis; that is, given an element with an absolute
    height, you can vertically center it by setting the top and bottom margins to
    `auto`. [Figure 12-68](#various_auto-margin_alignments) shows a variety of `auto`
    margin effects on images, which inherently have explicit heights and widths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1268.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-68\. Various auto-margin alignments
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: CSS has other ways to align grid items, notably with properties like `justify-self`,
    which don’t depend on having explicit element sizes or auto margins. These are
    covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'This auto-margin behavior is a lot like the way margins and element sizes operate
    when elements are absolutely positioned—which leads us to the next question: what
    if a grid item is *also* absolutely positioned? For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The answer is actually pretty elegant: if you’ve defined grid-line starts and
    ends *and* the grid container establishes a positioning content (e.g., using `position:
    relative`), that grid area is used as the containing block and positioning context
    for the grid, and so the grid item is positioned *within* that context. That means
    the offset properties (`top` et al.) are calculated in relation to the declared
    grid area. Thus, the previous CSS would have the result shown in [Figure 12-69](#absolutely_positioning_a_grid_item),
    with the lightly shaded area denoting grid area used as the positioning context,
    and the thick-bordered box denoting the absolutely positioned grid item.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1269](assets/css5_1269.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-69\. Absolutely positioning a grid item
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Everything you know about absolutely positioned elements regarding offsets,
    margins, element sizing, and so on applies within this formatting context. It’s
    just that in this case, the formatting context is defined by a grid area. Absolute
    positioning introduces a wrinkle: it changes the behavior of the `auto` value
    for grid-line properties. If, for example, you set `grid-column-end: auto` for
    an absolutely positioned grid item, the ending grid line will actually create
    a new and special grid line that corresponds to the padding edge of the grid container
    itself. This is true even if the explicit grid is smaller than the grid container,
    as can happen. To see this in action, we’ll modify the previous example as follows,
    with the result shown in [Figure 12-70](#auto_values_and_absolute_positioning):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1270](assets/css5_1270.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-70\. Auto values and absolute positioning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice how the positioning context now starts at the top of the grid container
    (the thin black line around the outside of the figure), and stretches all the
    way to the right edge of the grid container, even though the grid itself ends
    short of that edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'One implication of this behavior is that if you absolutely position an element
    that’s a grid item, but you don’t give it any grid-line start or end values, then
    it will use the inner padding edge of the grid container as its positioning context.
    It does this without having to set the grid container to `position: relative`,
    or any of the other usual tricks to establish a positioning context.'
  prefs: []
  type: TYPE_NORMAL
- en: Also note that absolutely positioned grid items do *not* participate in figuring
    out grid cell and track sizing. As far as the grid layout is concerned, the positioned
    grid item doesn’t exist. Once the grid is set up, the grid item is positioned
    with respect to the grid lines that define its positioning context.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Alignment in Grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any familiarity with flexbox (see [Chapter 11](ch11.html#flexbox)),
    you’re probably aware of the various alignment properties and their values. Those
    same properties are also available in grid layout and have very similar effects.
  prefs: []
  type: TYPE_NORMAL
- en: First, a quick refresher. [Table 12-1](#grid_layout_properties) summarizes the
    alignment properties that are available and what they affect. Note there are a
    few more than you might have expected from flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: Table 12-1\. Justify and align values
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Aligns | Applies to |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `align-content` | The entire grid in the block direction | Grid container
    |'
  prefs: []
  type: TYPE_TB
- en: '| `align-items` | All grid items in the block direction | Grid container |'
  prefs: []
  type: TYPE_TB
- en: '| `align-self` | A grid item in the block direction | Grid items |'
  prefs: []
  type: TYPE_TB
- en: '| `justify-content` | The entire grid in the inline direction | Grid container
    |'
  prefs: []
  type: TYPE_TB
- en: '| `justify-items` | All grid items in the inline direction | Grid container
    |'
  prefs: []
  type: TYPE_TB
- en: '| `justify-self` | A grid item in the inline direction | Grid items |'
  prefs: []
  type: TYPE_TB
- en: '| `place-content` | The entire grid in both the block and inline directions
    | Grid container |'
  prefs: []
  type: TYPE_TB
- en: '| `place-items` | All grid items in both the block and inline directions |
    Grid container |'
  prefs: []
  type: TYPE_TB
- en: '| `place-self` | A grid item in both the block and inline directions | Grid
    items |'
  prefs: []
  type: TYPE_TB
- en: As [Table 12-1](#grid_layout_properties) shows, the various `justify-*` properties
    change alignment along the inline axis—in English, this will be the horizontal
    direction. The difference is whether a property applies to a single grid item,
    all the grid items in a grid, or the entire grid. Similarly, the `align-*` properties
    affect alignment along the block axis; in English, this is the vertical direction.
    The `place-*` properties, on the other hand, are shorthands that apply in both
    the block and inline directions.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning and Justifying Individual Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s easiest to start with the `*-self` properties, because we can have one
    grid show various `justify-self` property values, while a second grid shows the
    effects of those same values when used by `align-self`. (See [Figure 12-71](#self_alignment_in_the_inline_and_block_directions).)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1271.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-71\. Self-alignment in the inline and block directions
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each grid item in [Figure 12-71](#self_alignment_in_the_inline_and_block_directions)
    is shown with its grid area (the dashed line) and a label identifying the property
    value that’s applied to it. Each deserves a bit of commentary.
  prefs: []
  type: TYPE_NORMAL
- en: First, though, realize that for all of these values, any element that doesn’t
    have an explicit `width` or `height` will “shrink-wrap” its content, instead of
    using the default grid-item behavior of filling out the entire grid area.
  prefs: []
  type: TYPE_NORMAL
- en: The `start` and `end` values cause the grid item to be aligned to the start
    or end edge of its grid area, which makes sense. Similarly, `center` centers the
    grid item within its area along the alignment axis, *without* the need to declare
    margins or any other properties, including `height` and `width`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `left` and `right` values cause the item to be aligned to the left or right
    edge of the grid area when the inline axis is horizontal, as shown in [Figure 12-71](#self_alignment_in_the_inline_and_block_directions).
    If the inline axis is vertical, as in `writing-mode: vertical-rl`, items are aligned
    along the inline axis as if the inline axis were still horizontal; thus, in a
    top-to-bottom inline axis, `left` will align to the top of the grid area when
    `direction` is `ltr`, and to its bottom when `direction` is `rtl`. When applied
    to `align-self`, `left` and `right` are treated as if they were `stretch`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `self-start` and `self-end` values are more interesting. The `self-start`
    option aligns a grid item with the grid-area edge that corresponds to the grid
    *item’s* start edge. So in [Figure 12-71](#self_alignment_in_the_inline_and_block_directions),
    the `self-start` and `self-end` boxes are set to `direction: rtl`. That sets them
    to use RTL language direction, meaning their start edges are their right edges,
    and their end edges their left. You can see in the first grid this right-aligned
    `self-start` and left-aligned `self-end`. In the second grid, however, the RTL
    direction is irrelevant to block-axis alignment. Thus, `self-start` is treated
    as `start`, and `self-end` is treated as `end`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last value, `stretch`, is also interesting. To understand it, notice how
    the other boxes in each grid “shrink-wrap” themselves to their content, as if
    set to `max-content`. The `stretch` value, by contrast, directs the element to
    stretch from edge to edge in the given direction—`align-self: stretch` causes
    the grid item to stretch along the block axis, and `justify-self: stretch` causes
    inline-axis stretching. This is as you might expect, but bear in mind that it
    works only if the element’s size properties are set to `auto`. Thus, given the
    following styles, the first example will stretch vertically, but the second will
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Because the second example sets a `block-size` value that isn’t `auto` (which
    is the default value), that grid item cannot be resized by `stretch`. The same
    holds true for `justify-self` and `inline-size`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two more values that can be used to align grid items are sufficiently interesting
    to merit their own explanation. These permit the alignment of a grid item’s first
    or last baseline with the highest or lowest baseline in the grid track. For example,
    suppose you want a grid item to be aligned so the baseline of its last line is
    aligned with the last baseline in the tallest grid item sharing its row track.
    That would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, to align its first baseline with the lowest first baseline in the
    same row track, you’d say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: If a grid element doesn’t have a baseline, or it’s asked to baseline-align itself
    in a direction where baselines can’t be compared, `baseline` is treated as `start`,
    and `last-baseline` is treated as `end`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This section intentionally skips two values: `flex-start` and `flex-end`. These
    values are supposed to be used only in flexbox layout, and are defined to be equivalent
    to `start` and `end` in any other layout context, including grid layout.'
  prefs: []
  type: TYPE_NORMAL
- en: For a more detailed explanation of the values just discussed and how they cause
    items to interact, see [Chapter 11](ch11.html#flexbox).
  prefs: []
  type: TYPE_NORMAL
- en: The shorthand property `place-self` combines the two self-placement properties
    just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supplying one value for `place-self` means it’s copied to the second value
    as well. Thus, in each of the following pairs of declarations, the first declaration
    is equivalent to the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Because both of the individual properties `place-self` shorthands can accept
    baseline alignment values, supplying only one value causes both individual properties
    to be set to the same value. In other words, the following are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also supply two values, one for each of the individual properties the
    shorthand represents. So the following CSS shows rules that are equivalent to
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Aligning and Justifying All Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s consider `align-items` and `justify-items`. These properties accept
    all the same values you saw in the previous section plus a few more, and have
    the same effect, except they apply to all grid items in a given grid container,
    and must be applied to the grid container instead of to individual grid items.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, you could set all of the grid items in a grid to be center-aligned
    within their grid areas as follows, with a result like that depicted in [Figure 12-72](#centering_all_the_grid_items):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1272.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-72\. Centering all the grid items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, that rule horizontally *and* vertically centers every grid item
    within its given grid area. Furthermore, it causes any grid item without an explicit
    width and height to “shrink-wrap” its content rather than stretch out to fill
    its grid area, because of the way `center` is handled. If a grid item has an explicit
    inline or block size, those are honored instead of “shrink-wrapping” the content,
    and the item is still centered within its grid area.
  prefs: []
  type: TYPE_NORMAL
- en: For an overview of the effects of the various keyword values in the context
    of both `justify-items` and `align-items`, see [Figure 12-73](#grid-alignment-justify-items-both);
    the grid areas are represented with dashed lines, and the grid items are placed
    according to their alignment values.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1273.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-73\. The alignment of grid items within their grid cells
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Not illustrated in [Figure 12-73](#grid-alignment-justify-items-both), the `legacy`
    value is a new addition to grid alignment, and is essentially treated as `start`.
    (It exists to re-create the behaviors of HTML’s ancient `<CENTER>` element and
    `align` attribute, neither of which is relevant in a grid context.)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For an exploration of what `safe` and `unsafe` mean in terms of items overflowing
    their container, see [Chapter 11](ch11.html#flexbox).
  prefs: []
  type: TYPE_NORMAL
- en: The shorthand property `place-items` combines the two item-placement properties
    just discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way `place-items` works is very similar to the `place-self` property discussed
    previously in the chapter. If one value is given, it’s applied to both `align-items`
    and `justify-items`. If two values are given, the first is applied to `align-items`
    and the second to `justify-items`. Thus, the following rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Distributing Grid Items and Tracks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Beyond aligning and justifying every grid item, it’s possible to distribute
    the grid items, or even to justify or align the entire grid, using `align-content`
    and `justify-content`. A small set of distributive values is used for these properties.
    [Figure 12-74](#distributing_grid_items_horizontally) illustrates the effects
    of each value as applied to `justify-content`, with each grid sharing the following
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1274.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-74\. Distributing grid items along the inline axis
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In these cases, the set of grid tracks is taken as a single unit, and the items
    are then justified by the value of `justify-content`. That alignment does not
    affect the alignment of individual grid items; thus, you could end-justify the
    whole grid with `justify-content: end` while having individual grid items be left-,
    center-, or start-justified (among other options) within their grid areas.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This works just as well in column tracks as it does in row tracks, as [Figure 12-75](#distributing_grid_items_vertically)
    illustrates, as long as you switch to `align-content`. This time, the grids all
    share these styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1275.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-75\. Distributing grid items along the block axis
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The way these distributions work is that the grid tracks, including any gutters,
    are all sized as usual. Then, if any space is left over beyond the grid tracks
    and gutters—that is, if the grid tracks don’t reach all the way from one edge
    of the grid container to the other—then the remaining space is distributed according
    to the value of `justify-content` (in the inline axis) or `align-content` (in
    the block axis).
  prefs: []
  type: TYPE_NORMAL
- en: This space distribution is carried out by resizing the grid gutters. If no gutters
    are declared, they will be created. If gutters already exist, their sizes are
    altered as required to distribute the grid tracks as specified.
  prefs: []
  type: TYPE_NORMAL
- en: Note that because space is distributed only when the tracks don’t fill out the
    grid container, the gutters can only increase in size. If the tracks are larger
    than the container, which can easily happen, there is no leftover space to distribute
    (negative space turns out to be indivisible).
  prefs: []
  type: TYPE_NORMAL
- en: 'One more distribution value wasn’t shown in the previous figures: `stretch`.
    This value takes any leftover space and applies it equally to the grid tracks,
    not the gutters. So if we have 400 pixels of leftover space and 8 grid tracks,
    each grid track is increased by 50 pixels. The grid tracks are *not* increased
    proportionally, but equally. As of late 2022, there is no browser support for
    this value in terms of grid distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Layering and Ordering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in a previous section, it’s entirely possible to have grid
    items overlap each other, whether because negative margins are used to pull a
    grid item beyond the edges of its grid area, or because the grid areas of two
    different grid items share grid cells. By default, the grid items will visually
    overlap in document source order: grid items later in the document source will
    appear above (or “in front of”) grid items earlier in the document source. Thus
    the following results in [Figure 12-76](#grid_items_overlapping) (assume the number
    in each class name represents the grid item’s source order):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1276.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-76\. Grid items overlapping in source order
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you want to assert your own stacking order, `z-index` is here to help. Just
    as in positioning, `z-index` places elements relative to one another on the z-axis,
    which is perpendicular to the display surface. Positive values are closer to you,
    and negative values further away. So to bring the second box to the “top,” as
    it were, all you need is to give it a `z-index` value higher than any other (with
    the result shown in [Figure 12-77](#elevating_a_grid_item)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '![image](assets/css5_1277.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-77\. Elevating a grid item
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another way you can affect the ordering of grid items is by using the `order`
    property. Its effect is essentially the same as it is in flexbox—you can change
    the order of grid items within a grid track by giving them `order` values. This
    affects not only placement within the track, but also *paint order* if they should
    overlap. For example, we could change the previous example from `z-index` to `order`,
    as shown here, and get the same result shown in [Figure 12-77](#elevating_a_grid_item):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `box02` appears “on top of” the other grid items because its order
    places it after the rest of them. Thus, it’s drawn last. Similarly, if those grid
    items were all placed in sequence in a grid track, the `order` value for `box02`
    would put it at the end of the sequence. This is depicted in [Figure 12-78](#changing_grid_item_order).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/css5_1278.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12-78\. Changing grid-item order
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember that just because you *can* rearrange the order of grid items this
    way doesn’t necessarily mean you *should*. As the [Grid Layout specification](https://www.w3.org/TR/css-grid-1/#order-property)
    says:'
  prefs: []
  type: TYPE_NORMAL
- en: As with reordering flex items, the `order` property must only be used when the
    visual order needs to be *out-of-sync* with the speech and navigation order; otherwise
    the underlying document source should be reordered instead.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: So the only reason to use `order` to rearrange grid-item layout is if you need
    to have the document source in one order and layout in the other. This is already
    easily possible by assigning grid items to areas that don’t match source order.
  prefs: []
  type: TYPE_NORMAL
- en: This is not to say that `order` is useless and should always be shunned; there
    may well be times it makes sense. But unless you find yourself nearly forced into
    using it by specific circumstances, think very hard about whether it’s the best
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For a formal definition of the `order` property, see [Chapter 11](ch11.html#flexbox).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Grid layout is complex and powerful, so don’t be discouraged if you feel overwhelmed
    at first. It takes some time to get used to the way grid operates, especially
    because so many of its features are nothing like what we’ve dealt with before.
    Much of those features’ power comes directly from their novelty—but like any powerful
    tool, grid layout can be difficult and frustrating to learn to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We hope we were able to steer you past some of those pitfalls, but still, remember
    the wisdom of Master Yoda: “You must unlearn what you have learned.” When coming
    to grid layout, there has never been greater need to put aside what you think
    you know about layout and learn anew. Over time, your patience and persistence
    will be rewarded.'
  prefs: []
  type: TYPE_NORMAL
