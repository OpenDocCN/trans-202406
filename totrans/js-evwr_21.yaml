- en: Chapter 20\. Electron Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first time I taught a programming course, I came up with the clever idea
    of introducing the course topics through a text adventure game. Students would
    come into the lab, sit down at a desk, and walk through a series of hilarious
    (to me) prompts and instructions. This was met with mixed reactions, not because
    of the jokes (well, maybe because of the jokes), but because students had not
    interacted with a “program” in this way. The students were accustomed to a GUI
    (graphic user interface), and interacting with a program through text prompts
    felt *wrong* to many of them.
  prefs: []
  type: TYPE_NORMAL
- en: Presently, to run our application we need to type a prompt in our terminal application
    to start the Electron process. In this chapter, we’ll look at how we can bundle
    our application for distribution. To achieve this, we’ll be using the popular
    [Electron Builder](https://www.electron.build) library, which will help us package
    and distribute our application to our users.
  prefs: []
  type: TYPE_NORMAL
- en: Electron Builder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Electron Builder is a library designed to simplify the packaging and distribution
    of Electron and [Proton Native](https://proton-native.js.org) applications. While
    there are other packaging solutions, Electron Builder simplifies a number of pain
    points associated with application distribution, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Code signing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplatform distribution targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoupdates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers a great balance between flexibility and features. Additionally, though
    we won’t be making use of them, there are several Electron Builder boilerplates
    for [Webpack](https://oreil.ly/faYta), [React](https://oreil.ly/qli_e), [Vue](https://oreil.ly/9QY2W),
    and [Vanilla JavaScript](https://oreil.ly/uJo7e).
  prefs: []
  type: TYPE_NORMAL
- en: Electron Builder Versus Electron Forge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Electron Forge](https://www.electronforge.io) is another popular library that
    offers many similar features to Electron Builder. A primary advantage of Electron
    Forge is that it is based on official Electron libraries, while Electron Builder
    is an independent build tool. This means that users benefit from the growth of
    the Electron ecosystem. The downside is that Electron Forge is based on a much
    more rigid application setup. For the purposes of this book, Electron Builder
    provides the right balance of features and learning opportunities, but I encourage
    you to take a close look at Electron Forge as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Electron Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All of the configuration of Electron Builder will take place in our application’s
    *package.json* file. In that file we can see that `electron-builder` is already
    listed as a development dependency. Within the *package.json* file we can include
    a key, called `"build"`, which will contain all of the instructions to Electron
    Builder for packaging our app. To begin, we will include two fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appId`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a unique identifier for our application. macOS calls the concept [`CFBundle`​`Identifier`](https://oreil.ly/OOg1O)
    and Windows terms it the [`AppUser`​`ModelID`](https://oreil.ly/mr9si). The standard
    is to use the reverse DNS format. For example, if we run a company with a domain
    of *jseverywhere.io* and build an application named Notedly, the ID would be `io.jseverywhere.notedly`.
  prefs: []
  type: TYPE_NORMAL
- en: '`productName`'
  prefs: []
  type: TYPE_NORMAL
- en: This is the human-readable version of our product’s name, as the `package.json`
    `name` field requires hyphenated or single-word names.
  prefs: []
  type: TYPE_NORMAL
- en: 'All together, our beginning build configuration will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Electron Builder provides us with many configuration options, several of which
    we’ll be exploring throughout this chapter. For the complete list, visit the [Electron
    Builder docs](https://oreil.ly/ESAx-).
  prefs: []
  type: TYPE_NORMAL
- en: Build for Our Current Platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our minimal configuration in place, we can create our first application
    build. By default, Electron Builder will produce a build for the system we are
    developing on. For example, since I am writing this on a MacBook, my build will
    default to macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first add two scripts to our *package.json* file, which will be responsible
    for application builds. First, a `pack` script will generate a package directory,
    without fully packaging the app. This can be useful for testing purposes. Second,
    a `dist` script will package the application in distributable format, such as
    a macOS DMG, Windows installer, or DEB package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With this change, you can run `npm run dist` in your terminal application, which
    will package the application in the project’s *dist/* directory. Navigating to
    the *dist/* directory, you can see that Electron Builder has packaged the application
    for distribution for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: App Icons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that you have likely noticed is that our application is using the
    default Electron app icon. This is fine for local development, but for a production
    application we will want to use our own branding. In our project’s */resources*
    folder, I have included some application icons for both macOS and Windows. To
    generate these icons from a PNG file, I used the [iConvert Icons application](https://iconverticons.com),
    which is available for both macOS and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our */resources* folder you will see the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '*icon.icns*, the macOS application icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*icon.ico*, the Windows application icon'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *icons* directory with a series of different-sized *.png* files, used by
    Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, we could also include background images for the macOS DMG by adding
    icons with the names of *background.png* and *background@2x.png*, for retina screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now within our *package.json* file, we update the `build` object to specify
    the name of the build resource directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we build the application, Electron Builder will package it with our
    custom application icons (see [Figure 20-1](#dock_icon)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the macOS dock icon](assets/jsev_2001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 20-1\. Our custom application icon in the macOS dock
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Building for Multiple Platforms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, we’re only building our application for the operating system that
    matches our development platform. One of the great advantages of Electron as a
    platform is that it allows us to use the same code to target multiple platforms,
    by updating our `dist` script. To achieve this, Electron Builder makes use of
    the free and open source [`electron-build-service`](https://oreil.ly/IEIfW). We’ll
    be using the public instance of this service, but it is possible to self-host
    it for organizations seeking additional security and privacy.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `package.json` update the `dist` script to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will result in a build that targets macOS, Windows, and Linux. From here
    we can distribute our application by uploading it as a release to GitHub or anywhere
    that we can distribute files, such as Amazon S3 or our web server.
  prefs: []
  type: TYPE_NORMAL
- en: Code Signing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both macOS and Windows include the concept of *code signing*. Code signing is
    a boost for the security and trust of users, as it helps signify the trustworthiness
    of the app. I won’t be walking through the code-signing process, as it is operating
    system specific and comes at a cost to developers. The Electron Builder documentation
    offers a [comprehensive article](https://oreil.ly/g6wEz) on code signing for various
    platforms. Additionally, the [Electron documentation](https://oreil.ly/Yb4JF)
    offers several resources and links. If you are building a production application,
    I encourage you to further research the code-signing options for macOS and Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve covered the tip of the iceberg for deploying an Electron application.
    In this chapter we used Electron Builder to build our applications. We can then
    easily upload and distribute them through any web host. Once we have outgrown
    these needs, we can use Electron Builder to integrate builds into a continuous
    delivery pipeline; automatically push releases to GitHub, S3, or other distribution
    platforms; and integrate automatic updates into the application. If you are interested
    in further exploring the topics of Electron development and app distribution,
    these are fantastic next steps to take.
  prefs: []
  type: TYPE_NORMAL
