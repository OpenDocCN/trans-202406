<html><head></head><body><section data-pdf-bookmark="Chapter 11. Policy and Governance for Your Cluster" data-type="chapter" epub:type="chapter"><div class="chapter" id="policy_and_governance_for_your_cluster">&#13;
<h1><span class="label">Chapter 11. </span>Policy and Governance for Your Cluster</h1>&#13;
&#13;
&#13;
<p>Have you ever wondered how you might ensure that all containers running on a cluster come only from an approved container registry? Or maybe you’ve been asked by the security team to enforce a policy that services are never exposed to the internet. These are precisely the challenges that policy and governance for your cluster set out to address. As Kubernetes continues to mature and becomes adopted by more enterprises, the question of how to apply policy and governance to Kubernetes resources is increasing in frequency. In this chapter we share what you can&#13;
do and the tools to use to make sure that your cluster is in compliance with the defined policies, whether you work at a startup or an enterprise.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Policy and Governance Are Important" data-type="sect1"><div class="sect1" id="id217">&#13;
<h1>Why Policy and Governance Are Important</h1>&#13;
&#13;
<p>Whether you <a data-primary="policy and governance" data-secondary="importance of" data-type="indexterm" id="id816"/><a data-primary="governance" data-see="policy and governance" data-type="indexterm" id="id817"/>operate in a highly regulated environment—for example,&#13;
health care or financial services—or you simply want to make sure that you&#13;
maintain a level of control over what’s running on your clusters, you’re&#13;
going to need a way to implement the company-specific policies. Once your policy is defined, you will need to determine how to implement&#13;
it and maintain clusters that are compliant to these policies. These&#13;
policies may be required to meet regulatory compliance or simply to&#13;
enforce best practices. Whatever the reason, you must be sure that you do&#13;
not sacrifice developer agility and self-service when implementing these&#13;
policies.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Is This Policy Different?" data-type="sect1"><div class="sect1" id="id218">&#13;
<h1>How Is This Policy Different?</h1>&#13;
&#13;
<p>In Kubernetes, <a data-primary="policy and governance" data-secondary="purpose of" data-type="indexterm" id="id818"/>policy is everywhere. Whether it be network policy or pod&#13;
security, we’ve all come to understand what policy is and when to&#13;
use it. We trust that whatever is declared in Kubernetes resource&#13;
specifications is implemented as per the policy definition. Both network&#13;
policy and pod security are implemented at runtime. However, what policy&#13;
restricts the field values in these <span class="keep-together">Kubernetes</span> resource&#13;
specifications? That’s the job of policy and governance. Rather than&#13;
implementing policy at runtime, when we talk about policy in the context&#13;
of governance, what we mean (or at least what we are trying to achieve) is the ability to limit the way fields are configured in Kubernetes resources. Only Kubernetes resource specifications that are compliant when evaluated by policies are allowed and committed to the <span class="keep-together">cluster state.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cloud Native Policy Engine" data-type="sect1"><div class="sect1" id="id93">&#13;
<h1>Cloud Native Policy Engine</h1>&#13;
&#13;
<p>To be<a data-primary="policy and governance" data-secondary="cloud native policy engine" data-type="indexterm" id="id819"/><a data-primary="cloud native policy engine" data-type="indexterm" id="id820"/><a data-primary="OPA (Open Policy Agent)" data-type="indexterm" id="id821"/> able to evaluate which resources are&#13;
compliant, we need a policy engine that is flexible enough to meet a&#13;
variety of needs. <a href="https://oreil.ly/xzN2p">The Open Policy Agent (OPA)</a> is an open source, flexible, lightweight policy engine that has&#13;
become increasingly popular in the cloud native ecosystem. Having OPA in&#13;
the ecosystem has allowed many implementations of different Kubernetes&#13;
governance tools to appear. One such Kubernetes policy and governance&#13;
project the community is rallying around is called&#13;
<a href="https://oreil.ly/RvKUw">Gatekeeper</a>. For the&#13;
rest of this chapter, we use Gatekeeper as the canonical example to&#13;
illustrate how you might achieve policy and governance for your cluster.&#13;
Although there are other implementations of policy and governance tools in&#13;
the ecosystem, they all seek to provide the same user experience (UX) by&#13;
allowing only compliant Kubernetes resource specifications to be committed to&#13;
the cluster.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Introducing Gatekeeper" data-type="sect1"><div class="sect1" id="id94">&#13;
<h1>Introducing Gatekeeper</h1>&#13;
&#13;
<p>Gatekeeper is<a data-primary="policy and governance" data-secondary="Gatekeeper" data-type="indexterm" id="id822"/><a data-primary="Gatekeeper" data-type="indexterm" id="id823"/> an open source, customizable Kubernetes admission webhook&#13;
for cluster policy and governance. Gatekeeper takes advantage of the OPA constraint framework to enforce custom resource definition (CRD)-based policies. Using CRDs&#13;
allows for an integrated Kubernetes experience that decouples policy&#13;
authoring from implementation. Policy templates are referred to<a data-primary="constraint templates" data-type="indexterm" id="id824"/> as&#13;
<em>constraint templates</em>, which can be shared and reused across clusters.&#13;
Gatekeeper enables resource validation and audit functionality. One of&#13;
the great things about Gatekeeper is that it’s portable, which means that you&#13;
can implement it on any Kubernetes clusters, and if you are already using&#13;
OPA, you might be able to port that policy over to&#13;
Gatekeeper.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Gatekeeper is a production-ready open source project. For the latest stable version, please visit the official <a href="https://oreil.ly/Rk8dc">upstream repository</a>.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Example Policies" data-type="sect2"><div class="sect2" id="id219">&#13;
<h2>Example Policies</h2>&#13;
&#13;
<p>Before diving<a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="example policies" data-type="indexterm" id="id825"/><a data-primary="Gatekeeper" data-secondary="example policies" data-type="indexterm" id="id826"/> into how to configure Gatekeeper, it’s important to keep&#13;
the problem we are trying to solve in focus. While every organization/team will need to optimize their policies for their needs, some fairly universal policies serve as best practices. Let’s look at some&#13;
policies that solve the most common compliance issues for&#13;
context:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Services must not be exposed publicly on the internet.</p>&#13;
</li>&#13;
<li>&#13;
<p>Allow containers only from trusted container registries.</p>&#13;
</li>&#13;
<li>&#13;
<p>All containers must have resource limits.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ingress hostnames must not overlap.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ingresses must use only HTTPS.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Gatekeeper Terminology" data-type="sect2"><div class="sect2" id="id220">&#13;
<h2>Gatekeeper Terminology</h2>&#13;
&#13;
<p>Gatekeeper <a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="terminology" data-type="indexterm" id="id827"/><a data-primary="Gatekeeper" data-secondary="terminology" data-type="indexterm" id="id828"/>has adopted much of the same terminology as OPA. It’s&#13;
important that we cover that terminology so you can&#13;
understand how Gatekeeper operates. Gatekeeper uses the OPA constraint&#13;
framework, which introduces three new terms:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Constraint</p>&#13;
</li>&#13;
<li>&#13;
<p>Rego</p>&#13;
</li>&#13;
<li>&#13;
<p>Constraint template</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space" data-pdf-bookmark="Constraint" data-type="sect3"><div class="sect3" id="id221">&#13;
<h3>Constraint</h3>&#13;
&#13;
<p>The <a data-primary="constraints" data-secondary="purpose of" data-type="indexterm" id="id829"/>best way to think about constraints is as restrictions that you&#13;
apply to specific fields and values of Kubernetes resource&#13;
specifications. This is really just a long way of saying policy. When constraints are defined, you are effectively stating&#13;
that you <em>DO NOT</em> want to allow this. The implications of this approach&#13;
mean that resources are implicitly allowed without a constraint that&#13;
issues a deny. This is an important nuance because rather then allowing the&#13;
Kubernetes resources specification fields and values you want, you are denying only the ones you <em>DO NOT</em> want. This architectural decision suits&#13;
Kubernetes resource specifications nicely because they are ever changing.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rego" data-type="sect3"><div class="sect3" id="id95">&#13;
<h3>Rego</h3>&#13;
&#13;
<p>Rego is <a data-primary="Rego" data-type="indexterm" id="id830"/>an OPA-native query language. Rego queries are assertions on the&#13;
data stored in OPA. Gatekeeper stores rego in the constraint template.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Constraint template" data-type="sect3"><div class="sect3" id="id96">&#13;
<h3>Constraint template</h3>&#13;
&#13;
<p>Think<a data-primary="constraint templates" data-type="indexterm" id="constraint-template"/> of this as a policy template. It’s portable and reusable.&#13;
Constraint templates consist of typed parameters and the target rego&#13;
that is parameterized for reuse.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Constraint Templates" data-type="sect2"><div class="sect2" id="id97">&#13;
<h2>Defining Constraint Templates</h2>&#13;
&#13;
<p>Constraint templates <a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="constraint templates" data-type="indexterm" id="policy-gatekeeper-template"/><a data-primary="Gatekeeper" data-secondary="constraint templates" data-type="indexterm" id="gatekeeper-template"/>are a <a href="https://oreil.ly/LQSAH">custom resource definition</a> (CRD) that provide a means of templating policy so that it can be shared or reused. In addition, parameters for the policy can be validated. Let’s look at a constraint template, from the upstream <a href="https://oreil.ly/HksnE">Gatekeeper policy library</a>, in the context of the earlier examples. In the following example, we share a constraint template that provides the policy “Only allow containers from trusted container registries”:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">templates.gatekeeper.sh/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConstraintTemplate</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8sallowedrepos</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata.gatekeeper.sh/title</code><code class="p">:</code><code class="w"> </code><code class="s">"Allowed</code><code class="nv"> </code><code class="s">Repositories"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata.gatekeeper.sh/version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1.0.0</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;-</code><code class="w"/>&#13;
<code class="w">      </code><code class="no">Requires container images to begin with a string from the specified list.</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">crd</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">names</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">K8sAllowedRepos</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">validation</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="c1"># Schema for the `parameters` field</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">openAPIV3Schema</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">object</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">properties</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">repos</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">description</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">The list of prefixes a container image is allowed to</code><code class="w"/>&#13;
<code class="w">                </code><code class="l-Scalar-Plain">have.</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">array</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">items</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">string</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">targets</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">target</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">admission.k8s.gatekeeper.sh</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">rego</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">package k8sallowedrepos</code><code class="w"/>&#13;
&#13;
<code class="w">        </code><code class="no">violation[{"msg": msg}] {</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">container := input.review.object.spec.containers[_]</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">satisfied := [good | repo = input.parameters.repos[_] ;</code><code class="w"/>&#13;
<code class="w">            </code><code class="no">good = startswith(container.image, repo)]</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">not any(satisfied)</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">msg := sprintf("container &lt;%v&gt; has an invalid image repo &lt;%v&gt;,</code><code class="w"/>&#13;
<code class="w">            </code><code class="no">allowed repos are %v",</code><code class="w"/>&#13;
<code class="w">             </code><code class="no">[container.name, container.image, input.parameters.repos])</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">}</code><code class="w"/>&#13;
&#13;
<code class="w">        </code><code class="no">violation[{"msg": msg}] {</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">container := input.review.object.spec.initContainers[_]</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">satisfied := [good | repo = input.parameters.repos[_] ;</code><code class="w"/>&#13;
<code class="w">            </code><code class="no">good = startswith(container.image, repo)]</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">not any(satisfied)</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">msg := sprintf("initContainer &lt;%v&gt; has an invalid image repo &lt;%v&gt;,</code><code class="w"/>&#13;
<code class="w">            </code><code class="no">allowed repos are %v",</code><code class="w"/>&#13;
<code class="w">             </code><code class="no">[container.name, container.image, input.parameters.repos])</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">}</code><code class="w"/>&#13;
&#13;
<code class="w">        </code><code class="no">violation[{"msg": msg}] {</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">container := input.review.object.spec.ephemeralContainers[_]</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">satisfied := [good | repo = input.parameters.repos[_] ;</code><code class="w"/>&#13;
<code class="w">            </code><code class="no">good = startswith(container.image, repo)]</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">not any(satisfied)</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">msg := sprintf("ephemeralContainer &lt;%v&gt; has an invalid image repo &lt;%v&gt;,</code><code class="w"/>&#13;
<code class="w">            </code><code class="no">allowed repos are %v",</code><code class="w"/>&#13;
<code class="w">             </code><code class="no">[container.name, container.image, input.parameters.repos])</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">}</code><code class="w"/></pre>&#13;
&#13;
<p>The constraint template consists of three main components:</p>&#13;
<dl>&#13;
<dt>Kubernetes-required CRD metadata</dt>&#13;
<dd>&#13;
<p>The name is the most important part. It’s best practice to make it descriptive enough to easily identify the purpose of the policy. We reference this later.</p>&#13;
</dd>&#13;
<dt>Schema for input parameters</dt>&#13;
<dd>&#13;
<p>Indicated by the validation field, this section defines the input parameters and their associated types. In this example, we have a single parameter called <code>repos</code> that is an array of strings.</p>&#13;
</dd>&#13;
<dt>Policy definition</dt>&#13;
<dd>&#13;
<p>Indicated by the <code>target</code> field, this section contains templated rego (the language to define policy in OPA). Using a constraint template allows the templated rego to be reused and means that generic policy can be shared. If the rule matches, the constraint is <a data-primary="constraint templates" data-startref="constraint-template" data-type="indexterm" id="id831"/><a data-primary="policy and governance" data-secondary="Gatekeeper" data-startref="policy-gatekeeper-template" data-tertiary="constraint templates" data-type="indexterm" id="id832"/><a data-primary="Gatekeeper" data-secondary="constraint templates" data-startref="gatekeeper-template" data-type="indexterm" id="id833"/>violated.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining Constraints" data-type="sect2"><div class="sect2" id="id222">&#13;
<h2>Defining Constraints</h2>&#13;
&#13;
<p>To use<a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="constraints" data-type="indexterm" id="policy-gatekeeper-constraint"/><a data-primary="Gatekeeper" data-secondary="constraints" data-type="indexterm" id="gatekeeper-constraint"/><a data-primary="constraints" data-secondary="defining" data-type="indexterm" id="constraint"/> the previous constraint template, we must create a&#13;
constraint resource. The purpose of the constraint resource is to&#13;
provide the necessary parameters to the constraint template that we&#13;
created earlier. You can see that the <code>kind</code> of the resource defined in the following example&#13;
is <code>K8sAllowedRepos</code>, which maps to the constraint template defined in&#13;
the previous section:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">constraints.gatekeeper.sh/v1beta1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">K8sAllowedRepos</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prod-repo-is-openpolicyagent</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">enforcementAction</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">deny</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">match</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">kinds</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">kinds</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"Pod"</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">namespaces</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"production"</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">parameters</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">repos</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"openpolicyagent/"</code><code class="w"/></pre>&#13;
&#13;
<p>The constraint consists of two main sections:</p>&#13;
<dl>&#13;
<dt>Kubernetes metadata</dt>&#13;
<dd>&#13;
<p>Notice that this constraint is of <code>kind K8sAllowedRepos</code>, which matches the name of the constraint template.</p>&#13;
</dd>&#13;
<dt>The spec</dt>&#13;
<dd>&#13;
<p>The <code>match</code> field defines the scope of intent for the policy. In this example, we are matching pods only in the production namespace.</p>&#13;
&#13;
<p>The parameters define the intent for the policy. Notice that they match the type from the constraint template schema from the previous section. In this case, we allow only container images that start with <code>openpolicyagent/</code>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Constraints have the following operational characteristics:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Logical AND</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>When multiple policies validate the same field, if one violates then the whole request is rejected</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Schema validation that allows early error detection</p>&#13;
</li>&#13;
<li>&#13;
<p>Selection criteria</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Can use label selectors</p>&#13;
</li>&#13;
<li>&#13;
<p>Constrain only certain kinds</p>&#13;
</li>&#13;
<li>&#13;
<p>Constrain only in certain <a data-primary="policy and governance" data-secondary="Gatekeeper" data-startref="policy-gatekeeper-constraint" data-tertiary="constraints" data-type="indexterm" id="id834"/><a data-primary="Gatekeeper" data-secondary="constraints" data-startref="gatekeeper-constraint" data-type="indexterm" id="id835"/><a data-primary="constraints" data-secondary="defining" data-startref="constraint" data-type="indexterm" id="id836"/>namespaces</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Replication" data-type="sect2"><div class="sect2" id="data_replication">&#13;
<h2>Data Replication</h2>&#13;
&#13;
<p>In some <a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="data replication" data-type="indexterm" id="id837"/><a data-primary="Gatekeeper" data-secondary="data replication" data-type="indexterm" id="id838"/><a data-primary="data replication" data-type="indexterm" id="id839"/>cases, you might want to compare the current resource against&#13;
other resources that are in the cluster, for example, in the case of&#13;
“Ingress hostnames must not overlap.” OPA needs to have all the other&#13;
Ingress resources in its cache in order to evaluate the rule.&#13;
Gatekeeper uses a <code>config</code> resource to manage which data is cached in OPA&#13;
in order to perform evaluations such as the one previously mentioned. In&#13;
addition, <code>config</code> resources are also used in the audit functionality, which we explore a bit later on.</p>&#13;
&#13;
<p>The following example <code>config</code> resource caches v1 service, pods, and&#13;
namespaces:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config.gatekeeper.sh/v1alpha1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Config</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config</code><code class="w"/>&#13;
<code class="w">  </code><code class="l-Scalar-Plain">namespace</code><code class="p-Indicator">:</code><code class="w"> </code><code class="l-Scalar-Plain">gatekeeper-system</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">sync</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">syncOnly</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Service</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Namespace</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="UX" data-type="sect2"><div class="sect2" id="user_x">&#13;
<h2>UX</h2>&#13;
&#13;
<p>Gatekeeper <a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="violation feedback" data-type="indexterm" id="id840"/><a data-primary="Gatekeeper" data-secondary="violation feedback" data-type="indexterm" id="id841"/>enables real-time feedback to cluster users for resources&#13;
that violate defined policy. If we consider the example from the&#13;
previous sections, we allow containers only from repositories that start&#13;
with <code>openpolicyagent/</code>.</p>&#13;
&#13;
<p>Let’s try to create the following resource; it is not compliant given&#13;
the current policy:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">opa</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">production</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">opa</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">quay.io/opa:0.9.2</code><code class="w"/></pre>&#13;
&#13;
<p>This gives you the violation message that’s defined in the constraint template:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">$<code class="w"> </code>kubectl<code class="w"> </code>create<code class="w"> </code>-f<code class="w"> </code>bad_resources/opa_wrong_repo.yaml<code class="w"/>&#13;
Error<code class="w"> </code>from<code class="w"> </code>server<code class="w"> </code><code class="o">(</code>Forbidden<code class="o">)</code>:<code class="w"> </code>error<code class="w"> </code>when<code class="w"> </code>creating<code class="w"> </code><code class="s2">"STDIN"</code>:<code class="w"> </code>admission<code class="w"> </code>webhook<code class="w"/>&#13;
<code class="w">  </code><code class="s2">"validation.gatekeeper.sh"</code><code class="w"> </code>denied<code class="w"> </code>the<code class="w"> </code>request:<code class="w"> </code><code class="o">[</code>repo-is-openpolicyagent<code class="o">]</code><code class="w"/>&#13;
<code class="w">    </code>container<code class="w"> </code>&lt;opa&gt;<code class="w"> </code>has<code class="w"> </code>an<code class="w"> </code>invalid<code class="w"> </code>image<code class="w"> </code>repo<code class="w"> </code>&lt;quay.io/opa:0.9.2&gt;,<code class="w"> </code>allowed<code class="w"/>&#13;
<code class="w">      </code>repos<code class="w"> </code>are<code class="w"> </code><code class="o">[</code><code class="s2">"openpolicyagent/"</code><code class="o">]</code><code class="w"/></pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Enforcement Action and Audit" data-type="sect1"><div class="sect1" id="id99">&#13;
<h1>Using Enforcement Action and Audit</h1>&#13;
&#13;
<p>Thus far,<a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="enforcement actions/audit" data-type="indexterm" id="policy-gatekeeper-enforce"/><a data-primary="Gatekeeper" data-secondary="enforcement actions/audit" data-type="indexterm" id="gatekeeper-enforcement"/><a data-primary="enforcement actions" data-type="indexterm" id="enforce-action"/> we have discussed only how to define policy and have it&#13;
enforced as part of the request admission process. Constraints include the ability to configure an <code>enforcementAction</code>, which by default is set to <code>deny</code>. In addition to <code>deny</code>, <code>enforcementAction</code> also allows accepted values of <code>warn</code> and <code>dryrun</code>. When we think about rolling out policy, it’s not always the case that you are applying to a cluster or namespace without resources already deployed. It’s therefore important to understand how to deploy policy to a cluster that already has resources deployed with the confidence that you can identify and remediate policy violations without necessarily breaking deployed workloads. The <code>enforcementAction</code> field allows you to define the behavior. When set to <code>deny</code>, a resource that violates policy will not be created and an error message will both be audit logged and sent back to the user. If set to <code>warn</code>, the resource will be created; however, a warning message will be audit logged and sent back to the user. Finally, if <code>dryrun</code> is set, the resource will be created and resources that violate the policy will be available in the audit log.</p>&#13;
&#13;
<p>Whatever <code>enforcementAction</code> you decide to use, Gatekeeper will periodically evaluate resources against any configured policy and provide an audit log. This helps with the detection&#13;
of misconfigured resources according to policy and allows for&#13;
remediation. The audit results are stored in the status field of the&#13;
constraint, making them easy to find by simply using <code>kubectl</code>. To use audit, the resources to be audited must be replicated. For more details, refer to <a data-type="xref" href="#data_replication">“Data Replication”</a>.</p>&#13;
&#13;
<p>Let’s look at the constraint called <code>prod-repo-is-openpolicyagent</code>&#13;
that you defined in the previous section. In this case, imagine we already had a pod called nginx running in the&#13;
production namespace and we would like to check its compliance to the policy using audit:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>k8sallowedrepos<code class="w"/>&#13;
NAME<code class="w">                           </code>ENFORCEMENT-ACTION<code class="w">   </code>TOTAL-VIOLATIONS<code class="w"/>&#13;
prod-repo-is-openpolicyagent<code class="w">   </code>deny<code class="w">                 </code><code class="m">1</code><code class="w"/>&#13;
&#13;
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>k8sallowedrepos<code class="w"> </code>prod-repo-is-openpolicyagent<code class="w"> </code>-o<code class="w"> </code>yaml<code class="w"/>&#13;
apiVersion:<code class="w"> </code>constraints.gatekeeper.sh/v1beta1<code class="w"/>&#13;
kind:<code class="w"> </code>K8sAllowedRepos<code class="w"/>&#13;
metadata:<code class="w"/>&#13;
<code class="w">  </code>annotations:<code class="w"/>&#13;
<code class="w">    </code>kubectl.kubernetes.io/last-applied-configuration:<code class="w"> </code>...<code class="w"/>&#13;
<code class="w">  </code>creationTimestamp:<code class="w"> </code><code class="s2">"..."</code><code class="w"/>&#13;
<code class="w">  </code>generation:<code class="w"> </code><code class="m">1</code><code class="w"/>&#13;
<code class="w">  </code>name:<code class="w"> </code>prod-repo-is-openpolicyagent<code class="w"/>&#13;
<code class="w">  </code>resourceVersion:<code class="w"> </code><code class="s2">"..."</code><code class="w"/>&#13;
<code class="w">  </code>uid:<code class="w"> </code>...<code class="w"/>&#13;
spec:<code class="w"/>&#13;
<code class="w">  </code>match:<code class="w"/>&#13;
<code class="w">    </code>kinds:<code class="w"/>&#13;
<code class="w">    </code>-<code class="w"> </code>apiGroups:<code class="w"/>&#13;
<code class="w">      </code>-<code class="w"> </code><code class="s2">""</code><code class="w"/>&#13;
<code class="w">      </code>kinds:<code class="w"/>&#13;
<code class="w">      </code>-<code class="w"> </code>Pod<code class="w"/>&#13;
<code class="w">    </code>namespaces:<code class="w"/>&#13;
<code class="w">    </code>-<code class="w"> </code>production<code class="w"/>&#13;
<code class="w">  </code>parameters:<code class="w"/>&#13;
<code class="w">    </code>repos:<code class="w"/>&#13;
<code class="w">    </code>-<code class="w"> </code>openpolicyagent/<code class="w"/>&#13;
status:<code class="w"/>&#13;
<code class="w">  </code>auditTimestamp:<code class="w"> </code><code class="s2">"2022-11-27T23:37:42Z"</code><code class="w"/>&#13;
<code class="w">  </code>totalViolations:<code class="w"> </code><code class="m">1</code><code class="w"/>&#13;
<code class="w">  </code>violations:<code class="w"/>&#13;
<code class="w">  </code>-<code class="w"> </code>enforcementAction:<code class="w"> </code>deny<code class="w"/>&#13;
<code class="w">    </code>group:<code class="w"> </code><code class="s2">""</code><code class="w"/>&#13;
<code class="w">    </code>kind:<code class="w"> </code>Pod<code class="w"/>&#13;
<code class="w">    </code>message:<code class="w"> </code>container<code class="w"> </code>&lt;nginx&gt;<code class="w"> </code>has<code class="w"> </code>an<code class="w"> </code>invalid<code class="w"> </code>image<code class="w"> </code>repo<code class="w"> </code>&lt;nginx&gt;,<code class="w"> </code>allowed<code class="w"> </code>repos<code class="w"/>&#13;
<code class="w">      </code>are<code class="w"> </code><code class="o">[</code><code class="s2">"openpolicyagent/"</code><code class="o">]</code><code class="w"/>&#13;
<code class="w">    </code>name:<code class="w"> </code>nginx<code class="w"/>&#13;
<code class="w">    </code>namespace:<code class="w"> </code>production<code class="w"/>&#13;
<code class="w">    </code>version:<code class="w"> </code>v1<code class="w"/></pre>&#13;
&#13;
<p>Upon inspection, you can see the last time the audit ran in the&#13;
<code>auditTimestamp</code> field. We also see all the resources that violate this&#13;
constraint, only the nginx pod in this case, under the <code>violations</code> along <a data-primary="policy and governance" data-secondary="Gatekeeper" data-startref="policy-gatekeeper-enforce" data-tertiary="enforcement actions/audit" data-type="indexterm" id="id842"/><a data-primary="Gatekeeper" data-secondary="enforcement actions/audit" data-startref="gatekeeper-enforcement" data-type="indexterm" id="id843"/><a data-primary="enforcement actions" data-startref="enforce-action" data-type="indexterm" id="id844"/>with the <code>enforcementAction</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mutation" data-type="sect2"><div class="sect2" id="id100">&#13;
<h2>Mutation</h2>&#13;
&#13;
<p>In addition<a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="mutation policies" data-type="indexterm" id="id845"/><a data-primary="Gatekeeper" data-secondary="mutation policies" data-type="indexterm" id="id846"/><a data-primary="mutation policies" data-type="indexterm" id="id847"/> to resource validation, Gatekeeper also allows you to configure mutation policies. Mutation policies allow you to modify Kubernetes resources at admission time. Generally, mutating resources at admission time is not considered best practice. Having resources “magically” modified by Gatekeeper is a cloud native antipattern as this is counter to the declarative nature of Kubernetes. Mutation policies are simply mentioned here to provide guidance to avoid them unless you feel your use case absolutely requires them and that you have exhausted other best practices. Refer to <a data-type="xref" href="ch18.html#gitops">Chapter 18</a> for more details on how to implement declarative best practices for Kubernetes resources.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing Policies" data-type="sect2"><div class="sect2" id="id224">&#13;
<h2>Testing Policies</h2>&#13;
&#13;
<p>As the<a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="testing policies" data-type="indexterm" id="id848"/><a data-primary="Gatekeeper" data-secondary="testing policies" data-type="indexterm" id="id849"/><a data-primary="testing" data-secondary="policies" data-type="indexterm" id="id850"/> GitOps philosophy has become widely adopted, testing policy and evaluation as part of local testing or CI/CD pipelines has become a must have. Gatekeeper ships with a <code>gator</code> CLI that enables you to take the constraint templates and constraints and run a local evaluation. This is a great tool for building new policies, testing them against your resources, and remediating any issues prior to deploying them to your production clusters. The <a href="https://oreil.ly/Qj4p8">Gatekeeper documentation</a> provides a practical guide to using the <code>gator</code> CLI to test policy.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Becoming Familiar with Gatekeeper" data-type="sect2"><div class="sect2" id="id225">&#13;
<h2>Becoming Familiar with Gatekeeper</h2>&#13;
&#13;
<p>If you’d like<a data-primary="policy and governance" data-secondary="Gatekeeper" data-tertiary="demonstration" data-type="indexterm" id="id851"/><a data-primary="Gatekeeper" data-secondary="demonstration" data-type="indexterm" id="id852"/> to explore Gatekeeper further, the repository ships with fantastic demonstration content that walks you through a detailed example of building policies to meet compliance for a bank. We would strongly recommend walking through the demonstration for a hands-on approach to how Gatekeeper operates. You can find the demonstration in <a href="https://oreil.ly/GcR3i">this Git repository</a>. Gatekeeper also maintains a <a href="https://oreil.ly/e8ESD">public library</a> of policies that you can apply to your cluster with easy installation guidance via <a href="https://oreil.ly/uEcfn">ArtifactHub</a>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Policy and Governance Best Practices" data-type="sect1"><div class="sect1" id="id226">&#13;
<h1>Policy and Governance Best Practices</h1>&#13;
&#13;
<p>You<a data-primary="policy and governance" data-secondary="best practices" data-type="indexterm" id="policy-best-practice"/><a data-primary="best practices" data-secondary="policy and governance" data-type="indexterm" id="best-practice-policy"/> should consider the following best practices when implementing policy and governance on your clusters:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If you want to enforce a specific field in a pod, you need to determine which Kubernetes resource specification you want to&#13;
inspect and enforce. Let’s consider the case of Deployments, for example.&#13;
Deployments manage ReplicaSets, which manage pods. We could enforce at&#13;
all three levels, but the best choice is the one that is the lowest&#13;
handoff point before the runtime, which in this case is the pod. This decision,&#13;
however, has implications. The user-friendly error message when we try to deploy a&#13;
noncompliant pod, as seen in <a data-type="xref" href="#user_x">“UX”</a>, is not going to be displayed. This is because the&#13;
user is not creating the noncompliant resource, the ReplicaSet is. This&#13;
experience means that the user would need to determine that the resource&#13;
is not compliant by running a <code>kubectl describe</code> on the current&#13;
ReplicaSet associated with the Deployment. Although this might seem&#13;
cumbersome, this is consistent behavior with other Kubernetes features,&#13;
such as pod security.</p>&#13;
</li>&#13;
<li>&#13;
<p>Constraints can be applied to Kubernetes resources on the following&#13;
criteria: kinds, namespaces, and label selectors. We would strongly&#13;
recommend scoping the constraint to the resources to which you want it to&#13;
be applied as tightly as possible. This ensures consistent policy&#13;
behavior as the resources on the cluster grow, and means that resources&#13;
that don’t need to be evaluated aren’t being passed to OPA, which can result in&#13;
other inefficiencies.</p>&#13;
</li>&#13;
<li>&#13;
<p>On clusters with resources that are already deployed, utilize <code>warn</code> and <code>dryrun</code> along with audit to remediate resources&#13;
that violate policy before setting the <code>enforcementAction</code> to <code>deny</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Don’t use mutation policies; instead consider other declarative approaches, including GitOps.</p>&#13;
</li>&#13;
<li>&#13;
<p>Synchronizing and enforcing on potentially sensitive data such as Kubernetes&#13;
secrets is <em>not</em> recommended. Given that OPA will hold this in its cache&#13;
(if it is configured to replicate that data) and resources will be&#13;
passed to Gatekeeper, it leaves surface area for a potential attack&#13;
vector.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you have many constraints defined, a deny of constraint means that&#13;
the entire request is denied. There is no way to make this function as a&#13;
logical OR.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id366">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we covered why policy and governance are important&#13;
and walked through a project that’s built upon OPA, a cloud native&#13;
ecosystem policy engine, to provide a Kubernetes-native approach to&#13;
policy and governance. You should now be prepared and confident the&#13;
next time the security teams asks, “Are our clusters in compliance with our&#13;
defined policy?”</p>&#13;
</div></section>&#13;
</div></section></body></html>