<html><head></head><body><section data-pdf-bookmark="Chapter 5. Message Passing" data-type="chapter" epub:type="chapter"><div class="chapter" id="topic_message_passing">&#13;
<h1><span class="label">Chapter 5. </span>Message Passing</h1>&#13;
&#13;
&#13;
<p>Message passing<a data-primary="message passing" data-secondary="patterns and systems for" data-type="indexterm" id="idm46177236197832"/> is a very broad and sometimes contentious topic in computer science, and there are many patterns and systems that have come and gone or abided, like “pub/sub” (“publish” and “subscribe”), event dispatchers, callbacks, observers, message queues, etc. The truth is, these are often very similar, and you’d be hard pressed to define practical differences between some of them. Regardless, this is a critical function in any application, and there are some consensus strategies in mobile application development that we’ll explain here.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177236196040">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="message passing" data-secondary="task overview" data-type="indexterm" id="idm46177236194744"/> this chapter, you’ll learn to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Use a callback to react to an operation.</p>&#13;
</li>&#13;
<li>&#13;
<p>Dispatch a message to any interested subscribers.</p>&#13;
</li>&#13;
<li>&#13;
<p>Listen for and react to messages dispatched within a system.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177236190216">&#13;
<h1>Android</h1>&#13;
&#13;
<p>In<a data-primary="message passing" data-secondary="Android" data-tertiary="LocalBroadcastManager" data-type="indexterm" id="idm46177236188648"/><a data-primary="Android" data-secondary="message passing" data-tertiary="LocalBroadcastManager" data-type="indexterm" id="idm46177236186984"/><a data-primary="LocalBroadcastManager" data-type="indexterm" id="idm46177236185768"/> Android, you usually use callbacks for direct message passing and dispatch events with the statistically available and thread-safe <code>LocalBroadcastManager</code>. Note that <code>LocalBroadcastManager</code> sends <code>Intent</code> instances to be received by <code>BroadcastReceiver</code> instances—this is the same mechanism used by system-wide messages, many provided by other apps or operating system components; however, <code>LocalBroadcastManager</code> only notifies <code>BroadcastReceivers</code> in your app, which is both a good thing (safe) but also a little limiting—if you want to <span class="keep-together">communicate</span> between apps or with the underlying framework, you have to go beyond the brevity and simple API provided by <code>LocalBroadcastManager</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use a Callback to React to an Operation" data-type="sect2"><div class="sect2" id="idm46177236188312">&#13;
<h2>Use a Callback to React to an Operation</h2>&#13;
&#13;
<p>In<a data-primary="message passing" data-secondary="Android" data-tertiary="callbacks" data-type="indexterm" id="MPacall05"/><a data-primary="Android" data-secondary="message passing" data-tertiary="callbacks" data-type="indexterm" id="AMPcall05"/><a data-primary="callbacks" data-secondary="Android" data-type="indexterm" id="Cand05"/> Java and Android, the most direct route of passing a message is to send a callback along with an operation. A callback is an object instance created solely to receive a result and act on it and is often a simple anonymous instance of a functional interface. Here’s<a data-primary="Java" data-secondary="message passing" data-tertiary="callbacks" data-type="indexterm" id="JMPcall05"/><a data-primary="Kotlin" data-secondary="message passing" data-tertiary="callbacks" data-type="indexterm" id="KMPcall05"/> an example:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177236171000">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Callbacks</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">requestData</code><code class="o">(</code><code class="n">Callback</code> <code class="n">callback</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="c1">// perform some file i/o or network task...</code>&#13;
    <code class="n">Object</code> <code class="n">data</code> <code class="o">=</code> <code class="c1">// result of your operation</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">data</code> <code class="o">!=</code> <code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="n">callback</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="n">callback</code><code class="o">.</code><code class="na">onSuccess</code><code class="o">(</code><code class="n">data</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Callback</code> <code class="o">{</code>&#13;
    <code class="kt">void</code> <code class="nf">onSuccess</code><code class="o">(</code><code class="n">Object</code> <code class="n">data</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">object</code> <code class="nc">Callbacks</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">fun</code> <code class="nf">requestData</code><code class="p">(</code><code class="n">callback</code><code class="p">:</code> <code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">Any</code><code class="p">?)</code> <code class="p">-&gt;</code> <code class="n">Unit</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// perform some file i/o or network task...</code>&#13;
    <code class="k">val</code> <code class="py">data</code> <code class="p">=</code> <code class="n">Any</code><code class="p">()</code>&#13;
    <code class="n">callback</code><code class="p">(</code><code class="n">data</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Someone might invoke it with a full instance of the <code>Callback</code> interface, a lambda, or a method reference:</p>&#13;
<dl>&#13;
<dt>Lambda in Java then Kotlin</dt>&#13;
<dd>&#13;
<pre data-code-language="java" data-type="programlisting">&#13;
<code class="n">Callbacks</code><code class="o">.</code><code class="na">requestData</code><code class="o">(</code><code class="n">data</code> <code class="o">-&gt;</code> <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyApp"</code><code class="o">,</code> <code class="s">"result received: "</code> <code class="o">+</code> <code class="n">data</code><code class="o">));</code>&#13;
</pre>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting">&#13;
<code class="n">Callbacks</code><code class="p">.</code><code class="n">requestData</code> <code class="p">{</code> <code class="n">data</code><code class="p">-&gt;</code> <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyApp"</code><code class="p">,</code> <code class="s">"result received: $data"</code><code class="p">)</code> <code class="p">}</code>&#13;
</pre>&#13;
</dd>&#13;
</dl>&#13;
<dl>&#13;
<dt>Method reference in Java then Kotlin</dt>&#13;
<dd>&#13;
<pre data-code-language="java" data-type="programlisting">&#13;
<code class="kd">private</code> <code class="kt">void</code> <code class="nf">handleResult</code><code class="o">(</code><code class="n">Object</code> <code class="n">data</code><code class="o">)</code> <code class="o">{</code>&#13;
  <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyApp"</code><code class="o">,</code> <code class="s">"result received: "</code> <code class="o">+</code> <code class="n">data</code><code class="o">);</code>&#13;
<code class="o">}</code>&#13;
<code class="o">...</code>&#13;
<code class="n">Callbacks</code><code class="o">.</code><code class="na">requestData</code><code class="o">(</code><code class="k">this</code><code class="o">::</code><code class="n">handleResult</code><code class="o">);</code>&#13;
</pre>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting">&#13;
<code class="k">private</code> <code class="k">fun</code> <code class="nf">handleResult</code><code class="p">(</code><code class="n">data</code><code class="p">:</code> <code class="n">Any</code><code class="p">?)</code> <code class="p">{</code>&#13;
  <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyApp"</code><code class="p">,</code> <code class="s">"result received: $data"</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
<code class="p">...</code>&#13;
<code class="n">Callbacks</code><code class="p">.</code><code class="n">requestData</code><code class="p">(</code><code class="o">::</code><code class="n">handleResult</code><code class="p">)</code>&#13;
</pre>&#13;
</dd>&#13;
</dl>&#13;
<dl>&#13;
<dt>Instance in Java only</dt>&#13;
<dd>&#13;
<pre data-code-language="java" data-type="programlisting">&#13;
<code class="n">Callbacks</code><code class="o">.</code><code class="na">requestData</code><code class="o">(</code><code class="k">new</code> <code class="n">Callback</code><code class="o">(</code><code class="n">Object</code> <code class="n">data</code><code class="o">)</code> <code class="o">{</code>&#13;
  <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyApp"</code><code class="o">,</code> <code class="s">"result received: "</code> <code class="o">+</code> <code class="n">data</code><code class="o">);</code>&#13;
<code class="o">});</code>&#13;
</pre>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>There is no direct equivalent in Kotlin, since rather than interfaces, function parameters are defined as lambdas. Use the syntax for lambdas instead, and see <a href="https://oreil.ly/lr8Ja">the Kotlin documentation</a> for information on higher-order functions.</p>&#13;
&#13;
<p>As you can see, it’s a pretty direct route and allows you as the developer to define your program’s reaction to the result of an operation with enormous flexibility.</p>&#13;
&#13;
<p>Here’s a trivial but functional example. This time we use a callback for both a successful operation as well as an unsuccessful outcome:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177235816888">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">FiftyFifty</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">play</code><code class="o">(</code><code class="n">SuccessHandler</code> <code class="n">successHandler</code><code class="o">,</code> <code class="n">FailureHandler</code> <code class="n">failureHandler</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kt">float</code> <code class="n">random</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Random</code><code class="o">().</code><code class="na">nextFloat</code><code class="o">();</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">random</code> <code class="o">&gt;=</code> <code class="mf">0.5f</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="n">successHandler</code><code class="o">.</code><code class="na">onSuccess</code><code class="o">();</code>&#13;
    <code class="o">}</code>  <code class="k">else</code> <code class="o">{</code>&#13;
      <code class="n">failureHandler</code><code class="o">.</code><code class="na">onFailure</code><code class="o">();</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">interface</code> <code class="nc">SuccessHandler</code> <code class="o">{</code>&#13;
    <code class="kt">void</code> <code class="nf">onSuccess</code><code class="o">();</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">interface</code> <code class="nc">FailureHandler</code> <code class="o">{</code>&#13;
    <code class="kt">void</code> <code class="nf">onFailure</code><code class="o">();</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="n">fun</code> <code class="n">playFiftyFifty</code><code class="p">(</code><code class="n">success</code><code class="p">:</code> <code class="p">()</code> <code class="o">-&gt;</code> <code class="n">Unit</code><code class="p">,</code> <code class="n">failure</code><code class="p">:</code> <code class="p">()</code> <code class="o">-&gt;</code> <code class="n">Unit</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="n">val</code> <code class="n">random</code> <code class="o">=</code> <code class="n">Random</code><code class="p">()</code><code class="o">.</code><code class="n">nextFloat</code><code class="p">()</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="n">random</code> <code class="o">&gt;=</code> <code class="mf">0.5</code><code class="n">f</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">success</code><code class="p">()</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="n">failure</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>You could use this as follows:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177235626712">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">PlayFiftyFifty</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">PlayFiftyFifty</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">FiftyFifty</code><code class="o">.</code><code class="na">play</code><code class="o">(</code><code class="k">this</code><code class="o">::</code><code class="n">onSuccess</code><code class="o">,</code> <code class="k">this</code><code class="o">::</code><code class="n">onFailure</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="kt">void</code> <code class="nf">onSuccess</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"FiftyFifty"</code><code class="o">,</code> <code class="s">"We won!"</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="kt">void</code> <code class="nf">onFailure</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"FiftyFifty"</code><code class="o">,</code> <code class="s">"We lost :("</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">PlayFiftyFifty</code> <code class="p">{</code>&#13;
&#13;
  <code class="n">init</code> <code class="p">{</code>&#13;
    <code class="n">playFifityFifty</code><code class="p">({</code> <code class="k">this</code><code class="p">.</code><code class="n">onSuccess</code><code class="p">()</code> <code class="p">},</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="n">onFailure</code><code class="p">()</code> <code class="p">})</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">private</code> <code class="k">fun</code> <code class="nf">onSuccess</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"FiftyFifty"</code><code class="p">,</code> <code class="s">"We won!"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">private</code> <code class="k">fun</code> <code class="nf">onFailure</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"FiftyFifty"</code><code class="p">,</code> <code class="s">"We lost :("</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Invoke it elsewhere, like so:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177235466616">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="k">new</code> <code class="nf">PlayFiftyFifty</code><code class="o">();</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">PlayFiftyFifty</code><code class="p">()</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>A more practical example might be one where you have many operations that might throw exceptions, like network requests that require authentication and return JSON responses that must be successfully parsed, and then local disk or database operations to save the results. You might have an <code>Activity</code> that handles all of this logic and want common failure logic (e.g., showing a <code>Snackbar</code> to the user with some human-friendly copy describing the failure, but not interrupting the user’s experience or crashing the app). Something like this class might be helpful:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177235407016">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Safely</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kt">void</code> <code class="nf">handle</code><code class="o">(</code><code class="n">Attempter</code> <code class="n">attempter</code><code class="o">,</code> <code class="n">SuccessHandler</code> <code class="n">successHandler</code><code class="o">,</code>&#13;
    <code class="n">ErrorHandler</code> <code class="n">errorHandler</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">try</code> <code class="o">{</code>&#13;
      <code class="n">attempter</code><code class="o">.</code><code class="na">attempt</code><code class="o">();</code>&#13;
      <code class="n">successHandler</code><code class="o">.</code><code class="na">onSuccess</code><code class="o">();</code>&#13;
    <code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">Exception</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">if</code> <code class="o">(</code><code class="n">errorHandler</code> <code class="o">!=</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
        <code class="n">errorHandler</code><code class="o">.</code><code class="na">onException</code><code class="o">(</code><code class="n">e</code><code class="o">);</code>&#13;
      <code class="o">}</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">interface</code> <code class="nc">Attempter</code> <code class="o">{</code>&#13;
    <code class="kt">void</code> <code class="nf">attempt</code><code class="o">();</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">interface</code> <code class="nc">SuccessHandler</code> <code class="o">{</code>&#13;
    <code class="kt">void</code> <code class="nf">onSuccess</code><code class="o">();</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">interface</code> <code class="nc">ErrorHandler</code> <code class="o">{</code>&#13;
    <code class="kt">void</code> <code class="nf">onException</code><code class="o">(</code><code class="n">Exception</code> <code class="n">e</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">object</code> <code class="nc">Safely</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">fun</code> <code class="nf">handle</code><code class="p">(</code><code class="n">attempter</code><code class="p">:</code> <code class="p">()</code> <code class="p">-&gt;</code> <code class="n">Unit</code><code class="p">,</code> <code class="n">success</code><code class="p">:</code> <code class="p">()</code> <code class="p">-&gt;</code> <code class="n">Unit</code><code class="p">,</code> <code class="n">error</code><code class="p">:</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">Unit</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">try</code> <code class="p">{</code>&#13;
      <code class="n">attempter</code><code class="p">()</code>&#13;
      <code class="n">success</code><code class="p">()</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="n">error</code><code class="p">(</code><code class="n">e</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>You could use these utilities in a controller that might look like these:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177235223976">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MainActivity</code> <code class="kd">extends</code> <code class="n">Activity</code> <code class="o">{</code>&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">Bundle</code> <code class="n">savedInstanceState</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">setContentView</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">layout</code><code class="o">.</code><code class="na">activity_main</code><code class="o">);</code>&#13;
    <code class="n">Safely</code><code class="o">.</code><code class="na">handle</code><code class="o">(</code><code class="k">this</code><code class="o">::</code><code class="n">fetchAndSave</code><code class="o">,</code> <code class="k">this</code><code class="o">::</code><code class="n">handleSuccess</code><code class="o">,</code> <code class="k">this</code><code class="o">::</code><code class="n">handleFailure</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="kt">void</code> <code class="nf">fetchAndSave</code><code class="o">()</code> <code class="kd">throws</code> <code class="n">Exception</code> <code class="o">{</code>&#13;
    <code class="c1">// imagine this method established an HTTP connection,</code>&#13;
    <code class="c1">// provided credentials, requested a JSON response,</code>&#13;
    <code class="c1">// parsed the response, and wrote the resulting values</code>&#13;
    <code class="c1">// to a local SQLIte database</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="kt">void</code> <code class="nf">handleSuccess</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="c1">// perhaps here you'd show some UI representing the</code>&#13;
    <code class="c1">// data that you just successfully fetched and saved;</code>&#13;
    <code class="c1">// for now, we'll just log it ;)</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyApp"</code><code class="o">,</code> <code class="s">"just fetched and saved some data!"</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">private</code> <code class="kt">void</code> <code class="nf">handleFailure</code><code class="o">(</code><code class="n">Exception</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="c1">// perhaps here you'd show a Snackbar with some</code>&#13;
    <code class="c1">// information about what happened,</code>&#13;
    <code class="c1">// or provide a "Retry" interface...</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyApp"</code><code class="o">,</code> <code class="s">"Oops! Something went wrong: "</code> <code class="o">+</code> <code class="n">e</code><code class="o">.</code><code class="na">getMessage</code><code class="o">());</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyActivity</code> <code class="p">:</code> <code class="n">Activity</code><code class="p">()</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code>&#13;
    <code class="n">Safely</code><code class="p">.</code><code class="n">handle</code><code class="p">(</code><code class="o">::</code><code class="n">fetchAndSave</code><code class="p">,</code> <code class="o">::</code><code class="n">handleSuccess</code><code class="p">,</code> <code class="o">::</code><code class="n">handleFailure</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="n">@Throws</code><code class="p">(</code><code class="n">Exception</code><code class="o">::</code><code class="k">class</code><code class="p">)</code>&#13;
  <code class="k">private</code> <code class="k">fun</code> <code class="nf">fetchAndSave</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// imagine this method established an HTTP connection</code>&#13;
    <code class="c1">// provided credentials, requested a JSON response,</code>&#13;
    <code class="c1">// parsed the response and wrote the resulting values</code>&#13;
    <code class="c1">// to a local SQLIte database</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">private</code> <code class="k">fun</code> <code class="nf">handleSuccess</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="c1">// perhaps here you'd show some UI representing the</code>&#13;
    <code class="c1">// data that you just successfully fetched and saved</code>&#13;
    <code class="c1">// for now, we'll just log it ;)</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyApp"</code><code class="p">,</code> <code class="s">"just fetched and saved some data!"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">private</code> <code class="k">fun</code> <code class="nf">handleFailure</code><code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// perhaps here you'd show a Snackbar with some</code>&#13;
    <code class="c1">// information about what happened,</code>&#13;
    <code class="c1">// or provide a "Retry" interface...</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyApp"</code><code class="p">,</code> <code class="s">"Oops! Something went wrong: $e.getMessage()"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Those are the basics of using callbacks! It’s a pretty straightforward pattern, and you’ve probably seen, or even used, something similar already.<a data-primary="" data-startref="KMPcall05" data-type="indexterm" id="idm46177234987048"/><a data-primary="" data-startref="JMPcall05" data-type="indexterm" id="idm46177234865160"/><a data-primary="" data-startref="Cand05" data-type="indexterm" id="idm46177234864280"/><a data-primary="" data-startref="AMPcall05" data-type="indexterm" id="idm46177234863336"/><a data-primary="" data-startref="MPacall05" data-type="indexterm" id="idm46177234862392"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dispatch a Message to Any Interested Subscribers" data-type="sect2"><div class="sect2" id="idm46177236179976">&#13;
<h2>Dispatch a Message to Any Interested Subscribers</h2>&#13;
&#13;
<p>A<a data-primary="message passing" data-secondary="Android" data-tertiary="to subscribers" data-tertiary-sortas="subscribers" data-type="indexterm" id="idm46177234860296"/><a data-primary="Android" data-secondary="message passing" data-tertiary="to subscribers" data-tertiary-sortas="subscribers" data-type="indexterm" id="idm46177234858744"/><a data-primary="LocalBroadcastManager" data-type="indexterm" id="idm46177234857256"/><a data-primary="subscribers, passing messages to" data-secondary="Android" data-type="indexterm" id="idm46177234856584"/> less familiar API is one that’s Android specific and not available outside the framework: <code>LocalBroadcastManager</code>. Let’s jump right in.</p>&#13;
&#13;
<p>The <code>LocalBroadcastManager</code> is a singleton—a single instance is used and managed throughout your app. You are able to access the singleton instance by passing any <code>Context</code> instance to the static <code>getInstance</code> method: <code>LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(context);</code>. You’ll never need to worry about the constructor or configuration. Furthermore, it’s thread-safe out of the box!</p>&#13;
&#13;
<p>The really great thing about this class being a singleton is that you’re able to send and receive messages between two objects that know nothing about each other. For example, you may broadcast messages from an <code>Adapter</code> class that manages several different <code>RecyclerViews</code> in your app, without knowing what (if anything) will happen when that message is received. In one list view, you may want to update the list in response to one particular kind of message; in another list, you may want to react very differently—maybe even <code>finish</code> the <code>Activity</code> for the same message. The <code>Adapter</code> doesn’t have to know about the instances of the <code>RecyclerView</code> or the various <code>Activity</code> instances that house them, and vice versa—the <code>LocalBroadcastManager</code> sounds the alarm, and any interested party can react however you choose.</p>&#13;
&#13;
<p>The <code>LocalBroadcastManager</code> instance<a data-primary="Android commands and methods" data-secondary="send Broadcast" data-type="indexterm" id="idm46177234846936"/><a data-primary="Android commands and methods" data-secondary="registerReceiver" data-type="indexterm" id="idm46177234845960"/> has two methods we use regularly: they are <code>sendBroadcast</code> and <code>registerReceiver</code>. As you’ve probably guessed, <code>sendBroadcast</code> dispatches a message and notifies any other class that has registered a receiver for that kind of message. A third method, <code>unregisterReceiver</code>, is important as well, so that we can stop listening for messages if a listener is removed from the application (and thereby prevent memory leaks!).</p>&#13;
&#13;
<p>Messages like this are represented by the <code>Intent</code> class, the same class used to start new <code>Activities</code> and describe system-wide dispatches. An <code>Intent</code> instance has an “action” property, which you can set in the constructor by passing a <code>String</code>; you can even add more actions later with the <code>addAction</code> method.</p>&#13;
&#13;
<p>The <code>LocalBroadastManager</code> dispatches<a data-primary="Java" data-secondary="message passing" data-tertiary="to subscribers" data-tertiary-sortas="subscribers" data-type="indexterm" id="idm46177234839112"/><a data-primary="Kotlin" data-secondary="message passing" data-tertiary="to subscribers" data-tertiary-sortas="subscribers" data-type="indexterm" id="idm46177234837560"/> an <code>Intent</code> using the <code>sendBroadcast</code> method:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177234834952">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">Intent</code> <code class="n">intent</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Intent</code><code class="o">(</code><code class="s">"data-received"</code><code class="o">);</code>&#13;
<code class="n">LocalBroadcastManager</code><code class="o">.</code><code class="na">getInstance</code><code class="o">(</code><code class="n">context</code><code class="o">).</code><code class="na">sendBroadcast</code><code class="o">(</code><code class="n">intent</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">intent</code> <code class="p">=</code> <code class="n">Intent</code><code class="p">(</code><code class="s">"data-received"</code><code class="p">)</code>&#13;
<code class="n">LocalBroadcastManager</code><code class="p">.</code><code class="n">getInstance</code><code class="p">(</code><code class="n">context</code><code class="p">).</code><code class="n">sendBroadcast</code><code class="p">(</code><code class="n">intent</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Once this is invoked, any <code>BroadcastReceiver</code> that has previously been registered for this action on the same global instance of <code>LocalBroadcastManager</code> will call its <code><span class="keep-together">onReceive</span></code> method with the <code>Intent</code> instance you sent as the second argument to <code><span class="keep-together">onReceive</span></code>. Note that only <code>BroadcastReceiver</code> instances that were registered with an <code>IntentFilter</code> that includes an action that matches the action of the <code>Intent</code> instance will fire. So, in the preceding example, if you create a broadcast with an <code>Intent</code> constructed using a different action—like <code>Intent intent = new Intent("user-login");</code>—the <code><span class="keep-together">Broadcast</span>Receiver</code> in this example will not fire, because the actions do not match.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Listen for, and React to, Messages Dispatched Within a System" data-type="sect2"><div class="sect2" id="idm46177234802632">&#13;
<h2>Listen for, and React to, Messages Dispatched Within a System</h2>&#13;
&#13;
<p>Let’s<a data-primary="message passing" data-secondary="Android" data-tertiary="within systems" data-type="indexterm" id="idm46177234727064"/><a data-primary="Android" data-secondary="message passing" data-tertiary="within systems" data-type="indexterm" id="idm46177234725784"/> look at how we register to become notified of a broadcast.</p>&#13;
&#13;
<p>First, we need a <code>BroadcastReceiver</code> instance, an object instance that extends the base <code>BroadcastReceiver</code> class and will react to messages we’re<a data-primary="Java" data-secondary="message passing" data-tertiary="within systems" data-type="indexterm" id="idm46177234723064"/><a data-primary="Kotlin" data-secondary="message passing" data-tertiary="within systems" data-type="indexterm" id="idm46177234721816"/> interested in:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177234720344">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">BroadcastReceiver</code> <code class="n">receiver</code> <code class="o">=</code> <code class="k">new</code> <code class="n">BroadcastReceiver</code><code class="o">()</code> <code class="o">{</code>&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onReceive</code><code class="o">(</code><code class="n">Context</code> <code class="n">context</code><code class="o">,</code> <code class="n">Intent</code> <code class="n">intent</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyApp"</code><code class="o">,</code> <code class="s">"We received a broadcast for "</code> <code class="o">+</code> <code class="n">intent</code><code class="o">.</code><code class="na">getAction</code><code class="o">());</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">var</code> <code class="py">receiver</code><code class="p">:</code><code class="n">BroadcastReceiver</code> <code class="p">=</code> <code class="k">object</code><code class="p">:</code><code class="n">BroadcastReceiver</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onReceive</code><code class="p">(</code><code class="n">context</code><code class="p">:</code><code class="n">Context</code><code class="p">,</code> <code class="n">intent</code><code class="p">:</code><code class="n">Intent</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyApp"</code><code class="p">,</code> <code class="s">"We received a broadcast for "</code> <code class="p">+</code> <code class="n">intent</code><code class="p">.</code><code class="n">getAction</code><code class="p">())</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Next, we need an <code>IntentFilter</code> instance, which is really just a list of string action types that we’re interested in:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177234593400">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">IntentFilter</code> <code class="n">intentFilter</code> <code class="o">=</code> <code class="k">new</code> <code class="n">IntentFilter</code><code class="o">(</code><code class="s">"data-received"</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">intentFilter</code> <code class="p">=</code> <code class="n">IntentFilter</code><code class="p">(</code><code class="s">"data-received"</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There is other functionality the <code>IntentFilter</code> offers, but the most common is the basic <code>String</code> action filter.</p>&#13;
</div>&#13;
&#13;
<p>Now we can pass those to the <code>registerReceiver</code> method, and we’ll be notified any time a broadcast is sent with the action “data-received”:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177234515784">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">LocalBroadcastManager</code><code class="o">.</code><code class="na">getInstance</code><code class="o">(</code><code class="n">context</code><code class="o">).</code><code class="na">registerReceiver</code><code class="o">(</code><code class="n">receiver</code><code class="o">,</code>&#13;
  <code class="n">intentFilter</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">LocalBroadcastManager</code><code class="p">.</code><code class="n">getInstance</code><code class="p">(</code><code class="n">context</code><code class="p">).</code><code class="n">registerReceiver</code><code class="p">(</code><code class="n">receiver</code><code class="p">,</code>&#13;
  <code class="n">intentFilter</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Note that <code>LocalBroadcastReceiver</code> is thread-safe, so you can send a broadcast from a background thread and listen for it on the UI thread safely. However, the broadcast itself is asynchronous, meaning that it will not necessarily fire in the order of statements in your program. There is, however, a <code>broadcastSync</code> method that will send the broadcast immediately and serially.</p>&#13;
&#13;
<p>It’s also very important to remember to unregister <code>BroadcastReceivers</code> that are no longer being used, like those defined in an <code>Activity</code> that has been <code>finished</code>. Otherwise, memory leaks can occur.</p>&#13;
&#13;
<p>There<a data-primary="message passing" data-secondary="Android" data-tertiary="third-party systems" data-type="indexterm" id="idm46177234483176"/><a data-primary="Android" data-secondary="message passing" data-tertiary="third-party systems" data-type="indexterm" id="idm46177234482120"/><a data-primary="Otto" data-type="indexterm" id="idm46177234480904"/><a data-primary="EventBus" data-type="indexterm" id="idm46177234480232"/> are a number of third-party messaging systems available in Java and Android, including Otto by Square and EventBus by GreenRobot. There’s also the <code>Observable</code> API used by the very popular RxJava Android library, but to my mind the observable pattern is different enough from traditional pub-sub that it deserves to be addressed independently.</p>&#13;
&#13;
<p>Finally, it’s<a data-primary="message passing" data-secondary="Android" data-tertiary="writing your own event bus" data-type="indexterm" id="idm46177234450232"/><a data-primary="Android" data-secondary="message passing" data-tertiary="writing your own event bus" data-type="indexterm" id="idm46177234448984"/> extremely simple to write your own event bus (a full-featured event dispatch and receiver system) in Java; we have written one <a href="https://oreil.ly/en-O6">in about 40 lines</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177234728008">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>There are a few ways to handle message passing in iOS. Like Android, a common pattern for this is through the use of callbacks and notifications. Let’s examine the differences and determine the right time to use either one of these tried-and-true patterns.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Use a Callback to React to an Operation" data-type="sect2"><div class="sect2" id="idm46177234444904">&#13;
<h2>Use a Callback to React to an Operation</h2>&#13;
&#13;
<p>The<a data-primary="message passing" data-secondary="iOS" data-tertiary="callbacks" data-type="indexterm" id="MPioscall05"/><a data-primary="iOS" data-secondary="message passing" data-tertiary="callbacks" data-type="indexterm" id="IOSmpcall05"/><a data-primary="closures" data-type="indexterm" id="closure05"/><a data-primary="callbacks" data-secondary="iOS" data-tertiary="closures" data-type="indexterm" id="idm46177234439384"/> most common form of message passing in Swift and iOS is done through <span class="keep-together">closures</span>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Closures" data-type="sect3"><div class="sect3" id="idm46177234437256">&#13;
<h3>Closures</h3>&#13;
&#13;
<p>Closures are standalone functions that act as objects. They can be properties on another object and passed around as method parameters or stored for later use. In its most basic form a closure might look like this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">var</code> <code class="nv">someClosure</code> <code class="p">=</code> <code class="p">{</code> <code class="bp">print</code><code class="p">(</code><code class="s">"I'm a closure!"</code><code class="p">)</code> <code class="p">}</code>&#13;
<code class="n">someClosure</code><code class="p">()</code> <code class="c1">// Executes our closure, which prints out a message to the console</code></pre>&#13;
&#13;
<p>Essentially, a closure is a spring-loaded snippet of code that can be called any time. Another name for them is “anonymous functions,” and they’re very useful!</p>&#13;
&#13;
<p>Use of closures as callbacks is most powerful and appropriate in asynchronous situations—say when waiting for a network call to complete. Here’s an example of how a hypothetical API client might utilize closures to communicate with an API without causing the entire app to become unresponsive while waiting for a reply from a server:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">NetworkService</code> <code class="p">{</code>&#13;
	<code class="kd">var</code> <code class="nv">completion</code><code class="p">:</code> <code class="p">((</code><code class="nb">Bool</code><code class="p">,</code> <code class="n">Error</code><code class="p">?)</code> <code class="p">-&gt;</code> <code class="p">())?</code>&#13;
&#13;
	<code class="kd">func</code> <code class="nf">fetchData</code><code class="p">(</code><code class="k">for</code> <code class="n">url</code><code class="p">:</code> <code class="nb">URL</code><code class="p">)</code> <code class="p">{</code>&#13;
		<code class="p">...</code>&#13;
	<code class="p">}</code>&#13;
	<code class="kd">func</code> <code class="nf">onSuccess</code><code class="p">()</code> <code class="p">{</code>&#13;
		<code class="n">completion</code><code class="p">?(</code><code class="kc">true</code><code class="p">,</code> <code class="kc">nil</code><code class="p">)</code>&#13;
	<code class="p">}</code>&#13;
	<code class="kd">func</code> <code class="nf">onError</code><code class="p">(</code><code class="n">error</code><code class="p">:</code> <code class="n">Error</code><code class="p">)</code> <code class="p">{</code>&#13;
		<code class="n">completion</code><code class="p">?(</code><code class="kc">false</code><code class="p">,</code> <code class="n">error</code><code class="p">)</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">api</code> <code class="p">=</code> <code class="n">NetworkService</code><code class="p">()</code>&#13;
<code class="n">api</code><code class="p">.</code><code class="n">completion</code> <code class="p">=</code> <code class="p">{</code> <code class="n">success</code><code class="p">,</code> <code class="n">error</code> <code class="k">in</code>&#13;
	<code class="k">if</code> <code class="n">success</code> <code class="p">{</code>&#13;
		<code class="bp">print</code><code class="p">(</code><code class="s">"Success!"</code><code class="p">)</code>&#13;
	<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
		<code class="bp">print</code><code class="p">(</code><code class="s">"Uh-oh!"</code><code class="p">)</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="n">api</code><code class="p">.</code><code class="n">fetchData</code><code class="p">()</code></pre>&#13;
&#13;
<p>Let’s walk through this code.</p>&#13;
&#13;
<p>First, the <code>completion</code> property is a stored instance of a closure the containing class can use later. It should be noted that this is a nullable property and can be <code>nil</code> if we don’t want something to happen whenever a network call completes.</p>&#13;
&#13;
<p>Next, <code>fetchData</code> is a placeholder method that eventually calls <code>onSuccess</code> or <code>onError</code> whenever a response is received from our hypothetical API.</p>&#13;
&#13;
<p>Now, this is the important part. Whenever <code>onSuccess</code> or <code>onError</code> are invoked, they call the stored closure and pass in some data via method parameters. Any data could be passed to the closure, but in this example a boolean indicating if an operation was a success and an optional error if an error occurred are given to the closure.</p>&#13;
&#13;
<p>Moving on to how this object is used, we can see that the class is instantiated as <code>api</code>, and a closure is given to the <code>completion</code> variable from before that prints whether or not an operation was a success or failure to the console. This is the same closure that is referenced and called in <code>onSuccess</code> and <code>onError</code> within the <code>NetworkService</code> class.</p>&#13;
&#13;
<p>Last, we call <code>fetchData</code> from the object we’ve created so that we can kick off the network call and receive our response from the API.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Escaping and nonescaping closures" data-type="sect3"><div class="sect3" id="idm46177234436600">&#13;
<h3>Escaping and nonescaping closures</h3>&#13;
&#13;
<p>One<a data-primary="callbacks" data-secondary="iOS" data-tertiary="escaping and nonescaping closures" data-type="indexterm" id="CIOSescap05"/> of the harder aspects of closures to understand is memory management. Whenever a closure is created, the variables and instances contained within it are “closed around,” and strong references to these objects are created. The result of this is that the objects stick around even after they’ve gone out of scope so they can be used by the closure. Here’s an example of this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">Incrementor</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">count</code> <code class="p">=</code> <code class="mi">0</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">increment</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="bp">count</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="bp">count</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">incrementor</code> <code class="p">=</code> <code class="n">Incrementor</code><code class="p">()</code>&#13;
<code class="kd">let</code> <code class="nv">closure</code> <code class="p">=</code> <code class="p">{</code>&#13;
    <code class="n">incrementor</code><code class="p">.</code><code class="n">increment</code><code class="p">()</code> <code class="c1">// 1</code>&#13;
    <code class="n">incrementor</code><code class="p">.</code><code class="n">increment</code><code class="p">()</code> <code class="c1">// 2</code>&#13;
<code class="p">}</code>&#13;
<code class="n">closure</code><code class="p">()</code> <code class="c1">// Prints "1\n2"</code></pre>&#13;
&#13;
<p>First, we create an object that increments itself by one every time <code>increment</code> is called. We instantiate an object of that type. Then, we pass that object into a closure so that a strong reference to it is made. This allows that object to stick around past when it would normally be out of scope. The end result of this is that when <code>closure()</code> is called, the object is still around and is able to increment our count by one for the number of times it’s called (in this case, two times).</p>&#13;
&#13;
<p>This is relevant because it has to do with memory management of the objects created. Swift—and<a data-primary="Objective-C" data-type="indexterm" id="idm46177234220072"/> its predecessor, Objective-C—is susceptible to a class of bugs known as retain cycles. This is when an object cannot go out of scope and be cleared from memory because other objects hold on to a reference of it. Because closures create a strong reference to objects contained within them, they are essentially adding a “tally mark” to the list of objects that object is owned by. This tells the compiler not to clear it from memory so that it can used by the other objects. In our preceding example, this is helpful for the closure because <code>incrementor</code> stays in scope and can be called later when the closure is called.</p>&#13;
&#13;
<p>When a closure is passed as a parameter in Swift, if the closure does not outlive the function being called, the closure is called a <code>nonescaping</code> closure. By default, this is the type of closure implicitly declared for every closure passed as an argument. An example of a nonescaping closure is as follows:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">Incrementor</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">count</code> <code class="p">=</code> <code class="mi">0</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">increment</code><code class="p">(</code><code class="n">with</code> <code class="n">closure</code><code class="p">:</code> <code class="p">()</code> <code class="p">-&gt;</code> <code class="p">())</code> <code class="p">{</code>&#13;
        <code class="bp">count</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
        <code class="n">closure</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">incrementor</code> <code class="p">=</code> <code class="n">Incrementor</code><code class="p">()</code>&#13;
<code class="kd">let</code> <code class="nv">printCount</code> <code class="p">=</code> <code class="p">{</code>&#13;
    <code class="bp">print</code><code class="p">(</code><code class="n">incrementor</code><code class="p">.</code><code class="bp">count</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">incrementor</code><code class="p">.</code><code class="n">increment</code><code class="p">(</code><code class="n">with</code><code class="p">:</code> <code class="n">printCount</code><code class="p">)</code> <code class="c1">// 1</code>&#13;
<code class="n">incrementor</code><code class="p">.</code><code class="n">increment</code><code class="p">(</code><code class="n">with</code><code class="p">:</code> <code class="n">printCount</code><code class="p">)</code> <code class="c1">// 2</code></pre>&#13;
&#13;
<p>We’ve changed our <code>Incrementor</code> class’s <code>increment()</code> method to now take a closure as a method parameter so that the method signature is now <code>increment(with:)</code>. This closure is called as soon as the <code>count</code> variable is incremented by one. In our example, we pass in a closure that simply <code>print</code>s the <code>count</code> variable by calling it directly from the <code>incrementor</code> object. We’ve referenced <code>incrementor</code> directly, which means a strong reference is created by the compiler and <code>incrementor</code> will not be freed from memory until our application completes.</p>&#13;
&#13;
<p>In our example, the argument <code>closure</code> passed into <code>increment(with:)</code> is a nonescaping closure. It never will outlive the function that’s being called. Let’s take a look at an escaping closure to see what that looks like:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">Incrementor</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">count</code> <code class="p">=</code> <code class="mi">0</code>&#13;
    <code class="kd">var</code> <code class="nv">printingMethod</code><code class="p">:</code> <code class="p">(()</code> <code class="p">-&gt;</code> <code class="p">())?</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">increment</code><code class="p">(</code><code class="n">with</code> <code class="n">closure</code><code class="p">:</code> <code class="p">()</code> <code class="p">-&gt;</code> <code class="p">())</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="n">printingMethod</code> <code class="p">==</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
            <code class="n">printingMethod</code> <code class="p">=</code> <code class="n">closure</code>&#13;
        <code class="p">}</code>&#13;
        <code class="bp">count</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
        <code class="n">printingMethod</code><code class="p">?()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">incrementor</code> <code class="p">=</code> <code class="n">Incrementor</code><code class="p">()</code>&#13;
<code class="kd">let</code> <code class="nv">printCount</code> <code class="p">=</code> <code class="p">{</code>&#13;
    <code class="bp">print</code><code class="p">(</code><code class="n">incrementor</code><code class="p">.</code><code class="bp">count</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">incrementor</code><code class="p">.</code><code class="n">increment</code><code class="p">(</code><code class="n">with</code><code class="p">:</code> <code class="n">printCount</code><code class="p">)</code>&#13;
<code class="n">incrementor</code><code class="p">.</code><code class="n">increment</code><code class="p">(</code><code class="n">with</code><code class="p">:</code> <code class="n">printCount</code><code class="p">)</code></pre>&#13;
&#13;
<p>As you can see, we’ve added a new <code>printingMethod</code> to store our passed in closure. Then, within <code>increment(with:)</code>, we assign the closure passed in to the <code>printingMethod</code> variable. If you try this in the code editor, you’ll get a compiler error when you try to assign a value to <code>printingMethod</code> because you didn’t indicate this closure was an escaping closure. It’s a simple fix. Just add an <code>escaping</code> keyword to the closure passed in to the <code>increment(with:)</code> method like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">func</code> <code class="nf">increment</code><code class="p">(</code><code class="n">with</code> <code class="n">closure</code><code class="p">:</code> <code class="p">@</code><code class="n">escaping</code> <code class="p">()</code> <code class="p">-&gt;</code> <code class="p">())</code> <code class="p">{</code>&#13;
	<code class="k">if</code> <code class="n">printingMethod</code> <code class="p">==</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
		<code class="n">printingMethod</code> <code class="p">=</code> <code class="n">closure</code>&#13;
	<code class="p">}</code>&#13;
	<code class="bp">count</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
	<code class="n">printingMethod</code><code class="p">?()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The full example now looks like this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">Incrementor</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">count</code> <code class="p">=</code> <code class="mi">0</code>&#13;
    <code class="kd">var</code> <code class="nv">printingMethod</code><code class="p">:</code> <code class="p">(()</code> <code class="p">-&gt;</code> <code class="p">())?</code>&#13;
&#13;
    <code class="kd">func</code> <code class="nf">increment</code><code class="p">(</code><code class="n">with</code> <code class="n">closure</code><code class="p">:</code> <code class="p">@</code><code class="n">escaping</code> <code class="p">()</code> <code class="p">-&gt;</code> <code class="p">())</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="n">printingMethod</code> <code class="p">==</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
            <code class="n">printingMethod</code> <code class="p">=</code> <code class="n">closure</code>&#13;
        <code class="p">}</code>&#13;
        <code class="bp">count</code> <code class="o">+=</code> <code class="mi">1</code>&#13;
        <code class="n">printingMethod</code><code class="p">?()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">incrementor</code> <code class="p">=</code> <code class="n">Incrementor</code><code class="p">()</code>&#13;
<code class="kd">let</code> <code class="nv">printCount</code> <code class="p">=</code> <code class="p">{</code>&#13;
    <code class="bp">print</code><code class="p">(</code><code class="n">incrementor</code><code class="p">.</code><code class="bp">count</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">incrementor</code><code class="p">.</code><code class="n">increment</code><code class="p">(</code><code class="n">with</code><code class="p">:</code> <code class="n">printCount</code><code class="p">)</code>&#13;
<code class="n">incrementor</code><code class="p">.</code><code class="n">increment</code><code class="p">(</code><code class="n">with</code><code class="p">:</code> <code class="n">printCount</code><code class="p">)</code></pre>&#13;
&#13;
<p>This resolves the compiler error. But we’ve created a pesky bug known as a retain cycle. They’re easy to create and tough to debug. It’s not very noticeable in our small example, but if you had a large object or an object that was created a lot of times, you could quickly run out of available memory for your application or run into unwanted and unexpected side effects. So, where is our bug?</p>&#13;
&#13;
<p>Remember how we mentioned that creating a closure creates a strong reference, or adds a “tally mark,” to an object so it won’t be cleared out of memory until all its references are gone? Well, in our example, we create a strong reference to <code>incrementor</code> in our <code>printCount</code> closure. But, we create a strong reference to our closure when we store it as <code>printingMethod</code> inside our <code>increment(with:)</code> method. The object is storing a strong reference to itself so that object can never go out of scope and be cleared from memory!</p>&#13;
&#13;
<p>Luckily, Swift has a way to turn a strong reference into what is known as a weak reference through capture lists. Let’s declare <code>incrementor</code> as a weak reference inside the closure we pass into the <code>increment(with:)</code> method like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">printCount</code> <code class="p">=</code> <code class="p">{</code> <code class="p">[</code><code class="kr">weak</code> <code class="n">incrementor</code><code class="p">]</code> <code class="k">in</code>&#13;
    <code class="k">guard</code> <code class="kd">let</code> <code class="nv">incrementor</code> <code class="p">=</code> <code class="n">incrementor</code> <code class="k">else</code> <code class="p">{</code> <code class="k">return</code> <code class="p">}</code>&#13;
    <code class="bp">print</code><code class="p">(</code><code class="n">incrementor</code><code class="p">.</code><code class="bp">count</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice that we’ve used <code>[weak incrementor]</code> to note that <code>incrementor</code> should be a weak reference instead of a strong reference. We’ve also added a <code>guard</code> statement to our closure to check to make sure <code>incrementor</code> isn’t <code>nil</code> before we attempt to access it. This means that we no longer have a retain cycle because <code>Incrementor</code> doesn’t store a strong reference of itself when it stores the closure to <code>printingMethod</code> inside the <code>increment(with:)</code> method; it’s storing a weakly referenced version of itself. So, when the last <code>incrementor</code> is called, the virtual tally sheet can make it to zero and the object can be freed from memory.</p>&#13;
&#13;
<p>Now, closures are certainly the more modern approach to passing messages between objects, but sometimes they are a bit of overkill. They’re also prone to memory reference bugs, as just now demonstrated, and threading mistakes without careful attention and deliberate care. Within<a data-primary="Cocoa Touch" data-secondary="delegates in" data-type="indexterm" id="idm46177233750728"/> Cocoa Touch one finds they are not the only way for an object to get its message across. Let’s check out delegates and see how they differ from closure-based callbacks.<a data-primary="" data-startref="CIOSescap05" data-type="indexterm" id="idm46177233749432"/><a data-primary="" data-startref="closure05" data-type="indexterm" id="idm46177233748488"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Delegates" data-type="sect3"><div class="sect3" id="idm46177234267064">&#13;
<h3>Delegates</h3>&#13;
&#13;
<p>Delegates<a data-primary="callbacks" data-secondary="iOS" data-tertiary="delegates" data-type="indexterm" id="idm46177233746184"/><a data-primary="delegates" data-type="indexterm" id="idm46177233744904"/> have been a part of Cocoa Touch since its inception. They provide logical simplicity but tend to be a bit more verbose than closures. Here’s our same <code>NetworkService</code> class from before written to use a delegate instead of a closure:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">protocol</code> <code class="nc">NetworkServiceDelegate</code><code class="p">:</code> <code class="kd">class</code> <code class="p">{</code>&#13;
	<code class="kd">func</code> <code class="nf">fetchDidComplete</code><code class="p">(</code><code class="n">success</code><code class="p">:</code> <code class="nb">Bool</code><code class="p">,</code> <code class="n">with</code> <code class="n">error</code><code class="p">:</code> <code class="n">Error</code><code class="p">?)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">NetworkService</code> <code class="p">{</code>&#13;
	<code class="kr">weak</code> <code class="kd">var</code> <code class="nv">delegate</code><code class="p">:</code> <code class="n">NetworkServiceDelegate</code><code class="p">?</code>&#13;
&#13;
	<code class="kd">func</code> <code class="nf">fetchData</code><code class="p">(</code><code class="k">for</code> <code class="n">url</code><code class="p">:</code> <code class="nb">URL</code><code class="p">)</code> <code class="p">{</code>&#13;
		<code class="p">...</code>&#13;
	<code class="p">}</code>&#13;
	<code class="kd">func</code> <code class="nf">onSuccess</code><code class="p">()</code> <code class="p">{</code>&#13;
		<code class="n">delegate</code><code class="p">?.</code><code class="n">fetchDidComplete</code><code class="p">(</code><code class="n">success</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code> <code class="n">with</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
	<code class="p">}</code>&#13;
	<code class="kd">func</code> <code class="nf">onError</code><code class="p">(</code><code class="n">error</code><code class="p">:</code> <code class="n">Error</code><code class="p">)</code> <code class="p">{</code>&#13;
		<code class="n">delegate</code><code class="p">?.</code><code class="n">fetchDidComplete</code><code class="p">(</code><code class="n">success</code><code class="p">:</code> <code class="kc">false</code><code class="p">,</code> <code class="n">with</code><code class="p">:</code> <code class="n">error</code><code class="p">)</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">APIClient</code> <code class="p">{</code>&#13;
	<code class="kd">init</code><code class="p">()</code> <code class="p">{</code>&#13;
		<code class="kd">let</code> <code class="nv">api</code> <code class="p">=</code> <code class="n">NetworkService</code><code class="p">()</code>&#13;
		<code class="n">api</code><code class="p">.</code><code class="n">delegate</code> <code class="p">=</code> <code class="kc">self</code>&#13;
		<code class="n">api</code><code class="p">.</code><code class="n">fetchData</code><code class="p">()</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="kd">extension</code> <code class="nc">APIClient</code><code class="p">:</code> <code class="n">NetworkServiceDelegate</code> <code class="p">{</code>&#13;
	<code class="kd">func</code> <code class="nf">fetchDidComplete</code><code class="p">(</code><code class="n">success</code><code class="p">:</code> <code class="nb">Bool</code><code class="p">,</code> <code class="n">with</code> <code class="n">error</code><code class="p">:</code> <code class="n">Error</code><code class="p">?)</code> <code class="p">{</code>&#13;
		<code class="k">if</code> <code class="n">success</code> <code class="p">{</code>&#13;
			<code class="bp">print</code><code class="p">(</code><code class="s">"Success!"</code><code class="p">)</code>&#13;
		<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
			<code class="bp">print</code><code class="p">(</code><code class="s">"Uh-oh!"</code><code class="p">)</code>&#13;
		<code class="p">}</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Stepping through this code, we can see a protocol named <code>NetworkServiceDelegate</code> is defined. The method signature for our callback method is similar to our <span class="keep-together"><code>completion</code></span> closure with <code>Bool</code> and <code>Error</code> arguments but is named instead of <span class="keep-together">anonymous</span>.</p>&#13;
&#13;
<p>Next, we provide a place within <code>NetworkService</code> to store our delegate in the aptly named property, <code>delegate</code>. This property is labeled as <code>weak</code> to prevent a reference cycle where a delegate stores its parent object; this would prevent either object from ever being freed from memory and is an easy thing to miss.</p>&#13;
&#13;
<p>You can see that a lot of the code is the same, but instead of calling the closure in <code>Network<span class="keep-together">Service</span></code>, we’re not calling the delegate directly through <code>delegate?.fetchDidComplete(<span class="keep-together">success:with:)</span></code>.</p>&#13;
&#13;
<p>To actually call our API, we need to create an object that instantiates <code>Network<span class="keep-together">Service</span></code>, sets itself as the delegate, and calls <code>fetchData()</code> to fetch data from the network. In this example, this is the purpose of the <code>APIClient</code> class.</p>&#13;
&#13;
<p>Finally, the actual implementation of the delegate method required in our <code>NetworkServiceDelegate</code> protocol at the start of the example is written as an extension to the <code>APIClient</code> class. Whenever we call the <code>fetchData</code> method, the method <code>fetchDidComplete(success:with:)</code> will be called, and our success or failure message will be printed out to the console.</p>&#13;
&#13;
<p>As you can more than likely see, this is slightly more verbose than a closure can be, but the calls are fairly straightforward. Now, it can become unwieldy quickly, but given how deeply ingrained within Cocoa Touch this callback pattern is, you’ll inevitably run into it at some point. A good rule of thumb is to use closures for any operation where asynchronicity matters or there is one path that a closure could be called from and use delegates when you (or multiple objects) want synchronous calls about whether or not an action should be completed or the status of a call.</p>&#13;
&#13;
<p>Eventually, it’s possible closures and delegates will not meet the requirements necessary without extra, and unnecessary, complexity. When the need for multiple closures executing in tandem or multiple delegates receiving the same message arises, it’s probably time to consider <code>NotificationCenter</code> and friends.<a data-primary="" data-startref="MPioscall05" data-type="indexterm" id="idm46177233545512"/><a data-primary="" data-startref="IOSmpcall05" data-type="indexterm" id="idm46177233544504"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dispatch a Message to Any Interested Subscribers" data-type="sect2"><div class="sect2" id="idm46177233747288">&#13;
<h2>Dispatch a Message to Any Interested Subscribers</h2>&#13;
&#13;
<p>Notifications<a data-primary="message passing" data-secondary="iOS" data-tertiary="to subscribers" data-tertiary-sortas="subscribers" data-type="indexterm" id="idm46177233541896"/><a data-primary="iOS" data-secondary="message passing" data-tertiary="to subscribers" data-tertiary-sortas="subscribers" data-type="indexterm" id="idm46177233540344"/><a data-primary="subscribers, passing messages to" data-secondary="iOS" data-type="indexterm" id="idm46177233538856"/> are a built-in and convenient way to send messages to other parts of your app to allow for decoupling between components. In order to receive the notifications being sent, an object “listens” for a shared object to post a message with a specific name. There can be data attached to that message, and it propagates throughout the application to any objects that are subscribed. Cocoa Touch<a data-primary="Cocoa Touch" data-secondary="notifications in" data-type="indexterm" id="idm46177233537400"/> calls these “notifications,” and this pattern is sometimes called “pub-sub” or “observer” in other languages and frameworks. The equivalent on Android is <code>LocalBroadcastManager</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>When<a data-primary="notifications" data-type="indexterm" id="idm46177233534728"/> we say “notifications,” we’re referring to a <code>Notification</code> object and not a push notification. And, to complicate matters further, “notification” means something entirely different on Android and corresponds to events in the system tray.</p>&#13;
</div>&#13;
&#13;
<p>Let’s start with posting a notification. Notification names are strings at their core, so you can post a notification with a raw string like so:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">Notification</code><code class="p">.</code><code class="n">Name</code><code class="p">(</code><code class="s">"didFinish"</code><code class="p">),</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code></pre>&#13;
&#13;
<p>Within this code block, the shared <code>NotificationCenter.default</code> object is used to post a notification with the name “didFinish.” Now, this is a great way to get started, but it’s not something you’d want to include in a finished app sent to the App Store. The issue lies in how brittle this implementation is by using a raw string when posting the notification. Objects that want to listen for your notification will use the name of the notification to react. If, for example, you were to decide to change the name of the notification to something else, for example <code>didFinishDownload</code>, then any object subscribed to <code>didFinish</code> would not receive your notification.</p>&#13;
&#13;
<p>It’s not too difficult to fix this. You’ll notice that the <code>post</code> method isn’t ingesting the raw string itself, we’re actually wrapping it in an enum called <code>Notification.Name</code>. To solve our problem, we can create a property on a class or structure that is a type of this enum and use that to <em>store</em> the raw string instead of passing it around and listening for it directly. This change allows any object to target that property when listening for notifications, so any changes to the property value (e.g., the notification name) will automatically be picked up by our listeners. Here’s an example of how this might look:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeObject</code> <code class="p">{</code>&#13;
	<code class="kd">public</code> <code class="kd">static</code> <code class="kd">let</code> <code class="nv">didFinishNotification</code> <code class="p">=</code> <code class="n">Notification</code><code class="p">.</code><code class="n">Name</code><code class="p">(</code><code class="s">"didFinish"</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code> <code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code></pre>&#13;
&#13;
<p>In our example, the class <code>SomeObject</code> defines a new static property named <code>didFinishNotification</code>. This contains the value of the enum we defined at the call site in the first example. Later, in the notification posting method, we use this property instead of declaring the value ourselves. This allows us to change the name of the notification from “didFinish” to something that might be more in line with best practices to prevent name collisions like “SomeObjectDidFinishNotification.”</p>&#13;
&#13;
<p>It’s also possible, and a fairly common practice, to attach data to a notification. You do this by using a slightly different <code>post</code> method that has an extra argument for a dictionary of values. Here’s an example:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code> <code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">userInfo</code><code class="p">:</code>&#13;
    <code class="p">[</code><code class="s">"downloadCount"</code><code class="p">:</code> <code class="mi">3</code><code class="p">])</code></pre>&#13;
&#13;
<p>In this example, we are passing in a dictionary that contains a key named “downloadCount” with a value of <code>3</code>. We could pass all kinds of data as long as it fits in a dictionary (i.e., as long as it conforms to <code>Hashable</code>). For example, if we wanted to pass an object, we might use the following code:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">anObject</code> <code class="p">=</code> <code class="n">SomeObject</code><code class="p">()</code>&#13;
<code class="kd">let</code> <code class="nv">count</code> <code class="p">=</code> <code class="mi">3</code>&#13;
&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code> <code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">userInfo</code><code class="p">:</code>&#13;
    <code class="p">[</code><code class="s">"someObject"</code><code class="p">:</code> <code class="n">anObject</code><code class="p">,</code> <code class="s">"downloadCount"</code><code class="p">:</code> <code class="bp">count</code><code class="p">])</code></pre>&#13;
&#13;
<p>You’ll notice in our example, we’re using predetermined raw strings again. It’s easy to demonstrate for our examples but best to avoid in finished code due to the brittle connections it creates. We can fix this in a way similar to our notification names by including a property on our class that corresponds to this key like so:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeObject</code> <code class="p">{</code>&#13;
	<code class="p">...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Use an extension to encapsulate your notification code</code>&#13;
<code class="kd">extension</code> <code class="nc">SomeObject</code> <code class="p">{</code>&#13;
	<code class="kd">public</code> <code class="kd">static</code> <code class="kd">let</code> <code class="nv">didFinishNotification</code> <code class="p">=</code>&#13;
      <code class="n">Notification</code><code class="p">.</code><code class="n">Name</code><code class="p">(</code><code class="s">"SomeObjectDidFinishNotification"</code><code class="p">)</code>&#13;
	<code class="kd">public</code> <code class="kd">static</code> <code class="kd">let</code> <code class="nv">didFinishNotificationObjectKey</code> <code class="p">=</code> <code class="s">"someObjectKey"</code>&#13;
	<code class="kd">public</code> <code class="kd">static</code> <code class="kd">let</code> <code class="nv">didFinishNotificationDownloadCountKey</code> <code class="p">=</code> <code class="s">"downloadCount"</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">post</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code> <code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code>&#13;
    <code class="n">userInfo</code><code class="p">:</code> <code class="p">[</code><code class="n">SomeObject</code><code class="p">.</code> <code class="n">didFinishNotificationObjectKey</code><code class="p">:</code> <code class="n">anObject</code><code class="p">,</code>&#13;
    <code class="n">SomeObject</code><code class="p">.</code> <code class="n">didFinishNotificationDownloadCountKey</code><code class="p">:</code> <code class="bp">count</code><code class="p">])</code></pre>&#13;
&#13;
<p>By using static properties for dictionary keys, you can add some compile-time safety to your notifications and make your code a bit more stable. When our notification properties start going beyond a notification name or two, it’s standard practice to split the code off into an extension, as shown previously.</p>&#13;
&#13;
<p>We’re posting notifications and passing data around, but there is still no one listening to what we’re saying. Let’s start subscribing to these notifications and see what that looks like.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Listen for, and React to, Messages Dispatched Within a System" data-type="sect2"><div class="sect2" id="idm46177233542968">&#13;
<h2>Listen for, and React to, Messages Dispatched Within a System</h2>&#13;
&#13;
<p>There<a data-primary="message passing" data-secondary="iOS" data-tertiary="within systems" data-type="indexterm" id="idm46177233166760"/><a data-primary="iOS" data-secondary="message passing" data-tertiary="within systems" data-type="indexterm" id="idm46177233165480"/> are two ways to subscribe to a notification in Swift: one with selectors (<code>@objc</code> methods) and one with closures. Both are very similar in nature but require slight differences to the code and the logic. Here’s what it looks like to use a selector (which is arguably much more common):</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeObject</code> <code class="p">{</code>&#13;
	<code class="kd">func</code> <code class="nf">listenForNotifications</code><code class="p">()</code> <code class="p">{</code>&#13;
		<code class="c1">// Subscribe to the notification</code>&#13;
		<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
        <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">selector</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">didFinishDownload</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
        <code class="n">name</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code><code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
	<code class="p">}</code>&#13;
&#13;
	<code class="kr">@objc</code> <code class="kd">func</code> <code class="nf">didFinishDownload</code><code class="p">(</code><code class="kc">_</code> <code class="n">notification</code><code class="p">:</code> <code class="n">Notification</code><code class="p">)</code> <code class="p">{</code>&#13;
		<code class="c1">// Get the notification payload</code>&#13;
		<code class="kd">let</code> <code class="nv">downloadCount</code> <code class="p">=</code>&#13;
       <code class="n">notification</code><code class="p">.</code><code class="n">userInfo</code><code class="p">?[</code><code class="n">SomeObject</code><code class="p">.</code><code class="n">didFinishNotificationDownloadCountKey</code><code class="p">]</code>&#13;
		<code class="bp">print</code><code class="p">(</code><code class="n">downloadCount</code><code class="p">)</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s break down this code.</p>&#13;
&#13;
<p>First, we’ve added a <code>listenForNotifications</code> method to our example class. Within this method, we add ourselves as observers to the notification we created previously, <code>SomeObject.didFinishNotification</code> . We add any object as an observer, a child object we are controlling as an example, but by passing <code>self</code> as the first argument, the object is assigning itself directly. We’re targeting the <code>didFinishDownload(_:)</code> selector, which is defined in the following as an<a data-primary="Objective-C" data-type="indexterm" id="idm46177233048600"/> Objective-C style method by using the <code>@objc</code> keyword in front of the method declaration.</p>&#13;
&#13;
<p>Now, as part of the <code>didFinishDownload(_:)</code> method, there is a <code>Notification</code> object passed in. This object contains a <code>userInfo</code> property. This is an optional <code>Dictionary</code> where the notification payload we passed in our previous example is accessed. Using our previously defined notification payload keys, <code>SomeObject.didFinishNotificationDownloadCountKey</code> in our example, we can access the data from the notification and then print it out to the console in the next line.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Closures Instead of Selectors" data-type="sect2"><div class="sect2" id="idm46177233044264">&#13;
<h2>Closures Instead of Selectors</h2>&#13;
&#13;
<p>Using<a data-primary="closures" data-secondary="versus selectors" data-secondary-sortas="selectors" data-type="indexterm" id="idm46177233042760"/><a data-primary="message passing" data-secondary="iOS" data-tertiary="closures versus selectors" data-type="indexterm" id="idm46177233041480"/><a data-primary="iOS" data-secondary="message passing" data-tertiary="closures versus selectors" data-type="indexterm" id="idm46177233040200"/> a closure to observe a notification is similar to the preceding selector-style observation. Here’s the same notification observation from our example as a closure instead of a selector:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeObject</code> <code class="p">{</code>&#13;
	<code class="kd">private</code> <code class="kd">var</code> <code class="nv">observer</code><code class="p">:</code> <code class="nb">AnyObject</code><code class="p">?</code>&#13;
&#13;
	<code class="kd">func</code> <code class="nf">listenForNotifications</code><code class="p">()</code> <code class="p">{</code>&#13;
		<code class="c1">// Subscribe to the notification</code>&#13;
		<code class="kc">self</code><code class="p">.</code><code class="n">observer</code> <code class="p">=</code> <code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
      <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="n">forName</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code><code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code>&#13;
      <code class="n">queue</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code> <code class="p">{</code> <code class="n">notification</code> <code class="k">in</code>&#13;
  <code class="kd">let</code> <code class="nv">downloadCount</code> <code class="p">=</code>&#13;
    <code class="n">notification</code><code class="p">.</code><code class="n">userInfo</code><code class="p">?[</code><code class="n">SomeObject</code><code class="p">.</code><code class="n">didFinishNotificationDownloadCountKey</code><code class="p">]</code>&#13;
    <code class="bp">print</code><code class="p">(</code><code class="n">downloadCount</code><code class="p">)</code>&#13;
		<code class="p">}</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>First, it’s important to point out the main difference between selector and closure observation: the observer is stored as a variable named <code>observer</code>. This object is created as a result of the <code>addObserver(forName:object:queue:using:)</code> method call inside of <code>listenForNotifications()</code>. We need to store a reference to this object because otherwise, our notification will actually get deallocated and will never be called. Later, once we unsubscribe from notifications, we will set this property to <code>nil</code> to allow everything to get deallocated from memory.</p>&#13;
&#13;
<p>The body of the closure passed in is the same as our <code>didFinishDownload(_:)</code> selector in the previous example; it grabs the payload passed as part of the notification and then prints out the value to the console.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Stop Listening for Notifications" data-type="sect2"><div class="sect2" id="idm46177233010392">&#13;
<h2>Stop Listening for Notifications</h2>&#13;
&#13;
<p>We’ve<a data-primary="notifications" data-type="indexterm" id="idm46177232957000"/><a data-primary="message passing" data-secondary="iOS" data-tertiary="stop listening for notifications" data-type="indexterm" id="idm46177232956264"/><a data-primary="iOS" data-secondary="message passing" data-tertiary="stop listening for notifications" data-type="indexterm" id="idm46177232955080"/> shown how to post a notification and how to listen for a notification. The last step in the process is to show how to stop listening for notifications. Given all the apparatus required to post notifications and listen for them, removing yourself as an observer is remarkably straightforward:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="c1">// Selector style</code>&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">removeObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Closure style</code>&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code><code class="p">.</code><code class="n">removeObserver</code><code class="p">(</code><code class="n">observer</code><code class="p">)</code>&#13;
<code class="kc">self</code><code class="p">.</code><code class="n">observer</code> <code class="p">=</code> <code class="kc">nil</code></pre>&#13;
&#13;
<p>This unsubscribes an object from all notifications it might be listening for and is something of a hammer for selector-style notifications but often a succinct way to sever ties to <code>NotificationCenter</code>. A better practice for selector-style notification subscriptions is to unsubscribe to the notifications by name. This is done with a method call like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">removeObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">name</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code><code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code></pre>&#13;
&#13;
<p>This code unsubscribes from only the <code>SomeObject.didFinishNotification</code> notification and leaves all other subscriptions intact.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The importance of removing an object as an observer from notifications might not be immediately obvious. By removing an object, you are effectively removing a reference count on that object and allowing it to be freed from memory if it’s no longer referenced by other objects. Memory leaks are a common and easy mistake to make, particularly with closure-based notification observation. Always remove yourself as an observer and don’t forget to <code>nil</code> out the observer objects for closure-based observation.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Targeting specific objects with notifications" data-type="sect3"><div class="sect3" id="idm46177232929256">&#13;
<h3>Targeting specific objects with notifications</h3>&#13;
&#13;
<p>Although it wasn’t mentioned earlier, you can target specific objects when observing notifications, allowing you to receive only notifications that object posts. You do this by passing the object as an argument in the <code>addObserver</code> method as shown here:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">objectToObserve</code> <code class="p">=</code> <code class="n">SomeObject</code><code class="p">()</code>&#13;
&#13;
<code class="c1">// You will only receive notifications that objectToObserve posts</code>&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">selector</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">didFinishDownload</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
    <code class="n">name</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code><code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="n">objectToObserve</code><code class="p">)</code>&#13;
&#13;
&#13;
<code class="n">There</code> <code class="n">a</code> <code class="n">few</code> <code class="n">different</code> <code class="n">types</code> <code class="n">of</code> <code class="n">combinations</code> <code class="n">available</code><code class="p">,</code> <code class="k">for</code> <code class="n">example</code><code class="p">:</code>&#13;
&#13;
&#13;
<code class="c1">// Receive all notifications from specificed object</code>&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">selector</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">didFinishDownload</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
    <code class="n">name</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="n">objectToObserve</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Receive all didFinishNotification notifications from all objects</code>&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">selector</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">didFinishDownload</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
    <code class="n">name</code><code class="p">:</code> <code class="n">SomeObject</code><code class="p">.</code><code class="n">didFinishNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// Receive all notifications from all objects (don't do this)</code>&#13;
<code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
    <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">selector</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">didFinishDownload</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
    <code class="n">name</code><code class="p">:</code> <code class="kc">nil</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Threading" data-type="sect3"><div class="sect3" id="idm46177232833832">&#13;
<h3>Threading</h3>&#13;
&#13;
<p>Notifications are received on the same thread from which they are posted. This means that in order to update a user interface when a notification was received on a background thread, it’s important to use something like <code>DispatchQueue</code> to dispatch to the main thread. This can be done by wrapping the code that needs to run on the main thread with a <code>DispatchQueue.main.async { … }</code> block like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeObject</code> <code class="p">{</code>&#13;
	<code class="p">...</code>&#13;
&#13;
	<code class="kr">@objc</code> <code class="kd">func</code> <code class="nf">listenForNotifications</code><code class="p">(</code><code class="kc">_</code> <code class="n">notification</code><code class="p">:</code> <code class="n">Notification</code><code class="p">)</code> <code class="p">{</code>&#13;
		<code class="n">DispatchQueue</code><code class="p">.</code><code class="n">main</code><code class="p">.</code><code class="n">async</code> <code class="p">{</code>&#13;
			<code class="n">updateUI</code><code class="p">()</code>&#13;
		<code class="p">}</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Key-value observation" data-type="sect3"><div class="sect3" id="idm46177232670104">&#13;
<h3>Key-value observation</h3>&#13;
&#13;
<p>Cocoa Touch<a data-primary="message passing" data-secondary="iOS" data-tertiary="key-value observation (KVO)" data-type="indexterm" id="idm46177232656328"/><a data-primary="iOS" data-secondary="message passing" data-tertiary="key-value observation (KVO)" data-type="indexterm" id="idm46177232655080"/><a data-primary="key-value observation (KVO)" data-type="indexterm" id="idm46177232653896"/><a data-primary="Cocoa Touch" data-secondary="key-value observation in" data-type="indexterm" id="idm46177232653256"/> has an entire system of message passing that wasn’t touched on due to the complexity of the subject: key-value observation (KVO). It’s possible to observe a single property of an object and receive updates whenever that property’s value is updated. Unfortunately, it’s a poorly designed and older API; you can only use it on objects that inherit from <code>NSObject</code>. It’s also easy to make mistakes without careful use, and even then, in the opinion of the authors, it’s rare when one of the preceding methods isn’t a better-suited option.</p>&#13;
&#13;
<p>If, however, you are interested, you can find out information about KVO from Apple’s <a href="https://oreil.ly/j8oQV">Key-Value Observing Programming Guide</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177232957944">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>We’ve covered a lot of ground in this chapter. You’ve seen:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>How to pass messages in a variety of ways in iOS and Android. There are direct callbacks that are very much a one-to-one way to pass messages.</p>&#13;
</li>&#13;
<li>&#13;
<p>How decoupled message passing is handled in both Android (<code>LocalBroadcastManager</code>) and iOS (<code>NotificationCenter</code>).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are many ways pass messages in your app. The lines blur depending on the situation, but given the methods described here, you can start making different parts of your application talk to each other. This is important in creating a maintainable and decoupled architecture.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>