<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Falco Rules"><div class="chapter" id="falco_rules">
<h1><span class="label">Chapter 7. </span>Falco Rules</h1>
<p><a contenteditable="false" data-primary="rules" data-type="indexterm" id="ch07.html0"/>Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.xhtml#understanding_falcoapostr">3</a> through <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.xhtml#fields_and_filters">6</a> gave you a comprehensive view of Falco’s architecture, describing most of the important concepts that a serious Falco user needs to understand. The remaining piece to cover is one of the most important ones: rules. Rules are at the heart of Falco. You’ve already encountered them several times, but this chapter approaches the topic in a more formal and comprehensive manner, giving you the foundation you will need as you work through the next parts of the book.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This chapter covers what rules are and their syntax. The goal is to give you all the knowledge you need to understand and use them, not to teach you to write your own. Writing your own rules will be covered in <a data-type="xref" href="part04.xhtml#iv_extending_falco">Part IV</a> of the book (in particular, in <a data-type="xref" href="ch13.xhtml#writing_falco_rules">Chapter 13</a>).</p>
</div>
<p>Falco is designed to be easy and intuitive, and the rule syntax and semantics are no exception. Rules files are straightforward, and you’ll be able to understand them in no time. Let’s start by covering some basics.</p>
<section data-type="sect1" data-pdf-bookmark="Introducing Falco Rules Files"><div class="sect1" id="introducing_falco_rules_files">
<h1>Introducing Falco Rules Files</h1>
<p><a contenteditable="false" data-primary="rules files" data-secondary="basics" data-type="indexterm" id="ch07.html1"/>Falco rules tell Falco what to do. They are typically packaged inside rules files, which Falco reads at startup time. A rules file is a YAML file that can contain one or more rules, with each rule being a node in the YAML body.</p>
<p>Falco comes packaged with a set of default rules files that are normally located in <em>/etc/falco</em>. The default rules files are loaded automatically if Falco is launched with no command-line options. These files are curated by the community and updated with every new release of Falco.</p>
<p class="pagebreak-before">When it starts, Falco will tell you which rules files have been loaded:</p>
<pre data-type="programlisting">$ <strong>sudo falco</strong>
Mon Jun  6 17:09:22 2022: Falco version 0.32.0 (driver version 
39ae7d40496793cf3d3e7890c9bbdc202263836b)
Mon Jun  6 17:09:22 2022: Falco initialized with configuration file 
/etc/falco/falco.yaml
Mon Jun  6 17:09:22 2022: Loading rules from file /etc/falco/falco_rules.yaml:
Mon Jun  6 17:09:22 2022: Loading rules from file 
/etc/falco/falco_rules.local.yaml:</pre>
<p>Often, you will want to load your own rules files instead of the default ones. You can do this in two different ways. The first one involves using the <code>-r</code> command-line option:</p>
<pre data-type="programlisting">$ <strong>sudo falco -r book_rules_1.yaml -r book_rules_2.yaml</strong> 
Mon Jun  6 17:10:17 2022: Falco version 0.32.0 (driver version 
39ae7d40496793cf3d3e7890c9bbdc202263836b)
Mon Jun  6 17:10:17 2022: Falco initialized with configuration file 
/etc/falco/falco.yaml
Mon Jun  6 17:10:17 2022: Loading rules from file book_rules_1.yaml:
Mon Jun  6 17:10:17 2022: Loading rules from file book_rules_2.yaml:</pre>
<p>And the second one involves modifying the <code>rules_file</code> section of the Falco configuration file (normally located at <em>/etc/falco/falco.yaml</em>), which looks like this by default:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">rules_file</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/falco/falco_rules.yaml</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/falco/falco_rules.local.yaml</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/falco/rules.d</code><code class="w"/></pre>
<p>You can add, remove, or modify entries in this section to control which rules files Falco loads.</p>
<p>Note that with both of these methods, you can specify a directory instead of a single file. For example:</p>
<pre data-type="programlisting">$ <strong>sudo falco -r ~/my_rules_directory</strong></pre>
<p>and:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">rules_file</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/home/john/my_rules_directory</code><code class="w"/></pre>
<p>This is handy because it lets you add and remove rules files by just altering the contents of a directory, without having to reconfigure Falco.</p>
<p class="pagebreak-after">As we mentioned, Falco’s default rules files are normally installed under <em>/etc/falco</em>. This directory contains files that are critical for Falco to function in different environments. <a data-type="xref" href="#falcoapostrophes_default_rules_files">Table 7-1</a> gives an overview of the most important ones.</p>
<table class="border" id="falcoapostrophes_default_rules_files">
<caption><span class="label">Table 7-1. </span>Falco’s default rules files</caption>
<thead>
<tr>
<th>Filename</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>falco_rules.yaml</em></td>
<td>This is Falco’s main rules file, containing the official set of system call–based rules for hosts and containers.</td>
</tr>
<tr>
<td><em>falco_rules.local.yaml</em></td>
<td>This is where you can add your own rules, or create overrides to modify existing rules, without risking polluting <em>falco_rules.yaml</em>. <a data-type="xref" href="ch13.xhtml#writing_falco_rules">Chapter 13</a> will cover rule creation and overriding in detail.</td>
</tr>
<tr>
<td><em>rules.available/application_rules.yaml</em></td>
<td>This file contains rules that target common applications like Cassandra and Mongo. Since this ruleset tends to be fairly noisy, it’s disabled by default.</td>
</tr>
<tr>
<td><em>k8s_audit_rules.yaml</em></td>
<td>This file contains rules that detect threats and misconfigurations by tapping into the Kubernetes audit log. This ruleset is not enabled by default; to use it, you need to enable it and configure the Falco <a href="https://oreil.ly/6aQEx">Kubernetes Audit Events plugin</a>.</td>
</tr>
<tr>
<td><em>aws_cloudtrail_rules.yaml</em></td>
<td>This file contains rules that perform detections by tapping into the stream of AWS CloudTrail logs. This ruleset is not enabled by default; to use it, you need to enable it and configure the Falco <a href="https://oreil.ly/1opUj">CloudTrail plugin</a>, as we will explain in <a data-type="xref" href="ch11.xhtml#using_falco_for_cloud_se">Chapter 11</a>.</td>
</tr>
<tr>
<td><em>rules.d</em></td>
<td>This empty directory is included in the default Falco configuration. This means you can add files to this directory (or create symlinks to your rules files in this directory) and Falco will automatically load them.</td>
</tr>
</tbody>
</table>
<p>By default, Falco loads two of these files: <em>falco_rules.yaml</em> and <em>falco_rules.local.yaml</em>. In addition, it mounts the <em>rules.d</em> directory, which you can use to extend the ruleset with no changes to the command line or to the configuration file.<a contenteditable="false" data-primary="" data-startref="ch07.html1" data-type="indexterm" id="idm45324226592752"/></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Anatomy of a Falco Rules File"><div class="sect1" id="anatomy_of_a_falco_rules_file">
<h1>Anatomy of a Falco Rules File</h1>
<p><a contenteditable="false" data-primary="rules files" data-secondary="contents" data-type="indexterm" id="ch07.html2"/>Now that you know what a rules file looks like from the outside, it’s time to learn what’s inside it. The YAML in a rules file can contain three different types of nodes: <em>rules</em>, <em>macros</em>, and <em>lists</em>. Let’s take a look at what these constructs are and the roles they play in rules files.</p>
<section data-type="sect2" data-pdf-bookmark="Rules"><div class="sect2" id="rules-id000047">
<h2>Rules</h2>
<p><a contenteditable="false" data-primary="rules" data-secondary="basics" data-type="indexterm" id="idm45324226584368"/><a contenteditable="false" data-primary="rules files" data-secondary="rules and" data-type="indexterm" id="idm45324226582992"/>A rule declares a Falco detection. You’ve seen several examples in the previous chapters, but as a reminder, a <a contenteditable="false" data-primary="rules" data-secondary="main purposes" data-type="indexterm" id="idm45324226581360"/>rule has two main purposes:</p>
<ol>
<li><p>Declare a condition that, when met, will cause the user to be notified</p></li>
<li><p>Define the output message that will be reported to the user when the condition is met</p></li>
</ol>
<p>Here’s an example rule, borrowed from <a data-type="xref" href="ch06.xhtml#fields_and_filters">Chapter 6</a>:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">File Becoming Executable by Others</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Attempt to make a file executable by other users</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">(evt.type=chmod or evt.type=fchmod or evt.type=fchmodat)</code><code class="w"/>
<code class="w">    </code><code class="no">and evt.arg.mode contains S_IXOTH</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">attempt to make a file executable by others</code><code class="w"/>
<code class="w">    </code><code class="no">(file=%evt.arg.filename mode=%evt.arg.mode user=%user.name</code><code class="w"/>
<code class="w">    </code><code class="no">failed=%evt.failed)</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">WARNING</code><code class="w"/>
<code class="w">  </code><code class="nt">source</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">syscall</code><code class="w"/>
<code class="w">  </code><code class="nt">tags</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">filesystem</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">book</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>This rule notifies us every time there is an attempt to change the permissions of a file to make it executable by another user.</p>
<p>As you can see in the preceding example, a rule contains several keys. Some of the keys are required, while others are optional. <a data-type="xref" href="#rule_fieldss">Table 7-2</a> contains a comprehensive list of the fields that you can use in a rule.</p>
<table class="border" id="rule_fieldss">
<caption><span class="label">Table 7-2. </span>Rule fields</caption>
<thead>
<tr>
<th>Key</th>
<th>Required</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>rule</code></td>
<td>Yes</td>
<td>A short sentence describing the rule and uniquely identifying it.</td>
</tr>
<tr>
<td><code>desc</code></td>
<td>Yes</td>
<td>A longer description that describes in more detail what the rule detects.</td>
</tr>
<tr>
<td><code>condition</code></td>
<td>Yes</td>
<td>The rule condition. This is a filter expression, with the syntax described in <a data-type="xref" href="ch06.xhtml#fields_and_filters">Chapter 6</a>, specifying the condition that needs to be met in order for the rule to trigger.</td>
</tr>
<tr>
<td><code>output</code></td>
<td>Yes</td>
<td>A <code>printf</code>-like message that is emitted by Falco when the rule triggers.</td>
</tr>
<tr>
<td><code>priority</code></td>
<td>Yes</td>
<td>The priority of the alert generated when the rule is triggered. Falco uses syslog-style priorities and therefore accepts the following values for this key: <code>EMERGENCY</code>, <code>ALERT</code>, <code>CRITICAL</code>, <code>ERROR</code>, <code>WARNING</code>, <code>NOTICE</code>, <code>INFORMATIONAL</code>, and <code>DEBUG</code>.</td>
</tr>
<tr>
<td><code>source</code></td>
<td>No</td>
<td>The data source to which the rule should be applied. If this key is not present, the source is assumed to be <code>syscall</code>. Each plugin defines its own source type that can be used as the value for this key. For example, use <code>aws_cloudtrail</code> for rules that contain conditions/outputs based on the CloudTrail plugin fields.</td>
</tr>
<tr>
<td><code>enabled</code></td>
<td>No</td>
<td>A Boolean key that can optionally be used to disable a rule. Disabled rules are not loaded by the engine and don’t require any resources when Falco is running. If this key is missing, <code>enabled</code> is assumed to be <code>true</code>.</td>
</tr>
<tr>
<td><code>tags</code></td>
<td>No</td>
<td>A list of tags that are associated with this rule. Tags have multiple uses, including easily selecting which rules to load and categorizing the alerts that Falco generates. We’ll talk about tags later in this chapter.</td>
</tr>
<tr>
<td><code><span class="keep-together">warn_evttypes</span></code></td>
<td>No</td>
<td>When set to <code>false</code>, this flag disables warnings about missing event type checks for this rule. When Falco loads a rule, in addition to validating its syntax, it runs a number of checks to make sure that the rule meets basic performance criteria. If you know what you are doing and you specifically want to craft a rule that doesn’t meet such criteria, this flag will prevent Falco from complaining. By default, the value of this flag is <code>true</code>.</td>
</tr>
<tr>
<td><code>skip-if-unknown-filter</code></td>
<td>No</td>
<td>Setting this flag to <code>true</code> causes Falco to silently skip this rule if the field is not accepted by the current version of the rule engine. If this flag is not set or set to <code>false</code>, Falco will print an error and exit when it encounters a rule that cannot be parsed.</td>
</tr>
</tbody>
</table>
<p>The key fields in the rule are <code>condition</code> and <code>output</code>. <a data-type="xref" href="ch06.xhtml#fields_and_filters">Chapter 6</a> talks about them extensively, so if you haven’t done so yet, we recommend that you consult that chapter for an overview.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Macros"><div class="sect2" id="macros">
<h2>Macros</h2>
<p><a contenteditable="false" data-primary="macros" data-secondary="rules and" data-type="indexterm" id="idm45324226441808"/><a contenteditable="false" data-primary="rules files" data-secondary="macros" data-type="indexterm" id="idm45324226440432"/>Macros are heavily used in the default Falco ruleset. They make it possible to “separate” portions of rules into independent and reusable entities. You can think of a macro as a piece of a condition that has been separated out and can be referenced by name. To explore this concept, let’s go back to the previous example and try to modularize it using a macro:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">File Becoming Executable by Others</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Attempt to make a file executable by other users</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">(evt.type=chmod or evt.type=fchmod or evt.type=fchmodat)</code><code class="w"/>
<code class="w">    </code><code class="no">and evt.arg.mode contains S_IXOTH</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">attempt to make a file executable by others</code><code class="w"/>
<code class="w">    </code><code class="no">(file=%evt.arg.filename mode=%evt.arg.mode user=%user.name</code><code class="w"/>
<code class="w">    </code><code class="no">failed=%evt.failed)</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">WARNING</code><code class="w"/></pre>
<p>Take a look at the condition: we match the event type against three different system calls because, well, the kernel offers three different system calls to change file permissions. In practice, these three system calls are all flavors of <a href="https://oreil.ly/qAdBA"><code>chmod</code></a>, with essentially the same arguments to check. We can make the same condition easier to read by isolating this complexity into a macro:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">macro</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chmod</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">(evt.type=chmod or evt.type=fchmod or evt.type=fchmodat)</code><code class="w"/>
<code class="w">  </code>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">File Becoming Executable by Others</code><code class="w"> </code>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">attempt to make a file executable by other users</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chmod and evt.arg.mode contains S_IXOTH</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">attempt to make a file executable by others </code><code class="w"/>
<code class="w">    </code><code class="no">(file=%evt.arg.filename mode=%evt.arg.mode user=%user.name</code><code class="w"/>
<code class="w">    </code><code class="no">failed=%evt.failed) </code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">WARNING</code><code class="w"/></pre>
<p>Note how the condition is much shorter and more readable. In addition, now we can reuse the <code>chmod</code> macro in other rules, simplifying all of them and making them consistent. Even more importantly, if we ever want to add another <code>chmod</code> system call that Falco should inspect, we have only one place to change (the macro) instead of multiple rules.</p>
<p>Macros help us keep our rulesets clean, modular, and maintainable.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Lists"><div class="sect2" id="lists">
<h2>Lists</h2>
<p><a contenteditable="false" data-primary="lists" data-secondary="rules files and" data-type="indexterm" id="idm45324226292736"/><a contenteditable="false" data-primary="rules files" data-secondary="lists" data-type="indexterm" id="idm45324226291360"/>Like macros, lists are heavily used in Falco’s default ruleset. Lists are collections of items that can be included from other parts of the ruleset. For example, lists can be included by rules, by macros, and even by other lists. The difference between a macro and a list is that the former is actually a condition and is parsed as a filtering expression. Lists, on the other hand, are more akin to arrays in a programming language.</p>
<p>Continuing with the previous example, an even better way to write it is the following:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">list</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chmod_syscalls</code><code class="w"/>
<code class="w">  </code><code class="nt">items</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">chmod</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">fchmod</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">fchmodat</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">macro</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chmod</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">(evt.type in (chmod_syscalls))</code><code class="w"/>
<code class="w">  </code>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">File Becoming Executable by Others</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">attempt to make a file executable by other users</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">chmod and evt.arg.mode contains S_IXOTH</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"> </code>
<code class="w">    </code><code class="no">attempt to make a file executable by others</code><code class="w"/>
<code class="w">    </code><code class="no">(file=%evt.arg.filename mode=%evt.arg.mode user=%user.name </code><code class="w"/>
<code class="w">    </code><code class="no">failed=%evt.failed)</code><code class="w"/></pre>
<p>What’s different this time? First, we’ve changed the <code>chmod</code> macro to use the <code>in</code> operator instead of doing three separate comparisons. This not only is more efficient, but it also gives us the opportunity to separate out the three system calls into a list. The list approach is great for rule maintenance because it allows us to isolate only the values into an array-like representation that is clear and compact and can easily be overridden if necessary (more on list overriding in <a data-type="xref" href="ch13.xhtml#writing_falco_rules">Chapter 13</a>).</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Rule Tagging"><div class="sect2" id="rule_tagging">
<h2>Rule Tagging</h2>
<p><a contenteditable="false" data-primary="rule tagging" data-type="indexterm" id="idm45324226187200"/><a contenteditable="false" data-primary="rules files" data-secondary="rule tagging" data-type="indexterm" id="idm45324226186096"/><a contenteditable="false" data-primary="tagging" data-secondary="rules and" data-type="indexterm" id="idm45324226184720"/><em>Tagging</em> is the concept of assigning labels to rules. If you are familiar with modern cloud computing environments like AWS or Kubernetes, you know that they let you attach labels to resources. Doing that lets you manage those resources more easily, as groups instead of individuals. Tagging brings the same philosophy to Falco rules: it lets you treat rules as cattle instead of pets.</p>
<p>This, for example, is a rule in the default Falco ruleset:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Launch Privileged Container</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"> </code>
<code class="w">    </code><code class="no">Detect the initial process started in a privileged container.</code><code class="w"/>
<code class="w">    </code><code class="no">Exceptions are made for known trusted images.</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">container_started and container</code><code class="w"/>
<code class="w">    </code><code class="no">and container.privileged=true</code><code class="w"/>
<code class="w">    </code><code class="no">and not falco_privileged_containers</code><code class="w"/>
<code class="w">    </code><code class="no">and not user_privileged_containers</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">Privileged container started </code><code class="w"/>
<code class="w">    </code><code class="no">(user=%user.name user_loginuid=%user.loginuid command=%proc.cmdline</code><code class="w"/>
<code class="w">    </code><code class="no">%container.info image=%container.image.repository:%container.image.tag)</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">INFO</code><code class="w"/>
<code class="w">  </code><code class="nt">tags</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">container</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">cis</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">mitre_privilege_escalation</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">mitre_lateral_movement</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Note how the rule has several tags, some indicating what the rule applies to (e.g., <code>container</code>) and others mapping it to compliance frameworks like CIS and MITRE ATT&amp;CK.</p>
<p>Falco lets you use tags to control which rules are loaded. This is done through two command-line flags, <code>-T</code> and <code>-t</code>. Here’s how it works:</p>
<ul>
<li><p>Use <code>-T</code> to disable rules with a specific tag. For example, to skip all rules with the <code>k8s</code> and <code>cis</code> tags, you can run Falco like this:</p>
<pre data-type="programlisting">$ <strong>sudo falco -T k8s -T cis</strong></pre></li>
<li><p>Use <code>-t</code> for the opposite purpose; i.e., to only run the rules that have the specified tag. For example, to only run the rules with the <code>k8s</code> and <code>cis</code> tags, you can use the following command line:</p>
<pre data-type="programlisting">$ <strong>sudo falco -t k8s -T cis</strong></pre></li>
</ul>
<p>Both <code>-T</code> and <code>-t</code> can be specified multiple times on the command line.</p>
<p>You can use any tags you want to decorate your rules. However, the default ruleset is standardized on a coherent set of tags. <a data-type="xref" href="#default_rule_tags">Table 7-3</a> shows what this standard set of tags is, according to the official Falco documentation.</p>
<table class="border" id="default_rule_tags">
<caption><span class="label">Table 7-3. </span>Default rule tags</caption>
<thead>
<tr>
<th>Tag</th>
<th>Used for</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>file</code></td>
<td>Rules related to reading/writing files and accessing filesystems</td>
</tr>
<tr>
<td><code>software_mgmt</code></td>
<td>Rules related to package management (rpm, dpkg, etc.) or to installing new software</td>
</tr>
<tr>
<td><code>process</code></td>
<td>Rules related to processes, command execution, and interprocess communication (IPC)</td>
</tr>
<tr>
<td><code>database</code></td>
<td>Rules that have to do with databases</td>
</tr>
<tr>
<td><code>host</code></td>
<td>Rules that apply to virtual and physical machines but <em>not</em> to containers</td>
</tr>
<tr>
<td><code>shell</code></td>
<td>Rules that apply to starting shells and performing shell operations</td>
</tr>
<tr>
<td><code>container</code></td>
<td>Rules that apply to containers and don’t work for hosts</td>
</tr>
<tr>
<td><code>k8s</code></td>
<td>Rules related to Kubernetes</td>
</tr>
<tr>
<td><code>users</code></td>
<td>Rules that apply to users, groups, and identity management</td>
</tr>
<tr>
<td><code>network</code></td>
<td>Rules detecting network activity</td>
</tr>
<tr>
<td><code>cis</code></td>
<td>Rules covering portions of the CIS benchmark</td>
</tr>
<tr>
<td><code>mitre_*</code></td>
<td>Rules covering the MITRE ATT&amp;CK framework (this is a category that includes several tags: <code>mitre_execution</code>, <code>mitre_persistence</code>, <code>mitre_privilege_escalation</code>, and so on)</td>
</tr>
</tbody>
</table>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Declaring the Expected Engine Version"><div class="sect2" id="declaring_the_expected_engine_version">
<h2>Declaring the Expected Engine Version</h2>
<p><a contenteditable="false" data-primary="engine versions" data-type="indexterm" id="idm45324226008480"/><a contenteditable="false" data-primary="rules files" data-secondary="declaring the expected engine version" data-type="indexterm" id="idm45324226007376"/>If you open a Falco rules file with a text editor, the first line you will normally see is a statement that looks like this:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">required_engine_version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">9</code><code class="w"/></pre>
<p>Declaring the minimum required engine version is optional, but it’s very important because it helps ensure that the version of Falco you are running will properly support the rules inside it. Some of the fields used in a ruleset may not exist in older versions of Falco, or a rule may require a system call that was added only recently. Without correct versioning, a rules file might not load or, even worse, it might load but produce incorrect results. If the rules file requires an engine version higher than the one supported by Falco, Falco will report an error and refuse to start.</p>
<p>Similarly, rules files can declare the plugin versions they are compatible with through the <code>required_plugin_versions</code> top-level field. This field is optional too; if you don’t include it, no plugin compatibility checks will be performed, and you may see similar behavior to that just described. The syntax of <code>required_plugin_versions</code> is as follows:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">required_plugin_versions</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><em><code class="l-Scalar-Plain">&lt;plugin_name&gt;</code></em><code class="w">
</code><code class="w">    </code><code class="nt">version</code><code class="p">:</code><code class="w"> </code><em><code class="l-Scalar-Plain">&lt;x.y.z&gt;</code></em><code class="w">
</code><code class="w">  </code><code class="p">...</code></pre>
<p>Below <code>required_plugin_versions</code> you specify a list of objects, each of which has two properties: <code>name</code> and <code>version</code>. If a plugin is loaded and a corresponding entry in <code>required_plugin_versions</code> is found, then the loaded plugin version must be <a href="https://semver.org">semver-compatible</a> with the <code>version</code> property.</p>
<p>The default rules files that come prepackaged with Falco are all versioned. Don’t forget to do the same in each of your rules files!<a contenteditable="false" data-primary="" data-startref="ch07.html2" data-type="indexterm" id="idm45324225951760"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Replacing, Appending to, and Disabling Rules"><div class="sect1" id="replacingcomma_appending_tocomma_and_di">
<h1>Replacing, Appending to, and Disabling Rules</h1>
<p><a contenteditable="false" data-primary="lists" data-secondary="replacing" data-type="indexterm" id="ch07.html3"/><a contenteditable="false" data-primary="macros" data-secondary="replacing" data-type="indexterm" id="ch07.html4"/><a contenteditable="false" data-primary="rules" data-secondary="replacing" data-type="indexterm" id="ch07.html5"/><a contenteditable="false" data-primary="rules files" data-secondary="replacing macros/lists/rules" data-type="indexterm" id="ch07.html6"/>Falco comes prepackaged with a rich and constantly growing set of rules that covers many important use cases. However, there are many situations where you might find it beneficial to customize the default ruleset. For example, you might want to decrease the noisiness of some rules, or you might be interested in expanding the scope of some of the Falco detections to better match your environment.</p>
<p>One way to approach these situations is to edit the default rules files. An important lesson to learn is that you don’t have to do this. Actually, you <em>shouldn’t</em> do this—Falco offers a more versatile way to customize rules, designed to make your changes maintainable and reusable across releases. Let’s take a look at how this works.</p>
<section data-type="sect2" data-pdf-bookmark="Replacing Macros, Lists, and Rules"><div class="sect2" id="replacing_macroscomma_listscomma_and_ru">
<h2>Replacing Macros, Lists, and Rules</h2>
<p>Replacing a list, macro, or rule is just a matter of redeclaring it. The second declaration can be in the same file, or in a separate file that is loaded after the one containing the original declaration.</p>
<p>Let’s see how this works through an example. The following rule detects if a text editor has been opened as root (which, as we all know, people should avoid doing):</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">list</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">editors</code><code class="w"/>
<code class="w">  </code><code class="nt">items</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">vi</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">nano</code><code class="p-Indicator">]</code><code class="w"/>
<code class="w">  </code>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">macro</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">editor_started</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">(evt.type = execve and proc.name in (editors))</code><code class="w"/>
<code class="w">  </code>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Text Editor Run by Root</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">the root user opened a text editor</code><code class="w"> </code>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">editor_started and user.name=root</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">the root user started a text editor (cmdline=%proc.cmdline)</code><code class="w"> </code>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">WARNING</code><code class="w"/></pre>
<p>If we save this rule in a rules file called <em>rulefile.yaml</em>, we can test the rule by loading the file in Falco:</p>
<pre data-type="programlisting">$ <strong>sudo falco -r rulefile.yaml</strong></pre>
<p>The rule will trigger every time we run vi or nano as root.</p>
<p>Now say we want to change the rule to support a different set of text editors. We can create a second rules file, name it <em>editors.yaml</em>, and populate it in the following way:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">list</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">editors</code><code class="w"/>
<code class="w">  </code><code class="nt">items</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">emacs</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">subl</code><code class="p-Indicator">]</code><code class="w"/></pre>
<p>Note how we redefined the content of the <code>editors</code> list, replacing the original command names with <code>emacs</code> and <code>subl</code>. Now we just load <em>editors.yaml</em> after the original rules file:</p>
<pre data-type="programlisting">$ <strong>sudo falco -r rulefile.yaml -r editors.yaml</strong></pre>
<p>Falco will pick up the second definition of <code>editors</code> and generate an alert when root runs either emacs or subl, but <em>not</em> vi or nano. Essentially, we’ve replaced the content of the list.</p>
<p>This trick works exactly the same way with macros and rules as well.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Appending to Macros, Lists, and Rules"><div class="sect2" id="appending_to_macroscomma_listscomma_and">
<h2>Appending to Macros, Lists, and Rules</h2>
<p><a contenteditable="false" data-primary="lists" data-secondary="appending to" data-type="indexterm" id="idm45324225790720"/><a contenteditable="false" data-primary="macros" data-secondary="appending to" data-type="indexterm" id="idm45324225789344"/><a contenteditable="false" data-primary="rules" data-secondary="appending to" data-type="indexterm" id="idm45324225787968"/><a contenteditable="false" data-primary="rules files" data-secondary="appending to macros/lists/rules" data-type="indexterm" id="idm45324225786592"/>Let’s stick to the same text editor rule example. This time, however, suppose we want to <em>append</em> additional names to the list of editors instead of replacing the full list. The mechanism is the same, but with the addition of the <code>append</code> keyword. Here is the syntax:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">list</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">editors</code><code class="w">
</code><code class="w">  </code><code class="nt">items</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="nv">emacs</code><code class="p-Indicator">,</code><code class="w"> </code><code class="nv">subl</code><code class="p-Indicator">]</code><code class="w">
</code><code class="w">  </code><code class="nt">append</code><code class="p">:</code><code class="w"> </code><strong><code class="l-Scalar-Plain">true</code></strong></pre>
<p>We can save this list in a file named <em>additional_editors.yaml</em>. Now, if we run the following command line:</p>
<pre data-type="programlisting">$ <strong>sudo falco -r rulefile.yaml -r editors.yaml</strong></pre>
<p>Falco will detect root execution of vi, nano, emacs, and subl.</p>
<p>You can append (using the same syntax) to macros and rules as well. However, there are a couple of things to keep in mind:</p>
<ul>
<li><p>For rules, it is only possible to append to the condition. Attempts to append to other keys, like <code>output</code>, will be ignored.</p></li>
<li><p>Remember that appending to a condition just attaches the new text at the end of it, so be careful about ambiguities.</p></li>
</ul>
<p>For example, suppose we extended the rule condition in our example by appending to it like this:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Text</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">Editor</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">Run</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">by</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">Root</code><code class="w">
</code><code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">or</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">user.name</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">=</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">loris</code><code class="w">
</code><code class="w">  </code><code class="nt">append</code><code class="p">:</code><code class="w"> </code><strong><code class="l-Scalar-Plain">true</code></strong></pre>
<p>The full rule condition would become:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">editor_started and user.name=root or user.name = loris</code><code class="w"/></pre>
<p>This condition is clearly ambiguous. Will the rule trigger only whenever the user root or loris opens a text editor? Or will it trigger when root opens a text editor and when loris executes <em>any</em> command? To avoid such ambiguities, and to make your rules files more readable, you can use parentheses in the original conditions.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Disabling Rules"><div class="sect2" id="disabling_rules">
<h2>Disabling Rules</h2>
<p><a contenteditable="false" data-primary="disabling rules" data-type="indexterm" id="idm45324225650128"/><a contenteditable="false" data-primary="rules files" data-secondary="disabling rules" data-type="indexterm" id="idm45324225649264"/>You will often encounter situations where you need to disable one or more rules in a ruleset, for example because they are too noisy or they are just not relevant for your environment. Falco provides different ways to do this. We are going to cover two of them: using the command line and overriding the <code>enabled</code> flag.</p>
<section data-type="sect3" data-pdf-bookmark="Disabling rules from the command line"><div class="sect3" id="disabling_rules_from_the_command_line">
<h3>Disabling rules from the command line</h3>
<p><a contenteditable="false" data-primary="command line, disabling rules from" data-type="indexterm" id="idm45324225645568"/><a contenteditable="false" data-primary="disabling rules" data-secondary="from command line" data-secondary-sortas="command line" data-type="indexterm" id="idm45324225644272"/>Falco actually offers two separate ways to disable rules via the command line. The first one, which we discussed when talking about rule tagging earlier in this chapter, involves using the <code>-T</code> flag. As a refresher, you can use <code>-T</code> to disable rules with the given tag. <code>-T</code> can be used multiple times on the command line to disable multiple tags. For example, to skip all rules with either the <code>k8s</code> tag, the <code>cis</code> tag, or both, you can run Falco like this:</p>
<pre data-type="programlisting">$ <strong>sudo falco -T k8s -T cis</strong></pre>
<p>The second way to disable rules from the command line is by using the <code>-D</code> flag. <span class="keep-together"><code>-D <em>&lt;substring&gt;</em></code></span> disables all the rules that include <code><em>&lt;substring&gt;</em></code> in their name. Similarly to <code>-T</code>, <code>-D</code> can be specified multiple times with different arguments.</p>
<p>These parameters can also be specified as a Helm chart value (<code>extraArgs</code>) if you are deploying Falco via the official Helm chart.</p>
</div></section>
<section data-type="sect3" data-pdf-bookmark="Disabling rules by overriding the enabled flag"><div class="sect3" id="disabling_rules_by_overriding_the_enabl">
<h3>Disabling rules by overriding the enabled flag</h3>
<p><a contenteditable="false" data-primary="disabling rules" data-secondary="overriding the enabled flag" data-type="indexterm" id="idm45324225613264"/><a contenteditable="false" data-primary="enabled field" data-type="indexterm" id="idm45324225611920"/><a contenteditable="false" data-primary="enabled flag" data-type="indexterm" id="idm45324225610816"/>You might remember from <a data-type="xref" href="#rule_fieldss">Table 7-2</a> that one of the optional rule fields is called <code>enabled</code>. As a refresher, here’s how we documented it earlier in the chapter:</p>
<blockquote>
<p>A Boolean key that can optionally be used to disable a rule. Disabled rules are not loaded by the engine and don’t require any resources when Falco is running. If this key is missing, <code>enabled</code> is assumed to be <code>true</code>.</p>
</blockquote>
<p><code>enabled</code> can be turned on or off by overriding the rule with the usual mechanism. For example, if you want to disable the <em>User mgmt binaries</em> rule in <em>/etc/falco/falco_rules.yaml</em>, you can add the following content in <em>/etc/falco/falco_rules.local.yaml</em>:<a contenteditable="false" data-primary="" data-startref="ch07.html6" data-type="indexterm" id="idm45324225604080"/><a contenteditable="false" data-primary="" data-startref="ch07.html5" data-type="indexterm" id="idm45324225602704"/><a contenteditable="false" data-primary="" data-startref="ch07.html4" data-type="indexterm" id="idm45324225601328"/><a contenteditable="false" data-primary="" data-startref="ch07.html3" data-type="indexterm" id="idm45324225599952"/></p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">User</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">mgmt</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">binaries</code><code class="w">
</code><code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><strong><code class="l-Scalar-Plain">false</code></strong></pre>
</div></section>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000006">
<h1>Conclusion</h1>
<p>You see, it wasn’t that hard! At this point, you should be able to read and understand Falco rules, and you are much closer to being able to write your own. We’ll focus on rule writing in <a data-type="xref" href="part04.xhtml#iv_extending_falco">Part IV</a> of the book, and in particular in <a data-type="xref" href="ch13.xhtml#writing_falco_rules">Chapter 13</a>. Our next step will be learning everything about Falco outputs.<a contenteditable="false" data-primary="" data-startref="ch07.html0" data-type="indexterm" id="idm45324225581216"/></p>
</div></section>
</div></section></div></body></html>