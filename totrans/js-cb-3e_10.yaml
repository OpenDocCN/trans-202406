- en: Chapter 9\. Asynchronous Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript was built as a single-threaded programming language, with one call
    stack, one memory heap, and able to execute just one code routine at a time. But
    over the years, JavaScript has grown. It’s acquired the ability to send network
    messages, read files, and wait for user confirmation—all operations that might
    take time and could lock up the user interface. To handle these operations safely,
    JavaScript has introduced its own asynchronous programming patterns.
  prefs: []
  type: TYPE_NORMAL
- en: In the early days, JavaScript’s asynchronous support revolved around *callbacks*.
    With a callback, you request an operation (say, fetching an image from the web)
    and the browser does the work on another thread, outside of your application code.
    When the image has finished downloading and your application is idle, JavaScript
    triggers your callback and passes the data back to your code. The end result is
    that your application code is still single-threaded, but you have the ability
    to launch asynchronous work through a set of standardized web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks are still found all over JavaScript, but in recent years they’ve been
    wrapped with more polished language features, like *promises* and the `async`
    and `await` keywords. The underlying plumbing is the same, but now it’s possible
    to create sophisticated applications that manage concurrent asynchronous tasks,
    handle sequences of asynchronous calls, and deal gracefully with unexpected errors.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll use callback and promises to manage asynchronous tasks.
    You’ll also see how you can break out of JavaScript’s single-threaded model and
    perform continuous background work with the Web Worker API.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Page During a Loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to update the page during a long, CPU-intensive operation, but the
    browser won’t repaint the window while it’s busy.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `setTimeout()` function periodically to queue your work. Contrary to
    the name, you don’t need to set a delay with `setTimeout()`. Instead, use a timeout
    value of `0` to schedule the next step in your operation to execute immediately,
    as soon as the UI thread is idle.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this loop, which increments a counter for 10 seconds
    (10,000 milliseconds). After each pass through the loop, it attempts to change
    the text in a `<p>` element named `status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you run this code, you won’t see any of the “Just generated number” messages.
    Instead, the page will become unresponsive for 10 seconds, then display “Processing
    completed.”
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the problem, you move the work (in this case, incrementing the counter
    and showing a message) to a separate function. Then, instead of calling this function
    over and over again in a loop, you call it with `setTimeout()`. Each time, the
    function increments the counter, updates the page, and then calls `setTimeout()`
    for *another* pass, until the 10-second time limit has finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `doChunkedTask` variable holds an anonymous function that’s defined
    with arrow function syntax ([“Using Arrow Functions”](ch06.html#arrow_functions)).
    You don’t need to use an anonymous function or arrow syntax, but it simplifies
    the code. The `doChunkedTask` function gets access to everything that’s in scope
    when you create it, including the `startTime` and `statusElement` variables. As
    a result, you don’t need to worry about passing this information to the function,
    which would be necessary if you declared it separately.
  prefs: []
  type: TYPE_NORMAL
- en: When you run this code, you’ll see the numbers quickly flash by in the paragraph
    on the web page, and then be replaced with the completion message after 10 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has a mature solution for asynchronous work with the *web workers*
    feature (see [“Using a Web Worker to Perform a Background Task”](#using_web_workers)).
    However, you don’t always need this level of sophistication. Web workers are great
    if you have a long-running task, an asynchronous operation that needs to accept
    chunks of data as it works, or an asynchronous operation that needs support for
    cancellation. But if you’re dealing with a relatively short task and you have
    more modest requirements—for example, you just want to update the page during
    a brief burst of CPU-intensive work—the `setTimeout()` approach works perfectly
    well.
  prefs: []
  type: TYPE_NORMAL
- en: In the example presented here, the `setTimeout()` method is called repeatedly.
    Each time, the page relinquishes control and waits for the browser to schedule
    the requested function, which it does as soon as the main application thread is
    idle (in this case, almost instantaneously). To understand how this works, it’s
    important to realize that `setTimeout()` does not set *exactly* when a function
    will run. Instead, it sets a *minimum* time interval. When the `setTimeout()`
    timer ends, it asks the browser to execute the function, but it’s up to the browser
    to schedule this request. If the browser is busy, the request will be delayed.
    (In fact, even if the browser isn’t busy, modern browsers throttle a sequence
    of requests so it is never triggered more frequently than once every 4 milliseconds.)
    But in practice these delays are very small, and calling `setTimeout()` with a
    value of 0 milliseconds causes your code to be triggered almost immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The `setTimeout()` method isn’t the only method JavaScript has for scheduling
    work with a timer. There’s also the `window.setInterval()` method, which calls
    a function repeatedly, with a fixed wait time before each subsequent call. And
    if you want to use a timer to create an animation (for example, by redrawing objects
    in a `<canvas>`), it’s better to use `requestAnimationFrame()`, which synchronizes
    itself with the browser’s repainting operations to make sure you don’t waste resources
    calculating an animation more frequently that it can be shown.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both the `setTimeout()` and the `setInterval()` methods are ancient parts of
    JavaScript. However, they are not obsolete or deprecated. For more complex scenarios,
    you should web workers rather than roll your own custom solutions built on `setTimeout()`
    or `setInterval()`. However, both methods are still acceptable.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Using a Web Worker to Perform a Background Task”](#using_web_workers) describes
    how to carry out more ambitious operations in the background using web workers.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Function That Returns a Promise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to run code when an asynchronous task completes (successfully or unsuccessfully).
    You want to be notified about task completion through a `Promise` object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Promise` is an object that helps you manage an asynchronous task. It tracks
    the status of the task and—most importantly—handles the callbacks that notify
    your code when the task succeeds or fails. Technically, promises don’t add new
    functionality to JavaScript, but they do make it easier to cleanly coordinate
    a sequence of asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use promises, the API you’re calling must support them. There’s
    rarely any ambiguity about this, because APIs that support promises have methods
    that return `Promise` objects. Older APIs that *don’t* use promises will ask you
    to supply one or more callback functions or handle a specific event. (If you want
    to use a promise with a callback-based API, see [“Promisifying an Asynchronous
    Function That Uses a Callback”](#promisifying_callback_function) instead.)
  prefs: []
  type: TYPE_NORMAL
- en: To specify what should happen after a promise finishes, you call `Promise.then()`
    and supply a function. To specify what should happen in the case of an error,
    you call `Promise.catch()` and supply a different function. To add some clean-up
    code that should run after the promise has succeeded *or* failed, you call `Promise.finally()`
    with a third function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a naïve implementation of promises, using the Fetch API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If the call succeeds, you’ll see the HTTP status appear in the console window,
    followed by the “All done” message.
  prefs: []
  type: TYPE_NORMAL
- en: This example shows the structure of a basic promise call, but it isn’t the way
    we typically write promise-based code, for two reasons. First, for more compact
    and readable code, we favor declaring the functions with arrow function syntax
    ([“Using Arrow Functions”](ch06.html#arrow_functions)). Second, the `then()`,
    `catch()`, and `finally()` methods are usually chained into one statement. This
    is possible because these methods all return the same `Promise` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the more compact and more typical way to write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This promise-based example uses just a single statement, and you’re able to
    break the line wherever you like. One common convention, which we’ve used here,
    is to break the statement just *before* the dot operator, so the next line begins
    with `.then` or `.catch`. This way, the code is easy to follow and has an error-handling
    layout that’s similar to synchronous code. This is also the structure applied
    by the Prettier code formatter ([“Styling Code Consistently with a Formatter”](ch01.html#using_prettier)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Promise` object is not a result, but a *placeholder* for a result that will
    be available in the future.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as you create a `Promise` object, its code begins to execute. It’s even
    possible that the `Promise` may finish its work before you call `then()` or `catch()`.
    This won’t change how your code works. If you call `then()` on a promise that’s
    already resolved (successfully), or `catch()` on a promise that’s already rejected
    (with an error), your code runs right away.
  prefs: []
  type: TYPE_NORMAL
- en: The simple solution shown here uses chaining to attach a success function (with
    `then()`) and a failure function (with `catch()`). However, it’s also common to
    use chaining to tie multiple asynchronous tasks together, so they run one after
    the other. The `fetch()` function provides a good example. It returns a promise
    that resolves once the server responds. However, if you want to read the body
    of this message, you need to start a second asynchronous operation. (This sounds
    needlessly painful, but it makes perfect sense, because the amount of data being
    sent could be huge, so you don’t want to risk blocking your code while you retrieve
    it. In JavaScript, I/O operations are always asynchronous.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that performs an asynchronous `fetch` request, then reads
    the results as a binary stream using `response.blob()`, which returns a second
    `Promise` object. Now `then()` is called on that object to add a third step—turning
    the binary data into a Base64-encoded string that can be shown in an `<img>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Good code formatting is important, because a promise chain can become quite
    long. But if organized consistently, your asynchronous calls can look similar
    to a linear block of code, which is a significant improvement over the past, when
    developers coined the term *callback hell* to describe nested pyramids of consecutive
    callback functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'When chaining multiple promises, you call `catch()` and `finally()` at the
    end of the chain, if you decide to use them. That gives you one place to collect
    unhandled errors that occur during any stage of the promise chain. You can even
    throw your own exceptions in a `then()` function to signify failure and end the
    chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As soon as an unhandled error occurs, the entire promise chain is derailed.
    You can react to this error to perform logging or some other diagnostic task,
    but you can’t resume the promises that were abandoned further down the chain.
    If you don’t catch an error in a promise, it’s eventually raised as the `window.unhandledrejection`
    event and, if not canceled there, it’s logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Chapter 13](ch13.html#ch13) explains the Fetch API in more detail. [“Executing
    Multiple Promises Concurrently”](#concurrent_promises) shows how to link concurrent
    tasks with a promise. [“Waiting for a Promise to Finish with Await and Async”](#using_await)
    shows how to use `fetch()` with the `await` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Promisifying an Asynchronous Function That Uses a Callback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to change a callback-based asynchronous function to use a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create another function to wrap your asynchronous function. This function creates
    and returns a new `Promise` object. When the asynchronous task finishes, the function
    calls either `Promise.resolve()` if it succeeded or `Promise.reject()` if it failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a function that acts like a traditional, callback-based
    asynchronous function. It uses a timer to perform its asynchronous work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There’s no benefit to calculating factorials asynchronously or to using a timer.
    This example is just a stand-in for any older API that uses callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, you can use the `factorializeNumber()` function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to promisify the `factorializeNumber()` function is to create
    a new function that wraps it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can call `factorializeNumberPromise()`, receive a `Promise` object,
    and handle the result with `Promise.then()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can also catch potential errors, and even create a whole chain of asynchronous
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before going deeper into this solution, it’s important to address one possible
    misconception right away. It’s easy to create a function that returns a `Promise`
    object. However, this does *not* make your code asynchronous. Your code will run
    synchronously on the UI thread, as usual. (It’s similar to calling `setTimeout()`
    with a delay of 0.)
  prefs: []
  type: TYPE_NORMAL
- en: To get around this limitation, the `factorializeNumber()` example uses a timer
    to simulate an asynchronous API. If you really want to run your own code in the
    background on another thread, you need to use the Web Workers API ([“Using a Web
    Worker to Perform a Background Task”](#using_web_workers)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In JavaScript you’ll use promises often, but you’ll create them rarely. The
    most common reason for creating a `Promise` object is because you’re wrapping
    older callback-based code, as in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a promisified version of a function, you need a function that creates
    a `Promise` object and returns it. That’s the main job of the `factorializeNumberPromise()`
    function. And although creating a `Promise` is easy, it can look complex at first
    because there are two layers of nested functions at work. t its heart, the `Promise`
    object wraps a function that has this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The promise function receives two parameters, which are essentially callback
    functions. You use these functions to signal the completion of the promise. Call
    `resolve()` (with your return value) to successfully end the promise, or `reject()`
    (with an error object) to indicate a failure. Alternately, if an unhandled error
    occurs anywhere in your promise function, the `Promise` object will catch it and
    automatically call `reject()`, passing the error along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the promise function, you launch your asynchronous task. Or, in the
    `factorializeNumberPromise()` example, you call the existing `factorializeNumber()`
    function that starts the timer. You still need to use the callback functions to
    interface with the old `factorializeNumber()` function. The difference is that
    now you will forward them through the promise by calling `resolve()` or `reject()`.
    For example, here’s the function for the `successCallback`, which calls `resolve()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s the failure callback that calls `reject()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `Promise.reject()` method takes one argument, which represents the reason
    for the failure. This reason can be any type of object, but it’s strongly recommended
    that you use an instance of the `Error` object or a custom object that derives
    from `Error` ([“Throwing a Custom Error”](ch10.html#throwing_custom_errors)).
    In the current example, the failure callback already sends an `Error` object,
    so we can simply pass that to `reject()`.
  prefs: []
  type: TYPE_NORMAL
- en: The full solution makes the code more compact by declaring the `successCallback`,
    the `failureCallback`, and the promise function that holds them with arrow syntax
    ([“Using Arrow Functions”](ch06.html#arrow_functions)).
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to write a generic promisifying function that can promisify any
    callback-based function. In fact, some libraries, like BlueBird.js, provide this
    functionality. However, in most cases it’s simpler and less confusing to use promisification
    judiciously—for example, when you want to unify one asynchronous task with another
    one that already uses promises—rather than attempt to wrap every old asynchronous
    API.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re developing for the Node runtime environment, you can use the `promisify`
    utility to wrap a function with a promise, as described in [“Managing Callback
    Hell”](ch19.html#managing_callback_hell).
  prefs: []
  type: TYPE_NORMAL
- en: Executing Multiple Promises Concurrently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to execute multiple promises at the same time, and react once all the
    promises have finished their work.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the static `Promise.all()` method to combine multiple promises into a single
    promise and wait for them all to resolve successfully (or for any one of them
    to fail).
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how this works, imagine you have a function that returns a promise
    that resolves after a wait of roughly 0 to 10 seconds. Here’s a `randomWaitPromise()`
    function that does exactly that using `setTimeout()`. Treat it as a stand-in for
    any asynchronous operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can use `randomWaitPromise()` to quickly create any number of new promises.
    To wait for several promises to finish, you need to place all the `Promise` objects
    in an array, and pass that array to the `Promise.all()` method. `Promise.all()`
    returns a new promise that represents the completion of all your promises. Using
    that, you can call `then()` and `catch()` to build a promise chain, like usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: There’s no `Promise.catch()` in this chain, because it’s impossible for this
    code to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this example, each promise will write to the console as it finishes.
    When the last, slowest promise resolves, you’ll get the final “All done” message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you’re using several promises at a time, it’s common to pass an object
    with some sort of identifier to your promise (like a URL or an ID). Then, when
    the promise resolves it can pass back an object that includes this identifying
    detail. This way, you can determine which result goes with which promise. This
    tracking is convenient, but it isn’t necessary, because you can tell which result
    is which by their order. The order of the results that you receive in the results
    array matches the order of the promises that you submitted originally in the promises
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One advantage of asynchronous programming is being able to collapse your wait
    time. In other words, rather than wait for one task to complete, and then another,
    and then another, you can start all three at once. In real life, this is somewhat
    of a specialized scenario. It’s far more common to have an asynchronous task that
    depends on the results from another asynchronous task, in which case you need
    to chain one task after the other. But if this isn’t the case, you can save considerable
    time by running multiple promises at once and waiting for them with `Promise.all().`
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.all()` uses a *fail-fast* behavior. As soon as one of the promises
    is rejected (either deliberately by calling `Promise.reject()` or with an unhandled
    error), the combined promise you created with `Promise.all()` is also rejected,
    triggering whatever function you attached to the promise chain with `Promise.catch()`.
    The other promises will still run, and you can get their results from the corresponding
    `Promise` objects. For example, if `promise1` rejects, nothing stops you from
    calling `promise2.then()` to get its result. But in practice, when you use `Promise.all()`
    you will probably treat a failure in one promise as the end of your combined operation.
    Otherwise, it would be easier to keep your promises separate, or use one of the
    alternative `Promise` methods listed below.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other static `Promise` methods besides `all()` that accept multiple
    promises and return a single combined promise. They all have slightly different
    behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.allSettled()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Resolves when every promise has been resolved *or* rejected. (This is unlike
    `Promise.all()`, which only resolves if *all* the promises are successful.) The
    function you attach with `Promise.then()` receives an array of result objects,
    one for each promise. Each result object has two properties: `status` indicates
    if the promise was fulfilled or rejected, and `value` has the returned value or
    error object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.any()`'
  prefs: []
  type: TYPE_NORMAL
- en: Resolves as soon as one promise has resolved successfully. It provides the value
    for that promise only.
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.race()`'
  prefs: []
  type: TYPE_NORMAL
- en: Resolves as soon as one promise has resolved successfully or been rejected.
    It’s the most specialized of all the `Promise` methods, but it can be used to
    build some sort of custom scheduling system that queues up new asynchronous tasks
    as existing ones are finished.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for a Promise to Finish with Await and Async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of creating a promise chain, you want to write linear logic that’s easier
    to read and looks more like synchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Don’t call `Promise.then()`. Instead, use the `await` keyword on your promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The code after `await` doesn’t run until the awaited promise has been resolved
    or rejected. The execution of your code pauses, but without blocking the thread,
    locking up the UI, or preventing other timers and events from triggering.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s a catch. The `await` keyword is only useable inside an `async`
    function. That means you may need some rearranging to use `await`. Consider the
    `fetch()` example from [“Using a Function That Returns a Promise”](#async_call_with_promise).
    With promises, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `async` and `await` keywords, you can structure it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use traditional exception-catching blocks around awaited operations,
    instead of the `Promise.catch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of using `await` for just one call is relatively small. However,
    `await` can make your code considerably cleaner if you have a whole sequence of
    asynchronous operations that need to occur one after the other. Ordinarily, you
    would handle this with a promise chain that calls `Promise.then()` multiple times.
    But with `await`, the code looks like ordinary synchronous code. Here’s an example
    that duplicates the image-reading example from [“Using a Function That Returns
    a Promise”](#async_call_with_promise) to send an asynchronous web request, and
    then asynchronously read the image data that’s returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `await` keyword handles promises in a way that looks like synchronous code,
    but doesn’t lock up your application. Consider a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: From the point of view of your code, it’s as though execution stops and the
    `fetch()` function becomes synchronous. But in reality, JavaScript takes the remainder
    of your function and attaches it to the promise returned by `fetch()`, just as
    if you passed it to `Promise.then()`. As a result, the rest of your code is *scheduled*
    and the UI thread isn’t blocked. Your application is free to handle other events
    and timers while it waits for the fetch operation to finish.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `await` keyword only works in an `async` function. You can’t use `await`
    in the top level of web page code. Instead, you need to create a new `async` function
    to hold it, like the `getImage()` function in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that `getImage()` is an `async` function, it will automatically return a
    `Promise` object. You attach the code that runs when `getImage()` finishes using
    `Promise.then()`, as you would with any promise chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you forget that `getImage()` is an asynchronous function, you might call
    it but forget to use the promise. This is a common mistake by developers who are
    new to `async` and `await`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, you need to accept the `Promise` object returned by `getImage()`,
    and call `then()` and `catch()` to attach the code that should run next, and your
    error-handling code, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You might wonder why you’re dealing with a promise when the `async` and `await`
    keywords are supposed to save you from that effort. The answer is that you always
    need to manage the root-level `Promise` object that starts your asynchronous operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s one relatively recent exception. You can use `await` in the top-level
    code of a module (see [“Organizing Your JavaScript Classes with Modules”](ch08.html#using_es6_modules)).
    If you use this ability, make sure you place the statement that uses `await` inside
    a `try...catch` exception-handling block to catch any unhandled errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `await` keyword becomes more useful when you need to perform multiple asynchronous
    operations and make decisions along the way. For example, imagine you need to
    write code that waits for an asynchronous task to finish, evaluates its result,
    and then decides what task to launch next. You can implement this pattern with
    promises, but the logic is harder to follow. With `await`, it’s organized like
    traditional synchronous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Given that this code looks so clean and straightforward, you might wonder why
    you *wouldn’t* use `await`. Like all abstractions, `await` hides some details
    of the underlying `Promise` object and makes certain situations more difficult.
    For example, it’s a common mistake with `await` to wait for a series of actions
    to complete one after another with separate `await` statements, when what you
    really want is to launch all of them at once. Here’s a demonstration of the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You could solve this situation with `Promise.all()` (as described in [“Executing
    Multiple Promises Concurrently”](#concurrent_promises)). But that’s not necessary.
    You can still use `await`, as long as you make sure all the promises are started
    first. Here’s a correction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This works because a promise starts running code as soon as it is created. By
    the time the code has assigned `promise1`, `promise2`, and `promise3`, all three
    asynchronous processes are underway. And although `await` is often used with a
    function that returns a promise, it works on any `Promise` object.
  prefs: []
  type: TYPE_NORMAL
- en: It also doesn’t matter which promise you wait for first, because you can safely
    use `await` on a promise that’s already completed. No matter what you do, you
    won’t get past this section of your code until each promise is resolved or rejected.
    (Technically, that means this code follows the same behavior as `Promise.allSettled()`
    rather than `Promise.all()`, because the code keeps waiting for *all* the promises
    to be dealt with, even if one of them has failed.)
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Asynchronous Generator Function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a generator for an operation that returns values asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `async` keyword with the specialized generator function syntax shown
    in [“Creating a Generator Function That Yields Multiple Values”](ch06.html#creating_generator_functions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this exceedingly simple generator that yields a never-ending sequence
    of random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Which you call like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the generator asynchronous, you simply add the `async` keyword, exactly
    as you do with an ordinary function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And as with any other `async` function, an asynchronous generator function
    will not yield direct results. Instead, it will yield `Promise` objects that wrap
    the results. You can call `Promise.then()` to get the result, when it’s ready.
    Here’s an example that shows what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When you run this, you’ll see a list of “Received promise” messages, immediately
    followed by the list of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, asynchronous generators are combined with the `await` keyword. A common
    shortcut is the `for await` loop, which waits to request new values from the generator
    until the previous promise has resolved. Here’s an example that uses this technique
    to search for random numbers, one number at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You’ll notice that the code that uses the asynchronous iterator is now itself
    wrapped in an `async` function. This is because you can’t use `await` in top-level
    code (as explained in [“Waiting for a Promise to Finish with Await and Async”](#using_await)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generator functions provide a streamlined way to return on-demand values. After
    each `yield` statement, JavaScript pauses the generator function. But the context
    around it (all the local variables and passed-in arguments) is preserved until
    the next value is requested by the calling code.
  prefs: []
  type: TYPE_NORMAL
- en: The example in the solution doesn’t do any real asynchronous work, and the random
    numbers are available immediately. You could simulate an asynchronous process
    in this example by adding a timeout. But it’s more interesting to consider an
    example that shows asynchronous generators using a true asynchronous API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous generators are most useful for tasks that access an external resource
    and have some latency. For example, you might see them in web request or filestream
    APIs. Here’s a generator that uses the Fetch API to retrieve its list of random
    numbers from a web service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now, each time the calling code requests a value, the generator starts an asynchronous
    `fetch()` operation and returns a promise. When `fetch()` finishes, the promise
    resolves. The calling code could start several asynchronous calls at once by calling
    `next()` multiple times on the generator. But it’s much more common to use a `for
    await` loop to go one-by-one. Either way, there’s no need to change the code from
    what was used in the original solution. If you run this version of the example,
    you’ll see that each random number takes a short but measurable delay before it
    appears in the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Creating a Generator Function That Yields Multiple Values”](ch06.html#creating_generator_functions)
    explains how to create nonasynchronous generators. [“Waiting for a Promise to
    Finish with Await and Async”](#using_await) explains how to create ordinary asynchronous
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a Web Worker to Perform a Background Task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want long-running code to execute on a separate thread, so it doesn’t block
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Web Worker API. You create a `Worker` object, which runs all its code
    on a background thread. Although the `Worker` object is isolated from the rest
    of your code (it can’t access the DOM, the page, or any global variables, for
    instance), you can communicate with it by sending messages back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 9-1](#web_worker_example) shows an example page that calculates all
    the prime numbers in a given range. Because the page uses web workers, the interface
    remains responsive while the job is underway. For example, it’s still possible
    to type in the text boxes or click the Cancel button.'
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 0901](assets/jsc3_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. A web worker calculates prime numbers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The Start button triggers a function called `startSearch()`. It creates a new
    worker, attaches functions to handle the `Worker.error` and `Worker.message` events,
    and finally starts the operation by calling `Worker.postMessage()`. Here’s the
    relevant code in the script for the web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `prime-worker.js` file contains the code that the web worker runs. That
    includes a `findPrimes()` function (not shown here) which holds the logic for
    finding prime numbers using the [Sieve of Eratosthenes](https://oreil.ly/6CyO9).
    The `prime-worker.js` file also handles the `Worker.message` event, which is triggered
    whenever the page calls `Worker.postMessage()`. In this example, the page calls
    `postMessage()` to send the range of numbers to the worker and begin the search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The only remaining ingredient is the event handler for the Cancel button, which
    shuts down the web worker, even if it’s in the middle of its search:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ordinarily, the JavaScript code you write runs on a single application thread.
    JavaScript uses a scheduling system that’s based on an event loop. It continually
    watches for events, listens to timer ticks, and waits for callbacks from asynchronous
    APIs. When it receives functions to run, it queues them up in the order they arrive.
    If you decide to write CPU-intensive code (like performing time-consuming calculations),
    you’ll tie up the main thread and prevent other functions from running until your
    work is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You may be confused about how ordinary JavaScript code is single-threaded, but
    JavaScript provides certain APIs (like `fetch`) that are able to work asynchronously.
    This is because these APIs are provided by services in the browser and, ultimately,
    the operating system. They go outside of the JavaScript environment. For example,
    web requests made with `fetch()` are made on a separate thread, not the main application
    thread used for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Web Worker API gives you a way to escape JavaScript’s single-threaded execution
    model. With web workers, you are able to run code concurrently, on a separate
    thread from the main application user interface. To ensure that you don’t have
    to deal with messy problems like thread safety, race conditions, and locks, web
    workers are kept in a separate execution context. They can’t interact with a web
    page, the browser window, or the rest of your code. To emphasize this fact, the
    `Worker` object asks that you put your web worker code in a separate file, which
    you then supply when you create the worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you understand this limitation, the rest of the web worker model is quite
    intuitive. All the communication between the application and a worker happens
    through message passing. To send a message, you call `postMessage()`. In the prime
    number example, the page sends an object literal with two properties, `to` and
    `from`, to represent the search range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'When the worker responds, it calls `postMessage()` to send array of prime numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: There’s no limit to how often you can send messages. For example, you could
    create a worker, call `postMessage()` to send it some work, leave it idle for
    a while, and then call `postMessage()` to send it more work. Web workers can also
    use the `setTimeout()` and `setInterval()` functions to schedule periodic work.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to stop a worker. First, a worker can stop itself by calling
    `close()`. More commonly, the page that created the worker will shut it down by
    calling `worker.terminate()`. Once a worker is stopped in this way, it can’t be
    resurrected.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see the full code, including the prime number search routine, refer to [the
    book’s sample code](https://github.com/javascripteverywhere/cookbook). For a revised
    version of this example that uses more sophisticated message passing, see [“Adding
    Progress Support to a Web Worker”](#web_worker_with_progress).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Progress Support to a Web Worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want your web worker to report progress while it’s running a task.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use the standard message-passing behavior of your worker. Use a property
    of your message object to distinguish between different types of messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a version of the prime number example (from [“Adding
    Progress Support to a Web Worker”](#web_worker_with_progress)) that sends two
    types of messages: progress notifications (while the work is underway) and the
    prime number list (when the work is finished).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow the application to tell the difference between these two types of
    messages, it adds a string `messageType` property, which it sets to either `"Progress"`
    or `"PrimeList"`. Here’s the rewritten code to return the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the prime-number calculation code also needs to use `postMessage()` to
    report on its progress. It uses a rate-limiting check to round the progress to
    the nearest percent, and to make sure it doesn’t notify about the same progress
    more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When the page receives a message, it checks the `messageType` property to determine
    the type of message and then acts accordingly. If it’s a prime list, it shows
    the results in the page. If it’s a progress notification, it updates the progress
    text, as shown in [Figure 9-2](#web_worker_progress_example).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '![jsc3 0902](assets/jsc3_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. A web worker reports progress as it works
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enforce thread safety, there’s no way for an application and a web worker
    to interact except by passing messages. You can send any object you want as a
    message, as long as it can be serialized to JSON. It’s much the same as when you’re
    sending a message to a remote website.
  prefs: []
  type: TYPE_NORMAL
- en: You might decide to create your own custom class for messages to formalize the
    structure you’re using. However, keep in mind that once the object is sent between
    threads, it will look exactly like an ordinary object literal. It won’t have a
    custom prototype or any methods, and you won’t be able to test its type with `instanceof`.
    Similarly, you might think of using the enumerated values trick from [“Creating
    Enums with Symbol”](ch07.html#symbol_for_enums), but it won’t work because the
    application and the worker can’t share their symbols.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript also has two specialized APIs that build on the Web Worker API. You
    can used [*shared workers*](https://oreil.ly/jGV06) if you want to interact with
    the same worker from different windows. And you can use more advanced [*service
    workers*](https://oreil.ly/vh3L3) to create workers that, once installed, stay
    alive even when your page isn’t open. The idea behind this API is to help you
    build caching, synchronization, and notification services that make a website
    behave more like a native app.
  prefs: []
  type: TYPE_NORMAL
