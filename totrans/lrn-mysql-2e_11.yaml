- en: Chapter 11\. Configuring and Tuning the Server
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The MySQL installation process (see [Chapter 1](ch01.xhtml#CH1_INSTALL)) provides
    everything necessary to install the MySQL process and start using it. However,
    it is required for production systems to do some fine-tuning, adjusting MySQL
    parameters and the operating system to optimize MySQL Server’s performance. This
    chapter will cover the recommended best practices for different installations
    and show you the parameters that need to be adjusted based on the expected or
    current workload. As you’ll see, it is not necessary to memorize all the MySQL
    parameters. Based on the [*Pareto principle*](https://oreil.ly/1d58s), which states
    that, for many events, roughly 80% of the effects come from 20% of the causes,
    we will concentrate on the MySQL and operating system parameters that are responsible
    for most of the performance issues. There are some advanced topics in this chapter
    related to computer architecture (such as NUMA); the intent here is to introduce
    you to a few components that can affect MySQL performance that you will need to
    interact with sooner or later in your career.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL Server Daemon
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since 2015, the majority of Linux distributions have adopted `systemd`. Because
    of that, Linux operating systems do not use the `mysqld_safe` process to start
    MySQL anymore. `mysqld_safe` is called an *angel process*, because it adds some
    safety features, such as restarting the server when an error occurs and logging
    runtime information to the MySQL error log. For operating systems that use `systemd`
    (controlled and configured with the `systemctl` command), these functionalities
    have been incorporated into `systemd` and the `mysqld` process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '`mysqld` is the core process of MySQL Server. It is a single multithreaded
    program that does most of the work in the server. It does not spawn additional
    processes—we’re talking about a single process with multiple threads, making MySQL
    a *multithreaded process*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at some of those terms. A *program* is code that is
    designed to accomplish a specific objective. There are many types of programs,
    including ones to assist parts of the operating system and others that are designed
    for user needs, such as web browsing.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: A *process* is what we call a program that has been loaded into memory along
    with all the resources it needs to operate. The operating system allocates memory
    and other resources for it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: A *thread* is the unit of execution within a process. A process can have just
    one thread or many threads. In single-threaded processes, the process contains
    one thread, so only one command is executed at a time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Because modern CPUs have multiple cores, they can execute multiple threads at
    the same time, so multithreaded processes are widespread nowadays. It’s important
    to be aware of this concept to understand some of the proposed settings in the
    following sections.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: To conclude, MySQL is single-process software that spawns multiple threads for
    various purposes, such as serving user activities and executing background tasks.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Server Variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MySQL Server has many variables that allow tuning its operation. For example,
    MySQL Server 8.0.25 has an impressive *588* server variables!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Each system variable has a default value. Also, we can adjust most system variables
    dynamically (or “on the fly”); however, a few of them are static, which means
    that we need to change the *my.cnf* file and restart the MySQL process so they
    can take effect (as discussed in [Chapter 9](ch09.xhtml#CH9_OPTIONS_FILE)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The system variables can have two different scopes: `SESSION` and `GLOBAL`.
    That is, a system variable can have a global value that affects server operation
    as a whole, like the `innodb_log_file_size`, or a session value that affects only
    a specific session, like the `sql_mode`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Checking Server Settings
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Databases are not static entities; on the contrary, their workload is dynamic
    and changes over time, with a tendency to growth. This organic behavior requires
    constant monitoring, analysis, and adjustment. The command to show the MySQL settings
    is:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you use the `GLOBAL` modifier, the statement displays global system variable
    values. When you use `SESSION`, it displays the system variable values that affect
    the current connection. Observe that different connections can have different
    values.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: If no modifier is present, the default is `SESSION`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Best Practices
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many aspects to optimize in a database. If the database runs on *bare
    metal* (a physical host), we can control hardware and operating system resources.
    When we move to virtualized machines, we have reduced control over these resources
    because we can’t control what happens with the underlying host. The last option
    is managed databases in the cloud, like those provided by Amazon Relational Database
    Service (RDS), where only a few database settings are available. There’s a trade-off
    between being able to perform fine-grained tuning to extract the most performance
    and the comfort of having most of the tasks automated (at the cost of a few extra
    dollars).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by reviewing some settings at the operating system level. After
    that, we will check out the MySQL parameters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Operating system best practices
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several operating system settings that can affect the performance
    of MySQL. We’ll run through some of the most important ones here.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The swappiness setting and swap usage
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `swappiness` parameter controls the behavior of the Linux operating system
    in the swap area. Swapping is the process of transferring data between memory
    and the disk. This can have a significant effect on performance, because disk
    access (even with NVMe disks) is at least an order of magnitude slower than memory
    access.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The default setting (`60`) encourages the server to swap. You will want your
    MySQL server to keep swapping to a minimum for performance reasons. The recommended
    value is `1`, which means do not swap until it is absolutely necessary for the
    OS to be functional. To adjust this parameter, execute the following command as
    root:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that this is a nonpersistent change; the setting will revert to its original
    value when you reboot the OS. To make this change persistent after an operating
    system reboot, adjust the setting in *sysctl.conf*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can get information on swap space usage using the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or, if you want more detailed information, you can run the following snippet
    in the shell:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The difference between setting `vm.swappiness` to `1` and `0` is negligible.
    We chose the value of `1` because in some kernels there is a bug that can lead
    the Out of Memory (OOM) Killer to terminate MySQL when it’s set to `0`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: I/O scheduler
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The I/O scheduler is an algorithm the kernel uses to commit reads and writes
    to disk. By default, most Linux installs use the Completely Fair Queuing (`cfq`)
    scheduler. This works well for many general use cases, but offers few latency
    guarantees. Two other schedulers are `deadline` and `noop`. The `deadline` scheduler
    excels at latency-sensitive use cases (like databases), and `noop` is closer to
    no scheduling at all. For bare-metal installations, either `deadline` or `noop`
    (the performance difference between them is imperceptible) will be better than
    `cfq`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: If you are running MySQL in a VM (which has its own I/O scheduler), it is best
    to use `noop` and let the virtualization layer take care of the I/O scheduling
    itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'First, verify which algorithm is currently in use by Linux:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To change it dynamically, run this command as root:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In  order  to  make  this  change  persistent,  you  need  to  edit  the  GRUB 
    configuration file (usually */etc/sysconfig/grub*) and add the `elevator` option
    to `GRUB_CMDLINE_LINUX_DEFAULT`. For example, you would replace this line:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'with this line:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It is essential to take extra care when editing the GRUB config. Errors or incorrect
    settings can make the server unusable and require installing the operating system
    again.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are cases where the I/O scheduler has a value of `none`—most notably in
    AWS VM instance types where EBS volumes are exposed as NVMe block devices. This
    is because the setting has no use in modern PCIe/NVMe devices, which have a substantial
    internal queue and bypass the I/O scheduler altogether. The `none` setting is
    optimal in such disks.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems and mount options
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Choosing the filesystem appropriate for your database is an important decision
    due to the many options available and the trade-offs involved. It is worth mentioning
    two important ones that are frequently used: *XFS* and *ext4*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: XFS is a high-performance journaling filesystem designed for high scalability.
    It provides near-native I/O performance even when the filesystem spans multiple
    storage devices. XFS has features that make it suitable for very large filesystems,
    supporting files up to 8 EiB in size. Other features include fast recovery, fast
    transactions, delayed allocation for reduced fragmentation, and near-raw I/O performance
    with direct I/O.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'The [make filesystem XFS command](https://oreil.ly/IJ9em) (`mkfs.xfs`) has
    several options to configure the filesystem. However, the default options for
    `mkfs.xfs` are good for optimal speed, so the default command to create the filesystem
    will provide good performance while ensuring data integrity:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Regarding the filesystem mount options, the defaults again should fit most
    cases. You may see a performance increase on some filesystems by adding the `noatime`
    mount option to the */etc/fstab* file. For XFS filesystems, the default `atime`
    behavior is `relatime`, which has almost no overhead compared to `noatime` and
    still maintains sane `atime` values. If you create an XFS filesystem on a logical
    unit number (LUN) that has a battery-backed, nonvolatile cache, you can further
    increase the filesystem’s performance by disabling the write barrier with the
    mount option `nobarrier`. These settings help you avoid flushing data more often
    than necessary. If a backup battery unit (BBU) is not present, however, or you
    are unsure about it, leave barriers on; otherwise, you may jeopardize data consistency.
    The example below shows two imaginary mountpoints with these options:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The other popular option is ext4, developed as the successor to ext3 with added
    performance improvements. It is a solid option that will fit most workloads. We
    should note here that it supports files up to 16 TB in size, a smaller limit than
    XFS. This is something you should consider if excessive tablespace size/growth
    is a requirement. Regarding mount options, the same considerations apply. We recommend
    the defaults for a robust filesystem without risks to data consistency. However,
    if an enterprise storage controller with a BBU cache is present, the following
    mount options will provide the best performance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Transparent Huge Pages
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The operating system manages memory in blocks known as *pages*. A page has
    a size of 4,096 bytes (or 4 KB); 1 MB of memory is equal to 256 pages, 1 GB of
    memory is equivalent to 256,000 pages, etc. CPUs have a built-in memory management
    unit that contains a list of these pages, with each page referenced through a
    *page table entry*. It is common to see servers nowadays with hundreds or terabytes
    of memory. There are two ways to enable the system to manage large amounts of
    memory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Increase the number of page table entries in the hardware memory management
    unit.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase the page size.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first method is expensive since the hardware memory management unit in a
    modern processor only supports hundreds or thousands of page table entries. Besides,
    hardware and memory management algorithms that work well with thousands of pages
    (megabytes of memory) may have problems performing well with millions (or even
    billions) of pages. To address the scalability issue, operating systems started
    using huge pages. Simply put, huge pages are blocks of memory that can come in
    sizes of 2 MB, 4 MB, 1 GB size, etc. Using huge page memory increases the CPU
    cache hits against the transaction lookaside buffer (TLB).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run `cpuid` to verify the processor cache and TLB:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Transparent Huge Pages (THP), as the name suggests, is intended to bring huge
    page support automatically to applications without requiring custom configuration.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: For MySQL in particular, using THP is not recommended, for a couple of reasons.
    First, MySQL databases use small memory pages (16 KB), and using THP can cause
    excessive I/O because MySQL believes it is accessing 16 KB while THP is scanning
    a page larger than that. Also, the huge pages tend to become fragmented and impact
    performance. There have also been some cases reported over the years where using
    THP can result in memory leaking, eventually crashing MySQL.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable THP for RHEL/CentOS 6 and RHEL/CentOS 7, execute the following commands:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To ensure that this change will survive a server restart, you’ll have to add
    the flag `transparent_hugepage=never` to your kernel options (*/etc/sysconfig/grub*):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Back up the existing GRUB2 configuration file (*/boot/grub2/grub.cfg*), and
    then rebuild it. On BIOS-based machines, you can do this with the following command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If THP is still not disabled, it may be necessary to disable the `tuned` services:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To disable THP for Ubuntu 20.04 (Focal Fossa), we recommend you use the `sysfsutils`
    package. To install it, execute the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then append the following lines to the */etc/sysfs.conf* file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Reboot the server and check if the settings are in place:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: jemalloc
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: MySQL Server uses dynamic memory allocation, so a good memory allocator is important
    for proper CPU and RAM resource utilization. An efficient memory allocator should
    improve scalability, increase throughput, and keep the memory footprint under
    control.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: It is important to mention a characteristic of InnoDB here. InnoDB creates a
    read view for every transaction and allocates memory for this structure from the
    `heap` area. The problem is that MySQL deallocates the heap on each commit, and
    thus the read view memory is reallocated on the next transaction, leading to memory
    fragmentation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '`jemalloc` is a memory allocator that emphasizes fragmentation avoidance and
    scalable concurrency support.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Using `jemalloc` (with THP disabled), you have less memory fragmentation and
    more efficient resource management of the available server memory. You can install
    the `jemalloc` package from the [`jemalloc` repository](https://oreil.ly/NZMtb)
    or the Percona *yum* or *apt* repository. We prefer to use the Percona repository
    because we consider it simpler to install and manage. We describe the steps to
    install the *yum* repository in [“Installing Percona Server 8.0”](ch01.xhtml#PERCONA-YUM-REPO-INSTALL)
    and the *apt* repository in [“Installing Percona Server 8”](ch01.xhtml#INSTALL-APT-PERCONA-REPO).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the repo, you run the install command for your operating system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In CentOS, if the server has the Extra Packages for Enterprise Linux (EPEL)
    repository installed, it is possible to install `jemalloc` from this repo with
    `yum`. To install the EPEL package, use:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you are using Ubuntu 20.04, then you need to execute the following steps
    to enable `jemalloc`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `jemalloc`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `dpkg` command will show the location of the `jemalloc` library:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Override the default configuration of the service with the command:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: which will create the */etc/systemd/system/mysql.service.d/override.conf* file.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following configuration to the file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Restart the MySQL service to enable the `jemalloc` library:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To verify if it worked, with the `mysqld` process running, execute the following
    command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see similar output to the following:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you are using CentOS/RHEL, you need to execute the following steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `jemalloc` package:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `rpm -ql` command will show the library location:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Override the default configuration of the service with the command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: which will create the */etc/systemd/system/mysqld.service.d/override.conf* file.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the following configuration to the file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Restart the MySQL service to enable the `jemalloc` library:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To verify if it worked, with the `mysqld` process running, execute the following
    command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see similar output to the following:'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: CPU governor
  id: totrans-124
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the most effective ways to reduce the power consumption and heat output
    on your system is to use CPUfreq. CPUfreq, also referred to as CPU frequency scaling
    or CPU speed scaling, allows the processor’s clock speed to be adjusted on the
    fly. This feature enables the system to run at a reduced clock speed to save power.
    The rules for shifting frequencies—whether and when to shift to a faster or slower
    clock speed—are defined by the CPUfreq *governor*. The governor defines the power
    characteristics of the system CPU, which in turn affects CPU performance. Each
    governor has its own unique behavior, purpose, and suitability in terms of workload.
    However, for MySQL databases, we recommend using the maximum performance setting
    to achieve the best throughput.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'For CentOS, you can view which CPU governor is currently being used by executing:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can enable performance mode by running:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'For Ubuntu, we recommend installing the `linux-tools-common` package so you
    have access to the `cpupower` utility:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once you’ve installed it, you can change the governor to performance mode with
    the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: MySQL best practices
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let’s look at MySQL Server settings. This section proposes recommended values
    for the main MySQL parameters that have a direct impact on performance. You’ll
    see that it’s not necessary to change the default values for the majority of the
    parameters.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Buffer pool size
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `innodb_buffer_pool_size` parameter controls the size in bytes of the InnoDB
    buffer pool, the memory area where InnoDB caches table and index data. There’s
    no question that for tuning InnoDB, this is the most important parameter. The
    typical rule of thumb is to set it to around 70% of the total available RAM for
    a MySQL dedicated server.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: However, the larger the server is, the more likely it is that this will end
    up wasting RAM. For a server with 512 GB of RAM, for example, this would leave
    153 GB of RAM for the operating system, which is more than it needs.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: So what’s a better rule of thumb? Set the `innodb_buffer_pool_size` as large
    as possible, without causing swapping when the system is running the production
    workload. This will require some tuning.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'In MySQL 5.7 and later this is a dynamic parameter, so you can change it on
    the fly without the need to restart the database. For example, to set it to 1
    GB, use this command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To make the change persistent across restarts, you’ll need to add this parameter
    to *my.cnf*, under the `[mysqld]` section:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The innodb_buffer_pool_instances parameter
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the more obscure MySQL parameters is `innodb_buffer_pool_instances`.
    This parameter defines the number of instances that InnoDB will split the buffer
    pool into. For systems with buffer pools in the multigigabyte range, dividing
    the buffer pool into separate instances can improve concurrency by reducing contention
    as different threads read and write to cached pages.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: However, in our experience, setting a high value for this parameter may also
    introduce additional overhead. The reason is that each buffer pool instance manages
    its own free list, flush list, LRU list, and all other data structures connected
    to a buffer pool, and is protected by its own buffer pool mutex.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Unless you run benchmarks that prove performance gains, we suggest using the
    default value (`8`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `innodb_buffer_pool_instances` parameter was deprecated in MariaDB 10.5.1
    and removed in MariaDB 10.6\. According to MariaDB architect Marko Makela, this
    is because the original reasons for splitting the buffer pool have mostly gone
    away nowadays. You can find more details in the [MariaDB Jira ticket](https://oreil.ly/HOCNA).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Redo log size
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The redo log is a structure used during crash recovery to correct data written
    by incomplete transactions. The main goal is to guarantee the durability (D) property
    of ACID transactions by providing redo recovery for committed transactions. Because
    the redo file logs all data written to MySQL even before the commit, having the
    right redo log size is fundamental for MySQL to run smoothly without struggling.
    An undersized redo log can even lead to errors in operations!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the kind of error you might see if using a small redo
    log file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In this case MySQL was using the default value for the `innodb_log_file_size`
    parameter, which is 48 MB. To estimate the optimal redo log size, there is a formula
    that we can use in the majority of cases. Take a look at the following commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The log sequence number is the total number of bytes written to the redo log.
    Using the `SLEEP()` command, we can calculate the delta for that period. Then,
    using the following formula, we can reach an estimated value for the amount of
    space needed to hold an hour or so of logs (a good rule of thumb):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We usually round up, so the final number will be 56 MB. This is the value that
    needs to be added to *my.cnf* under the `[mysqld]` section:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The sync_binlog parameter
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The binary log is a set of log files that contain information about data modifications
    made to a MySQL server instance. They are different from the redo files and have
    other uses. For example, they are used to create replicas and InnoDB Clusters,
    and are helpful for performing PITR.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the MySQL server synchronizes its binary log to disk (using `fdatasync()`)
    before transactions are committed. The advantage is that in the event of a power
    failure or operating system crash, transactions that are missing from the binary
    log are only in a prepared state; this allows the automatic recovery routine to
    roll back the transactions, guaranteeing that no transaction is lost from the
    binary log. However, the default value (`sync_binlog = 1`) brings a penalty in
    performance. As this is a dynamic option, you can change it while the server is
    running with the following command:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'For the change to persist after a restart, add the parameter to your *my.cnf*
    file under the `[mysqld]` section:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most of the time, using `sync_binlog=0` will provide good performance (when
    binary logs are enabled). However, the performance variance can be significant
    because MySQL will rely on the OS flushing to flush the binary logs. Depending
    on the workload, using `sync_binlog=1000` or higher will provide better performance
    than `sync_binlog=1` and less variance than `sync_binlog=0`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The binlog_expire_logs_seconds and expire_logs_days parameters
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To avoid MySQL filling the entire disk with binary logs, you can adjust the
    settings of the parameters `binlog_expire_logs_seconds` and `expire_logs_days`.
    `expire_logs_days` specifies the number of days before automatic removal of binary
    log files. However, this parameter is deprecated in MySQL 8.0, and you should
    expect it to be removed in a future release.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免 MySQL 用二进制日志填满整个磁盘，您可以调整参数 `binlog_expire_logs_seconds` 和 `expire_logs_days`
    的设置。`expire_logs_days` 指定在自动删除二进制日志文件之前的天数。然而，在 MySQL 8.0 中，此参数已被弃用，预计在将来的版本中将被移除。
- en: Consequently, a better option is to use `binlog_expire_logs_seconds`, which
    sets the binary log expiration period in seconds. The default value for this parameter
    is `2592000` (30 days). MySQL can automatically remove the binary log files after
    this expiration period ends, either at startup or the next time the binary log
    is flushed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更好的选择是使用 `binlog_expire_logs_seconds`，该参数设置二进制日志的过期时间（以秒为单位）。此参数的默认值为 `2592000`（30
    天）。MySQL 可以在到期后自动删除二进制日志文件，无论是在启动时还是在下次刷新二进制日志时。
- en: Note
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to flush the binary log manually, you can execute the following
    command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想手动刷新二进制日志，可以执行以下命令：
- en: '[PRE51]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The innodb_flush_log_at_trx_commit parameter
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`innodb_flush_log_at_trx_commit` 参数'
- en: '`innodb_flush_log_at_trx_commit` controls the balance between strict ACID compliance
    for commit operations and the higher performance possible when commit-related
    I/O operations are rearranged and done in batches. It is a delicate option, and
    many prefer to use the default value (`innodb_flush_log_at_trx_commit=1`) in the
    source servers, while for replicas they use a value of `0` or `2`. The value `2`
    instructs InnoDB to write to the log files after each transaction commit, but
    to flush them to disk only once per second. This means you can lose up to a second
    of updates if the OS crashes, which, with modern hardware that supports up to
    one million inserts per second, is not negligible. The value `0` is even worse:
    logs are written and flushed to disk just once per second, so you may lose up
    to a second’s worth of transactions even if the `mysqld` process crashes.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb_flush_log_at_trx_commit` 控制提交操作的严格 ACID 兼容性与在重新排列并批量执行提交相关 I/O 操作时可能实现的更高性能之间的平衡。这是一个微妙的选项，许多人更喜欢在源服务器上使用默认值（`innodb_flush_log_at_trx_commit=1`），而在副本上使用值
    `0` 或 `2`。值 `2` 指示 InnoDB 在每个事务提交后写入日志文件，但每秒仅刷新一次到磁盘。这意味着如果操作系统崩溃，您最多可能会丢失一秒的更新，对于支持每秒达到一百万次插入的现代硬件来说，这并不可忽视。值
    `0` 更糟：日志每秒仅写入并刷新到磁盘一次，因此即使 `mysqld` 进程崩溃，您也可能会丢失一秒的事务。'
- en: Warning
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Many operating systems, and some disk hardware, “fool” the flush-to-disk operation.
    They may tell `mysqld` that the flush has taken place, even though it has not.
    In this case, the durability of transactions is not guaranteed even with the recommended
    settings, and in the worst case, a power outage can corrupt InnoDB data. Using
    a battery-backed disk cache in the SCSI disk controller or in the disk itself
    speeds up file flushes and makes the operation safer. You can also disable the
    caching of disk writes in hardware caches if the battery is not working correctly.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 许多操作系统和一些磁盘硬件在“刷入磁盘”的操作上表现得不可靠。它们可能会告诉 `mysqld` 刷入已完成，但实际上并未刷入。在这种情况下，即使使用推荐的设置，事务的耐久性也无法得到保证，最坏的情况下，断电可能会损坏
    InnoDB 数据。在 SCSI 磁盘控制器或磁盘本身使用带电池后备的磁盘缓存可以加快文件刷入速度，并使操作更安全。如果电池工作不正常，还可以禁用硬件缓存中的磁盘写入缓存。
- en: The innodb_thread_concurrency parameter
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`innodb_thread_concurrency` 参数'
- en: '`innodb_thread_concurrency` is set to `0` by default, which means that an infinite
    number (up to the hardware limit) of threads can be opened and executed inside
    MySQL. The usual recommendation is to leave this parameter with its default value
    and only change it to solve contention problems.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`innodb_thread_concurrency` 默认设置为 `0`，这意味着 MySQL 内可以打开和执行无限数量（最多达到硬件限制）的线程。通常的建议是将此参数保持默认值，并仅在解决争用问题时进行更改。'
- en: 'If your workload is consistently heavy or has occasional spikes, you can set
    the value of `innodb_thread_concurrency` using the following formula:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的工作负载始终很重或偶尔会有高峰，可以使用以下公式设置 `innodb_thread_concurrency` 的值：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Because MySQL does not use multiple cores to execute a single query (it is a
    1:1 relation), each core will run one query per single unit of time. Based on
    our experience, because modern CPUs are fast in general, setting the maximum number
    of executing threads to double the CPUs available is a good start.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Once the number of executing threads reaches this limit, additional threads
    sleep for a number of microseconds, set by the configuration parameter `innodb_​​thread_sleep_delay`,
    before being placed into the queue.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '`innodb_thread_concurrency` is a dynamic variable, and we can change it at
    runtime:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To make the change persistent, you’ll also need to add this to *my.cnf*, under
    the `[mysqld]` section:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can validate that MySQL applied the setting with this command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-193
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The MySQL 8.0.14 [release notes](https://oreil.ly/EqPrG) state: “As of MySQL
    8.0.14, InnoDB supports parallel clustered index reads, which can improve `CHECK
    TABLE` performance.” Parallel clustered index reads also work for a simple `COUNT(*)`
    (without a `WHERE` condition). You can control the number of parallel threads
    with the `innodb_parallel_read_threads` parameter.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: This feature is currently limited and available only for queries without a `WHERE`
    condition (full scans). However, it is a great start for MySQL and opens the road
    to real parallel query execution.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: NUMA architecture
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Non-uniform memory access (NUMA) is a shared memory architecture that describes
    the placement of main memory modules relative to processors in a multiprocessor
    system. In the NUMA shared memory architecture, each processor has its own local
    memory module, leading to a distinct performance advantage because the memory
    and the processor are physically closer. At the same time, it can also access
    any memory module belonging to another processor using a shared bus (or some other
    type of interconnect), as shown in [Figure 11-1](#FIG-NUMA).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A nice alternative that can show memory usage across NUMA nodes is the `numastat`
    command. You can get a more detailed memory usage per node by executing:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Another way to visualize this is by specific process. For example, to check
    the memory usage in NUMA nodes of the mysqld process:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![lm2e 1101](Images/lm2e_1101.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. NUMA architecture overview
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The following command shows an example of the available nodes on a server that
    has NUMA enabled:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As we can see, node 0 has more free memory than node 1\. There is an issue with
    this that causes the OS to swap even with memory available, as explained in the
    excellent article [“The MySQL *Swap Insanity* Problem and the Effects of the NUMA
    Architecture”](https://oreil.ly/lBRSk) by Jeremy Cole.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: In MySQL 5.7 the `innodb_buffer_pool_populate` and `numa_interleave` parameters
    were removed, and their functions are now controlled by the `innodb_numa_interleave`
    parameter. When we enable it, we balance memory allocation across nodes in a NUMA
    system, avoiding the swap insanity problem.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'This parameter is not dynamic, so to enable it we need to add it to the *my.cnf*
    file, under the `[mysqld]` section, and restart MySQL:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数不是动态的，因此要启用它，我们需要将它添加到 *my.cnf* 文件的 `[mysqld]` 部分，并重新启动 MySQL：
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
