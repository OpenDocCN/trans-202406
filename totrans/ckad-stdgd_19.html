<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 19. ConfigMaps and Secrets" class="praise"><div class="dedication" id="configmaps_secrets">
<h1 class="calibre14"><span class="keep-together">Chapter 19. </span>ConfigMaps and Secrets</h1>


<p class="author1">Kubernetes dedicates two primitives to defining configuration data: the ConfigMap and the Secret. Both primitives are completely decoupled from the life cycle of a Pod, which enables you to change their configuration data values without necessarily having to redeploy the Pod.</p>

<p class="author1">In essence, ConfigMaps and Secrets store a set of key-value pairs. Those key-value pairs can be injected into a container as environment variables, or they can be mounted as a Volume. <a data-type="xref" href="#consuming_configuration_data" class="calibre10">Figure 19-1</a> illustrates the options.</p>

<figure class="calibre35"><div id="consuming_configuration_data" class="figure">
<img src="Images/ckd2_1901.png" alt="ckd2 1901" class="calibre103"/>
<h6 class="calibre32"><span class="keep-together">Figure 19-1. </span>Consuming configuration data</h6>
</div></figure>

<p class="author1">The ConfigMap and Secret may look almost identical in purpose and structure on the surface; however, there is a slight but significant difference. A ConfigMap stores plain-text data, for example connection URLs, runtime flags, or even structured data like a JSON or YAML content. Secrets are better suited for representing sensitive data like passwords, API keys, or SSL certificates and store the data in base64-encoded form.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Encryption of ConfigMap and Secret data</h1>
<p class="author1">The cluster component that stores data of a ConfigMap and Secret object is etcd. Etcd manages this data in unencrypted form by default. You can configure encryption of data in etcd, as described in the <a href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/" class="calibre10">Kubernetes documentation</a>. Etcd encryption is not within the scope of the exam.</p>
</div>

<p class="author1">This chapter references the concept of Volumes heavily. Refer to <a data-type="xref" href="ch07.xhtml#volumes" class="calibre10">Chapter 7</a> to refresh your memory on the mechanics of consuming a Volume in a Pod.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id488">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objectives:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Understand ConfigMaps</p>
</li>
<li class="calibre13">
<p class="author1">Create and consume Secrets</p>
</li>
</ul>
</div></aside>






<section data-type="sect1" data-pdf-bookmark="Working with ConfigMaps" class="praise"><div class="dedication" id="id379">
<h1 class="calibre17">Working with ConfigMaps</h1>

<p class="author1">Applications often implement logic that uses configuration data to control runtime behavior. Examples for configuration data include a connection URL and network communication options (like the number of retries or timeouts) to third-party services that differ between target deployment environments.</p>

<p class="author1">It’s not unusual that the same configuration data needs to be made available to multiple Pods. Instead of copy-pasting the same key-value pairs across multiple Pod definitions, you can choose to centralize the information in a ConfigMap object. The ConfigMap object holds configuration data and can be consumed by as many Pods as you want. Therefore, you will need to modify the data in only one location should you need to change it.</p>








<section data-type="sect2" data-pdf-bookmark="Creating a ConfigMap" class="praise"><div class="dedication" id="id380">
<h2 class="calibre33">Creating a ConfigMap</h2>

<p class="author1">You can create a ConfigMap by emitting the imperative <code class="calibre15">create configmap</code> command. This command requires you to provide the source of the data as an option. Kubernetes distinguishes the four different options shown in <a data-type="xref" href="#source_options_configmap" class="calibre10">Table 19-1</a>.</p>
<table id="source_options_configmap" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 19-1. </span>Source options for data parsed by a ConfigMap</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Option</th>
<th class="calibre63">Example</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">--from-literal</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">--from-literal=locale=en_US</code></p></td>
<td class="calibre65"><p class="author1">Literal values, which are key-value pairs as plain text</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">--from-env-file</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">--from-env-file=config.env</code></p></td>
<td class="calibre65"><p class="author1">A file that contains key-value pairs and expects them to be environment variables</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">--from-file</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">--from-file=app-config.json</code></p></td>
<td class="calibre65"><p class="author1">A file with arbitrary contents</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">--from-file</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">--from-file=config-dir</code></p></td>
<td class="calibre65"><p class="author1">A directory with one or many files</p></td>
</tr>
</tbody>
</table>

<p class="author1">It’s easy to confuse the options <code class="calibre15">--from-env-file</code> and <code class="calibre15">--from-file</code>. The option <code class="calibre15">--from-env-file</code> expects a file that contains environment variables in the format <code class="calibre15">KEY=value</code> separated by a new line. The key-value pairs follow typical naming 
<span class="keep-together">conventions</span> for environment variables (e.g., the key is uppercase, and individual words are separated by an underscore character). Historically, this option has been used to process <a href="https://docs.docker.com/compose/environment-variables/env-file/" class="calibre10">Docker Compose <code class="calibre15">.env</code> file</a>, though you can use it for any other file containing environment variables.</p>

<p class="author1">The <code class="calibre15">--from-env-file</code> option does not enforce or normalize the typical naming conventions for environment variables. The option <code class="calibre15">--from-file</code> points to a file or directory containing <em class="calibre3">any</em> arbitrary content. It’s an appropriate option for files with structured configuration data to be read by an application (e.g., a properties file, a JSON file, or an XML file).</p>

<p class="author1">The following command shows the creation of a ConfigMap in action. We are simply providing the key-value pairs as literals:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create configmap db-config --from-literal=DB_HOST=mysql-service</strong> \
  <strong class="calibre38">--from-literal=DB_USER=backend</strong>
configmap/db-config created</pre>

<p class="author1">The resulting YAML object looks like the one shown in <a data-type="xref" href="#configmap_yaml_manifest" class="calibre10">Example 19-1</a>. As you can see, the object defines the key-value pairs in a section named <code class="calibre15">data</code>. A ConfigMap does not have a <code class="calibre15">spec</code> section.</p>
<div id="configmap_yaml_manifest" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-1. </span>ConfigMap YAML manifest</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ConfigMap</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-config</code><code class="w"></code>
<code class="nt">data</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">DB_HOST</code><code class="p">:</code><code class="w"> </code><code class="calibre15">mysql-service</code><code class="w"></code>
<code class="w">  </code><code class="nt">DB_USER</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w"></code></pre></div>

<p class="author1">You may have noticed that the key assigned to the ConfigMap data follows the typical naming conventions used by environment variables. The intention is to consume them as such in a container.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Consuming a ConfigMap as Environment Variables" class="praise"><div class="dedication" id="id381">
<h2 class="calibre33">Consuming a ConfigMap as Environment Variables</h2>

<p class="author1">With the ConfigMap created, you can now inject its key-value pairs as environment variables into a container. <a data-type="xref" href="#injecting_configmap_environment_variables" class="calibre10">Example 19-2</a> shows the use of <code class="calibre15">spec.containers[].envFrom[].configMapRef</code> to reference the ConfigMap by name.</p>
<div id="injecting_configmap_environment_variables" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-2. </span>Injecting ConfigMap key-value pairs into the container</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/web-app:1.0.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w"></code>
<code class="w">    </code><code class="nt">envFrom</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">configMapRef</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-config</code><code class="w"></code></pre></div>

<p class="author1">After creating the Pod from the YAML manifest, you can inspect the environment variables available in the container by running the <code class="calibre15">env</code> Unix command:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl exec backend -- env</strong>
...
DB_HOST=mysql-service
DB_USER=backend
...</pre>

<p class="author1">The injected configuration data will be listed among environment variables available to the container.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Mounting a ConfigMap as a Volume" class="praise"><div class="dedication" id="id382">
<h2 class="calibre33">Mounting a ConfigMap as a Volume</h2>

<p class="author1">Another way to configure applications at runtime is by processing a machine-readable configuration file. Say we have decided to store the database configuration in a JSON file named <em class="calibre3">db.json</em> with the structure shown in <a data-type="xref" href="#json_file_database_information" class="calibre10">Example 19-3</a>.</p>
<div id="json_file_database_information" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-3. </span>A JSON file used for configuring database information</h5>

<pre data-type="programlisting" data-code-language="json" class="calibre47"><code class="p">{</code><code class="w"></code>
<code class="w">    </code><code class="nt">"db"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"></code>
<code class="w">      </code><code class="nt">"host"</code><code class="p">:</code><code class="w"> </code><code class="s">"mysql-service"</code><code class="p">,</code><code class="w"></code>
<code class="w">      </code><code class="nt">"user"</code><code class="p">:</code><code class="w"> </code><code class="s">"backend"</code><code class="w"></code>
<code class="w">    </code><code class="p">}</code><code class="w"></code>
<code class="p">}</code><code class="w"></code></pre></div>

<p class="author1">Given that we are not dealing with literal key-value pairs, we need to provide the option <code class="calibre15">--from-file</code> when creating the ConfigMap object:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create configmap db-config --from-file=db.json</strong>
configmap/db-config created</pre>

<p class="author1"><a data-type="xref" href="#configmap_yaml_manifest_structured_data" class="calibre10">Example 19-4</a> shows the corresponding YAML manifest of the ConfigMap. You can see that the file name becomes the key; the contents of the file has used a multiline value.</p>
<div id="configmap_yaml_manifest_structured_data" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-4. </span>ConfigMap YAML manifest defining structured data</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ConfigMap</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-config</code><code class="w">
</code><code class="nt">data</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">db.json</code><code class="p">:</code><code class="w"> </code><code class="calibre15">|</code><code class="calibre15">-</code><code class="w">                        </code><a class="calibre10" id="co_configmaps_and_secrets_CO1-1" href="#callout_configmaps_and_secrets_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="no">{</code><code class="w">
</code><code class="w">       </code><code class="no">"db": {</code><code class="w">
</code><code class="w">          </code><code class="no">"host": "mysql-service",</code><code class="w">
</code><code class="w">          </code><code class="no">"user": "backend"</code><code class="w">
</code><code class="w">       </code><code class="no">}</code><code class="w">
</code><code class="w">    </code><code class="no">}</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO1-1" href="#co_configmaps_and_secrets_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The multiline string syntax (<code class="calibre15">|-</code>) used in this YAML structure removes the line feed and removes the trailing blank lines. For more information, see the <a href="https://yaml-multiline.info/" class="calibre10">YAML syntax for multiline string</a>.</p></dd>
</dl>

<p class="author1">The Pod mounts the ConfigMap as a volume to a specific path inside of the container with read-only permissions. The assumption is that the application will read the configuration file when starting up. <a data-type="xref" href="#mounting_configmap_volume" class="calibre10">Example 19-5</a> demonstrates the YAML definition.</p>
<div id="mounting_configmap_volume" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-5. </span>Mounting a ConfigMap as a volume</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/web-app:1.0.1</code><code class="w">
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w">
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-config-volume</code><code class="w">
</code><code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/etc/config</code><code class="w">
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-config-volume</code><code class="w">
</code><code class="w">    </code><code class="nt">configMap</code><code class="p">:</code><code class="w">                      </code><a class="calibre10" id="co_configmaps_and_secrets_CO2-1" href="#callout_configmaps_and_secrets_CO2-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-config</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO2-1" href="#co_configmaps_and_secrets_CO2-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Assign the volume type for referencing a ConfigMap object by name.</p></dd>
</dl>

<p class="author1">To verify the correct behavior, open an interactive shell to the container. As you can see in the following commands, the directory <em class="calibre3">/etc/config</em> contains a file with the key we used in the ConfigMap. The content represents the JSON configuration:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl exec -it backend -- /bin/sh</strong>
# ls -1 /etc/config
db.json
# cat /etc/config/db.json
{
    "db": {
      "host": "mysql-service",
      "user": "backend"
    }
}</pre>

<p class="author1">The application code can now read the file from the mount path and configure the runtime behavior as needed.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Working with Secrets" class="praise"><div class="dedication" id="id383">
<h1 class="calibre17">Working with Secrets</h1>

<p class="author1">Data stored in ConfigMaps represent arbitrary plain-text key-value pairs. In comparison to the ConfigMap, the Secret primitive is meant to represent sensitive configuration data. A typical example for Secret data is a password or an API key for authentication.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Values stored in a Secret are only encoded, not encrypted</h1>
<p class="author1">Secrets expect the value of each entry to be Base64-encoded. Base64 encodes only a value, but it doesn’t encrypt it. Therefore, anyone with access to its value can decode it without problems. Therefore, storing Secret manifests in the source code repository alongside other resource files should be avoided.</p>
</div>

<p class="author1">It’s somewhat unfortunate that the Kubernetes project decided to choose the term “Secret” to represent sensitive data. The nomenclature implies that data is actually secret and therefore encrypted. You can select from a range of options to keep sensitive data secure in real-world projects.</p>

<p class="author1"><a href="https://github.com/bitnami-labs/sealed-secrets" class="calibre10">Bitnami Sealed Secrets</a> is an production-ready and proven Kubernetes operator that uses asymmetric crypto encryption for data. The manifest representation of the data, the CRD SealedSecret, is safe to be stored in a public source code repository. You 
<span class="keep-together">cannot</span> decrypt this data yourself. The controller installed with the operator is the only entity that can decrypt the data. Another option is to store sensitive data in external secrets managers, e.g., HashiCorp Vault or AWS Secrets Manager, and integrate them with Kubernetes. The <a href="https://external-secrets.io/" class="calibre10">External Secrets Operator</a> synchronizes secrets from external APIs into Kubernetes. The exam only expects you to understand the built-in Secret primitive, covered in the following sections.</p>








<section data-type="sect2" data-pdf-bookmark="Creating a Secret" class="praise"><div class="dedication" id="id384">
<h2 class="calibre33">Creating a Secret</h2>

<p class="author1">You can create a Secret with the imperative command <code class="calibre15">create secret</code>. In addition, a mandatory subcommand needs to be provided that determines the type of Secret. <a data-type="xref" href="#options_creating_secret" class="calibre10">Table 19-2</a> lists the different types. Kubernetes assigns the value in the Internal Type column to the <code class="calibre15">type</code> attribute in the live object. <a data-type="xref" href="#specialized_secret_types" class="calibre10">“Specialized Secret types”</a> discusses other Secret types and their use cases.</p>
<table id="options_creating_secret" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 19-2. </span>Options for creating a Secret</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">CLI option</th>
<th class="calibre63">Description</th>
<th class="calibre63">Internal Type</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">generic</code></p></td>
<td class="calibre65"><p class="author1">Creates a secret from a file, directory, or literal value</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">Opaque</code></p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">docker-registry</code></p></td>
<td class="calibre65"><p class="author1">Creates a secret for use with a Docker registry, e.g., to pull images from a private registry when requested by a Pod</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">kubernetes.io/dockercfg</code></p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">tls</code></p></td>
<td class="calibre65"><p class="author1">Creates a TLS secret</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">kubernetes.io/tls</code></p></td>
</tr>
</tbody>
</table>

<p class="author1">The most commonly used Secret type is <code class="calibre15">generic</code>. The options for a generic Secret are exactly the same as for a ConfigMap, as shown in <a data-type="xref" href="#source_options_data_secret" class="calibre10">Table 19-3</a>.</p>
<table id="source_options_data_secret" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 19-3. </span>Source options for data parsed by a Secret</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Option</th>
<th class="calibre63">Example</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">--from-literal</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">--from-literal=password=secret</code></p></td>
<td class="calibre65"><p class="author1">Literal values, which are key-value pairs as plain text</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">--from-env-file</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">--from-env-file=config.env</code></p></td>
<td class="calibre65"><p class="author1">A file that contains key-value pairs and expects them to be environment variables</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">--from-file</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">--from-file=id_rsa=~/.ssh/id_rsa</code></p></td>
<td class="calibre65"><p class="author1">A file with arbitrary contents</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">--from-file</code></p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">--from-file=config-dir</code></p></td>
<td class="calibre65"><p class="author1">A directory with one or many files</p></td>
</tr>
</tbody>
</table>

<p class="author1">To demonstrate the functionality, let’s create a Secret of type <code class="calibre15">generic</code>. The command sources the key-value pairs from the literals provided as a command-line option:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create secret generic db-creds --from-literal=pwd=s3cre!</strong>
secret/db-creds created</pre>

<p class="author1">When created using the imperative command, a Secret will automatically Base64-encode the provided value. This can be observed by looking at the produced YAML manifest. You can see in <a data-type="xref" href="#secret_base64_encoded_values" class="calibre10">Example 19-6</a> that the value <code class="calibre15">s3cre!</code> has been turned into <code class="calibre15">czNjcmUh</code>, the Base64-encoded equivalent.</p>
<div id="secret_base64_encoded_values" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-6. </span>A Secret with Base64-encoded values</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Secret</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-creds</code><code class="w">
</code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Opaque</code><code class="w">       </code><a class="calibre10" id="co_configmaps_and_secrets_CO3-1" href="#callout_configmaps_and_secrets_CO3-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="nt">data</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">pwd</code><code class="p">:</code><code class="w"> </code><code class="calibre15">czNjcmUh</code><code class="w">    </code><a class="calibre10" id="co_configmaps_and_secrets_CO3-2" href="#callout_configmaps_and_secrets_CO3-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO3-1" href="#co_configmaps_and_secrets_CO3-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The value <code class="calibre15">Opaque</code> for the type has been assigned to represent generic sensitive data.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO3-2" href="#co_configmaps_and_secrets_CO3-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The plain-text value has been Base64-encoded automatically if the object has been created imperatively.</p></dd>
</dl>

<p class="author1">If you start with the YAML manifest to create the Secret object, you will need to create the Base64-encoded value if you want to assign it to the <code class="calibre15">data</code> attribute. A Unix tool that does the job is <code class="calibre15">base64</code>. The following command achieves exactly that:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ echo -n 's3cre!' | base64</strong>
czNjcmUh
</pre>

<p class="author1">As a reminder, if you have access to a Secret object or its YAML manifest then you can decode the Base64-encoded value at any time with the <code class="calibre15">base64</code> Unix tool. Therefore, you may as well specify the value in plain-text when defining the manifest, which we’ll discuss in the next section.</p>










<section data-type="sect3" data-pdf-bookmark="Defining Secret data with plain-text values" class="praise"><div class="dedication" id="id385">
<h3 class="calibre44">Defining Secret data with plain-text values</h3>

<p class="author1">Having to generate and assign Base64-encoded values to Secret manifests can become cumbersome. The Secret primitive offers the <code class="calibre15">stringData</code> attribute as a replacement for the <code class="calibre15">data</code> attribute. With <code class="calibre15">stringData</code>, you can assign plain-text values in the manifest file, as shown in <a data-type="xref" href="#secret_plain_text_values" class="calibre10">Example 19-7</a>.</p>
<div id="secret_plain_text_values" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-7. </span>A Secret with plain-text values</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Secret</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-creds</code><code class="w">
</code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Opaque</code><code class="w">
</code><code class="nt">stringData</code><code class="p">:</code><code class="w">      </code><a class="calibre10" id="co_configmaps_and_secrets_CO4-1" href="#callout_configmaps_and_secrets_CO4-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">pwd</code><code class="p">:</code><code class="w"> </code><code class="calibre15">s3cre!</code><code class="w">    </code><a class="calibre10" id="co_configmaps_and_secrets_CO4-2" href="#callout_configmaps_and_secrets_CO4-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO4-1" href="#co_configmaps_and_secrets_CO4-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The <code class="calibre15">stringData</code> attribute allows assigning plain-text key-value pairs.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO4-2" href="#co_configmaps_and_secrets_CO4-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The value referenced by the <code class="calibre15">pwd</code> key was provided in plain-text format.</p></dd>
</dl>

<p class="author1">Kubernetes will automatically Base64-encode the <code class="calibre15">s3cre!</code> value upon creation of the object from the manifest. The result is the live object representation shown in <a data-type="xref" href="#secret_live_object" class="calibre10">Example 19-8</a>, which you can retrieve with the command <code class="calibre15">kubectl get secret db-creds -o yaml</code>.</p>
<div id="secret_live_object" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-8. </span>A Secret live object</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Secret</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-creds</code><code class="w">
</code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Opaque</code><code class="w">
</code><code class="nt">data</code><code class="p">:</code><code class="w">              </code><a class="calibre10" id="co_configmaps_and_secrets_CO5-1" href="#callout_configmaps_and_secrets_CO5-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">pwd</code><code class="p">:</code><code class="w"> </code><code class="calibre15">czNjcmUh!</code><code class="w">   </code><a class="calibre10" id="co_configmaps_and_secrets_CO5-2" href="#callout_configmaps_and_secrets_CO5-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO5-1" href="#co_configmaps_and_secrets_CO5-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The live object of a Secret always uses the <code class="calibre15">data</code> attribute even though you may have used <code class="calibre15">stringData</code> in the manifest.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO5-2" href="#co_configmaps_and_secrets_CO5-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The value has been Base64-encoded upon creation.</p></dd>
</dl>

<p class="author1">You can represent arbitrary Secret data using the <code class="calibre15">Opaque</code> type. Kubernetes offers specialized Secret types you can choose from should the data fit specific uses cases. We’ll discuss those specialized Secret types in the next section.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Specialized Secret types" class="praise"><div class="dedication" id="specialized_secret_types">
<h3 class="calibre44">Specialized Secret types</h3>

<p class="author1">Instead of using the <code class="calibre15">Opaque</code> Secret type, you can also use one of the <a href="https://kubernetes.io/docs/concepts/configuration/secret/#secret-types" class="calibre10">specialized types</a> to represent configuration data for particular use cases. The type <code class="calibre15">kubernetes.io/basic-auth</code> is meant for basic authentication and expects the keys <code class="calibre15">username</code> and <code class="calibre15">password</code>. At the time of writing, Kubernetes does not validate the correctness of the assigned keys.</p>

<p class="author1">The created object from this definition automatically Base64-encodes the values 
<span class="keep-together">for both</span> keys. <a data-type="xref" href="#secret_type_basic_auth" class="calibre10">Example 19-9</a> illustrates a YAML manifest for a Secret with type <code class="calibre15">kubernetes.io/basic-auth</code>.</p>
<div id="secret_type_basic_auth" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-9. </span>Usage of the Secret type kubernetes.io/basic-auth</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Secret</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">secret-basic-auth</code><code class="w">
</code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">kubernetes.io/basic-auth</code><code class="w">
</code><code class="nt">stringData</code><code class="p">:</code><code class="w">                      </code><a class="calibre10" id="co_configmaps_and_secrets_CO6-1" href="#callout_configmaps_and_secrets_CO6-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">username</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko</code><code class="w">             </code><a class="calibre10" id="co_configmaps_and_secrets_CO6-2" href="#callout_configmaps_and_secrets_CO6-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">password</code><code class="p">:</code><code class="w"> </code><code class="calibre15">secret</code><code class="w">               </code><a class="calibre10" id="co_configmaps_and_secrets_CO6-3" href="#callout_configmaps_and_secrets_CO6-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO6-1" href="#co_configmaps_and_secrets_CO6-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Uses the <code class="calibre15">stringData</code> attribute to allow for assigning plain-text values.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO6-2" href="#co_configmaps_and_secrets_CO6-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Specifies the mandatory keys required by the <code class="calibre15">kubernetes.io/basic-auth</code> Secret type.</p></dd>
</dl>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Consuming a Secret as Environment Variables" class="praise"><div class="dedication" id="id387">
<h2 class="calibre33">Consuming a Secret as Environment Variables</h2>

<p class="author1">Consuming a Secret as environment variables works similar to the way you’d do it for ConfigMaps. Here, you’d use the YAML expression <code class="calibre15">spec.containers[].env⁠From[].secretRef</code> to reference the name of the Secret. <a data-type="xref" href="#injecting_secret_container" class="calibre10">Example 19-10</a> injects the Secret named <code class="calibre15">secret-basic-auth</code> as environment variables into the container named 
<span class="keep-together"><code class="calibre15">backend</code>.</span></p>
<div id="injecting_secret_container" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-10. </span>Injecting Secret key-value pairs into the container</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/web-app:1.0.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w"></code>
<code class="w">    </code><code class="nt">envFrom</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">secretRef</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">secret-basic-auth</code><code class="w"></code></pre></div>

<p class="author1">Inspecting the environment variables in the container reveals that the Secret values do not have to be decoded. That’s something Kubernetes does automatically. Therefore, the running application doesn’t need to implement custom logic to decode the value. Note that Kubernetes does not verify or normalize the typical naming conventions of environment variables, as you can see in the following output:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl exec backend -- env</strong>
...
username=bmuschko
password=secret
...</pre>










<section data-type="sect3" class="praise" data-pdf-bookmark="Remapping environment variable keys"><div class="dedication" id="id388">
<h3 class="calibre44">Remapping environment variable keys</h3>

<p class="author1">Sometimes, key-value pairs stored in a Secret do not conform to typical naming conventions for environment variables or can’t be changed without impacting running services. You can redefine the keys used to inject an environment variable into a Pod with the <code class="calibre15">spec.containers[].env[].valueFrom</code> attribute. <a data-type="xref" href="#remapping_environment_variable_keys" class="calibre10">Example 19-11</a> turns the key <code class="calibre15">username</code> into <code class="calibre15">USER</code> and the key <code class="calibre15">password</code> into <code class="calibre15">PWD</code>.</p>
<div id="remapping_environment_variable_keys" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-11. </span>Remapping environment variable keys for Secret entries</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/web-app:1.0.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w"></code>
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">USER</code><code class="w"></code>
<code class="w">      </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">secretKeyRef</code><code class="p">:</code><code class="w"></code>
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">secret-basic-auth</code><code class="w"></code>
<code class="w">          </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="calibre15">username</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">PWD</code><code class="w"></code>
<code class="w">      </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">secretKeyRef</code><code class="p">:</code><code class="w"></code>
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">secret-basic-auth</code><code class="w"></code>
<code class="w">          </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="calibre15">password</code><code class="w"></code></pre></div>

<p class="author1">The resulting environment variables available to the container now follow the typical conventions for environment variables, and we changed how their are consumed by the application code:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl exec backend -- env</strong>
...
USER=bmuschko
PWD=secret
...
</pre>

<p class="author1">The same mechanism of reassigning environment variables works for ConfigMaps. You’d use the attribute <code class="calibre15">spec.containers[].env[].valueFrom.configMapRef</code> instead.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Mounting a Secret as a Volume" class="praise"><div class="dedication" id="id389">
<h2 class="calibre33">Mounting a Secret as a Volume</h2>

<p class="author1">To demonstrate mounting a Secret as a volume, we’ll create a new Secret of type <code class="calibre15">kubernetes.io/ssh-auth</code>. This Secret type captures the value of an SSH private key that you can view using the command <code class="calibre15">cat ~/.ssh/id_rsa</code>. To process the SSH 
<span class="keep-together">private</span> key file with the <code class="calibre15">create secret</code> command, it needs to be available as a file with the name <code class="calibre15">ssh-privatekey</code>:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ cp ~/.ssh/id_rsa ssh-privatekey</strong>
<strong class="calibre38">$ kubectl create secret generic secret-ssh-auth --from-file=ssh-privatekey</strong> \
  <strong class="calibre38">--type=kubernetes.io/ssh-auth</strong>
secret/secret-ssh-auth created</pre>

<p class="author1">Mounting the Secret as a volume follows the two-step approach:  define the volume first and then reference it as a mount path for one or many containers. The volume type is called <code class="calibre15">secret</code> as used in <a data-type="xref" href="#mounting_secret_volume" class="calibre10">Example 19-12</a>.</p>
<div id="mounting_secret_volume" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 19-12. </span>Mounting a Secret as a volume</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/web-app:1.0.1</code><code class="w">
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">backend</code><code class="w">
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ssh-volume</code><code class="w">
</code><code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/var/app</code><code class="w">
</code><code class="w">      </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="calibre15">true</code><code class="w">                </code><a class="calibre10" id="co_configmaps_and_secrets_CO7-1" href="#callout_configmaps_and_secrets_CO7-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ssh-volume</code><code class="w">
</code><code class="w">    </code><code class="nt">secret</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">secretName</code><code class="p">:</code><code class="w"> </code><code class="calibre15">secret-ssh-auth</code><code class="w">   </code><a class="calibre10" id="co_configmaps_and_secrets_CO7-2" href="#callout_configmaps_and_secrets_CO7-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO7-1" href="#co_configmaps_and_secrets_CO7-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Files provided by the Secret mounted as volume cannot be modified.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_configmaps_and_secrets_CO7-2" href="#co_configmaps_and_secrets_CO7-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Note that the attribute <code class="calibre15">secretName</code> that points to the Secret name is not the same as for the ConfigMap (which is <code class="calibre15">name</code>).</p></dd>
</dl>

<p class="author1">You will find the file named <code class="calibre15">ssh-privatekey</code> in the mount path <em class="calibre3">/var/app</em>. To verify, open an interactive shell and render the file contents. The contents of the file are not Base64-encoded:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl exec -it backend -- /bin/sh</strong>
# ls -1 /var/app
ssh-privatekey
# cat /var/app/ssh-privatekey
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,8734C9153079F2E8497C8075289EBBF1
...
-----END RSA PRIVATE KEY-----</pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id390">
<h1 class="calibre17">Summary</h1>

<p class="author1">Application runtime behavior can be controlled either by injecting configuration data as environment variables or by mounting a volume to a path. In Kubernetes, this configuration data is represented by the API resources ConfigMap and Secret in the form of key-value pairs. A ConfigMap is meant for plain-text data, and a Secret encodes the values in Base64 to obfuscate the values. Secrets are a better fit for sensitive information like credentials and SSH private keys.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id391">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Practice creating ConfigMap objects with the imperative and declarative approach</dt>
<dd class="calibre20">
<p class="calibre21">The quickest ways to create those objects are the imperative <code class="calibre15">kubectl create configmap</code> commands. Understand how to provide the data with the help of different command line flags. The ConfigMap specifies plain-text key-value pairs in the <code class="calibre15">data</code> section of YAML manifest.</p>
</dd>
<dt class="calibre19">Practice creating Secret objects with the imperative and declarative approach</dt>
<dd class="calibre20">
<p class="calibre21">Creating a Secret using the imperative command <code class="calibre15">kubectl create secret</code> does not require you to Base64-encode the provided values. <code class="calibre15">kubectl</code> performs the encoding operation automatically. The declarative approach requires the Secret YAML manifest to specify a Base64-encoded value with the <code class="calibre15">data</code> section. You can use the <code class="calibre15">stringData</code> convenience attribute in place of the <code class="calibre15">data</code> attribute if you prefer providing a plain-text value. The live object will use a Base64-encoded value. Functionally, there’s no difference at runtime between the use of <code class="calibre15">data</code> and <code class="calibre15">stringData</code>.</p>
</dd>
<dt class="calibre19">Understand the purpose of specialized Secret types</dt>
<dd class="calibre20">
<p class="calibre21">Secrets offer specialized types, e.g., <code class="calibre15">kubernetes.io/basic-auth</code> or <code class="calibre15">kuber⁠netes.io/service-account-token</code>, to represent data for specific use cases. Read up on the different types in the Kubernetes documentation and understand their 
<span class="keep-together">purpose.</span></p>
</dd>
<dt class="calibre19">Know how to inspect ConfigMap and Secret data</dt>
<dd class="calibre20">
<p class="calibre21">The exam may confront you with existing ConfigMap and Secret objects. You need to understand how to use the <code class="calibre15">kubectl get</code> or the <code class="calibre15">kubectl describe</code> command to inspect the data of those objects. The live object of a Secret will always represent the value in a Base64-encoded format.</p>
</dd>
<dt class="calibre19">Exercise the consumption of ConfigMaps and Secrets in Pods</dt>
<dd class="calibre20">
<p class="calibre21">The primary use case for ConfigMaps and Secrets is the consumption of the data from a Pod. Pods can inject configuration data into a container as environment variables or mount the configuration data as Volumes. For the exam, you need to be familiar with both consumption methods.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id392">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_015.xhtml#appendix_a_configmaps_secrets" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">In this exercise, you will first create a ConfigMap from a YAML configuration file as a source. Later, you’ll create a Pod, consume the ConfigMap as Volume, and inspect the key-value pairs as files.</p>

<p class="author1">Navigate to the directory <em class="calibre3">app-a/ch19/configmap</em> of the checked-out GitHub repository <a href="https://github.com/bmuschko/ckad-study-guide" class="calibre10"><em class="calibre3">bmuschko/ckad-study-guide</em></a>. Inspect the YAML configuration file named <em class="calibre3">application.yaml</em>.</p>

<p class="author1">Create a new ConfigMap named <code class="calibre15">app-config</code> from that file.</p>

<p class="author1">Create a Pod named <code class="calibre15">backend</code> that consumes the ConfigMap as Volume at the mount path <em class="calibre3">/etc/config</em>. The container runs the image <code class="calibre15">nginx:1.23.4-alpine</code>.</p>

<p class="author1">Shell into the Pod and inspect the file at the mounted Volume path.</p>
</li>
<li class="calibre56">
<p class="author1">You will first create a Secret from literal values in this exercise. Next, you’ll create a Pod and consume the Secret as environment variables. Finally, you’ll print out its values from within the container.</p>

<p class="author1">Create a new Secret named <code class="calibre15">db-credentials</code> with the key/value pair <code class="calibre15">db-password=passwd</code>.</p>

<p class="author1">Create a Pod named <code class="calibre15">backend</code> that uses the Secret as an environment variable named <code class="calibre15">DB_PASSWORD</code> and runs the container with the image <code class="calibre15">nginx:1.23.4-alpine</code>.</p>

<p class="author1">Shell into the Pod and print out the created environment variables. You should be able to find the <code class="calibre15">DB_PASSWORD</code> variable.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>