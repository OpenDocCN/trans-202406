<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Policy"><div class="chapter" id="ch-policy">
<h1><span class="label">Chapter 8. </span>Policy</h1>


<p>Once a system is constructed on solid foundations, it must be used correctly
to maintain its integrity. Building a sea-fort to defend an island from pirates
is half the battle, followed by posting guards to the watchtower and being
prepared for defense at any time.</p>

<p>Like the orders to the fort’s guards, the<a data-type="indexterm" data-primary="policies" data-secondary="overview" id="idm45302810430944"/><a data-type="indexterm" data-primary="clusters" data-secondary="policies, overview" id="idm45302810429968"/><a data-type="indexterm" data-primary="cloud" data-secondary="policies, overview" id="idm45302810429024"/> policies applied to a cluster define
the range of behaviors allowed. For example, what security configuration options
a pod must use, storage and network options, container images, and any other
feature of the 
<span class="keep-together">workloads.</span></p>

<p>Policies must be synchronized across clusters and cloud (admission controllers,
IAM policy, security sidecars, service mesh, <code>seccomp</code> and AppArmor profiles)
and enforced. And policies must target workloads, which raises a question of identity.
Can we prove the identity of a workload before giving it privileges?</p>

<p>In this chapter we look at what happens when policies are not enforced,
how identity for workloads and operators should be managed, and how the
Captain would try to engage with potential holes in our defensive walls.</p>

<p>We will first review different types of policies and discuss the out-of-the-box
(OOTB) features of Kubernetes in this area. Then we move on to threat models and
common expectations concerning policies such as auditing. The bulk of the chapter
we spend with the access control topic, specifically around role-based access
control (RBAC) and further on we investigate the generic handling of policies
for Kubernetes, based on projects such as the Open Policy Agent (OPA) and
Kyverno.</p>






<section data-type="sect1" data-pdf-bookmark="Types of Policies"><div class="sect1" id="types-of-policies">
<h1>Types of Policies</h1>

<p>In real-world scenarios—that is, when you’re running workloads in production—in the context of a<a data-type="indexterm" data-primary="policies" data-secondary="types" id="idm45302810422448"/> business, you have to consider different types of
policies:</p>
<dl>
<dt>Technical policies</dt>
<dd>
<p>These are usually well understood and straightforward to implement (for example, runtime or network communication policies).</p>
</dd>
<dt>Organizational policies</dt>
<dd>
<p>Arriving at these policies can, depending on the organization, be challenging (for example, “developers only deploy to test and dev environments”).</p>
</dd>
<dt>Regulatory policies</dt>
<dd>
<p>These policies are dependent on the vertical your workload is operating in and can, depending on the level of compliance, take a lot of time and energy to implement (for example, the Payment Card Industry
Data Security Standards [PCI DSS] policy that cardholder data transmitted across open, public networks must be <a href="https://oreil.ly/iSQEE">encrypted</a>).</p>
</dd>
</dl>

<p>In the context of this chapter, we focus mainly on how to define and enforce policies that can be explicitly stated. In <a data-type="xref" href="ch10.xhtml#ch-organizations">Chapter 10</a> we go further and look at the organizational context and how usually, despite all policies in place, the human user (as the weakest link in the chain), provides the Captain with a welcome entry angle.</p>

<p>Let’s first have a look at what Kubernetes brings, by default, to the table.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Defaults"><div class="sect1" id="default-policies">
<h1>Defaults</h1>

<p>Policy is essential to<a data-type="indexterm" data-primary="policies" data-secondary="Kubernetes default configuration, overview" id="pol_kub_default"/><a data-type="indexterm" data-primary="configuration" data-secondary="default policies, overview" id="conf_defpol_oview"/> keeping Kubernetes secure, but by default little is enabled.
Configuration mutates with time for most software as new features come out;
misconfiguration is a common attack vector, and Kubernetes is no different.</p>

<p>Reusing and extending open source policy configuration<a data-type="indexterm" data-primary="open source" data-secondary="policy configuration" id="idm45302810407872"/> for your needs is often safer than
rolling out your own, and to protect against regressions you must test your
infrastructure and <a data-type="indexterm" data-primary="conftest" id="idm45302810406624"/><a data-type="indexterm" data-primary="configuration" data-secondary="testing" id="idm45302810405952"/><a data-type="indexterm" data-primary="testing" data-secondary="configuration" id="idm45302810405008"/><a data-type="indexterm" data-primary="testing" data-secondary="security code" id="idm45302810404064"/>security code with tools like <a href="https://oreil.ly/Jvg7z">conftest</a>
before you deploy it; in <a data-type="xref" href="#open-policy-agent">“Open Policy Agent”</a> we will dive deeper into this topic.</p>

<p><a data-type="xref" href="#tweet-brad-psp">Figure 8-1</a>, sums up the sentiment nicely. In it,
Kubernetes security practitioner <a href="https://oreil.ly/KaOWm">Brad Geesaman</a> points out the dangers of not having admission control enabled by default; see also the respective
<a href="https://oreil.ly/kHpfU">TGIK episdode</a>.</p>

<p>Now, what are the defaults that the Captain might be able to exploit, if you’re asleep at the helm?</p>

<figure class="width-70"><div id="tweet-brad-psp" class="figure">
<img src="Images/haku_0801.png" alt="tweet-brad-not-a-container-escape" width="848" height="884"/>
<h6><span class="label">Figure 8-1. </span>Brad Geesaman sagely reminding us of the dangers of Kubernetes defaults, and the importance of adding admission control</h6>
</div></figure>

<p>Kubernetes offers out-of-the-box support for some policies, including for
controlling network traffic, limiting resource usage, runtime behavior, and
most prominently for access control, which we will dive deeper into in
<a data-type="xref" href="#policy-authn-authz">“Authentication and Authorization”</a> and <a data-type="xref" href="#rbac">“Role-Based Access Control (RBAC)”</a> before we shift our attention
to generic policies in <a data-type="xref" href="#generic-policy-engines">“Generic Policy Engines”</a>.</p>

<p>Let’s have a closer look now at the defaults and see what challenges <a data-type="indexterm" data-primary="policies" data-secondary="Kubernetes default configuration, overview" data-startref="pol_kub_default" id="idm45302810392496"/><a data-type="indexterm" data-primary="configuration" data-secondary="default policies, overview" data-startref="conf_defpol_oview" id="idm45302810391072"/>we face.</p>








<section data-type="sect2" data-pdf-bookmark="Network Traffic"><div class="sect2" id="idm45302810389632">
<h2>Network Traffic</h2>

<p>The <code>NetworkPolicy</code> resource, in <a data-type="indexterm" data-primary="NetworkPolicy" id="idm45302810387760"/><a data-type="indexterm" data-primary="network policies" data-secondary="traffic" id="idm45302810387024"/><a data-type="indexterm" data-primary="policies" data-secondary="network traffic" id="idm45302810386080"/><a data-type="indexterm" data-primary="traffic" data-secondary="policies" id="idm45302810385136"/>conjunction with a CNI plug-in that
enforces it, allow us to put policies constraining network traffic in place (also see <a data-type="xref" href="ch05.xhtml#ch-networking">Chapter 5</a>).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Limiting Resource Allocations"><div class="sect2" id="idm45302810382864">
<h2>Limiting Resource Allocations</h2>

<p>In Kubernetes, by default, containers<a data-type="indexterm" data-primary="containers" data-secondary="resources, limiting" id="cont_res_lim"/><a data-type="indexterm" data-primary="resources" data-secondary="limiting" id="idm45302810379920"/> in pods are not restricted concerning
compute resource consumption. Since Kubernetes 1.10 you can use
<a href="https://oreil.ly/nQsYU">LimitRanges</a> to
constrain container and pod resource allocations <a data-type="indexterm" data-primary="LimitRanges" id="idm45302810378080"/><a data-type="indexterm" data-primary="namespaces" data-secondary="resources" data-tertiary="limiting" id="idm45302810377376"/>on a 
<span class="keep-together">per-namespace</span> basis.
This policy type is enforced via an admission controller, with the implication
that it doesn’t apply to running pods.</p>

<p>To see how LimitRanges work in action, assume you want to limit the memory
containers can use in the <code>dev</code> namespace to 2 GB of RAM. You would define the
policy like so:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">LimitRange</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">dev-mem-limits</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">limits</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Container</code>
    <code class="nt">max</code><code class="p">:</code>
      <code class="nt">memory</code><code class="p">:</code> <code class="l-Scalar-Plain">2Gi</code></pre>

<p>Assuming you stored the preceding YAML snippet in a file called <em>dev-mem-limits.yaml</em>
you would then, in order to enforce the limit range, execute the following
command:</p>

<pre data-type="programlisting" data-code-language="bash">kubectl -n dev apply -f dev-mem-limits.yaml</pre>

<p>If you now tried to create a pod with a container that attempts to
use more memory, you’d get an error message of<a data-type="indexterm" data-primary="containers" data-secondary="resources, limiting" data-startref="cont_res_lim" id="idm45302810285952"/> type 403<a data-type="indexterm" data-primary="memory" data-secondary="limiting" id="idm45302810351584"/> Forbidden.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Resource Quotas"><div class="sect2" id="idm45302810349344">
<h2>Resource Quotas</h2>

<p>In a multitenant<a data-type="indexterm" data-primary="quotas, resources" id="idm45302810347776"/><a data-type="indexterm" data-primary="Resource Quotas" id="idm45302810315360"/> environment, where a cluster is shared among multiple teams,
a particular team could potentially use more than its fair share of the
available resources as provided by the worker nodes (CPU, RAM, etc.).
<a href="https://oreil.ly/7sZLF">Resource quotas</a> are
a policy type allowing you to control these quotas.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Certain Kubernetes distributions, such as OpenShift, for<a data-type="indexterm" data-primary="OpenShift" data-secondary="resource quotas" id="idm45302810312672"/> example, extend
namespaces in a way (there it’s called “project”) that things like resource quotas are available and enforced out of the box.</p>
</div>

<p>For concrete usages, peruse the in-depth article
<a href="https://oreil.ly/MZKxX">“How to Use Kubernetes Resource Quotas”</a> and also check out the Google Cloud blog post on the topic,
<a href="https://oreil.ly/eTrf5">“Kubernetes Best Practices: Resource Requests and Limits”</a>.</p>

<p>In addition, since Kubernetes v1.20 there is<a data-type="indexterm" data-primary="process IDs, limiting" id="idm45302810309136"/> also a possibility to limit the number of
<a href="https://oreil.ly/AJaM8">process IDs</a> a pod may
use on a per-node basis.</p>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Runtime Policies"><div class="sect2" id="policy-runtime-policies">
<h2>Runtime Policies</h2>

<p><a href="https://oreil.ly/NfYXy">Pod Security Policies</a>
(PSPs) allow you to<a data-type="indexterm" data-primary="Pod Security Policies (PSPs)" id="idm45302810304816"/><a data-type="indexterm" data-primary="PSPs (Pod Security Policies)" id="idm45302810304112"/><a data-type="indexterm" data-primary="policies" data-secondary="PSPs" id="idm45302810303424"/><a data-type="indexterm" data-primary="runtime policies" id="idm45302810285088"/><a data-type="indexterm" data-primary="pods" data-secondary="creation policies" id="idm45302810284480"/><a data-type="indexterm" data-primary="pods" data-secondary="update policies" id="idm45302810283568"/> define fine-grained authorization of pod creation and updates.</p>

<p>Let’s say you want to set default <code>seccomp</code> and AppArmor profiles with PSPs, as also shown in the canonical docs example:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">policy/v1beta1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">PodSecurityPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">restricted</code>
  <code class="nt">annotations</code><code class="p">:</code>
    <code class="nt">seccomp.security.alpha.kubernetes.io/allowedProfileNames</code><code class="p">:</code>
    <code class="s">'docker/default,runtime/default'</code>
    <code class="nt">apparmor.security.beta.kubernetes.io/allowedProfileNames</code><code class="p">:</code> <code class="s">'runtime/default'</code>
    <code class="nt">seccomp.security.alpha.kubernetes.io/defaultProfileName</code><code class="p">:</code>  <code class="s">'runtime/default'</code>
    <code class="nt">apparmor.security.beta.kubernetes.io/defaultProfileName</code><code class="p">:</code>  <code class="s">'runtime/default'</code>
<code class="nt">spec</code><code class="p">:</code>
<code class="c1"># ...</code></pre>

<p>There is an issue with PSPs, though. They are at time of writing of the book in the
<a href="https://oreil.ly/YWAEJ">process of being deprecated</a>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Increasingly, organizations are looking into the
<a href="https://oreil.ly/9eC1B">OPA Constraints Framework</a>
as a replacement for PSPs, so maybe<a data-type="indexterm" data-primary="OPA Constraints Framework" id="idm45302810255024"/><a data-type="indexterm" data-primary="Open Policy Agent" data-secondary="OPA Constraints Framework" id="idm45302810254288"/> this is something you want to consider as well.</p>
</div>

<p>The good news is that replacements for PSPs exist: upstream, they are replaced by
<a href="https://oreil.ly/bvJzZ">Pod Security Standards</a>
(PSS) (the Aqua Security blog post <a href="https://oreil.ly/ayg7a">“Kubernetes Pod Security Policy Deprecation: All You Need to Know”</a> goes into further detail
here), and alternatively you can <a data-type="indexterm" data-primary="PSS (Pod Security Standards)" id="idm45302810218000"/><a data-type="indexterm" data-primary="Pod Security Standards (PSS)" id="idm45302810217296"/>use frameworks discussed in <a data-type="xref" href="#generic-policy-engines">“Generic Policy Engines”</a>
to cover runtime policies.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Access Control Policies"><div class="sect2" id="policy-access-control">
<h2>Access Control Policies</h2>

<p>Kubernetes<a data-type="indexterm" data-primary="access control policies" id="idm45302810213968"/><a data-type="indexterm" data-primary="policies" data-secondary="access control" id="idm45302810213232"/> is, concerning authentication and authorization,
flexible and extensible. We discuss the details of access control policies
in <a data-type="xref" href="#policy-authn-authz">“Authentication and Authorization”</a> and specifically role-based access control (RBAC) in
<a data-type="xref" href="#rbac">“Role-Based Access Control (RBAC)”</a>.</p>

<p>Now, with the overview on built-in policies in Kubernetes out of the way,
what does the threat modeling in the policies space look like? Let’s find out.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Threat Model"><div class="sect1" id="idm45302810412736">
<h1>Threat Model</h1>

<p>The threat model <a data-type="indexterm" data-primary="threat models" data-secondary="policies" id="idm45302810208368"/><a data-type="indexterm" data-primary="policies" data-secondary="threat models" id="idm45302810207360"/>relevant in the context of policies is broad, however
sometimes they may subtly be hidden within other topics and/or not explicitly
called out. Let’s have a look at some scenarios of past attacks pertinent to
the policy<a data-type="indexterm" data-primary="CVEs (Common Vulnerabilities and Exposures)" data-secondary="policies" id="idm45302810206048"/><a data-type="indexterm" data-primary="security" data-secondary="CVEs" data-tertiary="policies" id="idm45302810205008"/> space using examples from the 2016 to 2019 time frame:</p>

<ul>
<li>
<p><a href="https://oreil.ly/dPmHr">CVE-2016-5392</a> describes an
attack where the API server (in a multitenant environment) allowed
remote authenticated users with knowledge of other project names to
obtain sensitive project and user information via vectors related to
the watch-cache list.</p>
</li>
<li>
<p>Certain versions of CoreOS Tectonic mount a direct proxy to the cluster at
<em>/api/kubernetes/</em>, accessible without authentication to and allowing an
attacker to directly connect to the API server, as observed in
<a href="https://oreil.ly/FsmL2">CVE-2018-5256</a>.</p>
</li>
<li>
<p>In <a href="https://oreil.ly/9ZJHR">CVE-2019-3818</a>, the <code>kube-rbac-proxy</code> container did not honor TLS configurations, allowing for use of insecure
ciphers and TLS 1.0. An attacker could target traffic sent over a TLS
connection with a weak configuration and potentially break the encryption.</p>
</li>
<li>
<p>In <a href="https://oreil.ly/N5RfD">CVE-2019-11245</a> we see
how an attacker could exploit the fact that certain <code>kubelet</code> versions
did not specify an explicit <code>runAsUser</code> attempt to run as UID 0 (root)
on container restart, or if the image was previously pulled to the node.</p>
</li>
<li>
<p>As per <a href="https://oreil.ly/DcLvA">CVE-2019-11247</a> the
Kubernetes API server mistakenly allowed access to a cluster-scoped custom
resource if the request was made as if the resource were namespaced.
Authorizations for the resource accessed in this manner are enforced
using roles and role bindings within the namespace, meaning that a user
with access only to a resource in one namespace could create,
view, update, or delete the cluster-scoped resource.</p>
</li>
<li>
<p>In <a href="https://oreil.ly/fxRTk">CVE-2020-8554</a> it’s possible for an attack to person-in-the-middle
traffic, which in multitenant environments may intercept traffic to other tenants. The new
<a href="https://oreil.ly/SDAHG">DenyServiceExternalIPs</a>
admission controller was added as there is currently no patch for this issue.</p>
</li>
</ul>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Common Expectations"><div class="sect1" id="idm45302810189744">
<h1>Common Expectations</h1>

<p>In the following sections, we review some common expectations—that is, policy-related
situations and methods that are well-established—and how they are addressed
by defaults in Kubernetes and, in case there are no OOTB functions available,
point to examples that work on top of Kubernetes.</p>








<section data-type="sect2" data-pdf-bookmark="Breakglass Scenario"><div class="sect2" id="idm45302810187984">
<h2>Breakglass Scenario</h2>

<p>When we say breakglass scenario<a data-type="indexterm" data-primary="breakglass scenario" id="idm45302810186656"/><a data-type="indexterm" data-primary="policies" data-secondary="breakglass scenario" id="idm45302810185952"/> we routinely think of a process to
bypass the default access<a data-type="indexterm" data-primary="access control policies" data-secondary="breakglass scenario" id="idm45302810184880"/> control regime, in case of an emergency. The emergency
could be an external event like a natural disaster or an attacker trying to mess
with your cluster. If such a functionality is provided, the breakglass accounts
offered are usually highly privileged (so to stop the bleeding) and oftentimes
time-boxed. As breakglass access is granted, what happens in the background is that
owners are notified and the account is recorded for auditing.</p>

<p>While Kubernetes does not ship with breakglass features by default, there are
examples, such as GKE’s binary authorization
<a href="https://oreil.ly/ruud4">breakglass capability</a>, that show how this might work in practice.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Auditing"><div class="sect2" id="idm45302810181712">
<h2>Auditing</h2>

<p>Kubernetes comes<a data-type="indexterm" data-primary="policies" data-secondary="auditing" id="idm45302810180208"/><a data-type="indexterm" data-primary="auditing" data-secondary="policies" id="idm45302810179200"/> with
<a href="https://oreil.ly/PeOUe">auditing</a>
built in. In the API server, each request generates an audit event, which is
preprocessed according to a policy that states what is recorded and then
written to a backend; currently logfiles and webhooks (sends events
to an external HTTP API) are supported.</p>

<p>The configurable <a data-type="indexterm" data-primary="configuration" data-secondary="policy auditing" id="idm45302810176752"/>audit levels range from <code>None</code> (do not record event) to
<code>RequestResponse</code> (record event metadata, request and response bodies).</p>

<p>An example policy to capture events on ConfigMaps may look as follows:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">audit.k8s.io/v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Policy</code>
<code class="nt">rules</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">level</code><code class="p">:</code> <code class="l-Scalar-Plain">Request</code>
    <code class="nt">resources</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">group</code><code class="p">:</code> <code class="s">""</code>
      <code class="nt">resources</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"configmaps"</code><code class="p-Indicator">]</code></pre>

<p>The <a href="https://oreil.ly/AxDwJ">OOTB auditing features</a>
of Kubernetes are a good starting point and many security and observability
vendors offer, based on it, additional functionality, be it a more convenient
interface or integrations with destinations, including but not limited to the
following:</p>

<ul>
<li>
<p>Sysdig <a href="https://oreil.ly/ZS5tm">“Kubernetes Audit Logging”</a></p>
</li>
<li>
<p>Datadog <a href="https://oreil.ly/4WTOv">“Kubernetes Audit Logs”</a></p>
</li>
<li>
<p>Splunk/Outcold <a href="https://oreil.ly/GKvaW">“Monitoring Kubernetes: Metrics and Log Forwarding”</a></p>
</li>
</ul>

<p>As a good practice, enable auditing and try to find the right balance between
verbosity (audit level) and retention period.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Authentication and Authorization"><div class="sect1" id="policy-authn-authz">
<h1>Authentication and Authorization</h1>

<p>If you consider a <a data-type="indexterm" data-primary="policies" data-secondary="authentication and authorization" id="idm45302810115584"/><a data-type="indexterm" data-primary="authentication" data-secondary="policies" id="idm45302810114656"/><a data-type="indexterm" data-primary="authorization" data-secondary="policies" id="idm45302810113712"/>Kubernetes cluster, there are different types of resources,
both in-cluster (such as a pod or a namespace) as well as out-of-cluster (for
example, the load balancer of your cloud provider), that a service may provision. In
this section we will dive into the topic of defining and checking the access
a person or a program requires to access resources necessary to carry out a task.</p>

<p>In the context of <a data-type="indexterm" data-primary="access control policies" data-secondary="authentication and authorization" id="idm45302810111856"/>access control, when we say authorization we mean the
process of checking the permissions concerning a certain action, for example to
create or delete a resource, for a given identity. This identity can represent
a human user or a program, which we usually refer to as workload identity.
Verifying the identity of a subject, human or machine, is called authentication.</p>

<p><a data-type="xref" href="#fig-k8s-access-control-overview">Figure 8-2</a> shows, on a high level, how the access to resources
works in a Kubernetes cluster, covering the authentication and authorization
steps.</p>

<figure><div id="fig-k8s-access-control-overview" class="figure">
<img src="Images/haku_0802.png" alt="Kubernetes access control overview" width="1212" height="598"/>
<h6><span class="label">Figure 8-2. </span>Kubernetes access control overview (source: <a href="https://oreil.ly/lHeUm">Kubernetes documentation</a>)</h6>
</div></figure>

<p>The first step in the <a data-type="indexterm" data-primary="API server" data-secondary="authentication" id="idm45302810105920"/>API server is the authentication of the request via
one or more of the configured authentication modules such as client certificates,
passwords, or<a data-type="indexterm" data-primary="JWTs (JSON Web Tokens)" id="idm45302810104624"/><a data-type="indexterm" data-primary="JSON Web Tokens (JWTs)" id="idm45302810103952"/> JSON Web Tokens (JWT). If an API server cannot
authenticate the request, it rejects it with a 401 HTTP status. However, if the
authentication succeeds, the API server moves on to the authorization step.</p>

<p>In this step the API server uses one of the configured authorization modules
to determine if the access is allowed; it takes the credentials along with the
requested path, resource (pod, service, etc.) and verb (create, get, etc.),
and if at least one module grants access, the request is allowed. If the
authorization fails, an 403 HTTP status code is returned. The most widely used
authorization module nowadays is RBAC (see <a data-type="xref" href="#rbac">“Role-Based Access Control (RBAC)”</a>).</p>

<p>In the following sections, we will first review the defaults Kubernetes has, show
how those can be attacked, and subsequently discuss how to monitor and defend
against attacks in the access control space.</p>








<section data-type="sect2" data-pdf-bookmark="Human Users"><div class="sect2" id="idm45302810100496">
<h2>Human Users</h2>

<p>Kubernetes does <a data-type="indexterm" data-primary="human users, Kubernetes and" id="idm45302810098992"/>not consider <a href="https://oreil.ly/Y8sP0">human users</a>
as first-class citizens, in contrast to machines (or applications), which
are represented by so-called service accounts (see <a data-type="xref" href="#service-accounts">“Service accounts”</a>).
In other words, there are no core Kubernetes resources representing human users
in Kubernetes proper.</p>

<p>In practice, organizations oftentimes want to map Kubernetes cluster users to
existing user directories such as LDAP servers like Azure Directory and
ideally provide<a data-type="indexterm" data-primary="SSO (single sign-on), providing" id="idm45302810095712"/><a data-type="indexterm" data-primary="single sign-on (SSO), providing" id="idm45302810094992"/> single sign-on (SSO).</p>

<p>As usual, there are the two options available: buy or build. If you’re using
the Kubernetes distribution of your cloud provider, check the integrations
there. If you’re looking into building out SSO yourself, there are a number
of open source tools available that allow you to do this:</p>

<ul>
<li>
<p>OpenID Connect (OIDC)/OAuth 2.0–based solutions, such as available
via <a href="https://oreil.ly/BLDzz">Dex</a>.</p>
</li>
<li>
<p>Security Assertion Markup Language (SAML)–based solutions, such as
offered by
<a href="https://oreil.ly/jXtnG">Teleport</a>.</p>
</li>
</ul>

<p>In addition, there are more complete open source offerings such as
<a href="https://oreil.ly/tC4ZP">Keycloak</a>, supporting a range of use cases
from SSO to policy enforcement.</p>

<p>While humans don’t have a native representation in Kubernetes, your workload does.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Workload Identity"><div class="sect2" id="idm45302810088192">
<h2>Workload Identity</h2>

<p>In contrast <a data-type="indexterm" data-primary="workloads" data-secondary="identities" id="wrklds_ident"/>to human users, workloads such as a deployment owning pods
are indeed first-class citizens in Kubernetes.</p>










<section data-type="sect3" data-pdf-bookmark="Service accounts"><div class="sect3" id="service-accounts">
<h3>Service accounts</h3>

<p>By default, a <a href="https://oreil.ly/FxOIu">service account</a>
represents <a data-type="indexterm" data-primary="service accounts" id="servacct"/>the identity of an app in Kubernetes. A service account is a namespaced <a data-type="indexterm" data-primary="resources" data-secondary="service accounts" id="idm45302810081440"/>resource that can be used in the context
of a pod to authenticate your app against the API server. Its canonical form
is as follows:</p>

<pre data-type="programlisting">system:serviceaccount:NAMESPACE:NAME</pre>

<p class="pagebreak-before">As part of the control <a data-type="indexterm" data-primary="control plane" data-secondary="service accounts, automation" id="idm45302810078880"/>plane, <a href="https://oreil.ly/Rrn4a">three controllers</a>
jointly implement the service account automation, that is, managing Secrets
and tokens:</p>

<ul>
<li>
<p>The ServiceAccount admission controller,<a data-type="indexterm" data-primary="service accounts" data-secondary="ServiceAccount admission controller" id="idm45302810075712"/><a data-type="indexterm" data-primary="admission controllers" data-secondary="ServiceAccount" id="idm45302810074720"/> part of the API server, acts on pod
creation and update. The controller checks if service account used by the
pod exists, and in case it does not, rejects the pod (or, if no service
account is specified, uses the <code>default</code> service account). In addition, it
manages a volume, making the service account available via a well-known location:
<em>/var/run/secrets/kubernetes.io/serviceaccount</em>.</p>
</li>
<li>
<p>The TokenController, part of the<a data-type="indexterm" data-primary="TokenController" id="idm45302810071472"/> control plane component called controller
manager, watches service accounts and creates or deletes the respective
tokens. These are JSON Web Tokens (JWT) as defined in RFC 7519.</p>
</li>
<li>
<p>The ServiceAccount controller, also part of the controller manager,
ensures that in every namespace a service account <code>default</code> exists.</p>
</li>
</ul>

<p>For example, the <code>default</code> service account in the <code>kube-system</code> namespace
would be referred to as <code>system:serviceaccount:kube-system:default</code> and would
look something like the following:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ServiceAccount</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">default</code><code> </code><a class="co" id="co_policy_CO1-1" href="#callout_policy_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>  </code><code class="nt">namespace</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">kube-system</code><code> </code><a class="co" id="co_policy_CO1-2" href="#callout_policy_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code class="nt">secrets</code><code class="p">:</code><code>
</code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">default-token-v9vsm</code><code> </code><a class="co" id="co_policy_CO1-3" href="#callout_policy_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO1-1" href="#co_policy_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The <code>default</code> service account</p></dd>
<dt><a class="co" id="callout_policy_CO1-2" href="#co_policy_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>In the <code>kube-system</code> namespace</p></dd>
<dt><a class="co" id="callout_policy_CO1-3" href="#co_policy_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Using the Secret with the name <code>default-token-v9vsm</code></p></dd>
</dl>

<p>We saw that the <code>default</code> service account uses a Secret called
<code>default-token-v9vsm</code>, so let have a look at it with
<code>kubectl -n kube-system get secret default-token-v9vsm -o yaml</code>, which yields
the following YAML doc (edited to fit):</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Secret</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">annotations</code><code class="p">:</code>
    <code class="nt">kubernetes.io/service-account.name</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default-token-v9vsm</code>
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">kube-system</code>
<code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">kubernetes.io/service-account-token</code>
<code class="nt">data</code><code class="p">:</code>
  <code class="nt">ca.crt</code><code class="p">:</code> <code class="l-Scalar-Plain">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tL...==</code>
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">a3ViZS1zeXN0ZW0=</code>
  <code class="nt">token</code><code class="p">:</code> <code class="l-Scalar-Plain">ZXlKaGJHY2lPaUpTVXpJMU5pSXNJbXRwWk...==</code></pre>

<p>Your application can use the data managed by the control plane components
as described previously from within the pod. For example, from inside a container,
the volume is available at:</p>
<pre data-type="programlisting" data-code-language="sh" class="small">
~ <code class="nv">$ </code>ls -al /var/run/secrets/kubernetes.io/serviceaccount/
total 4
drwxrwxrwt <code class="m">3</code> root root  <code class="m">140</code> Jun <code class="m">16</code> 11:31 .
drwxr-xr-x <code class="m">3</code> root root <code class="m">4096</code> Jun <code class="m">16</code> 11:31 ..
drwxr-xr-x <code class="m">2</code> root root  <code class="m">100</code> Jun <code class="m">16</code> 11:31 ..2021_06_16_11_31_31.83035518
lrwxrwxrwx <code class="m">1</code> root root   <code class="m">31</code> Jun <code class="m">16</code> 11:31 ..data -&gt; ..2021_06_16_11_31_31.83035518
lrwxrwxrwx <code class="m">1</code> root root   <code class="m">13</code> Jun <code class="m">16</code> 11:31 ca.crt -&gt; ..data/ca.crt
lrwxrwxrwx <code class="m">1</code> root root   <code class="m">16</code> Jun <code class="m">16</code> 11:31 namespace -&gt; ..data/namespace
lrwxrwxrwx <code class="m">1</code> root root   <code class="m">12</code> Jun <code class="m">16</code> 11:31 token -&gt; ..data/token
</pre>

<p>The JWT token that the TokenController<a data-type="indexterm" data-primary="TokenController" id="idm45302809929536"/> created is readily available for
you:</p>

<pre data-type="programlisting" data-code-language="sh">~ <code class="nv">$ </code>cat /var/run/secrets/kubernetes.io/serviceaccount/token
eyJhbGciOiJSUzI1NiIsImtpZCI6InJTT1E1VDlUX1ROZEpRMmZSWi1aVW0yNWVocEh.
...</pre>

<p>Service accounts are regularly used as building blocks and can be combined
with other mechanisms such as <a href="https://oreil.ly/Tardt">projected volumes</a>
(discussed in <a data-type="xref" href="ch06.xhtml#ch-storage">Chapter 6</a>, and the <code>kubelet</code> for workload identity management.</p>

<p>For example, the EKS feature
<a href="https://oreil.ly/XXPUv">IAM roles for service accounts</a> demonstrates such a combination in action.</p>

<p>While handy, the service account does not provide for a cryptographically strong
workload identity out-of-the-box and hence may be not <a data-type="indexterm" data-primary="workloads" data-secondary="identities" data-startref="wrklds_ident" id="idm45302809857584"/>sufficient for <a data-type="indexterm" data-primary="service accounts" data-startref="servacct" id="idm45302809874752"/>certain use cases.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Cryptographically strong identities"><div class="sect3" id="idm45302810084608">
<h3>Cryptographically strong identities</h3>

<p><a href="https://spiffe.io">Secure Production Identity Framework for Everyone</a> (SPIFFE)
is a Cloud Native Computing Foundation (CNCF) project that<a data-type="indexterm" data-primary="SPIFFE (Secure Production Identity Framework for Everyone)" data-secondary="workload identities" id="SPIFFE_workident"/><a data-type="indexterm" data-primary="workloads" data-secondary="identities" data-tertiary="SPIFFE and" id="wrklds_ident_SPIFFE"/> establishes identities
for your workloads.
<a href="https://oreil.ly/e5bRL">SPIRE</a> is a
production-ready reference implementation of the SPIFFE APIs allowing performance of node and workload attestation; that is, you can automatically
assign cryptographically strong identities to resources like pods.</p>

<p>In SPIFFE, a workload is a program deployed using a specific configuration,
defined in the context of a trust domain, such as a Kubernetes cluster.
The identity of the workload is in the form of a so-called SPIFFE ID, which comes
in the general schema shown as follows:</p>

<pre data-type="programlisting" data-code-language="bash">spiffe://trust-domain/workload-identifier</pre>

<p>An SVID (short for SPIFFE Verifiable Identity Document) is <a data-type="indexterm" data-primary="SVIDs (SPIFFE Verifiable Identity Documents)" data-secondary="workload identities" id="idm45302809862736"/>the document, for
example a X.509 certificate JWT token, a workload proves its identity toward
a caller. The SVID is valid if it has been signed by an authority in the trust domain.</p>

<p>If you are not familiar with SPIFFE and want to read up on it, we recommend
having a look at the <a href="https://oreil.ly/6pwBP">terminology section of the SPIFFE docs</a>.</p>

<p>With this we’ve reached the end of the general authentication and authorization
discussion and focus now on a central topic in Kubernetes security: role-based access<a data-type="indexterm" data-primary="SPIFFE (Secure Production Identity Framework for Everyone)" data-secondary="workload identities" data-startref="SPIFFE_workident" id="idm45302809864864"/><a data-type="indexterm" data-primary="workloads" data-secondary="identities" data-tertiary="SPIFFE and" data-startref="wrklds_ident_SPIFFE" id="idm45302809839696"/>
control.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Role-Based Access Control (RBAC)"><div class="sect1" id="rbac">
<h1>Role-Based Access Control (RBAC)</h1>

<p>Nowadays, the default mechanism for granting humans and workloads access to
resources in Kubernetes is
<a href="https://oreil.ly/Z8wA3">role-based access control (RBAC)</a>.</p>

<p>We will first review the defaults, then discuss how to understand RBAC using
tools to analyze and visualize the relations, and finally we review attacks
in this space.</p>








<section data-type="sect2" data-pdf-bookmark="RBAC Recap"><div class="sect2" id="idm45302809834656">
<h2>RBAC Recap</h2>

<p>In the context of RBAC <a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="overview" id="RBAC_oview"/>we use the following terminology:</p>

<ul>
<li>
<p>An <em>identity</em> is a human user <a data-type="indexterm" data-primary="identities" id="idm45302809830192"/>or service account.</p>
</li>
<li>
<p>A <em>resource</em> is something (like a namespace or<a data-type="indexterm" data-primary="resources" id="idm45302809827968"/> deployment) we want to provide access to.</p>
</li>
<li>
<p>A <em>role</em> is used to define <a data-type="indexterm" data-primary="roles" id="idm45302809809424"/>conditions for actions on resources.</p>
</li>
<li>
<p>A <em>role binding</em> attaches a <a data-type="indexterm" data-primary="role bindings" id="idm45302809807440"/>role to an identity, effectively representing the
permissions of a set of actions concerning specified resources.</p>
</li>
</ul>

<p>Allowed actions of an identity on a given resource are called verbs that come
in two flavors: read-only ones (<code>get</code> and <code>list</code>) and read-write ones (<code>create</code>,
<code>update</code>, <code>patch</code>, <code>delete</code>, and <code>deletecollection</code>). Further, the scope of
a role can be cluster-wide or in the context of a Kubernetes namespace.</p>

<p>By default, Kubernetes comes with privilege escalation prevention. That is,
users can create or update a role only if they already have all the
permissions contained in the role.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are two types of <a data-type="indexterm" data-primary="roles" data-secondary="types" id="idm45302809800720"/><a data-type="indexterm" data-primary="clusters" data-secondary="cluster roles" id="idm45302809799712"/>roles in Kubernetes: roles and cluster roles. The
difference is the scope: the former is only relevant and valid in the
context of a namespace, whereas the latter works cluster-wide. The same is
true for the respective bindings.</p>
</div>

<p class="pagebreak-before">Last but not least, Kubernetes defines
a number of <a href="https://oreil.ly/Ned1s">default roles</a>
you might want to review<a data-type="indexterm" data-primary="roles" data-secondary="default" id="idm45302809796864"/><a data-type="indexterm" data-primary="default roles" id="idm45302809795888"/> before defining your own roles (or use them as starting
points).</p>

<p>For example, there’s a default cluster role<a data-type="indexterm" data-primary="edit (cluster role)" id="idm45302809794640"/> called <code>edit</code> predefined (note that
the output has been cut down<a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="overview" data-startref="RBAC_oview" id="idm45302809793328"/> to fit):</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>kubectl describe clusterrole edit
Name:         edit
Labels:       kubernetes.io/bootstrapping<code class="o">=</code>rbac-defaults
              rbac.authorization.k8s.io/aggregate-to-admin<code class="o">=</code><code class="nb">true</code>
Annotations:  rbac.authorization.kubernetes.io/autoupdate: <code class="nb">true</code>
PolicyRule:
  Resources     Non-Resource URLs  Resource Names  Verbs
  ---------     -----------------  --------------  -----
  configmaps    <code class="o">[]</code>                 <code class="o">[]</code>              <code class="o">[</code>create delete ... watch<code class="o">]</code>
  ...</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="A Simple RBAC Example"><div class="sect2" id="idm45302809834320">
<h2>A Simple RBAC Example</h2>

<p>In this section, we<a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="example implementation" id="RBAC_eximp"/> have a look at a simple RBAC example: assume you want to give a
developer <code>joey</code> the permission to view resources of type deployments
in the <code>yolo</code> namespace.</p>

<p>Let’s first create a <a data-type="indexterm" data-primary="clusters" data-secondary="cluster roles" data-tertiary="creating" id="idm45302809778768"/>cluster role called <code>view-deploys</code> that defines the
actions allowed for the targeted resources with the following command:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>kubectl create clusterrole view-deploys <code class="se">\</code>
  --verb<code class="o">=</code>get --verb<code class="o">=</code>list <code class="se">\</code>
  --resource<code class="o">=</code>deployments</pre>

<p>The preceding command creates a resource with a YAML representation as shown in the
following:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ClusterRole</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">view-deploys</code><code>
</code><code class="nt">rules</code><code class="p">:</code><code>
</code><code class="p-Indicator">-</code><code> </code><code class="nt">apiGroups</code><code class="p">:</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">apps</code><code>
</code><code>  </code><code class="nt">resources</code><code class="p">:</code><code> </code><a class="co" id="co_policy_CO2-1" href="#callout_policy_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">deployments</code><code>
</code><code>  </code><code class="nt">verbs</code><code class="p">:</code><code> </code><a class="co" id="co_policy_CO2-2" href="#callout_policy_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">get</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">list</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO2-1" href="#co_policy_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The targeted resources of this cluster role</p></dd>
<dt><a class="co" id="callout_policy_CO2-2" href="#co_policy_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The allowed actions when this cluster role is bound</p></dd>
</dl>

<p class="pagebreak-before">Next, we equip the targeted principal with the cluster role we created in the
previous step. This is achieved by the following command that binds the
<code>view-deploys</code> cluster role to the user <code>joey</code>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>kubectl create rolebinding assign-perm-view-deploys <code class="se">\</code>
  --role<code class="o">=</code>view-deploys <code class="se">\</code>
  --user<code class="o">=</code>joey <code class="se">\</code>
  --namespace<code class="o">=</code>yolo</pre>

<p>When you execute this command you create a resource with a YAML
representation like so:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">RoleBinding</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">assign-perm-view-deploys</code><code>
</code><code>  </code><code class="nt">namespace</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">yolo</code><code> </code><a class="co" id="co_policy_CO3-1" href="#callout_policy_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="nt">roleRef</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">apiGroup</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code>
</code><code>  </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Role</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">view-deploys</code><code> </code><a class="co" id="co_policy_CO3-2" href="#callout_policy_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code class="nt">subjects</code><code class="p">:</code><code>
</code><code class="p-Indicator">-</code><code> </code><code class="nt">apiGroup</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code>
</code><code>  </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">User</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">joey</code><code> </code><a class="co" id="co_policy_CO3-3" href="#callout_policy_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO3-1" href="#co_policy_CO3-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The scope of the role binding</p></dd>
<dt><a class="co" id="callout_policy_CO3-2" href="#co_policy_CO3-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The cluster role we want to use (bind)</p></dd>
<dt><a class="co" id="callout_policy_CO3-3" href="#co_policy_CO3-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The targeted principal (subject) to bind the cluster role to</p></dd>
</dl>

<p>Now, looking at a bunch of YAML code to determine what the permissions are
is usually not the way you want to go. Given its<a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="permissions, viewing" id="idm45302809557632"/><a data-type="indexterm" data-primary="permissions" data-secondary="RBAC" data-tertiary="viewing" id="idm45302809523808"/> graph nature, usually you
want some visual representation, something akin to what is depicted in
<a data-type="xref" href="#fig-rbac-example-graph">Figure 8-3</a>.</p>

<p>For this case it looks pretty straightforward, but alas the reality is much
more complicated and messy. Expect to deal with hundreds of roles, bindings, and subjects and actions across core Kubernetes resources as well as
custom resource definitions (CRDs).</p>

<p>So, how can you figure out what’s going on, how can you truly understand the
RBAC setup in your cluster? As usual, the answer is: additional <a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="example implementation" data-startref="RBAC_eximp" id="idm45302809520544"/>software.</p>

<figure><div id="fig-rbac-example-graph" class="figure">
<img src="Images/haku_0803.png" alt="Example RBAC graph showing what developer `joey` is allowed to do" width="1226" height="938"/>
<h6><span class="label">Figure 8-3. </span>Example RBAC graph showing what developer <code>joey</code> is allowed to do</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Authoring RBAC"><div class="sect2" id="idm45302809782240">
<h2>Authoring RBAC</h2>

<p>According to the <a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="roles, generating" id="RBAC_role_gen"/><a data-type="indexterm" data-primary="roles" data-secondary="generating" id="role_gen"/><a data-type="indexterm" data-primary="permissions" data-secondary="RBAC" data-tertiary="generating" id="perm_RBAC_gen"/>least privileges principle, you should only grant exactly the permissions necessary to carry out a specific task. But how do you arrive at the exact permissions? Too few means the task will fail, but too much power can yield a field day for attackers. A good way to go about this is to automate it: let’s have a look at a small but powerful tool called <code>audit2rbac</code> that <a data-type="indexterm" data-primary="audit2rbac" id="audit2rbac"/>can generate Kubernetes RBAC roles and role bindings covering API requests made by a user.</p>

<p>As a concrete example we’ll use an EKS cluster running in AWS.
First, install <a href="https://oreil.ly/nWB5K">awslogs</a> and <a data-type="indexterm" data-primary="awslogs" id="idm45302809508288"/>also
<a href="https://oreil.ly/hU8mO">audit2rbac</a> for your <a data-type="indexterm" data-primary="audit2rbac" id="idm45302809506736"/>
<span class="keep-together">platform.</span></p>

<p>For the following you need two terminal sessions as we use the first
command (<code>awslogs</code>) in a blocking mode.</p>

<p>First, in one terminal session, create the <a data-type="indexterm" data-primary="audit logs, creating" id="idm45302809503968"/>audit log by tailing the CloudWatch
output as follows (note, you can also directly pipe into <code>audit2rbac</code>):</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>awslogs get /aws/eks/example/cluster <code class="se">\</code>
  <code class="s2">"kube-apiserver-audit*"</code> <code class="se">\</code>
  --no-stream --no-group --watch <code class="se">\</code>
  &gt;&gt; audit-log.json</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While the <code>awslogs</code> snippet shown <a data-type="indexterm" data-primary="awslogs" id="idm45302809500272"/>here uses an AWS-specific method to grab the logs, the principle stays the same. For example, to
<a href="https://oreil.ly/j2sB0">view GKE logs</a> you could use <code>gcloud logging read</code> and <a href="https://oreil.ly/ikRda">AKS offers a similar way to access logs.</a></p>
</div>

<p>Now, in another terminal session, execute the <code>kubectl</code> command<a data-type="indexterm" data-primary="kubectl, generating roles" id="idm45302809495200"/> with the user you want to create the RBAC setting for. In the case shown we’re already logged in as said user, otherwise you can impersonate them with <code>--as</code>.</p>

<p>Let’s say you want to generate the necessary role and binding for listing all the
default resources (such as pods, services, etc.) across all namespaces. You would use the following command (note that the output is not shown):</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>kubectl get all -A
...</pre>

<p>At this point we should have the audit log in <em>audit-log.json</em> and can use it
as an input for <code>audit2rbac</code> as shown in the following. Let’s
consume the audit log and create RBAC roles and bindings for a specific user:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code><code>audit2rbac</code><code> </code><code>--user</code><code> </code><code>kubernetes-admin</code><code> </code><code class="se">\ </code><code>  </code><a class="co" id="co_policy_CO4-1" href="#callout_policy_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
  </code><code>--filename</code><code> </code><code>audit-log.json</code><code> </code><code class="se">\ </code><a class="co" id="co_policy_CO4-2" href="#callout_policy_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code>&gt;</code><code> </code><code>list-all.yaml</code><code>
</code><code>Opening</code><code> </code><code>audit</code><code> </code><code>source...</code><code>
</code><code>Loading</code><code> </code><code>events....</code><code>
</code><code>Evaluating</code><code> </code><code>API</code><code> </code><code>calls...</code><code>
</code><code>Generating</code><code> </code><code>roles...</code><code>
</code><code>Complete!</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO4-1" href="#co_policy_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Specify target user for the role binding.</p></dd>
<dt><a class="co" id="callout_policy_CO4-2" href="#co_policy_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Specify the logs to use as an input.</p></dd>
</dl>

<p>After running the preceding command, the resulting RBAC resources, comprising a cluster role and a cluster
role binding that permit the user <code>kubernetes-admin</code> to successfully execute
<code>kubectl get all -A</code>, is now available in <em>list-all.yaml</em> (note that the output has been trimmed):</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ClusterRole</code><code> </code><a class="co" id="co_policy_CO5-1" href="#callout_policy_CO5-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">annotations</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">audit2rbac.liggitt.net/version</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v0.8.0</code><code>
</code><code>  </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">audit2rbac.liggitt.net/generated</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">true</code><code class="s">"</code><code>
</code><code>    </code><code class="nt">audit2rbac.liggitt.net/user</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">kubernetes-admin</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">audit2rbac:kubernetes-admin</code><code>
</code><code class="nt">rules</code><code class="p">:</code><code>
</code><code class="p-Indicator">-</code><code> </code><code class="nt">apiGroups</code><code class="p">:</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="s">"</code><code class="s">"</code><code>
</code><code>  </code><code class="nt">resources</code><code class="p">:</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">pods</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">replicationcontrollers</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">services</code><code>
</code><code>  </code><code class="nt">verbs</code><code class="p">:</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">get</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">list</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">watch</code><code>
</code><code class="nn">...</code><code>
</code><code class="nn">---</code><code>
</code><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ClusterRoleBinding</code><code> </code><a class="co" id="co_policy_CO5-2" href="#callout_policy_CO5-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">annotations</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">audit2rbac.liggitt.net/version</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v0.8.0</code><code>
</code><code>  </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">audit2rbac.liggitt.net/generated</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">true</code><code class="s">"</code><code>
</code><code>    </code><code class="nt">audit2rbac.liggitt.net/user</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">kubernetes-admin</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">audit2rbac:kubernetes-admin</code><code>
</code><code class="nt">roleRef</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">apiGroup</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code>
</code><code>  </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ClusterRole</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">audit2rbac:kubernetes-admin</code><code>
</code><code class="nt">subjects</code><code class="p">:</code><code>
</code><code class="p-Indicator">-</code><code> </code><code class="nt">apiGroup</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code>
</code><code>  </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">User</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">kubernetes-admin</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO5-1" href="#co_policy_CO5-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The generated cluster role allowing you to list the default resources across
all namespaces</p></dd>
<dt><a class="co" id="callout_policy_CO5-2" href="#co_policy_CO5-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The binding, giving the user <code>kubernetes-admin</code> the permissions</p></dd>
</dl>
<div data-type="tip"><h6>Tip</h6>
<p>There’s also a <code>krew</code> plug-in<a data-type="indexterm" data-primary="krew plug-in" id="idm45302809359168"/> called <a href="https://oreil.ly/9TsqY">who-can</a>
allowing you to gather the same information, quickly.</p>
</div>

<p>That was some (automagic) entertainment, was it not? Automating the creation of the roles helps you in enforcing least privileges as otherwise the temptation to simply “give access to everything to make it work” is indeed a big one, playing into the hands of the Captain and their greedy crew.</p>

<p>Next up: how to read and understand RBAC in a <a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="roles, generating" data-startref="RBAC_role_gen" id="idm45302809356336"/><a data-type="indexterm" data-primary="roles" data-secondary="generating" data-startref="role_gen" id="idm45302809355024"/><a data-type="indexterm" data-primary="permissions" data-secondary="RBAC" data-tertiary="generating" data-startref="perm_RBAC_gen" id="idm45302809353808"/><a data-type="indexterm" data-primary="audit2rbac" data-startref="audit2rbac" id="idm45302809352320"/>scalable manner.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Analyzing and Visualizing RBAC"><div class="sect2" id="idm45302809516512">
<h2>Analyzing and Visualizing RBAC</h2>

<p>Given<a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="visualization" id="RBAC_visul"/><a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="analyzing" id="RBAC_analy"/> their nature, with RBAC you end up with a huge forest of directed acyclic graph
(DAGs), including the subjects, roles, their bindings, and actions. Trying to
manually comprehend the connections is almost impossible, so you want to either
visualize the graphs and/or use tooling to query for specific paths.</p>
<div data-type="tip"><h6>Tip</h6>
<p>To address the challenge of discovering RBAC tooling and good practices, we maintain
<a href="https://rbac.dev">rbac.dev</a>, open to suggestions for additions via issues and
pull requests.</p>
</div>

<p>For example, let’s assume you would like to perform a <a data-type="indexterm" data-primary="static analysis, RBAC" id="statanyl_RBAC"/>static analysis on
your RBAC setup. You could consider using <a href="https://oreil.ly/M9aUx">krane</a>,
a tool that identifies potential security risks and also makes suggestions on
how to mitigate those.</p>

<p>To demonstrate RBAC <a data-type="indexterm" data-primary="visualization, RBAC" id="idm45302809192112"/>visualization in action, let’s walk through two examples.</p>

<p>The first example to visualize RBAC is a <a href="https://oreil.ly/CG1q7">krew plug-in</a>
called <code>rbac-view</code> (<a data-type="xref" href="#fig-screen-shot-rbac-view">Figure 8-4</a>) that <a data-type="indexterm" data-primary="rbac-view" id="idm45302809188848"/>you can run as follows:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>kubectl rbac-view
INFO<code class="o">[</code>0000<code class="o">]</code> Getting K8s client
INFO<code class="o">[</code>0000<code class="o">]</code> serving RBAC View and http://localhost:8800
INFO<code class="o">[</code>0010<code class="o">]</code> Building full matrix <code class="k">for</code> json
INFO<code class="o">[</code>0010<code class="o">]</code> Building Matrix <code class="k">for</code> Roles
INFO<code class="o">[</code>0010<code class="o">]</code> Retrieving RoleBindings
INFO<code class="o">[</code>0010<code class="o">]</code> Building Matrix <code class="k">for</code> ClusterRoles
...</pre>

<figure><div id="fig-screen-shot-rbac-view" class="figure">
<img src="Images/haku_0804.png" alt="Screen shot of the `rbac-view` web interface in action" width="3358" height="1613"/>
<h6><span class="label">Figure 8-4. </span>Screenshot of the <code>rbac-view</code> web interface in action</h6>
</div></figure>

<p>Then you open the link provided, here <code>http://localhost:8800</code>, in a browser and
can interactively view and query roles.</p>

<p>The second example is a CLI tool called <a href="https://oreil.ly/sVFlg">rback</a>,
invented and <a data-type="indexterm" data-primary="rback" id="idm45302809149616"/>codeveloped by one of the authors. <code>rback</code> queries
RBAC-related information and generates a graph representation of service accounts,
(cluster) roles, and the access rules in <code>dot</code> format:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code><code>kubectl</code><code> </code><code>get</code><code> </code><code>sa,roles,rolebindings,clusterroles,clusterrolebindings</code><code> </code><code class="se">\ </code><a class="co" id="co_policy_CO6-1" href="#callout_policy_CO6-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
  </code><code>--all-namespaces</code><code> </code><code class="se">\ </code><a class="co" id="co_policy_CO6-2" href="#callout_policy_CO6-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code>-o</code><code> </code><code>json</code><code> </code><code class="p">|</code><code>
  </code><code>rback</code><code> </code><code class="p">|</code><code> </code><a class="co" id="co_policy_CO6-3" href="#callout_policy_CO6-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code>dot</code><code> </code><code>-Tpng</code><code>  </code><code>&gt;</code><code> </code><code>rback-output.png</code><code> </code><a class="co" id="co_policy_CO6-4" href="#callout_policy_CO6-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO6-1" href="#co_policy_CO6-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>List the resources to include in the graph.</p></dd>
<dt><a class="co" id="callout_policy_CO6-2" href="#co_policy_CO6-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Set the scope (in our case: cluster-wide).</p></dd>
<dt><a class="co" id="callout_policy_CO6-3" href="#co_policy_CO6-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Feed the resulting JSON into <code>rback</code> via <code>stdin</code>.</p></dd>
<dt><a class="co" id="callout_policy_CO6-4" href="#co_policy_CO6-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Feed the <code>rback</code> output in <code>dot</code> format to the <code>dot</code> program to generate the
image <code>rback-output.png</code>.</p></dd>
</dl>

<p>If you do have <a href="https://oreil.ly/suqyg">dot</a> installed you would find
the output in the file called <em>rback-output.png</em>, which would look <a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="visualization" data-startref="RBAC_visul" id="idm45302809063456"/><a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="analyzing" data-startref="RBAC_analy" id="idm45302809062160"/><a data-type="indexterm" data-primary="static analysis, RBAC" data-startref="statanyl_RBAC" id="idm45302809060928"/>something
like shown in <a data-type="xref" href="#fig-rback-output">Figure 8-5</a>.</p>

<figure><div id="fig-rback-output" class="figure">
<img src="Images/haku_0805.png" alt="Output of running `rback` against an EKS cluster" width="3853" height="687"/>
<h6><span class="label">Figure 8-5. </span>Output of running <code>rback</code> against an EKS cluster</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="RBAC-Related Attacks"><div class="sect2" id="idm45302809350656">
<h2>RBAC-Related Attacks</h2>

<p>There are <a data-type="indexterm" data-primary="RBAC (role-based access control)" data-secondary="attacks, patterns" id="idm45302809055344"/><a data-type="indexterm" data-primary="attacks" data-secondary="RBAC, patterns" id="idm45302809054368"/>not that many RBAC-related attacks found in the wild, indicated by CVEs.
The basic patterns include:</p>

<ul>
<li>
<p>Too-loose permissions. Oftentimes, due to time constraints or not being aware
of the issue, more permissions than actually needed to carry out a task are
granted. For example, you want to state people are allowed to manage
deployments and really all they need is to list and describe them, but you also
give edit rights to them. This is violating the least privileges principle and
a skilled attacker can misuse this setting.</p>
</li>
<li>
<p>Demarcation line blurry. The shared responsibilities model in the context of
running containers in a cloud environment might not always be super clear. For
example, while it’s usually clear who is responsible for patching the worker
nodes, it’s not always explicit who maintains application packages and their
dependencies. Too liberal RBAC settings suggested as defaults can, if not
properly reviewed, lead to an attack vector both subtle—as in: “ah, I thought
<em>you</em> are taking care of it”—and potentially with an unwelcome outcome when the
T&amp;C of the service have not been carefully perused.</p>
</li>
<li>
<p>Prior to Helm 3, there was an overly privileged component present that caused all sorts of <a href="https://oreil.ly/d6uXV">security   concerns</a>, especially <a href="https://oreil.ly/RKeUC">confused deputy</a> situations. While this is less and less of an issue, you might want
to double check if there’s still some Helm 2 used in your clusters.</p>
</li>
</ul>

<p>With the RBAC fun wrapped up, let’s now move on to the topic of generic policy
handling and engines for said purpose. The basic idea being that, rather than
hardcode certain policy types, making them part of Kubernetes proper, one has
a generic way to define policies and enforce it using one of the many
<a href="https://oreil.ly/MvJMK">Kubernetes extension</a> mechanisms.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Generic Policy Engines"><div class="sect1" id="generic-policy-engines">
<h1>Generic Policy Engines</h1>

<p>Let’s discuss generic policy engines that can be used in the context of
Kubernetes to define and enforce any kind of policy, from organizational
to regulatory ones.</p>








<section data-type="sect2" data-pdf-bookmark="Open Policy Agent"><div class="sect2" id="open-policy-agent">
<h2>Open Policy Agent</h2>

<p><a href="https://oreil.ly/xqarT">Open Policy Agent</a> (OPA) is a <a data-type="indexterm" data-primary="generic policy engines, Open Policy Agent" data-secondary="overview" id="idm45302809040320"/><a data-type="indexterm" data-primary="Open Policy Agent" data-secondary="overview" id="idm45302809039280"/>graduated CNCF project that
provides a general-purpose policy engine that unifies <a data-type="indexterm" data-primary="policies" data-secondary="enforcement" id="idm45302809038208"/>policy enforcement. The policies
in OPA are represented in a high-level declarative language called Rego. It lets
you specify policy as code and simple APIs to externalize policy decision-making,
that is, moving it out of your own software. As you can see in <a data-type="xref" href="#fig-opa-concept">Figure 8-6</a>,
OPA decouples policy decision-making from policy enforcement.</p>

<p>When you need to make a policy decision somewhere in your code (<code>service</code>), you’d use the OPA API to query the policy in question. As an input the OPA server takes the current request data (in JSON format) as well as a policy (in Rego format) as input and computes an answer such as “access allowed” or “here is a list of relevant locations.” Note that the answer is not a binary one and entirely depends on the rules and data provided, computed in a deterministic manner.</p>

<p>Let’s look at <a data-type="indexterm" data-primary="generic policy engines, Open Policy Agent" data-secondary="example" id="gpe_OPA_examp"/><a data-type="indexterm" data-primary="Open Policy Agent" data-secondary="example" id="OPA_examp"/>a concrete <a href="https://oreil.ly/TP45q">example</a> (one of
the examples from the Rego online playground). Imagine you
want to make sure that every resource has a <code>costcenter</code> label that starts with
<code>cccode-</code>, and if that’s not the case the user receives a message that this is
missing and cannot proceed (for example, cannot deploy an app).</p>

<figure><div id="fig-opa-concept" class="figure">
<img src="Images/haku_0806.png" alt="OPA concept" width="391" height="730"/>
<h6><span class="label">Figure 8-6. </span>OPA concept</h6>
</div></figure>

<p>In Rego, the rule would look something like the following (we will get back
to this example in <a data-type="xref" href="#opa-gatekeeper">“Gatekeeper”</a> in greater detail):</p>

<pre data-type="programlisting" data-code-language="bash"><code>package</code><code> </code><code>prod.k8s.acme.org</code><code>

</code><code>deny</code><code class="o">[</code><code>msg</code><code class="o">]</code><code> </code><code class="o">{</code><code> </code><a class="co" id="co_policy_CO7-1" href="#callout_policy_CO7-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
  </code><code>not</code><code> </code><code>input.request.object.metadata.labels.costcenter</code><code>
  </code><code>msg</code><code> </code><code>:</code><code class="o">=</code><code> </code><code class="s2">"Every resource must have a costcenter label"</code><code>
</code><code class="o">}</code><code>

</code><code>deny</code><code class="o">[</code><code>msg</code><code class="o">]</code><code> </code><code class="o">{</code><code> </code><a class="co" id="co_policy_CO7-2" href="#callout_policy_CO7-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code>value</code><code> </code><code>:</code><code class="o">=</code><code> </code><code>input.request.object.metadata.labels.costcenter</code><code>
  </code><code>not</code><code> </code><code>startswith</code><code class="o">(</code><code>value,</code><code> </code><code class="s2">"cccode-"</code><code class="o">)</code><code>
  </code><code>msg</code><code> </code><code>:</code><code class="o">=</code><code> </code><code>sprintf</code><code class="o">(</code><code class="s2">"Costcenter code must start with `cccode-`; found `%v`"</code><code>,</code><code> </code><code class="o">[</code><code>value</code><code class="o">]</code><code class="o">)</code><code>
</code><code class="o">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO7-1" href="#co_policy_CO7-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Is the <code>costcenter</code> label present?</p></dd>
<dt><a class="co" id="callout_policy_CO7-2" href="#co_policy_CO7-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Does the <code>costcenter</code> label start with a certain prefix?</p></dd>
</dl>

<p>Now, let’s assume someone does a <code>kubectl apply</code> that causes a pod to be created
that does not have a label.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The way OPA rather literally hooks into the API server is achieved via one
of the many Kubernetes extension mechanisms. In this case it uses the
<a href="https://oreil.ly/k5274">Dynamic Admission Control</a>; to <a data-type="indexterm" data-primary="Dynamic Admission Control" id="idm45302808973456"/>be more precise, it registers a webhook<a data-type="indexterm" data-primary="webhooks" id="idm45302808945104"/> that
the API server calls before the respective resource is persisted in <code>etcd</code>.</p>

<p>In other words, the <code>AdmissionReview</code> resource shown in the example is what the
API server sends to the OPA server, registered as a webhook.</p>
</div>

<p>As a result of the <code>kubectl</code> command the API server generates an <code>AdmissionReview</code>
resource, in the following shown as a JSON document:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code>
    <code class="nt">"kind"</code><code class="p">:</code> <code class="s2">"AdmissionReview"</code><code class="p">,</code>
    <code class="nt">"request"</code><code class="p">:</code> <code class="p">{</code>
        <code class="nt">"kind"</code><code class="p">:</code> <code class="p">{</code>
            <code class="nt">"kind"</code><code class="p">:</code> <code class="s2">"Pod"</code><code class="p">,</code>
            <code class="nt">"version"</code><code class="p">:</code> <code class="s2">"v1"</code>
        <code class="p">},</code>
        <code class="nt">"object"</code><code class="p">:</code> <code class="p">{</code>
            <code class="nt">"metadata"</code><code class="p">:</code> <code class="p">{</code>
                <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"myapp"</code>
            <code class="p">},</code>
            <code class="nt">"spec"</code><code class="p">:</code> <code class="p">{</code>
                <code class="nt">"containers"</code><code class="p">:</code> <code class="p">[</code>
                    <code class="p">{</code>
                        <code class="nt">"image"</code><code class="p">:</code> <code class="s2">"nginx"</code><code class="p">,</code>
                        <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"nginx-frontend"</code>
                    <code class="p">},</code>
                    <code class="p">{</code>
                        <code class="nt">"image"</code><code class="p">:</code> <code class="s2">"mysql"</code><code class="p">,</code>
                        <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"mysql-backend"</code>
                    <code class="p">}</code>
                <code class="p">]</code>
            <code class="p">}</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>With the preceding input, the OPA engine would compute the following output, which in
turn would be, for example, fed back by the API server to <code>kubectl</code> and shown to the user on the command line:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="o">{</code>
    <code class="s2">"deny"</code>: <code class="o">[</code>
        <code class="s2">"Every resource must have a costcenter label"</code>
    <code class="o">]</code>
<code class="o">}</code></pre>

<p class="pagebreak-before">Now, how to rectify the situation and make it work? Simply add a label:</p>

<pre data-type="programlisting" data-code-language="json"><code class="s2">"metadata"</code><code class="err">:</code> <code class="p">{</code>
                <code class="nt">"name"</code><code class="p">:</code> <code class="s2">"myapp"</code><code class="p">,</code>
                <code class="nt">"labels"</code><code class="p">:</code> <code class="p">{</code>
                    <code class="nt">"costcenter"</code><code class="p">:</code> <code class="s2">"cccode-HQ"</code>
                 <code class="p">}</code>
            <code class="p">}</code><code class="err">,</code></pre>

<p>This should go without saying, but it is always a good idea to
<a href="https://oreil.ly/FUmBU">test your policies</a> before
you deploy them.</p>

<p>Rego<a data-type="indexterm" data-primary="Rego" id="idm45302808781008"/> is a little different than what you might be used to and the best analogue
we could come up with is XSLT. If you do decide to adopt <a data-type="indexterm" data-primary="generic policy engines, Open Policy Agent" data-secondary="example" data-startref="gpe_OPA_examp" id="idm45302808780176"/><a data-type="indexterm" data-primary="Open Policy Agent" data-secondary="example" data-startref="OPA_examp" id="idm45302808778928"/>Rego, consider
internalizing some <a href="https://oreil.ly/0hmL6">tips</a>.</p>










<section data-type="sect3" data-pdf-bookmark="Using OPA directly"><div class="sect3" id="idm45302808776752">
<h3>Using OPA directly</h3>

<p>To use OPA<a data-type="indexterm" data-primary="generic policy engines, Open Policy Agent" data-secondary="command line use" id="gpe_OPA_cluse"/><a data-type="indexterm" data-primary="Open Policy Agent" data-secondary="command line use" id="OPA_cluse"/> on the command line directly or in the context of an editor
is fairly straightforward.</p>

<p>First, let’s see how to evaluate a given input and a policy. You start, as
usual, with <a href="https://oreil.ly/qpIvc">installing OPA</a>. Given that it’s written in Go, this means a single, self-contained binary.</p>

<p>Next, let’s say we want to use the <code>costcenter</code> example and evaluate it on the
command line, assuming you have stored the <code>AdmissionReview</code> resource in
a file called <em>input.json</em> and the Rego rules in <em>cc-policy.rego</em>:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code><code>opa</code><code> </code><code class="nb">eval</code><code> </code><code class="se">\
</code><code>  </code><code>--input</code><code> </code><code>input.json</code><code> </code><code class="se">\ </code><a class="co" id="co_policy_CO8-1" href="#callout_policy_CO8-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
  </code><code>--data</code><code> </code><code>cc-policy.rego</code><code> </code><code class="se">\ </code><a class="co" id="co_policy_CO8-2" href="#callout_policy_CO8-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
  </code><code>--package</code><code> </code><code>prod.k8s.acme.org</code><code> </code><code class="se">\ </code><a class="co" id="co_policy_CO8-3" href="#callout_policy_CO8-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
  </code><code>--format</code><code> </code><code>pretty</code><code> </code><code class="s1">'deny'</code><code> </code><a class="co" id="co_policy_CO8-4" href="#callout_policy_CO8-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="o">[</code><code>
  </code><code class="s2">"Every resource must have a costcenter label"</code><code>
</code><code class="o">]</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO8-1" href="#co_policy_CO8-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Specify the input OPA should use (an <code>AdmissionReview</code> resource).</p></dd>
<dt><a class="co" id="callout_policy_CO8-2" href="#co_policy_CO8-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Specify what rules to use (in Rego format).</p></dd>
<dt><a class="co" id="callout_policy_CO8-3" href="#co_policy_CO8-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Set the evaluation context.</p></dd>
<dt><a class="co" id="callout_policy_CO8-4" href="#co_policy_CO8-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Specify output.</p></dd>
</dl>

<p>That was easy enough! But we can go a step further: how about using OPA/Rego
in an editor, for developing new policies?</p>

<p>Interestingly enough, a <a href="https://oreil.ly/ezA46">range of
IDEs and editors</a>, from VSCode to <code>vim</code>, are supported (see <a data-type="xref" href="#fig-opa-vim">Figure 8-7</a>).</p>

<figure><div id="fig-opa-vim" class="figure">
<img src="Images/haku_0807.png" alt="Screen shot of the Rego plug-in for `vim`" width="1099" height="607"/>
<h6><span class="label">Figure 8-7. </span>Screenshot of the Rego plug-in for <code>vim</code></h6>
</div></figure>

<p>In the context of managing OPA policies across a fleet of clusters, you may want
to consider evaluating Styra’s
<a href="https://www.styra.com">Declarative Authorization Service (DAS) offering</a>,
an enterprise OPA solution coming with some useful features such as
centralized policy management and logging, as well as impact analysis.</p>
<div data-type="tip"><h6>Tip</h6>
<p>You can type-check <a data-type="indexterm" data-primary="Rego" data-secondary="type-checking" id="idm45302808674016"/>Rego policies in OPA with JSON schema. This adds another layer of validation and can help policy developers to catch bugs. Learn more
about this topic via <a href="https://oreil.ly/LpPfj">“Type
Checking Your Rego Policies with JSON Schema in OPA”</a>.</p>
</div>

<p>Do you have to use Rego directly, though? No you do not have to, really.
Let’s discuss alternatives in the context of <a data-type="indexterm" data-primary="generic policy engines, Open Policy Agent" data-secondary="command line use" data-startref="gpe_OPA_cluse" id="idm45302808671360"/><a data-type="indexterm" data-primary="Open Policy Agent" data-secondary="command line use" data-startref="OPA_cluse" id="idm45302808670016"/>Kubernetes, next.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Gatekeeper"><div class="sect3" id="opa-gatekeeper">
<h3>Gatekeeper</h3>

<p>Given that <a data-type="indexterm" data-primary="generic policy engines, Open Policy Agent" data-secondary="Gatekeeper and" id="gpe_OPA_gtkpr"/><a data-type="indexterm" data-primary="Open Policy Agent" data-secondary="Gatekeeper and" id="OPA_gtkpr"/><a data-type="indexterm" data-primary="Gatekeeper, Open Policy Agent" id="gtkpr_OPA"/>Rego is a DSL and has a learning curve, folks oftentimes wonder
if they should use it directly or if there are more Kubernetes-native
ways to use OPA. In fact the <a href="https://oreil.ly/VvSgk">Gatekeeper project</a> allows exactly for this.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you’re unsure if you should be using Gatekeeper over OPA directly, there are plenty of nice articles available that discuss the topic in greater detail; for example, <a href="https://oreil.ly/tBNvD">“Differences Between OPA and Gatekeeper for Kubernetes Admission Control”</a> and <a href="https://oreil.ly/AJJhy">“Integrating Open Policy Agent (OPA) With Kubernetes”</a>.</p>
</div>

<p>What Gatekeeper does is essentially introduce a separation of concerns: so-called templates represent the policies (encoding Rego) and as an end user
you would interface with CRDs that use said templates. An admission controller
configured in the API server takes care of the enforcement of the policies,
then.</p>

<p>Let’s have a look at how the previous example concerning <code>costcenter</code>
labels being required could look with Gatekeeper. We assume that you have
<a href="https://oreil.ly/6fGJp">installed Gatekeeper already</a>.</p>

<p>First, you define the template, defining a new CRD called <code>K8sCostcenterLabels</code>
in a file called <em>costcenter_template.yaml</em>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">templates.gatekeeper.sh/v1beta1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ConstraintTemplate</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">costcenterlabels</code><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">crd</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>      </code><code class="nt">names</code><code class="p">:</code><code>
</code><code>        </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">K8sCostcenterLabels</code><code>
</code><code>      </code><code class="nt">validation</code><code class="p">:</code><code>
</code><code>        </code><code class="nt">openAPIV3Schema</code><code class="p">:</code><code> </code><a class="co" id="co_policy_CO9-1" href="#callout_policy_CO9-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>          </code><code class="nt">properties</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>              </code><code class="nt">type</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">array</code><code>
</code><code>              </code><code class="nt">items</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">string</code><code>
</code><code>  </code><code class="nt">targets</code><code class="p">:</code><code>
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">target</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">admission.k8s.gatekeeper.sh</code><code>
</code><code>      </code><code class="nt">rego</code><code class="p">:</code><code> </code><code class="p-Indicator">|</code><code>
</code><code>  </code><code class="l-Scalar-Plain">package</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">prod.k8s.acme.org</code><code>

</code><code>  </code><code class="l-Scalar-Plain">deny[msg]</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">{</code><code> </code><a class="co" id="co_policy_CO9-2" href="#callout_policy_CO9-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>    </code><code class="l-Scalar-Plain">not</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">input.request.object.metadata.labels.costcenter</code><code> </code><a class="co" id="co_policy_CO9-3" href="#callout_policy_CO9-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>    </code><code class="l-Scalar-Plain">msg</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">:=</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">"Every</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">resource</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">must</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">have</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">a</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">costcenter</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">label"</code><code>
</code><code>  </code><code class="err">}</code><code>

</code><code>  </code><code class="l-Scalar-Plain">deny[msg]</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">{</code><code> </code><a class="co" id="co_policy_CO9-4" href="#callout_policy_CO9-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>    </code><code class="l-Scalar-Plain">value</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">:=</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">input.request.object.metadata.labels.costcenter</code><code>
</code><code>    </code><code class="l-Scalar-Plain">not</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">startswith(value,</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">"cccode-")</code><code>
</code><code>    </code><code class="l-Scalar-Plain">msg</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">:=</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">sprintf("Costcenter</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">code</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">must</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">start</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">with</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">`cccode-`;</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">found</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">`%v`",</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">[value])</code><code>
</code><code>  </code><code class="err">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO9-1" href="#co_policy_CO9-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>This defines the schema for the <code>parameters</code> field.</p></dd>
<dt><a class="co" id="callout_policy_CO9-2" href="#co_policy_CO9-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>This definition checks if the <code>costcenter</code> label is provided or not. Note that
each rule contributes individually to the resulting (error) messages.</p></dd>
<dt><a class="co" id="callout_policy_CO9-3" href="#co_policy_CO9-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The <code>not</code> keyword in this rule turns an undefined statement into a truthy
statement. That is, if any of the keys are missing, this statement is true.</p></dd>
<dt><a class="co" id="callout_policy_CO9-4" href="#co_policy_CO9-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>In this rule we check if the <code>costcenter</code> label is formatted appropriately.
In other words, we require that it <em>must</em> start with <code>cccode-</code>.</p></dd>
</dl>

<p>When you have the CRD defined, you then can install it as follows:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>kubectl apply -f costcenter_template.yaml</pre>

<p>To use the <code>costcenter</code> template CRD, you have to define a concrete
instance (a custom resource, or CR for short), so put the following
in a file called <em>req_cc.yaml</em>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">constraints.gatekeeper.sh/v1beta1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">K8sCostcenterLabels</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ns-must-have-cc</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">match</code><code class="p">:</code>
    <code class="nt">kinds</code><code class="p">:</code>
      <code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code>
        <code class="nt">kinds</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"Namespace"</code><code class="p-Indicator">]</code></pre>

<p>Which you then create using the following command:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nv">$ </code>kubectl apply -f req_cc.yaml</pre>

<p>After this command, the Gatekeeper controller knows about the policy and
enforces it.</p>

<p>To check if the preceding policy works, you can create a namespace
that doesn’t have a label and if you then tried to create the namespace, for
example using <code>kubectl apply</code>, you would see an error message containing
“Every resource must have a costcenter label” along with the resource creation
denial.</p>

<p>With this you have a basic idea of how Gatekeeper works. Now let’s move on
to an alternative way to effectively achieve<a data-type="indexterm" data-primary="generic policy engines, Open Policy Agent" data-secondary="Gatekeeper and" data-startref="gpe_OPA_gtkpr" id="idm45302808407728"/><a data-type="indexterm" data-primary="Open Policy Agent" data-secondary="Gatekeeper and" data-startref="OPA_gtkpr" id="idm45302808362176"/><a data-type="indexterm" data-primary="Gatekeeper, Open Policy Agent" data-startref="gtkpr_OPA" id="idm45302808360960"/> the same: the CNCF Kyverno project.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Kyverno"><div class="sect2" id="kyverno">
<h2>Kyverno</h2>

<p>Another way<a data-type="indexterm" data-primary="policies" data-secondary="management" data-tertiary="Kyverno" id="pol_man_kyv"/><a data-type="indexterm" data-primary="Kyverno, policy management" id="kyv_polman"/> to go about managing and enforcing policies is a CNCF project
by the name of <a href="https://kyverno.io">Kyverno</a>. This project, initiated by Nirmata,
is conceptually similar to Gatekeeper. Kyverno works as shown in
<a data-type="xref" href="#fig-kyverno-concept">Figure 8-8</a>: it runs as a dynamic admission controller, supporting both validating and mutating admission webhooks.</p>

<figure><div id="fig-kyverno-concept" class="figure">
<img src="Images/haku_0808.png" alt="Kyverno concept" width="992" height="762"/>
<h6><span class="label">Figure 8-8. </span>Kyverno concept</h6>
</div></figure>

<p>So, what’s the difference between using Gatekeeper or plain OPA, then? Well,
rather than directly or indirectly using Rego, with Kyverno you can do the following:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">kyverno.io/v1</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ClusterPolicy</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">costcenterlabels</code><code>
</code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">validationFailureAction</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">enforce</code><code>
</code><code>  </code><code class="nt">rules</code><code class="p">:</code><code>
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">check-for-labels</code><code>
</code><code>    </code><code class="nt">match</code><code class="p">:</code><code> </code><a class="co" id="co_policy_CO10-1" href="#callout_policy_CO10-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>      </code><code class="nt">resources</code><code class="p">:</code><code>
</code><code>        </code><code class="nt">kinds</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">Namespace</code><code>
</code><code>    </code><code class="nt">validate</code><code class="p">:</code><code>
</code><code>      </code><code class="nt">message</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">label</code><code class="nv"> </code><code class="s">'app.kubernetes.io/name'</code><code class="nv"> </code><code class="s">is</code><code class="nv"> </code><code class="s">required</code><code class="s">"</code><code>
</code><code>      </code><code class="nt">pattern</code><code class="p">:</code><code> </code><a class="co" id="co_policy_CO10-2" href="#callout_policy_CO10-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>        </code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>          </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">app.kubernetes.io/name</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">?cccode-*</code><code class="s">"</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_policy_CO10-1" href="#co_policy_CO10-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Defines what resources to target, in this case namespaces.</p></dd>
<dt><a class="co" id="callout_policy_CO10-2" href="#co_policy_CO10-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Defines the expected pattern; in case this is not achieved, the preceding error
message is returned via webhook to client.</p></dd>
</dl>

<p>Does the preceding YAML look familiar? This is our costcenter-labels-are-required
example from earlier on.</p>

<p>Learn more about getting started from Gaurav Agarwal’s article
<a href="https://oreil.ly/KxQGc">“Policy as Code on Kubernetes with Kyverno”</a>
and watch <a href="https://oreil.ly/H8kMm">“Introduction to Kyverno”</a>
from David McKay’s excellent Rawkode Live series on YouTube.</p>

<p>Both OPA/Gatekeeper and Kyverno fail open, meaning that if the policy engine
service called by the API server webhook is down and hence unable to validate
an inbound change, they will proceed unvalidated. Depending on your requirements
this may not be what you want, but the reasoning behind this is to prevent
DOSing your cluster and subsequently slowing it down or potentially bringing
down the control plane at all.</p>

<p>Both have auditing functionalities as well as
a scanning mode that addresses this situation. For a more fine-grained comparison,
we recommend you peruse Chip Zoller’s blog post
<a href="https://oreil.ly/qBd3l">“Kubernetes Policy Comparison: OPA/Gatekeeper vs. Kyverno”</a>.</p>

<p>Let’s now have a further look at other options in <a data-type="indexterm" data-primary="policies" data-secondary="management" data-tertiary="Kyverno" data-startref="pol_man_kyv" id="idm45302808270256"/><a data-type="indexterm" data-primary="Kyverno, policy management" data-startref="kyv_polman" id="idm45302808232816"/>this space.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Other Policy Offerings"><div class="sect2" id="idm45302808378208">
<h2>Other Policy Offerings</h2>

<p>In this last section on handling <a data-type="indexterm" data-primary="policies" data-secondary="management" data-tertiary="tools" id="pol_man_tools"/>policies for and in Kubernetes
we review some projects and offerings that you may want to consider using in
addition to or as an alternative to the previously discussed ones.</p>

<p>Given that a Kubernetes cluster doesn’t operate in a vacuum, but in a certain
environment such as the case with managed offerings that would be the cloud
provider of your choice, you may indeed already be using some of the following:</p>
<dl>
<dt><a href="https://oreil.ly/e4r3X">OSO</a></dt>
<dd>
<p>This is a library for building <a data-type="indexterm" data-primary="OSO" id="idm45302808225744"/><a data-type="indexterm" data-primary="authorization" data-secondary="OSO" id="idm45302808225040"/>authorization in your application. It comes with a set of APIs built on top of a declarative policy language called Polar, as well as a CLI/REPL and a debugger and REPL. With OSO you can express policies like “these types of users can see these sorts of information,” as well as implement role-based access control in your app.</p>
</dd>
<dt><a href="https://oreil.ly/FB7RB">Cilium policy</a> and <a href="https://oreil.ly/xyh87">Calico policy</a></dt>
<dd>
<p>These extend<a data-type="indexterm" data-primary="Calico" data-secondary="policy" id="idm45302808221216"/> the functionalities of Kubernetes network policies.</p>
</dd>
<dt><a href="https://oreil.ly/Bi835">AWS Identity and Access Management (IAM)</a></dt>
<dd>
<p>This has a range of policies, from identity-based to <a data-type="indexterm" data-primary="Identity and Access Management (IAM)" id="idm45302808218240"/><a data-type="indexterm" data-primary="IAM (Identity and Access Management)" id="idm45302808217568"/>resource-based to organization-level policies.
There are also more specialized offerings; for example, in the context of Amazon EKS,
you can define <a href="https://oreil.ly/yZH2Q">security groups for pods</a>.</p>
</dd>
<dt><a href="https://oreil.ly/D7O3F">Google Identity and Access Management (IAM)</a></dt>
<dd>
<p>This has a rich and powerful policy model, similar to Kubernetes.</p>
</dd>
<dt><a href="https://oreil.ly/c6N8J">Azure Policy</a></dt>
<dd>
<p>This allows<a data-type="indexterm" data-primary="Azure" data-secondary="Policy" id="idm45302808212448"/> stating business-level policies and they in addition offer Azure RBAC for
access control purposes.</p>
</dd>
<dt><a href="https://oreil.ly/rUBSA">CrossGuard</a></dt>
<dd>
<p>By Pulumi, this is
  described <a data-type="indexterm" data-primary="CrossGuard" id="idm45302808209520"/>as “Policy as Code,” offering to define and enforce guardrails across
  cloud<a data-type="indexterm" data-primary="policies" data-secondary="management" data-tertiary="tools" data-startref="pol_man_tools" id="idm45302808208688"/> providers.</p>
</dd>
</dl>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45302808206816">
<h1>Conclusion</h1>

<p>Policy is essential to securing your clusters, and thought is required to map
your teams to their groups and roles. Roles that allow transitive access to
other service accounts may offer a path to privilege escalation. Also, don’t
forget to threat model the impact of credential compromise, and always use 2FA for humans.
Last but not least, as usual, automating as much as possible, including policy
testing and validation, pays off in the long run.</p>

<p>The wonderful Kubernetes and wider CNCF ecosystem has already provided a wealth
of open source solutions, so in our experience it’s usually not a problem to
find a tool but to figure out which out of the, say, ten tools available is
the best and will still be supported when the Captain’s grandchildren have taken over.</p>

<p>With this we’ve reached the end of the policy chapter and will now turn our
attention to the question of what happens if the Captain somehow, despite of all
our controls put in place, manages to break in. In other words, we discuss
intrusion detection systems (IDS) to detect unexpected activity. Arrrrrrr!</p>
</div></section>







</div></section></div></body></html>