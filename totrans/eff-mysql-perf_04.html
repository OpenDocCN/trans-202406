<html><head></head><body><section data-pdf-bookmark="Chapter 4. Access Patterns" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch04">&#13;
<h1><span class="label">Chapter 4. </span>Access Patterns</h1>&#13;
&#13;
&#13;
<p><em>Access patterns</em> describe how an application uses MySQL to access data.&#13;
Changing access patterns has a powerful effect on MySQL performance, but it usually requires a greater level of effort than other optimizations.&#13;
That’s why it’s the last leg of the journey mapped out in <a data-type="xref" href="ch01.html#query-optimization">“Improving Query Response Time”</a>: first optimize queries, indexes, and data—then optimize access patterns.&#13;
Before we begin, let’s think again about the rocks <a data-primary="rocks" data-type="indexterm" id="idm45829112062288"/>from <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>.</p>&#13;
&#13;
<p>Suppose you have a truck, which is analogous to MySQL.&#13;
If used efficiently, the truck makes moving any pile of rocks uphill easy.&#13;
But if used inefficiently, the truck provides little value, and it might even make the job take longer than necessary.&#13;
For example, you could use the truck to haul the <a data-primary="cobbles" data-type="indexterm" id="idm45829112059920"/>cobbles <em>one by one</em> up the hill.&#13;
That’s easy for you (and the truck), but it’s terribly inefficient and time-consuming.&#13;
A truck is only as useful as the person who uses it.&#13;
Likewise, MySQL is only as useful as the application that uses it.</p>&#13;
&#13;
<p>Sometimes, an engineer puzzles over why MySQL isn’t running faster.&#13;
For example, when MySQL is executing 5,000 QPS and the engineer wonders why it’s not executing 9,000 QPS instead.&#13;
Or when MySQL is using 50% CPU and the engineer wonders why it’s not using 90% CPU instead.&#13;
The engineer is unlikely to find an answer because they’re focused on the effect (MySQL) rather than the cause: the application.&#13;
Metrics like QPS and CPU usage say very little—almost nothing—about MySQL; they only reflect how the application uses MySQL.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>MySQL is only as fast and efficient as the application that uses it.</p>&#13;
</div>&#13;
&#13;
<p>An application can outgrow the capacity of a <em>single</em> MySQL instance, but again: that says more about the application than MySQL because there are innumerable large, high-performance applications using a single MySQL instance.&#13;
Without a doubt, MySQL is fast enough for the application.&#13;
The real question is: does the application use MySQL efficiently?&#13;
After many years with MySQL, hundreds of different applications, and thousands of different MySQL instances, I assure you: MySQL performance is limited by the application, not the other way around.</p>&#13;
&#13;
<p>This chapter centers on data access patterns that determine how you can change the application to use MySQL efficiently.&#13;
There are six major sections.&#13;
The first clarifies what MySQL does apart from the application and why it’s important.&#13;
The second proves that database performance does not scale linearly; instead, there is a limit past which performance destabilizes.&#13;
The third contemplates why a Ferrari is faster than a Toyota even though both car brands work roughly the same.&#13;
The answer explains why some applications excel with MySQL while others can’t get out of first gear.&#13;
The fourth enumerates data access patterns.&#13;
The fifth presents several application changes to improve or modify data access patterns.&#13;
The sixth revisits an old friend: better, faster hardware.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="MySQL Does Nothing" data-type="sect1"><div class="sect1" id="mysql-does-nothing">&#13;
<h1>MySQL Does Nothing</h1>&#13;
&#13;
<p>When the application is idle, MySQL is idle.&#13;
When the application is busy executing queries, MySQL is busy executing those queries.&#13;
MySQL has several background tasks (like <a data-type="xref" href="ch06.html#metrics-page-flushing">“Page flushing”</a>), but they are only busy reading and writing data for those queries.&#13;
In fact, background tasks increase performance by allowing foreground tasks—executing queries—to defer or avoid slow operations.&#13;
Therefore, if MySQL is running slowly and there are no external issues, the cause can only be what drives MySQL: the application.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>QPS is directly and only attributable to the application.&#13;
Without the application, QPS is zero.</p>&#13;
</div>&#13;
&#13;
<p>Some data stores have <em>ghosts in the machine</em>: internal <a data-primary="ghosts in the machine" data-type="indexterm" id="idm45829112048336"/>processes that can run at any time and degrade performance if they run at the worst time: when the data store is busy executing queries.&#13;
(Compaction and vacuuming are two examples—MySQL has neither.)&#13;
MySQL has no ghosts in the machine—unless the application is executing queries that you don’t know about.&#13;
Knowing this helps you avoid looking for nonexistent causes and, more importantly, focus on what MySQL is busy doing: executing queries.&#13;
From <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, you know how to see that: <a data-type="xref" href="ch01.html#query-profile">“Query profile”</a>.&#13;
A query profile shows more than just slow queries, it shows what MySQL is busy doing.</p>&#13;
&#13;
<p>Queries affect other queries.&#13;
The general term for this is <em>query contention</em>: when queries compete and wait for shared resources.&#13;
There are specific types of contention: row lock contention, CPU contention, and so forth.&#13;
Query contention can make it seem like MySQL is busy doing other things, but don’t be misled: MySQL is only busy executing application queries.</p>&#13;
&#13;
<p>It’s nearly impossible to see or prove query contention because MySQL reports only one type of contention: row lock contention.&#13;
(Even row lock contention is difficult to see precisely because row locking is complex.)&#13;
Moreover, contention is fleeting—almost imperceptible—because the problem is intrinsic to high QPS (where <em>high</em> is relative to the application).&#13;
Query contention is like a traffic jam: it requires a lot of cars on the road.&#13;
Although it’s nearly impossible to see or prove, you need to be aware of it because it might explain inexplicably slow queries.</p>&#13;
&#13;
<p>Query contention plays a major role when performance is pushed to the limit.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performance Destabilizes at the Limit" data-type="sect1"><div class="sect1" id="perf-at-the-limit">&#13;
<h1>Performance Destabilizes at the Limit</h1>&#13;
&#13;
<p>At the end of <a data-type="xref" href="ch01.html#mysql-go-faster">“MySQL: Go Faster”</a>, <a data-primary="access patterns" data-secondary="performance destabilization" data-type="indexterm" id="performance-destabilization"/>I said that MySQL can easily push most modern hardware to its limits.&#13;
That’s true, but the limit might surprise you.&#13;
<a data-type="xref" href="#sys-cap-db-1">Figure 4-1</a> illustrates what engineers expect: as load increases, database performance increases until it utilizes 100% of <em>system capacity</em>—throughput of the hardware and operating system—then performance remains steady.&#13;
This is called <em>linear scaling</em> <a data-primary="linear scaling" data-type="indexterm" id="idm45829112035520"/>(or <em>linear scalability</em>), and it’s a myth.</p>&#13;
&#13;
<figure><div class="figure" id="sys-cap-db-1">&#13;
<img alt="emsp 0401" src="assets/emsp_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>Expected database performance (linear scalability)</h6>&#13;
</div></figure>&#13;
&#13;
<p>Linear scaling is the dream of every DBA and engineer, but it cannot happen.&#13;
Instead, <a data-type="xref" href="#sys-cap-db-2">Figure 4-2</a> illustrates the reality of database performance with respect to load and system capacity.</p>&#13;
&#13;
<figure><div class="figure" id="sys-cap-db-2">&#13;
<img alt="emsp 0402" src="assets/emsp_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Real database performance</h6>&#13;
</div></figure>&#13;
&#13;
<p>Database performance increases with load only to a limit that is less than 100% of system capacity.&#13;
Realistically, the limit of database performance is 80% to 95% of system capacity.&#13;
When load increases past the limit, database performance <em>destabilizes</em>: throughput, response time, and other metrics fluctuate markedly—sometimes wildly—from their normal value.&#13;
At best, the result is decreased performance for some (or most) queries; at worst, it causes an outage.</p>&#13;
&#13;
<p><a data-type="xref" href="#usl">Equation 4-1</a> shows the <em>Universal Scalability Law</em> <a data-primary="Universal Scalability Law (USL)" data-type="indexterm" id="Universal-Scalability-Law-ch4"/><a data-primary="throughput" data-type="indexterm" id="throughput1"/><a data-primary="load" data-type="indexterm" id="load"/><a data-primary="concurrency" data-type="indexterm" id="idm45829112023040"/><a data-primary="contention" data-type="indexterm" id="contention"/><a data-primary="coherency" data-type="indexterm" id="coherency"/>articulated by Neil Gunther: an equation that models the scalability of hardware and software systems.</p>&#13;
<div data-type="equation" id="usl">&#13;
<h5><span class="label">Equation 4-1. </span><span class="label">Equation 4-1. </span>Universal Scalability Law</h5>&#13;
<math>&#13;
  <mrow>&#13;
    <mi>X</mi>&#13;
    <mrow>&#13;
      <mo>(</mo>&#13;
      <mi>N</mi>&#13;
      <mo>)</mo>&#13;
    </mrow>&#13;
    <mo>=</mo>&#13;
    <mfrac><mrow><mi>γ</mi><mi>N</mi></mrow> <mrow><mn>1</mn><mo>+</mo><mi>α</mi><mo>(</mo><mi>N</mi><mo>-</mo><mn>1</mn><mo>)</mo><mo>+</mo><mi>β</mi><mi>N</mi><mo>(</mo><mi>N</mi><mo>-</mo><mn>1</mn><mo>)</mo></mrow></mfrac>&#13;
  </mrow>&#13;
</math>&#13;
</div>&#13;
&#13;
<p><a data-type="xref" href="#usl-coef">Table 4-1</a> outlines what each term in the Universal Scalability Law equation <span class="keep-together">represents</span>.</p>&#13;
<table id="usl-coef">&#13;
<caption><span class="label">Table 4-1. </span>Universal Scalability Law terms</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Term</th>&#13;
<th>Represents</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>X</code></p></td>&#13;
<td><p>Throughput</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>N</code></p></td>&#13;
<td><p>Load: concurrent requests, running processes, CPU cores, nodes in a distributed system, and so on</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>γ</code></p></td>&#13;
<td><p>Concurrency (ideal parallelism)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>α</code></p></td>&#13;
<td><p>Contention: waiting for shared resources</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>β</code></p></td>&#13;
<td><p>Coherency: coordinating shared resources</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div class="pagebreak-before less_space" data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A deep dive into the Universal Scalability Law is beyond the scope of this book, so I limit the explanation to the current topic: the limit of database performance.&#13;
To learn more, read <a href="https://oreil.ly/WZEd8"><em>Guerrilla Capacity Planning</em></a> by Neil Gunther.</p>&#13;
</div>&#13;
&#13;
<p>Throughput is a function of load: <code>X(N)</code>.&#13;
Concurrency (<code>γ</code>) helps throughput increase as load (<code>N</code>) increases.&#13;
But contention (<code>α</code>) and coherency (<code>β</code>) reduce throughput as load increases.&#13;
This precludes linear scalability and limits database performance.</p>&#13;
&#13;
<p>Worse than limiting performance, coherency causes <em>retrograde performance</em>: decreasing <a data-primary="retrograde performance" data-type="indexterm" id="idm45829111987904"/>performance at high load.&#13;
The term <em>retrograde</em> is an understatement.&#13;
It suggests that MySQL simply reverts to less throughput when it cannot handle the load, but the reality is worse than that.&#13;
I prefer the terms <em>instability</em> and <em>destabilize</em> because they convey the reality: the system is breaking down, not just running more slowly.</p>&#13;
&#13;
<p>The Universal Scalability Law models real-world MySQL performance surprisingly well.<sup><a data-type="noteref" href="ch04.html#idm45829111984992" id="idm45829111984992-marker">1</a></sup>&#13;
But as a model, it only describes and predicts the scalability of a workload; it does not say anything about how or why the workload scales (or fails to scale).&#13;
The USL is primarily used by experts who measure and fit data to the model to determine the parameters (<code>γ</code>, <code>α</code>, and <code>β</code>), then toil heroically to reduce them.&#13;
Everyone else just watches graphs (<a data-type="xref" href="ch06.html#ch06">Chapter 6</a> covers MySQL metrics) and waits until MySQL performance destabilizes—that’s the limit.</p>&#13;
&#13;
<p><a data-type="xref" href="#db-perf-limit-charts">Figure 4-3</a> shows three charts from a real outage when the application pushed MySQL past the limit.<a data-primary="Universal Scalability Law (USL)" data-startref="Universal-Scalability-Law-ch4" data-type="indexterm" id="idm45829111979024"/><a data-primary="throughput" data-startref="throughput1" data-type="indexterm" id="idm45829111978000"/><a data-primary="load" data-startref="load" data-type="indexterm" id="idm45829111977056"/><a data-primary="contention" data-startref="contention" data-type="indexterm" id="idm45829111976112"/><a data-primary="coherency" data-startref="coherency" data-type="indexterm" id="idm45829111975168"/></p>&#13;
&#13;
<p>The outage had three periods:</p>&#13;
<dl>&#13;
<dt><em>The Rise</em> (6 a.m. to 9 a.m.)</dt>&#13;
<dd>&#13;
<p>  The application was stable at the beginning of the rise, but its developers were beginning to worry because the metrics shown were rising slowly but steadily.&#13;
In the past, the application had outages that began with steadily rising metrics.&#13;
In response, the application developers increased transaction throughput to cope with the rising demand.&#13;
(The application is able to throttle transaction throughput; this isn’t a feature of MySQL.)&#13;
The rise and the response repeated until it no longer worked: MySQL had reached the limit.</p>&#13;
&#13;
<figure><div class="figure" id="db-perf-limit-charts">&#13;
<img alt="emsp 0403" src="assets/emsp_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>Database performance past the limit</h6>&#13;
</div></figure>&#13;
</dd>&#13;
<dt><em>The Limit</em> (9 a.m. to noon)</dt>&#13;
<dd>&#13;
<p>  The application was completely unstable and effectively offline during the limit.&#13;
Although CPU usage and QPS were high and steady, threads running told a different story.&#13;
The whipsaw pattern of threads running shown in <a data-type="xref" href="#db-perf-limit-charts">Figure 4-3</a> was a telltale sign that MySQL had destabilized.&#13;
Since one query requires one thread to run, the big swings in threads running indicated that queries were not flowing smoothly through the system.&#13;
Instead, queries were hammering MySQL in uneven, disconcerted strikes.</p>&#13;
&#13;
<p>High and steady CPU usage and QPS were misleading: steady is only good with a little variation, as seen before and after the limit.&#13;
Steady with no variation, as seen during the limit, is flatline.&#13;
To understand why, here’s a strange but effective analogy.&#13;
Imagine an orchestra.&#13;
When the orchestra is playing correctly, there are variations in all aspects of the music.&#13;
In fact, those variations <em>are</em> the music: rhythm, tempo, pitch, tone, melody, dynamics, and so forth.&#13;
A flatline metric is analogous to a deranged clarinetist playing a single, continuous note <em>fortissimo</em>: steady, but not music.</p>&#13;
&#13;
<p>During the limit, application developers kept trying to increase transaction throughput, but it didn’t work.&#13;
MySQL would not use the last 5% of CPU, QPS would not increase, and threads running would not stabilize.&#13;
From the USL (<a data-type="xref" href="#usl">Equation 4-1</a>), you know why: contention <a data-primary="contention" data-type="indexterm" id="idm45829111962784"/>and coherency<a data-primary="coherency" data-type="indexterm" id="idm45829111961984"/>.&#13;
As load increased (<code>N</code>), transaction throughput (<code>X</code>) increased, but so did the limiting effects of contention (<code>α</code>) and coherency (<code>β</code>) until MySQL reached the limit.</p>&#13;
</dd>&#13;
<dt><em>The Fix</em> (noon to 3 p.m.)</dt>&#13;
<dd>&#13;
<p>  Since increasing transaction throughput was its own demise, the fix was to <em>reduce</em> transaction throughput.&#13;
That seems counterintuitive, but the math doesn’t lie.&#13;
At noon, application developers reduced transaction throughput, and the results are clear in the charts: CPU usage dropped to 50%, QPS returned to a steady variation (and even increased a little), and threads running also returned to a steady variation (with a few spikes, which MySQL had spare capacity to absorb).</p>&#13;
&#13;
<p>To imagine how this works, consider another analogy.&#13;
Imagine a highway.&#13;
When there are many cars on the road, they all slow down (hopefully) because humans need time to think and react to others cars, especially at highway speeds.&#13;
When there are too many cars on the road, they cause a traffic jam.&#13;
The only solution (apart from adding more lanes) is to reduce the number of cars on the highway: fewer cars can drive faster.&#13;
Reducing transaction throughput is analogous to reducing the number of cars on the highway, which lets the remaining cars go faster and traffic flow smoothly.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>This example nicely models the limit of database performance according to the Universal Scalability Law (<a data-type="xref" href="#usl">Equation 4-1</a>), but it’s also an exceptional case because the application was able to push MySQL and the hardware to the limit.&#13;
More typically, high load destabilizes the application, and that prevents it from increasing load on MySQL.&#13;
In other words: the application fails before it can push MySQL to the limit.&#13;
But in this example, the application didn’t fail, it kept scaling up until it pushed MySQL to the limit.</p>&#13;
&#13;
<p class="pagebreak-before">Two more points about MySQL performance at the limit before we turn our attention to the application:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The limit is difficult to reach unless the hardware is blatantly insufficient.&#13;
As mentioned in <a data-type="xref" href="ch02.html#better-faster-hardware">“Better, Faster Hardware!”</a>, this is one of two exceptions for which you should scale up to reasonable hardware.&#13;
It’s also difficult for an application to fully and <em>simultaneously</em> utilize all hardware—CPU, memory, and storage.&#13;
An application is most likely to incur a bottleneck in one piece of hardware long before it can fully and simultaneously utilize all hardware.&#13;
When this happens, the application has not reached the limit of database performance, only the limit of that one piece of hardware.</p>&#13;
</li>&#13;
<li>&#13;
<p>When high load causes MySQL to respond slowly, this does <em>not</em> mean the limit has been reached.&#13;
The reason is simple: <code>γ</code>.&#13;
Gamma (<code>γ</code>) represents concurrency or ideal parallelism.&#13;
Recall from the Universal Scalability Law equation (<a data-type="xref" href="#usl">Equation 4-1</a>) that gamma is in the numerator.<sup><a data-type="noteref" href="ch04.html#idm45829111946752" id="idm45829111946752-marker">2</a></sup>&#13;
Slow database performance does <em>not</em> mean the limit has been reached because increasing concurrency <a data-primary="coherency" data-type="indexterm" id="idm45829111943920"/><a data-primary="concurrency" data-type="indexterm" id="idm45829111943168"/>(<code>γ</code>) raises the limit.&#13;
Decreasing contention <a data-primary="contention" data-type="indexterm" id="idm45829111941888"/>(<code>α</code>) also raises the limit.&#13;
(Coherency [<code>β</code>] is out of our control: it’s inherent to MySQL and the operating system, but it’s usually not a problem.)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The second point leads to the question: how do we increase concurrency, or decrease contention, or both?&#13;
That seems like a critically important question, but it’s not: it’s misleading because the North Star of MySQL performance is query response time.&#13;
The values of concurrency (<code>γ</code>) and contention (<code>α</code>) are not directly measurable.&#13;
They are determined by fitting throughput and load measurements to the model.&#13;
Experts use the Universal Scalability Law to understand system capacity, not to improve performance.&#13;
And this section has used it to prove that performance destabilizes at the limit.<a data-primary="access patterns" data-secondary="performance destabilization" data-startref="performance-destabilization" data-type="indexterm" id="idm45829111938208"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Toyota and Ferrari" data-type="sect1"><div class="sect1" id="toyota-and-ferrari">&#13;
<h1>Toyota and Ferrari</h1>&#13;
&#13;
<p>Some <a data-primary="access patterns" data-secondary="application design" data-type="indexterm" id="application-design"/>applications achieve incredible MySQL performance while others struggle with low throughput.&#13;
Some applications can fully utilize the hardware—up to the limit—while others barely warm the CPUs.&#13;
Some applications don’t have any performance problems while others continually struggle with slow queries.&#13;
It’s a sweeping generalization, but I’m going to claim that every engineer wants their application be on the left side of <em>while</em>: incredible performance, fully utilizing the hardware, and no problems.&#13;
The difference between applications on the left of <em>while</em> versus those on the right is understood by contemplating why a Ferrari is faster than a Toyota.</p>&#13;
&#13;
<p>Both car brands use roughly the same parts and design, but the top speed of a Toyota is generally 130 MPH, whereas the top speed of a Ferrari is 200 MPH.<sup><a data-type="noteref" href="ch04.html#idm45829111931920" id="idm45829111931920-marker">3</a></sup>&#13;
A Ferrari does not have special parts that make it 70 MPH faster than a Toyota.&#13;
So why is a Ferrari so much faster than a Toyota?&#13;
The answer is the difference in engineering <em>design</em> and <em>details</em>.</p>&#13;
&#13;
<p>A Toyota is not designed for high speed.&#13;
Achieving high speed (like high performance) requires careful attention to many details.&#13;
For a car, those details include:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Engine size, configuration, and timing</p>&#13;
</li>&#13;
<li>&#13;
<p>Transmission gear ratios, shift points, and timing</p>&#13;
</li>&#13;
<li>&#13;
<p>Tire size, traction, and rotational force</p>&#13;
</li>&#13;
<li>&#13;
<p>Steering, suspension, and braking</p>&#13;
</li>&#13;
<li>&#13;
<p>Aerodynamics</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Both car brands design and engineer for those details, but the exacting level of detail in a Ferrari explains why it achieves greater performance.&#13;
You can see this in one of those details: aerodynamics.&#13;
The unique exterior design of a Ferrari is flamboyant but also functional: it lowers the drag coefficient, which increases efficiency.</p>&#13;
&#13;
<p>High performance, like high speed, is not accomplished accidentally or by brute force.&#13;
It is the result of meticulous engineering with the goal of high performance.&#13;
A Ferrari is faster than a Toyota because it’s designed and engineered in every detail to be faster.</p>&#13;
&#13;
<p>Is your application designed and engineered in every detail for maximum MySQL performance?&#13;
If yes, then I suppose you can skip the rest of this chapter.&#13;
If not, which is the usual answer, then the next section addresses the fundamental technical differences that separate Toyota-like applications from Ferrari-like applications: data access patterns.<a data-primary="access patterns" data-secondary="application design" data-startref="application-design" data-type="indexterm" id="idm45829111922368"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Access Patterns" data-type="sect1"><div class="sect1" id="access-patterns">&#13;
<h1>Data Access Patterns</h1>&#13;
&#13;
<p><em>Data access patterns</em> <a data-primary="access patterns" data-type="indexterm" id="access-patterns_index1"/>describe how an application uses MySQL to access data.</p>&#13;
&#13;
<p>The term <em>data access patterns</em> (or <em>access patterns</em> for short) is commonly used but rarely explained.&#13;
Let’s change that by clarifying three details about access patterns:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>It’s so common to discuss access patterns in the plural that they begin to blur together.&#13;
But it’s important to realize that they are not an undifferentiated blob.&#13;
An application has many access patterns.&#13;
For convenience, they’re discussed in the plural.&#13;
But in practice, you modify access patterns individually.</p>&#13;
</li>&#13;
<li>&#13;
<p>An access pattern ultimately refers to a query, and you change queries (and the application) to change access patterns, but queries are <em>not</em> the focus.&#13;
In <a href="https://golang.org">Go programming language terms</a>, an access pattern is an interface and a query is an implementation.&#13;
Focus on the interface, not the implementation.&#13;
This makes it possible to envision (and possibly apply) access patterns to different data stores.&#13;
For example, certain access patterns executed on MySQL are better suited for a key-value data store, but that’s difficult to see by focusing on SQL queries that bear no resemblance to key-value queries.&#13;
In this book, I discuss modifying access patterns, but in practice you modify queries (and the application).</p>&#13;
</li>&#13;
<li>&#13;
<p>An access pattern comprises a name and a list of technical traits.&#13;
The name is used to identify and communicate the access pattern with other engineers.&#13;
(Access patterns do not have intrinsic names.)&#13;
Choose a name that’s succinct and meaningful.&#13;
The list of technical traits depends on and varies by data store.&#13;
MySQL data access, for example, is quite different than Redis data access.&#13;
This section enumerates and explains nine traits for MySQL data access.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In theory, application developers should identify every individual access pattern, but let’s be honest: that is very tedious.&#13;
(I’ve never seen it done, and it might not even be feasible if the application changes quickly.)&#13;
Nevertheless, that is the goal.&#13;
Here are three reasonable and achievable approaches toward that goal:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Brainstorm with your team to identify the most obvious and common access patterns.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use the query profile (see <a data-type="xref" href="ch01.html#query-profile">“Query profile”</a>) to identify the top, slowest access patterns.</p>&#13;
</li>&#13;
<li>&#13;
<p>Peruse the code for lesser-known (or forgotten) access patterns.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>At the very least, you need to follow the first or second approach one time to accomplish the goal of this chapter: indirect query optimization by changing access patterns.</p>&#13;
&#13;
<p>Once you have identified (and named) an access pattern, ascertain the value or answer to each of the following nine traits.&#13;
Not knowing the value or answer to a trait is a great opportunity to learn and possibly improve part of the application.&#13;
Don’t leave a trait unknown; find or figure out the value or answer.</p>&#13;
&#13;
<p>Before explaining each of the nine traits, there’s one more question to settle: how do you use access patterns?&#13;
Access patterns are pure knowledge, and that knowledge forms a bridge between the previous section and the next section.&#13;
The previous section, <a data-type="xref" href="#toyota-and-ferrari">“Toyota and Ferrari”</a>, makes the point that high-performance MySQL requires a high-performance application.&#13;
The next section, <a data-type="xref" href="#app-changes">“Application Changes”</a>, presents common application changes that help re-engineer the application for high performance with respect to the database.&#13;
Access patterns help decide (and sometimes dictate) how to re-engineer the application from a Toyota to a Ferrari.</p>&#13;
&#13;
<p>Without further ado, let’s examine nine traits of data access patterns for MySQL.<a data-primary="access patterns" data-startref="access-patterns_index1" data-type="indexterm" id="idm45829111901072"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Read/Write" data-type="sect2"><div class="sect2" id="ap-read-write">&#13;
<h2>Read/Write</h2>&#13;
&#13;
<p>Does the access read or write data?<a data-primary="access patterns" data-secondary="read/write" data-type="indexterm" id="idm45829111898112"/><a data-primary="read/write" data-type="indexterm" id="idm45829111897136"/></p>&#13;
&#13;
<p>Read access is clear: <code>SELECT</code>.&#13;
Write is less clear when you consider the fine details.&#13;
For example, <code>INSERT</code> is write access, but <code>INSERT</code>…<code>SELECT</code> is read and write access.&#13;
Likewise, <code>UPDATE</code> and <code>DELETE</code> should use a <code>WHERE</code> clause, which makes them read and write access, too.&#13;
For simplicity: <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> are always considered write access.</p>&#13;
&#13;
<p>Internally, reads and writes are not equal: they have different technical impacts and invoke different internal parts of MySQL.&#13;
An <code>INSERT</code> and a <code>DELETE</code>, for example, are different writes under the hood—not simply because the former adds and the latter removes.&#13;
For simplicity again: all reads are equal and all writes are equal.</p>&#13;
&#13;
<p>The <em>read/write</em> trait is one of the most fundamental and ubiquitous because scaling reads and writes requires different application changes.&#13;
Scaling reads is usually accomplished by offloading reads, which I cover later in <a data-type="xref" href="#offload-reads">“Offload Reads”</a>.&#13;
Scaling write is more difficult, but enqueuing writes is one technique (see <a data-type="xref" href="#enqueue-writes">“Enqueue Writes”</a>), and <a data-type="xref" href="ch05.html#ch05">Chapter 5</a> covers the ultimate solution: sharding.</p>&#13;
&#13;
<p>Although this trait is quite simple, it’s important because knowing if an application is read-heavy or write-heavy quickly focuses your attention on relevant application changes.&#13;
Using a cache, for example, is not relevant for a write-heavy application.&#13;
Furthermore, other data stores are optimized for reads or writes, and there is a write-optimized storage engine for MySQL: <a href="https://myrocks.io">MyRocks</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Throughput" data-type="sect2"><div class="sect2" id="ap-throughput">&#13;
<h2>Throughput</h2>&#13;
&#13;
<p>What <a data-primary="access patterns" data-secondary="throughput" data-type="indexterm" id="idm45829111882752"/><a data-primary="throughput" data-type="indexterm" id="idm45829111881744"/>is the throughput (in QPS) and variation of the data access?</p>&#13;
&#13;
<p>First of all, throughput is <em>not</em> performance.&#13;
Low throughput access—even just <span class="keep-together">1 QPS—</span>can wreak havoc.&#13;
You can probably imagine how; in case not, here’s an example: a <code>SELECT</code>…<code>FOR UPDATE</code> statement that does a table scan and locks every row.&#13;
It’s rare to find access that terrible, but it proves the point: throughput is not performance.</p>&#13;
&#13;
<p>Terrible access notwithstanding, very high QPS (where <em>high</em> is relative to the application) is usually an issue to abate for all the reasons eloquently stated in <a data-type="xref" href="ch03.html#less-qps-is-better">“Less QPS Is Better”</a>.&#13;
For example, if the application executes stock trades, it probably has a huge burst of read and write access at 9:30 a.m. Eastern Time when the American stock exchanges open.&#13;
That level of throughput conjures entirely different considerations than a steady 500 QPS.</p>&#13;
&#13;
<p><em>Variation</em>—how <a data-primary="variation (QPS)" data-type="indexterm" id="idm45829111875216"/>QPS increases and decreases—is equally important.&#13;
The previous paragraph mentioned <em>burst</em> and <em>steady</em>; another type of variation is <em>cyclical</em>: QPS increases and decreases over a period of time.&#13;
A common cyclical pattern is higher QPS during business hours—9 a.m. to 5 p.m. Eastern Time, for example—and lower QPS in the middle of the night.&#13;
A common problem is that high QPS during business hours prevents developers from making schema changes (<code>ALTER TABLE</code>) or backfilling data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Age" data-type="sect2"><div class="sect2" id="ap-data-age">&#13;
<h2>Data Age</h2>&#13;
&#13;
<p>What <a data-primary="access patterns" data-secondary="data age" data-type="indexterm" id="data-age"/><a data-primary="data age" data-type="indexterm" id="data_age"/>is the age of the data accessed?</p>&#13;
&#13;
<p><em>Age</em> is relative to access order, not time.&#13;
If an application inserts one million rows in 10 minutes, the first row is the oldest because it was the last row accessed, not because it’s 10 minutes old.&#13;
If the application updates the first row, then it becomes the newest because it was the most recent row accessed.&#13;
And if the application never accesses the first row again, but it continues to access other rows, then the first row becomes older and older.</p>&#13;
&#13;
<p>This trait is important because it affects the working set.&#13;
Recall from  <a data-type="xref" href="ch03.html#working-set-size">“Working set size”</a> that the working set is frequently used index values and the primary key rows to which they refer—which is a long way of saying <em>frequently accessed data</em>⁠—and it’s usually a small percentage of the table size.&#13;
MySQL keeps as much data in memory as possible, and data age affects whether or not the data in memory is part of the working set.&#13;
It usually is because MySQL is exceptionally good at keeping the working set in memory thanks to a mélange of algorithms and data structures.&#13;
<a data-type="xref" href="#data-aging">Figure 4-4</a> is a highly simplified illustration of the process.</p>&#13;
&#13;
<p>The rectangle in <a data-type="xref" href="#data-aging">Figure 4-4</a> represents all data.&#13;
The working set is a small amount of data: from the dashed line to the top.&#13;
And memory is smaller than both: from the solid line to the top.&#13;
In MySQL lingo, data is <em>made young</em> when accessed.&#13;
And when data is not accessed, it becomes old and is eventually evicted from memory.</p>&#13;
&#13;
<figure><div class="figure" id="data-aging">&#13;
<img alt="emsp 0404" src="assets/emsp_0404.png"/>&#13;
<h6><span class="label">Figure 4-4. </span>Data aging</h6>&#13;
</div></figure>&#13;
&#13;
<p>Since accessing data keeps it young and in memory, the working set stays in memory because it’s frequently accessed.&#13;
This is how MySQL is very fast with a little memory and a lot of data.</p>&#13;
&#13;
<p>Frequently accessing old data is problematic in more than one way.&#13;
To explain why, I must delve into technical details beyond the scope of this section, but I clarify later in <a data-type="xref" href="ch06.html#metrics-innodb">“InnoDB”</a>.&#13;
Data is loaded into <em>free pages</em> (in memory): pages that don’t already contain data.&#13;
(A <em>page</em> is a 16 KB unit of logical storage inside InnoDB.)&#13;
MySQL uses all available memory, but it also keeps a certain number of free pages.&#13;
When there are free pages, which is normal, the problem is only that reading data from storage is slow.&#13;
When there are zero free pages, which is abnormal, the problem worsens threefold.&#13;
First, MySQL must evict old pages, which it tracks in a least recently used (LRU) list.&#13;
Second, if an old page is dirty (has data changes not persisted to disk) MySQL must flush (persist) it before it can evict it, and flushing is slow.&#13;
Third, the original problem remains: reading data from storage is slow.&#13;
Long story short: frequently dredging up old data is problematic for performance.</p>&#13;
&#13;
<p>Occasionally accessing old data is not a problem because MySQL is clever: the algorithms driving the process in <a data-type="xref" href="#data-aging">Figure 4-4</a> prevent occasional access of old data from interfering with new (young) data.&#13;
Therefore, take data age and throughput into consideration together: old and slow access is probably harmless, but old and fast is bound to cause trouble.</p>&#13;
&#13;
<p>Data age is nearly impossible to measure.<sup><a data-type="noteref" href="ch04.html#idm45829111854048" id="idm45829111854048-marker">4</a></sup>&#13;
Fortunately, you only need to estimate the age of the data accessed, which you can do with your understanding of the application, the data, and the access pattern.&#13;
If, for example, the application stores financial transactions, you know that access is mostly limited to new data: the last 90 days of transactions.&#13;
Accessing data older than 90 days should be infrequent because transactions have settled and become immutable.&#13;
By contrast, another part of the same application that manages user profiles might frequently access old data if the percentage of active users is high.&#13;
Remember: old data is relative to access, not time.&#13;
The profile of a user who last logged in a week ago isn’t necessarily old by time, but their profile data is relatively old because millions of other profile data have since been accessed, which means their profile data was evicted from memory.</p>&#13;
&#13;
<p>Knowing this trait is a prerequisite for understanding <a data-type="xref" href="#partition-data">“Partition Data”</a> and sharding in <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>.<a data-primary="access patterns" data-secondary="data age" data-startref="data-age" data-type="indexterm" id="idm45829111850192"/><a data-primary="data age" data-startref="data_age" data-type="indexterm" id="idm45829111848944"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Data Model" data-type="sect2"><div class="sect2" id="ap-data-model">&#13;
<h2>Data Model</h2>&#13;
&#13;
<p>What data model does the access exhibit?<a data-primary="access patterns" data-secondary="data model" data-type="indexterm" id="idm45829111846192"/><a data-primary="data model" data-type="indexterm" id="idm45829111845216"/></p>&#13;
&#13;
<p>Although MySQL is a relational data store, it’s commonly used with other data models: key-value, document, complex analytics, graph, and so forth.&#13;
You should be keenly aware of nonrelational access because it’s not the best fit for MySQL; therefore, it cannot yield the best performance.&#13;
MySQL excels with other data models but only to a point.&#13;
For example, MySQL works well as a key-value data store, but <a href="https://rocksdb.org">RocksDB</a> is incomparably better because it’s a purpose-built key-value data store.</p>&#13;
&#13;
<p>The data model trait cannot be programmatically measured like other traits.&#13;
Instead, you need to determine which data model the access exhibits.&#13;
The verb <em>exhibits</em> is meaningful: the access might be relational only because MySQL was the only available data store when the access was created, but it <em>exhibits</em> another data model when you consider all data stores.&#13;
Access is often jammed into the data model of the available data stores.&#13;
But the best practice is the reverse: determine the ideal data model for the access, then use a data store built for that data model.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transaction Isolation" data-type="sect2"><div class="sect2" id="ap-trx-iso">&#13;
<h2>Transaction Isolation</h2>&#13;
&#13;
<p>What <a data-primary="access patterns" data-secondary="transaction isolation" data-type="indexterm" id="transaction-isolation_index1"/><a data-primary="transaction isolation" data-type="indexterm" id="transaction-isolation_index2"/>transaction isolation does the access require?</p>&#13;
&#13;
<p><em>Isolation</em> is one of four ACID <a data-primary="ACID (atomicity, consistency, isolation, and durability) properties" data-type="indexterm" id="idm45829111836064"/>properties: atomicity, consistency, isolation, and durability.&#13;
Since the default MySQL storage engine, InnoDB, is transactional, every query executes in a transaction by default—even a single <code>SELECT</code> statement.&#13;
(<a data-type="xref" href="ch08.html#ch08">Chapter 8</a> examines transactions.)&#13;
Consequently, the access has isolation whether it needs it or not.&#13;
This trait clarifies whether isolation is required and if so, what level.</p>&#13;
&#13;
<p>When I ask engineers this question, the answer falls into one of three categories:</p>&#13;
<dl>&#13;
<dt>None</dt>&#13;
<dd>&#13;
<p>  No, the access does not require any isolation.&#13;
It would execute correctly on a nontransactional storage engine.&#13;
Isolation is just useless overhead, but it doesn’t cause any problems or noticeably impact performance.</p>&#13;
</dd>&#13;
<dt>Default</dt>&#13;
<dd>&#13;
<p>  Presumably, the access requires isolation, but it’s unknown or unclear which level is required.&#13;
The application works correctly with the default transaction isolation level for MySQL: <code>REPEATABLE READ</code>.&#13;
Careful thought would be required to determine if another isolation level—or no isolation—would work correctly.</p>&#13;
</dd>&#13;
<dt>Specific</dt>&#13;
<dd>&#13;
<p>  Yes, the access requires a specific isolation level because it’s part of a transaction that executes concurrently with other transactions that access the same data.&#13;
Without the specific isolation level, the access could see incorrect versions of the data, which would be a serious problem for the application.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In my experience, <em>Default</em> is the most common category, and that makes sense because the default transaction isolation level for MySQL, <code>REPEATABLE READ</code>, is correct for most cases.&#13;
But the answer to this trait should lead to <em>None</em> or <em>Specific</em>.&#13;
If the access does not require any isolation, then it might not require a transactional data store.&#13;
Else, if the access requires isolation, now you specifically know which isolation level and why.</p>&#13;
&#13;
<p>Other data stores have transactions—even data stores that are not fundamentally transactional.&#13;
For example, the document store <a href="https://www.mongodb.com">MongoDB</a> introduced multidocument ACID <a data-primary="ACID (atomicity, consistency, isolation, and durability) properties" data-type="indexterm" id="idm45829111823488"/>transactions in version 4.0.&#13;
Knowing which isolation level is required and why allows you to translate and move access from MySQL to another data store.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Transactions in other data stores can be very different than MySQL transactions, and transactions affect other aspects, like locking.<a data-primary="access patterns" data-secondary="transaction isolation" data-startref="transaction-isolation_index1" data-type="indexterm" id="idm45829111821312"/><a data-primary="transaction isolation" data-startref="transaction-isolation_index2" data-type="indexterm" id="idm45829111820000"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Read Consistency" data-type="sect2"><div class="sect2" id="ap-read-consistency">&#13;
<h2>Read Consistency</h2>&#13;
&#13;
<p>Does the read access require strong or eventual consistency?<a data-primary="access patterns" data-secondary="read consistency" data-type="indexterm" id="read-consistency_index1"/><a data-primary="read consistency" data-type="indexterm" id="read-consistency_index2"/></p>&#13;
&#13;
<p><em>Strong consistency</em> (or <em>strongly consistent reads</em>) means that a read returns the most current value.&#13;
Reads on the source MySQL instance (not replicas) are strongly consistent, but the transaction isolation level determines the <em>current</em> value.&#13;
A long-running transaction can read an old value, but it’s technically the current value with respect to the transaction isolation level.&#13;
<a data-type="xref" href="ch08.html#ch08">Chapter 8</a> delves into these details.&#13;
For now, remember that strong consistency is the default (and only option) on the source MySQL instance.&#13;
This is not true for all data stores.&#13;
<a href="https://oreil.ly/EDCme">Amazon DynamoDB</a>, for example, defaults to eventually consistent reads, and strongly consistent reads are optional, slower, and more expensive.</p>&#13;
&#13;
<p><em>Eventual consistency</em> <a data-primary="eventual consistency" data-type="indexterm" id="idm45829111810096"/>(or <em>eventually consistent reads</em>) means that a read might return an old value, but eventually it will return the current value.&#13;
Reads on MySQL replicas are eventually consistent because of <em>replication lag</em>: the delay between when data is written on the source and when it’s written (applied) on the replica.&#13;
The duration of <em>eventually</em> is roughly equal to replication lag, which should be less than a second.&#13;
Replicas used to serve read access are called <em>read replicas</em>.&#13;
(Not all replicas serve reads; some are only for high availability, or other purposes.)</p>&#13;
&#13;
<p>In the world of MySQL, it’s common for all access to use the source instance, which makes all reads strongly consistent by default.&#13;
But it’s also common for reads <em>not</em> to require strong consistency, especially when replication lag is subsecond.&#13;
When eventual consistency is acceptable, offloading reads (see <a data-type="xref" href="#offload-reads">“Offload Reads”</a>) becomes possible.<a data-primary="access patterns" data-secondary="read consistency" data-startref="read-consistency_index1" data-type="indexterm" id="idm45829111805152"/><a data-primary="read consistency" data-startref="read-consistency_index2" data-type="indexterm" id="idm45829111803904"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Concurrency" data-type="sect2"><div class="sect2" id="ap-concurrency">&#13;
<h2>Concurrency</h2>&#13;
&#13;
<p>Is the data accessed concurrently?<a data-primary="access patterns" data-secondary="concurrency" data-type="indexterm" id="idm45829111801136"/><a data-primary="concurrency" data-type="indexterm" id="concurrency2_index2"/></p>&#13;
&#13;
<p>Zero concurrency <a data-primary="zero concurrency" data-type="indexterm" id="idm45829111798832"/>means that the access does not read (or write) the same data at the same time.&#13;
If it reads (or writes) the same data at <em>different</em> times, that’s also zero concurrency.&#13;
For example, an access pattern that inserts unique rows has zero <span class="keep-together">concurrency</span>.</p>&#13;
&#13;
<p>High concurrency <a data-primary="high concurrency" data-type="indexterm" id="idm45829111796176"/>means that the access frequently reads (or writes) the same data at the same time.</p>&#13;
&#13;
<p>Concurrency indicates how important (or troublesome) row locking will be for write access.&#13;
Unsurprisingly, the higher the write concurrency on the same data, the greater the row lock contention.&#13;
Row lock contention is acceptable as long as the increased response time that it causes is also acceptable.&#13;
It becomes unacceptable when it causes lock wait timeouts, which is a query error that the application must handle and retry.&#13;
When this begins to happen, there are only two solutions: decrease concurrency (change the access pattern), or shard (see <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>) to scale out writes.</p>&#13;
&#13;
<p>Concurrency also indicates how applicable a cache might be for read access.&#13;
If the same data is read with high concurrency but infrequently changed, then it’s a good fit for a cache.&#13;
I discuss this in <a data-type="xref" href="#offload-reads">“Offload Reads”</a>.</p>&#13;
&#13;
<p>As addressed in <a data-type="xref" href="#ap-data-age">“Data Age”</a>, concurrency is nearly impossible to measure, but you only need to estimate concurrency, which you can do with your understanding of the application, the data, and the access pattern.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Row Access" data-type="sect2"><div class="sect2" id="ap-row-access">&#13;
<h2>Row Access</h2>&#13;
&#13;
<p>How are rows accessed?<a data-primary="access patterns" data-secondary="row access" data-type="indexterm" id="idm45829111788640"/><a data-primary="row access" data-type="indexterm" id="idm45829111787632"/> There are three types of row access:</p>&#13;
<dl>&#13;
<dt><em>Point access</em></dt>&#13;
<dd>&#13;
<p>A single row</p>&#13;
</dd>&#13;
<dt><em>Range access</em></dt>&#13;
<dd>&#13;
<p>Ordered rows between two values</p>&#13;
</dd>&#13;
<dt><em>Random access</em></dt>&#13;
<dd>&#13;
<p>Several rows in any order</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Using the English alphabet (<em>A</em> to <em>Z</em>), point access is any single character (<em>A</em>, for example); range access is any number of characters in order (<em>ABC</em>, or <em>AC</em> if <em>B</em> doesn’t exist); and random access is any number of random characters (<em>ASMR</em>).</p>&#13;
&#13;
<p>This trait seems simplistic, but it’s important for write access for two reasons:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Gap locking: range and random access writes that use nonunique indexes exacerbate row lock contention due to gap locks.&#13;
<a data-type="xref" href="ch08.html#row-locking">“Row Locking”</a> goes into detail.</p>&#13;
</li>&#13;
<li>&#13;
<p>Deadlocks: random access writes are a setup for <em>deadlocks</em>, which is when two transactions hold row locks that the other transaction needs.&#13;
MySQL detects and breaks deadlocks, but they kill performance (MySQL kills one transaction to break the deadlock) and they’re annoying.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><em>Row access</em> is also important when planning how to shard.&#13;
Effective sharding requires that access patterns use a single shard.&#13;
Point access works best with sharding: one row, one shard.&#13;
Range and random access work with sharding but require careful planning to avoid negating the benefits of sharding by accessing too many shards.&#13;
<a data-type="xref" href="ch05.html#ch05">Chapter 5</a> covers sharding.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Result Set" data-type="sect2"><div class="sect2" id="ap-result-set">&#13;
<h2>Result Set</h2>&#13;
&#13;
<p>Does <a data-primary="access patterns" data-secondary="result set" data-type="indexterm" id="result-set_index1"/><a data-primary="result set" data-type="indexterm" id="idm45829111768928"/>the access group, sort, or limit the result set?</p>&#13;
&#13;
<p>This trait is easy to answer: does the access have a <code>GROUP BY</code>, <code>ORDER BY</code>, or <code>LIMIT</code> clause?&#13;
Each of these clauses affects if and how the access might be changed or run on another data store.&#13;
<a data-type="xref" href="ch03.html#data-access">“Data Access”</a> covers several changes.&#13;
At the very least, optimize access that groups or sorts rows.&#13;
Limiting rows is not a problem—it’s a benefit—but it works differently on other data stores.&#13;
Likewise, other data stores may or may not support grouping or sorting rows.<a data-primary="access patterns" data-secondary="result set" data-startref="result-set_index2" data-type="indexterm" id="idm45829111765072"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Application Changes" data-type="sect1"><div class="sect1" id="app-changes">&#13;
<h1>Application Changes</h1>&#13;
&#13;
<p>You <a data-primary="access patterns" data-secondary="application changes" data-type="indexterm" id="application-changes_index1"/><a data-primary="application changes" data-type="indexterm" id="application-changes_index2"/>must change the application to change its data access patterns.&#13;
The changes presented in this section are common, not exhaustive.&#13;
They are highly effective but also highly dependent on the application: some could work, others might not.&#13;
(Except the first change, <a data-type="xref" href="#audit-the-code">“Audit the Code”</a>: that always works.)&#13;
Consequently, each change is an idea that needs further discussion and planning with your team.</p>&#13;
&#13;
<p>All changes except the first have a subtle commonality: they require additional infrastructure.&#13;
I point that out to mentally prepare you for the fact that, in addition to code changes, you will need infrastructure changes, too.&#13;
As foretold from the beginning, <a data-type="xref" href="ch01.html#query-optimization">“Improving Query Response Time”</a>, indirect query optimization requires a greater level of effort.&#13;
Whereas changing data (<a data-type="xref" href="ch03.html#ch03">Chapter 3</a>) is potentially work, changing access patterns is certainly work.&#13;
But it’s worth the effort because these changes are, by definition, <em>transformative</em>: how the application changes from a Toyota to a Ferrari.</p>&#13;
&#13;
<p>You might wonder: if these changes are so powerful, why not make them first—before optimizing queries and data?&#13;
Since the focus of this book is <em>efficient</em> MySQL performance, I planned the journey to end with application changes because they require the most effort.&#13;
By contrast, direct query optimization (<a data-type="xref" href="ch02.html#ch02">Chapter 2</a>) and changes to data (<a data-type="xref" href="ch03.html#ch03">Chapter 3</a>) require far less effort, and the former solves a lot of—if not most—performance problems.&#13;
But if you have the time and energy to jump straight into re-engineering the application, you have my support.&#13;
Just remember the lesson from <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>: indexes provide the most <em>and the best</em> leverage.&#13;
Bad queries ruin wonderful access patterns; or, to quote renowned MySQL expert Bill <a data-primary="Karwin, Bill" data-type="indexterm" id="idm45829111750992"/>Karwin:</p>&#13;
<blockquote>&#13;
<p>Your unoptimized queries are killing the database server.</p></blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Audit the Code" data-type="sect2"><div class="sect2" id="audit-the-code">&#13;
<h2>Audit the Code</h2>&#13;
&#13;
<p>You might be surprised by how long code <a data-primary="code audits" data-type="indexterm" id="code-audits"/>can exist and run without any human looking at it.&#13;
In a certain sense, that’s a sign of good code: it just works and doesn’t cause problems.&#13;
But “doesn’t cause problems” does not necessarily mean that the code is efficient or even required.</p>&#13;
&#13;
<p>You don’t have to audit all the code (although that’s not a bad idea), just the code that accesses the database.&#13;
Look at the actual queries, of course, but also consider the context: the business logic that the queries accomplish.&#13;
You might realize a different and better way to accomplish the same business logic.</p>&#13;
&#13;
<p>With respect to queries, look for the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Queries that are no longer needed</p>&#13;
</li>&#13;
<li>&#13;
<p>Queries that execute too frequently</p>&#13;
</li>&#13;
<li>&#13;
<p>Queries that retry too fast or too often</p>&#13;
</li>&#13;
<li>&#13;
<p>Large or complex queries—can they be simplified?</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If the code uses ORM—or any kind of database abstraction—double check its defaults and configuration.&#13;
One consideration is that some database libraries execute <code>SHOW WARNINGS</code> after every query to check for warnings.&#13;
That’s usually not a problem, but it’s also quite wasteful.&#13;
Also double-check the driver defaults, configuration, and release notes.&#13;
For example, the MySQL driver for the Go programming language has had very useful developments over the years, so Go code should be using the latest version.</p>&#13;
&#13;
<p>Indirectly audit the code by using the query profile to see what queries the application executes—no query analysis required; just use the query profile as an auditing tool.&#13;
It’s quite common to see unknown queries in the profile.&#13;
Given <a data-type="xref" href="#mysql-does-nothing">“MySQL Does Nothing”</a>, unknown queries likely originate from the application—either your application code or any kind of database abstraction, like ORM—but there is another possibility: ops.&#13;
<em>Ops</em> refers to whoever runs and maintains the data store: DBAs, cloud providers, and so on.&#13;
If you find unknown queries and you’re certain that the application isn’t executing them, check with whoever operates the data store.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>To make query auditing easier, add application metadata to queries in <code>/* SQL comments */</code>.&#13;
For example, <code>SELECT</code>…<code>/* file:app.go line:75 */</code> reveals where the query originates in the application source code.&#13;
SQL comments are removed from digest texts, so your query metric tool must include samples (see <a data-type="xref" href="ch01.html#query-group-ids">Example 1-1</a>) or parse metadata from SQL comments.</p>&#13;
</div>&#13;
&#13;
<p>Lastly and most overlooked: review the <a href="https://oreil.ly/hmLlY">MySQL error log</a>.&#13;
It should be quiet: no errors, warnings, and so forth.&#13;
If it’s noisy, look into the errors because they signify a wide array of issues: network, authentication, replication, MySQL configuration, nondeterministic queries, and so forth.&#13;
These types of problems should be incredibly rare, so don’t ignore them.<a data-primary="code audits" data-startref="code-audits" data-type="indexterm" id="idm45829111732032"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Offload Reads" data-type="sect2"><div class="sect2" id="offload-reads">&#13;
<h2>Offload Reads</h2>&#13;
&#13;
<p>By <a data-primary="offload reads" data-type="indexterm" id="offload-reads_index1"/>default, a single MySQL instance called <em>the source</em> serves all reads and writes.&#13;
In production, the source should have at least one <em>replica</em>: another MySQL instance that replicates all writes from the source.&#13;
<a data-type="xref" href="ch07.html#ch07">Chapter 7</a> addresses replication, but I mention it here to set the stage for a discussion about offloading reads.</p>&#13;
&#13;
<p>Performance can be improved by offloading reads from the source.&#13;
This technique uses MySQL replicas or cache servers to serve reads.&#13;
(More on these two in a moment.)&#13;
It improves performance in two ways.&#13;
First, it reduces load on the source, which frees time and system resources to run the remaining queries faster.&#13;
Second, it improves response time for the offloaded reads because the replicas or caches serving those reads are not loaded with writes.&#13;
It’s a win-win technique that’s commonly used to achieve high-throughput, low-latency reads.</p>&#13;
&#13;
<p>Data read from a replica or cache is <em>not</em> guaranteed to be current (the latest value) because there is inherent and unavoidable delay in MySQL replication and writing to a cache.&#13;
Consequently, data from replicas and caches is <em>eventually consistent</em>: it becomes current after a (hopefully very) short delay.&#13;
Only data on the source is current (transaction isolation levels notwithstanding).&#13;
Therefore, before serving reads from a replica or cache, the following must be true: <em>reading data that is out-of-date (eventually consistent) is acceptable, and it will not cause problems for the application or its users</em>.</p>&#13;
&#13;
<p>Give that statement some thought because more than once I’ve seen developers think about it and realize, “Yeah, it’s fine if the application returns slightly out-of-date values.”&#13;
A commonly cited example is the number of “likes” or up-votes on a post or video: if the current value is 100 but the cache returns 98, that’s close enough—especially if the cache returns the current value a few milliseconds later.&#13;
If that statement is <em>not</em> true for your application, do not use this technique.</p>&#13;
&#13;
<p>In addition to the requirement that eventual consistency is acceptable, offloaded reads must not be part of a multi-statement transaction.&#13;
Multi-statement transactions must be executed on the source.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Always ensure that offload reads are acceptable with eventual consistency and not part of a multi-statement transaction.</p>&#13;
</div>&#13;
&#13;
<p>Before serving reads from replicas or caches, thoroughly address this question: <em>how will the application run degraded when the replicas or caches are offline?</em></p>&#13;
&#13;
<p>The only wrong answer to that question is not knowing.&#13;
Once an application offloads reads, it tends to depend heavily on the replicas or caches to serve those reads.&#13;
It’s imperative to design, implement, and test the application to run degraded when the replicas or caches are offline.&#13;
<em>Degraded</em> means that the application is running but noticeably slower, limiting client requests, or not fully functional because some parts are offline or throttled.&#13;
As long as the application is not <em>hard down</em>—completely offline and unresponsive with no human-friendly error message—then you’ve done a good job making the application run degraded.</p>&#13;
&#13;
<p>Last point before we discuss using MySQL replicas versus cache servers: do not offload all reads.&#13;
Offloading reads improves performance by not wasting time on the source for work that a replica or cache can accomplish.&#13;
Therefore, start by offloading slow (time-consuming) reads: reads that show up as slow queries in the query profile.&#13;
This technique is potent, so offload reads one by one because you might only need to offload a few to significantly improve performance.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="MySQL replica" data-type="sect3"><div class="sect3" id="idm45829111715968">&#13;
<h3>MySQL replica</h3>&#13;
&#13;
<p>Using MySQL replicas to serve reads is common because every production MySQL setup should already have at least one replica, and more than two replicas is common.&#13;
With the infrastructure (the replicas) <a data-primary="replicas" data-type="indexterm" id="replicas"/>already in place, you only have to modify the code to use the replicas for offloaded reads instead of the source.</p>&#13;
&#13;
<p>Before stating why replicas are preferable to cache servers, there’s one important issue to settle: can the application use the replicas?&#13;
Since replicas are used for high availability, whoever manages MySQL might not intend for replicas to serve reads.&#13;
Be sure to find out because, if not, replicas might be taken offline without notice for maintenance.</p>&#13;
&#13;
<p>Presuming your replicas can be used to serve reads, they are preferable to cache servers for three reasons:</p>&#13;
<dl>&#13;
<dt>Availability</dt>&#13;
<dd>&#13;
<p>Since replicas are the foundation of high availability, they should have the same availability as the source—99.95% or 99.99% availability, for example.&#13;
That makes replicas nearly worry-free: whoever manages MySQL is also managing the replicas.</p>&#13;
</dd>&#13;
<dt>Flexibility</dt>&#13;
<dd>&#13;
<p>In the previous section, I said that you should start by offloading slow (time-consuming) reads.&#13;
For caches, this is especially true because the cache server most likely has limited CPU and memory—resources not to be wasted on trivial reads.&#13;
By contrast, replicas used for high availability should have the same hardware as the source, so they have resources to spare.&#13;
Offloading trivial reads to a replica doesn’t matter as much, hence the flexibility when choosing what to offload.&#13;
On the off chance that you have pure <em>read replicas</em>—replicas <em>not</em> used for high availability—with less powerful hardware, then don’t waste resources on trivial reads.&#13;
This is more common in the cloud because it’s easy to provision read replicas with large storage but small CPU and memory (to save money).</p>&#13;
</dd>&#13;
<dt>Simplicity</dt>&#13;
<dd>&#13;
<p>The application doesn’t have to do anything to keep replicas in sync with the source—that’s intrinsic to being a replica. With a cache, the application must manage updates, invalidation, and (possibly) eviction.&#13;
But the real simplicity is that replicas don’t require any query changes: the application can execute the exact same SQL statements on a replica.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Those are three compelling reasons to prefer MySQL replicas to cache servers, but the latter has one important point in its favor: a cache server can be incredibly faster than MySQL.<a data-primary="replicas" data-startref="replicas" data-type="indexterm" id="idm45829111704160"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cache server" data-type="sect3"><div class="sect3" id="idm45829111703056">&#13;
<h3>Cache server</h3>&#13;
&#13;
<p>A cache server <a data-primary="cache server" data-type="indexterm" id="cache-server"/>is not encumbered with SQL, transactions, or durable storage.&#13;
That makes it incredibly faster than MySQL, but it also takes more work in the application to use properly.&#13;
As mentioned in the previous section, the application must manage cache updates, invalidation, and (possibly) eviction.&#13;
Moreover, the application needs a data model that works with the cache, which is usually a key-value model.&#13;
The extra work is worth the effort because practically nothing is faster than a cache.&#13;
<a href="https://memcached.org">Memcached</a> and <a href="https://redis.io">Redis</a> are two popular and widely-used cache servers.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you hear that MySQL has a built-in query cache: forget it and never use it.&#13;
It was deprecated as of MySQL 5.7.20 and removed as of MySQL 8.0.</p>&#13;
</div>&#13;
&#13;
<p>Caching is ideal for data that’s frequently accessed but infrequently changed.&#13;
This is not a consideration for MySQL replicas because all changes replicate, but a cache stores only what the application puts in it.&#13;
A bad example is the current Unix timestamp in seconds: it’s always changing.&#13;
The exception in a bad case like this: if the frequency of access is significantly <em>greater than</em> the frequency of change.&#13;
For example, if the current Unix timestamp in seconds is requested one million times per second, then caching the current timestamp might be appropriate.&#13;
A good example is the current year: it changes infrequently.&#13;
However, the exception in a good case like this: if the frequency of access is significantly <em>less than</em> the frequency of change.&#13;
For example, if the current year is requested only once per second, then a cache provides almost no value because 1 QPS doesn’t make any difference for this data access.</p>&#13;
&#13;
<p>A word of caution when using a cache: <em>decide whether the cache is ephemeral or durable</em>.&#13;
This, too, is not a consideration for MySQL replicas because they are always durable, but some cache servers can be either.&#13;
If the cache is truly ephemeral, then you should be able to do the equivalent of <code>TRUNCATE TABLE</code> on the cache data without affecting the application.&#13;
You also need to decide how the ephemeral cache is rebuilt.&#13;
Some applications rebuild the cache on <em>cache miss</em>: when the requested data is not in the cache.&#13;
Other applications have an external process to rebuild the cache from another data source (for example, loading the cache with images stored in <a href="https://oreil.ly/XMQxR">Amazon S3</a>).&#13;
And some applications rely so heavily on the cache, or the cache is so large, that rebuilding it is not feasible.&#13;
For such applications, a durable cache is required.&#13;
Either way—ephemeral or durable—test your decision to verify that the application functions as expected when the cache fails and recovers.<a data-primary="offload reads" data-startref="offload-reads_index1" data-type="indexterm" id="idm45829111691568"/><a data-primary="cache server" data-startref="cache-server" data-type="indexterm" id="idm45829111690592"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enqueue Writes" data-type="sect2"><div class="sect2" id="enqueue-writes">&#13;
<h2>Enqueue Writes</h2>&#13;
&#13;
<p>Use <a data-primary="enqueue writes" data-type="indexterm" id="enqueue-writes_index1"/>a queue to stabilize write throughput.&#13;
<a data-type="xref" href="#erratic-writes">Figure 4-5</a> illustrates unstable—erratic—write throughput that spikes above 30,000 QPS and dips below 10,000 QPS.</p>&#13;
&#13;
<figure><div class="figure" id="erratic-writes">&#13;
<img alt="emsp 0405" src="assets/emsp_0405.png"/>&#13;
<h6><span class="label">Figure 4-5. </span>Erratic write throughput</h6>&#13;
</div></figure>&#13;
&#13;
<p>Even if performance is currently acceptable with unstable write throughput, it’s not a recipe for success because unstable throughput worsens at scale—it never spontaneously stabilizes.&#13;
(And if you recall <a data-type="xref" href="#db-perf-limit-charts">Figure 4-3</a> from <a data-type="xref" href="#perf-at-the-limit">“Performance Destabilizes at the Limit”</a>, a flatline value is not stable.)&#13;
Using a queue allows the application to process changes (writes) at a stable rate, as shown in <a data-type="xref" href="#stable-writes">Figure 4-6</a>.</p>&#13;
&#13;
<figure><div class="figure" id="stable-writes">&#13;
<img alt="emsp 0406" src="assets/emsp_0406.png"/>&#13;
<h6><span class="label">Figure 4-6. </span>Stable write throughput</h6>&#13;
</div></figure>&#13;
&#13;
<p>The real power of enqueueing writes and stable write throughput is that they allow the application to respond gracefully and predictably to a <em>thundering herd</em>: a flood of requests that overwhelms the application, or the database, or both.&#13;
For example, imagine that the application normally processes 20,000 changes per second.&#13;
But it goes offline for five seconds, which results in 100,000 pending changes.&#13;
The moment the application comes back online, it’s hit with the 100,000 pending changes—a thundering herd—plus the normal 20,000 changes for the current second.&#13;
How will the application and MySQL handle the thundering herd?</p>&#13;
&#13;
<p>With a queue, the thundering herd does not affect MySQL: it goes into the queue, and MySQL processes the changes as usual.&#13;
The only difference is that some changes happen later than usual.&#13;
As long as write throughput is stable, you can increase the number of queue consumers to process the queue more quickly.</p>&#13;
&#13;
<p>Without a queue, experience teaches that one of two things will happen.&#13;
Either you’ll be super lucky and MySQL will handle the thundering herd, or it won’t.&#13;
Don’t count on luck.&#13;
MySQL does not throttle query execution, so it will try to execute all queries when the thundering herd hits.&#13;
(However, MySQL Enterprise Edition, Percona <a data-primary="Percona Server" data-secondary="enqueue writes" data-type="indexterm" id="idm45829111675568"/>Server, and MariaDB Server have a <em>thread pool</em> that limits the number of concurrently executing queries, which acts as a throttle.)&#13;
This never works because CPU, memory, and disk I/O are inherently limited—not to mention the Universal Scalability Law (<a data-type="xref" href="#usl">Equation 4-1</a>).&#13;
Regardless, MySQL always tries because it’s incredibly ambitious and a little foolhardy.</p>&#13;
&#13;
<p>This technique bestows other advantages that make it worth the effort to implement.&#13;
One advantage is that it decouples the application from MySQL availability: the application can accept changes when MySQL is offline.&#13;
Another advantage is that it can be used to recover lost or abandoned changes.&#13;
Suppose a change requires various steps, some of which might be long-running or unreliable.&#13;
If a step fails or times out, the application can re-enqueue the change to try again.&#13;
A third advantage is the ability to replay changes if the queue is an event stream, like <a href="https://oreil.ly/fRZpa">Kafka</a>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>For write-heavy applications, enqueueing writes is the best practice and practically a requirement.&#13;
Invest the time to learn and implement a queue.<a data-primary="enqueue writes" data-startref="enqueue-writes_index1" data-type="indexterm" id="idm45829111670016"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Partition Data" data-type="sect2"><div class="sect2" id="partition-data">&#13;
<h2>Partition Data</h2>&#13;
&#13;
<p>After <a data-type="xref" href="ch03.html#ch03">Chapter 3</a>, it should <a data-primary="partition data" data-type="indexterm" id="partition-data_index1"/>be no surprise that it’s easier to improve performance with <em>less data</em>.&#13;
Data is valuable to you, but it’s dead weight <a data-primary="dead weight" data-type="indexterm" id="idm45829111664624"/>to MySQL.&#13;
If you cannot delete or archive data (see <a data-type="xref" href="ch03.html#delete-or-archive">“Delete or Archive Data”</a>), then you should at least partition (physically separate) the data.</p>&#13;
&#13;
<p>First, let’s briefly address then put aside <a href="https://oreil.ly/BNopd">MySQL partitioning</a>.&#13;
MySQL supports partitioning, but it requires special handling.&#13;
It’s not trivial to <span class="keep-together">implement</span> or maintain, and some third-party MySQL tools don’t support it.&#13;
Consequently, I don’t recommend using MySQL partitioning.</p>&#13;
&#13;
<p>The type of data partitioning that is most useful, more common, and easier for application developers to implement is separating <em>hot</em> and <em>cold</em> data: frequently and <span class="keep-together">infrequently</span> accessed data, respectively.&#13;
Separating hot and cold data is a combination of partitioning and archiving.&#13;
It partitions by access, and it archives by moving the infrequently accessed (cold) data out of the access path of the frequently accessed (hot) data.</p>&#13;
&#13;
<p>Let’s use an example: a database that stores payments.&#13;
The hot data is the last 90 days of payments for two reasons.&#13;
First, payments usually do not change after settling, but there are exceptions like refunds that can be applied later.&#13;
After some period, however, payments are finalized and cannot be changed.&#13;
Second, the application shows only the last 90 days of payments.&#13;
To see older payments, users have to look up past statements.&#13;
The cold data is payments after 90 days.&#13;
For a year, that’s 275 days, which is roughly 75% of data.&#13;
Why have 75% of data sit idly in a transactional data store like MySQL?&#13;
That’s a rhetorical question: there’s no good reason.</p>&#13;
&#13;
<p>Separating hot and cold data is primarily an optimization for the former.&#13;
Storing cold data elsewhere yields three immediate advantages: more hot data fits in memory, queries don’t waste time examining cold data, and operations (like schema changes) are faster.&#13;
Separating hot and cold data is also an optimization for the latter when it has completely different access patterns.&#13;
In the preceding example, old payments might be grouped by month into a single data object that no longer requires a row for each payment.&#13;
In that case, a document store or key-value store might be better suited for storing and accessing the cold data.</p>&#13;
&#13;
<p>At the very least, you can archive cold data in another table in the same database.&#13;
That’s relatively easy with a controlled <code>INSERT</code>…<code>SELECT</code> statement to select from the hot table and insert into the cold table.&#13;
Then <code>DELETE</code> the archived cold data from the hot table.&#13;
Wrap it all up in a transaction for consistency.&#13;
See <a data-type="xref" href="ch03.html#delete-or-archive">“Delete or Archive Data”</a>.</p>&#13;
&#13;
<p>This technique can be implemented many different ways, especially with respect to how and where the cold data is stored and accessed.&#13;
But fundamentally it’s very simple and highly effective: move infrequently accessed (cold) data out of the access path of frequently accessed (hot) data to improve performance for the latter.<a data-primary="partition data" data-startref="partition-data_index1" data-type="indexterm" id="idm45829111652880"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t Use MySQL" data-type="sect2"><div class="sect2" id="dont-use-mysql">&#13;
<h2>Don’t Use MySQL</h2>&#13;
&#13;
<p>I want to put a figurative capstone on the current discussion about application changes: the most significant change is not using MySQL when it’s clearly not the best data store for the access patterns.&#13;
Sometimes it’s very easy to see when MySQL is not the best choice.&#13;
For example, in previous chapters I made reference to a query with load 5,962.&#13;
That query is used to select vertices in a graph.&#13;
Clearly, a relational database is not the best choice for graph data; the best choice is a graph data store.&#13;
Even a key-value store would be better because graph data has nothing to do with relational database concepts like normalization and transactions.&#13;
Another easy and common example is time series data: a row-oriented transactional database is not the best choice; the best choice is a time series database, or perhaps a columnar store.</p>&#13;
&#13;
<p>MySQL scales surprising well for a wide range of data and access patterns even when it’s not the best choice.&#13;
But never take that for granted: be the first engineer on your team to say, “Maybe MySQL isn’t the best choice.”&#13;
It’s okay: if I can say that, then you can too.&#13;
If anyone gives you grief, tell them I support your decision to use the best tool for the job.</p>&#13;
&#13;
<p>That said, MySQL is amazing.&#13;
Please at least finish this chapter and the next, <a data-type="xref" href="ch05.html#ch05">Chapter 5</a>, before you swipe left on MySQL.<a data-primary="access patterns" data-secondary="application changes" data-startref="application-changes_index1" data-type="indexterm" id="idm45829111647072"/><a data-primary="application changes" data-startref="application-changes_index2" data-type="indexterm" id="idm45829111645792"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Better, Faster Hardware?" data-type="sect1"><div class="sect1" id="better-faster-hardware-again">&#13;
<h1>Better, Faster Hardware?</h1>&#13;
&#13;
<p><a data-type="xref" href="ch02.html#better-faster-hardware">“Better, Faster Hardware!”</a> cautions <a data-primary="hardware upgrade" data-type="indexterm" id="hardware-upgrade_index2"/>against scaling up hardware to increase performance.&#13;
But the first sentence of that section is carefully worded: “When MySQL performance isn’t acceptable, do <em>not</em> begin by scaling up…”&#13;
The key word in that sentence is <em>begin</em>, and the pivotal question that it leads to is: <em>when is the correct time to scale up hardware?</em></p>&#13;
&#13;
<p>That question is difficult to answer because it depends on a combination of factors: queries, indexes, data, access patterns, and how those utilize the current hardware.&#13;
For example, let’s say that the application has a super inefficient access pattern: it uses MySQL as a queue and polls it very quickly from many application instances.&#13;
I would not scale up hardware until fixing the access pattern first.&#13;
But sometimes, engineers don’t have the luxury of time necessary to make such application changes.</p>&#13;
&#13;
<p><a data-type="xref" href="#hardware-upgrade-checklist">Table 4-2</a> is a checklist to help determine if it’s time to scale up the hardware.&#13;
When you can check all items in column 1 and at least two items in column 2, then it’s a strong indication that it’s time to scale up the hardware.</p>&#13;
<table id="hardware-upgrade-checklist">&#13;
<caption><span class="label">Table 4-2. </span>Hardware upgrade checklist</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>1. Check all</th>&#13;
<th>2. Check at least two</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>☐ Response time is too high</p></td>&#13;
<td><p>☐ CPU utilization is greater than 80%</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>☐ Slow queries have been optimized</p></td>&#13;
<td><p>☐ Threads running greater than number of CPU cores</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>☐ Data has been deleted or archived</p></td>&#13;
<td><p>☐ Memory is less than 10% of total data size</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>☐ Access patterns have been reviewed and optimized</p></td>&#13;
<td><p>☐ Storage IOPS utilization is greater than 80%</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Column 1 is an unapologetic reiteration of everything since <a data-type="xref" href="ch01.html#ch01">Chapter 1</a>, but it’s also an unequivocal justification for spending money to upgrade the hardware.&#13;
Column 2 requires at least two checks because hardware works together.&#13;
Heavily utilizing only one piece of hardware doesn’t guarantee a problem or slow performance.&#13;
Instead, it’s probably a good sign: you’re fully utilizing that piece of hardware.&#13;
But when one piece of hardware is overloaded, it usually begins to affect other pieces of hardware.&#13;
For example, when slow storage causes a backlog of queries which causes a backlog of clients which causes high CPU utilization because MySQL is trying to execute too many threads.&#13;
That’s why column 2 requires two checks.</p>&#13;
&#13;
<p>Values in column 2 should be consistently greater or less than the suggested thresholds.&#13;
Occasional spikes and dips are normal.</p>&#13;
&#13;
<p>The maximum number of storage IOPS is determined by the storage device, if running your own hardware.&#13;
If you’re not sure, check the device specifications, or ask the engineers who manage the hardware.&#13;
In the cloud, storage IOPS are allocated or provisioned, so it’s usually easier to tell the maximum because you purchase the IOPS.&#13;
But if you’re not sure, check the MySQL storage settings, or ask the cloud provider.&#13;
<a data-type="xref" href="ch06.html#metrics-iops">“IOPS”</a> shows which metrics report storage IOPS.</p>&#13;
&#13;
<p>Storage IOPS utilization has an additional consideration based on whether the application is read-heavy or write-heavy (see <a data-type="xref" href="#ap-read-write">“Read/Write”</a>):</p>&#13;
<dl>&#13;
<dt>Read-heavy</dt>&#13;
<dd>&#13;
<p>For read-heavy access patterns, <a data-primary="read-heavy access patterns" data-type="indexterm" id="idm45829111620112"/>consistently high IOPS is probably due to insufficient memory, not insufficient IOPS.&#13;
MySQL reads data from disk when it’s not in memory, and it’s exceptionally good at keeping the working set in memory (see <a data-type="xref" href="ch03.html#working-set-size">“Working set size”</a>).&#13;
But a combination of two factors can cause high IOPS for reads: the working set size is significantly larger than memory, and read throughput is exceptionally high (see <a data-type="xref" href="#ap-throughput">“Throughput”</a>).&#13;
That combination causes MySQL to swap so much data between disk and memory that the problem shows up as high IOPS.&#13;
This is rare, but possible.</p>&#13;
</dd>&#13;
<dt>Write-heavy</dt>&#13;
<dd>&#13;
<p>For write-heavy access patterns, <a data-primary="write-heavy access patterns" data-type="indexterm" id="idm45829111615760"/>consistently high IOPS is probably due to insufficient IOPS.&#13;
Simply put: the storage can’t write data fast enough.&#13;
Normally, storage achieves high throughput (IOPS) with write caches, but caches are not durable.&#13;
MySQL requires <em>durable storage</em>: data physically on disk, not in caches.&#13;
(The phrase “on disk” is still used even for flash-based storage that doesn’t have disks.)&#13;
Consequently, MySQL must <em>flush</em> data—force it to be written to disk.&#13;
Flushing severely limits storage throughput, but MySQL has sophisticated techniques and algorithms to achieve performance with durability—<a data-type="xref" href="ch06.html#metrics-page-flushing">“Page flushing”</a> goes into detail.&#13;
The only solution at this point—because you’ve already optimized queries, data, and access patterns—is more storage IOPS.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>With a cautious nod to scaling up hardware, it might seem that we’ve reached the end.&#13;
No matter how many pebbles, <a data-primary="pebbles" data-type="indexterm" id="idm45829111611696"/>or cobbles, <a data-primary="cobbles" data-type="indexterm" id="idm45829111610864"/>or boulders <a data-primary="boulders" data-type="indexterm" id="idm45829111610032"/>we have to move, we can always use a bigger truck to move them.&#13;
But what if you have to move a mountain?&#13;
Then you need the next chapter: sharding.<a data-primary="hardware upgrade" data-startref="hardware-upgrade_index2" data-type="indexterm" id="idm45829111609040"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45829111644240">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter centered on data access patterns that determine how you can change the application to use MySQL efficiently.&#13;
The important takeaway points are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>MySQL does nothing but execute application queries.</p>&#13;
</li>&#13;
<li>&#13;
<p>Database performance destabilizes at a limit that is less than 100% of hardware capacity.</p>&#13;
</li>&#13;
<li>&#13;
<p>Some applications have far greater MySQL performance because every detail is engineered for high performance.</p>&#13;
</li>&#13;
<li>&#13;
<p>Access patterns describe how an application uses MySQL to access data.</p>&#13;
</li>&#13;
<li>&#13;
<p>You must change the application to change its data access patterns.</p>&#13;
</li>&#13;
<li>&#13;
<p>Scale up hardware to improve performance after exhausting other solutions.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The next chapter introduces the basic mechanics of sharding MySQL to achieve MySQL at scale.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Practice: Describe an Access Pattern" data-type="sect1"><div class="sect1" id="idm45829111599728">&#13;
<h1>Practice: Describe an Access Pattern</h1>&#13;
&#13;
<p>The goal of this practice is to describe the access pattern of the slowest query.&#13;
(To get slow queries, refer back to <a data-type="xref" href="ch01.html#query-profile">“Query profile”</a> and <a data-type="xref" href="ch01.html#ch01-ai">“Practice: Identify Slow Queries”</a>.)&#13;
For the slowest query, describe all nine access pattern traits from <a data-type="xref" href="#access-patterns">“Data Access Patterns”</a>.&#13;
As mentioned in that section, access patterns are pure knowledge.&#13;
Use that knowledge to consider what <a data-type="xref" href="#app-changes">“Application Changes”</a> could be made to indirectly optimize the query by changing its access pattern.&#13;
Even if no application changes are possible, knowing access patterns is an expert practice because MySQL performance depends on queries, data, and access patterns.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45829111984992"><sup><a href="ch04.html#idm45829111984992-marker">1</a></sup> Watch the video <a href="https://oreil.ly/hzXnb">Universal Scalability Law Modeling Workbook</a> by renowned MySQL expert Baron Schwartz <a data-primary="Schwartz, Baron" data-type="indexterm" id="idm45829111983584"/>to see the USL in action with values from real MySQL servers.</p><p data-type="footnote" id="idm45829111946752"><sup><a href="ch04.html#idm45829111946752-marker">2</a></sup> In fact, renowned MySQL expert Baron Schwartz <a data-primary="Schwartz, Baron" data-type="indexterm" id="idm45829111946160"/>put it there. Neil Gunther wrote in a blog post, <a href="https://oreil.ly/s2BL8">“USL Scalability Modeling with Three Parameters”</a>, that Baron added the third parameter because it allowed the USL to fit data from real databases.</p><p data-type="footnote" id="idm45829111931920"><sup><a href="ch04.html#idm45829111931920-marker">3</a></sup> Toyota: 210 Km/h; Ferrari: 320 Km/h.</p><p data-type="footnote" id="idm45829111854048"><sup><a href="ch04.html#idm45829111854048-marker">4</a></sup> It’s technically possible by inspecting the LSN of data pages in the InnoDB buffer pool, but that’s disruptive, so it’s practically never done.</p></div></div></section></body></html>