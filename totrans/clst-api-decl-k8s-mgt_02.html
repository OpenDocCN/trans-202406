<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
      lang="en"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Cluster API and Declarative Kubernetes Management</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Declarative Kubernetes Cluster Management"><div class="chapter" id="declarative_kubernetes_cluster_management">
      <h1><span class="label">Chapter 2. </span>Declarative Kubernetes Cluster Management</h1>
      <p>When you create a CRD, you can provide a custom controller with the proper logic to maintain the associated objects. In this way, you can extend the Kubernetes declarative API to embrace new kinds of objects. This is exactly the approach Cluster API uses to manage Kubernetes: it provides resources to represent Kubernetes clusters and the infrastructure itself.</p>
      <p>Cluster API is a project created by the Kubernetes Cluster Lifecycle special interest group (SIG) to provide a consistent, modular platform for declarative Kubernetes cluster management. Leveraging kubeadm, Cluster API uses Kubernetes-style APIs to create, configure, and manage Kubernetes clusters and their infrastructure for a variety of deployment environments and providers.</p>
      <section data-type="sect1" data-pdf-bookmark="Goals of Cluster API"><div class="sect1" id="goals_of_cluster_api">
        <h1>Goals of Cluster API</h1>
        <p>The Kubernetes Cluster Lifecycle SIG created Cluster API to make cluster lifecycle management easier. Although Kubernetes itself has APIs for orchestrating containers regardless of the environment or provider, it doesn’t provide a consistent way to create new machines on arbitrary infrastructure. This means cluster lifecycle has to be handled uniquely depending on the environment.</p>
        <p class="pagebreak-before">The primary charter of the Kubernetes Cluster Lifecycle SIG is to make it easier to create, manage, upgrade, and retire Kubernetes clusters. The group decided to develop Cluster API as a framework for managing Kubernetes infrastructure across environments, with several goals in mind:</p>
        <dl>
          <dt>Declarative cluster lifecycle management</dt> 
          <dd>Cluster API’s declarative approach for managing Kubernetes cluster lifecycle makes it easy to integrate with GitOps, a declarative operations framework that applies DevOps application development practices to infrastructure automation.</dd>
          <dt>Infrastructure abstraction</dt> 
          <dd>Cluster API provides a consistent way to provision and maintain cluster infrastructure across different environments, both in the cloud and on premises. This means managing not just compute and storage but also networking and security, including implementing security best practices such as subnets and bastion hosts.</dd>
          <dt>Integration with existing components</dt> 
          <dd>Cluster API is designed to work with existing components that rely on kubeadm, cloud-init, and other tools to initialize a cluster rather than reinventing and reimplementing what already works. Even the Cluster API approach to managing cluster infrastructure is familiar, as it’s designed to resemble the way developers manage workloads on Kubernetes.</dd>
          <dt>Easy adoption</dt> 
          <dd>Cluster API is designed to be adopted as quickly or as slowly as necessary. A team can adopt Cluster API all at once or in stages, or they can even choose to adopt only part of Cluster API.</dd>
          <dt>A modular approach</dt> 
          <dd>To be adaptable to different deployment environments and infrastructure providers, Cluster API uses a modular, extensible architecture. The goal is to provide consistent, repeatable operations that work the same way even on unforeseen infrastructure. A modular approach also means standardizing default operations for common operations and the ability to use alternative implementations when needed. For example, although Cluster API leverages kubeadm, it can use other bootstrap providers.</dd>
        </dl>
        <p>The overall goal of Cluster API is to provide a centralized, consistent set of tools that make it possible to manage multiple Kubernetes clusters in different environments without having to worry about the underlying infrastructure and without having to build large assortments of custom tools.</p>
      </div></section>
      <section data-type="sect1" data-pdf-bookmark="Cluster API Concepts"><div class="sect1" id="cluster_api_concepts">
        <h1>Cluster API Concepts</h1>
        <p>Cluster API uses modular, interchangeable components as the basis for a complete cluster infrastructure management platform that automates difficult cluster lifecycle management tasks such as creating, scaling, repairing, and upgrading a cluster. In essence, Cluster API is a modular abstraction layer that makes it possible to treat a variety of objects on different infrastructure substrates consistently. The core components of Cluster API remain the same from one environment to another, while the modular parts of Cluster API adapt to each environment:</p>
        <ul>
          <li>
            <p>CRDs model the VMs, physical servers, and other cluster <span class="keep-together">components</span>.</p>
          </li>
          <li>
            <p>Providers implement the correct capabilities and services for different infrastructure environments.</p>
          </li>
        </ul>
        <p>Cluster API manages these resources declaratively, meaning that instead of specifying how to create and manage the infrastructure, you need only to define the desired state of the cluster. Instead of a set of commands, the code becomes a repeatable specification that you can reuse for multiple deployments.</p>
        <p><a data-type="xref" href="#fig_1_cluster_api_modular_architecture">Figure 2-1</a> shows how providers implement the modular approach to Cluster API architecture, making it possible to tailor cluster lifecycle management to any infrastructure.</p>
        <figure><div id="fig_1_cluster_api_modular_architecture" class="figure">
          <img alt="Cluster API modular architecture" src="assets/cdkm_0201.png" width="600" height="496"/>
          <h6><span class="label">Figure 2-1. </span>Cluster API modular architecture</h6>
        </div></figure>
        <section data-type="sect2" data-pdf-bookmark="Custom Resource Definitions and Controllers"><div class="sect2" id="custom_resource_definitions_and_controllers">
          <h2>Custom Resource Definitions and Controllers</h2>
          <p>Just as Kubernetes provides abstractions for objects such as nodes, namespaces, and pods, Cluster API uses Kubernetes CRDs to represent the infrastructure and configuration that support a Kubernetes cluster. Each CRD is a declarative specification for a component of infrastructure. Cluster API introduces several CRDs for managing cluster infrastructure, including:</p>
          <dl>
            <dt><code>Cluster</code> </dt>
            <dd>
              <p>Specifies cluster details like API version, the IP address blocks for pods and services, the API endpoints, and the service domains</p>
            </dd>
            <dt><code>ControlPlane</code> </dt>
            <dd>
              <p>Controls the configuration and lifecycle of the control plane nodes</p>
            </dd>
            <dt><code>Machine</code> </dt>
            <dd>
              <p>Specifies the configuration of an individual node</p>
            </dd>
            <dt><code>MachineHealthCheck</code> </dt>
            <dd>
              <p>Determines when a node is unhealthy and needs to be replaced</p>
            </dd>
            <dt><code>MachineSet</code> </dt>
            <dd>
              <p>Specifies the desired number of <code>Machine</code> resources to maintain in a specific group</p>
            </dd>
            <dt><code>MachineDeployment</code> </dt>
            <dd>
              <p>Manages changes to <code>Machines</code> by destroying and replacing them as needed</p>
            </dd>
            <dt><code>MachineClass</code> </dt>
            <dd>
              <p>Makes it easier to reuse machine specifications across <code>Machines</code>, <code>MachineSets</code>, and <code>MachineDeployments</code></p>
            </dd>
          </dl>
          <p>Each CRD has a corresponding <em>controller</em>, a service that maintains the specified state. A controller ensures that the state of its corresponding object and the state of the world outside the object both match the desired state. This is called <em>reconciling</em> the actual state with the specification. The Cluster API Core Manager, also known as the Controller Manager, uses these controllers when managing the lifecycle of each cluster.</p>
          <p>When you specify the characteristics of a cluster, control plane, or machine, you do so by creating a YAML file called a <em>manifest</em>, which follows the schema defined in the corresponding CRD. For every parameter defined in the CRD, the YAML file provides a value that tells Cluster API how to create the custom resource.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Providers"><div class="sect2" id="providers_id3h8arn">
          <h2>Providers</h2>
          <p>Providers are modules that make Cluster API work in different environments. There are three types of providers:</p>
          <dl>
            <dt>Infrastructure providers </dt>
            <dd>
              <p>Create and access infrastructure and resources on specific environments and infrastructure hosts</p>
            </dd>
            <dt>Control plane provider </dt>
            <dd>
              <p>Instantiates a Kubernetes control plane and starts its required services</p>
            </dd>
            <dt>Bootstrap provider </dt>
            <dd>
              <p>Generates a script that brings up a Kubernetes node on a machine, which encapsulates configuration logic for initializing different distributions of Kubernetes nodes like kubeadm, k8s, microk8s, and so forth </p>
            </dd>
          </dl>
          <p>With Cluster API, you can use a single declarative API to deploy a pool of VMs or work directly on bare metal, using the correct commands and services for your chosen provider, and bring up a Kubernetes cluster. Each provider implements the best practices for the environment for which it’s designed.</p>
          <p>Cluster API providers let you use the same declarative specifications to bring up similar clusters in different environments or on different infrastructure hosts. <a data-type="xref" href="#fig_2_how_crds_and_providers_abstract_system_resources_a">Figure 2-2</a> shows how CRDs and providers create abstractions that make it possible to manage resources and infrastructure consistently across environments.</p>
          <figure><div id="fig_2_how_crds_and_providers_abstract_system_resources_a" class="figure">
            <img alt="How CRDs and providers abstract system resources and infrastructure" src="assets/cdkm_0202.png" width="580" height="800"/>
            <h6><span class="label">Figure 2-2. </span>How CRDs and providers abstract system resources and infrastructure</h6>
          </div></figure>
          <p>The ability to work consistently across different types of infrastructure makes it easy to work across deployments on premises and in public clouds, private clouds, or edge locations. This provides consistency regardless of substrate, which is especially important in diverse geographical regions with different providers.</p>
        </div></section>
      </div></section>
    </div></section></div>
</div>
</body>
</html>