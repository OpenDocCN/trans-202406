["```\ntype BoardGame = {\n  name: string;\n  price: number;\n  quantity: number;\n  minimumAge: number;\n  players: number;\n};\n\ntype Puzzle = {\n  name: string;\n  price: number;\n  quantity: number;\n  minimumAge: number;\n  pieces: number;\n};\n\ntype Doll = {\n  name: string;\n  price: number;\n  quantity: number;\n  minimumAge: number;\n  material: string;\n};\n```", "```\ntype ToyBase = {\n  name: string;\n  price: number;\n  quantity: number;\n  minimumAge: number;\n};\n\nfunction printToy(toy: ToyBase) {\n  /* ... */\n}\n\nconst doll: Doll = {\n  name: \"Mickey Mouse\",\n  price: 9.99,\n  quantity: 10000,\n  minimumAge: 2,\n  material: \"plush\",\n\n};\n\nprintToy(doll); // works\n```", "```\n// Union Toy\ntype Toy = Doll | BoardGame | Puzzle;\n\nfunction printToy(toy: Toy) {\n  /* ... */\n}\n```", "```\nfunction takesNumberOrString(value: number | string) {\n  /* ... */\n}\n\ntakesNumberOrString(2); // ok\ntakesNumberOrString(\"Hello\"); // ok\n```", "```\ntype ToyBase = {\n  name: string;\n  price: number;\n  quantity: number;\n  minimumAge: number;\n};\n\n// Intersection of ToyBase and { players: number }\ntype BoardGame = ToyBase & {\n  players: number;\n};\n\n// Intersection of ToyBase and { pieces: number }\ntype Puzzle = ToyBase & {\n  pieces: number;\n};\n\n// Intersection of ToyBase and { material: string }\ntype Doll = ToyBase & {\n  material: string;\n};\n```", "```\ntype One = 1;\nconst one: One = 1; // nothing else can be assigned.\n```", "```\ntype Doll = ToyBase & {\n  material: \"plush\" | \"plastic\";\n};\n\nfunction checkDoll(doll: Doll) {\n  if (doll.material === \"plush\") {\n    // do something with plush\n  } else {\n    // doll.material is \"plastic\", there are no other options\n  }\n}\n```", "```\ntype Circle = {\n  radius: number;\n};\n\ntype Square = {\n  x: number;\n};\n\ntype Triangle = {\n  x: number;\n  y: number;\n};\n\ntype Shape = Circle | Triangle | Square;\n```", "```\nfunction area(shape: Shape) {\n  if (\"radius\" in shape) {\n    // shape is Circle\n    return Math.PI * shape.radius * shape.radius;\n  } else if (\"y\" in shape) {\n    // shape is Triangle\n    return (shape.x * shape.y) / 2;\n  } else {\n    // shape is Square\n    return shape.x * shape.x;\n  }\n}\n```", "```\ntype Rectangle = {\n  x: number;\n  y: number;\n};\n\ntype Shape = Circle | Triangle | Square | Rectangle;\n```", "```\ntype Circle = {\n  radius: number;\n  kind: \"circle\";\n};\n\ntype Square = {\n  x: number;\n  kind: \"square\";\n};\n\ntype Triangle = {\n  x: number;\n  y: number;\n  kind: \"triangle\";\n};\n\ntype Shape = Circle | Triangle | Square;\n```", "```\nfunction area(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\": // shape is Circle\n      return Math.PI * shape.radius * shape.radius;\n    case \"triangle\": // shape is Triangle\n      return (shape.x * shape.y) / 2;\n    case \"square\": // shape is Square\n      return shape.x * shape.x;\n    default:\n      throw Error(\"not possible\");\n  }\n}\n```", "```\ntype Circle = {\n  radius: number;\n  kind: \"circle\";\n};\n\ntype Square = {\n  x: number;\n  kind: \"square\";\n};\n\ntype Triangle = {\n  x: number;\n  y: number;\n  kind: \"triangle\";\n};\n\ntype Shape = Circle | Triangle | Square;\n\nfunction area(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\": // shape is Circle\n      return Math.PI * shape.radius * shape.radius;\n    case \"triangle\": // shape is Triangle\n      return (shape.x * shape.y) / 2;\n    case \"square\": // shape is Square\n      return shape.x * shape.x;\n    default:\n      throw Error(\"not possible\");\n  }\n}\n```", "```\nfunction area(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\": // shape is Circle\n      return Math.PI * shape.radius * shape.radius;\n    case \"triangle\": // shape is Triangle\n      return (shape.x * shape.y) / 2;\n    case \"square\": // shape is Square\n      return shape.x * shape.x;\n    default:\n      console.error(\"Shape not defined:\", shape); // shape is never\n      throw Error(\"not possible\");\n  }\n}\n```", "```\ntype Rectangle = {\n  x: number;\n  y: number;\n  kind: \"rectangle\";\n};\n\ntype Shape = Circle | Triangle | Square | Rectangle;\n\nfunction area(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\": // shape is Circle\n      return Math.PI * shape.radius * shape.radius;\n    case \"triangle\": // shape is Triangle\n      return (shape.x * shape.y) / 2;\n    case \"square\": // shape is Square\n      return shape.x * shape.x;\n    default:\n      console.error(\"Shape not defined:\", shape); // shape is Rectangle\n      throw Error(\"not possible\");\n  }\n}\n```", "```\nfunction assertNever(value: never) {\n  console.error(\"Unknown value\", value);\n  throw Error(\"Not possible\");\n}\n```", "```\nfunction area(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\": // shape is Circle\n      return Math.PI * shape.radius * shape.radius;\n    case \"triangle\": // shape is Triangle\n      return (shape.x * shape.y) / 2;\n    case \"square\": // shape is Square\n      return shape.x * shape.x;\n    default: // shape is Rectangle\n      assertNever(shape);\n//    ^-- Error: Argument of type 'Rectangle' is not\n//        assignable to parameter of type 'never'\n  }\n}\n```", "```\nfunction area(shape: Shape) {\n  switch (shape.kind) {\n    case \"circle\": // shape is Circle\n      return Math.PI * shape.radius * shape.radius;\n    case \"triangle\": // shape is Triangle\n      return (shape.x * shape.y) / 2;\n    case \"square\": // shape is Square\n      return shape.x * shape.x;\n    case \"rectangle\":\n      return shape.x * shape.y;\n    default: // shape is never\n      assertNever(shape); // shape can be passed to assertNever!\n  }\n}\n```", "```\nlet name = \"Stefan\"; // name is string\n```", "```\nconst name = \"Stefan\"; // name is \"Stefan\"\n```", "```\n// person is { name: string }\nlet person = { name: \"Stefan\" };\n```", "```\n// person is { name: string }\nconst person = { name: \"Stefan\" };\n```", "```\n// person is { name: string }\nconst person = { name: \"Stefan\" };\n\nperson.name = \"Not Stefan\"; // works!\n```", "```\ntype Circle = {\n  radius: number;\n  kind: \"circle\";\n};\n\ntype Square = {\n  x: number;\n  kind: \"square\";\n};\n\ntype Triangle = {\n  x: number;\n  y: number;\n  kind: \"triangle\";\n};\n\ntype Shape = Circle | Triangle | Square;\n\nfunction area(shape: Shape) {\n  /* ... */\n}\n\nconst circle = {\n  radius: 2,\n  kind: \"circle\",\n};\n\narea(circle);\n//   ^-- Argument of type '{ radius: number; kind: string; '\n//       is not assignable to parameter of type 'Shape'.\n//       Type '{ radius: number; kind: string; }' is not\n//       assignable to type 'Circle'.\n//       Types of property 'kind' are incompatible.\n//       Type 'string' is not assignable to type '\"circle\"'.\n```", "```\n// Exact type\nconst circle: Circle = {\n  radius: 2,\n  kind: \"circle\",\n};\n\narea(circle); // Works!\n\n// Broader set\nconst circle: Shape = {\n  radius: 2,\n  kind: \"circle\",\n};\n\narea(circle); // Also works!\n```", "```\n// Type assertion\nconst circle = {\n  radius: 2,\n  kind: \"circle\",\n} as Circle;\n\narea(circle); // Works!\n```", "```\nconst circle = {\n  radius: 2,\n  kind: \"circle\" as \"circle\",\n};\n\narea(circle); // Works!\n```", "```\nconst circle = {\n  radius: 2,\n  kind: \"circle\" as const,\n};\n\narea(circle); // Works!\n```", "```\nconst circle = {\n  radius: 2,\n  kind: \"circle\",\n} as const;\n\narea2(circle); // Works!\n\ncircle.kind = \"rectangle\";\n//     ^-- Cannot assign to 'kind' because\n//         it is a read-only property.\n```", "```\ntype Dice = 1 | 2 | 3 | 4 | 5 | 6;\n```", "```\nfunction rollDice(input: number) {\n  if ([1, 2, 3, 4, 5, 6].includes(input)) {\n    // `input` is still `number`, even though we know it\n    // should be Dice\n  }\n}\n```", "```\nfunction isDice(value: number): boolean {\n  return [1, 2, 3, 4, 5, 6].includes(value);\n}\n```", "```\nfunction isDice(value: number): value is Dice {\n  return [1, 2, 3, 4, 5, 6].includes(value);\n}\n```", "```\nfunction rollDice(input: number) {\n  if (isDice(input)) {\n    // Great! `input` is now `Dice`\n  } else {\n    // input is still `number`\n  }\n}\n```", "```\ntype Dice = 1 | 2 | 3 | 4 | 5 | 6;\n\nfunction isDice(value: string): value is Dice {\n// Error: A type predicate's type must be assignable to\n// its parameter's type. Type 'number' is not assignable to type 'string'.\n  return [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"].includes(value);\n}\n```", "```\n// Correct on a type-level\n// incorrect set of values on a value-level\nfunction isDice(value: number): value is Dice {\n  return [1, 2, 3, 4, 5, 7].includes(value);\n}\n```", "```\n// Correct on a type-level, incorrect logic\nfunction isDice(value: number): value is Dice {\n  return value >= 1 && value <= 6;\n}\n```", "```\nfunction isDice(value: number): value is Dice {\n  return true;\n}\n```", "```\nfunction iHaveNoReturnValue(i) {\n  console.log(i);\n}\n\nlet check = iHaveNoReturnValue(2);\n// check is undefined\n```", "```\nfunction iHaveNoReturnValue(i) {\n  console.log(i);\n}\n\ntype Fn = typeof iHaveNoReturnValue;\n// type Fn = (i: any) => void\n```", "```\nfunction iTakeNoParameters(x: void): void { }\n\niTakeNoParameters(); // works\niTakeNoParameters(undefined); // works\niTakeNoParameters(void 2); // works\n```", "```\nfunction fetchResults(\n  callback: (statusCode: number, results: number[]) => void\n) {\n  // get results from somewhere ...\n  callback(200, results);\n}\n```", "```\nfunction normalHandler(statusCode: number, results: number[]): void {\n  // do something with both parameters\n}\n\nfetchResults(normalHandler);\n```", "```\nfunction handler(statusCode: number): boolean {\n  // evaluate the status code ...\n  return true;\n}\n\nfetchResults(handler); // compiles, no problem!\n```", "```\nfunction fetchResults(\n  callback: (statusCode: number, results: number[]) => void\n) {\n  // get results from somewhere ...\n  const didItWork = callback(200, results);\n  // didItWork is `undefined` in the type system,\n  // even though it would be a boolean with `handler`.\n}\n```", "```\ntry {\n  // something with the popular fetching library Axios, for example\n} catch(e: AxiosError) {\n//         ^^^^^^^^^^ Error 1196: Catch clause variable\n//                    type annotation must be 'any' or\n//                    'unknown' if specified.\n}\n```", "```\nthrow \"What a weird error\"; // OK\nthrow 404; // OK\nthrow new Error(\"What a weird error\"); // OK\n```", "```\ntry {\n  myroutine(); // There's a couple of errors thrown here\n} catch (e) {\n  if (e instanceof TypeError) {\n    // A TypeError\n  } else if (e instanceof RangeError) {\n    // Handle the RangeError\n  } else if (e instanceof EvalError) {\n    // you guessed it: EvalError\n  } else if (typeof e === \"string\") {\n    // The error is a string\n  } else if (axios.isAxiosError(e)) {\n    // axios does an error check for us!\n  } else {\n    // everything else\n    logMyErrors(e);\n  }\n}\n```", "```\nconst somePromise = () =>\n  new Promise((fulfil, reject) => {\n    if (someConditionIsValid()) {\n      fulfil(42);\n    } else {\n      reject(\"Oh no!\");\n    }\n  });\n\nsomePromise()\n  .then((val) => console.log(val)) // val is number\n  .catch((e) => console.log(e)); // can be anything, really;\n```", "```\ntry {\n  const z = await somePromise(); // z is number\n} catch(e) {\n  // same thing, e can be anything!\n}\n```", "```\nfunction isAxiosError(payload: any): payload is AxiosError {\n  return payload !== null\n    && typeof payload === 'object'\n    && payload.isAxiosError;\n}\n```", "```\ntype SelectBase = {\n  options: string[];\n};\n\ntype SingleSelect = SelectBase & {\n  value: string;\n};\n\ntype MultipleSelect = SelectBase & {\n  values: string[];\n};\n\ntype SelectProperties = SingleSelect | MultipleSelect;\n\nfunction selectCallback(params: SelectProperties) {\n  if (\"value\" in params) {\n    // handle single cases\n  } else if (\"values\" in params) {\n    // handle multiple cases\n  }\n}\n\nselectCallback({\n  options: [\"dracula\", \"monokai\", \"vscode\"],\n  value: \"dracula\",\n});\n\nselectCallback({\n  options: [\"dracula\", \"monokai\", \"vscode\"],\n  values: [\"dracula\", \"vscode\"],\n});\n```", "```\nselectCallback({\n  options: [\"dracula\", \"monokai\", \"vscode\"],\n  values: [\"dracula\", \"vscode\"],\n  value: \"dracula\",\n}); // still works! Which one to choose?\n```", "```\ntype SelectBase = {\n  options: string[];\n};\n\ntype SingleSelect = SelectBase & {\n  value: string;\n  values?: never;\n};\n\ntype MultipleSelect = SelectBase & {\n  value?: never;\n  values: string[];\n};\n```", "```\nselectCallback({\n  options: [\"dracula\", \"monokai\", \"vscode\"],\n  values: [\"dracula\", \"vscode\"],\n  value: \"dracula\",\n});\n// ^ Argument of type '{ options: string[]; values: string[]; value: string; }'\n//   is not assignable to parameter of type 'SelectProperties'.\n```", "```\ntype Dice = 1 | 2 | 3 | 4 | 5 | 6;\n\nfunction rollDice(): Dice {\n  let num = Math.floor(Math.random() * 6) + 1;\n  return num;\n//^ Type 'number' is not assignable to type 'Dice'.(2322)\n}\n```", "```\n// All dice are numbers\nfunction asNumber(dice: Dice): number {\n  return dice;\n}\n```", "```\ntype Dice = 1 | 2 | 3 | 4 | 5 | 6;\n\nfunction rollDice(): Dice {\n  let num = Math.floor(Math.random() * 6) + 1;\n  return num as Dice;\n}\n```", "```\nfunction asString(num: number): string {\n  return num as string;\n//       ^- Conversion of type 'number' to type 'string' may\n//          be a mistake because neither type sufficiently\n//          overlaps with the other.\n//          If this was intentional, convert the expression to 'unknown' first.\n}\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\nfunction createDemoPerson(name: string) {\n  const person = {} as Person;\n  person.name = name;\n  person.age = Math.floor(Math.random() * 95);\n  return person;\n}\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n  profession: string;\n};\n\nfunction createDemoPerson(name: string) {\n  const person = {} as Person;\n  person.name = name;\n  person.age = Math.floor(Math.random() * 95);\n  // Where's Profession?\n  return person;\n}\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\nfunction createDemoPerson(name: string) {\n  const person: Person = {\n    name,\n    age: Math.floor(Math.random() * 95),\n  };\n  return person;\n}\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\nconst ppl: Person[] = await fetch(\"/api/people\").then((res) => res.json());\n```", "```\nconst ppl = await fetch(\"/api/people\").then((res) => res.json()) as Person[];\n```", "```\nconst timings = {\n  \"fettblog.eu\": {\n    ttfb: 300,\n    fcp: 1000,\n    si: 1200,\n    lcp: 1500,\n    tti: 1100,\n    tbt: 10,\n  },\n  \"typescript-book.com\": {\n    ttfb: 400,\n    fcp: 1100,\n    si: 1100,\n    lcp: 2200,\n    tti: 1100,\n    tbt: 0,\n  },\n};\n```", "```\nfunction findLowestTiming(collection, metric) {\n  let result = {\n    domain: \"\",\n    value: Number.MAX_VALUE,\n  };\n  for (const domain in collection) {\n    const timing = collection[domain];\n    if (timing[metric] < result.value) {\n      result.domain = domain;\n      result.value = timing[metric];\n    }\n  }\n  return result.domain;\n}\n```", "```\ntype Metrics = {\n  // Time to first byte\n  ttfb: number;\n  // First contentful paint\n  fcp: number;\n  // Speed Index\n  si: number;\n  // Largest contentful paint\n  lcp: number;\n  // Time to interactive\n  tti: number;\n  // Total blocking time\n  tbt: number;\n};\n```", "```\ntype MetricCollection = {\n  [domain: string]: Timings;\n};\n```", "```\nfunction findLowestTiming(\n  collection: MetricCollection,\n  key: keyof Metrics\n): string {\n  let result = {\n    domain: \"\",\n    value: Number.MAX_VALUE,\n  };\n  for (const domain in collection) {\n    const timing = collection[domain];\n    if (timing[key] < result.value) {\n      result.domain = domain;\n      result.value = timing[key];\n    }\n  }\n  return result.domain;\n}\n```", "```\nconst emptySet: MetricCollection = {};\nlet timing = emptySet[\"typescript-cookbook.com\"].fcp * 2; // No type errors!\n```", "```\ntype MetricCollection = {\n  [domain: string]: Metrics | undefined;\n};\n\nfunction findLowestTiming(\n  collection: MetricCollection,\n  key: keyof Metrics\n): string {\n  let result = {\n    domain: \"\",\n    value: Number.MAX_VALUE,\n  };\n  for (const domain in collection) {\n    const timing = collection[domain]; // Metrics | undefined\n    // extra check for undefined values\n    if (timing && timing[key] < result.value) {\n      result.domain = domain;\n      result.value = timing[key];\n    }\n  }\n  return result.domain;\n}\n\nconst emptySet: MetricCollection = {};\n// access with optional chaining and nullish coalescing\nlet timing = (emptySet[\"typescript-cookbook.com\"]?.fcp ?? 0) * 2;\n```", "```\ntype MetricCollection = {\n  [domain in string]?: Metrics;\n};\n```", "```\ntype Throws = {\n  [x in 1 | 2 | 3 | 4 | 5 | 6]: number;\n};\n```", "```\ntype ElementCollection = {\n  [y: number]: HTMLElement | undefined;\n  get(index: number): HTMLElement | undefined;\n  length: number;\n  filter(callback: (element: HTMLElement) => boolean): ElementCollection;\n};\n```", "```\ntype StringDictionary = {\n  [index: string]: string;\n  count: number;\n  // Error: Property 'count' of type 'number' is not assignable\n  // to 'string' index type 'string'.(2411)\n};\n```", "```\ntype StringOrNumberDictionary = {\n  [index: string]: string | number;\n  count: number; // works\n};\n```", "```\ntype Settings = {\n  language: \"en\" | \"de\" | \"fr\";\n  theme?: \"dracula\" | \"monokai\" | \"github\";\n};\n```", "```\nfunction applySettings(settings: Settings) {\n  // theme is \"dracula\" | \"monokai\" | \"github\" | undefined\n  const theme = settings.theme;\n}\n```", "```\nfunction getTheme(settings: Settings) {\n  if ('theme' in settings) { // only true if the property is set!\n    return settings.theme;\n  }\n  return 'default';\n}\n\nconst settings: Settings = {\n  language: \"de\",\n};\n\nconst settingsUndefinedTheme: Settings = {\n  language: \"de\",\n  theme: undefined,\n};\n\nconsole.log(getTheme(settings)) // \"default\"\nconsole.log(getTheme(settingsUndefinedTheme)) // undefined\n```", "```\ntype Fn = typeof getTheme;\n// type Fn = (settings: Settings)\n//   => \"dracula\" | \"monokai\" | \"github\" | \"default\" | undefined\n```", "```\nfunction getTheme(settings: Settings) {\n  return settings.theme ?? \"default\";\n}\n\ntype Fn = typeof getTheme;\n// type Fn = (settings: Settings)\n//   => \"dracula\" | \"monokai\" | \"github\" | \"default\"\n```", "```\n// exactOptionalPropertyTypes is true\nconst settingsUndefinedTheme: Settings = {\n  language: \"de\",\n  theme: undefined,\n};\n\n// Error: Type '{ language: \"de\"; theme: undefined; }' is\n// not assignable to type 'Settings' with 'exactOptionalPropertyTypes: true'.\n// Consider adding 'undefined' to the types of the target's properties.\n// Types of property 'theme' are incompatible.\n// Type 'undefined' is not assignable to type\n// '\"dracula\" | \"monokai\" | \"github\"'.(2375)\n```", "```\nenum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n};\n```", "```\n// used as type\nfunction move(direction: Direction) {\n  // ...\n}\n\n// used as value\nmove(Direction.Up);\n```", "```\nvar Direction;\n(function (Direction) {\n    Direction[Direction[\"Up\"] = 0] = \"Up\";\n    Direction[Direction[\"Down\"] = 1] = \"Down\";\n    Direction[Direction[\"Left\"] = 2] = \"Left\";\n    Direction[Direction[\"Right\"] = 3] = \"Right\";\n})(Direction || (Direction = {}));\n```", "```\nconst enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n};\n\n// When having a const enum, TypeScript\n// transpiles move(Direction.Up) to this:\nmove(0 /* Direction.Up */);\n```", "```\n// Default\nenum Direction {\n  Up, // 0\n  Down, // 1\n  Left, // 2\n  Right, // 3\n};\n\nenum Direction {\n  Up = 1,    // 1\n  Down,      // 2\n  Left,      // 3\n  Right = 5, // 5\n};\n```", "```\ntype Direction = 0 | 1 | 2 | 3;\n```", "```\nfunction move(direction: Direction) { /* ... */ }\n\nmove(30);// This is  ok!\n```", "```\n// Possible traits of a person, can be multiple\nenum Traits {\n  None,              // 0000\n  Friendly = 1,      // 0001 or 1 << 0\n  Mean     = 1 << 1, // 0010\n  Funny    = 1 << 2, // 0100\n  Boring   = 1 << 3, // 1000\n}\n\n// (0010 | 0100) === 0110\nlet aPersonsTraits = Traits.Mean | Traits.Funny;\n\nif ((aPersonsTraits & Traits.Mean) === Traits.Mean) {\n  // Person is mean, amongst other things\n}\n```", "```\nenum Status {\n  Admin = \"Admin\",\n  User = \"User\",\n  Moderator = \"Moderator\",\n};\n```", "```\nfunction closeThread(threadId: number, status: Status): {\n  // ...\n}\n\ncloseThread(10, \"Admin\");\n//              ^-- Argument of type '\"Admin\"' is not assignable to\n//                  parameter of type 'Status'\n\ncloseThread(10, Status.Admin); // This works\n```", "```\nenum Roles {\n  Admin = \"Admin\",\n  User = \"User\",\n  Moderator = \"Moderator\",\n};\n\ncloseThread(10, Roles.Admin);\n//              ^-- Argument of type 'Roles.Admin' is not\n//                  assignable to parameter of type 'Status'\n```", "```\ntype Status = \"Admin\" | \"User\" | \"Moderator\";\n\nfunction closeThread(threadId: number, status: Status) {\n  // ...\n}\n\ncloseThread(10, \"Admin\"); // All good\n```", "```\nconst Direction = {\n  Up: 0,\n  Down: 1,\n  Left: 2,\n  Right: 3,\n} as const;\n\n// Get to the const values of Direction\ntype Direction = (typeof Direction)[keyof typeof Direction];\n\n// (typeof Direction)[keyof typeof Direction] yields 0 | 1 | 2 | 3\nfunction move(direction: Direction) {\n  // ...\n}\n\nmove(30); // This breaks!\n\nmove(0); //This works!\n\nmove(Direction.Left); // This also works!\n```", "```\n// = 0 | 1 | 2 | 3\ntype Direction = (typeof Direction)[keyof typeof Direction];\n```", "```\ntype Person = {\n  name: string;\n  age: number;\n};\n\ntype Student = {\n  name: string;\n  age: number;\n};\n\nfunction acceptsPerson(person: Person) {\n  // ...\n}\n\nconst student: Student = {\n  name: \"Hannah\",\n  age: 27,\n};\n\nacceptsPerson(student); // all ok\n```", "```\nclass Balance {\n  private kind = \"balance\";\n  value: number;\n\n  constructor(value: number) {\n    this.value = value;\n  }\n}\n\nclass AccountNumber {\n  private kind = \"account\";\n  value: number;\n\n  constructor(value: number) {\n    this.value = value;\n  }\n}\n```", "```\nclass Balance {\n  private _nominal: void = undefined;\n  value: number;\n\n  constructor(value: number) {\n    this.value = value;\n  }\n}\n\nclass AccountNumber {\n  private _nominal: void = undefined;\n  value: number;\n\n  constructor(value: number) {\n    this.value = value;\n  }\n}\n\nconst account = new AccountNumber(12345678);\nconst balance = new Balance(10000);\n\nfunction acceptBalance(balance: Balance) {\n  // ...\n}\n\nacceptBalance(balance); // ok\nacceptBalance(account);\n// ^ Argument of type 'AccountNumber' is not\n//   assignable to parameter of type 'Balance'.\n//   Types have separate declarations of a\n//    private property '_nominal'.(2345)\n```", "```\ntype Credits = number & { _kind: \"credits\" };\n\ntype AccountNumber = number & { _kind: \"accountNumber\" };\n\nconst account = 12345678 as AccountNumber;\nlet balance = 10000 as Credits;\nconst amount = 3000 as Credits;\n\nfunction increase(balance: Credits, amount: Credits): Credits {\n  return (balance + amount) as Credits;\n}\n\nbalance = increase(balance, amount);\nbalance = increase(balance, account);\n// ^ Argument of type 'AccountNumber' is not\n//   assignable to parameter of type 'Credits'.\n//   Type 'AccountNumber' is not assignable to type '{ _kind: \"credits\"; }'.\n//   Types of property '_kind' are incompatible.\n//   Type '\"accountNumber\"' is not assignable to type '\"credits\"'.(2345)\n```", "```\nconst result = balance + amount; // result is number\nconst credits = (balance + amount) as Credits; // credits is Credits\n```", "```\n// Hypothetical code, this does not work!\ntype Balance = unique number;\ntype AccountNumber = unique number;\n```", "```\ntype Entry = {\n    // tbd.\n};\n\nfunction retrieve(contentType: string): Entry[] {\n    // tbd.\n}\n```", "```\ntype ContentType = \"post\" | \"page\" | \"asset\" | string;\n\nfunction retrieve(content: ContentType): Entry[] {\n  // tbd\n}\n```", "```\ntype ContentType = \"post\" | \"page\" | \"asset\" | string & {};\n```"]