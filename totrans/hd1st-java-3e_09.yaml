- en: 'Chapter 7\. Better Living in Objectville: Inheritance and Polymorphism'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0167-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Plan your programs with the future in mind.** If there were a way to write
    Java code such that you could take more vacations, how much would it be worth
    to you? What if you could write code that someone *else* could extend, **easily**?
    And if you could write code that was flexible, for those pesky last-minute spec
    changes, would that be something you’d be interested in? Then this is your lucky
    day. For just three easy payments of 60 minutes time, you can have all this. When
    you get on the Polymorphism Plan, you’ll learn the 5 steps to better class design,
    the 3 tricks to polymorphism, the 8 ways to make flexible code, and if you act
    now—a bonus lesson on the 4 tips for exploiting inheritance. Don’t delay, an offer
    this good will give you the design freedom and programming flexibility you deserve.
    It’s quick, it’s easy, and it’s available now. Start today, and we’ll throw in
    an extra level of abstraction!'
  prefs: []
  type: TYPE_NORMAL
- en: Chair Wars Revisited...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '***Remember way back in [Chapter 2](ch02.xhtml#a_trip_to_objectville_classes_and_object),
    when Laura (procedural programmer) and Brad (OO developer) were vying for the
    Aeron chair? Let’s look at a few pieces of that story to review the basics of
    inheritance.***'
  prefs: []
  type: TYPE_NORMAL
- en: '**LAURA:** You’ve got duplicated code! The rotate procedure is in all four
    Shape things. It’s a stupid design. You have to maintain four different rotate
    “methods.” How can that ever be good?'
  prefs: []
  type: TYPE_NORMAL
- en: '**BRAD:** Oh, I guess you didn’t see the final design. Let me show you how
    OO **inheritance** works, Laura.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0168-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You can read this as **“Square inherits from Shape”, “Circle inherits from Shape”**
    and so on. I removed rotate() and playSound() from the other shapes, so now there’s
    only one copy to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: The Shape class is called the **superclass** of the other four classes. The
    other four are the **subclasses** of Shape. The subclasses inherit the methods
    of the superclass. In other words, *if the Shape class has the functionality,
    then the subclasses automatically get that same functionality.*
  prefs: []
  type: TYPE_NORMAL
- en: What about the Amoeba rotate()?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0169-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**LAURA:** Wasn’t that the whole problem here—that the Amoeba shape had a completely
    different rotate and playSound procedure?'
  prefs: []
  type: TYPE_NORMAL
- en: How can Amoeba do something different if it *inherits* its functionality from
    the Shape class?
  prefs: []
  type: TYPE_NORMAL
- en: '**BRAD:** That’s the last step. The Amoeba class ***overrides*** any methods
    of the Shape class that need specific amoeba behavior. Then at runtime, the JVM
    knows exactly which rotate() method to run when someone tells the Amoeba to rotate.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0169-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Understanding Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you design with inheritance, you put common code in a class and then tell
    other more specific classes that the common (more abstract) class is their superclass.
    When one class inherits from another, **the subclass inherits from the superclass.**
  prefs: []
  type: TYPE_NORMAL
- en: In Java, we say that the **subclass *extends* the superclass**. An inheritance
    relationship means that the subclass inherits the **members** of the superclass.
    When we say “members of a class,” we mean the instance variables and methods.
    For example if PantherMan is a subclass of SuperHero, the PantherMan class automatically
    inherits the instance variables and methods common to all superheroes including
    `suit, tights, specialPower, useSpecialPower()`, and so on. But the PantherMan
    **subclass can add new methods and instance variables of its own, and it can override
    the methods it inherits from the superclass** SuperHero.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0170-01.png)'
  prefs: []
  type: TYPE_IMG
- en: FriedEggMan doesn’t need any behavior that’s unique, so he doesn’t override
    any methods. The methods and instance variables in SuperHero are sufficient. PantherMan,
    though, has specific requirements for his suit and special powers, so `useSpecialPower()`
    and `putOnSuit()` are both overridden in the PantherMan class.
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance variables are not overridden** because they don’t need to be. They
    don’t define any special behavior, so a subclass can give an inherited instance
    variable any value it chooses. PantherMan can set his inherited `tights` to purple,
    while FriedEggMan sets his to white.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An inheritance example:'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0171-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s design the inheritance tree for an Animal simulation program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine you’re asked to design a simulation program that lets the user throw
    a bunch of different animals into an environment to see what happens. We don’t
    have to code the thing now; we’re mostly interested in the design.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been given a list of *some* of the animals that will be in the program,
    but not all. We know that each animal will be represented by an object and that
    the objects will move around in the environment, doing whatever it is that each
    particular type is programmed to do.
  prefs: []
  type: TYPE_NORMAL
- en: '***And we want other programmers to be able to add new kinds of animals to
    the program at any time.***'
  prefs: []
  type: TYPE_NORMAL
- en: First we have to figure out the common, abstract characteristics that all animals
    have, and build those characteristics into a class that all animal classes can
    extend.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circlea.png) Look for objects that have common attributes
    and behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What do these six types have in common? This helps you to abstract out behaviors.
    (step 2)**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**How are these types related? This helps you to define the inheritance tree
    relationships (steps 4-5)**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0172-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Using inheritance to avoid duplicating code in subclasses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have five ***instance variables:***
  prefs: []
  type: TYPE_NORMAL
- en: '***picture*** – the filename representing the JPEG of this animal.'
  prefs: []
  type: TYPE_NORMAL
- en: '***food*** – the type of food this animal eats. Right now, there can be only
    two values: *meat* or *grass*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***hunger*** – an int representing the hunger level of the animal. It changes
    depending on when (and how much) the animal eats.'
  prefs: []
  type: TYPE_NORMAL
- en: '***boundaries*** – values representing the height and width of the “space”
    (for example, 640 x 480) that the animals will roam around in.'
  prefs: []
  type: TYPE_NORMAL
- en: '***location*** – the X and Y coordinates for where the animal is in the space.'
  prefs: []
  type: TYPE_NORMAL
- en: We have four ***methods:***
  prefs: []
  type: TYPE_NORMAL
- en: '***makeNoise()*** – behavior for when the animal is supposed to make noise.'
  prefs: []
  type: TYPE_NORMAL
- en: '***eat()*** – behavior for when the animal encounters its preferred food source,
    *meat* or *grass*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***sleep()*** – behavior for when the animal is considered asleep.'
  prefs: []
  type: TYPE_NORMAL
- en: '***roam()*** – behavior for when the animal is not eating or sleeping (probably
    just wandering around waiting to bump into a food source or a boundary).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circleb.png) Design a class that represents the common state
    and behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**These objects are all animals, so we’ll make a common superclass called Animal.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**We’ll put in methods and instance variables that all animals might need.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0173-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Do all animals eat the same way?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Assume that we all agree on one thing: the instance variables will work for
    *all* Animal types. A lion will have his own value for picture, food (we’re thinking
    *meat*), hunger, boundaries, and location. A hippo will have different *values*
    for his instance variables, but he’ll still have the same variables that the other
    Animal types have. Same with dog, tiger, and so on. But what about *behavior*?'
  prefs: []
  type: TYPE_NORMAL
- en: Which methods should we override?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Does a lion make the same **noise** as a dog? Does a cat **eat** like a hippo?
    Maybe in *your* version, but in ours, eating and making noise are Animal-type-specific.
    We can’t figure out how to code those methods in such a way that they’d work for
    any animal. OK, that’s not true. We could write the makeNoise() method, for example,
    so that all it does is play a sound file defined in an instance variable for that
    type, but that’s not very specialized. Some animals might make different noises
    for different situations (like one for eating, and another when bumping into an
    enemy, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: So just as with the Amoeba overriding the Shape class rotate() method, to get
    more amoeba-specific (in other words, *unique*) behavior, we’ll have to do the
    same for our Animal subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circlec.png) Decide if a subclass needs behaviors (method
    implementations) that are specific to that particular subclass type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Looking at the Animal class, we decide that eat() and makeNoise() should
    be overridden by the individual subclasses.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0174-01.png)![image](Images/f0174-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking for more inheritance opportunities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The class hierarchy is starting to shape up. We have each subclass override
    the *makeNoise()* and *eat()* methods so that there’s no mistaking a Dog bark
    from a Cat meow (quite insulting to both parties). And a Hippo won’t eat like
    a Lion.
  prefs: []
  type: TYPE_NORMAL
- en: But perhaps there’s more we can do. We have to look at the subclasses of Animal
    and see if two or more can be grouped together in some way, and given code that’s
    common to only *that* new group. Wolf and Dog have similarities. So do Lion, Tiger,
    and Cat.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circled.png) Look for more opportunities to use abstraction,
    by finding two or more *subclasses* that might need common behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**We look at our classes and see that Wolf and Dog might have some behavior
    in common, and the same goes for Lion, Tiger, and Cat.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0175-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1circlee.png) Finish the class hierarchy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since animals already have an organizational hierarchy (the whole kingdom, genus,
    phylum thing), we can use the level that makes the most sense for class design.
    We’ll use the biological “families” to organize the animals by making a Feline
    class and a Canine class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**We decide that Canines could use a common roam() method, because they tend
    to move in packs. We also see that Felines could use a common roam() method, because
    they tend to avoid others of their own kind. We’ll let Hippo continue to use its
    inherited roam() method— the generic one it gets from Animal.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**So we’re done with the design for now; we’ll come back to it later in the
    chapter.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0176-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Which method is called?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Wolf class has four methods. One inherited from Animal, one inherited from
    Canine (which is actually an overridden version of a method in class Animal),
    and two overridden in the Wolf class. When you create a Wolf object and assign
    it to a variable, you can use the dot operator on that reference variable to invoke
    all four methods. But which *version* of those methods gets called?
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0177-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you call a method on an object reference, you’re calling the most specific
    version of the method for that object type.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, ***the lowest one wins!***
  prefs: []
  type: TYPE_NORMAL
- en: “Lowest” meaning lowest on the inheritance tree. Canine is lower than Animal,
    and Wolf is lower than Canine, so invoking a method on a reference to a Wolf object
    means the JVM starts looking first in the Wolf class. If the JVM doesn’t find
    a version of the method in the Wolf class, it starts walking back up the inheritance
    hierarchy until it finds a match.
  prefs: []
  type: TYPE_NORMAL
- en: Designing an Inheritance Tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0178-02.png)![image](Images/f0178-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Using IS-A and HAS-A
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0179-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Remember that when one class inherits from another, we say that the subclass
    *extends* the superclass. When you want to know if one thing should extend another,
    apply the IS-A test.
  prefs: []
  type: TYPE_NORMAL
- en: Triangle IS-A Shape, yeah, that works.
  prefs: []
  type: TYPE_NORMAL
- en: Cat IS-A Feline, that works too.
  prefs: []
  type: TYPE_NORMAL
- en: Surgeon IS-A Doctor, still good.
  prefs: []
  type: TYPE_NORMAL
- en: Tub extends Bathroom, sounds reasonable.
  prefs: []
  type: TYPE_NORMAL
- en: '*Until you apply the IS-A test.*'
  prefs: []
  type: TYPE_NORMAL
- en: To know if you’ve designed your types correctly, ask, “Does it make sense to
    say type X IS-A type Y?” If it doesn’t, you know there’s something wrong with
    the design, so if we apply the IS-A test, Tub IS-A Bathroom is definitely false.
  prefs: []
  type: TYPE_NORMAL
- en: What if we reverse it to Bathroom extends Tub? That still doesn’t work, Bathroom
    IS-A Tub doesn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: Tub and Bathroom *are* related, but not through inheritance. Tub and Bathroom
    are joined by a HAS-A relationship. Does it make sense to say “Bathroom HAS-A
    Tub”? If yes, then it means that Bathroom has a Tub instance variable. In other
    words, Bathroom has a *reference* to a Tub, but Bathroom does not *extend* Tub
    and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0179-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Bathroom HAS-A Tub and Tub HAS-A Bubbles.
  prefs: []
  type: TYPE_NORMAL
- en: But nobody inherits from (extends) anybody else.
  prefs: []
  type: TYPE_NORMAL
- en: But wait! There’s more!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The IS-A test works *anywhere* in the inheritance tree. If your inheritance
    tree is well-designed, the IS-A test should make sense when you ask *any* subclass
    if it IS-A *any* of its supertypes.
  prefs: []
  type: TYPE_NORMAL
- en: '**If class B extends class A, class B IS-A class A.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**This is true anywhere in the inheritance tree. If class C extends class B,
    class C passes the IS-A test for both B *and* A.**'
  prefs: []
  type: TYPE_NORMAL
- en: Canine extends Animal
  prefs: []
  type: TYPE_NORMAL
- en: Wolf extends Canine
  prefs: []
  type: TYPE_NORMAL
- en: Wolf extends Animal
  prefs: []
  type: TYPE_NORMAL
- en: Canine IS-A Animal
  prefs: []
  type: TYPE_NORMAL
- en: Wolf IS-A Canine
  prefs: []
  type: TYPE_NORMAL
- en: Wolf IS-A Animal
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0180-01.png)'
  prefs: []
  type: TYPE_IMG
- en: With an inheritance tree like the one shown here, you’re always allowed to say
    **“Wolf extends Animal”** or **“Wolf IS-A Animal.”** It makes no difference if
    Animal is the superclass of the superclass of Wolf. In fact, **as long as Animal
    is *somewhere* in the inheritance hierarchy above Wolf, Wolf IS-A Animal will
    always be true.**
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of the Animal inheritance tree says to the world:'
  prefs: []
  type: TYPE_NORMAL
- en: “Wolf IS-A Canine, so Wolf can do anything a Canine can do. And Wolf IS-A Animal,
    so Wolf can do anything an Animal can do.”
  prefs: []
  type: TYPE_NORMAL
- en: It makes no difference if Wolf overrides some of the methods in Animal or Canine.
    As far as the world (of other code) is concerned, a Wolf can do those four methods.
    *How* he does them, or *in which class they’re overridden*, makes no difference.
    A Wolf can makeNoise(), eat(), sleep(), and roam() because a Wolf extends from
    class Animal.
  prefs: []
  type: TYPE_NORMAL
- en: How do you know if you’ve got your inheritance right?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s obviously more to it than what we’ve covered so far, but we’ll look
    at a lot more OO issues in the next chapter (where we eventually refine and improve
    on some of the design work we did in *this* chapter).
  prefs: []
  type: TYPE_NORMAL
- en: For now, though, a good guideline is to use the IS-A test. If “X IS-A Y” makes
    sense, both classes (X and Y) should probably live in the same inheritance hierarchy.
    Chances are, they have the same or overlapping behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Keep in mind that the inheritance IS-A relationship works in only *one* direction!**'
  prefs: []
  type: TYPE_NORMAL
- en: Triangle IS-A Shape makes sense, so you can have Triangle extend Shape.
  prefs: []
  type: TYPE_NORMAL
- en: But the reverse—Shape IS-A Triangle—does *not* make sense, so Shape should not
    extend Triangle. Remember that the IS-A relationship implies that if X IS-A Y,
    then X can do anything a Y can do (and possibly more).
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arr1.png) **Yours to solve.**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Hint: apply the IS-A test*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Who ge ts the Porsche, who ge ts the porcelain? (how to know what a subclass
    can inherit from it’s superclass)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0182-02.png)'
  prefs: []
  type: TYPE_IMG
- en: A subclass inherits members of the superclass. Members include instance variables
    and methods, although later in this book we’ll look at other inherited members.
    A superclass can choose whether or not it wants a subclass to inherit a particular
    member by the level of access the particular member is given.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four access levels that we’ll cover in this book. Moving from most
    restrictive to least, the four access levels are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0182-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Access levels control *who sees what***, and are crucial to having well-designed,
    robust Java code. For now we’ll focus just on public and private. The rules are
    simple for those two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When a subclass inherits a member, it is ***as if the subclass defined the member
    itself***. In the Shape example, Square inherited the `rotate()` and `playSound()`
    methods and to the outside world (other code) the Square class simply has a `rotate()`
    and `playSound()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The members of a class include the variables and methods defined in the class
    plus anything inherited from a superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Note: get more details about default and protected in [Appendix B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d).'
  prefs: []
  type: TYPE_NORMAL
- en: When designing with inheritance, are you using or abusing?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although some of the reasons behind these rules won’t be revealed until later
    in this book, for now, simply *knowing* a few rules will help you build a better
    inheritance design.
  prefs: []
  type: TYPE_NORMAL
- en: '**DO** use inheritance when one class *is* a more specific type of a superclass.
    Example: Willow is a more specific type of Tree, so Willow *extends* Tree makes
    sense.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DO** consider inheritance when you have behavior (implemented code) that
    should be shared among multiple classes of the same general type. Example: Square,
    Circle, and Triangle all need to rotate and play sound, so putting that functionality
    in a superclass Shape might make sense and makes for easier maintenance and extensibility.
    Be aware, however, that while inheritance is one of the key features of object-oriented
    programming, it’s not necessarily the best way to achieve behavior reuse. It’ll
    get you started, and often it’s the right design choice, but design patterns will
    help you see other more subtle and flexible options. If you don’t know about design
    patterns, a good follow-on to this book would be *Head First Design Patterns.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**DO NOT** use inheritance just so that you can reuse code from another class,
    if the relationship between the superclass and subclass violate either of the
    above two rules. For example, imagine you wrote special printing code in the Animal
    class and now you need printing code in the Potato class. You might think about
    making Potato extend Animal so that Potato inherits the printing code. That makes
    no sense! A Potato is *not* an Animal! (So the printing code should be in a Printer
    class that all printable objects can take advantage of via a HAS-A relationship.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DO NOT** use inheritance if the subclass and superclass do not pass the IS-A
    test. Always ask yourself if the subclass IS-A more specific type of the superclass.
    Example: Tea IS-A Beverage makes sense. Beverage IS-A Tea does not.'
  prefs: []
  type: TYPE_NORMAL
- en: So what does all this inheritance really buy you?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You get a lot of OO mileage by designing with inheritance. You can get rid
    of duplicate code by abstracting out the behavior common to a group of classes,
    and sticking that code in a superclass. That way, when you need to modify it,
    you have only one place to update, and *the change is magically reflected in all
    the classes that inherit that behavior.* Well, there’s no magic involved, but
    it is pretty simple: make the change and compile the class again. That’s it. **You
    don’t have to touch the subclasses!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Just deliver the newly changed superclass, and all classes that extend it
    will automatically use the new version.**'
  prefs: []
  type: TYPE_NORMAL
- en: A Java program is nothing but a pile of classes, so the subclasses don’t have
    to be recompiled in order to use the new version of the superclass. As long as
    the superclass doesn’t *break* anything for the subclass, everything’s fine. (We’ll
    discuss what the word “break” means in this context later in the book. For now,
    think of it as modifying something in the superclass that the subclass is depending
    on, like a particular method’s arguments, return type, method name, etc.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1circlea.png) **You avoid duplicate code.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put common code in one place, and let the subclasses inherit that code from
    a superclass. When you want to change that behavior, you have to modify it in
    only one place, and everybody else (i.e., all the subclasses) sees the change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/1circleb.png) **You define a common protocol for a group of
    classes.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0184-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Inheritance lets you guarantee that all classes grouped under a certain supertype
    have all the methods that the supertype has*
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**In other words, you define a common protocol for a set of classes related
    through inheritance.**'
  prefs: []
  type: TYPE_NORMAL
- en: When you define methods in a superclass that can be inherited by subclasses,
    you’re announcing a kind of protocol to other code that says, “All my subtypes
    (i.e., subclasses) can do these things, with these methods that look like this...”
  prefs: []
  type: TYPE_NORMAL
- en: In other words, you establish a *contract.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Class Animal establishes a common protocol for all Animal subtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0185-01.png)'
  prefs: []
  type: TYPE_IMG
- en: And remember, when we *say any Animal*, we mean Animal *and any class that extends
    from Animal*. That again means, *any class that has Animal somewhere above it
    in the inheritance hierarchy.*
  prefs: []
  type: TYPE_NORMAL
- en: But we’re not even at the really cool part yet, because we saved the best—*polymorphism*—for
    last.
  prefs: []
  type: TYPE_NORMAL
- en: When you define a supertype for a group of classes, *any subclass of that supertype
    can be substituted where the supertype is expected.*
  prefs: []
  type: TYPE_NORMAL
- en: Say, what?
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry, we’re nowhere near done explaining it. Two pages from now, you’ll
    be an expert.
  prefs: []
  type: TYPE_NORMAL
- en: '**And I care because...**'
  prefs: []
  type: TYPE_NORMAL
- en: You get to take advantage of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: '**Which matters to me because...**'
  prefs: []
  type: TYPE_NORMAL
- en: You get to refer to a subclass object using a reference declared as the supertype.
  prefs: []
  type: TYPE_NORMAL
- en: '**And that means to me...**'
  prefs: []
  type: TYPE_NORMAL
- en: You get to write really flexible code. Code that’s cleaner (more efficient,
    simpler). Code that’s not just easier to *develop*, but also much, much easier
    to *extend*, in ways you never imagined at the time you originally wrote your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: That means you can take that tropical vacation while your co-workers update
    the program, and your co-workers might not even need your source code.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see how it works on the next page.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t know about you, but personally, we find the whole tropical vacation
    thing particularly motivating.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0185-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '* When we say “all the methods,” we mean “all the inheritable methods,” which
    for now actually means “all the *public* methods,” although later we’ll refine
    that definition a bit more.'
  prefs: []
  type: TYPE_NORMAL
- en: '**To see how polymorphism works, we have to step back and look at the way we
    normally declare a reference and create an object...**'
  prefs: []
  type: TYPE_NORMAL
- en: '**The 3 steps of object declaration and assignment**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0186-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1circlea.png) **Declare a reference variable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tells the JVM to allocate space for a reference variable. The reference variable
    is, forever, of type Dog. In other words, a remote control that has buttons to
    control a Dog, but not a Cat or a Button or a Socket.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0186-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/1circleb.png) **Create an object**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tells the JVM to allocate space for a new Dog object on the garbage collectible
    heap.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0186-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/1circlec.png) **Link the object and the reference**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Assigns the new Dog to the reference variable myDog. In other words, ***program
    the remote control.***
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0186-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The important point is that the reference type AND the object type are the
    same.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**In this example, both are Dog.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0187-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**But with polymorphism, the reference type and the object type can be *different.***'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0187-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**With polymorphism, the reference type can be a superclass of the actual object
    type.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0188-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When you declare a reference variable, any object that passes the IS-A test
    for the type of the reference can be assigned to that variable. In other words,
    anything that *extends* the declared reference variable type can be *assigned*
    to the reference variable. ***This lets you do things like make polymorphic arrays.***
  prefs: []
  type: TYPE_NORMAL
- en: '**OK, OK maybe an example will help.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0188-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**But wait! There’s more!**'
  prefs: []
  type: TYPE_NORMAL
- en: '**You can have polymorphic arguments and return types.**'
  prefs: []
  type: TYPE_NORMAL
- en: If you can declare a reference variable of a supertype, say, Animal, and assign
    a subclass object to it, say, Dog, think of how that might work when the reference
    is an argument to a method...
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0189-01.png)![image](Images/f0190-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**With polymorphism, you can write code that doesn’t have to change when you
    introduce new subclass types into the program.**'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Vet class? If you write that Vet class using arguments declared
    as type *Animal*, your code can handle any Animal *subclass*. That means if others
    want to take advantage of your Vet class, all they have to do is make sure *their*
    new Animal types extend class Animal. The Vet methods will still work, even though
    the Vet class was written without any knowledge of the new Animal subtypes the
    Vet will be working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping the contract: rules for overriding'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you override a method from a superclass, you’re agreeing to fulfill the
    contract. The contract that says, for example, “I take no arguments and I return
    a boolean.” In other words, the arguments and return types of your overriding
    method must look to the outside world *exactly* like the overridden method in
    the superclass.
  prefs: []
  type: TYPE_NORMAL
- en: '**The methods *are* the contract.**'
  prefs: []
  type: TYPE_NORMAL
- en: If polymorphism is going to work, the Toaster’s version of the overridden method
    from Appliance has to work at runtime. Remember, the compiler looks at the reference
    type to decide whether you can call a particular method on that reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0192-01.png)'
  prefs: []
  type: TYPE_IMG
- en: With an Appliance reference to a Toaster, the compiler cares only if class *Appliance*
    has the method you’re invoking on an Appliance reference. But at runtime, the
    JVM does not look at the **reference** type (*Appliance*) but at the actual *Toaster*
    **object** on the heap.
  prefs: []
  type: TYPE_NORMAL
- en: So if the compiler has already approved the method call, the only way it can
    work is if the overriding method has the same arguments and return types. Otherwise,
    someone with an Appliance reference will call turnOn() as a no-arg method, even
    though there’s a version in Toaster that takes an int. Which one is called at
    runtime? The one in Appliance. In other words, ***the turnOn(int level) method
    in Toaster is not an override!***
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0192-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1.png) **Arguments must be the same, and return types must
    be compatible.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The contract of superclass defines how other code can use a method. Whatever
    the superclass takes as an argument, the subclass overriding the method must use
    that same argument. And whatever the superclass declares as a return type, the
    overriding method must declare either the same type or a subclass type. Remember,
    a subclass object is guaranteed to be able to do anything its superclass declares,
    so it’s safe to return a subclass where the superclass is expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **The method can’t be less accessible.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That means the access level must be the same, or friendlier. You can’t, for
    example, override a public method and make it private. What a shock that would
    be to the code invoking what it *thinks* (at compile time) is a public method,
    if suddenly at runtime the JVM slammed the door shut because the overriding version
    called at runtime is private!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So far we’ve learned about two access levels: private and public. The other
    two are in [Appendix B](app02.xhtml#appendix_b_the_top_ten-ish_topics_that_d).
    There’s also another rule about overriding related to exception handling, but
    we’ll wait until [Chapter 13](ch13.xhtml#risky_behavior_exception_handling), *Risky
    Behavior*, to cover that.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0192-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Overloading a method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Method overloading is nothing more than having two methods with the same name
    but different argument lists. Period. There’s no polymorphism involved with overloaded
    methods!
  prefs: []
  type: TYPE_NORMAL
- en: Overloading lets you make multiple versions of a method, with different argument
    lists, for convenience to the callers. For example, if you have a method that
    takes only an int, the calling code has to convert, say, a double into an int
    before calling your method. But if you overloaded the method with another version
    that takes a double, then you’ve made things easier for the caller. You’ll see
    more of this when we look into constructors in [Chapter 9](ch09.xhtml#life_and_death_of_an_object_constructors),
    *Life and Death of an Object.*
  prefs: []
  type: TYPE_NORMAL
- en: Since an overloading method isn’t trying to fulfill the polymorphism contract
    defined by its superclass, overloaded methods have much more flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: An overloaded method is just a different method that happens to have the same
    met hod name. It has nothing to do with inheritance and polymorphism. An overloaded
    met hod is NOT the same as an overridden method.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **The return types can be different.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t change ONLY the return type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) **You can’t change ONLY the return type.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If only the return type is different, it’s not a valid over*load*—the compiler
    will assume you’re trying to override the method. And even *that* won’t be legal
    unless the return type is a subtype of the return type declared in the superclass.
    To overload a method, you MUST change the argument list, although you *can* change
    the return type to anything.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/3.png) **You *can* vary the access levels in any direction.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’re free to overload a method with a method that’s more restrictive. It doesn’t
    matter, since the new method isn’t obligated to fulfill the contract of the overloaded
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Legal examples of method overloading:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Mixed Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/common-04.png)'
  prefs: []
  type: TYPE_IMG
- en: A short Java program is listed below. One block of the program is missing! Your
    challenge is to match the candidate block of code (on the left), with the output
    that you’d see if the block were inserted. Not all the lines of output will be
    used, and some of the lines of output might be used more than once. Draw lines
    connecting the candidate blocks of code with their matching command-line output.
  prefs: []
  type: TYPE_NORMAL
- en: '**The program:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0194-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Code candidates:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0194-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Output:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](Images/arr1.png) **Answers in [“Mixed Messages”](#mixed_messages_left_parenthesisfro-id200).**'
  prefs: []
  type: TYPE_NORMAL
- en: BE the Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '****Which of the A-B pairs of methods listed on the right, if inserted into
    the classes on the left, would compile and produce the output shown? (The A method
    inserted into class Monster, the B method inserted into class Vampire.)**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0195-02.png)![image](Images/f0195-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr1.png) **Answers in [“BE the Compiler”](#be_the_compiler_left_parenthesisfro-0001).**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common-04.png)** **# Exercise Solutions'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common-03.png)![image](Images/f0197-01.png)'
  prefs: []
  type: TYPE_IMG
- en: BE the Compiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“BE the Compiler”](#exercise-id000012))
  prefs: []
  type: TYPE_NORMAL
- en: Set 1 **will** work.
  prefs: []
  type: TYPE_NORMAL
- en: Set 2 **will not** compile because of Vampire’s return type (int).
  prefs: []
  type: TYPE_NORMAL
- en: The Vampire’s frighten() method (B) is not a legal override OR overload of Monster’s
    frighten() method. Changing ONLY the return type is not enough to make a valid
    overload, and since an int is not compatible with a boolean, the method is not
    a valid override. (Remember, if you change ONLY the return type, it must be to
    a return type that is compatible with the superclass version’s return type, and
    then it’s an override.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets 3 and 4 **will** compile but produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrrgh`'
  prefs: []
  type: TYPE_NORMAL
- en: '`breathe fire`'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrrgh`'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, class Vampire did not override class Monster’s frighten() method.
    (The frighten() method in Vampire’s set 4 takes a byte, not an int.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Code candidates:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Mixed Messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Mixed Messages”](#mixed_messages-id0100006))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0197-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Pool Puzzle”](#pool_puzzle-id00003))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/common-04.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**OUTPUT:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0198-01.png)**'
  prefs: []
  type: TYPE_NORMAL
