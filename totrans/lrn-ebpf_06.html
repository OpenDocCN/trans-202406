<html><head></head><body><section data-pdf-bookmark="Chapter 6. The eBPF Verifier" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_ebpf_verifier">&#13;
<h1><span class="label">Chapter 6. </span>The eBPF Verifier</h1>&#13;
<p><a contenteditable="false" data-primary="verifier" data-type="indexterm" id="ch06.html0"/>I’ve mentioned the verification step a few times, so you already know that when you load an eBPF program into the kernel, this verification process ensures that the program is safe. In this chapter we’ll dive into how the verifier works to achieve this goal.</p>&#13;
<p>Verification involves checking every possible execution path through the program and ensuring that every instruction is safe. The verifier also makes some updates to the bytecode to ready it for execution. In this chapter I’ll show some examples of verification failures, by starting from an example that works and making modifications that render that code invalid to the verifier.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The example code for this chapter is in the <em>chapter6</em> directory of the repository at <a class="orm:hideurl" href="https://github.com/lizrice/learning-ebpf"><em>github.com/lizrice/learning-ebpf</em></a>.</p>&#13;
</div>&#13;
<p>This chapter doesn’t attempt to cover every possible check the verifier makes. It’s intended to be an overview, with illustrative examples that will help you deal with verification errors that you might run into when writing your own eBPF code.</p>&#13;
<p>One thing to bear in mind is that the verifier works on eBPF bytecode, not directly on the source. That bytecode depends on the output from the compiler. Because of things like compiler optimization, a change in the source code might not always result in exactly what you expect in the bytecode, so correspondingly it might not give you the result you expect in the verifier’s verdict. For example, the verifier will reject unreachable instructions, but the compiler might optimize them away before the verifier sees them.</p>&#13;
<section data-pdf-bookmark="The Verification Process" data-type="sect1"><div class="sect1" id="the_verification_process">&#13;
<h1>The Verification Process</h1>&#13;
<p><a contenteditable="false" data-primary="verifier" data-secondary="verification process" data-type="indexterm" id="ch06.html1"/>The verifier analyzes the program to assess all possible execution paths. It steps through the instructions in order, evaluating them rather than actually executing them. As it goes along it keeps track of the state of each register in a structure called <code>bpf_reg_state</code>. (The registers I’m referring to here are the registers from the eBPF virtual machine that you met in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>.) This structure includes a field called <code>bpf_reg_type</code>, which describes what type of value is held in that register. There are several possible types, including these:</p>&#13;
<ul>&#13;
<li><p><code>NOT_INIT</code>, indicating that the register has not yet been set to a value.</p></li>&#13;
<li><p><code>SCALAR_VALUE</code>, indicating that the register has been set to a value that doesn’t represent a pointer.</p></li>&#13;
<li><p>Several <code>PTR_TO_*</code> types, indicating that the register holds a pointer to something. That something could be, for example:</p>&#13;
<ul>&#13;
<li><p><code>PTR_TO_CTX</code>: The register holds a pointer to the context passed as the argument to a BPF program.</p></li>&#13;
<li><p><code>PTR_TO_PACKET</code>: The register points to a network packet (held in the kernel as  <code>skb-&gt;data</code>).</p></li>&#13;
<li><p><code>PTR_TO_MAP_KEY</code> or <code>PTR_TO_MAP_VALUE</code>: I’m sure you can guess what these mean.</p></li>&#13;
</ul></li>&#13;
</ul>&#13;
<p>There are several other <code>PTR_TO_*</code> types, and you can find the full set enumerated in the <a href="https://oreil.ly/aWb50"><em>linux/bpf.h</em> header file</a>.</p>&#13;
<p>The <code>bpf_reg_state</code> structure also keeps track of the range of possible values the register might hold. This information is used by the verifier to determine when invalid actions are being attempted.</p>&#13;
<p>Each time the verifier comes to a branch, where a decision has to be made on whether to carry on in sequence or jump to a different instruction, the verifier pushes a copy of the current state of all the registers onto a stack and explores one of the possible paths. It continues evaluating the instructions until it reaches the return at the end of the program (or reaches the limit on the number of instructions it will process, which is currently one million instructions<sup><a data-type="noteref" href="ch06.html#ch06fn1" id="ch06fn1-marker">1</a></sup>), at which point it pops a branch off the stack to evaluate next. If it finds an instruction that could result in an invalid operation, it fails verification.</p>&#13;
<p><a contenteditable="false" data-primary="state pruning" data-type="indexterm" id="idm46123196759296"/>Verifying every single possibility could get computationally expensive, so in practice there are optimizations called <em>state pruning</em> that avoid reevaluating paths through the program that are essentially equivalent. As it works through the program, the verifier records the state of all the registers at certain instructions within the program. If it later arrives at the same instruction with registers in a matching state, there is no need to continue to verify the rest of that path, as it’s already known to be valid.</p>&#13;
<p><a href="https://oreil.ly/pQDES">Lots of work has gone into optimizing the verifier</a> and its pruning process. The verifier used to store pruning state before and after each jump instruction, but analysis showed that this results in storing state on average every four instructions or so, and the vast majority of these pruning states would never get matched. It turned out that it’s more efficient to store pruning state every 10 instructions, regardless of branching.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You can read more details on how verification works in the <a href="https://oreil.ly/atNda">kernel documentation</a>.<a contenteditable="false" data-primary="" data-startref="ch06.html1" data-type="indexterm" id="idm46123196754736"/></p>&#13;
</div>&#13;
</div></section>&#13;
<section data-pdf-bookmark="The Verifier Log" data-type="sect1"><div class="sect1" id="the_verifier_log">&#13;
<h1>The Verifier Log</h1>&#13;
<p><a contenteditable="false" data-primary="log, verifier" data-type="indexterm" id="ch06.html2"/><a contenteditable="false" data-primary="verifier" data-secondary="verifier log" data-type="indexterm" id="ch06.html3"/>When the verification of a program fails, the verifier generates a log showing how it reached the conclusion that the program is invalid. If you’re using <code>bpftool prog load</code>, the verifier log gets output to stderr. When you’re writing a program with <em>libbpf</em>, you can use the function <code>libbpf_set_print()</code> to set a handler that will display (or do something else useful with) any errors. (You’ll see an example of this in the <em>hello-verifier.c</em> source code for this chapter.)</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you really want to dig into what the verifier is doing, you can get it to generate the log on success as well as on failure. There is a basic example of this in the <em>hello-verifier.c</em> file too. It involves passing a buffer that will hold verifier log contents into the <em>libbpf</em> call that loads the program into the kernel and then writing the contents of that log to screen.</p>&#13;
</div>&#13;
<p>The verifier log includes a summary of how much work the verifier did, which looks something like this:</p>&#13;
<pre data-type="programlisting">processed 61 insns (limit 1000000) max_states_per_insn 0 total_states 4&#13;
peak_states 4 mark_read 3</pre>&#13;
<p class="pagebreak-before">In this example, the verifier processed 61 instructions, including potentially processing the same instruction multiple times by arriving at it through different paths. Note that the complexity limit of one million is an upper bound on the number of instructions in a program; in practice, if there are branches in the code, the verifier will process some instructions more than once.</p>&#13;
<p>The total number of states stored was four, which for this simple program matches the peak number of stored states. If some of the states had been pruned, the peak number might be lower than the total.</p>&#13;
<p>The log output includes the BPF instructions the verifier has analyzed, along with the corresponding C source code lines (if the object file was built with the <code>-g</code> flag to include debug information) and summaries of verifier state information. Here is an example extract of the verifier log relating to the first few lines of the program in <em>hello-verifier.bpf.c</em>:</p>&#13;
<pre data-type="programlisting">0: (bf) r6 = r1&#13;
; data.counter = c;                                              <a class="co" href="#list_id_6_1" id="code_id_6_1"><img alt="1" src="assets/1.png"/></a>&#13;
1: (18) r1 = 0xffff800008178000&#13;
3: (61) r2 = *(u32 *)(r1 +0)&#13;
 R1_w=map_value(id=0,off=0,ks=4,vs=16,imm=0) R6_w=ctx(id=0,off=0,imm=0) &#13;
 R10=fp0                                                         <a class="co" href="#list_id_6_2" id="code_id_6_2"><img alt="2" src="assets/2.png"/></a>&#13;
; c++; &#13;
4: (bf) r3 = r2&#13;
5: (07) r3 += 1&#13;
6: (63) *(u32 *)(r1 +0) = r3&#13;
 R1_w=map_value(id=0,off=0,ks=4,vs=16,imm=0) R2_w=inv(id=1,umax_value=4294967295,&#13;
 var_off=(0x0; 0xffffffff)) R3_w=inv(id=0,umin_value=1,umax_value=4294967296,&#13;
 var_off=(0x0; 0x1ffffffff)) R6_w=ctx(id=0,off=0,imm=0) R10=fp0  <a class="co" href="#list_id_6_3" id="code_id_6_3"><img alt="3" src="assets/3.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_6_1" id="list_id_6_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>The log includes source code lines to make it easier to understand how the output relates to the source. This source code is available because the <code>-g</code> flag was used to build in debug information during the compilation step.</dd>&#13;
<dt><a class="co" href="#code_id_6_2" id="list_id_6_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>Here’s an example of some register state information being output in the log. It tells us that at this stage Register 1 contains a map value, Register 6 holds the context, and Register 10 is the frame (or stack) pointer where local variables are held.</dd>&#13;
<dt><a class="co" href="#code_id_6_3" id="list_id_6_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>This is another example of register state information. Here you can see not only the types of values that are held in each (initialized) register, but also the range of possible values for Register 2 and Register 3.</dd>&#13;
</dl>&#13;
<p>Let’s dig further into the details of this. I said that Register 6 holds the context, and the verifier log indicates this with <code>R6_w=ctx(id=0,off=0,imm=0)</code>. This was set up in the very first line of the bytecode, where Register 1 was copied to Register 6. When an eBPF program is called, Register 1 always holds the context argument passed to the program. Why copy it to Register 6? Well, when a BPF helper function is called, the arguments to that call are passed in Registers 1 through 5. Helper functions don’t modify the contents of Registers 6 through 9, so saving the context off into Register 6 means the code can call a helper function without losing access to the context.</p>&#13;
<p>Register 0 is used for the return value from a helper function and also for the return value from an eBPF program. Register 10 always holds a pointer to the eBPF stack frame (and the eBPF program can’t modify it).</p>&#13;
<p>Let’s look at the register state information for Registers 2 and 3 after instruction 6:</p>&#13;
<pre data-type="programlisting">R2_w=inv(id=1,umax_value=4294967295,var_off=(0x0; 0xffffffff))&#13;
R3_w=inv(id=0,umin_value=1,umax_value=4294967296,var_off=(0x0; 0x1ffffffff))</pre>&#13;
<p>Register 2 doesn’t have a minimum value, and the <code>umax_value</code> shown here in decimal corresponds to 0xFFFFFFFF, which is the largest value that can be held in an 8-byte register. In other words, at this point the register could hold any of its possible values.</p>&#13;
<p>In instruction 4, the contents of Register 2 are copied into Register 3, and then instruction 5 adds one to that value. Therefore, Register 3 could have any value that’s 1 or greater. You can see this in the state information for Register 3, which has <code>umin_value</code> set to <code>1</code>, and a <code>umax_value</code> of <code>0xFFFFFFFF</code>.</p>&#13;
<p>The verifier uses the information about not just the states of each register, but also the range of values each can contain, to determine the possible paths through the program. This is also used for the state pruning that I mentioned before: if the verifier has been in the same position in the code, with the same types and possible ranges of values for each register, there’s no need to evaluate this path further. What’s more, if the current state is a subset of a state that was seen earlier, it can also be pruned.<a contenteditable="false" data-primary="" data-startref="ch06.html3" data-type="indexterm" id="idm46123196720032"/><a contenteditable="false" data-primary="" data-startref="ch06.html2" data-type="indexterm" id="idm46123196718656"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Visualizing Control Flow" data-type="sect1"><div class="sect1" id="visualizing_control_flow">&#13;
<h1>Visualizing Control Flow</h1>&#13;
<p><a contenteditable="false" data-primary="verifier" data-secondary="visualizing control flow" data-type="indexterm" id="idm46123196715600"/>The verifier explores all the possible paths through the eBPF program, and if you’re trying to debug an issue, it can be helpful to see those paths for yourself. <a contenteditable="false" data-primary="bpftool" data-secondary="visualizing control flow with" data-type="indexterm" id="idm46123196714032"/>The <code>bpftool</code> utility can help with this by producing a control flow graph of the program in <a href="https://oreil.ly/V-1WN">DOT format</a>, which you can then convert into an image format, like this:</p>&#13;
<pre data-type="programlisting">$ bpftool prog dump xlated name kprobe_exec visual &gt; out.dot&#13;
$ dot -Tpng out.dot &gt; out.png</pre>&#13;
<p class="pagebreak-before">This produces a visual representation of the control flow like that shown in <a data-type="xref" href="#extract_from_control_flow_graph_left_pa">Figure 6-1</a>.</p>&#13;
<figure><div class="figure" id="extract_from_control_flow_graph_left_pa">&#13;
<img alt="Extract from control flow graph (the full image can be found as chapter6/kprobe_exec.png in the GitHub repo for this book)" src="assets/lebp_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>Extract from control flow graph (the full image can be found as chapter6/kprobe_exec.png in the <a class="orm:hideurl" href="http://github.com/lizrice/learning-ebpf">GitHub repo</a> for this book)</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Validating Helper Functions" data-type="sect1"><div class="sect1" id="validating_helper_functions">&#13;
<h1>Validating Helper Functions</h1>&#13;
<p><a contenteditable="false" data-primary="verifier" data-secondary="validating helper functions" data-type="indexterm" id="idm46123196703568"/>You’re not allowed to call directly from eBPF programs to any kernel function (unless it has been registered as a kfunc, which you’ll meet in the next chapter), but eBPF provides a number of helper functions that enable programs to access information from the kernel. There’s a <a href="https://oreil.ly/pdLGW">bpf-helpers manpage</a> that attempts to document them all.</p>&#13;
<p>Different helper functions are valid for different BPF program types. For example, the helper function <code>bpf_get_current_pid_tgid()</code> retrieves the current user space process ID and thread ID, but it doesn’t make sense to call this from an XDP program that is triggered by the receipt of a packet at a network interface, because there is no user space process involved. You can see an example of this by changing the <code>SEC()</code> definition for the <em>hello</em> eBPF program in <em>hello-verifier.bpf.c</em> from <code>kprobe</code> to <code>xdp</code>. On attempting to load this program the verifier output gives the following message:</p>&#13;
<pre data-type="programlisting">...&#13;
16: (85) call bpf_get_current_pid_tgid#14&#13;
unknown func bpf_get_current_pid_tgid#14</pre>&#13;
<p>The <code>unknown func</code> doesn’t mean the function is completely unknown, just that it is unknown <em>for this BPF program type</em>. (BPF program types are a topic for the next chapter; for now you can just think of them as being programs that are suitable for attaching to different types of event.)</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Helper Function Arguments" data-type="sect1"><div class="sect1" id="helper_function_arguments">&#13;
<h1>Helper Function Arguments</h1>&#13;
<p><a contenteditable="false" data-primary="verifier" data-secondary="helper function arguments" data-type="indexterm" id="idm46123196693520"/>If you look, for example, in <a href="https://oreil.ly/tjjVR"><em>kernel/bpf/helpers.c</em></a>,<sup><a data-type="noteref" href="ch06.html#ch06fn2" id="ch06fn2-marker">2</a></sup> you’ll find that each helper function has a <code>bpf_func_proto</code> structure similar to this example for the helper function <code>bpf_map_lookup_elem()</code>:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">const</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/bpf_func_proto"><code class="nc">bpf_func_proto</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/bpf_map_lookup_elem_proto"><code class="n">bpf_map_lookup_elem_proto</code></a><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/func"><code class="n">func</code></a><code class="w">      </code><code class="o">=</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/bpf_map_lookup_elem"><code class="n">bpf_map_lookup_elem</code></a><code class="p">,</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/gpl_only"><code class="n">gpl_only</code></a><code class="w"> </code><code class="o">=</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/false"><code class="nb">false</code></a><code class="p">,</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/pkt_access"><code class="n">pkt_access</code></a><code class="w">     </code><code class="o">=</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/true"><code class="nb">true</code></a><code class="p">,</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/ret_type"><code class="n">ret_type</code></a><code class="w"> </code><code class="o">=</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/RET_PTR_TO_MAP_VALUE_OR_NULL"><code class="n">RET_PTR_TO_MAP_VALUE_OR_NULL</code></a><code class="p">,</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/arg1_type"><code class="n">arg1_type</code></a><code class="w"> </code><code class="o">=</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/ARG_CONST_MAP_PTR"><code class="n">ARG_CONST_MAP_PTR</code></a><code class="p">,</code><code class="w">&#13;
</code><code class="w">    </code><code class="p">.</code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/arg2_type"><code class="n">arg2_type</code></a><code class="w"> </code><code class="o">=</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/ARG_PTR_TO_MAP_KEY"><code class="n">ARG_PTR_TO_MAP_KEY</code></a><code class="p">,</code><code class="w">&#13;
</code><code class="p">}</code><code class="p">;</code></pre>&#13;
<p>This structure defines the constraints for arguments to and return values from the helper function. Because the verifier is keeping track of the type of value held in each register, it can spot if you try to pass the wrong kind of argument to a helper function. For example, try changing the argument to the call to <code>bpf_map_lookup_elem()</code> in the <em>hello</em> program, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">data</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">uid</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>Instead of passing <code>&amp;my_config</code>, which is a pointer to a map, this now passes <code>&amp;data</code>, which is a pointer to a local variable structure. This is valid from the compiler’s point of view, so you can build the BPF object file <em>hello-verifier.bpf.o</em>, but when you try to load the program into the kernel, you’ll see an error like this in the verifier log:</p>&#13;
<pre data-type="programlisting">27: (85) call bpf_map_lookup_elem#1&#13;
R1 type=fp expected=map_ptr</pre>&#13;
<p><a contenteditable="false" data-primary="frame pointer" data-type="indexterm" id="idm46123196555344"/>Here, <code>fp</code> stands for <em>frame pointer</em>, and it’s the area of memory on the stack where local variables are stored. Register 1 was loaded with the address of the local variable called <code>data</code>, but the function expects a pointer to a map (as indicated by the <code>arg1_type</code> field in the <code>bpf_func_proto</code> structure shown earlier). By tracking the types of value stored in each register, the verifier was able to spot this discrepancy.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Checking the License" data-type="sect1"><div class="sect1" id="checking_the_license">&#13;
<h1>Checking the License</h1>&#13;
<p><a contenteditable="false" data-primary="GPL license" data-type="indexterm" id="idm46123196550000"/><a contenteditable="false" data-primary="licenses" data-secondary="eBPF verifier and" data-type="indexterm" id="idm46123196520928"/><a contenteditable="false" data-primary="verifier" data-secondary="checking the license" data-type="indexterm" id="idm46123196519712"/>The verifier also checks that if you are using a BPF helper function that’s licensed under GPL, your program also has a GPL-compatible license. The last line in the <a data-type="xref" href="#the_ebpf_verifier">Chapter 6</a> example code <em>hello-verifier.bpf.c</em> defines a “license” section that holds the string <code>Dual BSD/GPL</code>. If you remove this line, the output from the verifier will end like this:</p>&#13;
<pre data-type="programlisting">...&#13;
37: (85) call bpf_probe_read_kernel#113&#13;
cannot call GPL-restricted function from non-GPL compatible program</pre>&#13;
<p>That’s because the <code>gpl_only</code> field is set to <code>true</code> for the <code>bpf_probe_read_kernel()</code> helper function. There are other helper functions called earlier in this eBPF program, but they are not GPL licensed, so the verifier doesn’t object to their use.</p>&#13;
<p>The BCC project maintains a <a href="https://oreil.ly/mCpvB">list of helper functions</a>, indicating whether they are GPL licensed or not. If you’re interested in more details on how helper functions are implemented, there’s a section on this in the <a href="https://oreil.ly/kVd6j">BPF and XDP reference guide</a>.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Checking Memory Access" data-type="sect1"><div class="sect1" id="checking_memory_access">&#13;
<h1>Checking Memory Access</h1>&#13;
<p><a contenteditable="false" data-primary="memory access" data-secondary="checks performed by verifier" data-type="indexterm" id="ch06.html4"/><a contenteditable="false" data-primary="verifier" data-secondary="checking memory access" data-type="indexterm" id="ch06.html5"/>The verifier performs a number of checks to make sure BPF programs only access memory they are supposed to have access to.</p>&#13;
<p><a contenteditable="false" data-primary="XDP (eXpress Data Path)" data-secondary="memory access" data-type="indexterm" id="idm46123196506096"/>For example, when processing a network packet, an XDP program is only permitted to access the memory locations that make up that network packet. Most XDP programs start with something very similar to the following:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"xdp"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">xdp_load_balancer</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">xdp_md</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data_end</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">...</code><code class="w"/></pre>&#13;
<p>The <code>xdp_md</code> structure passed as the context to the program describes the network packet that has been received. The <code>ctx-&gt;data</code> field within that structure is the <span class="keep-together">location</span> in memory where the packet starts, and <code>ctx-&gt;data_end</code> is the last location in the packet. The verifier will ensure that the program doesn’t exceed these bounds.</p>&#13;
<p>For example, the following program in <em>hello_verifier.bpf.c</em> is valid:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"xdp"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">xdp_hello</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">xdp_md</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data_end</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"%x"</code><code class="p">,</code><code class="w"> </code><code class="n">data_end</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_PASS</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>The variables <code>data</code> and <code>data_end</code> are very similar, but the verifier is smart enough to recognize that <code>data_end</code> relates to the end of a packet. Your program is required to check that any values read from the packet aren’t from beyond that location, and it won’t let you “cheat” by modifying the <code>data_end</code> value. Try adding the following line just before the <code>bpf_printk()</code> call:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">data_end</code><code class="o">++</code><code class="p">;</code><code class="w"/></pre>&#13;
<p>The verifier will complain, like this:</p>&#13;
<pre data-type="programlisting">; data_end++;&#13;
1: (07) r3 += 1&#13;
R3 pointer arithmetic on pkt_end prohibited</pre>&#13;
<p>In another example, when accessing an array you need to make sure there’s no possibility of accessing an index that is beyond the bounds of that array. In the example code there is a section that reads a character out of the <code>message</code> array, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">c</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">message</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">char</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="n">c</code><code class="p">];</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"%c"</code><code class="p">,</code><code class="w"> </code><code class="n">a</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>This is fine because of the explicit check to ensure that the counter variable <code>c</code> is no bigger than the size of the message array. Making a simple “off by one” error like the following renders it invalid:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">c</code><code class="w"> </code><code class="o">&lt;=</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">message</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">char</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">message</code><code class="p">[</code><code class="n">c</code><code class="p">];</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"%c"</code><code class="p">,</code><code class="w"> </code><code class="n">a</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>The verifier will fail this with an error message similar to this:</p>&#13;
<pre data-type="programlisting">invalid access to map value, value_size=16 off=16 size=1&#13;
R2 max value is outside of the allowed memory range</pre>&#13;
<p>It’s fairly clear from this message that there is an invalid access to a map value because Register 2 might hold a value that’s too large for indexing the map. If you were debugging this error, you’d want to dig into the log to see what line in the source code was responsible. The log ends like this just before emitting the error message (I have removed some of the state information for clarity):</p>&#13;
<pre data-type="programlisting">; if (c &lt;= sizeof(message)) {&#13;
30: (25) if r1 &gt; 0xc goto pc+10                                <a class="co" href="#list_id_6_4" id="code_id_6_4"><img alt="3" src="assets/3.png"/></a>&#13;
 R0_w=map_value_or_null(id=2,off=0,ks=4,vs=12,imm=0) R1_w=inv(id=0,&#13;
 umax_value=12,var_off=(0x0; 0xf)) R6=ctx(id=0,off=0,imm=0) ...&#13;
; char a = message[c];&#13;
31: (18) r2 = 0xffff800008e00004                               <a class="co" href="#list_id_6_5" id="code_id_6_5"><img alt="2" src="assets/2.png"/></a>&#13;
33: (0f) r2 += r1                                               &#13;
last_idx 33 first_idx 19&#13;
regs=2 stack=0 before 31: (18) r2 = 0xffff800008e00004&#13;
regs=2 stack=0 before 30: (25) if r1 &gt; 0xc goto pc+10&#13;
regs=2 stack=0 before 29: (61) r1 = *(u32 *)(r8 +0)&#13;
34: (71) r3 = *(u8 *)(r2 +0)                                   <a class="co" href="#list_id_6_6" id="code_id_6_6"><img alt="1" src="assets/1.png"/></a>&#13;
 R0_w=map_value_or_null(id=2,off=0,ks=4,vs=12,imm=0) R1_w=invP(id=0,&#13;
 umax_value=12,var_off=(0x0; 0xf)) R2_w=map_value(id=0,off=4,ks=4,vs=16,&#13;
 umax_value=12,var_off=(0x0; 0xf),s32_max_value=15,u32_max_value=15)&#13;
 R6=ctx(id=0,off=0,imm=0) ...</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_6_6" id="list_id_6_6"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>Working backward from the error, the last register state information shows that Register 2 could have a maximum value of <code>12</code>.</dd>&#13;
<dt><a class="co" href="#code_id_6_5" id="list_id_6_5"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>At instruction 31, Register 2 is set to an address in memory and then is incremented by the value of Register 1. The output shows that this corresponds to the line of code accessing <code>message[c]</code>, so it stands to reason that Register 2 is set to point to the message array and then to be incremented by the value of <code>c</code>, which is held in the Register 1 register.</dd>&#13;
<dt><a class="co" href="#code_id_6_4" id="list_id_6_4"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>Working further back to find the value of Register 1, the log shows that it has a maximum value of <code>12</code> (which is hex 0x0c). However, <code>message</code> is defined as a 12-byte character array, so only indexes 0 through 11 are within its bounds. From this, you can see that the error springs from the source code testing for <code>c &lt;= sizeof(message)</code>.</dd>&#13;
</dl>&#13;
<p>At step 2, I have inferred the relationship between some registers and the source code variables they represent, from the lines of source code the verifier has helpfully included in the log. You could work back through the verifier log to check that this is true, and indeed you might have to if the code was compiled without debug information. Given the debug information is present, it makes sense to use it.</p>&#13;
<p>The <code>message</code> array is declared as a global variable, and you might recall from <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a> that global variables are implemented using maps. This explains why the error message talks about “invalid access to a map value.”<a contenteditable="false" data-primary="" data-startref="ch06.html5" data-type="indexterm" id="idm46123196123104"/><a contenteditable="false" data-primary="" data-startref="ch06.html4" data-type="indexterm" id="idm46123196121760"/></p>&#13;
</div></section>&#13;
<section class="pagebreak-before" data-pdf-bookmark="Checking Pointers Before Dereferencing Them" data-type="sect1"><div class="sect1" id="checking_pointers_before_dereferencing_">&#13;
<h1 class="less_space">Checking Pointers Before Dereferencing Them</h1>&#13;
<p><a contenteditable="false" data-primary="dereferencing pointers" data-type="indexterm" id="idm46123196118160"/><a contenteditable="false" data-primary="pointers, checking before dereferencing" data-type="indexterm" id="idm46123196117056"/><a contenteditable="false" data-primary="verifier" data-secondary="checking pointers before dereferencing them" data-type="indexterm" id="idm46123196115984"/>One easy way to make a C program crash is to dereference a pointer when the pointer has a zero value (also known as <em>null</em>). Pointers indicate where in memory a value is being held, and zero is not a valid memory location. The eBPF verifier requires all pointers to be checked before they are dereferenced so that this type of crash can’t happen.</p>&#13;
<p>The example code in <em>hello-verifier.bpf.c</em> looks for a custom message that might exist in the <code>my_config</code> hash table map for a user, with the following line:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">p</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">bpf_map_lookup_elem</code><code class="p">(</code><code class="o">&amp;</code><code class="n">my_config</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="n">uid</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>If there’s no entry in this map corresponding to <code>uid</code>, this will set <code>p</code> (which is a pointer to the message structure <code>msg_t</code>) to zero. Here’s a little bit of additional code that attempts to dereference this potentially null pointer:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">char</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">p</code><code class="o">-&gt;</code><code class="n">message</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>&#13;
<code class="n">bpf_printk</code><code class="p">(</code><code class="s">"%c"</code><code class="p">,</code><code class="w"> </code><code class="n">a</code><code class="p">);</code><code class="w"/></pre>&#13;
<p>This compiles fine, but the verifier rejects it as follows:</p>&#13;
<pre data-type="programlisting">; p = bpf_map_lookup_elem(&amp;my_config, &amp;uid); &#13;
25: (18) r1 = 0xffff263ec2fe5000&#13;
27: (85) call bpf_map_lookup_elem#1&#13;
28: (bf) r7 = r0                                <a class="co" href="#list_id_6_7" id="code_id_6_7"><img alt="1" src="assets/1.png"/></a>&#13;
; char a = p-&gt;message[0];&#13;
29: (71) r3 = *(u8 *)(r7 +0)                    <a class="co" href="#list_id_6_8" id="code_id_6_8"><img alt="2" src="assets/2.png"/></a>&#13;
R7 invalid mem access 'map_value_or_null'</pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_6_7" id="list_id_6_7"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>The return value from a helper function call gets stored in Register 0. Here, that value is being stored in Register 7. This means Register 7 now holds the value of the local variable <code>p</code>.</dd>&#13;
<dt><a class="co" href="#code_id_6_8" id="list_id_6_8"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>This instruction attempts to dereference the pointer value <code>p</code>. The verifier has been keeping track of the state of Register 7 and knows that it may hold a pointer to a map value, or it might be null.</dd>&#13;
</dl>&#13;
<p>The verifier rejects this attempt to dereference a null pointer, but the program will pass if there is an explicit check, like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">p</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="mi">0</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">char</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">p</code><code class="o">-&gt;</code><code class="n">message</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"%d"</code><code class="p">,</code><code class="w"> </code><code class="n">cc</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p class="pagebreak-before">Some helper functions incorporate the pointer check for you. For example, if you look at the manpage for bpf-helpers, you’ll find the function signature for <code>bpf_probe_read_kernel()</code> is as follows:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">long</code><code class="w"> </code><code class="n">bpf_probe_read_kernel</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><em><code class="n">dst</code></em><code class="p">,</code><code class="w"> </code><code class="n">u32</code><code class="w"> </code><em><code class="n">size</code></em><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><em><code class="n">unsafe_ptr</code></em><code class="p">)</code></pre>&#13;
<p>The third argument to this function is called <code>unsafe_ptr</code>. This is an example of a BPF helper function that helps programmers write safe code by handling checks for you. You’re allowed to pass a potentially null pointer—but only as the third argument called <code>unsafe_ptr</code>—and the helper function will check that it’s not null before attempting to deference it.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Accessing Context" data-type="sect1"><div class="sect1" id="accessing_context">&#13;
<h1>Accessing Context</h1>&#13;
<p><a contenteditable="false" data-primary="context information, accessing with verifier" data-type="indexterm" id="idm46123195933120"/><a contenteditable="false" data-primary="verifier" data-secondary="accessing context" data-type="indexterm" id="idm46123195932048"/>Every eBPF program is passed some context information as an argument, but depending on the program and attachment type, it may be allowed to access only some of that context information. For example, <a href="https://oreil.ly/6RFFI">tracepoint programs</a> receive a pointer to some tracepoint data. The format of that data depends on the particular tracepoint, but they all start with some common fields—yet those common fields are not accessible to eBPF programs. Only the tracepoint-specific fields that follow can be accessed. Attempting to read or write the wrong fields leads to an <code>invalid bpf_context access</code> error. There is an example of this in the exercises at the end of this chapter.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Running to Completion" data-type="sect1"><div class="sect1" id="running_to_completion">&#13;
<h1>Running to Completion</h1>&#13;
<p><a contenteditable="false" data-primary="programs, eBPF" data-secondary="ensuring that programs run to completion" data-type="indexterm" id="idm46123195927744"/><a contenteditable="false" data-primary="verifier" data-secondary="ensuring that programs run to completion" data-type="indexterm" id="idm46123195902176"/>The verifier ensures that the eBPF program will run to completion; otherwise, there is a risk that it might consume resources indefinitely. It does this by having a limit on the total number of instructions that it will process, which, as I mentioned earlier, is set at one million instructions at the time of this writing. That limit is <a href="https://oreil.ly/IucYm">hard-coded into the kernel</a>; it’s not a configurable option. If the verifier hasn’t reached the end of the BPF program before it has processed this many instructions, it rejects the program.</p>&#13;
<p>One easy way to create a program that never completes is to write a loop that never ends. Let’s see how loops can be created in eBPF programs.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Loops" data-type="sect1"><div class="sect1" id="loops">&#13;
<h1>Loops</h1>&#13;
<p><a contenteditable="false" data-primary="loops, verifier handling of" data-type="indexterm" id="idm46123195897616"/><a contenteditable="false" data-primary="verifier" data-secondary="loops" data-type="indexterm" id="idm46123195896544"/>To guarantee completion, until kernel version 5.3 there was a restriction on loops.<sup><a data-type="noteref" href="ch06.html#ch06fn3" id="ch06fn3-marker">3</a></sup> Looping through the same instructions requires a jump backward to earlier instructions, and it used to be the case that the verifier would not permit this. eBPF programmers worked around this by using the <code>#pragma unroll</code> compiler directive to tell the compiler to write out a set of identical (or very similar) bytecode instructions for each time around the loop. This saved the programmer typing in the same lines many times, but you would see repeated instructions in the emitted bytecode.</p>&#13;
<p>From version 5.3 onward the verifier follows branches backward as well as forward as part of its process of checking all the possible execution paths. This means it can accept some loops, provided the execution path remains within the limit of one million instructions.</p>&#13;
<p>You can see an example of a loop in the example <em>xdp_hello</em> program. A version of the loop that passes verification looks like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"Looping %d"</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>The (successful) verifier log will show that it has followed the execution path around this loop 10 times. In doing so, it doesn’t hit the complexity limit of one million instructions. In the exercises for this chapter, there’s another version of this loop that will hit that limit and will fail verification.</p>&#13;
<p>In version 5.17 a new helper function, <code>bpf_loop()</code>, was introduced that makes it much easier for the verifier not only to accept loops but also to do it in a much more efficient way. This helper takes the maximum number of iterations as its first argument, and it is also passed a function that is called for each iteration. The verifier only has to validate the BPF instructions in that function once, however many times it might be called. That function can return a nonzero value to indicate that there is no need to call it again, which is used to terminate a loop early once the desired result is achieved.</p>&#13;
<p>There’s also a helper function <a href="https://oreil.ly/Yg_oQ"><code>bpf_for_each_map_elem()</code></a> that calls a provided callback function for each item in a map.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Checking the Return Code" data-type="sect1"><div class="sect1" id="checking_the_return_code">&#13;
<h1>Checking the Return Code</h1>&#13;
<p><a contenteditable="false" data-primary="return code" data-secondary="checking with verifier" data-type="indexterm" id="idm46123195829904"/><a contenteditable="false" data-primary="verifier" data-secondary="checking return code" data-type="indexterm" id="idm46123195828528"/>The return code from an eBPF program is stored in Register 0 (<code>R0</code>). If the program leaves <code>R0</code> uninitialized, the verifier will fail, like this:</p>&#13;
<pre data-type="programlisting">R0 !read_ok</pre>&#13;
<p>You can try this by commenting out all the code in a function; for example, modify the <code>xdp_hello</code> example to be like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"xdp"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">xdp_hello</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">xdp_md</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data</code><code class="p">;</code><code class="w"/>&#13;
<code class="w"> </code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">data_end</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="p">)(</code><code class="kt">long</code><code class="p">)</code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">data_end</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w"> </code><code class="c1">// bpf_printk("%x", data_end);</code>&#13;
<code class="w"> </code><code class="c1">// return XDP_PASS;</code>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>This will fail the verifier. However, if you put the line with the helper function <code>bpf_printf()</code> back in, the verifier won’t complain, even though there’s no explicit return value set by the source code!</p>&#13;
<p>This is because Register 0 is also used to hold the return code from a helper function. After returning from a helper function in an eBPF program, Register 0 is no longer uninitialized.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Invalid Instructions" data-type="sect1"><div class="sect1" id="invalid_instructions">&#13;
<h1>Invalid Instructions</h1>&#13;
<p><a contenteditable="false" data-primary="instructions" data-secondary="verifier check for invalid" data-type="indexterm" id="idm46123195747056"/><a contenteditable="false" data-primary="verifier" data-secondary="checking for invalid instructions" data-type="indexterm" id="idm46123195723136"/>As you know from the discussion of the eBPF (virtual) machine in <a data-type="xref" href="ch03.html#anatomy_of_an_ebpf_program">Chapter 3</a>, eBPF programs consist of a set of bytecode instructions. The verifier checks that the instructions in a program are valid bytecode instructions—for example, using only known opcodes.</p>&#13;
<p>It would be considered a bug in the compiler if it emitted invalid bytecode, so you’re not likely to see this kind of verifier error unless you choose (for some reason best known to yourself) to write eBPF bytecode by hand. However, there have been some instructions added more recently, such as the atomic operations. If your compiled bytecode uses these instructions, they would fail verification on an older kernel.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Unreachable Instructions" data-type="sect1"><div class="sect1" id="unreachable_instructions">&#13;
<h1>Unreachable Instructions</h1>&#13;
<p><a contenteditable="false" data-primary="instructions" data-secondary="verifier check for unreachable" data-type="indexterm" id="idm46123195718688"/><a contenteditable="false" data-primary="unreachable instructions, verifier check for" data-type="indexterm" id="idm46123195717344"/><a contenteditable="false" data-primary="verifier" data-secondary="checking for unreachable instructions" data-type="indexterm" id="idm46123195716272"/>The verifier also rejects programs that have unreachable instructions. Oftentimes, these will get optimized out by the compiler anyway.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000015">&#13;
<h1>Summary</h1>&#13;
<p>When I first got interested in eBPF, getting code through the verifier seemed like a dark art, where seemingly valid code would get rejected, throwing up what seemed to be arbitrary errors. Over time there have been <em>lots</em> of improvements to the verifier, and in this chapter you’ve seen several examples where the verifier log gives hints to help you figure out what the problem is.</p>&#13;
<p>These hints are more helpful when you have a mental model of how the eBPF (virtual) machine works, using a set of registers for temporary value storage as it steps through an eBPF program. The verifier keeps track of the types and possible range of values for each register to ensure that eBPF programs are safe to run.</p>&#13;
<p>If you try writing some eBPF code of your own, you might find yourself needing assistance to resolve verifier errors. The <a href="http://ebpf.io/slack">eBPF community Slack channel</a> is a good place to ask for help, and lots of people have also found advice on <a href="https://oreil.ly/nu_0v">StackOverflow</a>.<a contenteditable="false" data-primary="" data-startref="ch06.html0" data-type="indexterm" id="idm46123195708016"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="exercises_id000005">&#13;
<h1>Exercises</h1>&#13;
<p>Here are some more ways to cause a verifier error. See if you can correlate the verifier log output to the errors you get:</p>&#13;
<ol>&#13;
<li><p>In <a data-type="xref" href="#checking_memory_access">“Checking Memory Access”</a>, you saw the verifier rejecting access beyond the end of the global <code>message</code> array. In the example code there’s a section that accesses the local variable <code>data.message</code> in a similar way:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="n">c</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="k">sizeof</code><code class="p">(</code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">))</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">char</code><code class="w"> </code><code class="n">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">data</code><code class="p">.</code><code class="n">message</code><code class="p">[</code><code class="n">c</code><code class="p">];</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"%c"</code><code class="p">,</code><code class="w"> </code><code class="n">a</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>Try adjusting the code to make the same out-by-one mistake by replacing the <code>&lt;</code> with <code>&lt;=</code>, and you’ll see an error message about  <code>invalid variable-offset read from stack R2</code>.</p></li>&#13;
<li><p>Find the commented-out loops in <em>xdp_hello</em> in the example code. Try adding in the first loop that looks like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mi">10</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"Looping %d"</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>You should see in the verifier log a repeated series of lines that look something like this:</p>&#13;
<pre data-type="programlisting">42: (18) r1 = 0xffff800008e10009&#13;
44: (b7) r2 = 11&#13;
45: (b7) r3 = 8&#13;
46: (85) call bpf_trace_printk#6&#13;
 R0=inv(id=0) R1_w=map_value(id=0,off=9,ks=4,vs=26,imm=0) R2_w=inv11&#13;
 R3_w=inv8 R6=pkt_end(id=0,off=0,imm=0) R7=pkt(id=0,off=0,r=0,imm=0) &#13;
 R10=fp0&#13;
last_idx 46 first_idx 42&#13;
regs=4 stack=0 before 45: (b7) r3 = 8&#13;
regs=4 stack=0 before 44: (b7) r2 = 11</pre>&#13;
<p>From the log, work out which register is tracking the loop variable <code>i</code>.</p></li>&#13;
<li><p>Now try adding in a loop that will fail, which looks like this:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="k">for</code><code class="w"> </code><code class="p">(</code><code class="kt">int</code><code class="w"> </code><code class="n">i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="n">c</code><code class="p">;</code><code class="w"> </code><code class="n">i</code><code class="o">++</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"Looping %d"</code><code class="p">,</code><code class="w"> </code><code class="n">i</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>You should see that the verifier tries to explore this loop to its conclusion, but it reaches the instruction complexity limit before it completes (because there is no upper bound on the global variable <code>c</code>).</p></li>&#13;
<li><p>Write a program that attaches to a tracepoint. (You may have done this already for the exercises in <a data-type="xref" href="ch04.html#the_bpfleft_parenthesisright_parenthesi">Chapter 4</a>.) Looking ahead to <a data-type="xref" href="ch07.html#tracepoints">“Tracepoints”</a>, you can see a structure definition for the context argument that starts with these fields:</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="kt">unsigned</code><code class="w"> </code><code class="kt">short</code><code class="w"> </code><code class="n">common_type</code><code class="p">;</code><code class="w"/>&#13;
<code class="kt">unsigned</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">common_flags</code><code class="p">;</code><code class="w"/>&#13;
<code class="kt">unsigned</code><code class="w"> </code><code class="kt">char</code><code class="w"> </code><code class="n">common_preempt_count</code><code class="p">;</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">common_pid</code><code class="p">;</code><code class="w"/></pre>&#13;
<p>Create your own version of a structure that starts like this, and make the context argument in your program a pointer to this structure. In the program, try accessing any of these fields and see that the verifier fails with <code>invalid bpf_context access</code>.</p></li>&#13;
</ol>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch06fn1"><sup><a href="ch06.html#ch06fn1-marker">1</a></sup> For a long time the limit was 4,096 instructions, which imposed significant restrictions on the complexity of eBPF programs. This limit still applies to unprivileged users running BPF programs.</p><p data-type="footnote" id="ch06fn2"><sup><a href="ch06.html#ch06fn2-marker">2</a></sup> Helper functions are also defined in some other places in the source code, for example, <a href="https://oreil.ly/cY8y9"><em>kernel/trace/bpf_trace.c</em></a> and <a href="https://oreil.ly/qww-b"><em>net/core/filter.c</em></a>.</p><p data-type="footnote" id="ch06fn3"><sup><a href="ch06.html#ch06fn3-marker">3</a></sup> This release brought a number of significant optimizations and improvements to the BPF verifier, which are summarized nicely in the LWN article <a href="https://oreil.ly/50BoD">“Bounded loops in BPF for the 5.3 kernel”</a>.</p></div></div></section></body></html>