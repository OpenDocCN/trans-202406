<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Saving Time with Express"><div class="chapter" id="ch_saving_time_with_express">
<h1><span class="label">Chapter 3. </span>Saving Time with Express</h1>


<p><a data-type="indexterm" data-primary="Express" data-secondary="basics" id="ix_ch-03-saving_time_with_express-asciidoc0"/><a data-type="indexterm" data-primary="web server project" data-secondary="creating with Express" id="ix_ch-03-saving_time_with_express-asciidoc1"/>In <a data-type="xref" href="ch02.xhtml#ch_getting_started_with_node">Chapter 2</a>, you learned how to create a simple web
server using only Node. In this chapter, we will re-create that server
using Express.
This will provide a jumping-off point for the rest of the content of this
book and introduce you to the basics of Express.</p>






<section data-type="sect1" data-pdf-bookmark="Scaffolding"><div class="sect1" id="idm45053605026600">
<h1>Scaffolding</h1>

<p><a data-type="indexterm" data-primary="Express" data-secondary="scaffolding" id="idm45053605025192"/><a data-type="indexterm" data-primary="Ruby" id="idm45053605024216"/><a data-type="indexterm" data-primary="scaffolding" id="idm45053605023544"/><a data-type="indexterm" data-primary="web server project" data-secondary="scaffolding" id="idm45053605022872"/><em>Scaffolding</em> is not a new idea, but many people (myself included) were
introduced to the concept by Ruby. The idea is simple:
most projects require a certain amount of so-called <em>boilerplate</em> code, and
who wants to re-create that code every time you begin a new
project? A simple way is to create a rough
skeleton of a project, and every time you need a new project, you just copy
this skeleton, or template.</p>

<p><a data-type="indexterm" data-primary="Ruby on Rails" id="idm45053605020424"/>Ruby on Rails took this concept one step further by providing a program
that would automatically generate scaffolding for you. The advantage of this approach is that it could
generate a more sophisticated framework than just selecting from a
collection of templates.</p>

<p>Express has taken a page from Ruby on Rails and provided a utility to
generate scaffolding to start your Express project.</p>

<p>While the Express scaffolding utility is useful, I think it’s valuable to
learn how to set up Express from scratch. In addition to learning more,
you have more control over what gets installed and the structure of your
project. Also, the Express scaffolding utility is geared toward
server-side HTML generation and is less relevant for APIs and single-page
applications.</p>

<p>While we won’t be using the scaffolding utility, I encourage you to take a
look at it once you’ve finished the book: by then you’ll be armed with
everything you need to know to evaluate whether the scaffolding it
generates is useful for you. For more information, see the
<a href="http://bit.ly/2CyvvLr"><code>express-generator</code>
documentation</a>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The Meadowlark Travel Website"><div class="sect1" id="idm45053605016168">
<h1>The Meadowlark Travel Website</h1>

<p><a data-type="indexterm" data-primary="Meadowlark Travel website (fictional example)" data-secondary="Express and" id="ix_ch-03-saving_time_with_express-asciidoc2"/>Throughout this book, we’ll be using a running example: a fictional website
for <span class="keep-together">Meadowlark</span> Travel, a company
offering services for people visiting the great state of
Oregon. If you’re more interested in creating an API,
have no fear: the Meadowlark Travel website will expose an API in addition
to serving a functional website.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Initial Steps"><div class="sect1" id="idm45053605012472">
<h1>Initial Steps</h1>

<p><a data-type="indexterm" data-primary="Meadowlark Travel website (fictional example)" data-secondary="initial steps" id="ix_ch-03-saving_time_with_express-asciidoc3"/>Start by creating a new directory: <a data-type="indexterm" data-primary="root directory" id="idm45053605009128"/>this will be the root
directory for your project. In this book, whenever we refer to the
project directory, app directory, or project root, we’re referring to
this directory.</p>
<div data-type="tip"><h6>Tip</h6>
<p>You’ll probably want to keep your web app files separate from
all the other files that usually accompany a project, such as meeting
notes, documentation, etc. For that reason, I recommend making your project root a
subdirectory of your project directory. For example, for the Meadowlark
Travel website, I might keep the project in <em>~/projects/meadowlark</em>, and
the project root in <em>~/projects/meadowlark/site</em>.</p>
</div>

<p><a data-type="indexterm" data-primary="npm (package manager)" data-secondary="package.json file and" id="idm45053605005464"/><a data-type="indexterm" data-primary="package.json file" id="idm45053605004296"/>npm manages project dependencies—as well as metadata about the project—in a
file called <em>package.json</em>. The easiest way to create this file is to
run <code>npm init</code>: it will ask you a series of questions and generate a
<em>package.json</em> file to get you started (for the “entry point” question,
use <em>meadowlark.js</em> for the name of your project).</p>
<div data-type="tip"><h6>Tip</h6>
<p>Every time you run npm, you may get warnings about a missing description or
repository field. It’s safe to ignore these warnings, but if you want to
eliminate them, edit the <em>package.json</em> file and provide values for the
fields npm is complaining about. For more information about the fields in
this file, see the <a href="http://bit.ly/2O8HrbW">npm
<em>package.json</em> documentation</a>.</p>
</div>

<p>The first step will be installing Express. Run the following npm
command:</p>

<pre data-type="programlisting">npm install express</pre>

<p>Running <code>npm install</code> will install the named package(s) in the
<em>node_modules</em> <span class="keep-together">directory</span> and
update the <em>package.json</em> file. Since the <em>node_modules</em> directory can
be regenerated at any time with npm, we will not save it in our repository.
To ensure we don’t accidentally add it to our repository, we create a file
called <em>.gitignore</em>:</p>

<pre data-type="programlisting"># ignore packages installed by npm
node_modules

# put any other files you don't want to check in here, such as .DS_Store
# (OSX), *.bak, etc.</pre>

<p>Now create a file called <em>meadowlark.js</em>. This will be our project’s entry point.
Throughout the book, we will simply be referring to this file as the <em>app
file</em> (<em>ch03/00-meadowlark.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express'</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">()</code>

<code class="kr">const</code> <code class="nx">port</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">3000</code>

<code class="c1">// custom 404 page</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">((</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">type</code><code class="p">(</code><code class="s1">'text/plain'</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">404</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'404 - Not Found'</code><code class="p">)</code>
<code class="p">})</code>

<code class="c1">// custom 500 page</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">((</code><code class="nx">err</code><code class="p">,</code> <code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">type</code><code class="p">(</code><code class="s1">'text/plain'</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">500</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'500 - Server Error'</code><code class="p">)</code>
<code class="p">})</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">port</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>
  <code class="sb">`Express started on http://localhost:</code><code class="si">${</code><code class="nx">port</code><code class="si">}</code><code class="sb">; `</code> <code class="o">+</code>
  <code class="sb">`press Ctrl-C to terminate.`</code><code class="p">))</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>Many tutorials, as well as the Express scaffolding generator,
encourage you to name your primary file <em>app.js</em> (or sometimes
<em>index.js</em> or <em>server.js</em>). Unless you’re
using a hosting service or deployment system that requires your main
application file to have a specific name, I don’t feel there’s a compelling
reason to do this, and I prefer to name the primary file after the project.
Anyone who’s ever stared at a bunch of editor tabs that all say
“index.html” will immediately see the wisdom of this. <code>npm init</code> will
default to <em>index.js</em>; if you use a different name for your application
file, make sure to update the
<code>main</code> property in <em>package.json</em>.</p>
</div>

<p>You now have a minimal Express server. You can start the server (<code>node
meadowlark.js</code>) and navigate to <em>http://localhost:3000</em>. The result
will be disappointing: you haven’t provided Express with any routes, so it
will simply give you a generic 404 message indicating that the page doesn’t
exist.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Note how we choose the port that we want our application to
run on: <code>const port = process.env.PORT || 3000</code>. This allows us to
override the port by setting an environment variable before you start the
server. If your app isn’t running on port
3000 when you run this example, check to see whether your <code>PORT</code> environment
variable is set.</p>
</div>

<p>Let’s add some routes for the home page and an About page. Before the 404
handler, we’ll add two new routes (<em>ch03/01-meadowlark.js</em> in the
companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">type</code><code class="p">(</code><code class="s1">'text/plain'</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'Meadowlark Travel'</code><code class="p">);</code>
<code class="p">})</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/about'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">type</code><code class="p">(</code><code class="s1">'text/plain'</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'About Meadowlark Travel'</code><code class="p">)</code>
<code class="p">})</code>

<code class="c1">// custom 404 page</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">((</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">type</code><code class="p">(</code><code class="s1">'text/plain'</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">404</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'404 - Not Found'</code><code class="p">)</code>
<code class="p">})</code></pre>

<p><a data-type="indexterm" data-primary="app.get() method" id="idm45053604802056"/><code>app.get</code> is the method by which we’re adding routes. In the Express documentation, you
will see <code>app.METHOD</code>. This doesn’t mean that there’s literally a method
called <code>METHOD</code>; it’s just a placeholder for your (lowercased) HTTP verbs
(<code>get</code> and <code>post</code> being the most common). This method
takes two parameters: a path and a function.</p>

<p>The <em>path</em> is what defines the route. Note that <code>app.METHOD</code> does the heavy
lifting for you: by default, it doesn’t care about the case or trailing
slash, and it doesn’t consider the querystring when performing the match.
So the route for the About page will work for <em>/about</em>, <em>/About</em>,
<em>/about/</em>, <em>/about?foo=bar</em>, <em>/about/?foo=bar</em>, etc.</p>

<p>The <em>function</em> you provide will get invoked when the route is matched. The
parameters passed to that function are the request and response objects,
which we’ll learn more about in <a data-type="xref" href="ch06.xhtml#ch_the_request_and_response_objects">Chapter 6</a>.
For now, we’re just returning plain text with a status code of 200 (Express
defaults to a status code of 200—you don’t have to specify it explicitly).</p>
<div data-type="tip"><h6>Tip</h6>
<p>I highly recommend getting a browser plug-in that shows you the
status code of the HTTP request as well as any redirects that took
place. It will make it easier to spot
redirect issues in your code or incorrect status codes, which are often
overlooked. <a data-type="indexterm" data-primary="Ayima Redirect Path" id="idm45053604650184"/><a data-type="indexterm" data-primary="Chrome" data-secondary="browser plug-in for" id="idm45053604649480"/><a data-type="indexterm" data-primary="Redirect Path" id="idm45053604648536"/>For Chrome, Ayima’s
Redirect Path works wonderfully. In most browsers, you can see the status
code in the Network section of the developer tools.</p>
</div>

<p><a data-type="indexterm" data-primary="res.send()" id="idm45053604647192"/>Instead of using Node’s low-level <code>res.end</code>, we’re switching to using
Express’s extension, <code>res.send</code>. We are also replacing Node’s
<code>res.writeHead</code> with <code>res.set</code> and <code>res.status</code>. Express is also providing us a
convenience method, <code>res.type</code>, which sets the <code>Content-Type</code>
header. While it’s still
possible to use <code>res.writeHead</code> and <code>res.end</code>, it isn’t necessary or
recommended.</p>

<p>Note that our custom 404 and 500 pages must be handled slightly
differently. <a data-type="indexterm" data-primary="app.use() method" id="idm45053604641720"/><a data-type="indexterm" data-primary="middleware" data-secondary="app.use method and" id="idm45053604641016"/>Instead of using <code>app.get</code>, we are using
<code>app.use</code>. <code>app.use</code> is the method by which Express adds
<em>middleware</em>. We’ll be covering
middleware in more depth in <a data-type="xref" href="ch10.xhtml#ch_middleware">Chapter 10</a>, but for now, you can think
of this as a catchall handler for anything that didn’t get matched by a
route. This brings us to an important point: <em>in Express, the order in
which routes and middleware are added is significant</em>. If we put the 404 handler above the
routes, the home page and About page would stop working; instead, those
URLs would result in a 404. Right now, our routes are pretty simple, but
they also support wildcards, which can lead to problems with
ordering. For example, what if we
wanted to add subpages to About, such as <em>/about/contact</em> and
<em>/about/directions</em>? The following will not work as expected:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/about*'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c1">// send content....</code>
<code class="p">})</code> <code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/about/contact'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c1">// send content....</code>
<code class="p">})</code> <code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/about/directions'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="c1">// send content....</code>
<code class="p">})</code></pre>

<p>In this example, the <code>/about/contact</code> and <code>/about/directions</code> handlers will
never be matched because the first handler uses a wildcard in its path:
<code>/about*</code>.</p>

<p>Express can distinguish between the 404 and 500 handlers by the number of
arguments their callback functions take. Error routes will be covered in
depth in <a data-type="xref" href="ch10.xhtml#ch_middleware">Chapter 10</a> and <a data-type="xref" href="ch12.xhtml#ch_production_concerns">Chapter 12</a>.</p>

<p>Now you can start the server again and see that there’s a functioning home
page and About page.</p>

<p>So far, we haven’t done anything that couldn’t be done just as easily
without Express, but already Express is providing us some functionality
that isn’t immediately obvious. Remember in the previous chapter how we
had to normalize <code>req.url</code> to determine what resource was being requested?
We had to manually strip off the querystring and the trailing slash and
convert to lowercase. Express’s router is now handling those details for
us automatically. While it may not seem like a large thing now, it’s only
scratching the surface of what Express’s router is capable of.</p>








<section data-type="sect2" data-pdf-bookmark="Views and Layouts"><div class="sect2" id="idm45053604610808">
<h2>Views and Layouts</h2>

<p><a data-type="indexterm" data-primary="Meadowlark Travel website (fictional example)" data-secondary="views and layouts" id="ix_ch-03-saving_time_with_express-asciidoc4"/><a data-type="indexterm" data-primary="views" id="ix_ch-03-saving_time_with_express-asciidoc5"/>If you’re familiar with the “model-view-controller” paradigm, then the
concept of a view will be no stranger to you. Essentially, a <em>view</em> is what gets delivered to the user. <a data-type="indexterm" data-primary="HTML" data-secondary="views and" id="idm45053608099784"/>In the case of a
website, that usually means HTML, though you could also deliver a PNG or a
PDF or anything that can be rendered by the client. For our purposes, we
will consider views to be HTML.</p>

<p>A view differs from a static resource (like an image or CSS file) in
that a view doesn’t necessarily have to be static: the HTML can be
constructed on the fly to provide a customized page for each
request.</p>

<p>Express supports many different view engines that provide different levels
of abstraction. <a data-type="indexterm" data-primary="Pug" id="idm45053608097336"/>Express gives some preference to a view engine called
<em>Pug</em> (which is no surprise, because it is also the brainchild of TJ
Holowaychuk). The approach Pug takes
is minimal: what you write doesn’t resemble HTML at all, which
certainly represents a lot less typing (no more angle brackets or closing
tags). The Pug engine then takes that and converts it to HTML.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Pug was originally called Jade, and the name changed with the release of
version 2 because of a trademark issue.</p>
</div>

<p>Pug is appealing, but that level of abstraction comes at a cost. If
you’re a frontend developer, you have to understand HTML and understand it
well, even if you’re actually writing your views in Pug. Most frontend
developers I know are uncomfortable with the idea of their primary markup
language being abstracted away. For this reason, I am recommending the use
of another, less abstract templating framework called <em>Handlebars</em>.</p>

<p><a data-type="indexterm" data-primary="Handlebars" id="idm45053608092952"/>Handlebars (which is based on the popular language-independent templating
language Mustache) doesn’t attempt to abstract away HTML for you: you write
HTML with special tags that allow Handlebars to inject content.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>In the years following the original release of this book, React has taken
the world by storm…which abstracts HTML away from frontend developers!
Viewed through that lens, my prediction that frontend developers didn’t
want HTML abstracted away hasn’t stood the test of time. However, JSX (the
JavaScript language extension that most React developers use) is (almost)
identical to writing HTML, so I wasn’t entirely wrong.</p>
</div>

<p><a data-type="indexterm" data-primary="express-handlebars" id="idm45053608090056"/>To provide Handlebars support, we’ll use Eric Ferraiuolo’s
<code>express-handlebars</code> <span class="keep-together">package</span>. In your project directory, execute the following:</p>

<pre data-type="programlisting">npm install express-handlebars</pre>

<p>Then in <em>meadowlark.js</em>, modify the first few lines
(<em>ch03/02-meadowlark.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express'</code><code class="p">)</code>
<code class="kr">const</code> <code class="nx">expressHandlebars</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express-handlebars'</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">()</code>

<code class="c1">// configure Handlebars view engine</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">engine</code><code class="p">(</code><code class="s1">'handlebars'</code><code class="p">,</code> <code class="nx">expressHandlebars</code><code class="p">({</code>
  <code class="nx">defaultLayout</code><code class="o">:</code> <code class="s1">'main'</code><code class="p">,</code>
<code class="p">}))</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'view engine'</code><code class="p">,</code> <code class="s1">'handlebars'</code><code class="p">)</code></pre>

<p>This creates a view engine and configures Express to use it by default.
<a data-type="indexterm" data-primary="layouts" id="ix_ch-03-saving_time_with_express-asciidoc6"/>Now create a directory called <em>views</em> that has a subdirectory called
<em>layouts</em>. If you’re an experienced web developer, you’re
probably already comfortable with the concepts of <em>layouts</em> (sometimes
called <em>master pages</em>). When you build a website,
there’s a certain amount of HTML that’s the same—or very close to the
same—on every page. It not only becomes tedious to rewrite all that
repetitive code for every page, but also creates a potential maintenance
nightmare: if you want to change something on every page, you have to
change <em>all</em> the files. Layouts free you from this, providing a common
framework for all the pages on your site.</p>

<p>So let’s create a template for our site. Create a file called
<em>views/layouts/main.handlebars</em>:</p>

<pre data-type="programlisting" data-code-language="html"><code class="cp">&lt;!doctype html&gt;</code>
<code class="nt">&lt;html&gt;</code>
  <code class="nt">&lt;head&gt;</code>
    <code class="nt">&lt;title&gt;</code>Meadowlark Travel<code class="nt">&lt;/title&gt;</code>
  <code class="nt">&lt;/head&gt;</code>
  <code class="nt">&lt;body&gt;</code>
    {{{body}}}
  <code class="nt">&lt;/body&gt;</code>
<code class="nt">&lt;/html&gt;</code></pre>

<p>The only thing that you probably haven’t seen before is this:
<code>{{{body}}}</code>. This expression will be replaced with the HTML for
each view. When we created the Handlebars instance, note we specified the
default layout (<code>defaultLayout: \'main'</code>). That means that unless you
specify otherwise, this is the layout that will be used for any
view.</p>

<p>Now let’s create view pages for our home page,
<em>views/home.handlebars</em>:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;h1&gt;</code>Welcome to Meadowlark Travel<code class="nt">&lt;/h1&gt;</code></pre>

<p>Then our About page, <em>views/about.handlebars</em>:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;h1&gt;</code>About Meadowlark Travel<code class="nt">&lt;/h1&gt;</code></pre>

<p>Then our Not Found page, <em>views/404.handlebars</em>:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;h1&gt;</code>404 - Not Found<code class="nt">&lt;/h1&gt;</code></pre>

<p>And finally our Server Error page, <em>views/500.handlebars</em>:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;h1&gt;</code>500 - Server Error<code class="nt">&lt;/h1&gt;</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>You probably want your editor to associate <em>.handlebars</em> and
<em>.hbs</em> (another common extension for Handlebars files) with HTML to
<span class="keep-together">enable</span> syntax highlighting and
other editor features. For vim, you can add the line <code>au BufNewFile,BufRead *.handlebars
set filetype=html</code> to your <em>~/.vimrc</em> file. For other editors, consult
your <span class="keep-together">documentation.</span></p>
</div>

<p>Now that we have some views set up, we have to replace our old
routes with new ones that use these views
(<em>ch03/02-meadowlark.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'home'</code><code class="p">))</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/about'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'about'</code><code class="p">))</code>

<code class="c1">// custom 404 page</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">((</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">404</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'404'</code><code class="p">)</code>
<code class="p">})</code>

<code class="c1">// custom 500 page</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">((</code><code class="nx">err</code><code class="p">,</code> <code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">500</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'500'</code><code class="p">)</code>
<code class="p">})</code></pre>

<p>Note that we no longer have to specify the content type or status code: the
view engine will return a content type of <code>text/html</code> and a status code
of 200 by default. In the catchall handler, which provides our custom 404 page,
and the 500 handler, we have to set the status code explicitly.</p>

<p>If you start your server and check out the home or About page, you’ll see
that the views have been rendered. If you examine the source, you’ll see
that the boilerplate HTML from <em>views/layouts/main.handlebars</em> is there.</p>

<p><a data-type="indexterm" data-primary="dynamic content" data-secondary="defined" id="idm45053607728776"/>Even though every time you visit the home page, you get the same HTML,
these routes are considered <em>dynamic content</em>, because we could make a
different decision each time the route gets called (which we’ll see plenty
of later in this book). However, content that really never changes, in other words,
static content, is common and important, so we’ll consider static content
next<a data-type="indexterm" data-startref="ix_ch-03-saving_time_with_express-asciidoc6" id="idm45053607726920"/>.<a data-type="indexterm" data-startref="ix_ch-03-saving_time_with_express-asciidoc5" id="idm45053607725992"/><a data-type="indexterm" data-startref="ix_ch-03-saving_time_with_express-asciidoc4" id="idm45053607725256"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Static Files and Views"><div class="sect2" id="idm45053604609864">
<h2>Static Files and Views</h2>

<p><a data-type="indexterm" data-primary="Meadowlark Travel website (fictional example)" data-secondary="static files and views" id="idm45053607723496"/><a data-type="indexterm" data-primary="middleware" data-secondary="for static files and views" id="idm45053607722552"/><a data-type="indexterm" data-primary="static middleware" id="idm45053607721640"/><a data-type="indexterm" data-primary="views" data-secondary="middleware for" id="idm45053607720968"/>Express relies on <em>middleware</em> to handle static files and
views. Middleware is a concept that will be covered in more detail in
<a data-type="xref" href="ch10.xhtml#ch_middleware">Chapter 10</a>. For now, it’s sufficient to know that middleware
provides modularization, making it easier to handle requests.</p>

<p>The <code>static</code> middleware allows you to designate one or more directories as
containing static resources that are simply to be delivered to the client
without any special <span class="keep-together">handling.</span> This is
where you would put things such as images, CSS files, and client-side
JavaScript files.</p>

<p>In your project directory, create a subdirectory called <em>public</em> (we call
it <em>public</em> because anything in this directory will be served to the
client without question). Then, before you declare any routes, you’ll add
the <code>static</code> middleware (<em>ch03/02-meadowlark.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">express</code><code class="p">.</code><code class="kr">static</code><code class="p">(</code><code class="nx">__dirname</code> <code class="o">+</code> <code class="s1">'/public'</code><code class="p">))</code></pre>

<p>The <code>static</code> middleware has the same effect as creating a route for each
static file you want to deliver that renders a file and returns it to the
client. So let’s
create an <em>img</em> subdirectory inside <em>public</em> and put our <em>logo.png</em>
file in there.</p>

<p>Now we can simply reference <em>/img/logo.png</em> (note, we do not specify
<code>public</code>; that directory is invisible to the client), and the <code>static</code>
middleware will serve that file, setting the content type
appropriately. Now let’s
modify our layout so that our logo appears on every page:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;body&gt;</code>
  <code class="nt">&lt;header&gt;</code>
    <code class="nt">&lt;img</code> <code class="na">src=</code><code class="s">"/img/logo.png"</code> <code class="na">alt=</code><code class="s">"Meadowlark Travel Logo"</code><code class="nt">&gt;</code>
  <code class="nt">&lt;/header&gt;</code>
  {{{body}}}
<code class="nt">&lt;/body&gt;</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Remember that middleware is processed in order, and static middleware—which
is usually declared first or at least very early—will override other
routes. For example, if you put an <em>index.html</em> file in the <em>public</em>
directory (try it!), you’ll find that the contents of that file get served
instead of the route you configured! So if you’re getting confusing
results, check your static files and make sure there’s nothing unexpected
matching the route.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Dynamic Content in Views"><div class="sect2" id="idm45053607654232">
<h2>Dynamic Content in Views</h2>

<p><a data-type="indexterm" data-primary="dynamic content" data-secondary="in views" id="idm45053607652824"/><a data-type="indexterm" data-primary="Meadowlark Travel website (fictional example)" data-secondary="dynamic content in views" id="idm45053607687400"/><a data-type="indexterm" data-primary="views" data-secondary="dynamic content in" id="idm45053607686520"/>Views aren’t simply a complicated way to deliver static HTML (though they
can certainly do that as well). The real power of views is that
they can contain dynamic information.</p>

<p>Let’s say that on the About page, we want to deliver a “virtual fortune
cookie.” In our <em>meadowlark.js</em> file, we define an array of fortune cookies:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fortunes</code> <code class="o">=</code> <code class="p">[</code>
  <code class="s2">"Conquer your fears or they will conquer you."</code><code class="p">,</code>
  <code class="s2">"Rivers need springs."</code><code class="p">,</code>
  <code class="s2">"Do not fear what you don't know."</code><code class="p">,</code>
  <code class="s2">"You will have a pleasant surprise."</code><code class="p">,</code>
  <code class="s2">"Whenever possible, keep it simple."</code><code class="p">,</code>
<code class="p">]</code></pre>

<p>Modify the view (<em>/views/about.handlebars</em>) to display a fortune:</p>

<pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;h1&gt;</code>About Meadowlark Travel<code class="nt">&lt;/h1&gt;</code>
{{#if fortune}}
  <code class="nt">&lt;p&gt;</code>Your fortune for the day:<code class="nt">&lt;/p&gt;</code>
  <code class="nt">&lt;blockquote&gt;</code>{{fortune}}<code class="nt">&lt;/blockquote&gt;</code>
{{/if}}</pre>

<p>Now modify the route <em>/about</em> to deliver the random fortune cookie:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/about'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">randomFortune</code> <code class="o">=</code> <code class="nx">fortunes</code><code class="p">[</code><code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code><code class="o">*</code><code class="nx">fortunes</code><code class="p">.</code><code class="nx">length</code><code class="p">)]</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'about'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">fortune</code><code class="o">:</code> <code class="nx">randomFortune</code> <code class="p">})</code>
<code class="p">})</code></pre>

<p>Now if you restart the server and load the <em>/about</em> page, you’ll see a
random fortune, and you’ll get a new one every time you reload the page.
Templating is incredibly useful, and we will be covering it in depth in
<a data-type="xref" href="ch07.xhtml#ch_templating">Chapter 7</a><a data-type="indexterm" data-startref="ix_ch-03-saving_time_with_express-asciidoc3" id="idm45053607488856"/>.<a data-type="indexterm" data-startref="ix_ch-03-saving_time_with_express-asciidoc2" id="idm45053607487992"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Conclusion"><div class="sect2" id="idm45053607487128">
<h2>Conclusion</h2>

<p>We’ve created a basic website with Express. Even though it’s simple,
it contains all the seeds we need for a full-featured website. In the next
chapter, we’ll be crossing our <em>t</em>s and dotting our <em>i</em>s in preparation
for adding more advanced functionality.<a data-type="indexterm" data-startref="ix_ch-03-saving_time_with_express-asciidoc1" id="idm45053607484776"/><a data-type="indexterm" data-startref="ix_ch-03-saving_time_with_express-asciidoc0" id="idm45053607484040"/></p>
</div></section>





</div></section>







</div></section></div>



  </body></html>