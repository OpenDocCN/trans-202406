<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Query Response Time" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch01">&#13;
<h1><span class="label">Chapter 1. </span>Query Response Time</h1>&#13;
&#13;
&#13;
<p>Performance is query response time.</p>&#13;
&#13;
<p>This book explores that idea from various angles with a single intent: to help you achieve remarkable MySQL performance.&#13;
<em>Efficient</em> MySQL performance means <em>focusing</em> on the best practices and techniques that directly affect MySQL performance—no superfluous details or deep internals required by DBAs and experts.&#13;
I presume that you’re a busy professional who is using MySQL, not managing it, and that you need the most results for the least effort.&#13;
That’s not laziness, that’s efficiency.&#13;
To that end, this book is direct and to the point.&#13;
And by the end, you will be able to achieve remarkable MySQL performance.</p>&#13;
&#13;
<p>MySQL performance is a complex and multifaceted subject, but you do not need to become an expert to achieve remarkable performance.&#13;
I narrow the scope of MySQL complexity by focusing on the essentials.&#13;
MySQL performance begins with query response time.</p>&#13;
&#13;
<p><em>Query response time</em> <a data-primary="query response time" data-type="indexterm" id="query-response-time1"/>is how long it takes MySQL to execute a query. Synonymous terms are: <em>response time</em>, <em>query time</em>, <em>execution time</em>, and (inaccurately) <em>query latency</em>.<sup><a data-type="noteref" href="ch01.html#idm45829115580240" id="idm45829115580240-marker">1</a></sup> Timing starts when MySQL receives the query and ends when it has sent the result set to the client. Query response time comprises many stages (steps during query execution) and waits <a data-primary="waits" data-secondary="query response time" data-type="indexterm" id="idm45829115709392"/>(lock waits, I/O waits, and so on), but a complete and detailed breakdown is neither possible nor necessary. As with many systems, basic troubleshooting and analysis reveal the majority of problems.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Performance increases as query response time decreases.&#13;
<em>Improving</em> query response time is synonymous with <em>reducing</em> query response time.</p>&#13;
</div>&#13;
&#13;
<p>This chapter is the foundation.&#13;
It expounds query response time so that, in subsequent chapters, you can learn how to improve it.&#13;
There are seven major sections.&#13;
The first is a true story to motivate and amuse.&#13;
The second discusses why query response time is the North Star of MySQL performance.&#13;
The third outlines how query metrics are transformed into meaningful reports: query reporting.&#13;
The fourth addresses query analysis: using query metrics and other information to understand query execution.&#13;
The fifth maps out the journey of improving query response time: query optimization.&#13;
The sixth gives an honest and modest schedule for optimizing queries.&#13;
The seventh discusses why MySQL cannot simply go faster—why query optimization is necessary.<a data-primary="query response time" data-startref="query-response-time1" data-type="indexterm" id="idm45829115705008"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A True Story of False Performance" data-type="sect1"><div class="sect1" id="a-true-story">&#13;
<h1>A True Story of False Performance</h1>&#13;
&#13;
<p>In 2004, I was working the night shift at a data center—2 p.m. to midnight. It was a great job for two reasons. First, the only employees in the data center after 5 p.m. were a handful of engineers monitoring and managing thousands of physical servers for an undisclosed number of customers and websites—probably tens of thousands of websites. It was an engineer’s dream. Second, there were countless MySQL servers that always had problems to fix. It was a gold mine of learning and opportunity. But at the time, there were few books, blogs, or tools about MySQL. (Though that same year, O’Reilly published the first edition of <em>High Performance MySQL</em>.) Consequently, the state of the art for “fixing” MySQL performance problems was “sell the customer more RAM.” For sales and management it always worked, but for MySQL the results were inconsistent.</p>&#13;
&#13;
<p>One night I decided not to sell the customer more RAM and, instead, to do a technical deep dive to find and fix the true root cause of their MySQL performance problem. Their database was powering a bulletin board which had slowed to a crawl under the weight of its success—still a common problem today, almost 20 years later. To make a long story short, I found a single query missing a critical index. After properly indexing the query, performance improved dramatically and the website was saved. It cost the customer zero dollars.</p>&#13;
&#13;
<p>Not all performance problems and solutions are that straightforward and glamorous. But just shy of 20 years’ experience with MySQL has taught me (and many others) that MySQL performance problems are very often solved by the best practices and techniques in this book.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="North Star" data-type="sect1"><div class="sect1" id="north-star">&#13;
<h1>North Star</h1>&#13;
&#13;
<p>I’m a <a data-primary="North Star" data-type="indexterm" id="idm45829115168576"/>MySQL DBA <em>and</em> a software engineer, so I know what it’s like working with MySQL as the latter. Especially when it comes to performance, we (software engineers) just want it (MySQL) to work. Between shipping features and putting out fires, who has time for MySQL performance? And when MySQL performance is poor—or worse: when it suddenly becomes poor—the way forward can be difficult to see because there are many considerations: where do we begin? Do we need more RAM? Faster CPUs? More storage IOPS? Is the problem a recent code change? (Fact: code changes deployed in the past can cause performance problems in the future, sometimes days in the future.) Is the problem a noisy neighbor? Are the DBAs doing something to the database? Has the app has gone viral and it’s the good kind of problem to have?</p>&#13;
&#13;
<p>As an engineer whose expertise is the application, not MySQL, that situation can be overwhelming.&#13;
To move forward confidently, start by looking at query response time <a data-primary="query response time" data-secondary="as meaningful and actionable" data-secondary-sortas="meaningful and actionable" data-type="indexterm" id="idm45829115165888"/>because it is <em>meaningful</em> and <em>actionable</em>.&#13;
These are powerful qualities that lead to real solutions:</p>&#13;
<dl>&#13;
<dt>Meaningful</dt>&#13;
<dd>&#13;
<p>Query response time is the only metric anyone truly cares about because, let’s be honest, when the database is fast, nobody looks at it or asks questions. Why? Because query response time is the only metric we <em>experience</em>. When a query takes 7.5 seconds to execute, we experience 7.5 seconds of impatience. That same query might examine a million rows, but we don’t experience a million rows examined. Our time is precious.</p>&#13;
</dd>&#13;
<dt>Actionable</dt>&#13;
<dd>&#13;
<p>There’s so much you can do to improve query response time and make everyone happy again that you’re holding a book about it. (Do people still hold books in the future? I hope so.) Query response time is directly actionable because you own the code, so you can change the queries. Even if you don’t own the code (or have access to it), you can still indirectly optimize query response time. <a data-type="xref" href="#query-optimization">“Improving Query Response Time”</a> addresses direct and indirect query optimization.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Focus on improving query response time—the North Star of MySQL performance.&#13;
Do not begin by throwing hardware at the problem.&#13;
Begin by using query metrics to determine what MySQL is doing, then analyze and optimize slow queries to reduce response time, and repeat.&#13;
Performance <em>will</em> improve.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Query Reporting" data-type="sect1"><div class="sect1" id="idm45829110089088">&#13;
<h1>Query Reporting</h1>&#13;
&#13;
<p>Query metrics <a data-primary="query reporting" data-type="indexterm" id="query-reporting-ch1"/><a data-primary="query response time" data-secondary="query reporting" data-type="indexterm" id="query-reporting_index1"/>provide invaluable insights into query execution: response time, lock time, rows examined, and so on.&#13;
But query metrics, like all metrics, are raw values that need to be collected, aggregated, and reported in a way that’s meaningful to (and readable for) engineers.&#13;
That’s what this section outlines: how query metric tools transform query metrics into query reports.&#13;
But query reporting is only a means to an end, as discussed in <a data-type="xref" href="#query-analysis">“Query Analysis”</a>.</p>&#13;
&#13;
<p>Looking ahead, query analysis is the real work: analyzing query metrics (as reported) and other information with the goal of understanding query execution.&#13;
To improve MySQL performance, you must optimize queries.&#13;
To optimize queries, you must understand how they execute.&#13;
And to understand that, you must analyze them with pertinent information, including query reports and metadata.</p>&#13;
&#13;
<p>But first you need to understand query reporting, since it represents the trove of query metrics that provide invaluable insights into query execution.&#13;
The next three sections teach you about the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Sources: query metrics originate from two sources and vary by MySQL distribution and version</p>&#13;
</li>&#13;
<li>&#13;
<p>Aggregation: query metric values are grouped and aggregated by normalized SQL statements</p>&#13;
</li>&#13;
<li>&#13;
<p>Reporting: query reports are organized by a high-level profile and a query-specific report</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Then you’re ready for <a data-type="xref" href="#query-analysis">“Query Analysis”</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This is not a book about database administration, so this section does not discuss the setup and configuration of query metrics in MySQL.&#13;
I presume this is already done or will be done.&#13;
If not, don’t worry: ask your DBA, hire a consultant, or learn how by reading the MySQL manual.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sources" data-type="sect2"><div class="sect2" id="query-sources">&#13;
<h2>Sources</h2>&#13;
&#13;
<p>Query<a data-primary="source (query metrics)" data-type="indexterm" id="source-query-metrics-ch1"/> metrics originate from the <a href="https://oreil.ly/Glss3">slow query log</a> <a data-primary="slow query log" data-type="indexterm" id="slow-query-log"/>or the <a href="https://oreil.ly/FNXRq">Performance Schema</a>.<a data-primary="Performance Schema" data-type="indexterm" id="Performance-Schema"/>&#13;
As the names indicate, the former is a log file on disk, and the latter is a database with the same name: <code>performance_schema</code>.&#13;
Although completely different in nature (log file on disk as opposed to tables in a database), both provide query metrics.&#13;
The important difference is how many metrics they provide: apart from query response time, which both provide, the number of metrics ranges from 3 to more than 20.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The name <em>slow query log</em> is historical. Long ago, MySQL logged only queries that took greater than N <em>seconds</em> to execute, and the minimum value for N was 1. Old versions of MySQL would not log a query that took 900 milliseconds to execute because that was “fast.” The slow query log really earned its name. Today, the minimum value is zero with a resolution of microseconds. When set to zero, MySQL logs every query executed. Therefore, the name is a little misleading, but now you know why.</p>&#13;
</div>&#13;
&#13;
<p>All things considered, the Performance Schema is the best source of query metrics because it exists in every current version and distribution of MySQL, it works locally and in the cloud, it provides all nine metrics covered in <a data-type="xref" href="#query-metrics">“Query Metrics”</a>, and it’s the most consistent.&#13;
Plus, the Performance Schema contains a wealth of other data for deep MySQL analysis, so its usefulness extends far beyond query metrics. The slow query log is a good source, too, but it varies considerably:</p>&#13;
<dl>&#13;
<dt>MySQL</dt>&#13;
<dd>&#13;
<p>  As of MySQL 8.0.14, enable system variable <a href="https://oreil.ly/ibfRK"><code>log_slow_extra</code></a> and the slow query log provides six of the nine metrics in <a data-type="xref" href="#query-metrics">“Query Metrics”</a>, lacking only <code>Rows_affected</code>, <code>Select_scan</code>, and <code>Select_full_join</code>.&#13;
It’s still a good source, but use the Performance Schema if possible.</p>&#13;
&#13;
<p>Before MySQL 8.0.14, which includes MySQL 5.7, the slow query log is bare bones, providing only <code>Query_time</code>, <code>Lock_time</code>, <code>Rows_sent</code>, and <code>Rows_examined</code>.&#13;
You can still analyze queries with only these four metrics, but the analysis is much less insightful.&#13;
Consequently, avoid the slow query log before MySQL 8.0.14 and instead use the Performance Schema.</p>&#13;
</dd>&#13;
<dt>Percona Server</dt>&#13;
<dd>&#13;
<p>  <a href="https://oreil.ly/ILyh2">Percona Server</a> <a data-primary="Percona Server" data-secondary="query reporting" data-type="indexterm" id="idm45829115464320"/>provides a significantly greater number of metrics in the slow query log when system variable <code>log_slow_verbosity</code> is configured: all nine metrics covered in <a data-type="xref" href="#query-metrics">“Query Metrics”</a> and more.&#13;
It also supports query sampling (logging a percentage of queries) when system variable <code>log_slow_rate_limit</code> is configured, which is helpful for busy servers.&#13;
These features make the Percona Server slow query log a great source.&#13;
See <a href="https://oreil.ly/5JQ06">“Slow Query Log”</a> in the Percona Server manual for details.</p>&#13;
</dd>&#13;
<dt>MariaDB Server</dt>&#13;
<dd>&#13;
<p>  <a href="https://oreil.ly/oeGJO">MariaDB Server</a> <a data-primary="MariaDB" data-type="indexterm" id="Maria-DB"/>10.x uses the Percona Server slow query log enhancements, but there are two notable differences: system variable <code>log_slow_verbosity</code> is configured differently in MariaDB, and it does not provide metric <code>Rows_affected</code>.&#13;
Otherwise, it’s essentially the same and a great source, too.&#13;
See <a href="https://oreil.ly/oOVe7">“Slow Query Log Extended Statistics”</a> in the MariaDB knowledge base for details.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The slow query log is disabled by default, but you can enable it dynamically (without restarting MySQL).&#13;
The Performance Schema should be enabled by default, though some cloud providers disable it by default.&#13;
Unlike the slow query log, the Performance Schema cannot be enabled dynamically—you must restart MySQL to enable it.</p>&#13;
&#13;
<p>Make sure the best query metric source is used and properly configured.&#13;
Ask your DBA, hire a consultant, or learn how by reading the MySQL manual.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The slow query log can log <em>all</em> queries when <a href="https://oreil.ly/NUmuA"><code>long_query_time</code></a> is set to zero, but be careful: on a busy server, this can increase disk I/O and use a significant amount of disk space.<a data-primary="source (query metrics)" data-startref="source-query-metrics-ch1" data-type="indexterm" id="idm45829115287792"/><a data-primary="slow  query log" data-startref="slow-query-log" data-type="indexterm" id="idm45829115286880"/><a data-primary="Performance Schema" data-startref="Performance-Schema" data-type="indexterm" id="idm45829115285936"/><a data-primary="MariaDB" data-startref="Maria-DB" data-type="indexterm" id="idm45829115284992"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Aggregation" data-type="sect2"><div class="sect2" id="query-aggregation">&#13;
<h2>Aggregation</h2>&#13;
&#13;
<p>Query metrics are grouped and aggregated by query.<a data-primary="aggregation (query metrics)" data-type="indexterm" id="aggregation-query-metrics-ch1"/>&#13;
That sounds obvious since they’re called <em>query</em> metrics, but some query metric tools can group by username, hostname, database, and so on.&#13;
These alternate groupings are exceptionally rare and yield a different type of query analysis, so I don’t address them in this book.&#13;
Since query response time is the North Star of MySQL performance, grouping query metrics by query is the best way to see which queries have the slowest response time, which forms the basis of query reporting and analysis.</p>&#13;
&#13;
<p>There’s one little problem: how do you uniquely identify queries to determine the groups to which they belong? For example, system metrics (CPU, memory, storage, and so on) are grouped by hostname because hostnames are unique and meaningful. But queries don’t have any uniquely identifying properties like hostname. The solution: a SHA-256 hash of the normalized SQL statement. <a data-type="xref" href="#query-group-ids">Example 1-1</a> shows how a SQL statement is normalized.</p>&#13;
<div data-type="example" id="query-group-ids">&#13;
<h5><span class="label">Example 1-1. </span>SQL statement normalization</h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code><code> </code><code class="n">col</code><code> </code><code class="k">FROM</code><code> </code><code class="n">tbl</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">id</code><code class="o">=</code><code class="mi">1</code><code> </code><a class="co" href="#callout_query_response_time_CO1-1" id="co_query_response_time_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="k">SELECT</code><code> </code><code class="o">`</code><code class="n">col</code><code class="o">`</code><code> </code><code class="k">FROM</code><code> </code><code class="o">`</code><code class="n">tbl</code><code class="o">`</code><code> </code><code class="k">WHERE</code><code> </code><code class="o">`</code><code class="n">id</code><code class="o">`</code><code> </code><code class="o">=</code><code> </code><code class="o">?</code><code> </code><a class="co" href="#callout_query_response_time_CO1-2" id="co_query_response_time_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
&#13;
</code><code class="n">f49d50dfab1c364e622d1e1ff54bb12df436be5d44c464a4e25a1ebb80fc2f13</code><code> </code><a class="co" href="#callout_query_response_time_CO1-3" id="co_query_response_time_CO1-3"><img alt="3" src="assets/3.png"/></a></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_query_response_time_CO1-1" id="callout_query_response_time_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>SQL statement (sample)</p></dd>&#13;
<dt><a class="co" href="#co_query_response_time_CO1-2" id="callout_query_response_time_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Digest text (normalized SQL statement)</p></dd>&#13;
<dt><a class="co" href="#co_query_response_time_CO1-3" id="callout_query_response_time_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Digest hash (SHA-256 of digest text)</p></dd>&#13;
</dl>&#13;
&#13;
<p>MySQL normalizes SQL statements to digest texts, then computes the SHA-256 hash of the digest text to yield the digest hash. (It’s not necessary to understand the full process of normalization; it’s sufficient to know that normalization replaces all values with <code>?</code> and collapses multiple whitespaces to a single space.) Since the digest text is unique, the digest hash is also unique (hash collisions notwithstanding).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The MySQL manual uses the term <em>digest</em> equivocally to mean either <em>digest text</em> or <em>digest hash</em>. Since the digest hash is computed from the digest text, the equivocation is only a language ambiguity, not a technical error. Please allow me to equivocate, too, and use <em>digest</em> to <a data-primary="digest" data-type="indexterm" id="idm45829115198464"/>mean either <em>digest text</em> <a data-primary="digest text" data-type="indexterm" id="idm45829115197184"/>or <em>digest hash</em> <a data-primary="digest hash" data-type="indexterm" id="idm45829115195904"/>when the technical difference doesn’t matter.</p>&#13;
</div>&#13;
&#13;
<p>There is an important shift in terminology in the context of query metrics: the term <em>query</em> <a data-primary="query" data-secondary="term synonymous with &quot;digest text&quot;" data-type="indexterm" id="idm45829115194240"/>changes to be synonymous with <em>digest text</em>. The shift in terminology aligns with the shift in focus: grouping metrics by query. To group by query, <em>query</em> must be unique, which is only true of digests.</p>&#13;
&#13;
<p>SQL statements are also called <em>query samples</em> <a data-primary="query samples" data-type="indexterm" id="idm45829115191104"/>(or <em>samples</em> for short), and they may or may not be reported.&#13;
For security, most query metric tools discard samples by default (because they contain real values) and report only digest texts and hashes.&#13;
Samples are required for query analysis because you can <a href="https://oreil.ly/YSnio"><code>EXPLAIN</code></a> them, which produces metadata necessary for understanding query execution.&#13;
Some query metric tools <code>EXPLAIN</code> a sample, then discard it, and report the EXPLAIN plan (the output of <code>EXPLAIN</code>).&#13;
Others only report the sample, which is still very convenient: copy-paste to <code>EXPLAIN</code>.&#13;
If you have neither, then manually extract samples from the source or manually write them when needed.</p>&#13;
&#13;
<p>Two more clarifications about terminology and then I promise we’ll move on to more exciting material.&#13;
First, terminology varies widely depending on the query metric tool, as shown in <a data-type="xref" href="#qm-terms">Table 1-1</a>.</p>&#13;
<table id="qm-terms">&#13;
<caption><span class="label">Table 1-1. </span>Query metric terminology</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Official (MySQL)</th>&#13;
<th>Alternatives</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>SQL statement</p></td>&#13;
<td><p>Query</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Sample</p></td>&#13;
<td><p>Query</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Digest text</p></td>&#13;
<td><p>Class, family, fingerprint, query</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Digest hash</p></td>&#13;
<td><p>Class ID, query ID, signature</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Second, another term that originated from <a href="https://www.percona.com">Percona</a> <a data-primary="Percona Server" data-secondary="query reporting" data-type="indexterm" id="idm45829115174832"/>is <em>query abstract</em>: <a data-primary="query abstract" data-type="indexterm" id="query-abstract_index1"/>a SQL statement highly abstracted to its SQL command and table list.&#13;
<a data-type="xref" href="#query-abstract">Example 1-2</a> is the query abstract for <code>SELECT col FROM tbl WHERE id=1</code>.</p>&#13;
<div data-type="example" id="query-abstract">&#13;
<h5><span class="label">Example 1-2. </span>Query abstract</h5>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="n">tbl</code></pre></div>&#13;
&#13;
<p>Query abstracts are not unique, but they are useful because they’re succinct.&#13;
Usually, developers only need to see a query abstract to know the full query that it represents.<a data-primary="query abstract" data-startref="query-abstract_index1" data-type="indexterm" id="idm45829109469840"/></p>&#13;
<blockquote>&#13;
<p>Brevity is the soul of wit.</p>&#13;
<p data-type="attribution">William Shakespeare</p>&#13;
</blockquote>&#13;
&#13;
<p>It’s important to understand that SQL statements are normalized because the queries you write are not the queries you see. Most of the time, this is not a problem because digest texts closely resemble SQL statements. But the process of normalization raises another important point: do not dynamically generate the same logical query with different syntax, else it will normalize to different digests and be reported as different queries. For example, in the case of a programmatically-generated query that changes the <code>WHERE</code> clause based on user input:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="k">SELECT</code> <code class="n">name</code> <code class="k">FROM</code> <code class="n">captains</code> <code class="k">WHERE</code> <code class="n">last_name</code> <code class="o">=</code> <code class="s1">'Picard'</code>&#13;
<code class="k">SELECT</code> <code class="n">name</code> <code class="k">FROM</code> <code class="n">captains</code> <code class="k">WHERE</code> <code class="n">last_name</code> <code class="o">=</code> <code class="s1">'Picard'</code> <code class="k">AND</code> <code class="n">first_name</code> <code class="o">=</code> <code class="s1">'Jean-Luc'</code></pre>&#13;
&#13;
<p>Those two queries may be logically the same to you and the application, but they’re different queries with respect to reporting because they normalize to different digests.&#13;
To my knowledge, no query metric tool allows you to combine queries.&#13;
And it’s technically correct to report those queries separately because every condition—especially in the <code>WHERE</code> clause—affects query execution and optimization.</p>&#13;
&#13;
<p>One point about query normalization: values are removed, so the following two queries normalize to the same digest:</p>&#13;
&#13;
<pre data-code-language="sql" data-type="programlisting"><code class="c1">-- SQL statements</code>&#13;
<code class="k">SELECT</code> <code class="o">`</code><code class="n">name</code><code class="o">`</code> <code class="k">FROM</code> <code class="n">star_ships</code> <code class="k">WHERE</code> <code class="k">class</code> <code class="k">IN</code> <code class="p">(</code><code class="s1">'galaxy'</code><code class="p">)</code>&#13;
<code class="k">SELECT</code> <code class="o">`</code><code class="n">name</code><code class="o">`</code> <code class="k">FROM</code> <code class="n">star_ships</code> <code class="k">WHERE</code> <code class="k">class</code> <code class="k">IN</code> <code class="p">(</code><code class="s1">'galaxy'</code><code class="p">,</code> <code class="s1">'intrepid'</code><code class="p">)</code>&#13;
&#13;
<code class="c1">-- Digest text</code>&#13;
<code class="k">SELECT</code> <code class="o">`</code><code class="n">name</code><code class="o">`</code> <code class="k">FROM</code> <code class="o">`</code><code class="n">star_ships</code><code class="o">`</code> <code class="k">WHERE</code> <code class="o">`</code><code class="k">class</code><code class="o">`</code> <code class="k">IN</code> <code class="p">(...)</code></pre>&#13;
&#13;
<p>Since the digest is the same for both queries, the metrics for both queries are grouped, aggregated, and reported as one query.</p>&#13;
&#13;
<p>Enough about terminology and normalization. Let’s talk about reporting.<a data-primary="aggregation (query metrics)" data-startref="aggregation-query-metrics-ch1" data-type="indexterm" id="idm45829113538752"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reporting" data-type="sect2"><div class="sect2" id="query-reporting">&#13;
<h2>Reporting</h2>&#13;
&#13;
<p>Reporting is a challenge and an art form because a single application can have hundreds of queries. Each query has many metrics and each metric has several statistics: minimum, maximum, average, percentile, and so forth. On top of that, each query has metadata: samples, EXPLAIN plans, table structures, on so on. It’s challenging to store, process, and present all this data. Almost every query metric tool presents the data in a two-level hierarchy: <em>query profile</em> and <em>query report</em>. Those terms vary by query metric tool, but you will easily recognize each when you see them.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Query profile" data-type="sect3"><div class="sect3" id="query-profile">&#13;
<h3>Query profile</h3>&#13;
&#13;
<p>A <em>query profile</em> shows slow queries.<a data-primary="query profile" data-type="indexterm" id="query-profile_index1"/>&#13;
It is the top-level organization for query reporting, usually the first thing you see in a query metric tool.&#13;
It presents query digests and a limited subset of query metrics, which is why it’s called a profile.</p>&#13;
&#13;
<p><em>Slow</em> is relative to the <em>sort metric</em>: the aggregate value of a query metric by which queries are ordered.&#13;
The first ordered query is called <em>the slowest</em>, even if the sort metric is not query time (or any time).&#13;
For example, if the sort metric is average rows sent, the first ordered query is still called the slowest.</p>&#13;
&#13;
<p>Although any query metric can be the sort metric, query time is the universal default sort metric.&#13;
When you reduce query execution time, you free up time that allows MySQL to do more work, or possibly do other work more quickly.&#13;
Sorting queries by query time shows you where to begin: the slowest, most time-consuming queries.</p>&#13;
&#13;
<p>What’s not universal is how query time is aggregated. The most common aggregate values are:</p>&#13;
<dl>&#13;
<dt>Total query time</dt>&#13;
<dd>&#13;
<p>  <em>Total query time</em> <a data-primary="total query time" data-type="indexterm" id="idm45829113525760"/>is the sum of execution time (per query).&#13;
This is the most common aggregate value because it answers an important question: <em>which query does MySQL spend the most time executing?</em>&#13;
To answer that, a query metric tool adds up all the time MySQL spends executing each query.&#13;
The query with the greatest total time is the slowest, most time-consuming query.&#13;
Here’s an example of why this is important.&#13;
Suppose query <em>A</em> has a 1-second response time and executes 10 times, while query <em>B</em> has a 0.1-second response time and executes 1,000 times.&#13;
Query <em>A</em> has a much slower response time, but query <em>B</em> is 10 times more time-consuming: 10 seconds in total versus 100 seconds in total, respectively.&#13;
In a query profile sorted by total query time, query <em>B</em> is the slowest query.&#13;
This is important because you free up the most time for MySQL by optimizing query <em>B</em>.</p>&#13;
</dd>&#13;
<dt>Percentage execution time</dt>&#13;
<dd>&#13;
<p><em>Percentage execution time</em> <a data-primary="percentage execution time" data-type="indexterm" id="idm45829113519632"/>is total query time (per query) divided by grand total execution time (all queries). For example, if query <em>C</em> has a total query time of 321 ms and query <em>D</em> has a total query time of 100 ms, then grand total execution time is 421 ms. Individually, query <em>C</em> is (321 ms / 421 ms) × 100 = 76.2% of grand total execution time, and query <em>D</em> is (100 ms / 421 ms) × 100 = 23.8% of grand total execution time. In other words, MySQL spent 421 ms executing queries, 76.2% of which was spent executing query <em>C</em>. In a query profile sorted by percentage execution time, query <em>C</em> is the slowest query. Percentage execution time is used by some query metric tools, but not all.</p>&#13;
</dd>&#13;
<dt>Query load</dt>&#13;
<dd>&#13;
<p><em>Query load</em> <a data-primary="query load" data-type="indexterm" id="idm45829113514000"/>is total query time (per query) divided by clock time, where <em>clock time</em> is the number of seconds in the time range. If the time range is 5 minutes, then clock time is 300 seconds. For example, if query <em>E</em> has a total query time 250.2 seconds, then its load is 250.2 s / 300 s = 0.83; and if query <em>F</em> has a total query time of 500.1 seconds, then its load is 500.1 s / 300 s = 1.67. In a query profile sorted by query load, query <em>F</em> is the slowest query because its load is the greatest.</p>&#13;
&#13;
<p>Load is relative to time but also subtly indicative of <em>concurrency</em>: multiple instances of a query executing at the same time.&#13;
Query load less than 1.0 means that, on average, the query does not execute concurrently.&#13;
Query load greater than 1.0 indicates query concurrency.&#13;
For example, a query load of 3.5 means that, any time you look, you’re likely to see 3.5 instances of the query executing.&#13;
(In reality, 3 or 4 instances of the query since there cannot be 0.5 instances of a query.)&#13;
The higher the query load, the greater the possibility of contention if the query accesses the same or nearby rows.&#13;
Query load greater than 10 is high and likely to be a slow query, but there are exceptions.&#13;
As I write this, I’m looking at a query with a load of 5,962.&#13;
How is that possible?&#13;
I reveal the answer in <a data-type="xref" href="ch03.html#data-access">“Data Access”</a>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>When the sort metric uses a nontemporal query metric, like rows sent, a different aggregate value (average, maximum, and so on) might make sense depending on what you’re trying to diagnose. This is far less common than total query time, but it occasionally reveals interesting queries worth optimizing.<a data-primary="query profile" data-startref="query-profile_index1" data-type="indexterm" id="idm45829113507824"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Query report" data-type="sect3"><div class="sect3" id="query-report">&#13;
<h3>Query report</h3>&#13;
&#13;
<p>A <em>query report</em> <a data-primary="query report" data-type="indexterm" id="query-report_index1"/>shows you everything there is to know about one query. It is the second-level organization for query reporting, usually accessed by selecting a slow query in the query profile. It presents all query metrics and metadata. Whereas the query profile tells you something just by looking at it (which queries are the slowest), a query report is an organized information dump used for query analysis. As such, the more information, the better because it helps you understand query execution.</p>&#13;
&#13;
<p>Query reports vary dramatically depending on the query metric tool. A bare minimum report includes all query metrics from the source and the basic statistics for those metrics: minimum, maximum, average, percentile, and so forth. A thorough report includes metadata: query samples, EXPLAIN plans, table structures, and more. (Samples may be disabled for security purposes because they contain real values.) A few query metric tools go further by adding additional information: metric graphs, histograms (distributions), anomaly detection, time shift comparison (now versus last week), developer notes, SQL comment key-value extraction, and so on.</p>&#13;
&#13;
<p>Query analysis only requires query metrics in the report.&#13;
Metadata can be collected manually.&#13;
If the query metric tool you use reports only query metrics, don’t worry: that’s a start, but you will need to manually collect EXPLAIN plans and table structures, at the very least.</p>&#13;
&#13;
<p>With a query report figuratively in hand, you’re equipped for query analysis.<a data-primary="query response time" data-secondary="query reporting" data-startref="query-reporting_index1" data-type="indexterm" id="idm45829113500656"/><a data-primary="query reporting" data-startref="query-reporting-ch1" data-type="indexterm" id="idm45829113499408"/><a data-primary="query report" data-startref="query-report_index1" data-type="indexterm" id="idm45829113498464"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Query Analysis" data-type="sect1"><div class="sect1" id="query-analysis">&#13;
<h1>Query Analysis</h1>&#13;
&#13;
<p>The goal of query analysis <a data-primary="query analysis" data-type="indexterm" id="query-analysis_index1"/><a data-primary="query response time" data-secondary="query analysis" data-type="indexterm" id="query-analysis_index2"/>is understanding query execution, not solving slow response time. That might surprise you, but solving slow response time happens <em>after</em> query analysis, during query optimization. First, you need to understand what you’re trying to change: query execution.</p>&#13;
&#13;
<p>Query execution is like a story with a beginning, middle, and end: you read all three to understand the story.&#13;
Once you understand how MySQL executes a query, then you will understand how to optimize it.&#13;
Understanding through analysis, then action through optimization.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>I have helped many engineers analyze queries, and the primary difficulty is not understanding the metrics but getting stuck in the analysis: staring deeply into the numbers, waiting for a revelation.&#13;
Don’t get stuck.&#13;
Carefully review all the metrics and metadata—read the whole story—then turn your attention to query optimization with the goal of improving response time.</p>&#13;
</div>&#13;
&#13;
<p>The following sections address key aspects to an efficient and insightful query analysis.&#13;
Sometimes the cause of slow response time is so obvious that the analysis reads more like a tweet than a story.&#13;
But when it’s not—when the analysis reads like a graduate thesis on French existentialism—understanding these aspects will help you find the cause and determine a solution.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Query Metrics" data-type="sect2"><div class="sect2" id="query-metrics">&#13;
<h2>Query Metrics</h2>&#13;
&#13;
<p>From <a data-type="xref" href="#query-sources">“Sources”</a>, <a data-primary="query metrics" data-type="indexterm" id="idm45829113486672"/>you know that query metrics vary depending on the source, MySQL distribution, and MySQL version.&#13;
All query metrics are important because they help you understand query execution, but the nine metrics detailed in the following sections are essential to every query analysis.</p>&#13;
&#13;
<p>The Performance Schema provides all nine essential query metrics.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Query metric names also vary by source.&#13;
In the slow query log, query time is <code>Query_time</code>; but in the Performance Schema, it’s <code>TIMER_WAIT</code>.&#13;
I don’t use either convention.&#13;
Instead, I use human-friendly names like <em>query time</em> and <em>rows sent</em>.&#13;
Query reporting almost always uses human-friendly names, too.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Query time" data-type="sect3"><div class="sect3" id="Query-time">&#13;
<h3>Query time</h3>&#13;
&#13;
<p>Query time <a data-primary="query metrics" data-secondary="query time" data-type="indexterm" id="query-time"/>is the most important metric—you knew that already. What you may not know is that query time includes another metric: lock time.</p>&#13;
&#13;
<p>Lock time is an inherent part of query time, so it’s not surprising that the latter includes the former.&#13;
What’s surprising is that query time and lock time are the only two time-based query metrics, with one exception: the Percona Server <a data-primary="Percona Server" data-secondary="query analysis" data-type="indexterm" id="idm45829113478016"/>slow query log has metrics for InnoDB read time, row lock wait time, and queue wait time.&#13;
Lock time is important, but there’s an unfortunate technical gotcha: it’s accurate only in the slow query log.&#13;
More on this later.</p>&#13;
&#13;
<p>Using the Performance Schema, you can see many (but not all) parts of query execution.&#13;
This is off-topic and beyond the scope of this book, but it’s good awareness so you know where to look if you need to dig deeper.&#13;
MySQL instruments a bewildering number of <em>events</em> that the manual defines as, “anything the server does that takes time and has been instrumented so that timing information can be collected.”&#13;
Events are organized in a hierarchy:</p>&#13;
&#13;
<pre data-type="programlisting">transactions&#13;
└── statements&#13;
    └── stages&#13;
        └── waits</pre>&#13;
<dl>&#13;
<dt>Transactions</dt>&#13;
<dd>&#13;
<p>Transactions <a data-primary="transactions" data-type="indexterm" id="idm45829113472992"/>are the top-level event because every query executes in a transaction (<a data-type="xref" href="ch08.html#ch08">Chapter 8</a> covers transactions).</p>&#13;
</dd>&#13;
<dt>Statements</dt>&#13;
<dd>&#13;
<p>Statements <a data-primary="statements" data-type="indexterm" id="idm45829113470016"/>are queries, to which query metrics apply.</p>&#13;
</dd>&#13;
<dt>Stages</dt>&#13;
<dd>&#13;
<p>Stages <a data-primary="stages" data-type="indexterm" id="idm45829113467872"/>are “steps during the statement-execution process, such as parsing a statement, opening a table, or performing a filesort operation.”</p>&#13;
</dd>&#13;
<dt>Waits</dt>&#13;
<dd>&#13;
<p>Waits <a data-primary="waits" data-secondary="event" data-type="indexterm" id="idm45829113465568"/>are “events that take time.”&#13;
(This definition amuses me. It’s tautological and oddly satisfying in its simplicity.)</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#update-stages">Example 1-3</a> shows the stages for a single <code>UPDATE</code> statement (as of MySQL 8.0.22).</p>&#13;
<div class="pagebreak-before less_space" data-type="example" id="update-stages">&#13;
<h5><span class="label">Example 1-3. </span>Stages for a single <code>UPDATE</code> statement</h5>&#13;
&#13;
<pre data-type="programlisting">+----------------------------------+----------------------------------+-----------+&#13;
| stage                            | source:line                      | time (ms) |&#13;
+----------------------------------+----------------------------------+-----------+&#13;
| stage/sql/starting               | init_net_server_extension.cc:101 |     0.109 |&#13;
| stage/sql/Executing hook on trx  | rpl_handler.cc:1120              |     0.001 |&#13;
| stage/sql/starting               | rpl_handler.cc:1122              |     0.008 |&#13;
| stage/sql/checking permissions   | sql_authorization.cc:2200        |     0.004 |&#13;
| stage/sql/Opening tables         | sql_base.cc:5745                 |     0.102 |&#13;
| stage/sql/init                   | sql_select.cc:703                |     0.007 |&#13;
| stage/sql/System lock            | lock.cc:332                      |     0.072 |&#13;
| stage/sql/updating               | sql_update.cc:781                | 10722.618 |&#13;
| stage/sql/end                    | sql_select.cc:736                |     0.003 |&#13;
| stage/sql/query end              | sql_parse.cc:4474                |     0.002 |&#13;
| stage/sql/waiting handler commit | handler.cc:1591                  |     0.034 |&#13;
| stage/sql/closing tables         | sql_parse.cc:4525                |     0.015 |&#13;
| stage/sql/freeing items          | sql_parse.cc:5007                |     0.061 |&#13;
| stage/sql/logging slow query     | log.cc:1640                      |     0.094 |&#13;
| stage/sql/cleaning up            | sql_parse.cc:2192                |     0.002 |&#13;
+----------------------------------+----------------------------------+-----------+</pre></div>&#13;
&#13;
<p>The real output is more complex; I simplified it for easy reading.&#13;
The <code>UPDATE</code> statement executed in 15 stages.&#13;
The actual execution of the <code>UPDATE</code> was the eighth stage: <code>stage/sql/updating</code>.&#13;
There were 42 waits, <a data-primary="waits" data-secondary="event" data-type="indexterm" id="idm45829113456560"/>but I removed them from the output because they’re too far off topic.</p>&#13;
&#13;
<p>Performance Schema events (transactions, statements, stages, and waits) are the fine details of query execution. Query metrics apply to statements. If you need to dig deeper in a query, look in the Performance Schema.</p>&#13;
&#13;
<p>Efficiency is our modus operandi, so don’t get lost in the Performance Schema until you need to, which may be never. Query time is sufficient.<a data-primary="query metrics" data-secondary="query time" data-startref="query-time" data-type="indexterm" id="idm45829113454144"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lock time" data-type="sect3"><div class="sect3" id="Lock-time">&#13;
<h3>Lock time</h3>&#13;
&#13;
<p><em>Lock time</em> <a data-primary="query metrics" data-secondary="lock time" data-type="indexterm" id="lock-time_index1"/><a data-primary="lock time" data-type="indexterm" id="lock-time_index2"/>is time spent acquiring locks during query execution. Ideally, lock time is a minuscule percentage of query time, but values are relative (see <a data-type="xref" href="#values-are-relative">“Relative Values”</a>). For example, on one extremely optimized database that I manage, lock time is 40% to 50% of query time for the slowest query. Sounds terrible, right? But it’s not: the slowest query has a maximum query time of 160 microseconds and a maximum lock time of 80 microseconds—and the database executes over 20,000 queries per second (QPS).</p>&#13;
&#13;
<p>Although values are relative, I can safely say that lock time greater than 50% of query time is a problem because MySQL should spend the vast majority of its time doing work, not waiting. A theoretically perfect query execution would have zero wait time, but that’s impossible due to shared resources, concurrency, and latency inherent in the system. Still, we can dream.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45829113445824">&#13;
<h5>MySQL Storage Engines and Data Locking</h5>&#13;
<p>Before I explain more about lock time and locks in general, let me clarify some background information.</p>&#13;
&#13;
<p>MySQL has many storage engines<a data-primary="storage engines" data-type="indexterm" id="idm45829113443536"/>—and a history of storage engines, but I won’t bore you with that.&#13;
The default storage engine is InnoDB.<a data-primary="InnoDB" data-secondary="default storage engine for MySQL" data-secondary-sortas="default storage engine for MySQL" data-type="indexterm" id="idm45829113442576"/>&#13;
Other storage engines include:  MyISAM, MEMORY, <a href="https://oreil.ly/Ubz65">TempTable</a>, <a href="https://oreil.ly/VVAjG">Aria</a> with MariaDB, <a href="https://myrocks.io">MyRocks</a> with Percona Server <a data-primary="Percona Server" data-secondary="query analysis" data-type="indexterm" id="idm45829113439056"/>and MariaDB, <a href="https://oreil.ly/jrGlq">XtraDB</a> with Percona Server, and more. (Fun fact: the Performance Schema is implemented as a storage engine.) In this book, InnoDB is implied unless stated otherwise.</p>&#13;
&#13;
<p>There are table locks and row locks. The server (MySQL) manages tables and table locks. Tables are created using a storage engine (InnoDB by default) but are storage engine agnostic, meaning you can convert a table from one storage engine to another. Row-level locking is managed by the storage engine if supported. MyISAM does not support row-level locking, so it manages data access with table locks. InnoDB supports row-level locking, so it manages data access with row locks. Since InnoDB is the default storage engine, row-level locking is implied unless stated otherwise.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>InnoDB also has table locks called <a href="https://oreil.ly/XYLnq"><em>intention locks</em></a>, but they’re not important for this discussion.</p>&#13;
</div>&#13;
&#13;
<p>There are metadata locks managed by the server that control access to schemas, tables, stored programs, and more. Whereas table locks and row locks control access to table data, metadata locks control access to table structures (columns, indexes, and so on) to prevent changes while queries are accessing the tables. Every query acquires a metadata lock on every table that it accesses. Metadata locks are released at the end of the transaction, not the query.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember: InnoDB and row-level locking are implied unless stated otherwise.</p>&#13;
</div>&#13;
</div></aside>&#13;
&#13;
<p class="pagebreak-before">Remember the unfortunate technical gotcha mentioned earlier? Here it is: lock time from the Performance Schema does <em>not</em> include row lock waits, <a data-primary="waits" data-secondary="row lock" data-type="indexterm" id="idm45829113430896"/>only table and metadata lock waits. Row lock waits are the most important part of lock time, which makes lock time from the Performance Schema nearly useless. By contrast, lock time from the slow query log includes all lock waits: metadata, table, and row. Lock time from either source does not indicate which type of lock wait. From the Performance Schema, it’s certainly metadata lock wait; and from the slow query log, it’s probably row lock wait, but metadata lock wait is a possibility, too.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Lock time from the Performance Schema does not include row lock waits.</p>&#13;
</div>&#13;
&#13;
<p>Locks are primarily used for writes (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>REPLACE</code>) because rows must be locked before they can be written.&#13;
Response time for writes depends, in part, on lock time.&#13;
The amount of time needed to acquire row locks depends on concurrency: how many queries are accessing the same (or nearby) rows at the same time.&#13;
If a row has zero concurrency (accessed by only one query at a time), then lock time is vanishingly small.&#13;
But if a row is <em>hot</em>—jargon for <em>very frequently accessed</em>—then lock time could account for a significant percentage of response time.&#13;
Concurrency is one of several  data access patterns (see <a data-type="xref" data-xrefstyle="select:nopage" href="ch04.html#access-patterns">“Data Access Patterns”</a> in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>).</p>&#13;
&#13;
<p>For reads (<code>SELECT</code>), there are nonlocking and <a href="https://oreil.ly/WcyD3">locking reads</a>. The distinction is easy because there are only two locking reads: <code>SELECT</code>…<code>FOR UPDATE</code> and <code>SELECT</code>…<code>FOR SHARE</code>. If not one of those two, then <code>SELECT</code> is nonlocking, which is the normal case.</p>&#13;
&#13;
<p>Although <code>SELECT</code>…<code>FOR UPDATE</code> and <code>SELECT</code>…<code>FOR SHARE</code> are the only locking reads, don’t forget about writes with an optional <code>SELECT</code>.&#13;
In the following SQL statements, the <code>SELECT</code> acquires shared row locks on table <code>s</code>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>INSERT</code>…<code>SELECT FROM s</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>REPLACE</code>…<code>SELECT FROM s</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>UPDATE</code>…<code>WHERE</code>…<code>(SELECT FROM s)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>CREATE TABLE</code>…<code>SELECT FROM s</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Strictly speaking, those SQL statements are writes, not reads, but the optional <code>SELECT</code> acquires shared row locks on table <code>s</code>.&#13;
See <a href="https://oreil.ly/SJXcq">“Locks Set by Different SQL Statements in InnoDB”</a> in the MySQL manual for details.</p>&#13;
&#13;
<p class="pagebreak-before">Locking reads should be avoided, especially <code>SELECT</code>…<code>FOR UPDATE</code>, because they don’t scale, they tend to cause problems, and there is usually a nonlocking solution to achieve the same result.&#13;
With respect to lock time, a locking read is like a write: it depends on concurrency.&#13;
Be careful with <code>SELECT</code>…<code>FOR SHARE</code>: shared locks are compatible with other shared locks, but they’re incompatible with exclusive locks, which means shared locks block writes on the same (or nearby) rows.</p>&#13;
&#13;
<p>For nonlocking reads, even though row locks are not acquired, lock time will not be zero because metadata and table locks are acquired. But acquiring these two should be very fast: less than 1 millisecond. For example, another database I manage executes over 34,000 QPS but the slowest query is a nonlocking <code>SELECT</code> that does a full table scan, reading six million rows every execution, with very high concurrency: 168 query load. Despite these large values, its maximum lock time is 220 microseconds, and average lock time is 80 microseconds.</p>&#13;
&#13;
<p>Nonlocking read does <em>not</em> mean non-blocking. <code>SELECT</code> queries must acquire shared metadata locks (MDL) on all tables accessed. As usual with locks, shared MDL are compatible with other shared MDL, but one exclusive MDL blocks all other MDL. <code>ALTER TABLE</code> is the common operation that acquires an exclusive MDL. Even using <code>ALTER TABLE</code>…<code>ALGORITHM=INPLACE, LOCK=NONE</code> or third-party online schema change tools like <a href="https://oreil.ly/EzcrU">pt-online-schema-change</a> and <a href="https://oreil.ly/TeHjG"><code>gh-ost</code></a>, an exclusive MDL must be acquired at the end to swap the old table structure for the new one. Although the table swap is very quick, it can cause a noticeable disruption when MySQL is heavily loaded because <em>all</em> table access is blocked while the exclusive MDL is held. This problem shows up as a blip in lock time, especially for <code>SELECT</code> statements.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p><code>SELECT</code> can block waiting for metadata locks.</p>&#13;
</div>&#13;
&#13;
<p>Locking might be the most complex and nuanced aspect of MySQL.&#13;
To avoid going down the proverbial rabbit hole, let me state five points but defer explanation for now.&#13;
Merely being aware of these points greatly increases your MySQL prowess:</p>&#13;
<ul>&#13;
<li> Lock time can be significantly greater than <a href="https://oreil.ly/HlWwX"><code>innodb_lock_wait_timeout</code></a> because this system variable applies to <em>each row lock</em>.</li>&#13;
<li> Locking and transaction isolation levels are related.</li>&#13;
<li> InnoDB locks every row it accesses <em>including rows it does not write</em>.</li>&#13;
<li class="pagebreak-before">Locks are released on transaction commit or rollback, and sometimes during query execution.</li>&#13;
<li> InnoDB has different types of locks: record, gap, next-key, and more.</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="ch08.html#row-locking">“Row Locking”</a> goes into detail.&#13;
For now, let’s put it all together and visualize how query time includes lock time.&#13;
<a data-type="xref" href="#lock-time-during-query-exec">Figure 1-1</a> shows locks acquired and released during query execution.</p>&#13;
&#13;
<figure><div class="figure" id="lock-time-during-query-exec">&#13;
<img alt="emsp 0101" src="assets/emsp_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>Lock time during query execution</h6>&#13;
</div></figure>&#13;
&#13;
<p>Labels 1 to 10 mark events and details with respect to locking:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Acquire shared metadata lock on table</p>&#13;
</li>&#13;
<li>&#13;
<p>Acquire intention exclusive (IX) table lock</p>&#13;
</li>&#13;
<li>&#13;
<p>Acquire row lock 1</p>&#13;
</li>&#13;
<li>&#13;
<p>Update (write) row 1</p>&#13;
</li>&#13;
<li>&#13;
<p>Acquire row lock 2</p>&#13;
</li>&#13;
<li>&#13;
<p>Release row lock 2</p>&#13;
</li>&#13;
<li>&#13;
<p>Acquire row lock 3</p>&#13;
</li>&#13;
<li>&#13;
<p>Update (write) row 3</p>&#13;
</li>&#13;
<li>&#13;
<p>Commit transaction</p>&#13;
</li>&#13;
<li>&#13;
<p>Release all locks</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Two points of interest:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Lock time from the Performance Schema includes only labels <code>1</code> and <code>2</code>. From the slow query log it includes labels <code>1</code>, <code>2</code>, <code>3</code>, <code>5</code>, and <code>7</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Although row 2 is locked (label <code>5</code>), it’s not written and its lock is released (label <code>6</code>) before the transaction commits (label <code>9</code>). This can happen, but not always. It depends on the query and transaction isolation level.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>That was a lot of information about lock time and locking, but now you are well-equipped to understand lock time in your query analysis.<a data-primary="query metrics" data-secondary="lock time" data-startref="lock-time_index1" data-type="indexterm" id="idm45829113366512"/><a data-primary="lock time" data-startref="lock-time_index2" data-type="indexterm" id="idm45829113365264"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rows examined" data-type="sect3"><div class="sect3" id="Rows-examined">&#13;
<h3>Rows examined</h3>&#13;
&#13;
<p><em>Rows examined</em> <a data-primary="rows examined" data-type="indexterm" id="rows-examined1_index1"/><a data-primary="query metrics" data-secondary="rows examined" data-type="indexterm" id="rows-examined1_index2"/>is the number of rows that MySQL accessed to find matching rows.&#13;
It indicates the selectivity of the query and the indexes.&#13;
The more selective both are, the less time MySQL wastes examining non-matching rows.&#13;
This applies to reads and writes, except <code>INSERT</code> unless it’s an <code>INSERT</code>…<code>SELECT</code> statement.</p>&#13;
&#13;
<p>To understand rows examined, let’s look at two examples.&#13;
First, let’s use the following table, <code>t1</code>, and three rows:</p>&#13;
&#13;
<pre data-type="programlisting">CREATE TABLE `t1` (&#13;
  `id` int NOT NULL,&#13;
  `c` char(1) NOT NULL,&#13;
  PRIMARY KEY (`id`)&#13;
) ENGINE=InnoDB;&#13;
&#13;
+----+---+&#13;
| id | c |&#13;
+----+---+&#13;
|  1 | a |&#13;
|  2 | b |&#13;
|  3 | c |&#13;
+----+---+</pre>&#13;
&#13;
<p>Column <code>id</code> is the primary key, and column <code>c</code> is not indexed.</p>&#13;
&#13;
<p>The query <code>SELECT c FROM t1 WHERE c = 'b'</code> matches one row but examines three rows because there is no unique index on column <code>c</code>.&#13;
Therefore, MySQL has no idea how many rows match the <code>WHERE</code> clause.&#13;
We can see that only one row matches, but MySQL doesn’t have eyes, it has indexes.&#13;
By contrast, the query <code>SELECT c FROM t1 WHERE id = 2</code> matches and examines only one row because there is a unique index on column <code>id</code> (the primary key) and the table condition uses the entire index.&#13;
Now MySQL can figuratively see that only one row matches, so that’s all it examines.&#13;
<a data-type="xref" href="ch02.html#ch02">Chapter 2</a> teaches indexes and indexing, which explain table conditions and a lot more.</p>&#13;
&#13;
<p>For the second example, let’s use the following table, <code>t2</code>, and seven rows:</p>&#13;
&#13;
<pre data-type="programlisting">CREATE TABLE `t2` (&#13;
  `id` int NOT NULL,&#13;
  `c` char(1) NOT NULL,&#13;
  `d` varchar(8) DEFAULT NULL,&#13;
  PRIMARY KEY (`id`),&#13;
  KEY `c` (`c`)&#13;
) ENGINE=InnoDB;</pre>&#13;
&#13;
<pre class="pagebreak-before less_space" data-type="programlisting">+----+------+--------+&#13;
| id | c    | d      |&#13;
+----+------+--------+&#13;
|  1 | a    | apple  |&#13;
|  2 | a    | ant    |&#13;
|  3 | a    | acorn  |&#13;
|  4 | a    | apron  |&#13;
|  5 | b    | banana |&#13;
|  6 | b    | bike   |&#13;
|  7 | c    | car    |&#13;
+----+------+--------+</pre>&#13;
&#13;
<p>Column <code>id</code> is the same as before (primary key).&#13;
Column <code>c</code> has a <em>nonunique</em> index.&#13;
Column <code>d</code> is not indexed.</p>&#13;
&#13;
<p>How many rows will query <code>SELECT d FROM t2 WHERE c = 'a' AND d = 'acorn'</code> examine?&#13;
The answer is: four.&#13;
MySQL uses the nonunique index on column <code>c</code> to look up rows matching the condition <code>c = 'a'</code>, and that matches four rows.&#13;
And to match the other condition, <code>d = 'acorn'</code>, MySQL examines each of those four rows.&#13;
As a result, the query examines four rows but matches (and returns) only one row.</p>&#13;
&#13;
<p>It’s not uncommon to discover that a query examines more rows than expected. The cause is usually the selectivity of the query or the indexes (or both), but sometimes it’s because the table has grown a lot larger than expected, so there are a lot more rows to examine. <a data-type="xref" href="ch03.html#ch03">Chapter 3</a> examines this further (pun intended).</p>&#13;
&#13;
<p>Rows examined only tells half the story. The other half is rows sent.<a data-primary="rows examined" data-startref="rows-examined1_index1" data-type="indexterm" id="idm45829113341712"/><a data-primary="query metrics" data-secondary="rows examined" data-startref="rows-examined1_index2" data-type="indexterm" id="idm45829113340656"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rows sent" data-type="sect3"><div class="sect3" id="Rows-sent">&#13;
<h3>Rows sent</h3>&#13;
&#13;
<p><em>Rows sent</em> <a data-primary="query metrics" data-secondary="rows sent" data-type="indexterm" id="rows-sent_index1"/><a data-primary="rows sent" data-type="indexterm" id="rows-sent_index2"/>is the number of rows returned to the client—the result set size.&#13;
Rows sent is most meaningful in relation to rows examined.</p>&#13;
<dl>&#13;
<dt>Rows sent = Rows examined</dt>&#13;
<dd>&#13;
<p>The ideal case is when rows sent and rows examined are equal and the value is relatively small, especially as a percentage of total rows, and query response time is acceptable. For example, 1,000 rows from a table with one million rows is a reasonable 0.1%. This is ideal if response time is acceptable. But 1,000 rows from a table with only 10,000 rows is a questionable 10% even if response time is acceptable. Regardless of the percentage, if rows sent and rows examined are equal and the value is suspiciously high, it strongly indicates that the query is causing a table scan, which is usually terrible for performance—<a data-type="xref" href="ch02.html#table-scan">“Table scan”</a> explains why.</p>&#13;
</dd>&#13;
<dt>Rows sent &lt; Rows examined</dt>&#13;
<dd>&#13;
<p>Fewer rows sent than examined is a reliable sign of poor query or index selectivity. If the difference is extreme, it likely explains slow response time. For example, 1,000 rows sent and 100,000 rows examined aren’t large values, but they mean 99% of rows did not match—the query caused MySQL to waste a lot of time. Even if response time is acceptable, an index could dramatically reduce the wasted time.</p>&#13;
</dd>&#13;
<dt>Rows sent &gt; Rows examined</dt>&#13;
<dd>&#13;
<p>It’s possible, but rare, to send more rows than were examined. This happens under special conditions, like when MySQL can “optimize away” the query. For example, <code>SELECT COUNT(id) FROM t2</code> on the table in the previous section sends one row for the value of <code>COUNT(id)</code> but examines zero rows.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Rows sent is rarely a problem by itself. Modern networks are fast and the MySQL protocol is efficient. If your distribution and version of MySQL have the <em>bytes sent</em> metric in the slow query log (the Performance Schema does not provide this query metric), you can use it two ways. First, the minimum, maximum, and average values reveal the result set size in bytes. This is usually small, but it can be large if the query returns <code>BLOB</code> or <code>JSON</code> columns. Second, total bytes sent can be converted to a network throughput (Mbps or Gbps) to reveal the network utilization of the query, which is also usually very small.<a data-primary="rows sent" data-startref="rows-sent_index2" data-type="indexterm" id="idm45829113325024"/><a data-primary="query metrics" data-secondary="rows sent" data-startref="rows-sent_index1" data-type="indexterm" id="idm45829113324048"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rows affected" data-type="sect3"><div class="sect3" id="Rows-affected">&#13;
<h3>Rows affected</h3>&#13;
&#13;
<p><em>Rows affected</em> <a data-primary="query metrics" data-secondary="rows affected" data-type="indexterm" id="idm45829113320848"/><a data-primary="rows affected" data-type="indexterm" id="idm45829113319840"/>is the number of rows inserted, updated, or deleted.&#13;
Engineers are very careful to affect only the correct rows.&#13;
It’s a serious bug when the wrong rows are changed.&#13;
Viewed this way, the value of rows affected is always correct.&#13;
But a surprisingly large value could indicate a new or modified query that affects more rows than intended.</p>&#13;
&#13;
<p>Another way to view rows affected is as the batch size of bulk operations. Bulk <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> are a common source of several problems: replication lag, history list length, lock time, and overall performance degradation. Equally common is the question, “How large should the batch size be?” There’s no universally correct answer.&#13;
Instead, you must determine the batch size <em>and</em> rate that MySQL and the application can sustain without impacting query response time.&#13;
I explain in <a data-type="xref" href="ch03.html#batch-size">“Batch Size”</a>, which focuses on <code>DELETE</code> but is also applicable to <code>INSERT</code> and <code>UPDATE</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Select scan" data-type="sect3"><div class="sect3" id="Select-scan">&#13;
<h3>Select scan</h3>&#13;
&#13;
<p><em>Select scan</em> <a data-primary="query metrics" data-secondary="select scan" data-type="indexterm" id="select-scan_index1"/><a data-primary="select scan" data-type="indexterm" id="select-scan_index2"/>is the number of full table scans on the first table accessed.&#13;
(If the query accesses two or more tables, the next metric applies: select full join.)&#13;
This is usually bad for performance because it means the query isn’t using an index.&#13;
After <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, which teaches indexes and indexing, it should be easy to add an index to fix a table scan.&#13;
If select scan is not zero, query optimization is strongly advised.</p>&#13;
&#13;
<p>It’s possible, but <em>very</em> rare, that a query causes a table scan sometimes but not always. To determine why, you need a query sample and EXPLAIN plan for both: a query sample that causes a table scan, and a query sample that does not. One likely reason is how many rows MySQL estimates the query will examine relative to index cardinality (the number of unique values in the index), total rows in the table, and other costs. (The MySQL query optimizer uses a cost model.) Estimates aren’t perfect and sometimes MySQL is wrong, resulting in a table scan or suboptimal execution plan, but again: this is <em>very</em> rare.</p>&#13;
&#13;
<p>More than likely, select scan is either all zero or all one (it’s a binary value).&#13;
Be happy if it’s zero.&#13;
Optimize the query if it’s not zero.<a data-primary="select scan" data-startref="select-scan_index2" data-type="indexterm" id="idm45829113305568"/><a data-primary="query metrics" data-secondary="select scan" data-startref="select-scan_index1" data-type="indexterm" id="idm45829113304592"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Select full join" data-type="sect3"><div class="sect3" id="Select-full-join">&#13;
<h3>Select full join</h3>&#13;
&#13;
<p><em>Select full join</em> <a data-primary="query metrics" data-secondary="select full join" data-type="indexterm" id="select-full-join_index1"/><a data-primary="select full join" data-type="indexterm" id="select-full-join_index2"/>is the number of full table scans on tables joined.&#13;
This is similar to select scan but worse—I explain why in a moment.&#13;
Select full join should always be zero; if not, query optimization is practically required.</p>&#13;
&#13;
<p>When you <a href="https://oreil.ly/sRswS"><code>EXPLAIN</code> a query with multiple tables</a>, MySQL prints the table join order from top (first table) to bottom (last table). Select scan applies only to the first table. Select full join applies only to the second and subsequent tables.</p>&#13;
&#13;
<p>Table join order is determined by MySQL, not the query.<sup><a data-type="noteref" href="ch01.html#idm45829113296432" id="idm45829113296432-marker">2</a></sup>&#13;
<a data-type="xref" href="#explain-3-table">Example 1-4</a> shows the EXPLAIN plan for <code>SELECT</code>…<code>FROM t1, t2, t3</code>: MySQL determines a different join order than the implicit three-table join in the query.</p>&#13;
<div data-type="example" id="explain-3-table">&#13;
<h5><span class="label">Example 1-4. </span>EXPLAIN plan for three tables joined</h5>&#13;
&#13;
<pre data-type="programlisting">*************************** 1. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: t3&#13;
   partitions: NULL&#13;
         type: ALL&#13;
possible_keys: NULL&#13;
          key: NULL&#13;
      key_len: NULL&#13;
          ref: NULL&#13;
         rows: 3&#13;
     filtered: 100.00&#13;
        Extra: NULL&#13;
*************************** 2. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: t1&#13;
   partitions: NULL&#13;
         type: range&#13;
possible_keys: PRIMARY&#13;
          key: PRIMARY&#13;
      key_len: 4&#13;
          ref: NULL&#13;
         rows: 2&#13;
     filtered: 100.00&#13;
        Extra: Using where&#13;
*************************** 3. row ***************************&#13;
           id: 1&#13;
  select_type: SIMPLE&#13;
        table: t2&#13;
   partitions: NULL&#13;
         type: ALL&#13;
possible_keys: NULL&#13;
          key: NULL&#13;
      key_len: NULL&#13;
          ref: NULL&#13;
         rows: 7&#13;
     filtered: 100.00&#13;
        Extra: NULL</pre></div>&#13;
&#13;
<p>MySQL reads table <code>t3</code> first, then joins table <code>t1</code>, then joins table <code>t2</code>.&#13;
That join order is different than the query (<code>FROM t1, t2, t3</code>), which is why you must <code>EXPLAIN</code> a query to see its join order.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Always <code>EXPLAIN</code> a query to see its join order.</p>&#13;
</div>&#13;
&#13;
<p>Select scan applies to table <code>t3</code> because it’s the first table in the join order and it causes a table scan (indicated by <code>type: ALL</code>).&#13;
Select full join would apply to table <code>t1</code> if it caused a table scan, but it doesn’t: MySQL joins the table using a range scan on the primary key (indicated by <code>type: range</code> and <code>key: PRIMARY</code>, respectively).&#13;
Select full join applies to table <code>t2</code> because MySQL joins it using a full table scan (indicated by <code>type: ALL</code>).</p>&#13;
&#13;
<p>The table scan on <code>t2</code> is called a <em>full join</em> because MySQL scans the full table on join.&#13;
Select full join is worse than select scan because the number of full joins that occur on a table during query execution is equal to the product of rows from the preceding tables.&#13;
MySQL estimates three rows from table <code>t3</code> (indicated by <code>rows: 3</code>) and two rows from table <code>t1</code> (indicated by <code>rows: 2</code>).&#13;
Therefore, 3 × 2 = 6 full joins on table <code>t2</code> during query execution.&#13;
But the select full join metric value will be 1 because it counts full joins in the execution plan, not during query execution, which is sufficient because even one full join is too many.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of MySQL 8.0.18, the <a href="https://oreil.ly/zf7Rs">hash join optimization</a> improves performance for certain joins, but avoiding full joins remains the best practice.&#13;
See <a data-type="xref" href="ch02.html#table-join-algos">“Table Join Algorithms”</a> for a brief overview of hash join.<a data-primary="query metrics" data-secondary="select full join" data-startref="select-full-join_index1" data-type="indexterm" id="idm45829115058992"/><a data-primary="select full join" data-startref="select-full-join_index2" data-type="indexterm" id="idm45829115057776"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Created tmp disk tables" data-type="sect3"><div class="sect3" id="Created-tmp-disk-tables">&#13;
<h3>Created tmp disk tables</h3>&#13;
&#13;
<p><em>Created tmp disk tables</em> <a data-primary="query metrics" data-secondary="created tmp disk tables" data-type="indexterm" id="idm45829115054672"/><a data-primary="created tmp disk tables" data-type="indexterm" id="idm45829115053664"/>is the number of temporary tables created on disk.&#13;
It’s normal for queries to create temporary tables in memory; but when an in-memory temporary table becomes too large, MySQL writes it to disk.&#13;
That can affect response time because disk access is orders of magnitude slower than memory access.</p>&#13;
&#13;
<p>However, temporary tables on disk is not a common problem because MySQL tries to avoid them.&#13;
Excessive “tmp disk tables” indicates a query that can be optimized, or (perhaps) the system variable <a href="https://oreil.ly/8exZw"><code>tmp_table_size</code></a> is too small.&#13;
Always optimize queries first.&#13;
Change system variables as a last resort—especially ones that affect memory allocation.</p>&#13;
&#13;
<p>See <a href="https://oreil.ly/CeCSv">“Internal Temporary Table Use in MySQL”</a> in the MySQL manual for more information.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Query count" data-type="sect3"><div class="sect3" id="Query-count">&#13;
<h3>Query count</h3>&#13;
&#13;
<p><em>Query count</em> <a data-primary="query metrics" data-secondary="query count" data-type="indexterm" id="idm45829115047504"/><a data-primary="query count" data-type="indexterm" id="idm45829115046496"/>is the number of query executions.&#13;
The value is arbitrary unless extremely low and the query is slow.&#13;
“Low and slow” is an odd combination worth investigating.</p>&#13;
&#13;
<p>As I write this, I’m looking at a query profile that’s a perfect example: the slowest query executed <em>once</em> but took 44% of execution time. Other metrics are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Response time: 16 s</p>&#13;
</li>&#13;
<li>&#13;
<p>Lock time: 110 μs</p>&#13;
</li>&#13;
<li>&#13;
<p>Rows examined: 132,000</p>&#13;
</li>&#13;
<li>&#13;
<p>Rows sent: 13</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Not your everyday query. It looks like an engineer manually executed the query, but I can tell from the digest text that it was programmatically generated. What’s the story behind this query? To find out, I’ll have to ask the application developers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Metadata and the Application" data-type="sect2"><div class="sect2" id="metadata-completes-the-story">&#13;
<h2>Metadata and the Application</h2>&#13;
&#13;
<p>There’s <a data-primary="metadata and the application" data-type="indexterm" id="idm45829115038128"/>more to query analysis than query metrics: metadata.&#13;
In fact, you can’t complete a query analysis without at least two pieces of metadata: the EXPLAIN plan (also called the <em>query execution plan</em>), and the table structure for each table.&#13;
A few query metric tools automatically collect metadata and show it in the query report.&#13;
If your query metric tool does not, don’t worry: it’s easy to collect metadata.&#13;
<a href="https://oreil.ly/AZvGt"><code>EXPLAIN</code></a> and <a href="https://oreil.ly/Wwp8f"><code>SHOW CREATE TABLE</code></a> report the EXPLAIN plan and table structures, respectively.</p>&#13;
&#13;
<p>Metadata is indispensable for query analysis, query optimization, and MySQL performance in general.&#13;
<code>EXPLAIN</code> is a vital tool in your MySQL repertoire.&#13;
I explain it in <a data-type="xref" href="ch02.html#EXPLAIN">“EXPLAIN: Query Execution Plan”</a> and use it extensively throughout this book.</p>&#13;
&#13;
<p>There’s even more to query analysis than query metrics and metadata: the application.&#13;
Metrics and metadata are must-have for any query analysis, but the story is only complete when you know what purpose the query serves: <em>why</em> does the application execute the query?&#13;
Knowing this allows you to evaluate changes to the application, which is the focus of <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>.&#13;
More than once, I’ve seen engineers realize that a query can be a lot simpler—or completely removed.</p>&#13;
&#13;
<p>Query metrics, metadata, and the application should complete the story.&#13;
But I’d be remiss not to mention that, sometimes, issues outside MySQL and the application influence the story—and usually not for the better.&#13;
<a data-type="xref" href="ch09.html#noisy-neighbors">“Noisy Neighbors”</a> is a classic case.&#13;
If response time is slow but a thorough query analysis doesn’t reveal why, then consider outside issues.&#13;
But don’t be too quick to jump to this conclusion; outside issues should be the exception, never the norm.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Relative Values" data-type="sect2"><div class="sect2" id="values-are-relative">&#13;
<h2>Relative Values</h2>&#13;
&#13;
<p>For <a data-primary="relative values" data-type="indexterm" id="idm45829115027360"/>each query metric, the only objectively good value is zero because, as the saying goes, the fastest way to do something is to not do it. Nonzero values are always relative to the query and application. For example, one thousand rows sent is fine in general, but it could be terrible if the query is supposed to return only one row.&#13;
Relative values are meaningful when considering the full story: metrics, metadata, and the application.</p>&#13;
&#13;
<p>Here’s another true story to illustrate that values are relative and meaningful with the full story.&#13;
I inherited an application that became slower and slower over the years.&#13;
It was an internal application—not used by customers—so fixing it wasn’t a priority until it became unbearably slow.&#13;
In the query profile, the slowest query was examining and returning over ten thousand rows—not a full table scan, just a lot of rows.&#13;
Instead of fixating on the values, I went spelunking in the source code and discovered that the function executing the query was only counting the number of rows, not using the rows.&#13;
It was slow because it needlessly accessed and returned thousands of rows, and it became slower over time because the number of rows increased as the database grew.&#13;
With the full story, the optimization was glaringly obvious and simple: <code>SELECT COUNT(*)</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Average, Percentile, and Maximum" data-type="sect2"><div class="sect2" id="avg-p-max-distro">&#13;
<h2>Average, Percentile, and Maximum</h2>&#13;
&#13;
<p>It’s standard to talk about query response time as if it’s a single value, but it’s not.&#13;
From <a data-type="xref" href="#query-aggregation">“Aggregation”</a> you know that query metrics are grouped and aggregated by query.&#13;
As a result, query metrics are reported as single, statistical values: minimum, maximum, average, and percentile.&#13;
You are undoubtedly familiar with these ubiquitous “stats,” but with respect to query response time, the following points may surprise you:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Average is overly optimistic</p>&#13;
</li>&#13;
<li>&#13;
<p>Percentile is an assumption</p>&#13;
</li>&#13;
<li>&#13;
<p>Maximum is the best representation</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let me explain:</p>&#13;
<dl>&#13;
<dt>Average</dt>&#13;
<dd>&#13;
<p>Don’t be fooled by the average: <a data-primary="average (statistic)" data-type="indexterm" id="idm45829115015728"/>if query count is small, a few very large or small values can skew the average response time (or any metric). Moreover, without knowing the distribution of values, we cannot know what percentage of values the average represents. For example, if the average equals the median, then the average represents the bottom 50% of values, which are the better (faster) response times. In that case, the average is overly optimistic. (Most values are overly optimistic if you ignore the worst half.) The average only tells you, at a glance, if the query typically executes in a matter of microseconds, milliseconds, or seconds. Don’t read more into it than that.</p>&#13;
</dd>&#13;
<dt>Percentile</dt>&#13;
<dd>&#13;
<p>Percentiles <a data-primary="percentiles" data-type="indexterm" id="percentiles"/>solve the problem of averages. Without going into a full explanation of percentiles, P95 is the value that 95% of samples are less than or equal to.<sup><a data-type="noteref" href="ch01.html#idm45829115011648" id="idm45829115011648-marker">3</a></sup> For example, if P95 equals 100 ms, then 95% of values are less than or equal to 100 ms, and 5% of values are greater than 100 ms. Consequently, P95 represents 95% of values, which is objectively more representative—and less optimistic—than the average. There’s another reason percentiles are used: the small percentage of values ignored are considered outliers. For example, network jitter and flukes can cause a small percentage of query executions to take longer than normal. Since that’s no fault of MySQL, we ignore those execution times as outliers.</p>&#13;
&#13;
<p>Percentiles are standard practice, but they’re also an assumption. Yes, there can be outliers, but they should be <em>proven</em>, not assumed. Until the top N% are proven <em>not</em> to be outliers, they are the most interesting values precisely because they’re not normal. <em>What’s causing them?</em> That’s difficult to answer, which is why percentiles are standard practice: it’s easier to ignore the top N% of values than to dig deep and find the answer.</p>&#13;
&#13;
<p>The best percentile is P999 (99.9%) because discarding 0.1% of values is an acceptable tradeoff between assuming that they’re outliers and the reality that outliers do exist.<sup><a data-type="noteref" href="ch01.html#idm45829115006912" id="idm45829115006912-marker">4</a></sup><a data-primary="percentiles" data-startref="percentiles" data-type="indexterm" id="idm45829115006192"/></p>&#13;
</dd>&#13;
<dt>Maximum</dt>&#13;
<dd>&#13;
<p>Maximum <a data-primary="maximum (statistic)" data-type="indexterm" id="idm45829115003968"/>query time solves the problem of percentiles: don’t discard any values. The maximum value is not a myth or statistical apparition like the average. Somewhere in the world, some application user experienced the maximum query response time—​or gave up after a few seconds and left. You should want to know why, and you can find the answer. Whereas explaining the top N% of values is difficult because there are many values and, thus, many potentially different answers, explaining the maximum is a single value and answer. Query metric tools often use the query with the maximum response time as the sample, which makes explaining it almost trivial because you have the proverbial smoking gun. With that sample, one of two things will happen: either it reproduces the problem, in which case you continue with the analysis; or, it does not reproduce the problem, in which case you have proven that it’s an outlier that can be ignored.</p>&#13;
&#13;
<p>Here’s another true story of the former case. An otherwise good application would randomly respond very slowly. Minimum, average, and P99 query time were all milliseconds, but maximum query time was seconds. Instead of ignoring the maximum, I collected query samples of normal and maximum execution time. The difference was the size of the <code>IN</code> list in the <code>WHERE</code> clause: hundreds of values for normal query time, and several thousand values for maximum query time. Fetching more values takes longer to execute, but milliseconds to seconds is not normal even for thousands of values. <code>EXPLAIN</code> provided the answer: normal query time used an index, but maximum query time caused a full table scan. MySQL can switch query execution plans (see <a data-type="xref" href="ch02.html#its-a-trap">“It’s a Trap! (When MySQL Chooses Another Index)”</a>), which explains MySQL, but what explains the application? Long story short, the query was used to look up data for fraud detection, and occasionally a big case would look up several thousand rows at once, which caused MySQL to switch query execution plans. Normally, the query was perfectly fine, but digging into the maximum response time revealed not only a MySQL gotcha but also an opportunity to improve the application and user experience by handling large lookups more efficiently.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Average, percentile, and maximum are useful, just be aware of what they do and do not represent.</p>&#13;
&#13;
<p>Also consider the distribution of values between the minimum and maximum.&#13;
If you’re lucky, the query report includes histograms, but don’t count on it: calculating histograms for an arbitrary time range is difficult, so almost no query metric tool does it.&#13;
The basic statistics (minimum, maximum, average, and percentile) indicate enough of the distribution to determine if the query is <em>stable</em>: metrics are roughly the same for every execution.&#13;
(In <a data-type="xref" href="ch06.html#ch06">Chapter 6</a>, I return to the idea of stability. See <a data-type="xref" href="ch06.html#normal-and-stable">“Normal and Stable: The Best Database <span class="keep-together">Is a Boring Database</span>”</a>.)&#13;
Unstable queries complicate the analysis: what causes the query to execute differently?&#13;
The cause is likely outside MySQL, which makes it more difficult to find, but it’s necessary to find because stable queries are easier to analyze, understand, and optimize.<a data-primary="query response time" data-secondary="query analysis" data-startref="query-analysis" data-type="indexterm" id="idm45829114994464"/><a data-primary="query analysis" data-startref="query-analysis" data-type="indexterm" id="idm45829114993248"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Improving Query Response Time" data-type="sect1"><div class="sect1" id="query-optimization">&#13;
<h1>Improving Query Response Time</h1>&#13;
&#13;
<p>Improving query response time is a journey called <em>query optimization</em>. <a data-primary="query response time" data-type="indexterm" id="query-response-time"/>I call it a journey to set the proper expectations. Query optimization takes time and effort, and there is a destination: faster query response time. To make the journey efficient—not a waste of time and effort—there are two parts: direct query optimization and indirect query optimization.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Direct Query Optimization" data-type="sect2"><div class="sect2" id="direct-query-optimization">&#13;
<h2>Direct Query Optimization</h2>&#13;
&#13;
<p><em>Direct query optimization</em> <a data-primary="direct query optimization" data-type="indexterm" id="direct-query-optimization1"/>is changes to queries and indexes. These changes solve <em>a lot</em> of performance problems, which is why the journey begins with direct query optimization. And because these changes are so powerful, the journey often ends here, too.</p>&#13;
&#13;
<p>Let me use an analogy that’s a little simplistic now but will be more insightful later.&#13;
Think of a query as a car.&#13;
Mechanics have tools to fix a car when it’s not running well.&#13;
Some tools are common (like a wrench), and others are specialized (like a dual overhead cam lock).&#13;
Once a mechanic pops the hood and finds the problem, they know which tools are needed to fix it.&#13;
Likewise, engineers have tools to fix a query when it’s running slowly.&#13;
The common tools are query analysis, <a href="https://oreil.ly/oB3q9"><code>EXPLAIN</code></a>, and indexes.&#13;
The specialized tools are query-specific optimizations.&#13;
To name only a few from <a href="https://oreil.ly/dqEWw">“Optimizing SELECT Statements”</a> in the MySQL manual:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Range Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p>Index Merge Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p>Hash Join Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p>Index Condition Pushdown Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p>Multi-Range Read Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p>Constant-Folding Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p><code>IS NULL</code> Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p><code>ORDER BY</code> Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p><code>GROUP BY</code> Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p><code>DISTINCT</code> Optimization</p>&#13;
</li>&#13;
<li>&#13;
<p><code>LIMIT</code> Query Optimization</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In this book, I do not explain query-specific optimizations because <a href="https://oreil.ly/03htc">Chapter 8, “Optimization”</a> in the MySQL manual already explains them in detail, and it’s authoritative and regularly updated.&#13;
Plus, query-specific optimizations vary by MySQL version and distribution.&#13;
Instead, I teach indexes and indexing in <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>: the foundation for knowing which query-specific optimizations to use—and how—when fixing a slow query.&#13;
After <a data-type="xref" href="ch02.html#ch02">Chapter 2</a>, you will wield specialized tools like the <a href="https://oreil.ly/5CEbX">“Index Condition Pushdown Optimization”</a> like a master mechanic wields a dual overhead cam lock.</p>&#13;
&#13;
<p>Every so often I talk with an engineer who is surprised and a little unhappy when the query optimizations they so assiduously applied do not solve the problem. Direct query optimization is necessary but not always sufficient. An optimized query can be or become a problem under different circumstances. When you can’t optimize a query any further (or you can’t optimize it at all because you don’t have access to the source code), you can optimize <em>around</em> the query, which leads to part two of the journey: indirect query optimization.<a data-primary="direct query optimization" data-startref="direct-query-optimization" data-type="indexterm" id="idm45829114965120"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Indirect Query Optimization" data-type="sect2"><div class="sect2" id="indirect-query-optimization">&#13;
<h2>Indirect Query Optimization</h2>&#13;
&#13;
<p><em>Indirect query optimization</em> <a data-primary="indirect query optimization" data-type="indexterm" id="indirect-query-optimization1"/>is changes to data and access patterns. Instead of changing a query, you change what the query accesses and how: its data and access patterns, respectively. These changes indirectly optimize the query because query, data, and access patterns are inextricable with respect to performance. Changes to one influence the others. It’s easy to prove.</p>&#13;
&#13;
<p>Suppose you have a slow query. Data size and access patterns don’t matter for this proof, so imagine whatever you like. I can reduce query response time to near-zero. (Let’s say near-zero is 1 microsecond. For a computer that’s a long time, but for a human it’s imperceptible.) The indirect “optimization” is: <code>TRUNCATE TABLE</code>. With no data, MySQL can execute any query in near-zero time. That’s cheating, but it nonetheless proves the point: reducing data size improves query response time.</p>&#13;
&#13;
<p>Let’s revisit the car analogy. Indirect query optimization is analogous to changing major design elements of the car. For example, weight is a factor in fuel efficiency: decreasing weight increases fuel efficiency. (Data is analogous to weight, which is why <code>TRUNCATE TABLE</code> dramatically increases performance—but don’t use this “optimization.”) Reducing weight is not a straightforward (direct) change because engineers can’t magically make parts weigh less. Instead, they have to make significant changes, such as switching from steel to aluminum, which can affect many other design elements. Consequently, these changes require a greater level of effort.</p>&#13;
&#13;
<p>A greater level of effort is why indirect query optimization is part two of the journey. If direct query optimization solves the problem, then stop—be efficient. (And congratulations.) If it doesn’t and you’re certain the query cannot be further optimized, then it’s time to change data and access patterns, which Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04">4</a> cover.<a data-primary="query response time" data-startref="query-response-time" data-type="indexterm" id="idm45829114954208"/><a data-primary="indirect query optimization" data-startref="indirect-query-optimization" data-type="indexterm" id="idm45829114953200"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When to Optimize Queries" data-type="sect1"><div class="sect1" id="when-to-optimize-queries">&#13;
<h1>When to Optimize Queries</h1>&#13;
&#13;
<p>When <a data-primary="query response time" data-secondary="when to optimize queries" data-type="indexterm" id="when-to-optimize-queries_index1"/>you fix a slow query, another one takes its place. There will always be slow queries, but you should not always optimize them because it’s not an efficient use of your time. Instead, recall <a data-type="xref" href="#north-star">“North Star”</a> and ask: is query response time acceptable? If not, then please continue optimizing queries. If yes, then you’re done for now because when the database is fast, nobody looks or asks questions.</p>&#13;
&#13;
<p>As a DBA, I would like you to review query metrics (starting with the <a data-type="xref" href="#query-profile">“Query profile”</a>) every week and optimize the slowest queries <em>if needed</em>, but as a software engineer I know that’s not practical and almost never happens. Instead, here are three occasions when you should optimize queries.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performance Affects Customers" data-type="sect2"><div class="sect2" id="idm45829114945760">&#13;
<h2>Performance Affects Customers</h2>&#13;
&#13;
<p>When performance affects customers, it is the duty of engineers to optimize queries.&#13;
I don’t think any engineer would disagree; rather, engineers are eager to improve performance.&#13;
Some might say this is bad advice because it’s reactive, not proactive, but my overwhelming experience is that engineers (and even DBAs) don’t look at query metrics until customers report that the application is too slow or timing out.&#13;
As long as query metrics are always on and at the ready, this is an objectively good time to optimize queries because the need for better performance is as real as your <span class="keep-together">customers</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Before and After Code Changes" data-type="sect2"><div class="sect2" id="idm45829114942912">&#13;
<h2>Before and After Code Changes</h2>&#13;
&#13;
<p>Most engineers don’t argue against prioritizing query optimization before and after code changes, but my experience is that they don’t do it, either. I implore you to avoid this common pattern: seemingly innocent changes are made to code, vetted in staging, deployed to production, then performance starts to “swirl the bowl” (a colorful metaphor related to toilets that means “become worse”). What happened? The cause is usually changes to queries and access patterns, which are closely related. <a data-type="xref" href="ch02.html#ch02">Chapter 2</a> begins to explain why; Chapters <a href="ch03.html#ch03">3</a> and <a href="ch04.html#ch04">4</a> complete the explanation. For now, the point is: you will be a hero if you review query metrics before and after code changes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Once a Month" data-type="sect2"><div class="sect2" id="idm45829114938352">&#13;
<h2>Once a Month</h2>&#13;
&#13;
<p>Even if your code and queries do not change, at least two things around them are changing: data and access patterns. I hope your application is wildly successful and stores ever more data as the number of users climbs “up and to the right.” Query response time changes over time as data and access patterns change. Fortunately, these changes are relatively slow, usually on the order of weeks or months. Even for an application experiencing hyper-growth (for example, adding thousands of new users every day to millions of existing users), MySQL is really good at scaling up so that query response time remains stable—but nothing lasts forever (even the stars die). There is always a point at which good queries go bad. This reality becomes clear after Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#ch03">3</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#ch04">4</a>. For now, the point is: you will rise from hero to legend—possibly with song and story written about you—if you review query metrics once <span class="keep-together">a month</span>.<a data-primary="query response time" data-secondary="when to optimize queries" data-startref="when-to-optimize-queries_index1" data-type="indexterm" id="idm45829114932896"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="MySQL: Go Faster" data-type="sect1"><div class="sect1" id="mysql-go-faster">&#13;
<h1>MySQL: Go Faster</h1>&#13;
&#13;
<p>There <a data-primary="query response time" data-secondary="increasing speed" data-type="indexterm" id="increasing-speed"/>is no magic or secret to make MySQL significantly faster without changing queries or the application.&#13;
Here’s another true story to illustrate what I mean.</p>&#13;
&#13;
<p>A team of developers learned that their application was going to be mentioned by a celebrity.&#13;
They expected a flood of traffic, so they planned ahead to ensure that MySQL and the application would survive.&#13;
An engineer on the team asked me to help increase MySQL throughput (QPS).&#13;
I asked, “By how much?”&#13;
She said, “By 100x”.&#13;
I said, “Sure. Do you have a year and a willingness to rearchitect the application?”&#13;
She said, “No, we have one day.”</p>&#13;
&#13;
<p>I understand what the engineer was thinking: how much throughput could MySQL handle if we <em>significantly</em> upgraded the hardware—more CPU cores, more memory, more IOPS?&#13;
There’s no simple or single answer because it depends on many factors that this book explores in the coming chapters.&#13;
But one thing is certain: <em>time is a hard limit</em>.</p>&#13;
&#13;
<p class="pagebreak-before less_space">There are 1,000 milliseconds in 1 second—no more, no less.&#13;
If a query takes 100 milliseconds to execute, then its worst-case throughput is 10 QPS per CPU core: 1,000 ms / 100 ms/query = 10 QPS.&#13;
(Its real throughput is likely higher—more on this in a moment.)&#13;
If nothing changes, then there’s simply no more time to execute the query with greater throughput.</p>&#13;
&#13;
<p>To make MySQL do more work in the same amount of time, you have three options:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Change the nature of time</p>&#13;
</li>&#13;
<li>&#13;
<p>Decrease response time</p>&#13;
</li>&#13;
<li>&#13;
<p>Increase load</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Option one is beyond the scope of this book, so let’s focus on options two and three.</p>&#13;
&#13;
<p>Decreasing response time frees time that MySQL can use to do more work.&#13;
It’s simple math: if MySQL is busy 999 milliseconds out of every second, then it has one free millisecond to do more work.&#13;
If that’s not enough free time, then you must decrease the time that the current work is consuming.&#13;
The best way to accomplish that: direct query optimization.&#13;
Failing that: indirect query optimization.&#13;
And finally: better, faster hardware.&#13;
The following chapters teach you how.</p>&#13;
&#13;
<p>Increasing load—the number of queries executing concurrently—tends to happen first because it doesn’t require any query or application changes: simply execute more queries at once (concurrently), and MySQL responds by using more CPU cores.&#13;
This happens because one CPU core executes one thread, which executes one query.&#13;
Worst case, MySQL uses N CPU cores to execute N queries concurrently.&#13;
But the worst case is practically nonexistent because response time is not CPU time.&#13;
A nonzero amount of response time is CPU time, and the rest is <a href="https://oreil.ly/drw2d">off-CPU</a>.&#13;
For example, response time might be 10 ms of CPU time and 90 ms of disk I/O wait.&#13;
Therefore, the worst-case throughput for a query that takes 100 milliseconds to execute is 10 QPS per CPU core, but its real throughput should be higher since the worst case is practically nonexistent.&#13;
Sounds great, right?&#13;
Just push MySQL harder and voilà: more performance.&#13;
But you know how the story ends: push MySQL too hard and it stops working because every system has finite capacity.&#13;
MySQL can easily push most modern hardware to its limits, but don’t try it until you’ve read <a data-type="xref" href="ch04.html#perf-at-the-limit">“Performance Destabilizes at the Limit”</a>.</p>&#13;
&#13;
<p>Bottom line: MySQL cannot simply <em>go faster</em>.&#13;
To make MySQL go faster, you must embark on the journey of direct and indirect query optimization.<a data-primary="query response time" data-secondary="increasing speed" data-startref="increasing-speed" data-type="indexterm" id="idm45829114915184"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="ch01-summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter <a data-primary="query response time" data-type="indexterm" id="idm45829114911856"/>expounded query time so that, in subsequent chapters, you can learn how to improve it.&#13;
The central takeaway points are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Performance is <em>query response time</em>: how long it takes MySQL to execute a query.</p>&#13;
</li>&#13;
<li>&#13;
<p>Query response time is the North Star of MySQL performance because it is <em>meaningful</em> and <em>actionable</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Query metrics originate from the slow query log or the Performance Schema.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Performance Schema is the best source of query metrics.</p>&#13;
</li>&#13;
<li>&#13;
<p>Query metrics are grouped and aggregated by <em>digest</em>: normalized SQL statements.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <em>query profile</em> shows slow queries; <em>slow</em> is relative to the sort metric.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <em>query report</em> shows all available information for one query; it’s used for query analysis.</p>&#13;
</li>&#13;
<li>&#13;
<p>The goal of <em>query analysis</em> is understanding query execution, not solving slow response time.</p>&#13;
</li>&#13;
<li>&#13;
<p>Query analysis uses query metrics (as reported), metadata (EXPLAIN plans, table structures, and so on), and knowledge of the application.</p>&#13;
</li>&#13;
<li>&#13;
<p>Nine query metrics are essential to every query analysis: query time, lock time, rows examined, rows sent, row affected, select scan, select full join, created tmp disk tables, and query count.</p>&#13;
</li>&#13;
<li>&#13;
<p>Improving query response time (query optimization) is a two-part journey: direct query optimization, then indirect query optimization.</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><em>Direct query optimization</em> is changes to queries and indexes.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Indirect query optimization</em> is changes to data and access patterns.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>At the very least, review the query profile and optimize slow queries when performance affects customers, before and after code changes, and once a month.</p>&#13;
</li>&#13;
<li>&#13;
<p>To make MySQL go faster, you must decrease response time (free time to do more work) or increase load (push MySQL to work harder).</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The next chapter teaches MySQL indexes and indexing—direct query optimization.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Practice: Identify Slow Queries" data-type="sect1"><div class="sect1" id="ch01-ai">&#13;
<h1>Practice: Identify Slow Queries</h1>&#13;
&#13;
<p>The <a data-primary="query response time" data-secondary="identifying slow queries" data-type="indexterm" id="identifying-slow-queries"/>goal of this practice is to identify slow queries using <a href="https://oreil.ly/KU0hj">pt-query-digest</a>: a command-line tool that generates a query profile and query reports from a slow query log.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Use a development or staging MySQL instance—do not use production unless you are confident that it will not cause problems.&#13;
The slow query log is inherently safe, but enabling it on a busy server can increase disk I/O.</p>&#13;
</div>&#13;
&#13;
<p>If you have DBAs who manage MySQL, ask them to enable and configure the slow query log.&#13;
Or, you can learn how by reading <a href="https://oreil.ly/Hz0Sz">“The Slow Query Log”</a> in the MySQL manual.&#13;
(You need a MySQL user account with <code>SUPER</code> privileges to configure MySQL.)&#13;
If you’re using MySQL in the cloud, read the cloud provider documentation to learn how to enable and access the slow query log.</p>&#13;
&#13;
<p>MySQL configurations vary, but the simplest way to configure and enable the slow query log is:</p>&#13;
&#13;
<pre data-type="programlisting">SET GLOBAL long_query_time=0;&#13;
&#13;
SET GLOBAL slow_query_log=ON;&#13;
&#13;
SELECT @@GLOBAL.slow_query_log_file;&#13;
+-------------------------------+&#13;
| @@GLOBAL.slow_query_log_file  |&#13;
+-------------------------------+&#13;
| /usr/local/var/mysql/slow.log |&#13;
+-------------------------------+</pre>&#13;
&#13;
<p>Zero in the first statement, <code>SET GLOBAL long_query_time=0;</code>, causes MySQL to log <em>every query</em>.&#13;
Be careful: on a busy server, this can increase disk I/O and use gigabytes of disk space.&#13;
If needed, use a slightly larger value like <code>0.0001</code> (100 microseconds) or <code>0.001</code> (1 millisecond).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Percona Server <a data-primary="Percona Server" data-secondary="slow queries" data-type="indexterm" id="Percona-Server-slow-queries-ch1"/>and MariaDB Server support slow query log sampling: set system variable <code>log_slow_rate_limit</code> to log every Nth query.&#13;
For example, <code>log_slow_rate_limit = 100</code> logs every 100th query, which equals 1% of all queries.&#13;
Over time, this creates a representative sample when combined with <code>long_query_time = 0</code>.&#13;
When using this feature, be sure that the query metric tool accounts for sampling, else it will under report values.&#13;
<code>pt-query-digest</code> accounts for sampling.</p>&#13;
</div>&#13;
&#13;
<p>The last statement, <code>SELECT @@GLOBAL.slow_query_log_file;</code>, outputs the slow query log filename that you need as the first command line argument to <code>pt-query-digest</code>.&#13;
You can dynamically change this variable if you want to log to a different file.</p>&#13;
&#13;
<p>Second, run <code>pt-query-digest</code> with the slow query log filename as the first command line argument.&#13;
The tool will print a lot of output; but for now, look at the <code>Profile</code> near the top of the output:</p>&#13;
&#13;
<pre data-type="programlisting"># Profile&#13;
# Rank Query ID                            Response time   Calls&#13;
# ==== =================================== =============== =====&#13;
#    1 0x95FD3A847023D37C95AADD230F4EB56A  1000.0000 53.8%   452  SELECT tbl&#13;
#    2 0xBB15BFCE4C9727175081E1858C60FD0B   500.0000 26.9%    10  SELECT foo bar&#13;
#    3 0x66112E536C54CE7170E215C4BFED008C    50.0000  2.7%     5  INSERT tbl&#13;
# MISC 0xMISC                               310.0000 16.7%   220  &lt;2 ITEMS&gt;</pre>&#13;
&#13;
<p>The preceding output is a text-based table listing the slowest queries from the slow query log.&#13;
In this example, <code>SELECT tbl</code> (a query abstract) is the slowest query, accounting for 53.8% of total execution time.&#13;
(By default, <code>pt-query-digest</code> sorts queries by percentage execution time.)&#13;
Below the query profile, a query report is printed for each query.</p>&#13;
&#13;
<p>Explore the <code>pt-query-digest</code> output.&#13;
Its manual documents the output, and there is a trove of information on the internet because the tool is widely used.&#13;
Also check out <a href="https://oreil.ly/rZSx2">Percona Monitoring and Management</a>: a comprehensive database monitoring solution that uses <a href="https://grafana.com">Grafana</a>  to report query metrics.&#13;
Both tools are free, open source, and supported by <a href="https://percona.com">Percona</a>.<a data-primary="Percona Server" data-secondary="slow queries" data-startref="Percona-Server-slow-queries-ch1" data-type="indexterm" id="idm45829114865344"/></p>&#13;
&#13;
<p>By reviewing slow queries, you know exactly which queries to optimize for the most efficient performance gains.&#13;
More importantly, you’ve begun to practice MySQL performance like an expert: with a focus on queries, because performance is query response time.<a data-primary="query response time" data-secondary="identifying slow queries" data-startref="identifying-slow-queries" data-type="indexterm" id="idm45829114863344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45829115580240"><sup><a href="ch01.html#idm45829115580240-marker">1</a></sup> Latency is delay inherent in the system. Query response time is not a delay inherent in MySQL; it comprises various latencies: network, storage, and so on.</p><p data-type="footnote" id="idm45829113296432"><sup><a href="ch01.html#idm45829113296432-marker">2</a></sup> Unless <code>STRAIGHT_JOIN</code> is used—but don’t use this. Let the MySQL query optimizer choose the join order for the best query execution plan. It’s almost always right, so trust it unless you can prove it wrong.</p><p data-type="footnote" id="idm45829115011648"><sup><a href="ch01.html#idm45829115011648-marker">3</a></sup> For a full explanation of percentiles, see <a href="https://hackmysql.com/p95">HackMySQL</a>.</p><p data-type="footnote" id="idm45829115006912"><sup><a href="ch01.html#idm45829115006912-marker">4</a></sup> P95, P99, and P999 are conventional. I’ve never seen other percentiles used with MySQL—median (P50) and maximum (P100) notwithstanding.</p></div></div></section></body></html>