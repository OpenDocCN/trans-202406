- en: Chapter 3\. Unions and Literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing is constant
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Values may change over time
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (well, except constants)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Chapter 2, “The Type System”](ch02.xhtml#the_type_system) covered the concept
    of the “type system” and how it can read values to understand the types of variables.
    Now I’d like to introduce two key concepts that TypeScript works with to make
    inferences on top of those values:'
  prefs: []
  type: TYPE_NORMAL
- en: Unions
  prefs: []
  type: TYPE_NORMAL
- en: Expanding a value’s allowed type to be two or more possible types
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing
  prefs: []
  type: TYPE_NORMAL
- en: Reducing a value’s allowed type to *not* be one or more possible types
  prefs: []
  type: TYPE_NORMAL
- en: Put together, unions and narrowing are powerful concepts that allow TypeScript
    to make informed inferences on your code many other mainstream languages cannot.
  prefs: []
  type: TYPE_NORMAL
- en: Union Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take this `mathematician` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What type is `mathematician`?
  prefs: []
  type: TYPE_NORMAL
- en: It’s neither only `undefined` nor only `string`, even though those are both
    potential types. `mathematician` can be *either* `undefined` or `string`. This
    kind of “either or” type is called a *union*. Union types are a wonderful concept
    that let us handle code cases where we don’t know exactly which type a value is,
    but do know it’s one of two or more options.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript represents union types using the `|` (pipe) operator between the
    possible values, or *constituents*. The previous `mathematician` type is thought
    of as `string | undefined`. Hovering over the mathematician variable would show
    its type as `string | undefined` ([Figure 3-1](#hovering_union_type)).
  prefs: []
  type: TYPE_NORMAL
- en: '![TypeScript reporting the ''mathematician'' variable as being type ''string
    | undefined''.](Images/lets_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. TypeScript reporting the `mathematician` variable as being type
    `string | undefined`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Declaring Union Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Union types are an example of a situation when it might be useful to give an
    explicit type annotation for a variable even though it has an initial value. In
    this example, `thinker` starts off `null` but is known to potentially contain
    a `string` instead. Giving it an explicit `string | null` type annotation means
    TypeScript will allow it to be assigned values of type `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Union type declarations can be placed anywhere you might declare a type with
    a type annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The order of a union type declaration does not matter. You can write `boolean
    | number` or `number | boolean` and TypeScript will treat both the exact same.
  prefs: []
  type: TYPE_NORMAL
- en: Union Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a value is known to be a union type, TypeScript will only allow you to
    access member properties that exist on all possible types in the union. It will
    give you a type-checking error if you try to access a type that doesn’t exist
    on all possible types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, `physicist` is of type `number | string`. While `.toString()`
    exists in both types and is allowed to be used, `.toUpperCase()` and `.toFixed()`
    are not because `.toUpperCase()` is missing on the `number` type and `.toFixed()`
    is missing on the `string` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Restricting access to properties that don’t exist on all union types is a safety
    measure. If an object is not known to definitely be a type that contains a property,
    TypeScript will believe it unsafe to try to use that property. The property might
    not exist!
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a property of a union typed value that only exists on a subset of the
    potential types, your code will need to indicate to TypeScript that the value
    at that location in code is one of those more specific types: a process called
    *narrowing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Narrowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Narrowing is when TypeScript infers from your code that a value is of a more
    specific type than what it was defined, declared, or previously inferred as. Once
    TypeScript knows that a value’s type is more narrow than previously known, it
    will allow you to treat the value like that more specific type. A logical check
    that can be used to narrow types is called a *type guard*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s cover two of the common type guards TypeScript can use to deduce type
    narrowing from your code.
  prefs: []
  type: TYPE_NORMAL
- en: Assignment Narrowing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you directly assign a value to a variable, TypeScript will narrow the variable’s
    type to that value’s type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `admiral` variable is declared initially as a `number | string`,
    but after being assigned the value `"Grace Hopper"`, TypeScript knows it must
    be a `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Assignment narrowing comes into play when a variable is given an explicit union
    type annotation and an initial value too. TypeScript will understand that while
    the variable may later receive a value of any of the union typed values, it starts
    off as only the type of its initial value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, `inventor` is declared as type `number | string`,
    but TypeScript knows it’s immediately narrowed to a `string` from its initial
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Conditional Checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common way to get TypeScript to narrow a variable’s value is to write an
    `if` statement checking the variable for being equal to a known value. TypeScript
    is smart enough to understand that inside the body of that `if` statement, the
    variable must be the same type as the known value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Narrowing with conditional logic shows TypeScript’s type-checking logic mirroring
    good JavaScript coding patterns. If a variable might be one of several types,
    you’ll generally want to check its type for being what you need. TypeScript is
    forcing us to play it safe with our code. Thanks, TypeScript!
  prefs: []
  type: TYPE_NORMAL
- en: Typeof Checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to direct value checking, TypeScript also recognizes the `typeof`
    operator in narrowing down variable types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the `scientist` example, checking if `typeof researcher` is `"string"`
    indicates to TypeScript that the type of `researcher` must be `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Logical negations from `!` and `else` statements work as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Those code snippets can be rewritten with a ternary statement, which is also
    supported for type narrowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Whichever way you write them, `typeof` checks are a practical and often used
    way to narrow types.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s type checker recognizes several more forms of narrowing that we’ll
    see in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Literal Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that I’ve shown union types and narrowing for working with values that
    may be two or more potential types, I’d like go the opposite direction by introducing
    *literal types*: more specific versions of primitive types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this `philosopher` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What type is `philosopher`?
  prefs: []
  type: TYPE_NORMAL
- en: At first glance, you might say `string`—and you’d be correct. `philosopher`
    is indeed a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: But! `philosopher` is not just any old `string`. It’s specifically the value
    `"Hypatia"`. Therefore, the `philosopher` variable’s type is technically the more
    specific `"Hypatia"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such is the concept of a *literal type*: the type of a value that is known
    to be a specific value of a primitive, rather than any of those primitive’s values
    at all. The primitive type `string` represents the set of all possible strings
    that could ever exist; the literal type `"Hypatia"` represents just that one string.'
  prefs: []
  type: TYPE_NORMAL
- en: If you declare a variable as `const` and directly give it a literal value, TypeScript
    will infer the variable to be that literal value as a type. This is why, when
    you hover a mouse over a `const` variable with an initial literal value in an
    IDE such as VS Code, it will show you the variable’s type as that literal ([Figure 3-2](#hovering_const_string_literal))
    instead of the more general primitive ([Figure 3-3](#hovering_let_string_literal)).
  prefs: []
  type: TYPE_NORMAL
- en: '![TypeScript reporting a ''const'' variable as being its string literal type.](Images/lets_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. TypeScript reporting a `const` variable as being specifically its
    literal type
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![TypeScript reporting a ''let'' variable as being type ''string''.](Images/lets_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. TypeScript reporting a `let` variable as being generally its primitive
    type
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can think of each *primitive* type as a *union* of every possible matching
    *literal* value. In other words, a primitive type is the set of all possible literal
    values of that type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than the `boolean`, `null`, and `undefined` types, all other primitives
    such as `number` and `string` have a infinite number of literal types. The common
    types you’ll find in typical TypeScript code are just those:'
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean`: just `true | false`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`null` and `undefined`: both just have one literal value, themselves'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`number`: `0 | 1 | 2 | ... | 0.1 | 0.2 | ...`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`: `"" | "a" | "b" | "c" | ... | "aa" | "ab" | "ac" | ...`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Union type annotations can mix and match between literals and primitives. A
    representation of a lifespan, for example, might be represented by any `number`
    *or* one of a couple known edge cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Literal Assignability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve seen how different primitive types such as `number` and `string` are
    not assignable to each other. Similarly, different literal types within the same
    primitive type—e.g., `0` and `1`—are not assignable to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `specificallyAda` is declared as being of the literal type
    `"Ada"`, so while the value `"Ada"` may be given to it, the types `"Byron"` and
    `string` are not assignable to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Literal types are, however, allowed to be assigned to their corresponding primitive
    types. Any specific literal string is still a `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this code example, the value `":)"`, which is of type `":)"`, is being assigned
    to the `someString` variable previously inferred to be of type `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Who would have thought a simple variable assignment would be so theoretically
    intense?
  prefs: []
  type: TYPE_NORMAL
- en: Strict Null Checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The power of narrowed unions with literals is particularly visible when working
    with potentially undefined values, an area of type systems TypeScript refers to
    as *strict null checking*. TypeScript is part of a surge of modern programming
    languages that utilize strict null checking to fix the dreaded “billion-dollar
    mistake.”
  prefs: []
  type: TYPE_NORMAL
- en: The Billion-Dollar Mistake
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I call it my billion-dollar mistake. It was the invention of the null reference
    in 1965… This has led to innumerable errors, vulnerabilities, and system crashes,
    which have probably caused a billion dollars of pain and damage in the last 40
    years.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Tony Hoare, 2009
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The “billion-dollar mistake” is a catchy industry term for many type systems
    allowing null values to be used in places that require a different type. In languages
    without strict null checking, code like this example that assign `null` to a `string`
    is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve previously worked in a typed language such as C++ or Java that suffers
    from the billion-dollar mistake, it may be surprising to you that some languages
    don’t allow such a thing. If you’ve never worked in a language with the strict
    null checking before, it may be surprising that some languages allowed the billion-dollar
    mistake in the first place!
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler contains a multitude of options that allow changing
    how it runs. [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options)
    will cover TypeScript compiler options in depth. One of the most useful opt-in
    options, `strictNullChecks`, toggles whether strict null checking is enabled.
    Roughly speaking, disabling `strictNullChecks` adds `| null | undefined` to every
    type in your code, thereby allowing any variable to receive `null` or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `strictNullChecks` option set to `false`, the following code is considered
    totally type safe. That’s wrong, though; `nameMaybe` might be `undefined` when
    `.toLowerCase` is accessed from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With strict null checking enabled, TypeScript sees the potential crash in the
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Without strict null checking enabled, it’s much harder to know whether your
    code is safe from errors due to accidentally `null` or `undefined` values.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript best practice is generally to enable strict null checking. Doing
    so helps prevent crashes and eliminates the billion-dollar mistake.
  prefs: []
  type: TYPE_NORMAL
- en: Truthiness Narrowing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall from JavaScript that *truthiness*, or being *truthy*, is whether a value
    would be considered `true` when evaluated in a `Boolean` context, such as an `&&`
    operator or `if` statement. All values in JavaScript are truthy except for those
    defined as *falsy*: `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`, and `NaN`.^([1](ch03.xhtml#idm45584691848224))'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript can also narrow a variable’s type from a truthiness check if only
    some of its potential values may be truthy. In the following snippet, `geneticist`
    is of type `string | undefined`, and because `undefined` is always falsy, TypeScript
    can deduce that it must be of type `string` within the `if` statement’s body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Logical operators that perform truthiness checking work as well, namely `&&`
    and `?.`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, truthiness checking doesn’t go the other way. If all we know
    about a `string | undefined` value is that it’s falsy, that doesn’t tell us whether
    it’s an empty string or `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `biologist` is of type `false | string`, and while it can be narrowed
    down to just `string` in the `if` statement body, the `else` statement body knows
    it can still be a string if it’s `""`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Variables Without Initial Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables declared without an initial value default to `undefined` in JavaScript.
    That presents an edge case in the type system: what if you declare a variable
    to be a type that doesn’t include `undefined`, then try to use it before assigning
    a value?'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript is smart enough to understand that the variable is `undefined` until
    a value is assigned. It will report a specialized error message if you try to
    use that variable, such as by accessing one of its properties, before assigning
    a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that this reporting doesn’t apply if the variable’s type includes `undefined`.
    Adding `| undefined` to a variable’s type indicates to TypeScript that it doesn’t
    need to be defined before use, as `undefined` is a valid type for its value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet wouldn’t emit any errors if the type of `mathematician`
    is `string | undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Type Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most union types you’ll see in code will generally only have two or three constituents.
    However, you may sometimes find a use for longer union types that are inconvenient
    to type out repeatedly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of these variables can be one of four possible types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript includes *type aliases* for assigning easier names to reused types.
    A type alias starts with the `type` keyword, a new name, `=`, and then any type.
    By convention, type aliases are given names in PascalCase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Type aliases act as a copy-and-paste in the type system. When TypeScript sees
    a type alias, it acts as if you’d typed out the actual type the alias was referring
    to. The previous variables’ type annotations could be rewritten to use a type
    alias for the long union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That’s a lot easier to read!
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases are a handy feature to use in TypeScript whenever your types start
    getting complex. For now, that just includes long union types; later on it will
    include array, function, and object types.
  prefs: []
  type: TYPE_NORMAL
- en: Type Aliases Are Not JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type aliases, like type annotations, are not compiled to the output JavaScript.
    They exist purely in the TypeScript type system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet would compile to roughly this JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because type aliases are purely in the type system, you cannot reference them
    in runtime code. TypeScript will let you know with a type error if you are trying
    to access something that won’t exist at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Type aliases exist purely as a development-time construct.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Type Aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type aliases may reference other type aliases. It can sometimes be useful to
    have type aliases refer to each other, such as when one type alias is a union
    of types that includes (is a superset of) the union types within another type
    alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `IdMaybe` type is a union of the types within `Id` as well as `undefined`
    and `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Type aliases don’t have to be declared in order of usage. You can have a type
    alias declared earlier in a file reference an alias declared later in the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet could be rewritten to have `IdMaybe` come before
    `Id`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you went over union and literal types in TypeScript, along
    with how its type system can deduce more specific (narrower) types from how our
    code is structured:'
  prefs: []
  type: TYPE_NORMAL
- en: How union types represent values that could be one of two or more types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicitly indicating union types with type annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How type narrowing reduces the possible types of a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between `const` variables with literal types and `let` variables
    with primitive types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “billion-dollar mistake” and how TypeScript handles strict null checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using explicit `| undefined` to represent values that might not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit `| undefined` for unassigned variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using type aliases to save typing long type unions repeatedly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/unions-and-literals*](https://learningtypescript.com/unions-and-literals).
  prefs: []
  type: TYPE_NORMAL
- en: Why are `const` variables so serious?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: They take themselves too literally.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ^([1](ch03.xhtml#idm45584691848224-marker)) The deprecated `document.all` object
    in browsers is also defined as falsy in an old quirk of legacy browser compatibility.
    For the purposes of this book—and your own happiness as a developer—don’t worry
    about `document.all`.
  prefs: []
  type: TYPE_NORMAL
