- en: Chapter 2\. The Linux Kernel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Why an Operating System at All?”](ch01.xhtml#intro-os-overiew), we learned
    that the main function of an operating system is to abstract over different hardware
    and provide us with an API. Programming against this API allows us to write applications
    without having to worry about where and how they are executed. In a nutshell,
    the kernel provides such an API to programs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we discuss what the Linux kernel is and how you should be thinking
    about it as a whole as well as about its components. You will learn about the
    overall Linux architecture and the essential role the Linux kernel plays. One
    main takeaway of this chapter is that while the kernel provides all the core functionality,
    on its own it is not the operating system but only a very central part of it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we take a bird’s-eye view, looking at how the kernel fits in and interacts
    with the underlying hardware. Then, we review the computational core, discussing
    different CPU architectures and how they relate to the kernel. Next, we zoom in
    on the individual kernel components and discuss the API the kernel provides to
    programs you can run. Finally, we look at how to customize and extend the Linux
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of this chapter is to equip you with the necessary terminology,
    make you aware of the interfacing between programs and the kernel, and give you
    a basic idea what the functionality is. The chapter does not aim to turn you into
    a kernel developer or even a sysadmin configuring and compiling kernels. If, however,
    you want to dive into that, I’ve put together some pointers at the end of the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s jump into the deep end: the Linux architecture and the central role
    the kernel plays in this context.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At a high level, the Linux architecture looks as depicted in [Figure 2-1](#fig-linux-arch).
    There are three distinct layers you can group things into:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware
  prefs: []
  type: TYPE_NORMAL
- en: From CPUs and main memory to disk drives, network interfaces, and peripheral
    devices such as keyboards and monitors.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel
  prefs: []
  type: TYPE_NORMAL
- en: The focus of the rest of this chapter. Note that there are a number of components
    that sit between the kernel and user land, such as the init system and system
    services (networking, etc.), but that are, strictly speaking, not part of the
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: User land
  prefs: []
  type: TYPE_NORMAL
- en: Where the majority of apps are running, including operating system components
    such as shells (discussed in [Chapter 3](ch03.xhtml#shells-scripting)), utilities
    like `ps` or `ssh`, and graphical user interfaces such as X Window System–based
    desktops.
  prefs: []
  type: TYPE_NORMAL
- en: We focus in this book on the upper two layers of [Figure 2-1](#fig-linux-arch),
    that is, the kernel and user land. We only touch on the hardware layer in this
    and a few other chapters, where relevant.
  prefs: []
  type: TYPE_NORMAL
- en: The interfaces between the different layers are well defined and part of the
    Linux operating system package. Between the kernel and user land is the interface
    called *system calls* (*syscalls* for short). We will explore this in detail in
    [“syscalls”](#kernel-syscalls).
  prefs: []
  type: TYPE_NORMAL
- en: 'The interface between the hardware and the kernel is, unlike the syscalls,
    not a single one. It consists of a collection of individual interfaces, usually
    grouped by hardware:'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU interface (see [“CPU Architectures”](#kernel-cpu-arch))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interface with the main memory, covered in [“Memory Management”](#kernel-memory-management)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Network interfaces and drivers (wired and wireless; see [“Networking”](#kernel-networking))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filesystem and block devices driver interfaces (see [“Filesystems”](#kernel-filesystems))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Character devices, hardware interrupts, and device drivers, for input devices
    like keyboards, terminals, and other I/O (see [“Device Drivers”](#kernel-drivers))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![lmlx 0201](Images/lmlx_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. A high-level view of the Linux architecture
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, many of the things we usually consider part of the Linux operating
    system, such as shell or utilities such as `grep`, `find`, and `ping`, are in
    fact not part of the kernel but, very much like an app you download, part of user
    land.
  prefs: []
  type: TYPE_NORMAL
- en: On the topic of user land, you will often read or hear about user versus kernel
    mode. This effectively refers to how privileged the access to hardware is and
    how restricted the abstractions available are.
  prefs: []
  type: TYPE_NORMAL
- en: In general, *kernel mode* means fast execution with limited abstraction, whereas
    *user mode* means comparatively slower but safer and more convenient abstractions.
    Unless you are a [kernel developer](https://oreil.ly/AhAm6), you can almost always
    ignore kernel mode, since all your apps will run in user land. Knowing how to
    interact with the kernel ([“syscalls”](#kernel-syscalls)), on the other hand,
    is vital and part of our considerations.
  prefs: []
  type: TYPE_NORMAL
- en: With this Linux architecture overview out of the way, let’s work our way up
    from the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: CPU Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we discuss the kernel components, let’s review a basic concept: computer
    architectures or CPU families, which we will use interchangeably. The fact that
    Linux runs on a large number of different CPU architectures is arguably one of
    the reasons it is so popular.'
  prefs: []
  type: TYPE_NORMAL
- en: Next to generic code and drivers, the Linux kernel contains architecture-specific
    code. This separation allows it to port Linux and make it available on new hardware
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to figure out what CPU your Linux is running. Let’s
    have a look at a few in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is a dedicated tool called `dmidecode` that interacts with the BIOS.
    If this doesn’t yield results, you could try the following (output shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_linux_kernel_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The architecture we’re looking at here is `x86_64`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_linux_kernel_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: It looks like there are four CPUs available.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_linux_kernel_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The CPU model name is Intel Core Processor (Haswell).
  prefs: []
  type: TYPE_NORMAL
- en: In the previous command, we saw that the CPU architecture was reported to be
    `x86_64`, and the model was reported as “Intel Core Processor (Haswell).” We will
    learn more about how to decode this in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to glean similar architecture information is by using `cat /proc/cpuinfo`,
    or, if you’re only interested in the architecture, by simply calling `uname -m`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a handle on querying the architecture information on Linux,
    let’s see how to decode it.
  prefs: []
  type: TYPE_NORMAL
- en: x86 Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[x86](https://oreil.ly/PoQOT) is an instruction set family originally developed
    by Intel and later licensed to Advanced Micro Devices (AMD). Within the kernel,
    `x64` refers to the Intel 64-bit processors, and `x86` stands for Intel 32-bit.
    Further, `amd64` refers to AMD 64-bit processors.'
  prefs: []
  type: TYPE_NORMAL
- en: Today, you’ll mostly find the x86 CPU family in desktops and laptops, but it’s
    also widely used in servers. Specifically, `x86` forms the basis of the public
    cloud. It is a powerful and widely available architecture but isn’t very energy
    efficient. Partially due to its heavy reliance on out-of-order execution, it recently
    received a lot of attention around security issues such as [Meltdown](https://oreil.ly/nkEVB).
  prefs: []
  type: TYPE_NORMAL
- en: For further details, for example the Linux/x86 boot protocol or Intel and AMD
    specific background, see the [x86-specific kernel documentation](https://oreil.ly/CBvRQ).
  prefs: []
  type: TYPE_NORMAL
- en: ARM Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: More than 30 years old, [ARM](https://oreil.ly/E9HIN) is a family of Reduced
    Instruction Set Computing (RISC) architectures. RISC usually consists of many
    generic CPU registers along with a small set of instructions that can be executed
    faster.
  prefs: []
  type: TYPE_NORMAL
- en: Because the designers at Acorn—the original company behind ARM—focused from
    the get-go on minimal power consumption, you find ARM-based chips in a number
    of portable devices such as iPhones. They are also in most Android-based phones
    and in embedded systems found in IoT, such as in the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Given that they are fast, cheap, and produce less heat than x86 chips, you shouldn’t
    be surprised to increasingly find ARM-based CPUs—such as [AWS Graviton](https://oreil.ly/JpgdQ)—in
    the data center. While simpler than x86, ARM is not immune to vulnerabilities,
    such as [Spectre](https://oreil.ly/M79Yu). For further details, see the [ARM-specific
    kernel documentation](https://oreil.ly/i7kj4).
  prefs: []
  type: TYPE_NORMAL
- en: RISC-V Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An up-and-coming player, [RISC-V (pronounced *risk five*)](https://oreil.ly/wwnIA)
    is an open RISC standard that was originally developed by the University of California,
    Berkeley. As of 2021, a number of implementations exist, ranging from Alibaba
    Group and Nvidia to start-ups such as SiFive. While exciting, this is a relatively
    new and not widely used (yet) CPU family, and to get an idea how it look and feels,
    you may want to research it a little—a good start is Shae Erisson’s article [“Linux
    on RISC-V”](https://oreil.ly/6senY).
  prefs: []
  type: TYPE_NORMAL
- en: For further details, see the [RISC-V kernel documentation](https://oreil.ly/LA1Oq).
  prefs: []
  type: TYPE_NORMAL
- en: Kernel Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know the basics of CPU architectures, it’s time to dive into the
    kernel. While the Linux kernel is a monolithic one—that is, all the components
    discussed are part of a single binary—there are functional areas in the code base
    that we can identify and ascribe dedicated responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve discussed in [“Linux Architecture”](#kernel-architecture), the kernel
    sits between the hardware and the apps you want to run. The main functional blocks
    you find in the kernel code base are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Process management, such as starting a process based on an executable file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management, such as allocating memory for a process or map a file into
    memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking, like managing network interfaces or providing the network stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystems providing file management and supporting the creation and deletion
    of files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Management of character devices and device drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functional components often come with interdependencies, and it’s a truly
    challenging task to make sure that the [kernel developer motto](https://oreil.ly/6YDeF)
    “Kernel never breaks user land” holds true.
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s have a closer look at the kernel components.
  prefs: []
  type: TYPE_NORMAL
- en: Process Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a number of process management–related parts in the kernel. Some of
    them deal with CPU architecture–specific things, such as interrupts, and others
    focus on the launching and scheduling of programs.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get to Linux specifics, let’s note that commonly, a process is the
    user-facing unit, based on an executable program (or binary). A thread, on the
    other hand, is a unit of execution in the context of a process. You might have
    come across the term *multithreading*, which means that a process has a number
    of parallel executions going on, potentially running on different CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this general view out of the way, let’s see how Linux goes about it. From
    most granular to smallest unit, Linux has the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sessions
  prefs: []
  type: TYPE_NORMAL
- en: Contain one or more process groups and represent a high-level user-facing unit
    with optional `tty` attached. The kernel identifies a session via a number called
    *session ID* (SID).
  prefs: []
  type: TYPE_NORMAL
- en: Process groups
  prefs: []
  type: TYPE_NORMAL
- en: Contain one or more processes, with at most one process group in a session as
    the foreground process group. The kernel identifies a process group via a number
    called *process group ID* (PGID).
  prefs: []
  type: TYPE_NORMAL
- en: Processes
  prefs: []
  type: TYPE_NORMAL
- en: Abstractions that group multiple resources (address space, one or more threads,
    sockets, etc.), which the kernel exposes to you via */proc/self* for the current
    process. The kernel identifies a process via a number called *process ID* (PID).
  prefs: []
  type: TYPE_NORMAL
- en: Threads
  prefs: []
  type: TYPE_NORMAL
- en: Implemented by the kernel as processes. That is, there are no dedicated data
    structures representing threads. Rather, a thread is a process that shares certain
    resources (such as memory or signal handlers) with other processes. The kernel
    identifies a thread via *thread IDs* (TID) and *thread group IDs* (TGID), with
    the semantics that a shared TGID value means a multithreaded process (in user
    land; there are also kernel threads, but that’s beyond our scope).
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs: []
  type: TYPE_NORMAL
- en: In the kernel there is a data structure called `task_struct`—defined in [*sched.h*](https://oreil.ly/nIgz8)—that
    forms the basis of implementing processes and threads alike. This data structure
    captures scheduling-related information, identifiers (such as PID and TGID), and
    signal handlers, as well as other information, such as that related to performance
    and security. In a nutshell, all of the aforementioned units are derived and/or
    anchored in tasks; however, tasks are not exposed as such outside of the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: We will see sessions, process groups, and processes in action and learn how
    to manage them in [Chapter 6](ch06.xhtml#running-apps), and they’ll appear again
    in the context of containers in [Chapter 9](ch09.xhtml#advanced).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see some of these concepts in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_linux_kernel_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `bash` shell process has PID, PGID, and SID of 6756\. From `ls -al /proc/6756/task/6756/`,
    we can glean the task-level information.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_linux_kernel_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ps` process has PID/PGID 6790 and the same SID as the shell.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned earlier on that in Linux the task data structure has some scheduling-related
    information at the ready. This means that at any given time a process is in a
    certain state, as shown in [Figure 2-2](#fig-process-states).
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0202](Images/lmlx_0202.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Linux process states
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Strictly speaking, the process states are a little more complicated; for example,
    Linux distinguishes between interruptible and uninterruptible sleep, and there
    is also the zombie state (in which it has lost its parent process). If you’re
    interested in the details, check out the article [“Process States in Linux”](https://oreil.ly/XBXbU).
  prefs: []
  type: TYPE_NORMAL
- en: Different events cause state transitions. For example, a running process might
    transition to the waiting state when it carries out some I/O operation (such as
    reading from a file) and can’t proceed with execution (off CPU).
  prefs: []
  type: TYPE_NORMAL
- en: 'Having taken a quick look at process management, let’s examine a related topic:
    memory.'
  prefs: []
  type: TYPE_NORMAL
- en: Memory Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Virtual memory makes your system appear as if it has more memory than it physically
    has. In fact, every process gets a lot of (virtual) memory. This is how it works:
    both physical memory and virtual memory are divided into fixed-length chunks we
    call *pages*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-3](#fig-virtual-memory-management) shows the virtual address spaces
    of two processes, each with its own page table. These page tables map virtual
    pages of the process into physical pages in main memory (aka RAM).'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0203](Images/lmlx_0203.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-3\. Virtual memory management overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Multiple virtual pages can point to the same physical page via their respective
    process-level page tables. This is, in a sense, the core of memory management:
    how to effectively provide each process with the illusion that its page actually
    exists in RAM while using the existing space optimally.'
  prefs: []
  type: TYPE_NORMAL
- en: Every time the CPU accesses a process’s virtual page, the CPU would in principle
    have to translate the virtual address a process uses to the corresponding physical
    address. To speed up this process—which can be multilevel and hence slow—modern
    CPU architectures support a lookup on-chip called [translation lookaside buffer
    (TLB)](https://oreil.ly/y3xy0). The TLB is effectively a small cache that, in
    case of a miss, causes the CPU to go via the process page table(s) to calculate
    the physical address of a page and update the TLB with it.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, Linux had a default page size of 4 KB, but since kernel v2.6.3,
    it supports [huge pages](https://oreil.ly/7rqLO), to better support modern architectures
    and workloads. For example, 64-bit Linux allows you to use up to 128 TB of virtual
    address space (with virtual being the theoretical addressable number of memory
    addresses) per process, with an approximate 64 TB of physical memory (with physical
    being the amount of RAM you have in your machine) in total.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, that was a lot of theoretical information. Let’s have a look at it from
    a more practical point of view. A very useful tool to figure out memory-related
    information such as how much RAM is available to you is the */proc/meminfo* interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_linux_kernel_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List details on physical memory (RAM); that’s 4 GB there.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_linux_kernel_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: List details on virtual memory; that’s a bit more than 34 TB there.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_linux_kernel_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: List huge pages information; apparently here the page size is 2 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, we move on to the next kernel function: networking.'
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important function of the kernel is to provide networking functionality.
    Whether you want to browse the web or copy data to a remote system, you depend
    on the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux network stack follows a layered architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  prefs: []
  type: TYPE_NORMAL
- en: For abstracting communication
  prefs: []
  type: TYPE_NORMAL
- en: Transmission Control Protocol (TCP) and User Datagram Protocol (UDP)
  prefs: []
  type: TYPE_NORMAL
- en: For connection-oriented communication and connectionless communication, respectively
  prefs: []
  type: TYPE_NORMAL
- en: Internet Protocol (IP)
  prefs: []
  type: TYPE_NORMAL
- en: For addressing machines
  prefs: []
  type: TYPE_NORMAL
- en: These three actions are all that the kernel takes care of. The application layer
    protocols such as HTTP or SSH are, usually, implemented in user land.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get an overview of your network interfaces using (output edited):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Further, `ip route` provides you with routing information. Since we have a dedicated
    networking chapter ([Chapter 7](ch07.xhtml#networking)) where we will dive deep
    into the networking stack, the supported protocols, and typical operations, we
    keep it at this and move on to the next kernel component, block devices and filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux uses filesystems to organize files and directories on storage devices
    such as hard disk drives (HDDs) and solid-state drives (SSDs) or flash memory.
    There are many types of filesystems, such as `ext4` and `btrfs` or NTFS, and you
    can have multiple instances of the same filesystem in use.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual File System (VFS) was originally introduced to support multiple filesystem
    types and instances. The highest layer in VFS provides a common API abstraction
    of functions such as open, close, read, and write. At the bottom of VFS are filesystem
    abstractions called *plug-ins* for the given filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: We will go into greater detail on filesystems and file operations in [Chapter 5](ch05.xhtml#files).
  prefs: []
  type: TYPE_NORMAL
- en: Device Drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *driver* is a bit of code that runs in the kernel. Its job is to manage a
    device, which can be actual hardware—like a keyboard, a mouse, or hard disk drives—or
    it can be a pseudo-device such as a pseudo-terminal under */dev/pts/* (which is
    not a physical device but can be treated like one).
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting class of hardware are [*graphics processing units* (GPUs)](https://oreil.ly/os7pu),
    which traditionally were used to accelerate graphics output and ease the load
    on the CPU. In recent years, GPUs have found a new use case in the context of
    [machine learning](https://oreil.ly/qrVcY), and hence they are not exclusively
    relevant in desktop environments.
  prefs: []
  type: TYPE_NORMAL
- en: The driver may be built statically into the kernel, or it can be built as a
    kernel module (see [“Modules”](#kernel-modules)) so that it can be dynamically
    loaded when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re interested in an interactive way to explore device drivers and how
    kernel components interact, check out the [Linux kernel map](https://oreil.ly/voBtR).
  prefs: []
  type: TYPE_NORMAL
- en: The kernel [driver model](https://oreil.ly/Cb6mw) is complicated and out of
    scope for this book. However, following are a few hints for interacting with it,
    just enough so that you know where to find what.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an overview of the devices on your Linux system, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, you can use the following to list mounted devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have covered the Linux kernel components and move to the interface
    between the kernel and user land.
  prefs: []
  type: TYPE_NORMAL
- en: syscalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you sit in front of a terminal and type `touch test.txt` or whether
    one of your apps wants to download the content of a file from a remote system,
    at the end of the day you ask Linux to turn the high-level instruction, such as
    “create a file” or “read all bytes from address so and so,” into a set of concrete,
    architecture-dependent steps. In other words, the service interface the kernel
    exposes and that user land entities call is the set of system calls, or [syscalls](https://oreil.ly/UF09U)
    for short.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux has hundreds of syscalls: around three hundred or more, depending on
    the CPU family. However, you and your programs don’t usually invoke these syscalls
    directly but via what we call the *C standard library*. The standard library provides
    wrapper functions and is available in various implementations, such as [glibc](https://oreil.ly/mZPRy)
    or [musl](https://oreil.ly/jnTCA).'
  prefs: []
  type: TYPE_NORMAL
- en: 'These wrapper libraries perform an important task. They take care of the repetitive
    low-level handling of the execution of a syscall. System calls are implemented
    as software interrupts, causing an exception that transfers the control to an
    exception handler. There are a number of steps to take care of every time a syscall
    is invoked, as depicted in [Figure 2-4](#fig-syscall-seq):'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0204](Images/lmlx_0204.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-4\. syscall execution steps in Linux
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Defined in *syscall.h* and architecture-dependent files, the kernel uses a so-called
    *syscall table*, effectively an array of function pointers in memory (stored in
    a variable called `sys_call_table`) to keep track of syscalls and their corresponding
    handlers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the `system_call()` function acting like a syscall multiplexer, it first
    saves the hardware context on the stack, then performs checks (like if tracing
    is performed), and then jumps to the function pointed to by the respective syscall
    number index in the `sys_call_table`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the syscall is completed with `sysexit`, the wrapper library restores
    the hardware context, and the program execution resumes in user land.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notable in the previous steps is the switching between kernel mode and user
    land mode, an operation that costs time.
  prefs: []
  type: TYPE_NORMAL
- en: OK, that was a little dry and theoretical, so to better appreciate how syscalls
    look and feel in practice, let’s have a look at a concrete example. We will use
    [`strace`](https://oreil.ly/ksV9B) to look behind the curtain, a tool useful for
    troubleshooting, for example, if you don’t have the source code of an app but
    want to learn what it does.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume you wonder what syscalls are involved when you execute the innocent-looking
    `ls` command. Here’s how you can find it out using `strace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_linux_kernel_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: With `strace ls`, we ask `strace` to capture the syscall that `ls` uses. Note
    that I edited the output since `strace` generates some 162 lines on my system
    (this number varies between different distros, architectures, and other factors).
    Further, the output you see there comes via `stderr`, so if you want to redirect
    it, you have to use `2>` here. You’ll learn more about this in [Chapter 3](ch03.xhtml#shells-scripting).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_linux_kernel_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The syscall [`execve`](https://oreil.ly/iasHW) executes */usr/bin/ls*, causing
    the shell process to be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_the_linux_kernel_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`brk`](https://oreil.ly/HRuNj) syscall is an outdated way to allocate memory;
    it’s safer and more portable to use `malloc`. Note that `malloc` is not a syscall
    but a function that in turn uses `mallocopt` to decide if it needs to use the
    `brk` syscall or the `mmap` syscall based on the amount of memory accessed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_the_linux_kernel_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `access` syscall checks if the process is allowed to access a certain file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_the_linux_kernel_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Syscall `openat` opens the file */etc/ld.so.cache* relative to a directory file
    descriptor (here the first argument, `AT_FDCWD`, which stands for the current
    directory) and using flags `O_RDONLY|O_CLOEXEC` (last argument).
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_the_linux_kernel_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The `read` syscall reads from a file descriptor (first argument, `3`) 832 bytes
    (last argument) into a buffer (second argument).
  prefs: []
  type: TYPE_NORMAL
- en: '`strace` is useful to see exactly what syscalls have been called—in which order
    and with which arguments—effectively hooking into the live stream of events between
    user land and kernel. It’s also good for performance diagnostics. Let’s see where
    a `curl` command spends most of its time (output shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_linux_kernel_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `-c` option to generate overview stats of the syscalls used.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_the_linux_kernel_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Discard all output of `curl`.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the `curl` command here spends almost half of its time with `mmap`
    and `read` syscalls, and the `connect` syscall takes 0.3 ms—not bad.
  prefs: []
  type: TYPE_NORMAL
- en: To help you get a feeling for the coverage, I’ve put together [Table 2-1](#table-sycalls-examples),
    which lists examples of widely used syscalls across kernel components as well
    as system-wide ones. You can look up details of syscalls, including their parameters
    and return values, via [section 2 of the man pages](https://oreil.ly/qLOA3).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Example syscalls
  prefs: []
  type: TYPE_NORMAL
- en: '| Category | Example syscalls |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Process management | `clone`, `fork`, `execve`, `wait`, `exit`, `getpid`,
    `setuid`, `setns`, `getrusage`, `capset`, `ptrace` |'
  prefs: []
  type: TYPE_TB
- en: '| Memory management | `brk`, `mmap`, `munmap`, `mremap`, `mlock`, `mincore`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Networking | `socket`, `setsockopt`, `getsockopt`, `bind`, `listen`, `accept`,
    `connect`, `shutdown`, `recvfrom`, `recvmsg`, `sendto`, `sethostname`, `bpf` |'
  prefs: []
  type: TYPE_TB
- en: '| Filesystems | `open`, `openat`, `close`, `mknod`, `rename`, `truncate`, `mkdir`,
    `rmdir`, `getcwd`, `chdir`, `chroot`, `getdents`, `link`, `symlink`, `unlink`,
    `umask`, `stat`, `chmod`, `utime`, `access`, `ioctl`, `flock`, `read`, `write`,
    `lseek`, `sync`, `select`, `poll`, `mount`, |'
  prefs: []
  type: TYPE_TB
- en: '| Time | `time`, `clock_settime`, `timer_create`, `alarm`, `nanosleep` |'
  prefs: []
  type: TYPE_TB
- en: '| Signals | `kill`, `pause`, `signalfd`, `eventfd`, |'
  prefs: []
  type: TYPE_TB
- en: '| Global | `uname`, `sysinfo`, `syslog`, `acct`, `_sysctl`, `iopl`, `reboot`
    |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a nice interactive [syscall table](https://oreil.ly/HKu6Y) available
    online with source code references.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic idea of the Linux kernel, its main components, and
    interface, let’s move on to the question of how to extend it.
  prefs: []
  type: TYPE_NORMAL
- en: Kernel Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will focus on how to extend the kernel. In a sense, the
    content here is advanced and optional. You won’t need it for your day-to-day work,
    in general.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Configuring and compiling your own Linux kernel is out of scope for this book.
    For information on how to do it, I recommend [*Linux Kernel in a Nutshell*](https://oreil.ly/jzFCj)
    (O’Reilly) by Greg Kroah-Hartman, one of the main Linux maintainers and project
    lead. He covers the entire range of tasks, from downloading the source code to
    configuration and installation steps, to kernel options at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with something easy: how do you know what kernel version you’re
    using? You can use the following command to determine this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_the_linux_kernel_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: From the `uname` output here, you can tell that at the time of writing, I’m
    using a [5.11 kernel](https://oreil.ly/FJdA1) on an `x86_64` machine (see also
    [“x86 Architecture”](#cpu-arch-x86)).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the kernel version, we can address the question of how to extend
    the kernel out-of-tree—that is, without having to add features to the kernel source
    code and then build it. For this extension we can use modules, so let’s have a
    look at that.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a nutshell, a *module* is a program that you can load into a kernel on demand.
    That is, you do not necessarily have to recompile the kernel and/or reboot the
    machine. Nowadays, Linux detects most of the hardware automatically, and with
    it Linux loads its modules automatically. But there are cases where you want to
    manually load a module. Consider the following case: the kernel detects a video
    card and loads a generic module. However, the video card manufacturer offers a
    better third-party module (not available in the Linux kernel) that you may choose
    to use instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To list available modules, run the following command (output has been edited
    down, as there are over one thousand lines on my system):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s great! But which modules did the kernel actually load? Let’s take a
    look (output shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding information is available via */proc/modules*. This is
    thanks to the kernel exposing this information via a pseudo-filesystem interface;
    more on this topic is presented in [Chapter 6](ch06.xhtml#running-apps).
  prefs: []
  type: TYPE_NORMAL
- en: 'Want to learn more about a module or have a nice way to manipulate kernel modules?
    Then `modprobe` is your friend. For example, to list the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up: an alternative, modern way to extend the kernel.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Modern Way to Extend the Kernel: eBPF'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An increasingly popular way to extend kernel functionality is eBPF. Originally
    known as *Berkeley Packet Filter* (BPF), nowadays the kernel project and technology
    is commonly known as *eBPF* (a term that does not stand for anything).
  prefs: []
  type: TYPE_NORMAL
- en: Technically, eBPF is a feature of the Linux kernel, and you’ll need the Linux
    kernel version 3.15 or above to benefit from it. It enables you to safely and
    efficiently extend the Linux kernel functions by using the [`bpf`](https://oreil.ly/cltxg)
    syscall. eBPF is implemented as an in-kernel virtual machine using a custom 64-bit
    RISC instruction set.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to learn more about what is enabled in which kernel version for
    eBPF, you can use the [iovisor/bcc docs on GitHub](https://oreil.ly/HtKO8).
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 2-5](#fig-bpf-overview) you see a high-level overview taken from
    Brendan Gregg’s book [*BPF Performance Tools: Linux System and Application Observability*](https://oreil.ly/sfYKK)
    (Addison Wesley).'
  prefs: []
  type: TYPE_NORMAL
- en: '![lmlx 0205](Images/lmlx_0205.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-5\. eBPF overview in the Linux kernel
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'eBPF is already used in a number of places and for use cases such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: As a CNI plug-in to enable pod networking in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: For example, in [Cilium](https://oreil.ly/BS0iz) and Project Calico. Also, for
    service scalability.
  prefs: []
  type: TYPE_NORMAL
- en: For observability
  prefs: []
  type: TYPE_NORMAL
- en: For Linux kernel tracing, such as with [iovisor/bpftrace](https://oreil.ly/0M0oV),
    as well as in a clustered setup with [Hubble](https://oreil.ly/7yzhq) (see [Chapter 8](ch08.xhtml#observability)).
  prefs: []
  type: TYPE_NORMAL
- en: As a security control
  prefs: []
  type: TYPE_NORMAL
- en: For example, to perform container runtime scanning as you can use with projects
    such as [CNCF Falco](https://falco.org).
  prefs: []
  type: TYPE_NORMAL
- en: For network load balancing
  prefs: []
  type: TYPE_NORMAL
- en: Such as in Facebook’s L4 [katran](https://oreil.ly/HqMZg) library.
  prefs: []
  type: TYPE_NORMAL
- en: In mid-2021, the Linux Foundation announced that Facebook, Google, Isovalent,
    Microsoft, and Netflix joined together to [create the eBPF Foundation](https://oreil.ly/g2buM),
    and with it giving the eBPF project a vendor-neutral home. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: If you want to stay on top of things, have a look at [*ebpf.io*](https://ebpf.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Linux kernel is the core of the Linux operating system, and no matter what
    distribution or environment you are using Linux in—be it on your desktop or in
    the cloud—you should have a basic idea of its components and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the overall Linux architecture, the role of the
    kernel, and its interfaces. Most importantly, the kernel abstracts away the differences
    of the hardware—CPU architectures and peripheral devices—and makes Linux very
    portable. The most important interface is the syscall interface, through which
    the kernel exposes its functionality—be it opening a file, allocating memory,
    or listing network interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We have also looked a bit at the inner workings of the kernel, including modules
    and eBPF. If you want to extend the kernel functionality or implement performant
    tasks in the kernel (controlled from the user space), then eBPF is definitely
    worth taking a closer look at.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to learn more about certain aspects of the kernel, the following
    resources should provide you with some starting points:'
  prefs: []
  type: TYPE_NORMAL
- en: General
  prefs: []
  type: TYPE_NORMAL
- en: '[*The Linux Programming Interface*](https://oreil.ly/HCLmX) by Michael Kerrisk
    (No Starch Press).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linux Kernel Teaching](https://oreil.ly/lMzbW) provides a nice introduction
    with deep dives across the board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Anatomy of the Linux Kernel”](https://oreil.ly/it2jK) gives a quick high-level
    intro.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Operating System Kernels”](https://oreil.ly/9d93Y) has a nice overview and
    comparison of kernel design approaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[KernelNewbies](https://oreil.ly/OSfbA) is a great resource if you want to
    dive deeper into hands-on topics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[kernelstats](https://oreil.ly/kSov7) shows some interesting distributions
    over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Linux Kernel Map](https://oreil.ly/G55tF) is a visual representation of
    kernel components and dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory management
  prefs: []
  type: TYPE_NORMAL
- en: '[*Understanding the Linux Virtual Memory Manager*](https://oreil.ly/uKjtQ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“The Slab Allocator in the Linux Kernel”](https://oreil.ly/dBLkt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kernel docs](https://oreil.ly/sTBhM)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Device drivers
  prefs: []
  type: TYPE_NORMAL
- en: '[*Linux Device Drivers*](https://oreil.ly/Kn7CZ) by Jonathan Corbet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“How to Install a Device Driver on Linux”](https://oreil.ly/a0chO)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Character Device Drivers](https://oreil.ly/EGXIh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Linux Device Drivers: Tutorial for Linux Driver Development*](https://oreil.ly/jkiwB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: syscalls
  prefs: []
  type: TYPE_NORMAL
- en: '[“Linux Interrupts: The Basic Concepts”](https://oreil.ly/yCdTi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[The Linux Kernel: System Calls](https://oreil.ly/A3XMT)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linux System Call Table](https://oreil.ly/mezjr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*syscalls.h* source code](https://oreil.ly/tf6CW)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[syscall lookup for x86 and x86_64](https://oreil.ly/K7Zid)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: eBPF
  prefs: []
  type: TYPE_NORMAL
- en: '[“Introduction to eBPF”](https://oreil.ly/Afdsx) by Matt Oswalt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[eBPF maps documentation](https://oreil.ly/Fnj5t)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Equipped with this knowledge, we’re now ready to climb up the abstraction ladder
    a bit and move to the primary user interface we consider in this book: the shell,
    both in manual usage as well as automation through scripts.'
  prefs: []
  type: TYPE_NORMAL
