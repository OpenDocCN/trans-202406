<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 10. Generics"><div class="chapter" id="generics_chapter">
<h1><span class="label">Chapter 10. </span>Generics</h1>

<blockquote>
<p>Variables you</p>

<p>declare in the type system?</p>

<p>A whole new (typed) world!</p></blockquote>

<p>All the type syntaxes you’ve learned about so far are meant to be used with types that are completely known when they’re being written.
Sometimes, however, a piece of code may be intended to work with various different types depending on how it’s called.</p>

<p>Take this <code>identity</code> function in JavaScript meant to receive an input of any possible type and return that same input as output.
How would you describe its parameter type and return type?</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">identity</code><code class="p">(</code><code class="nx">input</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">input</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">identity</code><code class="p">(</code><code class="s2">"abc"</code><code class="p">);</code>
<code class="nx">identity</code><code class="p">(</code><code class="mi">123</code><code class="p">);</code>
<code class="nx">identity</code><code class="p">({</code> <code class="nx">quote</code><code class="o">:</code> <code class="s2">"I think your self emerges more clearly over time."</code> <code class="p">});</code></pre>

<p>We could declare <code>input</code> as <code>any</code>, but then the return type of the function would also be <code>any</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">identity</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">input</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">identity</code><code class="p">(</code><code class="mi">42</code><code class="p">);</code> <code class="c1">// Type of value: any</code></pre>

<p>Given <a data-type="indexterm" data-primary="generics" data-secondary="purpose of" id="idm45584677983248"/>that <code>input</code> is allowed to be any input, we need a way to say that there is a relationship between the <code>input</code> type and the type the function returns.
TypeScript captures relationships between types using <em>generics</em>.</p>

<p class="less_space pagebreak-before">In TypeScript, <a data-type="indexterm" data-primary="type parameters" data-secondary="purpose of" id="type-argue-purpose"/>constructs such as functions may declare any number of generic <em>type parameters</em>: types that are determined for each usage of the generic construct.
These type parameters are used as types in the construct to represent some type that can be different in each instance of the construct.
Type parameters may be provided with different types, referred to as <em>type arguments</em>, for each instance of the construct but will remain consistent within that<a data-type="indexterm" data-primary="type arguments" data-secondary="purpose of" data-startref="type-argue-purpose" id="idm45584677977904"/> instance.</p>

<p>Type parameters <a data-type="indexterm" data-primary="type parameters" data-secondary="naming conventions" id="idm45584677975888"/><a data-type="indexterm" data-primary="naming conventions" data-secondary="for type parameters" data-secondary-sortas="type parameters" id="idm45584677974880"/>typically have single-letter names like <code>T</code> and <code>U</code> or PascalCase names like <code>Key</code> and <code>Value</code>.
In all of the constructs covered in this chapter, generics may be declared using <code>&lt;</code> and <code>&gt;</code> brackets, like <code>someFunction&lt;T&gt;</code> or <code>SomeInterface&lt;T&gt;</code>.</p>






<section data-type="sect1" data-pdf-bookmark="Generic Functions"><div class="sect1" id="idm45584677970080">
<h1>Generic Functions</h1>

<p>A function<a data-type="indexterm" data-primary="generics" data-secondary="for functions" data-tertiary="declaring" data-secondary-sortas="functions" id="idm45584677968320"/><a data-type="indexterm" data-primary="functions" data-secondary="generics for" data-tertiary="declaring" id="idm45584677966768"/><a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for functions" data-tertiary-sortas="functions" id="type-generic-function"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic functions" data-secondary-sortas="generic functions" id="idm45584677963792"/><a data-type="indexterm" data-primary="declaring" data-secondary="functions" data-tertiary="as generics" data-tertiary-sortas="generics" id="idm45584677940912"/> may be made generic by placing an alias for a type parameter, wrapped in angle brackets, immediately before the parameters parentheses.
That type parameter will then be available for usage in parameter type annotations, return type annotations, and type annotations inside the function’s body.</p>

<p>The following version of <code>identity</code> declares a type parameter <code>T</code> for its <code>input</code> parameter, which allows TypeScript to infer that the return type of the function is <code>T</code>.
TypeScript can then infer a different type for <code>T</code> every time <code>identity</code> is called:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">identity</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">input</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">numeric</code> <code class="o">=</code> <code class="nx">identity</code><code class="p">(</code><code class="s2">"me"</code><code class="p">);</code> <code class="c1">// Type: "me"</code>
<code class="kr">const</code> <code class="nx">stringy</code> <code class="o">=</code> <code class="nx">identity</code><code class="p">(</code><code class="mi">123</code><code class="p">);</code> <code class="c1">// Type: 123</code></pre>

<p>Arrow functions can be generic too.
Their generic declarations are also placed immediately before the <code>(</code> before their list of parameters.</p>

<p>The following arrow function is functionally the same as the previous declaration:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">identity</code> <code class="o">=</code> <code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code><code class="p">;</code>

<code class="nx">identity</code><code class="p">(</code><code class="mi">123</code><code class="p">);</code> <code class="c1">// Type: 123</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The syntax for generic arrow functions has some restrictions in <em>.tsx</em> files, as it conflicts with JSX syntax.
See <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a> for workarounds as well as configuring JSX and React support.</p>
</div>

<p>Adding type parameters to functions in this way allows them to be reused with different inputs while still maintaining type safety and avoiding <code>any</code> types.</p>








<section data-type="sect2" data-pdf-bookmark="Explicit Generic Call Types"><div class="sect2" id="idm45584677856640">
<h2>Explicit Generic Call Types</h2>

<p>Most of <a data-type="indexterm" data-primary="generics" data-secondary="for functions" data-tertiary="explicit type arguments" data-secondary-sortas="functions" id="generic-function-explicit"/><a data-type="indexterm" data-primary="functions" data-secondary="generics for" data-tertiary="explicit type arguments" id="function-generic-explicit"/><a data-type="indexterm" data-primary="explicit type arguments" data-secondary="for generic functions" data-secondary-sortas="generic functions" id="explicit-type-argue-function"/><a data-type="indexterm" data-primary="type arguments" data-secondary="for generic functions" data-tertiary="explicit arguments" data-secondary-sortas="generic functions" id="type-argue-generic-explicit"/>the time when calling generic functions, TypeScript will be able to infer type arguments based on how the function is being called.
For example, in the previous examples’ <code>identity</code> functions, TypeScript’s type checker used an argument provided to <code>identity</code> to infer the corresponding function parameter’s type argument.</p>

<p>Unfortunately, as with class members and variable types, sometimes there isn’t enough information from a function’s call to inform TypeScript what its type argument should resolve to.
This will commonly happen if a generic construct is provided another generic construct whose type arguments aren’t known.</p>

<p>TypeScript will default to assuming the <code>unknown</code> type for any type argument it cannot infer.</p>

<p>For example, the following <code>logWrapper</code> function takes in a callback with a parameter type set to <code>logWrapper</code>’s type parameter <code>Input</code>.
TypeScript can infer the type argument if <code>logWrapper</code> is called with a callback that explicitly declares its parameter type.
If the parameter type is implicit, however, TypeScript has no way of knowing what <code>Input</code> should be:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">logWrapper</code><code class="o">&lt;</code><code class="nx">Input</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">Input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">Input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Input:"</code><code class="p">,</code> <code class="nx">input</code><code class="p">);</code>
        <code class="nx">callback</code><code class="p">(</code><code class="nx">input</code><code class="p">);</code>
    <code class="p">};</code>
<code class="p">}</code>

<code class="c1">// Type: (input: string) =&gt; void</code>
<code class="nx">logWrapper</code><code class="p">((</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// Type: (input: unknown) =&gt; void</code>
<code class="nx">logWrapper</code><code class="p">((</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
    <code class="c1">//                ~~~~~~</code>
    <code class="c1">// Error: Property 'length' does not exist on type 'unknown'.</code>
<code class="p">});</code></pre>

<p>To avoid defaulting to <code>unknown</code>, functions may be called with an explicit generic type argument that explicitly tells TypeScript what that type argument should be instead.
TypeScript will perform type checking on the generic call to make sure the parameter being requested matches up to what’s provided as a type argument.</p>

<p>Here, the <code>logWrapper</code> seen previously is provided with an explicit <code>string</code> for its <code>Input</code> generic.
TypeScript can then infer that the callback’s <code>input</code> parameter of generic type <code>Input</code> resolves to type <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: (input: string) =&gt; void</code>
<code class="nx">logWrapper</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">((</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
<code class="p">});</code>

<code class="nx">logWrapper</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">((</code><code class="nx">input</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">//             ~~~~~~~~~~~~~~~~~~~~~~~</code>
    <code class="c1">// Argument of type '(input: boolean) =&gt; void' is not</code>
    <code class="c1">// assignable to parameter of type '(input: string) =&gt; void'.</code>
    <code class="c1">//   Types of parameters 'input' and 'input' are incompatible.</code>
    <code class="c1">//     Type 'string' is not assignable to type 'boolean'.</code>
<code class="p">});</code></pre>

<p>Much like explicit type annotations on variables, explicit type arguments may always be specified on a generic function but often aren’t necessary.
Many TypeScript developers generally only specify them when needed.</p>

<p>The following <code>logWrapper</code> usage explicitly specifies <code>string</code> both as a type argument and as a function parameter type.
Either could be removed:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: (input: string) =&gt; void</code>
<code class="nx">logWrapper</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">((</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">});</code></pre>

<p>The <code>Name&lt;Type&gt;</code> syntax for specifying a type argument will be the same for other generic constructs throughout this <a data-type="indexterm" data-primary="generics" data-secondary="for functions" data-tertiary="explicit type arguments" data-secondary-sortas="functions" data-startref="generic-function-explicit" id="idm45584677611232"/><a data-type="indexterm" data-primary="functions" data-secondary="generics for" data-tertiary="explicit type arguments" data-startref="function-generic-explicit" id="idm45584677609568"/><a data-type="indexterm" data-primary="explicit type arguments" data-secondary="for generic functions" data-secondary-sortas="generic functions" data-startref="explicit-type-argue-function" id="idm45584677608112"/><a data-type="indexterm" data-primary="type arguments" data-secondary="for generic functions" data-tertiary="explicit arguments" data-secondary-sortas="generic functions" data-startref="type-argue-generic-explicit" id="idm45584677606656"/>chapter.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Multiple Function Type Parameters"><div class="sect2" id="idm45584677855984">
<h2>Multiple Function Type Parameters</h2>

<p>Functions may<a data-type="indexterm" data-primary="generics" data-secondary="for functions" data-tertiary="multiple type parameters" data-secondary-sortas="functions" id="idm45584677603296"/><a data-type="indexterm" data-primary="functions" data-secondary="generics for" data-tertiary="multiple type arguments" id="idm45584677601776"/><a data-type="indexterm" data-primary="multiple type arguments for generic functions" id="idm45584677600560"/><a data-type="indexterm" data-primary="type arguments" data-secondary="for generic functions" data-tertiary="multiple arguments" data-secondary-sortas="generic functions" id="idm45584677599920"/> define any number of type parameters, separated by commas.
Each call of the generic function may resolve its own set of values for each of the type parameters.</p>

<p>In this example, <code>makeTuple</code> declares two type parameters and returns a value typed as a read-only tuple with one, then the other:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">makeTuple</code><code class="o">&lt;</code><code class="nx">First</code><code class="p">,</code> <code class="nx">Second</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">first</code>: <code class="nx">First</code><code class="p">,</code> <code class="nx">second</code>: <code class="nx">Second</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="nx">second</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">tuple</code> <code class="o">=</code> <code class="nx">makeTuple</code><code class="p">(</code><code class="kc">true</code><code class="p">,</code> <code class="s2">"abc"</code><code class="p">);</code> <code class="c1">// Type of value: readonly [boolean, string]</code></pre>

<p>Note that if a function declares multiple type parameters, calls to that function must explicitly declare either none of the generic types or all of them.
TypeScript does not yet support inferring only some of the types of a generic call.</p>

<p>Here, <code>makePair</code> also takes in two type parameters, so either neither of them or both of them must be explicitly <a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for functions" data-tertiary-sortas="functions" data-startref="type-generic-function" id="idm45584677548512"/>specified:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kd">function</code> <code class="nx">makePair</code><code class="o">&lt;</code><code class="nx">Key</code><code class="p">,</code> <code class="nx">Value</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">key</code>: <code class="nx">Key</code><code class="p">,</code> <code class="nx">value</code>: <code class="nx">Value</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">{</code> <code class="nx">key</code><code class="p">,</code> <code class="nx">value</code> <code class="p">};</code>
<code class="p">}</code>

<code class="c1">// Ok: neither type argument provided</code>
<code class="nx">makePair</code><code class="p">(</code><code class="s2">"abc"</code><code class="p">,</code> <code class="mi">123</code><code class="p">);</code> <code class="c1">// Type: { key: string; value: number }</code>

<code class="c1">// Ok: both type arguments provided</code>
<code class="nx">makePair</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="s2">"abc"</code><code class="p">,</code> <code class="mi">123</code><code class="p">);</code> <code class="c1">// Type: { key: string; value: number }</code>
<code class="nx">makePair</code><code class="o">&lt;</code><code class="s2">"abc"</code><code class="p">,</code> <code class="mi">123</code><code class="o">&gt;</code><code class="p">(</code><code class="s2">"abc"</code><code class="p">,</code> <code class="mi">123</code><code class="p">);</code> <code class="c1">// Type: { key: "abc"; value: 123 }</code>

<code class="nx">makePair</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="s2">"abc"</code><code class="p">,</code> <code class="mi">123</code><code class="p">);</code>
<code class="c1">//       ~~~~~~</code>
<code class="c1">// Error: Expected 2 type arguments, but got 1.</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>Try not to use more than one or two type parameters in any generic construct.
As with runtime function parameters, the more you use, the harder it is to read and understand the code.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Generic Interfaces"><div class="sect1" id="idm45584677969424">
<h1>Generic Interfaces</h1>

<p>Interfaces <a data-type="indexterm" data-primary="generics" data-secondary="for interfaces" data-secondary-sortas="interfaces" id="generic-interface"/><a data-type="indexterm" data-primary="interfaces" data-secondary="generics for" id="interface-generic"/><a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for interfaces" data-tertiary-sortas="interfaces" id="type-generic-interface"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic interfaces" data-secondary-sortas="generic interfaces" id="type-argue-interface"/><a data-type="indexterm" data-primary="declaring" data-secondary="interfaces as generics" id="idm45584677421520"/>may be declared as generic as well.
They follow similar generic rules to functions: they may have any number of type parameters declared between a <code>&lt;</code> and <code>&gt;</code> after their name.
That generic type may later be used elsewhere in their declaration, such as on member types.</p>

<p>The following <code>Box</code> declaration has a <code>T</code> type parameter for a property.
Creating an object declared to be a <code>Box</code> with a type argument enforces that the <code>inside: T</code> property matches that type argument:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Box</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">inside</code>: <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">stringyBox</code>: <code class="nx">Box</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">inside</code><code class="o">:</code> <code class="s2">"abc"</code><code class="p">,</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">numberBox</code>: <code class="nx">Box</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">inside</code>: <code class="nx">123</code><code class="p">,</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">incorrectBox</code>: <code class="nx">Box</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">inside</code>: <code class="nx">false</code><code class="p">,</code>
    <code class="c1">// Error: Type 'boolean' is not assignable to type 'number'.</code>
<code class="p">}</code></pre>

<p>Fun fact: the built-in <code>Array</code> methods are defined in TypeScript as a generic interface!
<code>Array</code> uses a type parameter <code>T</code> to represent the type of data stored within an array.
Its <code>pop</code> and <code>push</code> methods look roughly like so:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="c1">// ...</code>

    <code class="cm">/**</code>
<code class="cm">     * Removes the last element from an array and returns it.</code>
<code class="cm">     * If the array is empty, undefined is returned and the array is not modified.</code>
<code class="cm">     */</code>
    <code class="nx">pop</code><code class="p">()</code><code class="o">:</code> <code class="nx">T</code><code class="o"> | </code><code class="nx">undefined</code><code class="p">;</code>

    <code class="cm">/**</code>
<code class="cm">     * Appends new elements to the end of an array,</code>
<code class="cm">     * and returns the new length of the array.</code>
<code class="cm">     * @param items new elements to add to the array.</code>
<code class="cm">     */</code>
    <code class="nx">push</code><code class="p">(...</code><code class="nx">items</code>: <code class="nx">T</code><code class="p">[])</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>

    <code class="c1">// ...</code>
<code class="p">}</code></pre>








<section data-type="sect2" data-pdf-bookmark="Inferred Generic Interface Types"><div class="sect2" id="idm45584677368256">
<h2>Inferred Generic Interface Types</h2>

<p>As with generic functions, generic interface type arguments may be inferred from usage.
TypeScript will do its best to infer type arguments from the types of values provided to a location declared as taking in a generic type.</p>

<p>This <code>getLast</code> function declares a type parameter <code>Value</code> that is then used for its <code>node</code> parameter.
TypeScript can then infer <code>Value</code> based on the type of whatever value is passed in as an argument.
It can even report a type error when an inferred type argument doesn’t match the type of a value. Providing <code>getLast</code> with an object that doesn’t include <code>next</code>, or whose inferred <code>Value</code> type argument is the same type, is allowed.
Mismatching the provided object’s <code>value</code> and <code>next.value</code>, though, is a type error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">LinkedNode</code><code class="o">&lt;</code><code class="nx">Value</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">next?</code>: <code class="nx">LinkedNode</code><code class="o">&lt;</code><code class="nx">Value</code><code class="o">&gt;</code><code class="p">;</code>
    <code class="nx">value</code>: <code class="nx">Value</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">getLast</code><code class="o">&lt;</code><code class="nx">Value</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">node</code>: <code class="nx">LinkedNode</code><code class="o">&lt;</code><code class="nx">Value</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="nx">Value</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">node</code><code class="p">.</code><code class="nx">next</code> <code class="o">?</code> <code class="nx">getLast</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">next</code><code class="p">)</code> <code class="o">:</code> <code class="nx">node</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Inferred Value type argument: Date</code>
<code class="kd">let</code> <code class="nx">lastDate</code> <code class="o">=</code> <code class="nx">getLast</code><code class="p">({</code>
    <code class="nx">value</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s2">"09-13-1993"</code><code class="p">),</code>
<code class="p">});</code>

<code class="c1">// Inferred Value type argument: string</code>
<code class="kd">let</code> <code class="nx">lastFruit</code> <code class="o">=</code> <code class="nx">getLast</code><code class="p">({</code>
    <code class="nx">next</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">value</code><code class="o">:</code> <code class="s2">"banana"</code><code class="p">,</code>
    <code class="p">},</code>
    <code class="nx">value</code><code class="o">:</code> <code class="s2">"apple"</code><code class="p">,</code>
<code class="p">});</code>

<code class="c1">// Inferred Value type argument: number</code>
<code class="kd">let</code> <code class="nx">lastMismatch</code> <code class="o">=</code> <code class="nx">getLast</code><code class="p">({</code>
    <code class="nx">next</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">value</code>: <code class="nx">123</code>
    <code class="p">},</code>
    <code class="nx">value</code>: <code class="nx">false</code><code class="p">,</code>
<code class="c1">//  ~~~~~</code>
<code class="c1">// Error: type 'boolean' is not assignable to type 'number'.</code>
<code class="p">});</code></pre>

<p>Note that if an interface declares type parameters, any type annotations referring to that interface must provide corresponding type arguments.
Here, the usage of <code>CrateLike</code> is incorrect for not including a type argument:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">CrateLike</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">contents</code>: <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">missingGeneric</code>: <code class="nx">CrateLike</code> <code class="o">=</code> <code class="p">{</code>
    <code class="c1">//              ~~~~~~~~~</code>
    <code class="c1">// Error: Generic type 'Crate&lt;T&gt;' requires 1 type argument(s).</code>
    <code class="nx">inside</code><code class="o">:</code> <code class="s2">"??"</code>
<code class="p">};</code></pre>

<p>Later in this chapter, I’ll show how to provide default values for type parameters to get around this <a data-type="indexterm" data-primary="generics" data-secondary="for interfaces" data-secondary-sortas="interfaces" data-startref="generic-interface" id="idm45584677044672"/><a data-type="indexterm" data-primary="interfaces" data-secondary="generics for" data-startref="interface-generic" id="idm45584677043312"/><a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for interfaces" data-tertiary-sortas="interfaces" data-startref="type-generic-interface" id="idm45584677042096"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic interfaces" data-secondary-sortas="generic interfaces" data-startref="type-argue-interface" id="idm45584677040336"/>requirement.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Generic Classes"><div class="sect1" id="idm45584677038592">
<h1>Generic Classes</h1>

<p>Classes,<a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="declaring" data-secondary-sortas="classes" id="generic-class-declare"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="declaring" id="class-generic-declare"/><a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for classes" data-tertiary-sortas="classes" id="type-generic-class"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic classes" data-tertiary="declaring" data-secondary-sortas="generic classes" id="type-argue-class-declare"/><a data-type="indexterm" data-primary="declaring" data-secondary="classes as generics" id="declare-class-generic"/> like interfaces, can also declare any number of type parameters to be later used on members.
Each instance of the class may have a different set of type arguments for its type parameters.</p>

<p>This <code>Secret</code> class declares <code>Key</code> and <code>Value</code> type parameters, then uses them for member properties, constructor parameter types, and a method’s parameter and return types:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Secret</code><code class="o">&lt;</code><code class="nx">Key</code><code class="p">,</code> <code class="nx">Value</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">Key</code><code class="p">;</code>
    <code class="nx">value</code>: <code class="nx">Value</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">key</code>: <code class="nx">Key</code><code class="p">,</code> <code class="nx">value</code>: <code class="nx">Value</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">key</code> <code class="o">=</code> <code class="nx">key</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">getValue</code><code class="p">(</code><code class="nx">key</code>: <code class="nx">Key</code><code class="p">)</code><code class="o">:</code> <code class="nx">Value</code><code class="o"> | </code><code class="nx">undefined</code> <code class="p">{</code>
        <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">key</code> <code class="o">===</code> <code class="nx">key</code>
            <code class="o">?</code> <code class="k">this</code><code class="p">.</code><code class="nx">value</code>
            : <code class="nx">undefined</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">storage</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Secret</code><code class="p">(</code><code class="mi">12345</code><code class="p">,</code> <code class="s2">"luggage"</code><code class="p">);</code> <code class="c1">// Type: Secret&lt;number, string&gt;</code>

<code class="nx">storage</code><code class="p">.</code><code class="nx">getValue</code><code class="p">(</code><code class="mi">1987</code><code class="p">);</code> <code class="c1">// Type: string | undefined</code></pre>

<p>As with generic interfaces, type annotations using a class must indicate to TypeScript what any generic types on that class are.
Later in this chapter, I’ll show how to provide default values for type parameters to get around this requirement for <a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="declaring" data-secondary-sortas="classes" data-startref="generic-class-declare" id="idm45584677006688"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="declaring" data-startref="class-generic-declare" id="idm45584676919504"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic classes" data-tertiary="declaring" data-secondary-sortas="generic classes" data-startref="type-argue-class-declare" id="idm45584676918016"/><a data-type="indexterm" data-primary="declaring" data-secondary="classes as generics" data-startref="declare-class-generic" id="idm45584676916288"/>classes too.</p>








<section data-type="sect2" data-pdf-bookmark="Explicit Generic Class Types"><div class="sect2" id="idm45584676896416">
<h2>Explicit Generic Class Types</h2>

<p>Instantiating<a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="explicit types" data-secondary-sortas="classes" id="generic-class-explicit"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="explicit types" id="class-generic-explicit"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic classes" data-tertiary="explicit types" data-secondary-sortas="generic classes" id="type-argue-class-explicit"/><a data-type="indexterm" data-primary="explicit type arguments" data-secondary="for generic classes" data-secondary-sortas="generic classes" id="type-argue-class-generic"/> generic classes goes by the same type arguments inference rules as calling generic functions.
If the type argument can be inferred from the type of a parameter to the class constructor, such as the <code>new Secret(12345, "luggage")</code> earlier, TypeScript will use the inferred type.
Otherwise, if a class type argument can’t be inferred from the arguments passed to its constructor, the type argument will default to <code>unknown</code>.</p>

<p>This <code>CurriedCallback</code> class declares a constructor that takes in a generic function.
If the generic function has a known type—such as from an explicit type argument type annotation—then the class instance’s <code>Input</code> type argument can be informed by it.
Otherwise, the class instance’s <code>Input</code> type argument will default to <code>unknown</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">CurriedCallback</code><code class="o">&lt;</code><code class="nx">Input</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="err">#</code><code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">Input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">callback</code><code class="o">:</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">Input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">callback</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">Input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Input:"</code><code class="p">,</code> <code class="nx">input</code><code class="p">);</code>
            <code class="nx">callback</code><code class="p">(</code><code class="nx">input</code><code class="p">);</code>
        <code class="p">};</code>
    <code class="p">}</code>

    <code class="nx">call</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">Input</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">callback</code><code class="p">(</code><code class="nx">input</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Type: CurriedCallback&lt;string&gt;</code>
<code class="k">new</code> <code class="nx">CurriedCallback</code><code class="p">((</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// Type: CurriedCallback&lt;unknown&gt;</code>
<code class="k">new</code> <code class="nx">CurriedCallback</code><code class="p">((</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
    <code class="c1">//                ~~~~~~</code>
    <code class="c1">// Error: Property 'length' does not exist on type 'unknown'.</code>
<code class="p">});</code></pre>

<p>Class instances may also avoid defaulting to <code>unknown</code> by providing explicit type argument(s) the same way other generic function calls do.</p>

<p>Here, <code>CurriedCallback</code> from before is now being provided with an explicit <code>string</code> for its <code>Input</code> type argument, so TypeScript can infer that the callback’s <code>Input</code> type parameter resolves <a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="explicit types" data-secondary-sortas="classes" data-startref="generic-class-explicit" id="idm45584676762960"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="explicit types" data-startref="class-generic-explicit" id="idm45584676761168"/><a data-type="indexterm" data-primary="type arguments" data-secondary="for generic classes" data-tertiary="explicit types" data-secondary-sortas="generic classes" data-startref="type-argue-class-explicit" id="idm45584676759680"/><a data-type="indexterm" data-primary="explicit type arguments" data-secondary="for generic classes" data-secondary-sortas="generic classes" data-startref="type-argue-class-generic" id="idm45584676757952"/>to <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: CurriedCallback&lt;string&gt;</code>
<code class="k">new</code> <code class="nx">CurriedCallback</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">((</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
<code class="p">});</code>

<code class="k">new</code> <code class="nx">CurriedCallback</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">((</code><code class="nx">input</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">//                       ~~~~~~~~~~~~~~~~~~~~~~</code>
    <code class="c1">// Argument of type '(input: boolean) =&gt; void' is not</code>
    <code class="c1">// assignable to parameter of type '(input: string) =&gt; void'.</code>
    <code class="c1">//   Types of parameters 'input' and 'input' are incompatible.</code>
    <code class="c1">//     Type 'string' is not assignable to type 'boolean'.</code>
<code class="p">});</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Extending Generic Classes"><div class="sect2" id="idm45584676654320">
<h2>Extending Generic Classes</h2>

<p>Generic classes <a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="extending" data-secondary-sortas="classes" id="generic-class-extend"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="extending" id="class-generic-extend"/><a data-type="indexterm" data-primary="type arguments" data-secondary="for generic classes" data-tertiary="extending classes" data-secondary-sortas="generic classes" id="type-argue-class-extend"/><a data-type="indexterm" data-primary="extending" data-secondary="generic classes" id="extend-class-generic"/>can be used as the base class following an <code>extends</code> keyword.
TypeScript will not attempt to infer type arguments for the base class from usage.
Any type arguments without defaults will need to be specified using an explicit type annotation.</p>

<p>The following <code>SpokenQuote</code> class provides <code>string</code> as the <code>T</code> type argument for its base class <code>Quote&lt;T&gt;</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Quote</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">lines</code>: <code class="nx">T</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">lines</code>: <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">lines</code> <code class="o">=</code> <code class="nx">lines</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">SpokenQuote</code> <code class="kr">extends</code> <code class="nx">Quote</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">[]</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">speak() {</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">lines</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">));</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">Quote</code><code class="p">(</code><code class="s2">"The only real failure is the failure to try."</code><code class="p">).</code><code class="nx">lines</code><code class="p">;</code> <code class="c1">// Type: string</code>
<code class="k">new</code> <code class="nx">Quote</code><code class="p">([</code><code class="mi">4</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">]).</code><code class="nx">lines</code><code class="p">;</code> <code class="c1">// Type: number[]</code>

<code class="k">new</code> <code class="nx">SpokenQuote</code><code class="p">([</code>
    <code class="s2">"Greed is so destructive."</code><code class="p">,</code>
    <code class="s2">"It destroys everything"</code><code class="p">,</code>
<code class="p">]).</code><code class="nx">lines</code><code class="p">;</code> <code class="c1">// Type: string[]</code>

<code class="k">new</code> <code class="nx">SpokenQuote</code><code class="p">([</code><code class="mi">4</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">23</code><code class="p">,</code> <code class="mi">42</code><code class="p">]);</code>
<code class="c1">//              ~~~~~~~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Argument of type 'number' is not</code>
<code class="c1">// assignable to parameter of type 'string'.</code></pre>

<p>Generic derived classes can alternately pass their own type argument through to their base class.
The type names don’t have to match; just for fun, this <code>AttributedQuote</code> passes a differently named <code>Value</code> type argument to the base <a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="extending" data-secondary-sortas="classes" data-startref="generic-class-extend" id="idm45584676583232"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="extending" data-startref="class-generic-extend" id="idm45584676581504"/><a data-type="indexterm" data-primary="type arguments" data-secondary="for generic classes" data-tertiary="extending classes" data-secondary-sortas="generic classes" data-startref="type-argue-class-extend" id="idm45584676580016"/><a data-type="indexterm" data-primary="extending" data-secondary="generic classes" data-startref="extend-class-generic" id="idm45584676578256"/>class <code>Quote&lt;T&gt;</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">AttributedQuote</code><code class="o">&lt;</code><code class="nx">Value</code><code class="o">&gt;</code> <code class="kr">extends</code> <code class="nx">Quote</code><code class="o">&lt;</code><code class="nx">Value</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">speaker</code>: <code class="nx">string</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">Value</code><code class="p">,</code> <code class="nx">speaker</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="kr">super</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">speaker</code> <code class="o">=</code> <code class="nx">speaker</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Type: AttributedQuote&lt;string&gt;</code>
<code class="c1">// (extending Quote&lt;string&gt;)</code>
<code class="k">new</code> <code class="nx">AttributedQuote</code><code class="p">(</code>
    <code class="s2">"The road to success is always under construction."</code><code class="p">,</code>
    <code class="s2">"Lily Tomlin"</code><code class="p">,</code>
<code class="p">);</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Implementing Generic Interfaces"><div class="sect2" id="idm45584676458688">
<h2>Implementing Generic Interfaces</h2>

<p>Generic <a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="implementing interfaces" data-secondary-sortas="classes" id="idm45584676439680"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="implementing interfaces" id="idm45584676438192"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic classes" data-tertiary="implementing interfaces" data-secondary-sortas="generic classes" id="idm45584676436976"/><a data-type="indexterm" data-primary="generics" data-secondary="for interfaces" data-secondary-sortas="interfaces" id="idm45584676435488"/><a data-type="indexterm" data-primary="interfaces" data-secondary="generics for" id="idm45584676434272"/><a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for interfaces" data-tertiary-sortas="interfaces" id="idm45584676433328"/>classes may also implement generic interfaces by providing them any necessary type parameters.
This works similarly to extending a generic base class: any type parameters on the base interface must be declared by the class.</p>

<p>Here, the <code>MoviePart</code> class specifies the <code>ActingCredit</code> interface’s <code>Role</code> type argument as <code>string</code>.
The <code>IncorrectExtension</code> class causes a type complaint because its <code>role</code> is type <code>boolean</code> despite it providing <code>string[]</code> as a type argument to <code>ActingCredit</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">ActingCredit</code><code class="o">&lt;</code><code class="nx">Role</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">role</code>: <code class="nx">Role</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">MoviePart</code> <code class="kr">implements</code> <code class="nx">ActingCredit</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">role</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">speaking</code>: <code class="nx">boolean</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">role</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">speaking</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">role</code> <code class="o">=</code> <code class="nx">role</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">speaking</code> <code class="o">=</code> <code class="nx">speaking</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">part</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MoviePart</code><code class="p">(</code><code class="s2">"Miranda Priestly"</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code>

<code class="nx">part</code><code class="p">.</code><code class="nx">role</code><code class="p">;</code> <code class="c1">// Type: string</code>

<code class="kr">class</code> <code class="nx">IncorrectExtension</code> <code class="kr">implements</code> <code class="nx">ActingCredit</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">role</code>: <code class="nx">boolean</code><code class="p">;</code>
    <code class="c1">//    ~~~~~~~</code>
    <code class="c1">// Error: Property 'role' in type 'IncorrectExtension' is not</code>
    <code class="c1">// assignable to the same property in base type 'ActingCredit&lt;string&gt;'.</code>
    <code class="c1">//   Type 'boolean' is not assignable to type 'string'.</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Method Generics"><div class="sect2" id="idm45584676317936">
<h2>Method Generics</h2>

<p>Class methods <a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="method generics" data-secondary-sortas="classes" id="idm45584676289568"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="method generics" id="idm45584676288048"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic classes" data-tertiary="method generics" data-secondary-sortas="generic classes" id="idm45584676286832"/><a data-type="indexterm" data-primary="methods" data-secondary="generics for" id="idm45584676285344"/>may declare their own generic types separate from their class instance.
Each call to a generic class method may have a different type argument for each of its type parameters.</p>

<p>This generic <code>CreatePairFactory</code> class declares a <code>Key</code> type and includes a <code>createPair</code> method that also declares a separate <code>Value</code> generic type.
The return type for <code>createPair</code> is then inferred to be <code>{ key: Key, value: Value }</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">CreatePairFactory</code><code class="o">&lt;</code><code class="nx">Key</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">Key</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">key</code>: <code class="nx">Key</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">key</code> <code class="o">=</code> <code class="nx">key</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">createPair</code><code class="o">&lt;</code><code class="nx">Value</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">Value</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">return</code> <code class="p">{</code> <code class="nx">key</code>: <code class="nx">this.key</code><code class="p">,</code> <code class="nx">value</code> <code class="p">};</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Type: CreatePairFactory&lt;string&gt;</code>
<code class="kr">const</code> <code class="nx">factory</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">CreatePairFactory</code><code class="p">(</code><code class="s2">"role"</code><code class="p">);</code>

<code class="c1">// Type: { key: string, value: number }</code>
<code class="kr">const</code> <code class="nx">numberPair</code> <code class="o">=</code> <code class="nx">factory</code><code class="p">.</code><code class="nx">createPair</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>

<code class="c1">// Type: { key: string, value: string }</code>
<code class="kr">const</code> <code class="nx">stringPair</code> <code class="o">=</code> <code class="nx">factory</code><code class="p">.</code><code class="nx">createPair</code><code class="p">(</code><code class="s2">"Sophie"</code><code class="p">);</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Static Class Generics"><div class="sect2" id="idm45584676238992">
<h2>Static Class Generics</h2>

<p>Static members <a data-type="indexterm" data-primary="generics" data-secondary="for classes" data-tertiary="static class generics" data-secondary-sortas="classes" id="idm45584676210368"/><a data-type="indexterm" data-primary="classes" data-secondary="generics for" data-tertiary="static class generics" id="idm45584676208816"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic classes" data-tertiary="static class generics" data-secondary-sortas="generic classes" id="idm45584676207600"/><a data-type="indexterm" data-primary="static class generics" id="idm45584676206112"/>of a class are separate from instance members and aren’t associated with any particular instance of the class.
They don’t have access to any class instances or type information specific to any class instances.
As a result, while static class methods can declare their own type parameters, they can’t access any type parameters declared on a class.</p>

<p>Here, a <code>BothLogger</code> class declares an <code>OnInstance</code> type parameter for its <code>instanceLog</code> method and a separate <code>OnStatic</code> type parameter for its static <code>staticLog</code> method.
The static method is not able to access the instance <code>OnInstance</code> because <code>OnInstance</code> is declared for class <a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for classes" data-tertiary-sortas="classes" data-startref="type-generic-class" id="idm45584676135200"/>instances:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">BothLogger</code><code class="o">&lt;</code><code class="nx">OnInstance</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">instanceLog</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">OnInstance</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
        <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="kr">static</code> <code class="nx">staticLog</code><code class="o">&lt;</code><code class="nx">OnStatic</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">OnStatic</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">fromInstance</code>: <code class="nx">OnInstance</code><code class="p">;</code>
        <code class="c1">//                ~~~~~~~~~~</code>
        <code class="c1">// Error: Static members cannot reference class type arguments.</code>

        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
        <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">logger</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">BothLogger</code><code class="o">&lt;</code><code class="kt">number</code><code class="p">[]</code><code class="o">&gt;</code><code class="p">;</code>
<code class="nx">logger</code><code class="p">.</code><code class="nx">instanceLog</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]);</code> <code class="c1">// Type: number[]</code>

<code class="c1">// Inferred OnStatic type argument: boolean[]</code>
<code class="nx">BothLogger</code><code class="p">.</code><code class="nx">staticLog</code><code class="p">([</code><code class="kc">false</code><code class="p">,</code> <code class="kc">true</code><code class="p">]);</code>

<code class="c1">// Explicit OnStatic type argument: string</code>
<code class="nx">BothLogger</code><code class="p">.</code><code class="nx">staticLog</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="s2">"You can't change the music of your soul."</code><code class="p">);</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Generic Type Aliases"><div class="sect1" id="idm45584677037968">
<h1>Generic Type Aliases</h1>

<p>One <a data-type="indexterm" data-primary="generics" data-secondary="for type aliases" data-secondary-sortas="type aliases" id="idm45584676081776"/><a data-type="indexterm" data-primary="type aliases" data-secondary="generics for" id="idm45584676080496"/><a data-type="indexterm" data-primary="type arguments" data-secondary="for generic type aliases" data-secondary-sortas="generic type aliases" id="idm45584676079552"/><a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for type aliases" data-tertiary-sortas="type aliases" id="idm45584676078368"/>last construct in TypeScript that can be made generic with type arguments is type aliases.
Each type alias may be given any number of type parameters, such as this <code>Nullish</code> type receiving a <code>T</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Nullish</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code><code class="o"> | </code><code class="nx">null</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code></pre>

<p>Generic type aliases are commonly used with functions to describe the type of a generic function:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">CreatesValue</code><code class="o">&lt;</code><code class="nx">Input</code><code class="p">,</code> <code class="nx">Output</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">Input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">Output</code><code class="p">;</code>

<code class="c1">// Type: (input: string) =&gt; number</code>
<code class="kd">let</code> <code class="nx">creator</code>: <code class="nx">CreatesValue</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">;</code>

<code class="nx">creator</code> <code class="o">=</code> <code class="nx">text</code> <code class="o">=&gt;</code> <code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">creator</code> <code class="o">=</code> <code class="nx">text</code> <code class="o">=&gt;</code> <code class="nx">text</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
<code class="c1">//                ~~~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Type 'string' is not assignable to type 'number'.</code></pre>








<section data-type="sect2" data-pdf-bookmark="Generic Discriminated Unions"><div class="sect2" id="idm45584675959808">
<h2>Generic Discriminated Unions</h2>

<p>I <a data-type="indexterm" data-primary="generics" data-secondary="for discriminated unions" data-secondary-sortas="discriminated unions" id="generic-discriminated-unions"/><a data-type="indexterm" data-primary="discriminated unions" data-secondary="generics for" id="discriminated-unions-generic"/><a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="for discriminated unions" data-tertiary-sortas="discriminated unions" id="type-generic-discriminated-unions"/><a data-type="indexterm" data-primary="type arguments" data-secondary="for generic discriminated unions" data-secondary-sortas="generic discriminated unions" id="type-argue-discriminated-unions"/><a data-type="indexterm" data-primary="unions" data-secondary="discriminated unions" id="union-discriminated-generic"/>mentioned back in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.xhtml#objects">Chapter 4, “Objects”</a> that discriminated unions are my favorite feature in all of TypeScript because they beautifully combine a common elegant JavaScript pattern with TypeScript’s type narrowing.
My favorite use for discriminated unions is to add a type argument to create a generic “result” type that represents either a successful result with data or a failure with an error.</p>

<p>This <code>Result</code> generic type features a <code>succeeded</code> discriminant that must be used to narrow a result to whether it’s a success or failure.
This means any operation that returns a <code>Result</code> can indicate an error or data result, and be assured that consumers will need to check whether the result succeeded:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Result</code><code class="o">&lt;</code><code class="nx">Data</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">FailureResult</code> <code class="o">|</code> <code class="nx">SuccessfulResult</code><code class="o">&lt;</code><code class="nx">Data</code><code class="o">&gt;</code><code class="p">;</code>

<code class="kr">interface</code> <code class="nx">FailureResult</code> <code class="p">{</code>
    <code class="nx">error</code>: <code class="nx">Error</code><code class="p">;</code>
    <code class="nx">succeeded</code>: <code class="nx">false</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">SuccessfulResult</code><code class="o">&lt;</code><code class="nx">Data</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">data</code>: <code class="nx">Data</code><code class="p">;</code>
    <code class="nx">succeeded</code>: <code class="nx">true</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">handleResult</code><code class="p">(</code><code class="nx">result</code>: <code class="nx">Result</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">result</code><code class="p">.</code><code class="nx">succeeded</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// Type of result: SuccessfulResult&lt;string&gt;</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`We did it! </code><code class="si">${</code><code class="nx">result</code><code class="p">.</code><code class="nx">data</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="c1">// Type of result: FailureResult</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="sb">`Awww... </code><code class="si">${</code><code class="nx">result</code><code class="p">.</code><code class="nx">error</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="p">}</code>

    <code class="nx">result</code><code class="p">.</code><code class="nx">data</code><code class="p">;</code>
    <code class="c1">//     ~~~~</code>
    <code class="c1">// Error: Property 'data' does not exist on type 'Result&lt;string&gt;'.</code>
    <code class="c1">//   Property 'data' does not exist on type 'FailureResult'.</code>
<code class="p">}</code></pre>

<p>Put together, generic types and discriminated types provide a wonderful way to model reusable types like <code>Result</code>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Generic Modifiers"><div class="sect1" id="idm45584675865888">
<h1>Generic Modifiers</h1>

<p>TypeScript includes syntax that allows you to modify the behavior of generic type parameters.</p>








<section data-type="sect2" data-pdf-bookmark="Generic Defaults"><div class="sect2" id="idm45584675815136">
<h2>Generic Defaults</h2>

<p>I <a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="defaults" id="type-generic-default"/><a data-type="indexterm" data-primary="generics" data-secondary="defaults" id="generic-default"/><a data-type="indexterm" data-primary="default generics" id="default-generic"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic defaults" data-secondary-sortas="generic defaults" id="type-argue-generic-default"/>have stated so far that if a generic type is used in a type annotation or as the base of a class <code>extends</code> or <code>implements</code>, it must provide a type argument for each type parameter.
You can get around explicitly providing type arguments by placing an <code>=</code> sign followed by a default type after the type parameter’s declaration.
The default will be used in any subsequent type where the type argument isn’t explicitly declared and can’t be inferred.</p>

<p>Here, the <code>Quote</code> interface takes in a <code>T</code> type parameter that defaults to <code>string</code> if not provided.
The <code>explicit</code> variable explicitly sets <code>T</code> to <code>number</code> while <code>implicit</code> and <code>mismatch</code> both resolve to <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Quote</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">value</code>: <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">explicit</code>: <code class="nx">Quote</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">value</code>: <code class="nx">123</code> <code class="p">};</code>

<code class="kd">let</code> <code class="nx">implicit</code>: <code class="nx">Quote</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="s2">"Be yourself. The world worships the original."</code> <code class="p">};</code>

<code class="kd">let</code> <code class="nx">mismatch</code>: <code class="nx">Quote</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">value</code>: <code class="nx">123</code> <code class="p">};</code>
<code class="c1">//                                     ~~~</code>
<code class="c1">// Error: Type 'number' is not assignable to type 'string'.</code></pre>

<p>Type parameters can default to earlier type parameters in the same declaration too.
Since each type parameter introduces a new type for the declaration, they are available as defaults for later type parameters in that declaration.</p>

<p>This <code>KeyValuePair</code> type can have different types for its <code>Key</code> and <code>Value</code> generics but defaults to keeping them the same—though because <code>Key</code> doesn’t have a default, it does still need to be inferrable or provided:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">KeyValuePair</code><code class="o">&lt;</code><code class="nx">Key</code><code class="p">,</code> <code class="nx">Value</code> <code class="o">=</code> <code class="nx">Key</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">Key</code><code class="p">;</code>
    <code class="nx">value</code>: <code class="nx">Value</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Type: KeyValuePair&lt;string, string&gt;</code>
<code class="kd">let</code> <code class="nx">allExplicit</code>: <code class="nx">KeyValuePair</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">key</code><code class="o">:</code> <code class="s2">"rating"</code><code class="p">,</code>
    <code class="nx">value</code>: <code class="nx">10</code><code class="p">,</code>
<code class="p">};</code>

<code class="c1">// Type: KeyValuePair&lt;string&gt;</code>
<code class="kd">let</code> <code class="nx">oneDefaulting</code>: <code class="nx">KeyValuePair</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">key</code><code class="o">:</code> <code class="s2">"rating"</code><code class="p">,</code>
    <code class="nx">value</code><code class="o">:</code> <code class="s2">"ten"</code><code class="p">,</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">firstMissing</code>: <code class="nx">KeyValuePair</code> <code class="o">=</code> <code class="p">{</code>
    <code class="c1">//            ~~~~~~~~~~~~</code>
    <code class="c1">// Error: Generic type 'KeyValuePair&lt;Key, Value&gt;'</code>
    <code class="c1">// requires between 1 and 2 type arguments.</code>
    <code class="nx">key</code><code class="o">:</code> <code class="s2">"rating"</code><code class="p">,</code>
    <code class="nx">value</code>: <code class="nx">10</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>Keep in mind that all default type parameters must come last in their declaration list, similar to default function parameters.
Generic types without a default may not follow generic types with a default.</p>

<p>Here, <code>inTheEnd</code> is allowed because all generic types without defaults come before generic types with defaults.
<code>inTheMiddle</code> is a problem because a generic type without a default follows types with <a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="defaults" data-startref="type-generic-default" id="idm45584675589744"/><a data-type="indexterm" data-primary="generics" data-secondary="defaults" data-startref="generic-default" id="idm45584675588288"/><a data-type="indexterm" data-primary="default generics" data-startref="default-generic" id="idm45584675587072"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for generic defaults" data-secondary-sortas="generic defaults" data-startref="type-argue-generic-default" id="idm45584675586128"/>defaults:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">inTheEnd</code><code class="o">&lt;</code><code class="nx">First</code><code class="p">,</code> <code class="nx">Second</code><code class="p">,</code> <code class="nx">Third</code> <code class="o">=</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">Fourth</code> <code class="o">=</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">()</code> <code class="p">{}</code> <code class="c1">// Ok</code>

<code class="kd">function</code> <code class="nx">inTheMiddle</code><code class="o">&lt;</code><code class="nx">First</code><code class="p">,</code> <code class="nx">Second</code> <code class="o">=</code> <code class="kr">boolean</code><code class="p">,</code> <code class="nx">Third</code> <code class="o">=</code> <code class="kt">number</code><code class="p">,</code> <code class="nx">Fourth</code><code class="o">&gt;</code><code class="p">()</code> <code class="p">{}</code>
<code class="c1">//                                                         // ~~~~~~</code>
<code class="c1">// Error: Required type parameters may not follow optional type parameters.</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Constrained Generic Types"><div class="sect1" id="idm45584675505824">
<h1>Constrained Generic Types</h1>

<p>Generic<a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="constrained" id="type-generic-constrain"/><a data-type="indexterm" data-primary="generics" data-secondary="constrained" id="generic-constrain"/><a data-type="indexterm" data-primary="constrained generics" id="constrain-generic"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for constrained generics" data-secondary-sortas="constrained generics" id="type-argue-constrain"/> types by default can be given any type in the world: classes, interfaces, primitives, unions, you name it.
However, some functions are only meant to work with a limited set of types.</p>

<p>TypeScript allows for a type parameter to declare itself as needing to <em>extend</em> a type: meaning it’s only allowed to alias types that are assignable to that type.
The syntax to constrain a type parameter is to place the <code>extends</code> keyword after the type parameter’s name, followed by a type to constrain it to.</p>

<p>For example, by creating a <code>WithLength</code> interface to describe anything that has a <code>length: number</code>, we can then allow our generic function to take in any type that has a <code>length</code> for its <code>T</code> generic.
Strings, arrays, and now even objects that just so happen to have a <code>length: number</code> are allowed, while type shapes such as <code>Date</code> missing that numeric <code>length</code> result in a type error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">WithLength</code> <code class="p">{</code>
    <code class="nx">length</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logWithLength</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">WithLength</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Length: </code><code class="si">${</code><code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
    <code class="k">return</code> <code class="nx">input</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">logWithLength</code><code class="p">(</code><code class="s2">"No one can figure out your worth but you."</code><code class="p">);</code> <code class="c1">// Type: string</code>
<code class="nx">logWithLength</code><code class="p">([</code><code class="kc">false</code><code class="p">,</code> <code class="kc">true</code><code class="p">]);</code> <code class="c1">// Type: boolean[]</code>
<code class="nx">logWithLength</code><code class="p">({</code> <code class="nx">length</code>: <code class="nx">123</code> <code class="p">});</code> <code class="c1">// Type: { length: number }</code>

<code class="nx">logWithLength</code><code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">());</code>
<code class="c1">//            ~~~~~~~~~~</code>
<code class="c1">// Error: Argument of type 'Date' is not</code>
<code class="c1">// assignable to parameter of type 'WithLength'.</code>
<code class="c1">//   Property 'length' is missing in type</code>
<code class="c1">//   'Date' but required in type 'WithLength'.</code></pre>

<p>I’ll cover more type operations you can perform with generics in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch15.xhtml#type_operations">Chapter 15, “Type Operations”</a>.</p>








<section data-type="sect2" data-pdf-bookmark="keyof and Constrained Type Parameters"><div class="sect2" id="idm45584675389264">
<h2>keyof and Constrained Type Parameters</h2>

<p>The <code>keyof</code> operator<a data-type="indexterm" data-primary="keyof type operator" data-secondary="constrained type parameters" id="idm45584675387024"/> introduced in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch09.xhtml#type_modifiers_chapter">Chapter 9, “Type Modifiers”</a> also works well with constrained type parameters.
Using <code>extends</code> and <code>keyof</code> together allows a type parameter to be constrained to the keys of a previous type parameter.
It is also the only way to specify the key of a generic type.</p>

<p>Take this simplified version of the <code>get</code> method from the popular library Lodash.
It takes in a container value, typed as <code>T</code>, and a <code>key</code> name of one of the keys of <code>T</code> to retrieve from <code>container</code>.
Because the <code>Key</code> type parameter is constrained to be a <code>keyof T</code>, TypeScript knows this function is allowed to return <code>T[Key]</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">Key</code> <code class="kr">extends</code> <code class="nx">keyof</code> <code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">container</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">key</code>: <code class="nx">Key</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">container</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">roles</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">favorite</code><code class="o">:</code> <code class="s2">"Fargo"</code><code class="p">,</code>
    <code class="nx">others</code><code class="o">:</code> <code class="p">[</code><code class="s2">"Almost Famous"</code><code class="p">,</code> <code class="s2">"Burn After Reading"</code><code class="p">,</code> <code class="s2">"Nomadland"</code><code class="p">],</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">favorite</code> <code class="o">=</code> <code class="nx">get</code><code class="p">(</code><code class="nx">roles</code><code class="p">,</code> <code class="s2">"favorite"</code><code class="p">);</code> <code class="c1">// Type: string</code>
<code class="kr">const</code> <code class="nx">others</code> <code class="o">=</code> <code class="nx">get</code><code class="p">(</code><code class="nx">roles</code><code class="p">,</code> <code class="s2">"others"</code><code class="p">);</code> <code class="c1">// Type: string[]</code>

<code class="kr">const</code> <code class="nx">missing</code> <code class="o">=</code> <code class="nx">get</code><code class="p">(</code><code class="nx">roles</code><code class="p">,</code> <code class="s2">"extras"</code><code class="p">);</code>
<code class="c1">//                         ~~~~~~~~</code>
<code class="c1">// Error: Argument of type '"extras"' is not assignable</code>
<code class="c1">// to parameter of type '"favorite" | "others"'.</code></pre>

<p>Without <code>keyof</code>, there would have been no way to correctly type the generic <code>key</code> parameter.</p>

<p>Note the importance of the <code>Key</code> type parameter in the previous example.
If only <code>T</code> is provided as a type parameter, and the <code>key</code> parameter is allowed to be any <code>keyof T</code>, then the return type will be the union type of all property values in <code>Container</code>.
This less-specific function declaration doesn’t indicate to TypeScript that each call can have a specific <code>key</code> via a type<a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="constrained" data-startref="type-generic-constrain" id="idm45584675267040"/><a data-type="indexterm" data-primary="generics" data-secondary="constrained" data-startref="generic-constrain" id="idm45584675265488"/><a data-type="indexterm" data-primary="constrained generics" data-startref="constrain-generic" id="idm45584675264272"/><a data-type="indexterm" data-primary="type parameters" data-secondary="for constrained generics" data-secondary-sortas="constrained generics" data-startref="type-argue-constrain" id="idm45584675193984"/> argument:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">get</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">container</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">key</code>: <code class="nx">keyof</code> <code class="nx">T</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">container</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">roles</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">favorite</code><code class="o">:</code> <code class="s2">"Fargo"</code><code class="p">,</code>
    <code class="nx">others</code><code class="o">:</code> <code class="p">[</code><code class="s2">"Almost Famous"</code><code class="p">,</code> <code class="s2">"Burn After Reading"</code><code class="p">,</code> <code class="s2">"Nomadland"</code><code class="p">],</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">found</code> <code class="o">=</code> <code class="nx">get</code><code class="p">(</code><code class="nx">roles</code><code class="p">,</code> <code class="s2">"favorite"</code><code class="p">);</code> <code class="c1">// Type: string | string[]</code></pre>

<p>Be sure when writing generic functions to know when a parameter’s type depends on a previous parameter’s type.
You’ll often need to use constrained type parameters for correct parameter types in those cases.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Promises"><div class="sect1" id="idm45584675108064">
<h1>Promises</h1>

<p>Now that<a data-type="indexterm" data-primary="Promises" data-secondary="purpose of" id="idm45584675150528"/> you’ve seen how generics work, it’s finally time to talk about a core feature of modern JavaScript that relies on their concepts: Promises!
To recap, a Promise in JavaScript represents something that might still be pending, such as a network request.
Each Promise provides methods to register callbacks in case the pending action “resolves” (completes successfully) or “rejects” (throws an error).</p>

<p>A Promise’s ability to represent similar actions on any arbitrary value types is a natural fit for TypeScript’s generics.
Promises are represented in the TypeScript type system as a <code>Promise</code> class with a single type parameter representing the eventual resolved value.</p>








<section data-type="sect2" data-pdf-bookmark="Creating Promises"><div class="sect2" id="idm45584675148464">
<h2>Creating Promises</h2>

<p>The<a data-type="indexterm" data-primary="Promises" data-secondary="creating" id="promise-create"/> <code>Promise</code> constructor is typed in TypeScript as taking in a single parameter.
That parameter’s type relies on a type parameter declared on the generic <code>Promise</code> class.
A reduced form would look roughly like this:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">PromiseLike</code><code class="o">&lt;</code><code class="nx">Value</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="kr">constructor</code><code class="p">(</code>
        <code class="nx">executor</code><code class="o">:</code> <code class="p">(</code>
            <code class="nx">resolve</code><code class="o">:</code> <code class="p">(</code><code class="nx">value</code>: <code class="nx">Value</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">,</code>
            <code class="nx">reject</code><code class="o">:</code> <code class="p">(</code><code class="nx">reason</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">,</code>
        <code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">,</code>
    <code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>Creating a Promise intended to eventually resolve with a value generally necessitates explicitly declaring the type argument of the Promise.
TypeScript would default to assuming the parameter type is <code>unknown</code> without that explicit generic type argument.
Explicitly providing a type argument to the <code>Promise</code> constructor would allow TypeScript to understand the resultant Promise instance’s resolved type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: Promise&lt;unknown&gt;</code>
<code class="kr">const</code> <code class="nx">resolvesUnknown</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">resolve</code><code class="p">(</code><code class="s2">"Done!"</code><code class="p">),</code> <code class="mi">1000</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// Type: Promise&lt;string&gt;</code>
<code class="kr">const</code> <code class="nx">resolvesString</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">((</code><code class="nx">resolve</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">resolve</code><code class="p">(</code><code class="s2">"Done!"</code><code class="p">),</code> <code class="mi">1000</code><code class="p">);</code>
<code class="p">});</code></pre>

<p>A Promise’s generic <code>.then</code> method introduces a new type parameter representing the resolved value of the Promise it returns.</p>

<p>For example, the following code creates a <code>textEventually</code> Promise that resolves with a <code>string</code> value after a second, as well as a <code>lengthEventually</code> that waits an additional second to resolve with<a data-type="indexterm" data-primary="Promises" data-secondary="creating" data-startref="promise-create" id="idm45584674990544"/> a <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: Promise&lt;string&gt;</code>
<code class="kr">const</code> <code class="nx">textEventually</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">((</code><code class="nx">resolve</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">resolve</code><code class="p">(</code><code class="s2">"Done!"</code><code class="p">),</code> <code class="mi">1000</code><code class="p">);</code>
<code class="p">});</code>

<code class="c1">// Type: Promise&lt;number&gt;</code>
<code class="kr">const</code> <code class="nx">lengthEventually</code> <code class="o">=</code> <code class="nx">textEventually</code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">text</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Async Functions"><div class="sect2" id="idm45584674929648">
<h2>Async Functions</h2>

<p>Any<a data-type="indexterm" data-primary="Promises" data-secondary="async functions and" id="idm45584674912560"/><a data-type="indexterm" data-primary="async functions, Promises and" id="idm45584674911168"/><a data-type="indexterm" data-primary="functions" data-secondary="async, Promises and" id="idm45584674910528"/> function declared in JavaScript with the <code>async</code> keyword returns a <code>Promise</code>.
If a value returned by an <code>async</code> function in JavaScript isn’t a Thenable<a data-type="indexterm" data-primary="Thenable" id="idm45584674908208"/> (an object with a <code>.then()</code> method; in practice almost always a Promise), it will be wrapped in a <code>Promise</code> as if <code>Promise.resolve</code> was called on it.
TypeScript recognizes this and will infer the return type of an <code>async</code> function to always be a <code>Promise</code> for whatever value is returned.</p>

<p>Here, <code>lengthAfterSecond</code> returns a <code>Promise&lt;number&gt;</code> directly, while 
<span class="keep-together"><code>lengthImmediately</code></span> is inferred to return a <code>Promise&lt;number&gt;</code> because it is <code>async</code> and directly returns a <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: (text: string) =&gt; Promise&lt;number&gt;</code>
<code class="kr">async</code> <code class="kd">function</code> <code class="nx">lengthAfterSecond</code><code class="p">(</code><code class="nx">text</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">await</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="mi">1000</code><code class="p">))</code>
    <code class="k">return</code> <code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Type: (text: string) =&gt; Promise&lt;number&gt;</code>
<code class="kr">async</code> <code class="kd">function</code> <code class="nx">lengthImmediately</code><code class="p">(</code><code class="nx">text</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Any manually declared return type on an <code>async</code> function therefore must always be a <code>Promise</code> type, even if the function doesn’t explicitly mention Promises in its implementation:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Ok</code>
<code class="kr">async</code> <code class="kd">function</code> <code class="nx">givesPromiseForString</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s2">"Done!"</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">async</code> <code class="kd">function</code> <code class="nx">givesString</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>
    <code class="c1">//                        ~~~~~~</code>
    <code class="c1">// Error: The return type of an async function</code>
    <code class="c1">// or method must be the global Promise&lt;T&gt; type.</code>
    <code class="k">return</code> <code class="s2">"Done!"</code><code class="p">;</code>
<code class="p">}</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Using Generics Right"><div class="sect1" id="idm45584674773184">
<h1>Using Generics Right</h1>

<p>As in <a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="when to use" id="type-generic-usage-golden"/><a data-type="indexterm" data-primary="generics" data-secondary="when to use" id="generic-usage-golden"/>the <code>Promise&lt;Value&gt;</code> implementations earlier in this chapter, although generics can give us a lot of flexibility in describing types in code, they can become rather complex quite quickly.
Programmers new to TypeScript often go through a phase of overusing generics to the point of making code confusing to read and overly complex to work with.
TypeScript best practice is generally to use generics only when necessary, and to be clear about what they’re used for when they are.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Most code you write in TypeScript should not heavily use generics to the point of confusion.
However, types for utility libraries, particularly general-use modules, may sometimes need to heavily use them.
Understanding generics is particularly useful to be able to work effectively with those utility types.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="The Golden Rule of Generics"><div class="sect2" id="idm45584674761344">
<h2>The Golden Rule of Generics</h2>

<p>One quick test that can help show whether a type parameter is necessary for a function is it should be used at least twice.
Generics describe relationships between types, so if a generic type parameter only appears in one place, it can’t possibly be defining a relationship between multiple types.</p>

<p>Each function type parameter should be used for a parameter and then also for at least one other parameter and/or the return type of the function.</p>

<p>For example, this <code>logInput</code> function uses its <code>Input</code> type parameter exactly once, to declare its <code>input</code> parameter:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">logInput</code><code class="o">&lt;</code><code class="nx">Input</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">Input</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hi!"</code><code class="p">,</code> <code class="nx">input</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Unlike the <code>identify</code> functions earlier in the chapter, <code>logInput</code> doesn’t do anything with its type parameter such as returning or declaring more parameters.
There is therefore not much use to declaring that <code>Input</code> type parameter.
We can rewrite <code>logInput</code> without it:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">logInput</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hi!"</code><code class="p">,</code> <code class="nx">input</code><code class="p">);</code>
<code class="p">}</code></pre>

<p><em>Effective TypeScript</em> by Dan Vanderkam (O’Reilly, 2019) contains several excellent tips for how to work with generics, including a section titled “The Golden Rule of Generics.”
I highly recommend reading <em>Effective TypeScript</em> and that section especially if you’re finding yourself spending a lot of time wrestling with generics in your <a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="when to use" data-startref="type-generic-usage-golden" id="idm45584674649952"/><a data-type="indexterm" data-primary="generics" data-secondary="when to use" data-startref="generic-usage-golden" id="idm45584674648560"/>code.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Generic Naming Conventions"><div class="sect2" id="idm45584674647088">
<h2>Generic Naming Conventions</h2>

<p>The <a data-type="indexterm" data-primary="types" data-secondary="generics" data-tertiary="naming conventions" id="idm45584674645552"/><a data-type="indexterm" data-primary="generics" data-secondary="naming conventions" id="idm45584674644272"/><a data-type="indexterm" data-primary="naming conventions" data-secondary="for generics" data-secondary-sortas="generics" id="idm45584674643328"/>standard naming convention for type parameters in many languages, TypeScript included, is to default to calling a first type argument “T” (for “type” or “template”) and if subsequent type parameters exist, calling them “U,” “V,” and so on.</p>

<p>If some contextual information is known about how the type argument is supposed to be used, the convention sometimes extends to using the first letter of the term for that usage: for example, state management libraries might refer to a generic state as “S.”
“K” and “V” often refer to keys and values in data structures.</p>

<p>Unfortunately, naming a type argument with one letter can be just as confusing as naming a function or variable with just one character:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// What on earth are L and V?!</code>
<code class="kd">function</code> <code class="nx">labelBox</code><code class="o">&lt;</code><code class="nx">L</code><code class="p">,</code> <code class="nx">V</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">l</code>: <code class="nx">L</code><code class="p">,</code> <code class="nx">v</code>: <code class="nx">V</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code></pre>

<p>When the intent of a generic isn’t clear from a single-letter <code>T</code>, it’s best to use descriptive generic type names that indicate what the type is used for:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Much more clear.</code>
<code class="kd">function</code> <code class="nx">labelBox</code><code class="o">&lt;</code><code class="nx">Label</code><code class="p">,</code> <code class="nx">Value</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">label</code>: <code class="nx">Label</code><code class="p">,</code> <code class="nx">value</code>: <code class="nx">Value</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code></pre>

<p>Whenever a construct has multiple type parameters, or the purpose of a single type argument isn’t immediately clear, consider using fully written names for readability instead of single-letter abbreviations.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584674591920">
<h1>Summary</h1>

<p>In this chapter, you made classes, functions, interfaces, and type aliases “generic” by allowing them to work with type parameters:</p>

<ul>
<li>
<p>Using type parameters to represent types different between uses of a construct</p>
</li>
<li>
<p>Providing explicit or implicit type arguments when calling generic functions</p>
</li>
<li>
<p>Using generic interfaces to represent generic object types</p>
</li>
<li>
<p>Adding type parameters to classes, and how that impacts their types</p>
</li>
<li>
<p>Adding type parameters to type aliases, in particular with discriminated type unions</p>
</li>
<li>
<p>Modifying generic type parameters with defaults (<code>=</code>) and constraints (<code>extends</code>)</p>
</li>
<li>
<p>How Promises and <code>async</code> functions use generics to represent asynchronous data flow</p>
</li>
<li>
<p>Best practices with generics, including their Golden Rule and naming 
<span class="keep-together">conventions</span></p>
</li>
</ul>

<p>Thus concludes the <em>Features</em> section of this book.
Congratulations: you now know all the most important syntax and type-checking features in the TypeScript type system for most projects!</p>

<p>The next section, <em>Usage</em>, covers how to configure TypeScript to run on your project, interact with external dependencies, and tweak its type checking and emitted JavaScript.
Those are important features for using TypeScript on your own projects.</p>

<p>There are some other miscellaneous type operations available in TypeScript syntax.
You don’t need to fully understand them to work in most TypeScript projects—but they are interesting and useful to know.
I’ve thrown them in <a data-type="xref" data-xrefstyle="part-num-title" href="part04.xhtml#extra_credit">Part IV, “Extra Credit”</a> after <a data-type="xref" data-xrefstyle="part-num-title" href="part03.xhtml#usage">Part III, “Usage”</a> as a fun little treat if you have the time.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/generics"><em class="hyperlink">https://learningtypescript.com/generics</em></a>.</p>
</div>
<blockquote class="joke">
<p>Why do generics anger developers?</p>

<p>They’re always typing arguments.</p></blockquote>
</div></section>







</div></section></div></body></html>