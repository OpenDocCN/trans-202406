- en: Chapter 4\. System Hardening
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The domain “system hardening” deals with security aspects relevant to the underlying
    host system running the Kubernetes cluster nodes. Topics discussed here touch
    on techniques and configuration options that are fundamentally Linux core functionality.
    This includes disabling services and removing packages, managing users and groups,
    disabling ports, and setting up firewall rules. Finally, this chapter discusses
    Linux kernel hardening tools that can restrict what operations a process running
    in a container can perform on a host level.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Minimizing the host OS footprint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing IAM roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing external access to the network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using kernel hardening tools like AppArmor and seccomp
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimizing the Host OS Footprint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cluster nodes run on physical or virtual machines. In most cases, the operating
    system on those machines is a Linux distribution. Evidently, the operating system
    can expose security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, you need to keep the version of the operating system up to date with
    the latest security fixes. This process could entail upgrading a node’s operating
    system from Ubuntu 18 to 22, for example. Upgrading the operating system is out
    of scope for this book; for more information, check the relevant Linux documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Many Linux distributions, such as Ubuntu, come with additional tools, applications,
    and services that are not necessarily required for operating the Kubernetes cluster.
    It is your job as an administrator to identify security risks, disable or remove
    any operating system-specific functionality that may expose vulnerabilities, and
    keep the operating system patched to incorporate the latest security fixes. The
    less functionality an operating system has, the smaller the risk.
  prefs: []
  type: TYPE_NORMAL
- en: CIS benchmark for Ubuntu Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a reference guide, you may want to compare your operating system’s configuration
    with the [CIS benchmark for Ubuntu Linux](https://oreil.ly/AeAAE).
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Exploits a Package Vulnerability'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Figure 4-1](#os-package-attacker) illustrates an attacker exploiting a vulnerability
    of a package installed on the system. For example, the application could be the
    package manager [snapd](https://oreil.ly/ZOFTj). Assume that the attacker takes
    advantage of the known vulnerability [USN-5292-1](https://oreil.ly/lw_MV) that
    has the potential of exposing sensitive information to an attacker.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0401](assets/ckss_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. An attacker exploits an OS-level vulnerability
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following section will explain how to minimize security risks for services
    and packages that are not really needed for operating Kubernetes by simply disabling
    or removing them.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On Linux, many applications run as services in the background. Services can
    be managed using the command line tool `systemctl`. The following `systemctl`
    command lists all running services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the services we will not need for operating a cluster node is the package
    manager snapd. For more details on the service, retrieve the status for it with
    the `status` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can stop service using the `systemctl` subcommand `stop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the `disable` subcommand to prevent the service from being started
    again upon a system restart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The service has now been stopped and disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Removing Unwanted Packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the service has been disabled, there’s no more point in keeping the
    package around. You can remove the package to free up additional disk space and
    memory. You can use the `apt purge` command to remove a package and its transitive
    packages, as demonstrated in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can use the same command even if the package isn’t controlled by a service.
    Identify the packages you don’t need and simply remove them. You should end up
    with a much slimmer footprint of your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A potential attacker cannot use the snapd service anymore to exploit the system.
    You should repeat the process for any unwanted services. As a result, the snapd
    service ceases to exist on the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Minimizing IAM Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Identity and access management (IAM) on the system level involves management
    of Linux users, the groups they belong to, and the permissions granted to them.
    Any directory and file will have file permissions assigned to a user.
  prefs: []
  type: TYPE_NORMAL
- en: Proper user and access management is a classic responsibility of every system
    administrator. While your role as a Kubernetes administrator may not directly
    involve system-level IAM, it’s important to understand the implications to security.
    You will likely have to work with a peer to harden the system running the Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This section will provide a short introduction on how to manage users and groups.
    We will also discuss how to set file permissions and ownership to minimize access
    as much as possible. We will only scratch the surface of the topic in this book.
    For more information, refer to the Linux documentation of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Uses Credentials to Gain File Access'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A security breach can lead to stolen user credentials. Gaining access to valid
    user credentials opens the door for additional attack vectors. [Figure 4-2](#iam-attacker)
    shows an attacker who could log into a cluster node with stolen user credentials
    and can now interact with all files and directories with the permissions granted
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0402](assets/ckss_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. An attacker uses stolen credentials to access files
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s recommended to follow the principle of least privilege. Only grant administrative
    permissions to a limited group of users. All other users should only be allowed
    to perform operations necessary to perform their jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding User Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every user must authenticate to a system to use it. The authenticated user has
    access to resources based on the assigned permissions. This section will walk
    you through the primary operations required to manage users.
  prefs: []
  type: TYPE_NORMAL
- en: Listing users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To list all users on the system, render the contents of the file `/etc/passwd`.
    Every entry follows the general pattern `username:password:UID:GID:com⁠ment:​home:shell`.
    Some of the fields within the pattern may be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The command output renders the user root in the first position of the output.
    The last portion of the string for the `root` user, `/bin/bash`, indicates that
    the user is allowed to log into the system with a `bash` shell. Other users might
    not be allowed to log in at all. For those users, you will find the string `/usr/sbin/nologin`
    assigned to the `shell` field.
  prefs: []
  type: TYPE_NORMAL
- en: 'At any given point of time, you can see which processes have been started by
    users. The following command shows all `bash` processes, including the corresponding
    user that started it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Adding a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At some point, you may want to give team members access to the machines running
    the cluster nodes, with limited permissions. You can add new users to the system
    with the `adduser` command. Add the flag `--shell /sbin/nologin` to disable shell
    access for the user. The following command creates the user `ben`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The user entry has been added to the file `/etc/passwd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Switching to a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can change the user in a shell by using the `su` command. The following
    command switches to the user `ben` we created earlier. You will be asked to enter
    the user’s password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The shell will indicate the current user by its prompt. You will inherit the
    environment variables from the account you used when running the `su` command.
    To create a new environment, add the hyphen with the `su` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to temporarily switch the user is by using the `sudo` command.
    You will need to have elevated privileges to execute the command. Therefore, the
    `sudo` command is equivalent to “run this command as administrator”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Team members, represented by users in the system, transition to other teams
    or may simply leave the company. You will want to revoke access to the user to
    prevent unauthorized use of the credentials. The following command deletes the
    user, including the user’s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Group Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s more convenient for a system administrator to group users with similar
    access requirements to control permissions on an individual user level. Linux
    systems offer the concept of a group as a way to organize users based on teams,
    or specific organizational roles. We’ll briefly touch on the most important aspects
    of group management.
  prefs: []
  type: TYPE_NORMAL
- en: Listing groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Groups can be listed by inspecting the contents of the file `/etc/group`. Every
    entry follows the general pattern `groupname:password:GID:group members`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the output, some of the fields may be empty. The only group
    with an assigned member is `plugdev`, whose name is `packer`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the command `groupadd` to add a new group. The following example adds the
    group `kube-developers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The group will now be listed in the file `/etc/group`. Notice that the group
    identifier is 1004:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Assigning a user to a group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To assign a group to a user, use the `usermod` command. The following command
    adds the user `ben` to the group `kube-developers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The group identifier 1004 acts as a stand-in for the group `kube-developers`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes you want to get rid of a group entirely. Maybe the organizational
    role referring to a Linux group that does not exist anymore. Use the `groupdel`
    command to delete a group. You will receive an error message if the members are
    still part of the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Before deleting a group, you should reassign group members to a different group
    using the `usermod` command. The following command changes the group from `kube-developers`
    to `kube-admins`. Assume that the group `kube-admins` has been created before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Understanding File Permissions and Ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assigning the file permissions with as minimal access as possible is crucial
    to maximizing security. This is where Linux file permissions and ownership come
    into play. I am only going to discuss the relevant operations on a high level.
    Refer to the [Linux Foundation’s blog post about Linux file permissions](https://oreil.ly/3IpRT)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing file permissions and ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every user can create new directories and files. For example, you could use
    the `touch` command to create an empty file. The following command creates a file
    with the name `my-file` in the current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the contents of a directory in the “long” format, use the `ls` command.
    The long format of the output requested by the `-l` command line parameter renders
    the file permissions and the file ownership:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The important portion of the output is `-rw-r--r--`. The first character is
    a special permission character that can vary per system, followed by three groupings
    with the notation `rwx`. The first three characters stand for the owner permissions,
    the second set of three characters is for the group permissions, and the last
    three characters represent the permissions for all users. The symbol `r` means
    read permissions, `w` stands for write permissions, and `x` refers to execution
    permissions. In the previous example, the user `root` can read and write the file,
    whereas the group and all other users can only read the file.
  prefs: []
  type: TYPE_NORMAL
- en: Changing file ownership
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the `chown` command to change the user and group assignment for a file
    or directory. The syntax of the command follows the pattern `chown owner:group
    filename`. The following command changes the ownership of the file to the user
    `ben` but does not reassign a group. The user executing the `chown` command needs
    to have write permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Changing file permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can add or remove permissions with the `chmod` command in a variety of
    notations. For example, use the following command to remove write permissions
    for the file owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Minimizing External Access to the Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: External access to your cluster nodes should only be allowed for the ports necessary
    to operate Kubernetes. We already discussed the standard Kubernetes ports in [“Protecting
    Node Metadata and Endpoints”](ch02.xhtml#node-metadata-endpoints). Access to all
    other ports should be blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying and Disabling Open Ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications like FTP servers, web servers, and file and print services such
    as Samba open ports as a means to expose a communication endpoint to clients.
    Running applications that open network communication can expose a security risk.
    You can eliminate the risk by simply disabling the service and deinstalling the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we [installed the Apache 2 HTTP web server](https://oreil.ly/t-np3)
    on a control plane node with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Update about netstat command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `netstat` command has been deprecated in favor of the faster, more human-readable
    `ss` command. For more information, refer to the documentation of the operating
    system you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect all open ports using the command line tool `ss`, a utility with
    similar functionality to `netstat`. The following command renders all of the open
    ports, including their processes. Among them is port 80, exposed by Apache 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have only needed the web server temporarily and may have simply forgotten
    about installing it. The process is currently managed by a server. You can review
    the status of a service with the `systemctl status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Apache 2 is not needed by Kubernetes. We decide to shut down the service and
    deinstall the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the port isn’t used anymore. The `ss` command doesn’t find an application
    exposing port 80 anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Setting Up Firewall Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another way to control ports is with the help of an operating-system-level firewall.
    On Linux, you could use the [Uncomplicated Firewall (UFW)](https://oreil.ly/iqiwv).
    This section will give you a very brief introduction on how to enable UFW and
    how to configure firewall rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the principle of least privilege, it’s a good idea to start by enabling
    the firewall and setting up deny rules for *any* incoming and outgoing network
    traffic. The following commands demonstrate the steps to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You will want to allow external tools like `kubectl` to connect to the API
    server running on port 6443\. On the control plane node, execute the following
    command to allow access to the API server port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You will have to repeat the same process to open up other ports on control plane
    and worker nodes. Ensure that all other ports not needed to operate Kubernetes
    are blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kernel Hardening Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications or processes running inside of a container can make system calls.
    A typical example could be the `curl` command performing an HTTP request. A system
    call is a programmatic abstraction running in the user space for requesting a
    service from the kernel. We can restrict which system calls are allowed to be
    made with the help of kernel hardening tools. The CKS exam explicitly mentions
    two tools in this space, AppArmor and seccomp. We’ll discuss both tools and the
    mechanics to integrate them with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Using AppArmor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[AppArmor](https://apparmor.net) provides access control to programs running
    on a Linux system. The tool implements an additional security layer between the
    applications invoked in the user space and the underlying system functionality.
    For example, we can restrict network calls or filesystem interaction. Many Linux
    distributions (e.g., Debian, Ubuntu, openSUSE) already ship with AppArmor. Therefore,
    AppArmor doesn’t have to be installed manually. Linux distributions that do not
    support AppArmor use [Security-Enhanced Linux (SELinux)](https://oreil.ly/CKBr7)
    instead, which takes a similar approach to AppArmor. Understanding SELinux is
    out of scope for the CKS exam.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding profiles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The rules that define what a program can or cannot do are defined in an AppArmor
    profile. Every profile needs to be loaded into AppArmor before it can take effect.
    AppArmor provides a command line tool for checking the profiles that have been
    loaded. Execute the command `aa-status` to see a summary of all loaded profiles.
    You will see that AppArmor already comes with a set of default application profiles
    to protect Linux services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The profile mode determines the treatment of rules at runtime should a matching
    event happen. AppArmor distinguishes two types of profile modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Enforce
  prefs: []
  type: TYPE_NORMAL
- en: The system enforces the rules, reports the violation, and writes it to the syslog.
    You will want to use this mode to prevent a program from making specific calls.
  prefs: []
  type: TYPE_NORMAL
- en: Complain
  prefs: []
  type: TYPE_NORMAL
- en: The system does not enforce the rules but will write violations to the log.
    This mode is helpful if you want to discover the calls a program makes.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-1](#apparmor-profile) defines a custom profile in the file `k8s-deny-write`
    for restricting file write access. The file should be placed in the directory
    `/etc/apparmor.d` of every worker node that executes workload. It is out of scope
    of this book to explain all the rules in detail. For more information, have a
    look at the [AppArmor wiki](https://oreil.ly/mNuWB).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. An AppArmor profile for restricting file write access
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_system_hardening_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The identifier after the `profile` keyword is the name of the profile.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_system_hardening_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Apply to file operations.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_system_hardening_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Deny all file writes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a custom profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To load the profile into AppArmor, run the following command on the worker
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The command uses the enforce mode by default. To load the profile in complain
    mode, use the `-C` option. The `aa-status` command will now list the profile in
    addition to the default profiles. As you can see in the output, the profile is
    listed in enforce mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'AppArmor supports additional convenience commands as part of a utilities package.
    You can manually install the package using the following commands if you want
    to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, you can use the command `aa-enforce` to load a profile in enforce
    mode, and `aa-complain` to load a profile in complain mode. For the exam, it’s
    likely easier to just go with the standard `apparmor_parser` command.
  prefs: []
  type: TYPE_NORMAL
- en: Applying a profile to a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to ensure a couple of prerequisites before using AppArmor rules in
    a Pod definition. First, the container runtime needs to support AppArmor to let
    rules take effect. In addition, AppArmor needs to be installed on the worker node
    that runs the Pod. Last, make sure you loaded the profile, as described in the
    previous section.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-2](#apparmor-pod) shows a YAML manifest for a Pod defined in the
    file `pod.yaml`. To apply a profile to the container, you will need to set a specific
    annotation. The annotation key needs to use the key in the format `container.apparmor.security.beta.​kuber⁠netes.io/<container-name>`.
    In our case, the container name is `hello`. The full key is `container.apparmor.security.beta.kubernetes.io/hello`.
    The value of the annotation follows the pattern `localhost/<profile-name>`. The
    custom profile we want to use here is `k8s-deny-write`. For more information on
    the configuration options, see the [Kubernetes documentation](https://oreil.ly/1o3zO).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. A Pod applying an AppArmor profile to a container
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_system_hardening_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The annotation key that consists of a hard-coded prefix and the container name
    separated by a slash character.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_system_hardening_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The profile name available on the current node indicated by `localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_system_hardening_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The container name.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are ready to create the Pod. Run the `apply` command and point it to the
    YAML manifest. Wait until the Pod transitions into the “Running” status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now shell into the container and perform a file write operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: AppArmor will prevent writing a file to the container’s filesystem. The message
    “Permission denied” will be rendered if you try to perform the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Using seccomp
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Seccomp, short for “Secure Computing Mode,” is another Linux kernel feature
    that can restrict the calls made from the userspace into the kernel. A seccomp
    profile is the mechanism for defining the rules for restricting syscalls and their
    arguments. Using seccomp can reduce the risk of exploiting a Linux kernel vulnerability.
    For more information on seccomp on Kubernetes, see the [documentation](https://oreil.ly/B8I5L).
  prefs: []
  type: TYPE_NORMAL
- en: Applying the default container runtime profile to a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Container runtimes, such as Docker Engine or containerd, ship with a default
    seccomp profile. The default seccomp profile allows the most commonly used syscalls
    used by applications while at the same time forbidding the use of syscalls considered
    dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes does not apply the default container runtime profile to containers
    when creating a Pod, but you can enable it using the `SeccompDefault` [feature
    gate](https://oreil.ly/m9g0G). Alternatively, you can opt into the feature on
    a Pod-by-Pod basis by setting the seccomp profile type to `RuntimeDefault` with
    the help of the security context attribute `seccompProfile`. [Example 4-3](#seccomp-default-profile-pod)
    demonstrates its use.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. A Pod applying the default seccomp profile provided by the container
    runtime profile
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_system_hardening_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Applies the default container runtime profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can start the Pod using the `apply` command and point to the YAML manifest.
    The Pod should transition into the “Running” status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `echo` command executed in the container is considered unproblematic from
    a security perspective by the default seccomp profile. The following command inspects
    the logs of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The call was permitted and resulted in writing the message “Hello seccomp!”
    to standard output.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a custom profile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can create and set your own custom profile in addition to the default container
    runtime profile. The standard directory for those files is `/var/lib/kubelet/seccomp`.
    We’ll organize our custom profiles in the subdirectory `profiles`. Create the
    directory if it doesn’t exist yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We decide to create our custom profile in the file `mkdir-violation.json` in
    the profile directory. [Example 4-4](#seccomp-mkdir-violation-profile) shows the
    details of the profile definition. In a nutshell, the rule set disallows the use
    of the `mkdir` syscall.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. A seccomp profile that prevents executing a `mkdir` syscall
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_system_hardening_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The default action applies to all system calls. Here we’ll allow all syscalls
    using `SCMP_ACT_ALLOW`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_system_hardening_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: You can filter for specific architectures the default action should apply to.
    The definition of the field is optional.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_system_hardening_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The default action can be overwritten by declaring more fine-grained rules.
    The `SCMP_ACT_ERRNO` action will prevent the execution of the `mkdir` syscall.
  prefs: []
  type: TYPE_NORMAL
- en: Placing a custom profile into the directory `/var/lib/kubelet/seccomp` doesn’t
    automatically apply the rules to a Pod. You still need to configure a Pod to use
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the custom profile to a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Applying a custom profile follows a similar pattern to applying the default
    container runtime profile, with minor differences. As you can see in [Example 4-5](#seccomp-custom-profile-pod),
    we point the `seccompProfile` attribute of the security profile to the file `mkdir-violation.json`
    and set the type to `Localhost`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. A Pod applying a custom seccomp profile prevents a `mkdir` syscall
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_system_hardening_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Refers to a profile on the current node.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_system_hardening_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Applies the profile with the name `mkdir-violation.json` in the subdirectory
    `profiles`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the Pod using the declarative `apply` command. Wait until the Pod transitions
    into the “Running” status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Shell into the container to verify that seccomp properly enforced the applied
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in output, the operation renders an error message when trying
    to execute the `mkdir` command. The rule in the custom profile has been violated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Addressing security aspects isn’t limited to Kubernetes cluster components or
    workload. There’s plenty you can do on the host system level. We discussed different
    OS capabilities and how to use them to minimize potential security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Many operating systems come with a wealth of packages and services to offer
    a more feature-rich experience to end users. It’s important to identify functionality
    not required to operate a Kubernetes cluster. Purge unnecessary packages and services
    rigorously and close ports you don’t need. You will also want to limited which
    users are allowed to have access to specific directories, files, and applications.
    Use Linux’s user management to restrict permissions.
  prefs: []
  type: TYPE_NORMAL
- en: It’s very common for applications and processes running in containers to make
    system calls. You can use Linux kernel hardening tools like AppArmor and seccomp
    to restrict those calls. Only allow system calls crucial to fulfill the needs
    of your application running the container.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have a basic understanding of Linux OS tooling.
  prefs: []
  type: TYPE_NORMAL
- en: The CKS exam primarily focuses on security functionality in Kubernetes. This
    domain crosses the boundary to Linux OS security features. It won’t hurt to explore
    Linux-specific tools and security aspects independent from the content covered
    in this chapter. On a high level, familiarize yourself with service, package,
    user, and network management on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to integrate Linux kernel hardening tools with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor and seccomp are just some kernel hardening tools that can be integrated
    with Kubernetes to restrict system calls made from a container. Practice the process
    of loading a profile and applying it to a container. In order to expand your horizons,
    you may also want to explore other kernel functionality that works alongside Kubernetes,
    such as [SELinux](https://oreil.ly/DrGbB) or [sysctl](https://oreil.ly/GyUoc).
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch04/close-ports* of the checked-out GitHub
    repository [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Start up the
    VMs running the cluster using the command `vagrant up`. The cluster consists of
    a single control plane node named `kube-control-plane` and one worker node named
    `kube-worker-1`. Once done, shut down the cluster using `vagrant destroy -f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the process listening on port 21 in the VM `kube-worker-1`. You decided
    not to expose this port to reduce the risk of attackers exploiting the port. Close
    the port by shutting down the corresponding process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Prerequisite:* This exercise requires the installation of the tools [Vagrant](https://oreil.ly/FiyeH)
    and [VirtualBox](https://oreil.ly/WW8IK).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch04/apparmor* of the checked-out GitHub repository
    [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Start up the VMs running
    the cluster using the command `vagrant up`. The cluster consists of a single control
    plane node named `kube-control-plane`, and one worker node named `kube-worker-1`.
    Once done, shut down the cluster using `vagrant destroy -f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create  an  AppArmor  profile  named  `network-deny`.  The  profile  should
     prevent  any  incoming  and  outgoing  network  traffic.  Add  the  profile  to
     the  set  of  AppArmor  rules  in  enforce  mode.  Apply  the  profile  to  the
     Pod  named `network-call` running in the `default` namespace. Check the logs
    of the Pod to ensure that network calls cannot be made anymore.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Prerequisite:* This exercise requires the installation of the tools [Vagrant](https://oreil.ly/FiyeH)
    and [VirtualBox](https://oreil.ly/WW8IK).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch04/seccomp* of the checked-out GitHub repository
    [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Start up the VMs running
    the cluster using the command `vagrant up`. The cluster consists of a single control
    plane node named `kube-control-plane`, and one worker node named `kube-worker-1`.
    Once done, shut down the cluster using `vagrant destroy -f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a seccomp profile file named `audit.json` that logs all syscalls in the
    standard seccomp directory. Apply the profile to the Pod named `network-call`
    running in the `default` namespace. Check the log file `/var/log/syslog` for log
    entries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Prerequisite:* This exercise requires the installation of the tools [Vagrant](https://oreil.ly/FiyeH)
    and [VirtualBox](https://oreil.ly/WW8IK).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a new Pod named `sysctl-pod` with the image `nginx:1.23.1`. Set the sysctl
    parameters `net.core.somaxconn` to 1024 and `debug.iotrace` to `1`. Check on the
    status of the Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
