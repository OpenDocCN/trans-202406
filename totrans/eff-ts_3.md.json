["```\nlet x: number = 12;\n```", "```\nlet x = 12;\n```", "```\nconst person: {\n  name: string;\n  born: {\n    where: string;\n    when: string;\n  };\n  died: {\n    where: string;\n    when: string;\n  }\n} = {\n  name: 'Sojourner Truth',\n  born: {\n    where: 'Swartekill, NY',\n    when: 'c.1797',\n  },\n  died: {\n    where: 'Battle Creek, MI',\n    when: 'Nov. 26, 1883'\n  }\n};\n```", "```\nconst person = {\n  name: 'Sojourner Truth',\n  born: {\n    where: 'Swartekill, NY',\n    when: 'c.1797',\n  },\n  died: {\n    where: 'Battle Creek, MI',\n    when: 'Nov. 26, 1883'\n  }\n};\n```", "```\nfunction square(nums: number[]) {\n  return nums.map(x => x * x);\n}\nconst squares = square([1, 2, 3, 4]); // Type is number[]\n```", "```\nconst axis1: string = 'x';  // Type is string\nconst axis2 = 'y';  // Type is \"y\"\n```", "```\ninterface Product {\n  id: number;\n  name: string;\n  price: number;\n}\n\nfunction logProduct(product: Product) {\n  const id: number = product.id;\n  const name: string = product.name;\n  const price: number = product.price;\n  console.log(id, name, price);\n}\n```", "```\ninterface Product {\n  id: string;\n  name: string;\n  price: number;\n}\n\nfunction logProduct(product: Product) {\n  const id: number = product.id;\n     // ~~ Type 'string' is not assignable to type 'number'\n  const name: string = product.name;\n  const price: number = product.price;\n  console.log(id, name, price);\n}\n```", "```\nfunction logProduct(product: Product) {\n  const {id, name, price} = product;\n  console.log(id, name, price);\n}\n```", "```\nfunction logProduct(product: Product) {\n  const {id, name, price}: {id: string; name: string; price: number } = product;\n  console.log(id, name, price);\n}\n```", "```\nfunction parseNumber(str: string, base=10) {\n  // ...\n}\n```", "```\n// Don't do this:\napp.get('/health', (request: express.Request, response: express.Response) => {\n  response.send('OK');\n});\n\n// Do this:\napp.get('/health', (request, response) => {\n  response.send('OK');\n});\n```", "```\nconst elmo: Product = {\n  name: 'Tickle Me Elmo',\n  id: '048188 627152',\n  price: 28.99,\n};\n```", "```\nconst furby = {\n  name: 'Furby',\n  id: 630509430963,\n  price: 35,\n};\nlogProduct(furby);\n        // ~~~~~ Argument .. is not assignable to parameter of type 'Product'\n        //         Types of property 'id' are incompatible\n        //         Type 'number' is not assignable to type 'string'\n```", "```\n const furby: Product = {\n   name: 'Furby',\n   id: 630509430963,\n// ~~ Type 'number' is not assignable to type 'string'\n   price: 35,\n };\n logProduct(furby);\n```", "```\nfunction getQuote(ticker: string) {\n  return fetch(`https://quotes.example.com/?q=${ticker}`)\n      .then(response => response.json());\n}\n```", "```\nconst cache: {[ticker: string]: number} = {};\nfunction getQuote(ticker: string) {\n  if (ticker in cache) {\n    return cache[ticker];\n  }\n  return fetch(`https://quotes.example.com/?q=${ticker}`)\n      .then(response => response.json())\n      .then(quote => {\n        cache[ticker] = quote;\n        return quote;\n      });\n}\n```", "```\ngetQuote('MSFT').then(considerBuying);\n              // ~~~~ Property 'then' does not exist on type\n              //        'number | Promise<any>'\n              //      Property 'then' does not exist on type 'number'\n```", "```\nconst cache: {[ticker: string]: number} = {};\nfunction getQuote(ticker: string): Promise<number> {\n  if (ticker in cache) {\n    return cache[ticker];\n        // ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise<number>'\n  }\n  // ...\n}\n```", "```\ninterface Vector2D { x: number; y: number; }\nfunction add(a: Vector2D, b: Vector2D) {\n  return { x: a.x + b.x, y: a.y + b.y };\n}\n```", "```\nlet id = \"12-34-56\";\nfetchProduct(id);  // Expects a string\n\nid = 123456;\nfetchProductBySerialNumber(id);  // Expects a number\n```", "```\n   let id = \"12-34-56\";\n   fetchProduct(id);\n\n   id = 123456;\n// ~~ '123456' is not assignable to type 'string'.\n   fetchProductBySerialNumber(id);\n                           // ~~ Argument of type 'string' is not assignable to\n                           //    parameter of type 'number'\n```", "```\nlet id: string|number = \"12-34-56\";\nfetchProduct(id);\n\nid = 123456;  // OK\nfetchProductBySerialNumber(id);  // OK\n```", "```\nconst id = \"12-34-56\";\nfetchProduct(id);\n\nconst serial = 123456;  // OK\nfetchProductBySerialNumber(serial);  // OK\n```", "```\nconst id = \"12-34-56\";\nfetchProduct(id);\n\n{\n  const id = 123456;  // OK\n  fetchProductBySerialNumber(id);  // OK\n}\n```", "```\ninterface Vector3 { x: number; y: number; z: number; }\nfunction getComponent(vector: Vector3, axis: 'x' | 'y' | 'z') {\n  return vector[axis];\n}\n```", "```\nlet x = 'x';\nlet vec = {x: 10, y: 20, z: 30};\ngetComponent(vec, x);\n               // ~ Argument of type 'string' is not assignable to\n               //   parameter of type '\"x\" | \"y\" | \"z\"'\n```", "```\nconst mixed = ['x', 1];\n```", "```\nlet x = 'x';\nx = 'a';\nx = 'Four score and seven years ago...';\n```", "```\nlet x = 'x';\nx = /x|y|z/;\nx = ['x', 'y', 'z'];\n```", "```\nconst x = 'x';  // type is \"x\"\nlet vec = {x: 10, y: 20, z: 30};\ngetComponent(vec, x);  // OK\n```", "```\nconst v = {\n  x: 1,\n};\nv.x = 3;\nv.x = '3';\nv.y = 4;\nv.name = 'Pythagoras';\n```", "```\n const v = {\n   x: 1,\n };\n v.x = 3;  // OK\n v.x = '3';\n// ~ Type '\"3\"' is not assignable to type 'number'\n v.y = 4;\n// ~ Property 'y' does not exist on type '{ x: number; }'\n v.name = 'Pythagoras';\n// ~~~~ Property 'name' does not exist on type '{ x: number; }'\n```", "```\nconst v: {x: 1|3|5} = {\n  x: 1,\n};  // Type is { x: 1 | 3 | 5; }\n```", "```\nconst v1 = {\n  x: 1,\n  y: 2,\n};  // Type is { x: number; y: number; }\n\nconst v2 = {\n  x: 1 as const,\n  y: 2,\n};  // Type is { x: 1; y: number; }\n\nconst v3 = {\n  x: 1,\n  y: 2,\n} as const;  // Type is { readonly x: 1; readonly y: 2; }\n```", "```\nconst a1 = [1, 2, 3];  // Type is number[]\nconst a2 = [1, 2, 3] as const;  // Type is readonly [1, 2, 3]\n```", "```\nconst el = document.getElementById('foo'); // Type is HTMLElement | null\nif (el) {\n  el // Type is HTMLElement\n  el.innerHTML = 'Party Time'.blink();\n} else {\n  el // Type is null\n  alert('No element #foo');\n}\n```", "```\nconst el = document.getElementById('foo'); // Type is HTMLElement | null\nif (!el) throw new Error('Unable to find #foo');\nel; // Now type is HTMLElement\nel.innerHTML = 'Party Time'.blink();\n```", "```\nfunction contains(text: string, search: string|RegExp) {\n  if (search instanceof RegExp) {\n    search  // Type is RegExp\n    return !!search.exec(text);\n  }\n  search  // Type is string\n  return text.includes(search);\n}\n```", "```\ninterface A { a: number }\ninterface B { b: number }\nfunction pickAB(ab: A | B) {\n  if ('a' in ab) {\n    ab // Type is A\n  } else {\n    ab // Type is B\n  }\n  ab // Type is A | B\n}\n```", "```\nfunction contains(text: string, terms: string|string[]) {\n  const termList = Array.isArray(terms) ? terms : [terms];\n  termList // Type is string[]\n  // ...\n}\n```", "```\nconst el = document.getElementById('foo'); // type is HTMLElement | null\nif (typeof el === 'object') {\n  el;  // Type is HTMLElement | null\n}\n```", "```\nfunction foo(x?: number|string|null) {\n  if (!x) {\n    x;  // Type is string | number | null | undefined\n  }\n}\n```", "```\ninterface UploadEvent { type: 'upload'; filename: string; contents: string }\ninterface DownloadEvent { type: 'download'; filename: string; }\ntype AppEvent = UploadEvent | DownloadEvent;\n\nfunction handleEvent(e: AppEvent) {\n  switch (e.type) {\n    case 'download':\n      e  // Type is DownloadEvent\n      break;\n    case 'upload':\n      e;  // Type is UploadEvent\n      break;\n  }\n}\n```", "```\nfunction isInputElement(el: HTMLElement): el is HTMLInputElement {\n  return 'value' in el;\n}\n\nfunction getElementContent(el: HTMLElement) {\n  if (isInputElement(el)) {\n    el; // Type is HTMLInputElement\n    return el.value;\n  }\n  el; // Type is HTMLElement\n  return el.textContent;\n}\n```", "```\nconst jackson5 = ['Jackie', 'Tito', 'Jermaine', 'Marlon', 'Michael'];\nconst members = ['Janet', 'Michael'].map(\n  who => jackson5.find(n => n === who)\n);  // Type is (string | undefined)[]\n```", "```\nconst members = ['Janet', 'Michael'].map(\n  who => jackson5.find(n => n === who)\n).filter(who => who !== undefined);  // Type is (string | undefined)[]\n```", "```\nfunction isDefined<T>(x: T | undefined): x is T {\n  return x !== undefined;\n}\nconst members = ['Janet', 'Michael'].map(\n  who => jackson5.find(n => n === who)\n).filter(isDefined);  // Type is string[]\n```", "```\nconst pt = {};\npt.x = 3;\npt.y = 4;\n```", "```\nconst pt = {};\npt.x = 3;\n// ~ Property 'x' does not exist on type '{}'\npt.y = 4;\n// ~ Property 'y' does not exist on type '{}'\n```", "```\ninterface Point { x: number; y: number; }\nconst pt: Point = {};\n   // ~~ Type '{}' is missing the following properties from type 'Point': x, y\npt.x = 3;\npt.y = 4;\n```", "```\nconst pt = {\n  x: 3,\n  y: 4,\n};  // OK\n```", "```\nconst pt = {} as Point;\npt.x = 3;\npt.y = 4;  // OK\n```", "```\nconst pt: Point = {\n  x: 3,\n  y: 4,\n};\n```", "```\nconst pt = {x: 3, y: 4};\nconst id = {name: 'Pythagoras'};\nconst namedPoint = {};\nObject.assign(namedPoint, pt, id);\nnamedPoint.name;\n        // ~~~~ Property 'name' does not exist on type '{}'\n```", "```\nconst namedPoint = {...pt, ...id};\nnamedPoint.name;  // OK, type is string\n```", "```\nconst pt0 = {};\nconst pt1 = {...pt0, x: 3};\nconst pt: Point = {...pt1, y: 4};  // OK\n```", "```\ndeclare let hasMiddle: boolean;\nconst firstLast = {first: 'Harry', last: 'Truman'};\nconst president = {...firstLast, ...(hasMiddle ? {middle: 'S'} : {})};\n```", "```\nconst president: {\n    middle: string;\n    first: string;\n    last: string;\n} | {\n    first: string;\n    last: string;\n}\n```", "```\npresident.middle\n       // ~~~~~~ Property 'middle' does not exist on type\n       //        '{ first: string; last: string; }'\n```", "```\nfunction addOptional<T extends object, U extends object>(\n  a: T, b: U | null\n): T & Partial<U> {\n  return {...a, ...b};\n}\n\nconst president = addOptional(firstLast, hasMiddle ? {middle: 'S'} : null);\npresident.middle  // OK, type is string | undefined\n```", "```\nconst borough = {name: 'Brooklyn', location: [40.688, -73.979]};\nconst loc = borough.location;\n```", "```\n> loc[0] = 0;\n> borough.location\n[0, -73.979]\n```", "```\ninterface Coordinate {\n  x: number;\n  y: number;\n}\n\ninterface BoundingBox {\n  x: [number, number];\n  y: [number, number];\n}\n\ninterface Polygon {\n  exterior: Coordinate[];\n  holes: Coordinate[][];\n  bbox?: BoundingBox;\n}\n```", "```\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  if (polygon.bbox) {\n    if (pt.x < polygon.bbox.x[0] || pt.x > polygon.bbox.x[1] ||\n        pt.y < polygon.bbox.y[1] || pt.y > polygon.bbox.y[1]) {\n      return false;\n    }\n  }\n\n  // ... more complex check\n}\n```", "```\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  const box = polygon.bbox;\n  if (polygon.bbox) {\n    if (pt.x < box.x[0] || pt.x > box.x[1] ||\n        //     ~~~                ~~~  Object is possibly 'undefined'\n        pt.y < box.y[1] || pt.y > box.y[1]) {\n        //     ~~~                ~~~  Object is possibly 'undefined'\n      return false;\n    }\n  }\n  // ...\n}\n```", "```\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  polygon.bbox  // Type is BoundingBox | undefined\n  const box = polygon.bbox;\n  box  // Type is BoundingBox | undefined\n  if (polygon.bbox) {\n    polygon.bbox  // Type is BoundingBox\n    box  // Type is BoundingBox | undefined\n  }\n}\n```", "```\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  const box = polygon.bbox;\n  if (box) {\n    if (pt.x < box.x[0] || pt.x > box.x[1] ||\n        pt.y < box.y[1] || pt.y > box.y[1]) {  // OK\n      return false;\n    }\n  }\n  // ...\n}\n```", "```\nfunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  const {bbox} = polygon;\n  if (bbox) {\n    const {x, y} = bbox;\n    if (pt.x < x[0] || pt.x > x[1] ||\n        pt.y < x[0] || pt.y > y[1]) {\n      return false;\n    }\n  }\n  // ...\n}\n```", "```\nconst {bbox} = polygon;\nif (!bbox) {\n  calculatePolygonBbox(polygon);  // Fills in polygon.bbox\n  // Now polygon.bbox and bbox refer to different values!\n}\n```", "```\nfunction fn(p: Polygon) { /* ... */ }\n\npolygon.bbox  // Type is BoundingBox | undefined\nif (polygon.bbox) {\n  polygon.bbox  // Type is BoundingBox\n  fn(polygon);\n  polygon.bbox  // Type is still BoundingBox\n}\n```", "```\nfetchURL(url1, function(response1) {\n  fetchURL(url2, function(response2) {\n    fetchURL(url3, function(response3) {\n      // ...\n      console.log(1);\n    });\n    console.log(2);\n  });\n  console.log(3);\n});\nconsole.log(4);\n\n// Logs:\n// 4\n// 3\n// 2\n// 1\n```", "```\nconst page1Promise = fetch(url1);\npage1Promise.then(response1 => {\n  return fetch(url2);\n}).then(response2 => {\n  return fetch(url3);\n}).then(response3 => {\n  // ...\n}).catch(error => {\n  // ...\n});\n```", "```\nasync function fetchPages() {\n  const response1 = await fetch(url1);\n  const response2 = await fetch(url2);\n  const response3 = await fetch(url3);\n  // ...\n}\n```", "```\nasync function fetchPages() {\n  try {\n    const response1 = await fetch(url1);\n    const response2 = await fetch(url2);\n    const response3 = await fetch(url3);\n    // ...\n  } catch (e) {\n    // ...\n  }\n}\n```", "```\nasync function fetchPages() {\n  const [response1, response2, response3] = await Promise.all([\n    fetch(url1), fetch(url2), fetch(url3)\n  ]);\n  // ...\n}\n```", "```\nfunction fetchPagesCB() {\n  let numDone = 0;\n  const responses: string[] = [];\n  const done = () => {\n    const [response1, response2, response3] = responses;\n    // ...\n  };\n  const urls = [url1, url2, url3];\n  urls.forEach((url, i) => {\n    fetchURL(url, r => {\n      responses[i] = url;\n      numDone++;\n      if (numDone === urls.length) done();\n    });\n  });\n}\n```", "```\nfunction timeout(millis: number): Promise<never> {\n  return new Promise((resolve, reject) => {\n     setTimeout(() => reject('timeout'), millis);\n  });\n}\n\nasync function fetchWithTimeout(url: string, ms: number) {\n  return Promise.race([fetch(url), timeout(ms)]);\n}\n```", "```\n// function getNumber(): Promise<number>\nasync function getNumber() {\n  return 42;\n}\n```", "```\nconst getNumber = async () => 42;  // Type is () => Promise<number>\n```", "```\nconst getNumber = () => Promise.resolve(42);  // Type is () => Promise<number>\n```", "```\n// Don't do this!\nconst _cache: {[url: string]: string} = {};\nfunction fetchWithCache(url: string, callback: (text: string) => void) {\n  if (url in _cache) {\n    callback(_cache[url]);\n  } else {\n    fetchURL(url, text => {\n      _cache[url] = text;\n      callback(text);\n    });\n  }\n}\n```", "```\nlet requestStatus: 'loading' | 'success' | 'error';\nfunction getUser(userId: string) {\n  fetchWithCache(`/user/${userId}`, profile => {\n    requestStatus = 'success';\n  });\n  requestStatus = 'loading';\n}\n```", "```\nconst _cache: {[url: string]: string} = {};\nasync function fetchWithCache(url: string) {\n  if (url in _cache) {\n    return _cache[url];\n  }\n  const response = await fetch(url);\n  const text = await response.text();\n  _cache[url] = text;\n  return text;\n}\n\nlet requestStatus: 'loading' | 'success' | 'error';\nasync function getUser(userId: string) {\n  requestStatus = 'loading';\n  const profile = await fetchWithCache(`/user/${userId}`);\n  requestStatus = 'success';\n}\n```", "```\n// Function getJSON(url: string): Promise<any>\nasync function getJSON(url: string) {\n  const response = await fetch(url);\n  const jsonPromise = response.json();  // Type is Promise<any>\n  return jsonPromise;\n}\n```", "```\n// Inline form\nsetLanguage('JavaScript');\n\n// Reference form\nlet language = 'JavaScript';\nsetLanguage(language);\n```", "```\nfunction setLanguage(language: string) { /* ... */ }\n\nsetLanguage('JavaScript');  // OK\n\nlet language = 'JavaScript';\nsetLanguage(language);  // OK\n```", "```\ntype Language = 'JavaScript' | 'TypeScript' | 'Python';\nfunction setLanguage(language: Language) { /* ... */ }\n\nsetLanguage('JavaScript');  // OK\n\nlet language = 'JavaScript';\nsetLanguage(language);\n         // ~~~~~~~~ Argument of type 'string' is not assignable\n         //          to parameter of type 'Language'\n```", "```\nlet language: Language = 'JavaScript';\nsetLanguage(language);  // OK\n```", "```\nconst language = 'JavaScript';\nsetLanguage(language);  // OK\n```", "```\n// Parameter is a (latitude, longitude) pair.\nfunction panTo(where: [number, number]) { /* ... */ }\n\npanTo([10, 20]);  // OK\n\nconst loc = [10, 20];\npanTo(loc);\n//    ~~~ Argument of type 'number[]' is not assignable to\n//        parameter of type '[number, number]'\n```", "```\nconst loc: [number, number] = [10, 20];\npanTo(loc);  // OK\n```", "```\nconst loc = [10, 20] as const;\npanTo(loc);\n   // ~~~ Type 'readonly [10, 20]' is 'readonly'\n   //     and cannot be assigned to the mutable type '[number, number]'\n```", "```\nfunction panTo(where: readonly [number, number]) { /* ... */ }\nconst loc = [10, 20] as const;\npanTo(loc);  // OK\n```", "```\nconst loc = [10, 20, 30] as const;  // error is really here.\npanTo(loc);\n//    ~~~ Argument of type 'readonly [10, 20, 30]' is not assignable to\n//        parameter of type 'readonly [number, number]'\n//          Types of property 'length' are incompatible\n//            Type '3' is not assignable to type '2'\n```", "```\ntype Language = 'JavaScript' | 'TypeScript' | 'Python';\ninterface GovernedLanguage {\n  language: Language;\n  organization: string;\n}\n\nfunction complain(language: GovernedLanguage) { /* ... */ }\n\ncomplain({ language: 'TypeScript', organization: 'Microsoft' });  // OK\n\nconst ts = {\n  language: 'TypeScript',\n  organization: 'Microsoft',\n};\ncomplain(ts);\n//       ~~ Argument of type '{ language: string; organization: string; }'\n//            is not assignable to parameter of type 'GovernedLanguage'\n//          Types of property 'language' are incompatible\n//            Type 'string' is not assignable to type 'Language'\n```", "```\nfunction callWithRandomNumbers(fn: (n1: number, n2: number) => void) {\n  fn(Math.random(), Math.random());\n}\n\ncallWithRandomNumbers((a, b) => {\n  a;  // Type is number\n  b;  // Type is number\n  console.log(a + b);\n});\n```", "```\nconst fn = (a, b) => {\n         // ~    Parameter 'a' implicitly has an 'any' type\n         //    ~ Parameter 'b' implicitly has an 'any' type\n  console.log(a + b);\n}\ncallWithRandomNumbers(fn);\n```", "```\nconst fn = (a: number, b: number) => {\n  console.log(a + b);\n}\ncallWithRandomNumbers(fn);\n```", "```\nconst csvData = \"...\";\nconst rawRows = csvData.split('\\n');\nconst headers = rawRows[0].split(',');\n\nconst rows = rawRows.slice(1).map(rowStr => {\n  const row = {};\n  rowStr.split(',').forEach((val, j) => {\n    row[headers[j]] = val;\n  });\n  return row;\n});\n```", "```\nconst rows = rawRows.slice(1)\n    .map(rowStr => rowStr.split(',').reduce(\n        (row, val, i) => (row[headers[i]] = val, row),\n        {}));\n```", "```\nimport _ from 'lodash';\nconst rows = rawRows.slice(1)\n    .map(rowStr => _.zipObject(headers, rowStr.split(',')));\n```", "```\nconst rowsA = rawRows.slice(1).map(rowStr => {\n  const row = {};\n  rowStr.split(',').forEach((val, j) => {\n    row[headers[j]] = val;\n // ~~~~~~~~~~~~~~~ No index signature with a parameter of\n //                 type 'string' was found on type '{}'\n  });\n  return row;\n});\nconst rowsB = rawRows.slice(1)\n  .map(rowStr => rowStr.split(',').reduce(\n      (row, val, i) => (row[headers[i]] = val, row),\n                     // ~~~~~~~~~~~~~~~ No index signature with a parameter of\n                     //                 type 'string' was found on type '{}'\n      {}));\n```", "```\nconst rows = rawRows.slice(1)\n    .map(rowStr => _.zipObject(headers, rowStr.split(',')));\n    // Type is _.Dictionary<string>[]\n```", "```\ninterface BasketballPlayer {\n  name: string;\n  team: string;\n  salary: number;\n}\ndeclare const rosters: {[team: string]: BasketballPlayer[]};\n```", "```\nlet allPlayers = [];\n // ~~~~~~~~~~ Variable 'allPlayers' implicitly has type 'any[]'\n //            in some locations where its type cannot be determined\nfor (const players of Object.values(rosters)) {\n  allPlayers = allPlayers.concat(players);\n            // ~~~~~~~~~~ Variable 'allPlayers' implicitly has an 'any[]' type\n}\n```", "```\nlet allPlayers: BasketballPlayer[] = [];\nfor (const players of Object.values(rosters)) {\n  allPlayers = allPlayers.concat(players);  // OK\n}\n```", "```\nconst allPlayers = Object.values(rosters).flat();\n// OK, type is BasketballPlayer[]\n```", "```\nconst teamToPlayers: {[team: string]: BasketballPlayer[]} = {};\nfor (const player of allPlayers) {\n  const {team} = player;\n  teamToPlayers[team] = teamToPlayers[team] || [];\n  teamToPlayers[team].push(player);\n}\n\nfor (const players of Object.values(teamToPlayers)) {\n  players.sort((a, b) => b.salary - a.salary);\n}\n\nconst bestPaid = Object.values(teamToPlayers).map(players => players[0]);\nbestPaid.sort((playerA, playerB) => playerB.salary - playerA.salary);\nconsole.log(bestPaid);\n```", "```\n[\n  { team: 'GSW', salary: 37457154, name: 'Stephen Curry' },\n  { team: 'HOU', salary: 35654150, name: 'Chris Paul' },\n  { team: 'LAL', salary: 35654150, name: 'LeBron James' },\n  { team: 'OKC', salary: 35654150, name: 'Russell Westbrook' },\n  { team: 'DET', salary: 32088932, name: 'Blake Griffin' },\n  ...\n]\n```", "```\nconst bestPaid = _(allPlayers)\n  .groupBy(player => player.team)\n  .mapValues(players => _.maxBy(players, p => p.salary)!)\n  .values()\n  .sortBy(p => -p.salary)\n  .value()  // Type is BasketballPlayer[]\n```", "```\n_.a(_.b(_.c(v)))\n```", "```\n_(v).a().b().c().value()\n```", "```\nconst namesA = allPlayers.map(player => player.name)  // Type is string[]\nconst namesB = _.map(allPlayers, player => player.name)  // Type is string[]\nconst namesC = _.map(allPlayers, 'name');  // Type is string[]\n```", "```\nconst salaries = _.map(allPlayers, 'salary');  // Type is number[]\nconst teams = _.map(allPlayers, 'team');  // Type is string[]\nconst mix = _.map(allPlayers, Math.random() < 0.5 ? 'name' : 'salary');\n  // Type is (string | number)[]\n```"]