["```\nsession1 > `SELECT` `*` `FROM` `person` `WHERE` `i` `BETWEEN` `1` `AND` `4``;`\n```", "```\n+---+----------+\n| i | name     |\n+---+----------+\n| 1 | Vinicius |\n| 2 | Sergey   |\n| 3 | Iwo      |\n| 4 | Peter    |\n+---+----------+\n4 rows in set (0.00 sec)\n```", "```\nsession2 > `UPDATE` `person` `SET` `name` `=` `'Kuzmichev'` `WHERE` `i``=``2``;`\n```", "```\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n```", "```\nsession2> `COMMIT``;`\n```", "```\nQuery OK, 0 rows affected (0.00 sec)\n```", "```\nsession2 > `SELECT` `*` `FROM` `person` `WHERE` `i` `BETWEEN` `1` `AND` `4``;`\n```", "```\n+---+-----------+\n| i | name      |\n+---+-----------+\n| 1 | Vinicius  |\n| 2 | Kuzmichev |\n| 3 | Iwo       |\n| 4 | Peter     |\n+---+-----------+\n4 rows in set (0.00 sec)\n```", "```\nsession1> `SELECT` `*` `FROM` `person` `WHERE` `i` `BETWEEN` `1` `AND` `4``;`\n```", "```\n+---+----------+\n| i | name     |\n+---+----------+\n| 1 | Vinicius |\n| 2 | Sergey   |\n| 3 | Iwo      |\n| 4 | Peter    |\n+---+----------+\n```", "```\nsession1 > `SELECT` `*` `FROM` `person` `WHERE` `i` `=` `1``;`\n```", "```\n+---+----------+\n| i | name     |\n+---+----------+\n| 1 | Vinicius |\n+---+----------+\n1 row in set (0.00 sec)\n```", "```\nsession2 > `UPDATE` `person` `SET` `name` `=` `'Grippa'` `WHERE` `i` `=` `1``;`\n```", "```\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n```", "```\nsession2 > `COMMIT``;`\n```", "```\nQuery OK, 0 rows affected (0.00 sec)\n```", "```\nsession1 > `SELECT` `*` `FROM` `person` `WHERE` `i` `=` `1``;`\n```", "```\n+---+--------+\n| i | name   |\n+---+--------+\n| 1 | Grippa |\n+---+--------+\n```", "```\nsession1 > `SELECT` `*` `FROM` `person` `WHERE` `i` `=` `5``;`\n```", "```\n+---+---------+\n| i | name    |\n+---+---------+\n| 5 | Marcelo |\n+---+---------+\n1 row in set (0.00 sec)\n```", "```\nsession2 > `UPDATE` `person` `SET` `name` `=` `'Altmann'` `WHERE` `i` `=` `5``;`\n```", "```\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n```", "```\nsession1 > `SELECT` `*` `FROM` `person` `WHERE` `i` `=` `5``;`\n```", "```\n+---+---------+\n| i | name    |\n+---+---------+\n| 5 | Altmann |\n+---+---------+\n1 row in set (0.00 sec)\n```", "```\nsession1> `SELECT` `*` `FROM` `accounts``;`\n```", "```\n+----+--------+---------+----------+---------------------+\n| id | owner  | balance | currency | created_at          |\n+----+--------+---------+----------+---------------------+\n|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |\n|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |\n|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |\n+----+--------+---------+----------+---------------------+\n3 rows in set (0.00 sec)\n```", "```\nsession2> `SELECT` `*` `FROM` `accounts` `WHERE` `balance` `>``=` `80``;`\n```", "```\n+----+--------+---------+----------+---------------------+\n| id | owner  | balance | currency | created_at          |\n+----+--------+---------+----------+---------------------+\n|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |\n|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |\n|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |\n+----+--------+---------+----------+---------------------+\n3 rows in set (0.00 sec)\n```", "```\nsession1> `UPDATE` `accounts` `SET` `balance` `=` `balance` `-` `10` `WHERE` `id` `=` `1``;`\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nsession1> `SELECT` `*` `FROM` `accounts``;`\n```", "```\n+----+--------+---------+----------+---------------------+\n| id | owner  | balance | currency | created_at          |\n+----+--------+---------+----------+---------------------+\n|  1 | Vinnie |      70 | USD      | 2021-07-13 20:39:27 |\n|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |\n|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |\n+----+--------+---------+----------+---------------------+\n3 rows in set (0.00 sec)\n```", "```\nsession1> `COMMIT``;`\n```", "```\nQuery OK, 0 rows affected (0.01 sec)\n```", "```\nsession2> `SELECT` `*` `FROM` `accounts` `WHERE` `id` `=` `1``;`\n```", "```\n+----+--------+---------+----------+---------------------+\n| id | owner  | balance | currency | created_at          |\n+----+--------+---------+----------+---------------------+\n|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |\n+----+--------+---------+----------+---------------------+\n1 row in set (0.01 sec)\n```", "```\nsession2> `UPDATE` `accounts` `SET` `balance` `=` `balance` `-` `10` `WHERE` `id` `=` `1``;`\n```", "```\nQuery OK, 1 row affected (0.00 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n```", "```\nsession2> `SELECT` `*` `FROM` `accounts` `WHERE` `id` `=` `1``;`\n```", "```\n+----+--------+---------+----------+---------------------+\n| id | owner  | balance | currency | created_at          |\n+----+--------+---------+----------+---------------------+\n|  1 | Vinnie |      60 | USD      | 2021-07-13 20:39:27 |\n+----+--------+---------+----------+---------------------+\n1 row in set (0.01 sec)\n```", "```\nsession1> `SELECT` `*` `FROM` `accounts``;`\n```", "```\n+----+--------+---------+----------+---------------------+\n| id | owner  | balance | currency | created_at          |\n+----+--------+---------+----------+---------------------+\n|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |\n|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |\n|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |\n+----+--------+---------+----------+---------------------+\n3 rows in set (0.00 sec)\n```", "```\nsession2> `SELECT` `*` `FROM` `accounts` `WHERE` `balance` `>``=` `80``;`\n```", "```\n+----+--------+---------+----------+---------------------+\n| id | owner  | balance | currency | created_at          |\n+----+--------+---------+----------+---------------------+\n|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |\n|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |\n|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |\n+----+--------+---------+----------+---------------------+\n3 rows in set (0.00 sec)\n```", "```\nsession1> `UPDATE` `accounts` `SET` `balance` `=` `balance` `-` `10` `WHERE` `id` `=` `1``;`\n```", "```\nERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n```", "```\n`USE` `test``;`\n\n`DROP` `TABLE` `IF` `EXISTS` `` `joinit` ```", "``` `i` ```", "```\n\nNow that we have some dummy data, we will open one session (session 1) and execute an `UPDATE`:\n\n```", "```\n\nThen, in a second session, we will try to add a new column to this table while the `UPDATE` is still running:\n\n```", "```\n\nAnd in a third session, we can execute the `SHOW PROCESSLIST` command to visualize the metadata lock:\n\n```", "```\n\n```", "```\n\nNote that a long-running query or a query that is not using autocommit will have the same effect. For example, suppose we have an `UPDATE` running in session 1:\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\nAnd we execute a DML statement in session 2:\n\n```", "```\n\nIf we check the process list in session 3, we can see the DDL waiting on the metadata lock (thread 11), while thread 10 has been sleeping since it executed the `UPDATE` (still not committed):\n\n```", "```\n\n###### Note\n\nMySQL is multithreaded, so there may be many clients issuing queries for a given table simultaneously. To minimize the problem with multiple client sessions having different states for the same table, each concurrent session opens the table independently. This uses additional memory but typically increases performance.\n\nBefore we start using the `sys` schema, it is necessary to enable MySQL instrumentation to monitor these locks. To do this, run the following command:\n\n```", "```\n\nThe following query uses the `schema_table_lock_waits` view from the `sys` schema to illustrate how to observe metadata locks in the MySQL database:\n\n```", "```\n\nThis view displays which sessions are blocked waiting on metadata locks and what is blocking them. Rather than selecting all fields, the following example shows a more compact view:\n\n```", "```\n\n```", "```\n\n```", "```\n\n###### Note\n\nThe MySQL `sys` schema is a set of objects that helps DBAs and developers interpret data collected by the Performance Schema, a feature for monitoring MySQL Server execution at a low level. It is available for MySQL 5.7 and MySQL 8.0\\. If you want to use the `sys` schema in MySQL 5.6, it is possible to install it using the `sys` project available on GitHub:\n\n```", "```\n\nLet’s see what happens when we query the `metadata_locks` table:\n\n```", "```\n\n```", "```\n\nNote that a `SHARED_UPGRADABLE` lock is set on the `joinit` table, and an `EXCLUSIVE` lock is pending on the same table.\n\nWe can get a nice view of all metadata locks from other sessions, excluding our current one, with the following query:\n\n```", "```\n\n```", "```\n\nIf we look carefully, a DDL statement waiting for a query on its own is not a problem: it will have to wait until it can acquire the metadata lock, which is expected. The problem is that while waiting, it blocks every other query from accessing the resource.\n\nWe recommend the following actions to avoid long metadata locks:\n\n*   Perform DDL operations in non-busy times. This way you reduce the concurrency in the database between the regular application workload and the extra workload that the operation carries.\n\n*   Always use autocommit. MySQL has autocommit enabled by default. This will avoid transactions with pending commits.\n\n*   When performing a DDL operation, set a low value for `lock_wait_timeout` at the session level. Then, if the metadata lock can’t be acquired, it won’t block for a long time waiting. For example:\n\n    ```", "```\n\nYou might also want to consider using the [`pt-kill` tool](https://oreil.ly/C4rMb) to kill queries that have been running for a long time. For example, to kill queries that have been running for more than 60 seconds, issue this command:\n\n```", "```\n\n## Row Locks\n\nInnoDB implements standard row-level locking. This means that, in general terms, there are two types of locks:\n\n*   A *shared* (S) lock permits the transaction that holds the lock to read a row.\n\n*   An *exclusive* (X) lock permits the transaction that holds the lock to update or delete a row.\n\nThe names are self-explanatory: exclusive locks don’t allow multiple transactions to acquire an exclusive lock in the same row while sharing a shared lock. That is why it is possible to have parallel reads for the same row, while parallel writes are not allowed.\n\nInnoDB also supports multiple granularity locking, which permits the coexistence of row locks and table locks. Granular locking is possible due to the existence of *intention locks*, which are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table. There are two types of intention locks:\n\n*   An *intention shared* (IS) lock indicates that a transaction intends to set a shared lock on individual rows in a table.\n\n*   An *intention exclusive* (IX) lock indicates that a transaction intends to set an exclusive lock on individual rows in a table.\n\nBefore a transaction can acquire a shared or an exclusive lock, it is necessary to obtain the respective intention lock (IS or IX).\n\nTo make things a bit easier to understand, take a look at [Table 6-1](#table0601).\n\nTable 6-1\\. Lock type compatibility matrix\n\n|  | X | IX | S | IS |\n| --- | --- | --- | --- | --- |\n| X | Conflict | Conflict | Conflict | Conflict |\n| IX | Conflict | Compatible | Conflict | Compatible |\n| S | Conflict | Conflict | Compatible | Compatible |\n| IS | Conflict | Compatible | Compatible | Compatible |\n\nAnother important concept is the *gap lock*, which is a lock on the gap between index records. Gap locks ensure that no new rows are added in the interval specified by the query; this means that when you run the same query twice, you get the same number of rows, regardless of other sessions’ modifications to that table. They make the reads consistent and therefore make the replication between servers consistent. If you execute `SELECT * FROM example_table WHERE id > 1000 FOR UPDATE` twice, you expect to get the same result twice. To accomplish that, InnoDB locks all index records found by the `WHERE` clause with an exclusive lock and the gaps between them with a shared gap lock.\n\nLet’s see an example of a gap lock in action. First, we will execute a `SELECT` statement on the `person` table:\n\n```", "```\n\n```", "```\n\nNow, in session 1, we will perform a delete operation, but we will *not* commit:\n\n```", "```\n\n```", "```\n\nAnd if we check in session 2, we can still see the row with Jobin:\n\n```", "```\n\n```", "```\n\nThe results show that there are gaps in the values of the primary key column that in theory are available to be used to insert new records. So what happens if we try to insert a new row with a value of 11? The insert will be locked and will fail:\n\n```", "```\n\n```", "```\n\nIf we run `SHOW ENGINE INNODB STATUS`, we will see the locked transaction in the `TRANSACTIONS` section:\n\n```", "```\n\nNote that MySQL does not need gap locking for statements that lock rows using a unique index to search for a unique row. (This does not include the case where the search condition includes only some columns of a multiple-column unique index; in that case, gap locking does occur.) For example, if the `name` column has a unique index, the following `DELETE` statement uses only an index-record lock:\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n## Deadlocks\n\nA *deadlock* is a situation where two (or more) competing actions are waiting for the other to finish. As a consequence, neither ever does. In computer science, the term refers to a specific condition where two or more processes are each waiting for another to release a resource. In this section, we will talk specifically about transaction deadlocks and how InnoDB solves this issue.\n\nFor a deadlock to happen, four conditions (known as the *Coffman conditions*) must exist:\n\n1.  *Mutual exclusion*. The process must hold at least one resource in a non-shareable mode. Otherwise, MySQL would not prevent the process from using the resource when necessary. Only one process can use the resource at any given moment in time.\n\n2.  *Hold and wait or resource holding*. A process is currently holding at least one resource and requesting additional resources held by other processes.\n\n3.  *No preemption*. A resource can be released only voluntarily by the process holding it.\n\n4.  *Circular wait*. Each process must be waiting for a resource held by another process, which in turn is waiting for the first process to release the resource.\n\nBefore moving on to an example, there are some misconceptions that you might hear and that it is essential to clarify. They are:\n\nTransaction isolation levels are responsible for deadlocks.\n\nThe possibility of deadlocks is not affected by the isolation level. The `READ COMMITTED` isolation level sets fewer locks, and hence it can help you avoid certain lock types (e.g., gap locking), but it won’t prevent deadlocks entirely.\n\nSmall transactions are not affected by deadlocks.\n\nSmall transactions are less prone to deadlocks because they run fast, so the chance of a conflict occurring is smaller than with more prolonged operations. However, it can still happen if transactions do not use the same order of operations.\n\nDeadlocks are terrible things.\n\nIt’s problematic to have deadlocks in a database, but InnoDB can resolve them automatically, unless deadlock detection is disabled (by changing the value of `innodb_deadlock_detect`). A deadlock is a a bad situation, but resolution through the termination of one of the transactions ensures that processes cannot hold onto the resources for a long time, slowing or stalling the database completely until the offending query gets canceled by the `innodb_lock_wait_timeout` setting.\n\nTo illustrate deadlocks, we’ll use the `world` database. If you need to import it, you can do so now by following the instructions in [“Entity Relationship Modeling Examples”](ch02.xhtml#BAS-SEC-MODELING-EXAMPLES).\n\nLet’s start by getting a list of Italian cities in the province of Toscana:\n\n```", "```\n\n```", "```\n\nNow let’s say we have two transactions trying to update the populations of the same two cities in Toscana at the same time, but in different orders:\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\nAnd we had a deadlock in session 1\\. It is important to note that it is not always the second transaction that will fail. In this example, session 1 was the one that MySQL aborted. We can get information on the latest deadlock that happened in the MySQL database by running `SHOW ENGINE INNODB STATUS`:\n\n```", "```\n\n```", "```\n\nIf you want, you can log all the deadlocks that happen in MySQL in the MySQL error log. Using the `innodb_print_all_deadlocks` parameter, MySQL records all information about deadlocks from InnoDB user transactions in the error log. Otherwise, you see information about only the last deadlock using the `SHOW ENGINE INNODB STATUS` command.\n\n# MySQL Parameters Related to Isolation and Locks\n\nTo round out this chapter, let’s take a look at a few MySQL parameters that are related to isolation behavior and lock duration:\n\n`transaction_isolation`\n\nSets the transaction isolation level. This parameter can change the behavior at the `GLOBAL`, `SESSION`, or `NEXT_TRANSACTION` level:\n\n```", "```\n\n```", "```\n\n```", "```\n\n```", "```\n\n###### Note\n\n`transaction_isolation` was added in MySQL 5.7.20 as a synonym for `tx_isolation`, which is now deprecated and has been removed in MySQL 8.0\\. Applications should be adjusted to use `transaction_isolation` in preference to `tx_isolation`.\n\n`innodb_lock_wait_timeout`\n\nSpecifies the amount of time in seconds an InnoDB transaction waits for a row lock before giving up. The default value is 50 seconds. The transaction raises the following error if the time waiting for the lock exceeds the `innodb_lock_wait_timeout` value:\n\n```", "```\n\n`innodb_print_all_deadlocks`\n\nCauses MySQL to record information about all deadlocks resulting from InnoDB user transactions in the MySQL error log. We can enable this dynamically with the following command:\n\n```", "```\n\n`lock_wait_timeout`\n\nSpecifies the timeout in seconds for attempts to acquire metadata locks. To avoid long metadata locks stalling the database, we can set `lock_wait_timeout=1` at the session level before executing the DDL statement. In this case, if the operation can’t acquire the lock, it will give up and let other requests execute. For example:\n\n```"]