- en: Chapter 22\. Ingresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 21](ch21.xhtml#services) delved into the purpose and creation of the
    Service primitive. Once there’s a need to expose the application to external consumers,
    selecting an appropriate Service type becomes crucial. The most practical choice
    often involves creating a Service of type LoadBalancer. Such a Service offers
    load balancing capabilities by assigning an external IP address accessible to
    consumers outside the Kubernetes cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: However, opting for a LoadBalancer Service for each externally reachable application
    has drawbacks. In a cloud provider environment, each Service triggers the provisioning
    of an external load balancer, resulting in increased costs. Additionally, managing
    a collection of LoadBalancer Service objects can lead to administrative challenges,
    as a new object must be established for each externally accessible microservice.
  prefs: []
  type: TYPE_NORMAL
- en: To mitigate these issues, the Ingress primitive comes into play, offering a
    singular, load-balanced entry point to an application stack. An Ingress possesses
    the ability to route external HTTP(S) requests to one or more Services within
    the cluster based on an optional, DNS-resolvable host name and URL context path.
    This chapter will guide you through the creation and access of an Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an Ingress in minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing an Ingress in minikube requires special handling. Refer to the Kubernetes
    tutorial [“Set up Ingress on Minikube with the NGINX Ingress Controller”](https://kubernetes.io/docs/tasks/access-application-cluster/ingress-minikube/)
    for detailed instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Ingresses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Ingress exposes HTTP (and optionally HTTPS) routes to clients outside of
    the cluster through an externally-reachable URL. The routing rules configured
    with the Ingress determine *how* the traffic should be routed. Cloud provider
    Kubernetes environments will often deploy an external load balancer. The Ingress
    receives a public IP address from the load balancer. You can configure rules for
    routing traffic to multiple Services based on specific URL context paths, as shown
    in [Figure 22-1](#ingress_traffic_routing).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 2201](Images/ckd2_2201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 22-1\. Managing external access to the Services via HTTP(S)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The scenario depicted in [Figure 22-1](#ingress_traffic_routing) instantiates
    an Ingress as the sole entry point for HTTP(S) calls to the domain name “next.example.com.”
    Based on the provided URL context, the Ingress directs the traffic to either of
    the fictional Services: one designed for a business application and the other
    for fetching metrics related to the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, the URL context path `/app` is routed to the App Service responsible
    for managing the business application. Conversely, sending a request to the URL
    context `/metrics` results in the call being forwarded to the Metrics Service,
    which is capable of returning relevant metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Installing an Ingress Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Ingress to function, an Ingress controller is essential. This controller
    assesses the set of rules outlined by an Ingress, dictating the routing of traffic.
    The choice of Ingress controller often depends on the specific use cases, requirements,
    and preferences of the Kubernetes cluster administrator. Noteworthy examples of
    production-grade Ingress controllers include the [F5 NGINX Ingress Controller](https://www.nginx.com/products/nginx-ingress-controller/)
    or the [AKS Application Gateway Ingress Controller](https://azure.github.io/application-gateway-kubernetes-ingress/).
    Additional options can be explored in the [Kubernetes documentation](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should find at least one Pod that runs the Ingress controller after installing
    it. This output renders the Pod created by the NGINX Ingress controller residing
    in the namespace `ingress-nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once the Ingress controller Pod transitions into the “Running” status, you can
    assume that the rules defined by Ingress objects will be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Multiple Ingress Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Certainly, deploying multiple Ingress controllers within a single cluster is
    a feasible option, especially if a cloud provider has preconfigured an Ingress
    controller in the Kubernetes cluster. The Ingress API introduces the attribute
    `spec.ingressClassName` to facilitate the selection of a specific controller implementation
    by name. To identify all installed Ingress classes, you can use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Kubernetes determines the default Ingress class by scanning for the annotation
    `ingressclass.kubernetes.io/is-default-class: "true"` within all Ingress class
    objects. In scenarios where Ingress objects do not explicitly specify an Ingress
    class using the attribute `spec.ingressClassName`, they automatically default
    to the Ingress class marked as the default through this annotation. This mechanism
    provides flexibility in managing Ingress classes and allows for a default behavior
    when no specific class is specified in individual Ingress objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Ingress Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating an Ingress, you have the flexibility to define one or multiple
    rules. Each rule encompasses the specification of an optional host, a set of URL
    context paths, and the backend responsible for routing the incoming traffic. This
    structure allows for fine-grained control over how external HTTP(S) requests are
    directed within the Kubernetes cluster, catering to different services based on
    specified conditions. [Table 22-1](#ingress_rules) describes the three rules.
  prefs: []
  type: TYPE_NORMAL
- en: Table 22-1\. Ingress rules
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Example | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| An optional host | `next.example.com` | If provided, the rules apply to that
    host. If no host is defined, all inbound HTTP(S) traffic is handled (e.g., if
    made through the IP address of the Ingress). |'
  prefs: []
  type: TYPE_TB
- en: '| A list of paths | `/app` | Incoming traffic must match the host and path
    to correctly forward the traffic to a Service. |'
  prefs: []
  type: TYPE_TB
- en: '| The backend | `app-service:8080` | A combination of a Service name and port.
    |'
  prefs: []
  type: TYPE_TB
- en: An Ingress controller can optionally define a default backend that is used as
    a fallback route should none of the configured Ingress rules match. You can learn
    more about it in the [documentation of the Ingress primitive](https://kubernetes.io/docs/concepts/services-networking/ingress/#default-backend).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Ingresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create an Ingress with the imperative `create ingress` command. The
    main command-line option you need to provide is `--rule`, which defines the rules
    in a comma-separated fashion. The notation for each key-value pair is `<host>/<path>=<service>:<port>`.
    Let’s create an Ingress object with two rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the output of the `create ingress --help` command, more fine-grained
    rules can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: Support for TLS termination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Port 80 for HTTP traffic is implied, as we didn’t specify a reference to a TLS
    Secret object. If you have specified `tls=mysecret` in the rule definition, then
    the port 443 would be listed here as well. For more information on enabling HTTPS
    traffic, see the [Kubernetes documentation](https://kubernetes.io/docs/concepts/services-networking/ingress/#tls).
    The exam does not cover configuring TLS termination for an Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: Using a YAML manifest to define Ingress is often more intuitive and preferred
    by many. It provides a clearer and more structured way to express the desired
    configuration. The Ingress defined as a YAML manifest is shown in [Example 22-1](#ingress_manifest).
  prefs: []
  type: TYPE_NORMAL
- en: Example 22-1\. An Ingress defined by a YAML manifest
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_ingresses_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Assigns a NGNIX ingress-specific annotation for rewriting the URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_ingresses_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the rule that maps the `app-service` backend to the URL *next.example.com/app*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_ingresses_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the rule that maps the `metrics-service` backend to the URL *next.example.com/metrics*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ingress YAML manifest contains one major difference from the live object
    representation created by the imperative command: the assignment of an Ingress
    controller annotation. Some Ingress controller implementations provide annotations
    to customize their behavior. You can find the full list of annotations that come
    with the NGINX Ingress controller in the [corresponding documentation](https://github.com/kubernetes/ingress-nginx/blob/main/docs/user-guide/nginx-configuration/annotations.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Path Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The previous YAML manifest demonstrates one of the options for specifying a
    path type via the attribute `spec.rules[].http.paths[].pathType`. The path type
    defines how an incoming request is evaluated against the declared path. [Table 22-2](#ingress_path_types)
    indicates the evaluation for incoming requests and their paths. See the [Kubernetes
    documentation](https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types)
    for a more comprehensive list.
  prefs: []
  type: TYPE_NORMAL
- en: Table 22-2\. Ingress path types
  prefs: []
  type: TYPE_NORMAL
- en: '| Path Type | Rule | Incoming Request |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Exact` | `/app` | Matches `/app` but does not match `/app/test` or `/app/`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Prefix` | `/app` | Matches `/app` and `/app/` but does not match `/app/test`
    |'
  prefs: []
  type: TYPE_TB
- en: The key distinction between the `Exact` and `Prefix` path types lies in their
    treatment of trailing slashes. The `Prefix` path type focuses solely on the provided
    prefix of a URL context path, allowing it to accommodate requests with URLs that
    include a trailing slash. In contrast, the `Exact` path type is more stringent,
    requiring an exact match of the specified URL context path without considering
    a trailing slash.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Ingresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Listing Ingresses can be achieved with the `get ingress` command. You will
    see some of the information you specified when creating the Ingress (e.g., the
    hosts):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The Ingress automatically selected the default Ingress class `nginx` configured
    by the Ingress controller. You can find the information under the `CLASS` column.
    The value listed under the `ADDRESS` columns is the IP address provided by the
    external load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Ingress Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `describe ingress` command is a valuable tool for obtaining detailed information
    about an Ingress resource. It presents the rules in a clear table format, which
    aids in understanding the routing configurations. Additionally, when troubleshooting,
    it’s essential to pay attention to any additional messages or events.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the provided output, it’s evident that there might be an issue with the
    Services named app-service and metrics-service that are mapped in the Ingress
    rules. This discrepancy between the specified services and their existence can
    lead to routing errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, observing the event log that shows syncing activity by the Ingress
    controller is crucial. Any warnings or errors in this log can provide insights
    into potential issues during the synchronization process.
  prefs: []
  type: TYPE_NORMAL
- en: To address the problem, ensure that the specified Services in the Ingress rules
    actually exist and are accessible within the Kubernetes cluster. Additionally,
    review the event log for any relevant messages that might indicate the cause of
    the discrepancy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s resolve the issue of not being able to route to the backends configured
    in the Ingress object. The following commands create the Pods and Services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting the Ingress object doesn’t show any errors for the configured rules.
    If you’re now able to see a list of resolvable backends along with the corresponding
    Pod virtual IP addresses and ports, the Ingress object is correctly configured,
    and the backends are recognized and accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth coming back to the Ingress details if you experience any issues with
    routing traffic through an Ingress endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing an Ingress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To enable the routing of incoming HTTP(S) traffic through the Ingress and subsequently
    to the configured Service, it’s crucial to set up a DNS entry mapping to the external
    address. This typically involves configuring either an A record or a CNAME record.
    The [ExternalDNS project](https://github.com/kubernetes-sigs/external-dns) is
    a valuable tool that can assist in managing these DNS records automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For local testing on a Kubernetes cluster on your machine, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the IP address of the load balancer used by the Ingress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the IP address to hostname mapping to your */etc/hosts* file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By adding the IP address to your local */etc/hosts* file, you simulate the
    DNS resolution locally, allowing you to test the behavior of the Ingress without
    relying on actual DNS records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now send HTTP requests to the backend. This call matches the `Exact`
    path rule and therefore returns a HTTP 200 response code from the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This next call uses a URL with a trailing slash. The Ingress path rule doesn’t
    support this case, and therefore the call doesn’t go through. You will receive
    a HTTP 404 response code. For the second call to work, you’d have to change the
    path rule to `Prefix`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can observe the same behavior for the Metrics Service configured with the
    URL context path `metrics`. Feel free to try that out as well.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The resource type Ingress defines rules for routing cluster-external HTTP(S)
    traffic to one or many Services. Each rule defines a URL context path to target
    a Service. For an Ingress to work, you first need to install an Ingress controller.
    An Ingress controller periodically evaluates those rules and ensures that they
    apply to the cluster. To expose the Ingress, a cloud provider usually stands up
    an external load balancer that lends an external IP address to the Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Know the difference between a Service and an Ingress
  prefs: []
  type: TYPE_NORMAL
- en: An Ingress is not to be confused with a Service. The Ingress is meant for routing
    cluster-external HTTP(S) traffic to one or many Services based on an optional
    hostname and mandatory path. A Service routes traffic to a set of Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the role of an Ingress controller
  prefs: []
  type: TYPE_NORMAL
- en: An Ingress controller needs to be installed before an Ingress can function properly.
    Without installing an Ingress controller, Ingress rules will have no effect. You
    can choose from a range of Ingress controller implementations, all documented
    on the Kubernetes documentation page. Assume that an Ingress controller will be
    preinstalled for you in the exam environment.
  prefs: []
  type: TYPE_NORMAL
- en: Practice the definition of Ingress rules
  prefs: []
  type: TYPE_NORMAL
- en: You can define one or many rules in an Ingress. Every rule consists of an optional
    host, the URL context path, and the Service DNS name and port. Try defining more
    than a single rule and how to access the endpoint. You will not have to understand
    the process for configuring TLS termination for an Ingress—this aspect is covered
    by the CKS exam.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_018.xhtml#appendix_a_ingresses).
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Deployment named `web` that controls a single replica running the
    image `bmuschko/nodejs-hello-world:1.0.0` on port 3000\. Expose the Deployment
    with a Service named `web` of type `ClusterIP`. The Service routes traffic to
    the Pods controlled by the Deployment `web`. Make a request to the endpoint of
    the application on the context path /. You should see the message “Hello World.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Ingress that exposes the path / for the host hello-world.exposed.
    The traffic should be routed to the Service created earlier. List the Ingress
    object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add an entry in */etc/hosts* that maps the load balancer IP address to the host
    hello-world.exposed. Make a request to [*http://hello-world.exposed*](http://hello-world.exposed).
    You should see the message “Hello World.”
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Any application has been exposed by an Ingress. Some of your end users report
    an issue with connecting to the application from outside of the cluster. Inspect
    the existing setup and fix the problem for your end users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch22/troubleshooting* of the checked-out GitHub
    repository [*bmuschko/ckad-study-guide*](https://github.com/bmuschko/ckad-study-guide).
    Create the objects from the YAML manifest *setup.yaml*. Inspect the objects in
    the namespace `s96`. Create an entry in */etc/hosts* for the hostname faulty.ingress.com.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Perform a HTTP call to faulty.ingress.com/ using `wget` or `curl`. Inspect the
    connection error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the configuration to ensure that end users can connect to the Ingress.
    Verify proper connectivity by performing another HTTP call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
