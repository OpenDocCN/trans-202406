<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 21. Services" class="praise"><div class="dedication" id="services">
<h1 class="calibre14"><span class="keep-together">Chapter 21. </span>Services</h1>


<p class="author1">In <a data-type="xref" href="ch05.xhtml#pod_network_communication" class="calibre10">“Using a Pod’s IP Address for Network Communication”</a>, we learned that you can communicate with a Pod by its IP address. A restart of a Pod will automatically assign a new virtual cluster IP address. Therefore, other parts of your system cannot rely on the Pod’s IP address if they need to talk to one another.</p>

<p class="author1">Building a microservices architecture, where each of the components runs in its own Pod with the need to communicate with each other through a stable network interface, requires a different primitive, the Service.</p>

<p class="author1">The Service implements an abstraction layer on top of Pods, assigning a fixed virtual IP fronting all the Pods with matching labels, and that virtual IP is called Cluster IP. This chapter will focus on the ins and outs of Services, and most importantly the exposure of Pods inside and outside of the cluster based on their declared type.</p>
<div data-type="warning" epub:type="warning" class="calibre28"><h1 class="calibre68">Accessing a Service in minikube</h1>
<p class="author1">Accessing Services of type <code class="calibre15">NodePort</code> and <code class="calibre15">LoadBalancer</code> in minikube requires special handling. Refer to the <a href="https://minikube.sigs.k8s.io/docs/handbook/accessing/#getting-the-nodeport-using-the-service-command" class="calibre10">documentation</a> for detailed instructions.</p>
</div>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id490">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objective:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Provide and troubleshoot access to applications via Services</p>
</li>
</ul>
</div></aside>






<section data-type="sect1" data-pdf-bookmark="Working with Services" class="praise"><div class="dedication" id="id400">
<h1 class="calibre17">Working with Services</h1>

<p class="author1">In a nutshell, Services provide discoverable names and load balancing to a set of Pods. The Service remains agnostic from IP addresses with the help of the Kubernetes DNS control-plane component, an aspect we’ll discuss in <a data-type="xref" href="Images/#discovering_service_by_dns_lookup" class="calibre10">“Discovering the Service by DNS lookup”</a>. Similar to a Deployment, the Service determines the Pods it works on with the help of label selection.</p>

<p class="author1"><a data-type="xref" href="#service_traffic_routing" class="calibre10">Figure 21-1</a> illustrates the functionality. Pod 1 receives traffic as its assigned label matches with the label selection defined in the Service. Pod 2 does not receive traffic as it defines a nonmatching label.</p>

<figure class="calibre35"><div id="service_traffic_routing" class="figure">
<img src="Images/ckd2_2101.png" alt="ckd2 2101" class="calibre106"/>
<h6 class="calibre32"><span class="keep-together">Figure 21-1. </span>Service traffic routing based on label selection</h6>
</div></figure>

<p class="author1">Note that it is possible to create a Service without a label selector to support other scenarios. Refer to the relevant <a href="https://kubernetes.io/docs/concepts/services-networking/service/#services-without-selectors" class="calibre10">Kubernetes documentation</a> for more information.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Services and Deployments</h1>
<p class="author1">Services are a complementary concept to Deployments. Services route network traffic to a set of Pods, and Deployments manage a set of Pods, the replicas. While you can use both concepts in isolation, it is recommended to use Deployments and Services together. The primary reason is the ability to scale the number of replicas and at the same time being able to expose an endpoint to funnel network traffic to those Pods.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Service Types" class="praise"><div class="dedication" id="id401">
<h2 class="calibre33">Service Types</h2>

<p class="author1">Every Service defines a type. The type is responsible for exposing the Service inside and/or outside of the cluster. <a data-type="xref" href="#service_types" class="calibre10">Table 21-1</a> lists the Service types relevant to the exam.</p>
<table id="service_types" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 21-1. </span>Service types</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Type</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><a href="#service_type_clusterip" class="calibre10"><code class="calibre60">ClusterIP</code></a></p></td>
<td class="calibre65"><p class="author1">Exposes the Service on a cluster-internal IP. Reachable only from within the cluster. Kubernetes uses a round-robin algorithm to distribute traffic evenly among the targeted Pods.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><a href="#service_type_nodeport" class="calibre10"><code class="calibre60">NodePort</code></a></p></td>
<td class="calibre65"><p class="author1">Exposes the Service on each node’s IP address at a static port. Accessible from outside of the cluster. The Service type does not provide any load balancing across multiple nodes.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><a href="#service_type_loadbalancer" class="calibre10"><code class="calibre60">Load</code> 
<span class="keep-together"><code class="calibre60">Balancer</code></span></a></p></td>
<td class="calibre65"><p class="author1">Exposes the Service externally using a cloud provider’s load balancer.</p></td>
</tr>
</tbody>
</table>

<p class="author1">Other Service types, e.g. <code class="calibre15">ExternalName</code> or the headless Service, can be defined; however, we’ll not address them in this book as they are not within the scope of the exam. For more information, refer to the <a href="https://kubernetes.io/docs/concepts/services-networking/service/" class="calibre10">Kubernetes documentation</a>.</p>










<section data-type="sect3" data-pdf-bookmark="Service type inheritance" class="praise"><div class="dedication" id="id402">
<h3 class="calibre44">Service type inheritance</h3>

<p class="author1">The Service types just mentioned, <code class="calibre15">ClusterIP</code>, <code class="calibre15">NodePort</code>, and <code class="calibre15">LoadBalancer</code>, make a Service accessible with different levels of exposure. It’s imperative to understand that those Service types also build on top of each other. <a data-type="xref" href="#service_type_layers" class="calibre10">Figure 21-2</a> shows the relationship between different Service types.</p>

<figure class="calibre35"><div id="service_type_layers" class="figure">
<img src="Images/ckd2_2102.png" alt="ckd2 2102" class="calibre107"/>
<h6 class="calibre32"><span class="keep-together">Figure 21-2. </span>Network accessibility characteristics for Service types</h6>
</div></figure>

<p class="author1">For example, creating a Service of type <code class="calibre15">NodePort</code> means that the Service will bear the network accessibility characteristics of a <code class="calibre15">ClusterIP</code> Service type as well. In turn, a <code class="calibre15">NodePort</code> Service is accessible from within and from outside of the cluster. This chapter demonstrates each Service type by example. You will find references to the inherited exposure behavior in the following sections.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="When to use which Service type?" class="praise"><div class="dedication" id="id403">
<h3 class="calibre44">When to use which Service type?</h3>

<p class="author1">When building a microservices architecture, the question arises which Service type to choose to implement certain use cases. We briefly discuss this question here.</p>

<p class="author1">The <code class="calibre15">ClusterIP</code> Service type is suitable for use cases that call for exposing a microservice to other Pods within the cluster. Say you have a frontend microservice that needs to connect to one or many backend microservices. To properly implement the scenario, you’d stand up a <code class="calibre15">ClusterIP</code> Service that routes traffic to the backend Pods. The frontend Pods would then talk to that Service.</p>

<p class="author1">The <code class="calibre15">NodePort</code> Service type is often mentioned as a way to expose an application to consumers external to the cluster. Consumers will have to know the node’s IP address and the statically assigned port to connect to the Service. That’s problematic for 
<span class="keep-together">multiple</span> reasons. First, the node port is usually allocated dynamically. Therefore, you won’t typically know it in advance. Second, providing the node’s IP address will funnel the network traffic only through a single node so you will not have load balancing at your disposal. Finally, by opening a publicly available node port, you are at risk of increasing the attack surface of your cluster. For all these reasons, a <code class="calibre15">NodePort</code> Service is primarily used for development or testing purposes, and less so in production 
<span class="keep-together">environments.</span></p>

<p class="author1">The <code class="calibre15">LoadBalancer</code> Service type makes the application available to outside consumers through an external IP address provided by an external load balancer. Network traffic will be distributed across multiple nodes in the cluster. This solution works great for production environments, but keep in mind that every provisioned load balancer will accrue costs and can lead to an expensive infrastructure bill. A more cost-effective solution is the use of an Ingress, discussed in <a data-type="xref" href="ch22.xhtml#ingresses" class="calibre10">Chapter 22</a>.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Port Mapping" class="praise"><div class="dedication" id="id404">
<h2 class="calibre33">Port Mapping</h2>

<p class="author1">A Service uses label selection to determine the set of Pods to forward traffic to. Successful routing of network traffic depends on the port mapping.</p>

<p class="author1"><a data-type="xref" href="#service_port_mapping" class="calibre10">Figure 21-3</a> shows a Service that accepts incoming traffic on port 80. That’s the port defined by the attribute <code class="calibre15">spec.ports[].port</code> in the manifest. Any incoming traffic is then routed toward the target port, represented by <code class="calibre15">spec.ports[].targetPort</code>.</p>

<figure class="calibre35"><div id="service_port_mapping" class="figure">
<img src="Images/ckd2_2103.png" alt="ckd2 2103" class="calibre108"/>
<h6 class="calibre32"><span class="keep-together">Figure 21-3. </span>Service port mapping</h6>
</div></figure>

<p class="author1">The target port is the same port as defined by the container with <code class="calibre15">spec.containers[].ports[].containerPort</code> running inside the label-selected Pod. In this example, that’s port 8080. The selected Pod(s) will receive traffic only if the Service’s target port and the container port match.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating Services" class="praise"><div class="dedication" id="id405">
<h2 class="calibre33">Creating Services</h2>

<p class="author1">You can create Services in a variety of ways, some of which are more appropriate for the exam as they provide a fast turnaround. Let’s discuss the imperative approach first.</p>

<p class="author1">A Service needs to select a Pod by a matching label. The Pod created by the following <code class="calibre15">run</code> command is called <code class="calibre15">echoserver</code>, which exposes the application on the container port 8080. Internally, it automatically assigns the label key-value pair <code class="calibre15">run=echoserver</code> to the object:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl run echoserver --image=k8s.gcr.io/echoserver:1.10 --restart=Never</strong> \
  <strong class="calibre38">--port=8080</strong>
pod/echoserver created</pre>

<p class="author1">You can create a Service object using the <code class="calibre15">create service</code> command. Make sure to provide the Service type as a mandatory argument. Here we are using the type <code class="calibre15">clusterip</code>. The command-line option <code class="calibre15">--tcp</code> specifies the port mapping. Port 80 exposes the Service to incoming network traffic. Port 8080 targets the container port exposed by the Pod:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create service clusterip echoserver --tcp=80:8080</strong>
service/echoserver created</pre>

<p class="author1">An even faster workflow of creating a Pod and Service together can be achieved with a <code class="calibre15">run</code> command and the <code class="calibre15">--expose</code> option. The following command creates both objects in one swoop while establishing the proper label selection. This command-line option is a good choice during the exam to save time if you are asked to create a Pod and a Service:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl run echoserver --image=k8s.gcr.io/echoserver:1.10 --restart=Never</strong> \
  <strong class="calibre38">--port=8080 --expose</strong>
service/echoserver created
pod/echoserver created</pre>

<p class="author1">It’s actually more common to use a Deployment and Service that work together. The following set of commands creates a Deployment with five replicas and then uses the <code class="calibre15">expose deployment</code> command to instantiate the Service object. The port mapping can be provided with the options <code class="calibre15">--port</code> and <code class="calibre15">--target-port</code>:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create deployment echoserver --image=k8s.gcr.io/echoserver:1.10</strong> \
  <strong class="calibre38">--replicas=5</strong>
deployment.apps/echoserver created
<strong class="calibre38">$ kubectl expose deployment echoserver --port=80 --target-port=8080</strong>
service/echoserver exposed</pre>

<p class="author1"><a data-type="xref" href="#service_manifest" class="calibre10">Example 21-1</a> shows the representation of a Service in the form of a YAML manifest. The Service declares the key-value <code class="calibre15">app=echoserver</code> for label selection and defines the port mapping from 80 to 8080.</p>
<div id="service_manifest" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 21-1. </span>A Service defined by a YAML manifest</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Service</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">echoserver</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">run</code><code class="p">:</code><code class="w"> </code><code class="calibre15">echoserver</code><code class="w">    </code><a class="calibre10" id="co_services_CO1-1" href="#callout_services_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w">               </code><a class="calibre10" id="co_services_CO1-2" href="#callout_services_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre15">80</code><code class="w">
</code><code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_services_CO1-1" href="#co_services_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Selects all Pods with the given label assignment.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_services_CO1-2" href="#co_services_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Defines incoming and outgoing ports of the Service. The outgoing port needs to match the container port of the selected Pods.</p></dd>
</dl>

<p class="author1">The Service YAML manifest shown does not assign an explicit type. A Service object that does not specify a value for the attribute <code class="calibre15">spec.type</code> will default to <code class="calibre15">ClusterIP</code> upon creation.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Listing Services" class="praise"><div class="dedication" id="id406">
<h2 class="calibre33">Listing Services</h2>

<p class="author1">Listing all Services presents a table view that includes the Service type, the cluster IP address, an optional external IP address, and the incoming port(s). Here, you can see the output for the <code class="calibre15">echoserver</code> Pod we created earlier:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get services</strong>
NAME         TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)   AGE
echoserver   ClusterIP   10.109.241.68   &lt;none&gt;        80/TCP    6s</pre>

<p class="author1">Kubernetes assigns a cluster IP address given that the Service type is <code class="calibre15">ClusterIP</code>. An external IP address is not available for this Service type. The Service is accessible on port 80.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Rendering Service Details" class="praise"><div class="dedication" id="id407">
<h2 class="calibre33">Rendering Service Details</h2>

<p class="author1">You may want to drill into the details of a Service for troubleshooting purposes. That might be the case if the incoming traffic to a Service isn’t routed properly to the set of Pods you expect to handle the request.</p>

<p class="author1">The <code class="calibre15">describe service</code> command renders valuable information about the configuration of a Service. The configuration relevant to troubleshooting a Service is the value of the fields Selector, IP, Port, TargetPort, and Endpoints. A common source of misconfiguration is incorrect label selection and port assignment. Make sure that the selected labels are actually available in the Pods intended to route traffic to and that the target port of the Service matches the exposed container port of the Pods.</p>

<p class="author1">Take a look at the output of the following <code class="calibre15">describe</code> command. It’s the details for a Service created for five Pods controlled by a Deployment. The Endpoints attribute lists a range of endpoints, one for each of the Pods:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl describe service echoserver</strong>
Name:              echoserver
Namespace:         default
Labels:            app=echoserver
Annotations:       &lt;none&gt;
Selector:          app=echoserver
Type:              ClusterIP
IP Family Policy:  SingleStack
IP Families:       IPv4
IP:                10.109.241.68
IPs:               10.109.241.68
Port:              &lt;unset&gt;  80/TCP
TargetPort:        8080/TCP
Endpoints:         172.17.0.4:8080,172.17.0.5:8080,172.17.0.7:8080 + 2 more...
Session Affinity:  None
Events:            &lt;none&gt;</pre>

<p class="author1">An endpoint is a resolvable network endpoint, which serves as the virtual IP address and container port of a Pod. If a Service does not render any endpoints then you are likely dealing with a misconfiguration.</p>

<p class="author1">Kubernetes represents endpoints by a dedicated primitive that you can query for. The Endpoint object is created at the same time you instantiate the Service object. The following command lists the endpoints for the Service named <code class="calibre15">echoserver</code>:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get endpoints echoserver</strong>
NAME         ENDPOINTS                                                     AGE
echoserver   172.17.0.4:8080,172.17.0.5:8080,172.17.0.7:8080 + 2 more...   8m5s</pre>

<p class="author1">The details of the endpoints give away the full list of IP addresses and ports 
<span class="keep-together">combinations:</span></p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl describe endpoints echoserver</strong>
Name:         echoserver
Namespace:    default
Labels:       app=echoserver
Annotations:  endpoints.kubernetes.io/last-change-trigger-time: \
              2021-11-15T19:09:04Z
Subsets:
  Addresses:          172.17.0.4,172.17.0.5,172.17.0.7,172.17.0.8,172.17.0.9
  NotReadyAddresses:  &lt;none&gt;
  Ports:
    Name     Port  Protocol
    ----     ----  --------
    &lt;unset&gt;  8080  TCP

Events:  &lt;none&gt;</pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The ClusterIP Service Type" class="praise"><div class="dedication" id="service_type_clusterip">
<h1 class="calibre17">The ClusterIP Service Type</h1>

<p class="author1"><code class="calibre15">ClusterIP</code> is the default Service type. It exposes the Service on a cluster-internal IP address. That means the Service can be accessed only from a Pod running inside of the cluster and not from outside of the cluster (e.g., if you were to make a call to the Service from your local machine). <a data-type="xref" href="#service_clusterip" class="calibre10">Figure 21-4</a> illustrates the accessibility of a Service with type <code class="calibre15">ClusterIP</code>.</p>

<figure class="calibre35"><div id="service_clusterip" class="figure">
<img src="Images/ckd2_2104.png" alt="ckd2 2104" class="calibre109"/>
<h6 class="calibre32"><span class="keep-together">Figure 21-4. </span>Accessibility of a Service with the type <code class="calibre15">ClusterIP</code></h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="Creating and Inspecting the Service" class="praise"><div class="dedication" id="id409">
<h2 class="calibre33">Creating and Inspecting the Service</h2>

<p class="author1">We will create a Pod and a corresponding Service to demonstrate the runtime behavior of the <code class="calibre15">ClusterIP</code> Service type. The Pod named <code class="calibre15">echoserver</code> exposes the container port 8080 and specifies the label <code class="calibre15">app=echoserver</code>. The Service defines port 5005 for incoming traffic, which is forwarded to outgoing port 8080. The label selection matches the Pod we set up:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl run echoserver --image=k8s.gcr.io/echoserver:1.10 --restart=Never</strong> \
  <strong class="calibre38">--port=8080 -l app=echoserver</strong>
pod/echoserver created
<strong class="calibre38">$ kubectl create service clusterip echoserver --tcp=5005:8080</strong>
service/echoserver created</pre>

<p class="author1">Inspecting the live object with the command <code class="calibre15">kubectl get service echoserver -o yaml</code> will the render the assigned cluster IP address. <a data-type="xref" href="#service_clusterip2" class="calibre10">Example 21-2</a> shows a abbreviated version of the Service runtime representation.</p>
<div id="service_clusterip2" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 21-2. </span>A ClusterIP Service object at runtime</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Service</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">echoserver</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ClusterIP</code><code class="w">          </code><a class="calibre10" id="co_services_CO2-1" href="#callout_services_CO2-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">clusterIP</code><code class="p">:</code><code class="w"> </code><code class="calibre15">10.96.254.0</code><code class="w">   </code><a class="calibre10" id="co_services_CO2-2" href="#callout_services_CO2-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">echoserver</code><code class="w">
</code><code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre15">5005</code><code class="w">
</code><code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w">
</code><code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="calibre15">TCP</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_services_CO2-1" href="#co_services_CO2-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The Service type set to <code class="calibre15">ClusterIP</code>.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_services_CO2-2" href="#co_services_CO2-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The cluster IP address assigned to the Service at runtime.</p></dd>
</dl>

<p class="author1">The cluster IP address that makes the Service available in this example is <code class="calibre15">10.96.254.0</code>. Listing the Service object is an alternative way to render the information we need to make a call to the Service:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get service echoserver</strong>
NAME         TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)    AGE
echoserver   ClusterIP   10.96.254.0   &lt;none&gt;        5005/TCP   8s</pre>

<p class="author1">Next up, we’ll try to make a call to the Service.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Accessing the Service" class="praise"><div class="dedication" id="id410">
<h2 class="calibre33">Accessing the Service</h2>

<p class="author1">You can access the Service using a combination of the cluster IP address and the incoming port: 10.96.254.0:5005. Making a request from any other machine residing outside of the cluster will fail, as illustrated by the following <code class="calibre15">wget</code> command:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ wget 10.96.254.0:5005 --timeout=5 --tries=1</strong>
--2021-11-15 15:45:36--  http://10.96.254.0:5005/
Connecting to 10.96.254.0:5005... ]failed: Operation timed out.
Giving up.</pre>

<p class="author1">Accessing the Service from a Pod from within the cluster properly routes the request to the Pod matching the label selection:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run tmp --image=busybox:1.36.1 --restart=Never -it --rm</strong> \
  <strong class="calibre38">-- wget 10.96.254.0:5005</strong>
Connecting to 10.96.254.0:5005 (10.96.254.0:5005)
saving to 'index.html'
index.html           100% |********************************|   408  0:00:00 ETA
'index.html' saved
pod "tmp" deleted
</pre>

<p class="author1">Apart from using the cluster IP address and the port, you can also discover a Service by DNS name and environment variables available to containers.</p>










<section data-type="sect3" data-pdf-bookmark="Discovering the Service by DNS lookup" class="praise"><div class="dedication" id="discovering_service_by_dns_lookup">
<h3 class="calibre44">Discovering the Service by DNS lookup</h3>

<p class="author1">Kubernetes registers every Service by its name with the help of its DNS service named CoreDNS. Internally, CoreDNS will store the Service name as a hostname and maps it to the cluster IP address. Accessing a Service by its DNS name instead of an IP address is much more convenient and expressive when building microservice 
<span class="keep-together">architectures.</span></p>

<p class="author1">You can verify the correct service discovery by running a Pod in the same namespace that makes a call to the Service by using its hostname and incoming port:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run tmp --image=busybox:1.36.1 --restart=Never -it --rm</strong> \
  <strong class="calibre38">-- wget echoserver:5005</strong>
Connecting to echoserver:5005 (10.96.254.0:5005)
saving to 'index.html'
index.html           100% |********************************|   408  0:00:00 ETA
'index.html' saved
pod "tmp" deleted
</pre>

<p class="author1">It’s not uncommon to make a call from a Pod to a Service that lives in a different namespace. Referencing just the hostname of the Service does not work across namespaces. You need to append the namespace as well. The following makes a call from a Pod in the <code class="calibre15">other</code> namespace to the Service in the <code class="calibre15">default</code> namespace:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run tmp --image=busybox:1.36.1 --restart=Never -it --rm</strong> \
  <strong class="calibre38">-n other -- wget echoserver.default:5005</strong>
Connecting to echoserver.default:5005 (10.96.254.0:5005)
saving to 'index.html'
index.html           100% |********************************|   408  0:00:00 ETA
'index.html' saved
pod "tmp" deleted
</pre>

<p class="author1">The full hostname for a Service is <code class="calibre15">echoserver.default.svc.cluster.local</code>. The string <code class="calibre15">svc</code> describes the type of resource we are communicating with. CoreDNS uses the default value <code class="calibre15">cluster.local</code> as a domain name (which is configurable if you want to change it). You do not have to spell out the full hostname when communicating with a Service.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Discovering the Service by environment variables" class="praise"><div class="dedication" id="id412">
<h3 class="calibre44">Discovering the Service by environment variables</h3>

<p class="author1">You may find it easier to use the Service connection information directly from the application running in a Pod. The kubelet makes the cluster IP address and port for every active Service available as environment variables. The naming convention for Service-related environments variable are <code class="calibre15">&lt;SERVICE_NAME&gt;_SERVICE_HOST</code> and <code class="calibre15">&lt;SERVICE_NAME&gt;_SERVICE_PORT</code>.</p>
<div data-type="warning" epub:type="warning" class="calibre28"><h1 class="calibre68">Availability of Service environment variables</h1>
<p class="author1">Make sure you create the Service before instantiating the Pod. Otherwise, those environment variables won’t be populated.</p>
</div>

<p class="author1">You can check on the actual key-value pairs by listing the environment variables of the container, as follows:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl exec -it echoserver -- env</strong>
ECHOSERVER_SERVICE_HOST=10.96.254.0
ECHOSERVER_SERVICE_PORT=8080
...
</pre>

<p class="author1">The name of the Service, <code class="calibre15">echoserver</code>, does not include any special characters. That’s why the conversion to the environment variable key is easy; the Service name was simply upper-cased to conform to environment variable naming conventions. Any special characters (such as dashes) in the Service name will be replaced by underscore characters. You need to make sure that the Service has been created before starting a Pod if you want those environment variables populated.</p>
</div></section>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The NodePort Service Type" class="praise"><div class="dedication" id="service_type_nodeport">
<h1 class="calibre17">The NodePort Service Type</h1>

<p class="author1">Declaring a Service with type <code class="calibre15">NodePort</code> exposes access through the node’s IP address and can be resolved from outside of the Kubernetes cluster. The node’s IP address can be reached in combination with a port number in the range of 30000 and 32767 (also called the node port), assigned automatically upon the creation of the Service. <a data-type="xref" href="#service_nodeport" class="calibre10">Figure 21-5</a> illustrates the routing of traffic to Pods via a <code class="calibre15">NodePort</code>-type Service.</p>

<figure class="calibre35"><div id="service_nodeport" class="figure">
<img src="Images/ckd2_2105.png" alt="ckd2 2105" class="calibre110"/>
<h6 class="calibre32"><span class="keep-together">Figure 21-5. </span>Accessibility of a Service with the type <code class="calibre15">NodePort</code></h6>
</div></figure>

<p class="author1">The node port is opened on every node in the cluster, and its value is global and unique at the cluster-scope level. To avoid port conflicts, it’s best to not define the exact node port and to let Kubernetes find an available port.</p>








<section data-type="sect2" data-pdf-bookmark="Creating and Inspecting the Service" class="praise"><div class="dedication" id="id414">
<h2 class="calibre33">Creating and Inspecting the Service</h2>

<p class="author1">The next two commands create a Pod and a Service of type <code class="calibre15">NodePort</code>. The only difference here is that <code class="calibre15">nodeport</code> is provided instead of <code class="calibre15">clusterip</code> as a command-line option:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl run echoserver --image=k8s.gcr.io/echoserver:1.10 --restart=Never</strong> \
  <strong class="calibre38">--port=8080 -l app=echoserver</strong>
pod/echoserver created
<strong class="calibre38">$ kubectl create service nodeport echoserver --tcp=5005:8080</strong>
service/echoserver created</pre>

<p class="author1">The runtime representation of the Service object is shown in <a data-type="xref" href="#service_nodeport2" class="calibre10">Example 21-3</a>. It’s important to point out that the node port will be assigned automatically. Keep in mind <code class="calibre15">NodePort</code> (capital <em class="calibre3">N</em>) is the Service type, whereas <code class="calibre15">nodePort</code> (lowercase <em class="calibre3">n</em>) is the key for the value.</p>
<div id="service_nodeport2" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 21-3. </span>A NodePort Service object at runtime</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Service</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">echoserver</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">NodePort</code><code class="w">           </code><a class="calibre10" id="co_services_CO3-1" href="#callout_services_CO3-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">clusterIP</code><code class="p">:</code><code class="w"> </code><code class="calibre15">10.96.254.0</code><code class="w">
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">echoserver</code><code class="w">
</code><code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre15">5005</code><code class="w">
</code><code class="w">    </code><code class="nt">nodePort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">30158</code><code class="w">        </code><a class="calibre10" id="co_services_CO3-2" href="#callout_services_CO3-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w">
</code><code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="calibre15">TCP</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_services_CO3-1" href="#co_services_CO3-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The Service type set to <code class="calibre15">NodePort</code>.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_services_CO3-2" href="#co_services_CO3-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The statically-assigned node port that makes the Service accessible from outside of the cluster.</p></dd>
</dl>

<p class="author1">Once the Service is created, you can list it. You will find that the port representation contains the statically assigned port that makes the Service accessible:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get service echoserver</strong>
NAME         TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
echoserver   NodePort    10.101.184.152   &lt;none&gt;        5005:30158/TCP   5s</pre>

<p class="author1">In this output, the node port is 30158 (identifiable by the separating colon). The incoming port 5005 is still available for the purpose of resolving the Service from within the cluster.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Accessing the Service" class="praise"><div class="dedication" id="id415">
<h2 class="calibre33">Accessing the Service</h2>

<p class="author1">From within the cluster, you can still access the Service using the cluster IP address and port number. This Service displays exactly the same behavior as if it were of type <code class="calibre15">ClusterIP</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run tmp --image=busybox:1.36.1 --restart=Never -it --rm</strong> \
  <strong class="calibre38">-- wget 10.101.184.152:5005</strong>
Connecting to 10.101.184.152:5005 (10.101.184.152:5005)
saving to 'index.html'
index.html           100% |********************************|   414  0:00:00 ETA
'index.html' saved
pod "tmp" deleted
</pre>

<p class="author1">From outside of the cluster, you need to use the IP address of any worker node in the cluster and the statically assigned port. One way to determine the worker node’s IP address is by rendering the node details. Another option is to use the <code class="calibre15">status.hostIP</code> attribute value of a Pod, which is the IP address of the worker node the Pod runs on.</p>

<p class="author1">The node IP address here is <code class="calibre15">192.168.64.15</code>. It can be used to call the Service from outside of the cluster:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get nodes -o</strong> \
  <strong class="calibre38">jsonpath='{ $.items[*].status.addresses[?(@.type=="InternalIP")].address }'</strong>
192.168.64.15
<strong class="calibre38">$ wget 192.168.64.15:30158</strong>
--2021-11-16 14:10:16--  http://192.168.64.15:30158/
Connecting to 192.168.64.15:30158... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/plain]
Saving to: ‘index.html’
...
</pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The LoadBalancer Service Type" class="praise"><div class="dedication" id="service_type_loadbalancer">
<h1 class="calibre17">The LoadBalancer Service Type</h1>

<p class="author1">The last Service type to discuss in this book is the <code class="calibre15">LoadBalancer</code>. This Service type provisions an external load balancer, primarily available to Kubernetes cloud providers, which exposes a single IP address to distribute incoming requests to the cluster nodes. The implementation of the load balancing strategy (e.g., round robin) is up to the cloud provider.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Load balancers for on-premises Kubernetes clusters</h1>
<p class="author1">Kubernetes does not offer a native load balancer solution for on-premises clusters. Cloud providers are in charge of providing an appropriate implementation. The <a href="https://metallb.universe.tf/" class="calibre10">MetalLB project</a> aims to fill the gap.</p>
</div>

<p class="author1"><a data-type="xref" href="#service_loadbalancer" class="calibre10">Figure 21-6</a> shows an architectural overview of the <code class="calibre15">LoadBalancer</code> Service type.</p>

<figure class="calibre35"><div id="service_loadbalancer" class="figure">
<img src="Images/ckd2_2106.png" alt="ckd2 2106" class="calibre111"/>
<h6 class="calibre32"><span class="keep-together">Figure 21-6. </span>Accessibility of a Service with the type <code class="calibre15">LoadBalancer</code></h6>
</div></figure>

<p class="author1">As you can see from the illustration, the load balancer routes traffic between different nodes, as long as the targeted Pods fulfill the requested label selection.</p>








<section data-type="sect2" data-pdf-bookmark="Creating and Inspecting the Service" class="praise"><div class="dedication" id="id417">
<h2 class="calibre33">Creating and Inspecting the Service</h2>

<p class="author1">To create a Service as a load balancer, set the type to <code class="calibre15">LoadBalancer</code> in the manifest or by using the <code class="calibre15">create service loadbalancer</code> command:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl run echoserver --image=k8s.gcr.io/echoserver:1.10 --restart=Never</strong> \
  <strong class="calibre38">--port=8080 -l app=echoserver</strong>
pod/echoserver created
 <strong class="calibre38">$ kubectl create service loadbalancer echoserver --tcp=5005:8080</strong>
service/echoserver created</pre>

<p class="author1">The runtime characteristics of a LoadBalancer Service type look similar to the ones provided by the NodePort Service type. The main difference is that the external IP address column has a value, as shown in <a data-type="xref" href="#service_loadbalancer2" class="calibre10">Example 21-4</a>.</p>
<div id="service_loadbalancer2" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 21-4. </span>A LoadBalancer Service object at runtime</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Service</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">echoserver</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">LoadBalancer</code><code class="w">            </code><a class="calibre10" id="co_services_CO4-1" href="#callout_services_CO4-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">clusterIP</code><code class="p">:</code><code class="w"> </code><code class="calibre15">10.96.254.0</code><code class="w">
</code><code class="w">  </code><code class="nt">loadBalancer</code><code class="p">:</code><code class="w"> </code><code class="calibre15">10.109.76.157</code><code class="w">   </code><a class="calibre10" id="co_services_CO4-2" href="#callout_services_CO4-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">echoserver</code><code class="w">
</code><code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre15">5005</code><code class="w">
</code><code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w">
</code><code class="w">    </code><code class="nt">nodePort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">30158</code><code class="w">
</code><code class="w">    </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="calibre15">TCP</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_services_CO4-1" href="#co_services_CO4-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The Service type set to <code class="calibre15">LoadBalancer</code>.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_services_CO4-2" href="#co_services_CO4-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">The external IP address assigned to the Service at runtime.</p></dd>
</dl>

<p class="author1">Listing the Service renders the external IP address, which is <code class="calibre15">10.109.76.157</code>, as demonstrated by this command:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get service echoserver</strong>
NAME         TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)          AGE
echoserver   LoadBalancer   10.109.76.157   10.109.76.157   5005:30642/TCP   5s</pre>

<p class="author1">Given that the external load balancer needs to be provisioned by the cloud provider, it may take a little time until the external IP address becomes available.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Accessing the Service" class="praise"><div class="dedication" id="id418">
<h2 class="calibre33">Accessing the Service</h2>

<p class="author1">To call the Service from outside of the cluster, use the external IP address and its incoming port:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ wget 10.109.76.157:5005</strong>
--2021-11-17 11:30:44--  http://10.109.76.157:5005/
Connecting to 10.109.76.157:5005... connected.
HTTP request sent, awaiting response... 200 OK
Length: unspecified [text/plain]
Saving to: ‘index.html’
...</pre>

<p class="author1">As discussed, a <code class="calibre15">LoadBalancer</code> Service is also accessible in the same way as you would access a <code class="calibre15">ClusterIP</code> or <code class="calibre15">NodePort</code> Service.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id419">
<h1 class="calibre17">Summary</h1>

<p class="author1">Kubernetes assigns a unique IP address for every Pod in the cluster. Pods can communicate with each other using that IP address; however, you cannot rely on the IP address to be stable over time. That’s why Kubernetes provides the Service resource type.</p>

<p class="author1">A Service forwards network traffic to a set of Pods based on label selection and port mappings. Every Service needs to assign a type that determines how the Service becomes accessible from within or outside of the cluster. The Service types relevant to the exam are <code class="calibre15">ClusterIP</code>, <code class="calibre15">NodePort</code>, and <code class="calibre15">LoadBalancer</code>. CoreDNS, the DNS server for Kubernetes, allows Pods to access the Service by hostname from the same and other namespaces.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id420">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Understand the purpose of a Service</dt>
<dd class="calibre20">
<p class="calibre21">Pod-to-Pod communication via their IP addresses doesn’t guarantee a stable network interface over time. A restart of the Pod will lease a new virtual IP address. The purpose of a Service is to provide that stable network interface so that you can operate complex microservice architecture that runs in a Kubernetes cluster. In most cases, Pods call a Service by hostname. The hostname is provided by the DNS server named CoreDNS running as a Pod in the <code class="calibre15">kube-system</code> namespace.</p>
</dd>
<dt class="calibre19">Practice how to access a Service for each type</dt>
<dd class="calibre20">
<p class="calibre21">The exam expects you to understand the differences between the Service types <code class="calibre15">ClusterIP</code>, <code class="calibre15">NodePort</code>, and <code class="calibre15">LoadBalancer</code>. Depending on the assigned type, a Service becomes accessible from inside the cluster or from outside the cluster.</p>
</dd>
<dt class="calibre19">Work through Service troubleshooting scenarios</dt>
<dd class="calibre20">
<p class="calibre21">It’s easy to get the configuration of a Service wrong. Any misconfiguration won’t allow network traffic to reach the set of Pod it was intended for. Common misconfigurations include incorrect label selection and port assignments. The <code class="calibre15">kubectl get endpoints</code> command will give you an idea which Pods a Service can route traffic to.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id421">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_017.xhtml#appendix_a_services" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Create a Service named <code class="calibre15">myapp</code> of type <code class="calibre15">ClusterIP</code> that exposes port 80 and maps to the target port 80.</p>

<p class="author1">Create a Deployment named <code class="calibre15">myapp</code> that creates 1 replica running the image <code class="calibre15">nginx:1.23.4-alpine</code>. Expose the container port 80. Scale the Deployment to 2 replicas.</p>

<p class="author1">Create a temporary Pod using the image <code class="calibre15">busybox:1.36.1</code> and execute a <code class="calibre15">wget</code> command against the IP of the service.</p>

<p class="author1">Change the service type to <code class="calibre15">NodePort</code> so that the Pods can be reached from outside of the cluster. Execute a <code class="calibre15">wget</code> command against the service from outside of the cluster.</p>
</li>
<li class="calibre56">
<p class="author1">Kate is a developer in charge of implementing a web-based application stack. She is not familiar with Kubernetes, and asked if you could help out. The relevant objects have been created; however, connection to the application cannot be established from within the cluster. Help Kate with fixing the configuration of her YAML manifests.</p>

<p class="author1">Navigate to the directory <em class="calibre3">app-a/ch21/troubleshooting</em> of the checked-out GitHub repository <a href="https://github.com/bmuschko/ckad-study-guide" class="calibre10"><em class="calibre3">bmuschko/ckad-study-guide</em></a>. Create the objects from the YAML manifest <em class="calibre3">setup.yaml</em>. Inspect the objects in the namespace <code class="calibre15">y72</code>.</p>

<p class="author1">Create a temporary Pod using the image <code class="calibre15">busybox:1.36.1</code> in the namespace <code class="calibre15">y72</code>. The container command should make a <code class="calibre15">wget</code> call to the Service <code class="calibre15">web-app</code>. The <code class="calibre15">wget</code> call will not be able to establish a successful connection to the Service.</p>

<p class="author1">Identify the root cause for the connection issue and fix it. Verify the correct behavior by repeating the previous step. The <code class="calibre15">wget</code> call should return a successful response.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>