- en: Chapter 7\. eBPF Program and Attachment Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapters you saw lots of examples of eBPF programs, and you
    probably spotted the fact that they are attached to different types of events.
    Some of the examples I’ve shown attach to kprobes, but in other examples I’ve
    demonstrated XDP programs that handle a newly arrived network packet. These are
    just two of the many attachment points within the kernel. In this chapter we’ll
    take a deeper look at different program types and how they can be attached to
    different events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can build and run the examples from this chapter using the code and instructions
    at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
    The code for this chapter is in the *chapter7* directory.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, some of the examples are not supported on ARM processors.
    Check out the *README* file in the *chapter7* directory for more details and advice.
  prefs: []
  type: TYPE_NORMAL
- en: There are currently around 30 program types enumerated in [*uapi/linux/bpf.h*](https://oreil.ly/6dNIW),
    and more than 40 attachment types. The attachment type defines more specifically
    where the program gets attached; for lots of program types, the attachment type
    can be inferred from the program type, but some program types can be attached
    to multiple different points in the kernel, so an attachment type has to be specified
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, this book isn’t intended to be a reference manual, so I won’t cover
    every single eBPF program type. There’s a good chance that new types will have
    been added by the time you read this book anyway!
  prefs: []
  type: TYPE_NORMAL
- en: Program Context Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All eBPF programs take a context argument that is a pointer, but the structure
    it points to depends on the type of event that triggered it. eBPF programmers
    need to write programs that accept the appropriate type of context; there is no
    point in pretending that the context argument points to a network packet if the
    event is, say, a tracepoint. Defining different types of programs allows the verifier
    to ensure that the contextual information is handled appropriately and to enforce
    rules about what helper functions are permissible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To dive into the details of the context data passed to different BPF program
    types, check out [this post by Alan Maguire on Oracle’s blog](https://oreil.ly/6dNIW).
  prefs: []
  type: TYPE_NORMAL
- en: Helper Functions and Return Codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, the verifier checks that all helper functions
    used by a program are compatible with its program type. The example in the previous
    chapter demonstrated that the `bpf_get_current_pid_tgid()` helper function isn’t
    permitted in an XDP program. There is no user space process or thread involved
    at the point where a packet is received and the XDP hook is triggered, so a call
    to discover the current process and thread ID doesn’t make sense in that context.
  prefs: []
  type: TYPE_NORMAL
- en: The program type also determines the meaning of the return code from the program.
    Again using XDP as an example, the return code value tells the kernel what to
    do with the packet once the eBPF program has finished processing it—which could
    involve passing it to the network stack, dropping it, or redirecting it to a different
    interface. These return codes wouldn’t make any sense when an eBPF program is
    triggered by, say, hitting a particular tracepoint, where there is no network
    packet involved.
  prefs: []
  type: TYPE_NORMAL
- en: There is a [manpage for helper functions](https://oreil.ly/e8K73) (with, quite
    reasonably, disclaimers that it might not be complete due to the ongoing development
    of the BPF subsystem).
  prefs: []
  type: TYPE_NORMAL
- en: You can get a list of which helper functions are available for each program
    type in your version of the kernel with the `bpftool feature` command. This shows
    the system configuration and lists all the available program types and map types,
    and even lists all the helper functions that are supported for each program type.
  prefs: []
  type: TYPE_NORMAL
- en: Helper functions are considered part of the *UAPI*, the Linux kernel’s external,
    stable interface. As such, once a helper function has been defined in the kernel,
    it shouldn’t change in the future, even though the kernel’s internal functions
    and data structures can change.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the risk of changes between kernel versions, there was demand from eBPF
    programmers to be able to access some internal functions from eBPF programs. This
    can be achieved using the mechanism called *BPF kernel functions*, or [*kfuncs*](https://oreil.ly/gKSEx)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Kfuncs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kfuncs allow internal kernel functions to be registered with the BPF subsystem
    so that the verifier will allow them to be called from eBPF programs. There is
    a registration for each eBPF program type that is permitted to call a given kfunc.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike helper functions, kfuncs don’t provide compatibility guarantees, so an
    eBPF programmer has to consider the possibility of changes between kernel versions.
  prefs: []
  type: TYPE_NORMAL
- en: There is a set of [“core” BPF kfuncs](https://oreil.ly/06qoi), which at the
    time of this writing consists of functions that allow eBPF programs to obtain
    and release kernel references to tasks and cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: To recap, the type of an eBPF program determines what events it can be attached
    to, which in turn defines the type of context information it receives. The program
    type also defines the set of helper functions and kfuncs it can call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Program types are broadly considered to fall into two categories: tracing (or
    perf) program types and networking-related program types. Let’s look at some examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs that attach to kprobes, tracepoints, raw tracepoints, fentry/fexit
    probes, and perf events were all designed to provide an efficient way for eBPF
    programs in the kernel to report tracing information about events into user space.
    These tracing-related types weren’t expected to influence the way the kernel behaves
    in response to the events they are attached to (although, as you’ll see in [Chapter 9](ch09.html#ebpf_for_security),
    there have been some innovations in this area!).
  prefs: []
  type: TYPE_NORMAL
- en: 'These are sometimes referred to as “perf-related” programs. For example, the
    `bpftool perf` subcommand lets you view programs attached to perf-related events
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output is what I see when running example code from the *hello.bpf.c*
    file in the *chapter7* directory, which attaches different programs to a variety
    of events that are all related to `execve()`. I’ll discuss all of these types
    in this section, but as an overview, these programs are:'
  prefs: []
  type: TYPE_NORMAL
- en: A kprobe attached to the entry point to the `execve()` system call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A kprobe attached to a kernel function, `do_execve()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tracepoint placed at the entry to the `execve()` syscall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two versions of a raw tracepoint called during the processing of `execve()`.
    One of these, as you’ll see in this section, is a BTF-enabled version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll need `CAP_PERFMON` and `CAP_BPF` or `CAP_SYS_ADMIN` capabilities to use
    any of the tracing-related eBPF program types.
  prefs: []
  type: TYPE_NORMAL
- en: Kprobes and Kretprobes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I discussed the concept of kprobes in [Chapter 1](ch01.html#what_is_ebpf_and_why_is_it_importantque).
    You can attach kprobe programs almost anywhere in the kernel.^([1](ch07.html#ch07fn1))
    Commonly, they are attached using kprobes to the entry to a function and kretprobes
    to the exit of a function, but you can use kprobes to attach to an instruction
    that is some specified offset after the entry to the function. If you choose to
    do this,^([2](ch07.html#ch07fn2)) you’d need to be confident that the kernel version
    you’re running on has the instruction you want to attach to where you think it
    is! Attaching to kernel function entry and exit points can be relatively stable,
    but arbitrary lines of code might easily be modified from one release to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the example output from `bpftool perf list`, you can see that there is an
    offset of 0 for both of the kprobes.
  prefs: []
  type: TYPE_NORMAL
- en: When the kernel is compiled, there’s also the possibility that the compiler
    chooses to “inline” any given kernel function; that is, rather than jump from
    where the function is called, the compiler might emit the machine code to implement
    whatever the function does within the calling functions. If a function happens
    to get inlined, there won’t be a kprobe entry point for your eBPF program to attach
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching kprobes to syscall entry points
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first example eBPF program for this chapter is called `kprobe_sys_execve`,
    and it is a kprobe attached to the `execve()` syscall. The function and its section
    definition look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as what you saw in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf).
  prefs: []
  type: TYPE_NORMAL
- en: One reason to attach to syscalls is that they are stable interfaces that won’t
    change between kernel versions (the same is true of tracepoints, which we’ll come
    to shortly). However, syscall kprobes shouldn’t be relied on for security tooling,
    for reasons I’ll cover in detail in [Chapter 9](ch09.html#ebpf_for_security).
  prefs: []
  type: TYPE_NORMAL
- en: Attaching kprobes to other kernel functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find lots of examples where eBPF-based tools use kprobes to attach
    to system calls, but, as mentioned earlier, kprobes can also be attached to any
    noninlined function in the kernel. I’ve provided an example in *hello.bpf.c* that
    attaches a kprobe to the function `do_execve()`, and it’s defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `do_execve()` isn’t a system call, there are a few differences between
    this and the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: The format of the SEC name is identical to the previous version attached to
    the syscall entry point, but there is no need to define platform-specific variants
    because `do_execve()`, like most kernel functions, is common to all platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I used the `BPF_KPROBE` macro rather than `BPF_KPROBE_SYSCALL`. The intent is
    exactly the same, just that the latter handles syscall parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is another important difference: the `pathname` parameter to the syscall
    is a pointer to a string `(char *)`, but for this function the parameter is called
    `filename`, and it’s a pointer to a `struct filename`, which is a data structure
    used within the kernel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might well be wondering how I knew to use this type for this parameter.
    I’ll show you. The `do_execve()` function in the kernel has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I chose to ignore the `do_execve()` parameters `__argv` and `__envp`, and only
    declare the `filename` argument, using the type `struct filename *` to match the
    kernel function’s definition. Given the way arguments are laid out sequentially
    in memory, it’s OK to ignore the last *n* parameters, but you can’t ignore an
    earlier argument in the list if you want to use a later one.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `filename` structure is defined internal to the kernel, and it’s an illustration
    of how eBPF programming is kernel programming: I had to look up the definition
    of `do_execve()` to find its arguments, and the definition of `struct filename`.
    The name of the executable that is about to be run is pointed to by `filename->name`.
    I’m retrieving this name in the example code with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So to recap: the context parameter to a syscall kprobe is a structure representing
    the values passed by user space into the syscall. The context parameter to a “regular”
    (nonsyscall) kprobe is a structure representing the parameters passed to the called
    function by whatever kernel code is calling it, so the structure depends on the
    function definition.'
  prefs: []
  type: TYPE_NORMAL
- en: Kretprobes are very similar to kprobes, except that they are triggered when
    a function returns and can access the return value instead of the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Kprobes and kretprobes are a reasonable way to hook into kernel functions, but
    there’s a newer option you should consider if you’re running on recent kernels.
  prefs: []
  type: TYPE_NORMAL
- en: Fentry/Fexit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more efficient mechanism for tracing the entry to and exit from kernel functions
    was introduced along with the idea of *BPF trampoline* in kernel version 5.5 (on
    x86 processors; BPF trampoline support doesn’t arrive for [ARM processors until
    Linux 6.0](https://oreil.ly/ccuz1)). If you’re using a recent enough kernel, fentry/fexit
    is now the preferred method for tracing the entry to or exit from a kernel function.
    You can write the same code inside a kprobe or fentry type program.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an example fentry program called `fentry_execve()` in *chapter7/hello.bpf.c*.
    I declared the eBPF program for this kprobe using *libbpf*’s macro `BPF_PROG`,
    which is another convenient wrapper giving access to typed parameters rather than
    the generic context pointer, but this version is used for fentry, fexit, and tracepoint
    program types. The definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The section name tells *libbpf* to attach to the fentry hook at the start of
    the `d⁠o⁠_​e⁠x⁠e⁠c⁠v⁠e⁠(⁠)` kernel function. Just as in the kprobe example, the
    context parameters reflect the parameters passed to the kernel function where
    you want to attach this eBPF program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fentry and fexit attachment points were designed to be more efficient than
    kprobes, but there’s another advantage when you want to generate an event at the
    end of a function: the fexit hook has access to the input parameters to the function,
    which kretprobe does not. You can see an example of this in [*libbpf-bootstrap*’s
    examples](https://oreil.ly/6HDh_). Both *kprobe.bpf.c* and *fentry.bpf.c* are
    equivalent examples that hook into the `do_unlinkat()` kernel function. The eBPF
    program attached to the kretprobe has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BPF_KRETPROBE` macro expands to make this a kretprobe program on exit
    from `do_unlinkat()`. The only parameter the eBPF program receives is `ret`, which
    holds the return value from `do_unlinkat()`. Compare this to the fexit version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this version the program gets access not just to the return value `ret`,
    but also to the input parameters to `do_unlinkat()`, which are `dfd` and `name`.
  prefs: []
  type: TYPE_NORMAL
- en: Tracepoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tracepoints](https://oreil.ly/yXk_L) are marked locations in the kernel code
    (we’ll come to user space tracepoints later in this chapter). They’re not by any
    means exclusive to eBPF and have long been used to generate kernel trace output
    and by tools like [SystemTap](https://oreil.ly/bLmQL). Unlike attaching to arbitrary
    instructions using kprobes, tracepoints are stable between kernel releases (although
    an older kernel might not have the full set of tracepoints that have been added
    into a newer one).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the available set of tracing subsystems on your kernel by looking
    at */sys/kernel/tracing/available_events*, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: My 5.15 version of the kernel has more than 1,400 tracepoints defined in this
    list. The section definition for a tracepoint eBPF program should match one of
    these items so that *libbpf* can automatically attach it to the tracepoint. The
    definition is in the form `SEC("tp/tracing subsystem/tracepoint name")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll find an example in the *chapter7/hello.bpf.c*files that matches the
    `syscalls:sys_enter_execve` tracepoint that gets hit when the kernel starts processing
    an `execve()` call. The section definition tells *libbpf* that this is a tracepoint
    program, and where it should be attached, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What about the context parameter to a tracepoint? As I’ll come to shortly,
    BTF can help us here, but first let’s consider what is needed when BTF isn’t available.
    Each tracepoint has a format describing the fields that get traced out from it.
    As an example, here’s the format for the tracepoint at the entry to the `execve()`
    syscall:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I used this information to define a matching structure called `m⁠y⁠_⁠s⁠y⁠s⁠c⁠a⁠l⁠l⁠s⁠_⁠e⁠n⁠t⁠e⁠r⁠_​e⁠x⁠e⁠c⁠v⁠e`
    in *chapter7/hello.bpf.c*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: eBPF programs aren’t allowed to access the first four of these fields. If you
    try to access them, the program will fail verification with an `invalid bpf_context
    access` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'My example eBPF program that attaches to this tracepoint can use a pointer
    to this type as its context parameter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can access the contents of this structure. For example, you can get
    the filename pointer as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you use a tracepoint program type, the structure passed to the eBPF program
    has already been mapped from a set of raw arguments. For better performance, you
    can directly access these raw arguments with a raw tracepoint eBPF program type.
    The section definition should start with `raw_tp` (or `raw_tracepoint`) instead
    of `tp`. You’ll need to convert the arguments from `__u64` to whatever type the
    tracepoint structure uses (when the tracepoint is the entry to a system call,
    these arguments are dependent on the chip architecture).
  prefs: []
  type: TYPE_NORMAL
- en: BTF-Enabled Tracepoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example I wrote a structure called `my_syscalls_enter_execve`
    to define the context parameter for my eBPF program. But when you define a structure
    in your eBPF code or parse the raw arguments, there’s a risk that your code might
    not match the kernel it’s running on. The good news is that BTF, which you met
    in [Chapter 5](ch05.html#co_recomma_btfcomma_and_libbpf), also solves this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'With BTF support, there will be a structure defined in *vmlinux.h* that matches
    the context structure passed to a tracepoint eBPF program. Your eBPF program should
    use the section definition `SEC("tp_btf/*tracepoint name*")` where the tracepoint
    name is one of the available events listed in */sys/kernel/tracing/available_events*.
    The example program in *chapter7/hello.bpf.c* looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the structure name matches the tracepoint name, prefixed with
    `trace_event_raw_`.
  prefs: []
  type: TYPE_NORMAL
- en: User Space Attachments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far I have shown examples of eBPF programs attaching to events defined within
    the kernel’s source code. There are similar attachment points within user space
    code: uprobes and uretprobes for attaching to the entry and exit of user space
    functions, and user statically defined tracepoints (USDTs) for attaching to specified
    tracepoints within application code or user space libraries. These all use the
    `BPF_PROG_TYPE_KPROBE` program type.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are lots of public examples of programs attached to user space events.
    Here are a few from the BCC project:'
  prefs: []
  type: TYPE_NORMAL
- en: The [bashreadline](https://oreil.ly/gDkaQ) and [funclatency tools](https://oreil.ly/zLT54)
    attach to u(ret)probe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[USDT sample](https://oreil.ly/o894f) in BCC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re using *libbpf*, the `SEC()` macro lets you define the auto-attachment
    point for these user space probes. You’ll find the format required for the section
    name in the [*libbpf* documentation](https://oreil.ly/o0CBQ). For example, to
    attach a uprobe to the start of the `SSL_write()` function in OpenSSL, you would
    define the section for the eBPF program with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few gotchas to be aware of when instrumenting user space code:'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the path to this shared library in this example is architecture
    specific, so you may need corresponding architecture-specific definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless you control the machine you’re running the code on, you can’t know what
    user space libraries and applications will be installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application might be built as a standalone binary, so it won’t hit any probes
    you might attach within shared libraries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers typically run with their own copy of a filesystem, with their own
    set of dependencies installed in it. The path to a shared library used by a container
    won’t be the same as the path to a shared library on the host machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your eBPF program might need to be aware of the language in which an application
    was written. For example, in C the arguments to a function are generally passed
    using registers, but in Go they are passed using the stack,^([3](ch07.html#ch07fn3))
    so the `pt_args` structure holding register information may be of less use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That said, there are lots of useful tools that instrument user space applications
    with eBPF. For example, you can hook into the SSL library to trace out decrypted
    versions of encrypted information—we’ll explore this in more detail in the next
    chapter. Another example is continuous profiling of your applications, using tools
    such as [Parca](https://www.parca.dev).
  prefs: []
  type: TYPE_NORMAL
- en: LSM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_LSM` programs are attached to the *Linux Security Module (LSM)
    API*, which is a stable interface within the kernel originally intended for kernel
    modules to use to enforce security policies. As you’ll see in [Chapter 9](ch09.html#ebpf_for_security),
    where I’ll discuss this in more detail, eBPF security tooling can now use this
    interface too.'
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_LSM` programs are attached using `bpf(BPF_RAW_TRACEPOINT_OPEN)`,
    and in many ways they are treated like tracing programs. One interesting characteristic
    of `BPF_PROG_TYPE_LSM` programs is that the return value affects the way the kernel
    behaves. A nonzero return code indicates that the security check wasn’t passed,
    so the kernel won’t proceed with whatever operation it was asked to complete.
    This is a significant difference from perf-related program types where the return
    code is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Linux kernel documentation covers [LSM BPF programs](https://oreil.ly/vcPHY).
  prefs: []
  type: TYPE_NORMAL
- en: The LSM program type isn’t the only one with a role to play in security. Many
    of the networking-related program types that you’ll see in the next section can
    be used for network security to permit or deny networking traffic or networking-related
    operations. You’ll also see more about eBPF being used for security purposes in
    [Chapter 9](ch09.html#ebpf_for_security).
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter you have seen how a set of kernel and user space tracing
    program types enable visibility over the whole system. The next set of eBPF program
    types to consider are those that let us hook into the network stack, with the
    option not merely to observe but also to affect how it handles data being sent
    and received.
  prefs: []
  type: TYPE_NORMAL
- en: Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of different eBPF program types intended to process network messages
    as they pass through various points in the network stack. [Figure 7-1](#bpf_program_types_hook_into_various_poi)
    shows where some of the commonly used program types attach. These program types
    all require `CAP_NET_ADMIN` and `CAP_BPF`, or `CAP_SYS_ADMIN`, capabilities to
    be permitted.
  prefs: []
  type: TYPE_NORMAL
- en: The context passed to these types of programs is the network message in question,
    although the type of structure depends on the data the kernel has at the relevant
    point in the network stack. At the bottom of the stack, data is held in the form
    of Layer 2 network packets, which are essentially a series of bytes that have
    been or are ready to be transmitted “on the wire.” At the top of the stack, applications
    use sockets, and the kernel creates socket buffers to handle data being sent and
    received from these sockets.
  prefs: []
  type: TYPE_NORMAL
- en: '![BPF program types hook into various points in the network stack](assets/lebp_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. BPF program types hook into various points in the network stack
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The network layer model is beyond the scope of this book, but it’s covered in
    many other books, posts, and training courses. I discussed it in [Chapter 10](ch10.html#ebpf_programming)
    of [*Container Security*](https://www.oreilly.com/library/view/container-security/9781492056690/)
    (O’Reilly). For the purposes of this book, it’s sufficient to know that Layer
    7 covers formats intended for applications to use, such as HTTP, DNS, or gRPC;
    TCP is at Layer 4; IP is at Layer 3; and Ethernet and WiFi are at Layer 2\. One
    of the roles of the networking stack is to convert messages between these different
    formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'One big difference between the networking program types and the tracing-related
    types you saw earlier in this chapter is that they are generally intended to allow
    for the customization of networking behaviors. That involves two main characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a return code from the eBPF program to tell the kernel what to do with
    a network packet—which could involve processing it as usual, dropping it, or redirecting
    it to a different destination
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allowing the eBPF program to modify network packets, socket configuration parameters,
    and so on
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll see some examples of how these characteristics are used to build powerful
    networking capabilities in the next chapter, but for now, here’s an overview of
    the eBPF program types.
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the top of the stack, a subset of these network-related program types relates
    to sockets and socket operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_SOCKET_FILTER` was the first program type to be added to the
    kernel. You probably guessed from the name that this is used for socket filtering,
    but what’s less obvious is that this doesn’t mean filtering data being sent to
    or from an application. It’s used to filter a *copy* of socket data that can be
    sent to an observability tool such as tcpdump.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A socket is specific to a Layer 4 (TCP) connection. `BPF_PROG_TYPE_SOCK_OPS`
    allows eBPF programs to intercept various operations and actions that take place
    on a socket, and to set for that socket parameters such as TCP timeout values.
    Sockets only exist at the endpoints for a connection, and not on any middleboxes
    that they might pass through.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BPF_PROG_TYPE_SK_SKB` programs are used in conjunction with a special map
    type that holds a set of references to sockets to provide what’s known as [*sockmap*
    operations](https://oreil.ly/0Enuo): redirecting traffic to different destinations
    at the socket layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Further down the network stack comes “TC” or traffic control. There is a whole
    subsystem in the Linux kernel related to TC, and a glance at the [manpage for
    the `tc` command](https://oreil.ly/kfyg5) will give you an idea of how complex
    it is and how important it is to computing in general to have deep levels of flexibility
    and configuration over the way network packets are handled.
  prefs: []
  type: TYPE_NORMAL
- en: eBPF programs can be attached to provide custom filters and classifiers for
    network packets for both ingress and egress traffic. This is one of the building
    blocks of the Cilium project, and I’ll cover some examples in the next chapter.
    If you can’t wait until then, there are some good examples on [Quentin Monnet’s
    blog](https://oreil.ly/heQ2D). This can be done programmatically, but you also
    have the option to use the `tc` command to manipulate these kinds of eBPF programs.
  prefs: []
  type: TYPE_NORMAL
- en: XDP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You briefly met XDP (eXpress Data Path) eBPF programs in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).
    In that example I loaded the eBPF program and attached it to the `eth0` interface
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth noting that XDP programs attach to a specific interface (or virtual
    interface), and you may very well have different XDP programs attached to different
    interfaces. In [Chapter 8](ch08.html#ebpf_for_networking) you’ll learn more about
    how XDP programs can be offloaded to network cards or executed by network drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'XDP programs are another example of programs that can be managed using Linux
    network utilities—in this case, the `link` subcommand of [iproute2’s ip](https://oreil.ly/8Isau).
    The roughly equivalent command for loading and attaching the program to `eth0`
    would be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This command reads the eBPF program marked as section `xdp` from the `hello.bpf.o`
    object and attaches it to the `eth0` network interface. The `ip link show` command
    for this interface now includes some information about the XDP program that’s
    attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing the XDP program with `ip link` can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see a lot more about XDP programs and their applications in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Flow Dissector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A flow dissector is used at various points in the network stack to extract details
    from a packet’s headers. eBPF programs of type `BPF_PROG_TYPE_FLOW_DISSECTOR`
    can implement custom packet dissection. There’s a nice write-up in this LWN article
    on [writing network flow dissectors in BPF](https://oreil.ly/nFKLV).
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight Tunnels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The family of `BPF_PROG_TYPE_LWT_*` program types can be used to implement network
    encapsulation in eBPF programs. These program types can also be manipulated using
    the `ip` command, but this time it’s the `route` subcommand that’s involved. In
    practice, these are used infrequently.
  prefs: []
  type: TYPE_NORMAL
- en: Cgroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: eBPF programs can be attached to cgroups (short for “control groups”). *Cgroups*
    are a concept in the Linux kernel that restricts the set of resources a given
    process or group of processes can have access to. Cgroups are one of the mechanisms
    that isolate one container (or one Kubernetes pod) from another. Attaching eBPF
    programs to a cgroup allows for custom behavior that only applies to that cgroup’s
    processes. All processes are associated with a cgroup, including processes that
    are not running inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: There are several cgroup-related program types, and even more hooks where they
    can be attached. At least at the time of this writing, they are nearly all networking
    related, although there is also a `BPF_CGROUP_SYSCTL` program type that can be
    attached to sysctl commands affecting a particular cgroup.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, there are socket-related program types specific to cgroups `BPF_PROG_TYPE_CGROUP_SOCK`
    and `BPF_PROG_TYPE_CGROUP_SKB`. eBPF programs can determine whether a given cgroup
    is permitted to perform a requested socket operation or data transmission. This
    is useful for network security policy enforcement (which I’ll cover in the next
    chapter). Socket programs can also trick the calling process into thinking they
    are connecting to a particular destination address.
  prefs: []
  type: TYPE_NORMAL
- en: Infrared Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programs of type [BPF_PROG_TYPE_LIRC_MODE2](https://oreil.ly/AwG1C) can be attached
    to the file descriptor for an infrared controller device to provide decoding for
    infrared protocols. At the time of this writing, this program type requires `CAP_NET_ADMIN`,
    but I think this illustrates that the division of program types into tracing related
    and networking related doesn’t fully express the range of different applications
    that eBPF can address.
  prefs: []
  type: TYPE_NORMAL
- en: BPF Attachment Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The attachment type offers more fine-grained control over where a program can
    be attached in the system. For some program types there is a one-to-one correlation
    to the type of hook that it can be attached to, so the attachment type is implicitly
    defined by the program type. For example, XDP programs are attached to XDP hooks
    in the network stack. For a few program types, an attachment type also has to
    be specified.
  prefs: []
  type: TYPE_NORMAL
- en: The attachment type is involved in deciding which helper functions are valid,
    and it also restricts access to parts of the context information in some cases.
    There was an example of this earlier in this chapter where the verifier gives
    an `invalid bpf_context access` error.
  prefs: []
  type: TYPE_NORMAL
- en: You can also see which program types need an attachment type to be specified,
    and which attachment types are valid, in the kernel function [bpf_prog_load_check_attach](https://oreil.ly/0LqCQ)
    (defined in [*bpf/syscall.c*](https://oreil.ly/7OrYS)).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here is the code that checks the attachment type for a program
    of type `CGROUP_SOCK`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This program type can be attached in multiple places: at socket creation, at
    socket release, or after a bind is completed in IPv4 or IPv6.'
  prefs: []
  type: TYPE_NORMAL
- en: Another place to find a listing of the valid attachment types for programs is
    the [*libbpf* documentation](https://oreil.ly/jraLh), where you’ll also find the
    section names that *libbpf* understands for each program and attachment type.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter you saw that various eBPF program types are used to attach into
    different hook points in the kernel. If you want to write code that responds to
    a particular event, you’ll need to determine the program type(s) that are appropriate
    for hooking onto that event. The context passed into the program depends on the
    program type, and the kernel may also respond differently to the return code from
    your program, depending on its type.
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this chapter mostly focused on perf-related (tracing) events.
    In the next two chapters you’ll see more details on different eBPF program types
    used for networking and security applications.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example code for this chapter includes kprobe, fentry, tracepoint, raw tracepoint,
    and BTF-enabled tracepoint programs that are all attached to the entry to the
    same system call. As you know, eBPF tracing programs can be attached to many other
    places besides syscalls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the example code using `strace` to capture the `bpf()` system calls, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will record information about each `bpf()` syscall into a file called *outfile*.
    Look for the `BPF_PROG_LOAD` instructions in that file, and see how the `prog_type`
    file varies for different programs. You can identify which program is which by
    the `prog_name` field in the trace, and match them to the source code in *chapter7/hello.bpf.c*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The example user space code in *hello.c* loads all the program objects defined
    in `hello.bpf.o`. As an exercise in writing *libbpf* user space code, modify the
    example code load and attach just one of the eBPF programs (pick whichever one
    you like), without removing those programs from *hello.bpf.c*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a kprobe and/or fentry program that is triggered when some other kernel
    function is called. You can find the available functions in your kernel version
    by looking at */proc/kallsyms*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a regular, raw or BTF-enabled tracepoint program that attaches to some
    other kernel tracepoint. You can find the available tracepoints in `/sys/kernel/tracing/available_events`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Try to attach more than one XDP program to a given interface, and confirm that
    you can’t! You should see an error that looks something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: ^([1](ch07.html#ch07fn1-marker)) Except for a few parts of the kernel where
    kprobes aren’t permitted for security reasons. These are listed in `/sys/kernel/debug/kprobes/blacklist`.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch07.html#ch07fn2-marker)) The only example I have seen so far is in the
    [cilium/ebpf test suite](https://oreil.ly/rL5E8).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch07.html#ch07fn3-marker)) Up to Go version 1.17, when a new register-based
    calling convention was introduced. Nevertheless, I think there will be Go executables
    built with older versions circulating for some time to come.
  prefs: []
  type: TYPE_NORMAL
