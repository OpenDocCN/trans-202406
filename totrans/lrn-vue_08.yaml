- en: Chapter 8\. Routing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have learned the fundamentals of Vue components and
    different approaches to composing a Vue component. We proceeded to create reusable
    component logic as standalone composable using Composition API. We also learned
    about more advanced concepts of rendering and custom plugin creation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore a different aspect of building a Vue application,
    routing, by introducing you to the concept of a routing system with Vue Router,
    the official routing management library for the Vue application, and its core
    API. We then learn how to configure the app’s routes, pass and handle data between
    the application’s paths using router guards, and build dynamic and nested routes
    for our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: What is Routing?
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When users navigate around the web, they enter a Uniform Resource Locator (URL)
    in the browser’s address bar. A URL is the address of a resource within the web.
    It contains many parts, which we can divide into the following significant sections
    ([Figure 8-1](#figure_c07_01_url)):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Location
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Includes the protocol, the application’s domain name (or IP address of the web
    server), and the port used to access the requested resource.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Path
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The path to the requested resource. In web development, we use it to determine
    the page component to render on the browser side based on a predefined path pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Query parameters
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: A set of key-value pairs for passing additional information to the server, separated
    by an `&` symbol. We mainly use query parameters to pass data between pages.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Anchor
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Any text after the `#` symbol. We use anchors to navigate to a specific element
    on the same page, often with matched `id` value with the matched id or a time-lapse
    for a media element.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram shows the one-way data flow between components](assets/lvue_0801.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Figure 8-1\. URL structure
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Upon receiving the URL from the user, the browser then communicates with the
    server based on the received URL, which returns the requested resource, if any.
    The resource can be a static file, such as an image or a video, or a dynamic page,
    such as a web page or a web application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: With single-page applications (SPAs), we perform the routing mechanism on the
    browser side instead, thus allowing smooth page navigation without refreshing
    the browser. As a URL is a page’s address, we use a routing system to connect
    its path pattern to a specific component representing it in our application.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Frontend frameworks like Vue provide the layout for building components for
    an SPA but not the routing services. To create a complete user navigation experience,
    we must design and develop the application’s routing ourselves, including solving
    the SPA’s issues such as history keeping and bookmarking.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Or we can use Vue Router as our primary engine for routing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Using Vue Router
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the official routing service for Vue applications, Vue Router offers a control
    mechanism for handling page navigation in a Vue application. We use Vue Router
    to set up our application’s routing systems, including configuring the mapping
    between components and pages, delivering a good user experience on the client
    side for the SPA’s flow.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The official Vue Router documentation is available at the [Vue Router website](https://oreil.ly/AwUZo),
    containing information on installation, APIs, and primary use cases for reference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Since Vue Router is a standalone package from the Vue framework, we need to
    perform additional steps to have it installed and ready to use in our application,
    which we will discuss next.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vue Router
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most straightforward way to install Vue Router for a new Vue project using
    Vite is to choose `Yes` when being asked to install Vue Router during the setup
    (see [“Create a New Vue Application”](ch01.html#chapter_01_newVueApp)). Vite then
    will take care of installing the Vue Router package and scaffold your project
    with related files and folders ([Figure 8-2](#figure_c07_01)), as in the following
    structure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The `router` folder with one file, `index.ts`, containing the routes configurations
    for the app.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `views` folder has two sample Vue components, `AboutView` and `HomeView`.
    Each component is the view for the related URL paths, which we will discuss shortly.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![A diagram shows the one-way data flow between components](assets/lvue_0802.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Figure 8-2\. Project structure after scaffolding with Vite with Vue Router enabled
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vite will also inject some code into the `main.ts` file to initialize Vue Router.
    Hence, the created app will enable the primary router enabled and make it ready
    to use.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to fully understand how Vue Router works, we will skip the scaffolding
    option and add Vue Router to our existing project manually by using the following
    command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this book, we use Vue Router 4.1.6, the latest version at the time of writing.
    You can replace the version number after `@` with the latest version from the
    [Vue Router NPM page](https://oreil.ly/h6Q0V).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: For Vue 3 projects, you should use version 4 and above.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate the Vue Router’s capabilities, we will build an SPA representing
    a pizza ordering system. The application header will have the following page links:
    Home, About, Pizzas, Contact, and Login (see [Figure 8-3](#figure_c07_02)).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the layout of the Pizza House application''s header](assets/lvue_0803.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Figure 8-3\. Pizza House application with navigation header
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Each application link leads to a page represented by a Vue component. For each
    application page, we create a placeholder component and keep it under the `views`
    folder. Our Pizza House codebase now contains the following view components:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '`HomeView`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Our application’s home page contains a welcome message and a list of pizzas.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '`AboutView`'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: The about page, which will contain a short description of the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '`PizzasView`'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a list of pizzas for ordering.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '`ContactView`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a contact form.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginView`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the login form for the user.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: We need to map these components to the appropriate page links, demonstrated
    in [Table 8-1](#table_chap07_01).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-1\. Table of the available routes with their corresponding components
    and page URLs in Pizza House
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '| Page link | Component | Route path pattern |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000* | HomeView | `/` |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000/about* | AboutView | `/about` |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000/pizzas* | PizzasView | `/pizzas` |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000/contact* | Contact | `/contact` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: '| *https://localhost:4000/login* | LoginView | `/login` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
- en: '[Table 8-1](#table_chap07_01) also shows the corresponding route patterns for
    each page link. We will use these patterns to define the routes in our application.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The port `4000` for `localhost` is the local port number for the development
    server by Vite. It can change depending on your Vite configuration and the available
    ports when you run your project locally.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Defining Routes
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A route is a path pattern in response to a page URL. We define a route in Vue
    Router based on a configuration object using the interface `RouteRecordRaw`. This
    configuration object contains the following properties described in [Table 8-2](#table_chap07_02).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Table 8-2\. Properties for a route configuration object
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Type | Description | Required? |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| `path` | `string` | The pattern to check against the browser’s location (browser
    URL) | Yes |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| `component` | `Component` | The component to render when the browser’s location
    matches the route’s path pattern | No |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| `name` | `string` | The name of the route. We can use it to avoid hard-coded
    URLs in the code. | No |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| `components` | `{ [name: string]: Component }` | A collection of components
    to render based on the matched route’s name | No |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| `redirect` | `string` or `Location` or `Function` | The redirect path | No
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: '| `props` | `boolean` or `Object` or `Function` | The props to pass to the
    component | No |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
- en: '| `alias` | `string` or `Array<string>` | The alias path | No |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
- en: '| `children` | `Array<RouteConfig>` | The child routes | No |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
- en: '| `before``Enter` | `Function` | The navigation guard callback | No |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
- en: '| `meta` | `any` | The route’s metadata. We can use this for passing additional
    information not visible on the URL. | No |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| `sensitive` | `Boolean` | Whether the route should be case sensitive. By
    default, all routes are case insensitive; for example, `/pizzas` and `/Pizzas`
    are the same route. | No |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| `strict` | `Boolean` | Whether we should allow trailing slash (like `/about/`
    or `/about`) | No |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: 'We often don’t use all the available fields to define a route. For instance,
    take the default application path (`/`). It’s sufficient to define the following
    `home` route object with the `path` property set to `/` and the `component` property
    set to `HomeView`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Vue Router in the previous code maps the default entry URL (such as *https://localhost:4000*)
    to the `/` case unless `strict` mode is enabled. If there is no indicator after
    the slash `/`, Vue Router will render the `HomeView` component as the default
    view. This behavior applies in both cases: when a user visits *https://localhost:4000*,
    or *https://localhost:4000/*.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can proceed to configure our app’s `routes` as an array of `RouteRecordRaw`
    configuration objects in the `index.ts` file under the `router` folder, as in
    the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using Named Routes
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter uses the named route with the `name` property. I recommend using
    this approach in your application, making the code more readable and maintainable.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: That’s straightforward enough. We have defined the necessary routes for our
    Pizza House. But we need more than this for our route system to work. We must
    create a router instance from the given routes and plug it into our Vue application
    on initialization. We will do this next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Router Instance
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create the router instance using the `createRouter` method from the
    `vue-router` package. This method takes a configuration object of type `RouterOptions`
    as an argument, with the following main properties:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '`history`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The history mode object can be hash-based or web-based (HTML history mode).
    The web-based method utilizes the HTML5 history API to make the URL readable,
    allowing us to navigate without reloading the page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`routes`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: The array of routes to use in the router instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '`linkActiveClass`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The class name for the active link. By default, it is `router-link-active`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '`linkExactActiveClass`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: The class name for the active link. By default, it is `router-link-exact-active`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Other less common properties for the `RouterOptions` interface are available
    at the [RouterOptions documentation](https://oreil.ly/pcSqw).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `createWebHistory` method from the `vue-route` package to create
    a web-based `history` object. This method takes a string that represents the base
    URL as its optional argument:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, passing the base URL as a static string is not a good practice. We
    want to keep the base URL configurable and isolated for different environments
    like development and production. For this purpose, Vite exposes the environment
    object `import.meta.env`, which contains a `BASE_URL` property. You can set the
    value for `BASE_URL` in a dedicated environment file, often denoted by the `.env`
    prefix, or through the command line when running the Vite server. Vite then extracts
    the relevant value for `BASE_URL` and injects it into the `import.meta.env` object,
    and we can use it in our code, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using BASE_URL from the Environment File
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You don’t have to set the `BASE_URL` value in the `.env` file for development.
    Vite will map it to the local server URL automatically.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Most modern hosting platforms, such as Netlify, will set the `BASE_URL` value
    for you during deployment, often to your application’s domain name.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: We have created the router instance from the given `routes` and the desired
    `history` mode. Our next step is to plug this instance into our Vue application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Plugging the Router Instance Into the Vue Application
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `main.ts` file where we initialize the application instance `app`, we
    will import the created `router` instance and pass it as the argument to the `app.use()`
    method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Our application now has a routing system for the navigation between pages. However,
    if you run the application now, you will see that the `AboutView` component is
    still not rendered when navigating to the `/about` path. We must modify our `App.vue`
    component to display the suitable component that binds to the route’s path in
    its configurations. Let’s do that next.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the Current Page with the RouterView Component
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To dynamically generate the desired view for a particular URL path, Vue Router
    provides `RouterView` (or `router-view`) as the placeholder component. During
    running, Vue Router will replace it with the element that matches the current
    URL pattern based on the configuration provided. We can use this component in
    our `App.vue` component to render the current page:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When running the application, the default home page is now the `HomeView` ([Figure 8-4](#home-view)).
    When navigating to `/about` using the browser’s location bar, you will see that
    the `AboutView` component is rendered ([Figure 8-5](#about-view)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![Home View](assets/lvue_0804.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Figure 8-4\. Application displays the HomeView component for the `"/"` path
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![About View](assets/lvue_0805.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Figure 8-5\. Application displays the AboutView component for the `"/about"`
    path
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since `RouterView` is a Vue component, we can pass props, attributes, and event
    listeners to it. `RouterView` will then pass them to the rendered view to handle.
    For instance, we can add a class using the `RouterView`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The rendered component—`AboutView`, for example—will then receive the `class`
    as the primary container element (see [Figure 8-6](#figure_ch7_03)), and we can
    use it for CSS styling accordingly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![RouterView class](assets/lvue_0806.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 8-6\. `AboutView` receives the `class` attribute from the `RouterView`
    component
  id: totrans-123
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At this point, we have seen how to set up the routes for our application and
    render the current page using the `RouterView` component. However, navigating
    by manually setting the URL path on the browser’s address bar does not seem to
    be very convenient for users. To enhance the user experience for our app, we can
    compose a header with navigation links using the `a` element and the full path.
    Or we can use the built-in `RouterLink` component to build the links to our routes,
    which we will discuss next.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Build a Navigation Bar with the RouterLink Component
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Vue Router provides the `RouterLink` (or `router-link`) component to generate
    an interactive and navigable element from a set of given props, such as `to`,
    for a specific route’s path. The route path can be a string that has the same
    value as `path` in the route configuration, as in the following example for the
    link to navigate to the about page:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, we can pass an object representing the route’s location object,
    including the `name` and the `params` for the route parameters:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By default, this component renders an anchor element (`a`) with an `href` and
    classes for the active link, such as `router-link-active` and `router-link-exact-active`.
    We can change the default element to any other element using the Boolean `custom`
    prop and `v-slot`, usually another interactive element such as `button`, as in
    the following example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code will render a `button` element instead of the default `a` element,
    binding with the `navigate` function to navigate the given route when clicking.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Using `custom` Prop
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you use the `custom` prop, you must bind the `navigate` function as a click
    handler or the `href` link to the custom element. Otherwise, the navigation will
    not work.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Also, no class names such as `router-link-active` or `router-link-exact-active`
    will be added to the custom element when in action.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Let’s build our navigation bar, `NavBar`, using `RouterLink` as shown in [Example 8-1](#NavBar_component).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. `NavBar` component
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We also add some CSS styles to the navigation bar and the active link:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Using activeClass and exactActiveClass Props
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use the `activeClass` and `exactActiveClass` props of `RouterLink` to
    customize the class names for the active link instead of using the default ones.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Once we add `NavBar` to the `App` component, we will see the navigation bar
    at the top of the page ([Figure 8-7](#figure_ch7_04)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the navigation bar with Home link active and underlined](assets/lvue_0807.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Figure 8-7\. Navigation bar of the application
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now our users can navigate between pages using the navigation bar. However,
    we still need to handle the data flow between the pages. In the upcoming sections,
    we will see how to pass data between routes with route parameters.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Passing Data Between Routes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To pass data between routes, we can use the `query` field in the router object
    passed to `to`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `query` field is an object that contains the query parameters we want to
    pass to the route. Vue Router will translate it into a complete `href` path with
    query parameters, starting with `?` syntax:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can then access the query parameters in the route component, `PizzasView`,
    using the `useRoute()` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This code will render the following page, where the browser’s URL is *http://localhost:4000/pizzas?id=1*
    ([Figure 8-8](#figure_ch7_05)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Pizzas page with the query parameter](assets/lvue_0808.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 8-8\. Pizzas page with the query parameter
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also pass the query parameters in the browser’s address bar, and the
    router instance will decouple it from the `route.query` object accordingly. This
    mechanism is handy in many scenarios. Take our `PizzasView` page, for instance.
    This page displays a list of pizzas taken from a `usePizzas` hook, using the `PizzaCard`
    component as shown in [Example 8-2](#pizza_view_component).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2\. `PizzasView` component
  id: totrans-158
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now we want to add a search feature, where the user can search for a pizza by
    its title using a query params `search` and get the filtered list of pizzas. We
    can add a `useSearch` hook, which receives the value of `route.query.search` as
    its initial value and returns the filtered list of pizzas as well as the reactive
    `search` value, as shown in [Example 8-3](#useSearch_hook).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. Implementing `useSearch` hook
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then we use the `useSearch` hook in the `PizzasView` component and change the
    iteration to be over `searchResults` instead of `pizzas`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now when you go to `/pizzas?search=hawaii`, the list will show only the pizza
    with the title `Hawaii` ([Figure 8-9](#figure_ch7_06)).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Pizzas page with the search query parameter](assets/lvue_0809.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Figure 8-9\. Pizzas page with the search term from query parameter
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'How about allowing the user to search while on the page and then syncing the
    updated search term with the query parameter? For that, we need to perform the
    following changes:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Add an input field to the `template` and bind it to the `search` variable:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Get the `router` instance using the `useRouter()` method:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use the `watch` function to watch for changes in the `search` value and update
    the query parameter using `router.replace`:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you type in the search field, the router instance will update the URL with
    the new query value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use Vue 2.x and below or Options API (without `setup()`), you can access
    the `router` and `route` instances using `this.$router` and `this.$route`, respectively.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have learned how to retrieve the query params with the `route`
    instance. Using the `route` instance in every component that needs to access the
    query params can be tedious. Instead, we can decouple the query params using props,
    which we will learn next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling Route Parameters Using Props
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the route configuration object, we can define the static props to pass to
    the view component as an object with static values or a function that returns
    the props. For example, in the following code, we change our `pizzas` route configuration
    to pass the `searchTerm` prop, whose value is from `route.query.search`, to the
    `PizzaView` component:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `PizzasView` component, we can remove the use of `useRoute` and access
    the `searchTerm` prop using the `props` object:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The behavior of the application stays the same as before.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use `props: true` to pass the `route.params` object to the view
    component as props, without caring about any specific props. When the route changes,
    we can combine this approach with navigation guards to perform side effects for
    the route’s parameters. More about navigation guards in the next section.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Navigation Guards
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigation guards are functions to help us control the navigation flow better.
    We can also use them to perform side effects when the route changes or before
    the navigation happens. There are three types of navigation guards and hooks:
    global, component-level, and route-level.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Global Navigation Guards
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For every router instance, Vue Router exposes a set of global-level navigation
    guards, including:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '`router.beforeEach`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Called *before* every navigation
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '`router.beforeResolve`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Called *after* Vue Router has resolved all async components in the route and
    all in-component guards (if any), but *before* confirming the navigation
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '`router.afterEach`'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Called *after* confirming the navigation and *before* the next update of the
    DOM and the navigation
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The global guards help perform validation before navigating to a specific route.
    For example, we can use the `router.beforeEach` to check if the user is authenticated
    before navigating to the `/pizzas` route. If not, we can redirect the user to
    the `/login` page:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this code, `to` is the destination route object to navigate to, `from` is
    the current route object, and `next` is a function to call to resolve the hook/guard.
    We need to trigger `next()` at the end, either without any argument to continue
    to the original destination or with a new route object as its argument to redirect
    the user to a different route. Otherwise, Vue Router will block the navigation
    flow.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Alternatively, we can use the `router.beforeResolve` to perform the same validation.
    The critical difference between `router.before``Each` and `router.beforeResolve`
    is that Vue Router triggers the latter after resolving all in-component guards.
    However, invoking the callback after settling everything will be less valuable
    when you want to avoid loading the suitable async component before confirming
    the navigation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'How about the `router.afterEach`? We can use this hook to perform actions like
    saving some page’s data as cache, tracking page analytics, or authenticating our
    user when navigating away from the login page:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While the global guards help perform side effects and control the redirecting
    of the whole application, in some cases we only want to achieve side effects for
    a specific route. In this case, using route-level guards is a good option.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Route-Level Navigation Guards
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For every route, we can define a callback for the `beforeEnter` guard, which
    Vue Router triggers when entering a path from a different one. Take our `/pizzas`
    route, for instance. Instead of mapping the `props` field with a function, we
    can achieve mapping the search query as a prop to the view by manually setting
    the `to.params.``searchTerm` field to `to.query.search` before entering the route:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that we have set `props: true` in the pizzas route. The UI will still
    display the same list of pizzas as before ([Figure 8-10](#figure_07_pizzaslist)).'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Pizzas list page.](assets/lvue_0810.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 8-10\. Pizzas list
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can manually modify the `to.query.searchTerm` within this guard. However,
    the changes won’t reflect on the URL path in the browser’s address bar. If we
    want to update the URL path, we can use the `next` function to redirect the user
    to a new route object with the desired query parameters.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Passing an Array of Callbacks to beforeEnter
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`beforeEnter` also accepts an array of callbacks, which Vue Router triggers
    in sequence. Hence we can perform multiple side effects for a specific route before
    entering it.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Like other global guards, the `beforeEnter` guard is handy when you want to
    perform authentication to specific routes, additional modification to the route
    parameters before passing them to the view component, etc. Next, we will learn
    how to leverage the component-level guards to perform side effects for a specific
    view.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Component-Level Router Guards
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From Vue 3.x on, Vue Router also provides composable guards at the component
    level to help control the flow of route leaving and updating, as `onBeforeRouteLeave`
    and `onBeforeRouteUpdate`. While Vue Router triggers `onBeforeRouteLeave` when
    the user navigates away from the current path view, it invokes `onBeforeRouteUpdate`
    when the user navigates to the same path view but with different parameters.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `onBeforeRouteLeave` to display a message to confirm the user’s
    navigation away from the Contact page with the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now when you are on the Contact page and try to navigate to another page, you
    will see a confirmation popup asking you to confirm your navigation, as in [Figure 8-11](#figure_07_alert).
    Clicking on the Cancel button will prevent navigation, and clicking the OK button
    will continue the navigation.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the confirmation popup.](assets/lvue_0811.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 8-11\. Confirmation popup
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use Options API for your components, `beforeRouteLeave` and `beforeRouteUpdate`
    guards would be available on the options object to achieve the same functionality.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: There is also a `beforeRouteEnter` hook, which the router triggers before Vue
    initialize the view component. This guard is similar to the `setup()` hook; hence,
    Vue Router’s API has no equivalent composable.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: We have explored the available navigation guards in different levels of a routing
    system and their order of execution, shown in [Figure 8-12](#figure_07_guardflow).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of the navigation guard flow.](assets/lvue_0812.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Figure 8-12\. Order of triggering navigation guards and their equivalent composable
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding the navigation flow and the order of execution of the guards is
    crucial to building a robust routing system. Next, we will learn how to create
    nested routes for our application.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Creating Nesting Routes
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we have built a basic one-level routing system for our application.
    In reality, most routing systems are more complex. Sometimes, we want to create
    subpages for a specific page, such as a Frequently Asked Questions (FAQs) page,
    and a Form page for the Contact page:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The default UI for the `/contact` page will be the `ContactView` page, and the
    user can navigate to the Form page by clicking on a link presented on this page.
    In this case, we need to create nested routes for the `/contact` page using the
    `children` field of the route configuration object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'First create the `ContactFaqView` and `ContactFormView` components, so the
    router can render them when matched, and then modify our `/contact` route:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We must also stub the placeholder component `RouterView` inside the `ContactView`
    to render the nested routes. As an example, let’s add the following code to the
    `ContactView`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now this Contact component will render `ContactFaqView` when the user navigates
    to *http://localhost:4000/contact/faq* ([Figure 8-13](#figure_07_contactfaq_nested))
    and `ContactFormView` when the user navigates to *http://localhost:4000/contact/form*,
    respectively.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Contact page with FAQ view rendered inside when navigating
    to http://localhost:4000/contact/faq](assets/lvue_0813.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: Figure 8-13\. Example output when navigating to http://localhost:4000/contact/faq
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This approach proves beneficial when we want to create a specific UI layout
    for a page containing nested views with nested routes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'We have seen how to create a nested route within a parent layout. However,
    in some cases we want to make a nested way without a parent layout, so we must
    declare the default path for the parent’s route as its nested route object. For
    example, instead of claiming the parent `/contact` route’s `name` and `component`,
    we can move it to the nested path with an empty path pattern:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This way, when the user navigates to *http://localhost:4000/contact/faq*, only
    the `Contact``FaqView` component will be rendered as a separate page, without
    the content of the `ContactView` ([Figure 8-14](#figure_07_contactfaq)).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot of the Contact page with FAQ view rendered inside when navigating
    to http://localhost:4000/contact/faq](assets/lvue_0814.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Figure 8-14\. Example output when navigating to http://localhost:4000/contact/faq
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-245
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see in the screenshot, the Contact link is still active in the navigation
    bar. This behavior happens because the link element of the Contact page still
    has the class `router-link-active`, but not `router-link-exact-active`. We can
    fix this styling issue by defining CSS rules for only the exact active link instead.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Using nested routes is very common in real-world applications; in fact, our
    `routes` array is already nested children for the router instance of the application.
    Declaring nested routes is a great way to organize routing structure and create
    dynamic routes, which we will explore next.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Creating Dynamic Routes
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most beneficial features of Vue Router is the ability to set up dynamic
    routes with routing parameters (routing params), which are variables extracted
    from a URL path. Routing params come in handy when we have a dynamic data-driven
    route structure. Each route shares a typical pattern and differs only by a unique
    identifier, such as a user or product id.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s revise our routes for the Pizza House and add a dynamic path for displaying
    one pizza at a time. One option is to define a new route, `/pizza`, and pass the
    pizza’s id as its query parameter as `/pizza?id=my-pizza-id` as we learned in
    [“Passing Data Between Routes”](#passing_data_between_routes). The better option,
    however, is to modify the `/pizzas` route and add a new nested route to it with
    the path pattern `:id`, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: By using `:id`, Vue Router will match any path that has a similar format, like
    */pizzas/1234-pizza-id*, and save the extracted id (like `1234-pizza-id`) as the
    `route.params.id` field.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we learned about the `props` field in the route configuration object,
    we can set its value to `true`, enabling the automatic mapping of route parameters
    to the `PizzaView`’s props:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the bound `PizzaView` component, we declare `id` as the component’s props
    with `defineProps()` and retrieve the pizza’s details from the `pizzas` array
    using the `useRoute` hook and this `id` prop:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can display the details of `pizza` in the `PizzaView` component as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now when you navigate to `/pizzas/1`, with `1` as the id of an existing pizza
    in the list, the `PizzaView` component will display the pizza’s details, as shown
    in [Figure 8-15](#figure_07_pizza_details).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot displaying the pizza details page of pizza with id 1](assets/lvue_0815.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: Figure 8-15\. Pizza details page
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Fetching Data from the Server
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, you should avoid fetching data again from the server, such as `pizzas`
    in the `PizzaView` component. Instead, you should use data store management such
    as Pinia ([Chapter 9](ch09.html#unique_chapter_id_08)) to store fetched `pizzas`
    and retrieve them from the store whenever needed.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Thus far, we have explored how to create nested and dynamic routes and decoupled
    the route’s parameters into props. In the next section, we will learn how to implement
    custom back and forward buttons for our application with Vue Router.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Going Back and Forward with the Router Instance
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Implementing a custom back button is a common feature in web applications in
    addition to using the native browser’s back button. We can use the `router.back()`
    method to navigate to the previous page in the history stack, where `router` is
    the app’s router instance received from `useRouter()`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To move forward in the history stack, we can use the `router.forward()` method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using router.go() To Navigate to a Specific Page in the History Stack
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also use the `router.go()` method, which accepts an argument as the
    number of steps in the history stack to go back or forward. For instance, `router.go(-2)`
    will navigate to the page two steps back, while `router.go(2)` will jump two steps
    forward (if they exist).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'We have explored the basics of Vue Router and created a basic routing system
    for our application with all the pages we need. But there is one thing we need
    to handle: if you try to navigate a path that doesn’t exist, you will see a blank
    page. This scenario happens because Vue Router can’t find a matched component
    to render when the user tries to navigate to a path that doesn’t exist. This will
    be our next topic.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Handling Unknown Routes
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In most scenarios, we can’t control all the paths users will try to navigate
    while using our application. For instance, a user may attempt to access *https://localhost:4000/pineapples*,
    for which we haven’t defined a route. We can display a 404 page to the user in
    such cases by using the regular expressions (regex) pattern `/:pathMatch(.**)**`
    as `path` in a new `error` route:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Vue Router will match the unfound paths against the pattern `/:pathMatch(.**)**`
    accordingly and then store the matched path value in the `pathMatch` parameter
    of the route location object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Using Regex to Match Unknown Paths
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can replace `pathMatch` with any other name you want. Its purpose is to
    let Vue Router knows where to store the matched path value.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ErrorView` component, we can display a message to the user:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now when we try to visit *https://localhost:4000/pineapples* or any unknown
    path, we will see the 404 page rendered.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we can use the `useRoute()` method of the `vue-router` package
    to access the current route location and display its path’s value:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code will display the path of the current route, which is, in this case,
    `/pineapples` ([Figure 8-16](#figure_07_error)).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the 404 page](assets/lvue_0816.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
- en: Figure 8-16\. The 404 page
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Alternatively, we can use the `redirect` property in the route configuration
    to redirect users to a specific route, such as the home page, when they visit
    an unknown path. For example, we can rewrite our `error` route as:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When we visit an unknown path, the router instance will automatically redirect
    us to the home page, and we no longer need an `ErrorView` component.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored how we can build a routing system for our
    Vue application using different APIs provided by Vue Router in our application.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何利用Vue Router在我们的应用程序中使用不同的API构建路由系统。
- en: Moving between routes requires the data flow to be consistent, like handling
    data flow between components that aren’t in a direct parent-children relationship.
    To solve this challenge, we need an efficient data management system for our application.
    The next chapter introduces Pinia, the official data management library for Vue,
    and how we can build an efficient, reusable data management system using Pinia
    APIs.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在路由之间移动需要数据流保持一致，就像处理不直接处于父子关系的组件之间的数据流一样。为了解决这个挑战，我们需要为我们的应用程序设计一个高效的数据管理系统。下一章介绍了Pinia，Vue官方的数据管理库，以及如何利用Pinia的API构建一个高效、可重复使用的数据管理系统。
