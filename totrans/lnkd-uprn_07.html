<html><head></head><body><section data-pdf-bookmark="Chapter 7. mTLS, Linkerd, and Certificates" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="LUAR_mtls_and_certs">
<h1 class="calibre7"><span class="calibre">Chapter 7. </span>mTLS, Linkerd, and Certificates</h1>


<p class="author1">Moving from a monolithic application<a data-primary="monolithic applications" data-secondary="security" data-type="indexterm" id="id1036" class="calibre4"/><a data-primary="security" data-secondary="monolithic versus microservice applications" data-type="indexterm" id="id1037" class="calibre4"/><a data-primary="microservices architecture" data-secondary="security" data-tertiary="monolithic applications versus" data-type="indexterm" id="id1038" class="calibre4"/><a data-primary="microservices architecture" data-secondary="monolithic applications versus" data-tertiary="security" data-type="indexterm" id="id1039" class="calibre4"/><a data-primary="monolithic applications" data-secondary="microservices architecture versus" data-tertiary="security" data-type="indexterm" id="id1040" class="calibre4"/><a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-tertiary="about security" data-type="indexterm" id="id1041" class="calibre4"/><a data-primary="communication" data-secondary="secure communications" data-tertiary="about security threats" data-type="indexterm" id="id1042" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-tertiary="about security threats" data-type="indexterm" id="id1043" class="calibre4"/> to a microservices application puts us in a very interesting position
as far as security is concerned. Where the monolith provided a natural
security perimeter at the edge of its process, a microservices application has no
natural security perimeter at all. Sensitive information that was previously
protected by being passed in a function call inside the process now has to be
sent over the network, as shown in <a data-type="xref" href="#monolith-vs-microservices" class="calibre4">Figure 7-1</a>.</p>

<figure class="calibre23"><div class="figure" id="monolith-vs-microservices">
<img alt="luar 0701" src="assets/luar_0701.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-1. </span>Security stance in a monolithic versus a microservices application</h6>
</div></figure>

<p class="author1">Additionally, the microservices are often running on infrastructure and
network resources provided by outside teams, organizations, or even companies.
If nothing is done to counter the threat, it’s all too easy for an attacker
with access to the network to read, intercept, and modify
communications between microservices. This is obviously a serious problem.</p>

<p class="author1">Finally, the network doesn’t even provide any secure way for a given
microservice to know who made a call to it. The called microservice can find out
the caller’s IP and MAC addresses, but these aren’t actually secure—it’s
very easy to spoof the sender’s IP address, for example. Things just get
worse when the application is running on a network it doesn’t control.</p>






<section data-pdf-bookmark="Secure Communications" data-type="sect1" class="preface"><div class="preface" id="id149">
<h1 class="calibre8">Secure Communications</h1>

<p class="author1">To allow any microservices application<a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-type="indexterm" id="id1044" class="calibre4"/><a data-primary="communication" data-secondary="secure communications" data-type="indexterm" id="id1045" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-type="indexterm" id="id1046" class="calibre4"/> to work, we need <em class="hyperlink">secure
communications</em>. There are three distinct elements to truly secure
communications:</p>
<dl class="calibre10">
<dt class="calibre11">Authenticity</dt>
<dd class="calibre12">
<p class="calibre13">We must be confident that we are talking to who we think
we’re talking to.</p>
</dd>
<dt class="calibre11">Confidentiality</dt>
<dd class="calibre12">
<p class="calibre13">We must be confident that no one can read the data being
sent over the connection.</p>
</dd>
<dt class="calibre11">Integrity</dt>
<dd class="calibre12">
<p class="calibre13">We must be confident that our messages haven’t been altered in
transit.</p>
</dd>
</dl>

<p class="author1">These aren’t new problems, and many different techniques have evolved to
address them in various ways. Linkerd relies on one of the most trusted of
these: <em class="hyperlink">mutual TLS</em>, or <em class="hyperlink">mTLS</em>.</p>








<section data-pdf-bookmark="TLS and mTLS" data-type="sect2" class="preface"><div class="preface" id="id52">
<h2 class="calibre27">TLS and mTLS</h2>

<p class="author1">TLS, defined by <a href="https://oreil.ly/K6Wwg" class="calibre4">RFC 8446</a>, is a <a data-primary="TLS (Transport Layer Security)" data-secondary="about" data-type="indexterm" id="ch07-tls" class="calibre4"/><a data-primary="communication" data-secondary="Transport Layer Security" data-type="indexterm" id="ch07-tls2" class="calibre4"/><a data-primary="security" data-secondary="Transport Layer Security" data-type="indexterm" id="ch07-tls3" class="calibre4"/><a data-primary="communication" data-secondary="secure communications" data-tertiary="TLS and mTLS" data-type="indexterm" id="ch07-tls5" class="calibre4"/><a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-tertiary="TLS and mTLS" data-type="indexterm" id="ch07-tls6" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-tertiary="TLS and mTLS" data-type="indexterm" id="ch07-tls7" class="calibre4"/><a data-primary="TLS (Transport Layer Security)" data-secondary="about" data-tertiary="RFC 8446 URL" data-type="indexterm" id="id1047" class="calibre4"/><a data-primary="resources online" data-secondary="TLS RFC" data-type="indexterm" id="id1048" class="calibre4"/>battle-tested,
industry-standard mechanism for secure communications that dates back to 1999.
It’s the same mechanism that web browsers have used for years to securely
communicate with banks, shopping sites, etc. The modern Internet has been
relying on TLS for nearly 25 years, and cryptanalysts have being trying for at
least that long to find weaknesses in it. TLS provides authenticity,
confidentiality, and integrity using the architecture shown in
<a data-type="xref" href="#tls-architecture-diagram-2" class="calibre4">Figure 7-2</a>.</p>

<figure class="calibre23"><div class="figure" id="tls-architecture-diagram-2">
<img alt="luar 0702" src="assets/luar_0702.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-2. </span>TLS architecture</h6>
</div></figure>

<p class="author1">(Linkerd specifically uses TLS version 1.3, but all TLS versions have used the
same architecture.)</p>

<p class="author1">TLS ensures confidentiality by encrypting data in transit and integrity by
adding message digests—cryptographic checksums—so that the receiver can
validate that the data sent hasn’t been altered. This takes care of two of
our three concerns.</p>

<p class="author1">Authenticity is more complex.<a data-primary="TLS (Transport Layer Security)" data-secondary="X.509 certificates" data-type="indexterm" id="id1049" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="TLS" data-type="indexterm" id="id1050" class="calibre4"/><a data-primary="certificates" data-secondary="TLS" data-type="indexterm" id="id1051" class="calibre4"/><a data-primary="authentication" data-secondary="X.509 certificates" data-tertiary="TLS" data-type="indexterm" id="id1052" class="calibre4"/> TLS uses <em class="hyperlink">certificates</em> to cryptographically
allow validating the identity of both the sender and the receiver. The TLS
standard always requires the receiving end to identify itself by sending a
certificate. In many cases, this is all that’s needed; for example, when you
use your web browser to visit a shopping site, it’s not terribly useful for
your browser to send a certificate since the shopping site will require you to
log in separately.</p>

<p class="author1">For a service mesh, though,<a data-primary="service meshes" data-secondary="authentication" data-type="indexterm" id="id1053" class="calibre4"/><a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-tertiary="service meshes" data-type="indexterm" id="id1054" class="calibre4"/><a data-primary="TLS (Transport Layer Security)" data-secondary="X.509 certificates" data-tertiary="service mesh mTLS" data-type="indexterm" id="id1055" class="calibre4"/><a data-primary="certificates" data-secondary="TLS" data-tertiary="service mesh mTLS" data-type="indexterm" id="id1056" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="TLS" data-tertiary="service mesh mTLS" data-type="indexterm" id="id1057" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="mTLS" data-tertiary="service mesh mTLS" data-type="indexterm" id="id1058" class="calibre4"/><a data-primary="certificates" data-secondary="mTLS" data-tertiary="service mesh mTLS" data-type="indexterm" id="id1059" class="calibre4"/><a data-primary="service meshes" data-secondary="mTLS for" data-seealso="mTLS" data-type="indexterm" id="id1060" class="calibre4"/><a data-primary="communication" data-secondary="secure communications" data-tertiary="service meshes" data-type="indexterm" id="id1061" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-tertiary="service meshes" data-type="indexterm" id="id1062" class="calibre4"/> we need to authenticate both ends of the
connection. This means we require both ends to send certificates for
identification. When we use TLS like this (as Linkerd does), we call it
mutual TLS or mTLS to distinguish it from the case where only the
receiver identifies itself. This is shown in <a data-type="xref" href="#tls-vs-mtls" class="calibre4">Figure 7-3</a>.</p>

<figure class="calibre23"><div class="figure" id="tls-vs-mtls">
<img alt="luar 0703" src="assets/luar_0703.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-3. </span>TLS compared to mTLS</h6>
</div></figure>

<p class="author1">Using certificates in both directions lets mTLS build on the guarantees
provided by TLS: it provides a cryptographically validated identity of the
client as well as the server, while still maintaining encryption in transit.
For Linkerd, this means that mTLS guarantees that your workloads know whom
they’re talking to and that no third party will be able to intercept or listen
in on their communication.<a data-startref="ch07-tls" data-type="indexterm" id="id1063" class="calibre4"/><a data-startref="ch07-tls2" data-type="indexterm" id="id1064" class="calibre4"/><a data-startref="ch07-tls3" data-type="indexterm" id="id1065" class="calibre4"/><a data-startref="ch07-tls5" data-type="indexterm" id="id1066" class="calibre4"/><a data-startref="ch07-tls6" data-type="indexterm" id="id1067" class="calibre4"/><a data-startref="ch07-tls7" data-type="indexterm" id="id1068" class="calibre4"/></p>
</div></section>








<section data-pdf-bookmark="mTLS and Certificates" data-type="sect2" class="preface"><div class="preface" id="id53">
<h2 class="calibre27">mTLS and Certificates</h2>

<p class="author1">As we first discussed in <a data-type="xref" href="ch02.html#LUAR_intro_to_linkerd" class="calibre4">Chapter 2</a>, the <a data-primary="certificates" data-secondary="mTLS" data-type="indexterm" id="id1069" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="mTLS" data-type="indexterm" id="id1070" class="calibre4"/><a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-seealso="certificates" data-tertiary="certificates" data-type="indexterm" id="id1071" class="calibre4"/><a data-primary="communication" data-secondary="secure communications" data-seealso="certificates" data-tertiary="mTLS certificates" data-type="indexterm" id="id1072" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-seealso="certificates" data-tertiary="mTLS certificates" data-type="indexterm" id="id1073" class="calibre4"/><a data-primary="keypairs of public and private keys" data-secondary="mTLS certificates" data-type="indexterm" id="id1074" class="calibre4"/><a data-primary="private keys" data-secondary="certificates" data-tertiary="mTLS certificates" data-type="indexterm" id="id1075" class="calibre4"/><a data-primary="public keys" data-secondary="mTLS certificates" data-type="indexterm" id="id1076" class="calibre4"/>certificates that
mTLS relies on are built on keypairs consisting of a public key and a
private key. The private key (of course) needs to be kept private: only the
entity that the keypair identifies can know it. The public key, on the other
hand, should be widely distributed: it’s what allows verifying the identity of
the entity holding the private key, so everyone who needs to communicate with
that entity needs the public key.</p>

<p class="author1">Certificates give us a way to associate a <em class="hyperlink">name</em> and other metadata with the
keypair, which is useful because it allows us humans to more easily work with
the certificate. They also give us a way for one certificate to attest that
another is valid (<em class="hyperlink">signing</em> or <em class="hyperlink">issuing</em> a certificate), which is useful
because it makes it much simpler to determine whether or not we trust a
certificate.</p>

<p class="author1">Using certificates to sign other certificates<a data-primary="certificates" data-secondary="trust hierarchy" data-type="indexterm" id="id1077" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="trust hierarchy" data-type="indexterm" id="id1078" class="calibre4"/><a data-primary="trust hierarchy of certificates" data-type="indexterm" id="id1079" class="calibre4"/> creates a <em class="hyperlink">trust hierarchy</em>, as
shown in <a data-type="xref" href="#certificate-hierarchy-diagram-2" class="calibre4">Figure 7-4</a>. This hierarchy is important: mTLS
can know that a certificate is valid as long as it has access to any of the
public keys higher up in the hierarchy, and systems built on mTLS (including
Linkerd) take advantage of this property.</p>

<figure class="calibre23"><div class="figure" id="certificate-hierarchy-diagram-2">
<img alt="luar 0704" src="assets/luar_0704.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-4. </span>The certificate trust hierarchy</h6>
</div></figure>

<p class="author1">Finally, it’s important to limit the<a data-primary="keypairs of public and private keys" data-secondary="rotating the keys" data-type="indexterm" id="id1080" class="calibre4"/><a data-primary="private keys" data-secondary="rotating the keys" data-type="indexterm" id="id1081" class="calibre4"/><a data-primary="public keys" data-secondary="rotating the keys" data-type="indexterm" id="id1082" class="calibre4"/><a data-primary="rotating the keys" data-type="indexterm" id="id1083" class="calibre4"/> lifespan of a given keypair: the longer a
key is used, the greater the danger if it’s compromised. Every so often, we
need to replace the keys in use for a given certificate. This involves
creating a new keypair, then generating a new certificate, and finally getting it
properly signed. This entire process is called <em class="hyperlink">rotating</em> the certificate; it
is the main source of operational complexity when working with certificates.</p>
</div></section>








<section data-pdf-bookmark="Linkerd and mTLS" data-type="sect2" class="preface"><div class="preface" id="id54">
<h2 class="calibre27">Linkerd and mTLS</h2>

<p class="author1">Linkerd transparently adds mTLS<a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-tertiary="Linkerd and mTLS" data-type="indexterm" id="id1084" class="calibre4"/><a data-primary="communication" data-secondary="secure communications" data-tertiary="mTLS and Linkerd" data-type="indexterm" id="id1085" class="calibre4"/><a data-primary="TLS (Transport Layer Security)" data-secondary="X.509 certificates" data-tertiary="mTLS and Linkerd" data-type="indexterm" id="id1086" class="calibre4"/><a data-primary="certificates" data-secondary="mTLS" data-tertiary="Linkerd and mTLS" data-type="indexterm" id="id1087" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="mTLS" data-tertiary="Linkerd and mTLS" data-type="indexterm" id="id1088" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="workload certificates" data-type="indexterm" id="id1089" class="calibre4"/><a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="workload certificates" data-type="indexterm" id="id1090" class="calibre4"/><a data-primary="workload certificates" data-type="indexterm" id="id1091" class="calibre4"/><a data-primary="workloads" data-secondary="deploying Linkerd" data-tertiary="workload certificates" data-type="indexterm" id="id1092" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="workload certificates" data-type="indexterm" id="id1093" class="calibre4"/><a data-primary="Pods" data-secondary="workload certificates and mTLS" data-type="indexterm" id="id1094" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-tertiary="mTLS and Linkerd" data-type="indexterm" id="id1095" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="workload certificates" data-type="indexterm" id="id1096" class="calibre4"/> to all of your interapplication
communications. This means that all meshed traffic is protected against
interception and tampering. It also means your workloads can be certain of
which workloads they’re communicating with at all times.</p>

<p class="author1">This can only work if every meshed workload has a valid TLS certificate
associated with that workload, and if all these <em class="hyperlink">workload certificates</em> are
part of the same trust hierarchy. <a data-primary="workload certificates" data-secondary="Linkerd handling automatically" data-type="indexterm" id="id1097" class="calibre4"/>Managing this by hand would be incredibly
difficult, so Linkerd helps to automate it.</p>

<p class="author1">We talked about adding workloads to the mesh in <a data-type="xref" href="ch04.html#LUAR_meshing_workloads" class="calibre4">Chapter 4</a>,
but let’s revisit that in a bit more detail. When a workload is added to the
mesh, it gets a <code class="calibre9">linkerd2-proxy</code> container added to its Pod. That container
will be configured to intercept all TCP traffic going into and out of the Pod,
and it will always attempt to build an mTLS session when a connection is made
with another Pod. If the other Pod also has a <code class="calibre9">linkerd2-proxy</code>—meaning that
it’s part of the mesh!—then the connection will be protected with mTLS.</p>

<p class="author1">Since this mTLS connection happens from proxy to proxy, the application
containers within the Pods never even know that mTLS is happening: from an
application perspective, all communications between Pods look like they’re
using cleartext. This means that the application Pods don’t see any
information about the certificates that Linkerd is using, which in turn means
that they don’t need any special code to handle certificate information.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Protocol Detection and the Proxy</h1>
<p class="author1">The fact that the proxy intercepts <em class="hyperlink">all</em> communication<a data-primary="protocol detection" data-secondary="mTLS and" data-type="indexterm" id="id1098" class="calibre4"/><a data-primary="communication" data-secondary="secure communications" data-tertiary="protocol detection and" data-type="indexterm" id="id1099" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-tertiary="protocol detection and" data-type="indexterm" id="id1100" class="calibre4"/><a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-tertiary="protocol detection and" data-type="indexterm" id="id1101" class="calibre4"/> between Pods means that
you may sometimes need to give it extra information about the protocol, or
indeed not try to do mTLS. This is all covered at some length in
<a data-type="xref" href="ch04.html#LUAR_meshing_workloads" class="calibre4">Chapter 4</a>, but a good rule of thumb is that as long as the
client speaks first, you’re probably OK. If the server speaks first, you’ll
need to do some configuration.</p>

<p class="author1">Of course, that’s only true if the server is in the mesh! If you’re trying to
communicate from a meshed Pod to an unmeshed Pod, you will always need to tell
Linkerd to skip the traffic: it won’t be able to do mTLS without the
destination Pod being part of the mesh.</p>
</div>
</div></section>
</div></section>






<section data-pdf-bookmark="Certificates and Linkerd" data-type="sect1" class="preface"><div class="preface" id="id55">
<h1 class="calibre8">Certificates and Linkerd</h1>

<p class="author1">We talked about Linkerd certificates<a data-primary="certificates" data-secondary="Linkerd and" data-type="indexterm" id="id1102" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-type="indexterm" id="id1103" class="calibre4"/> back in <a data-type="xref" href="ch03.html#LUAR_deploying_linkerd" class="calibre4">Chapter 3</a>. In this section, we’ll go into more detail about
exactly what these certificates are used for, how they are created, and what
needs to happen when you want to rotate them. We’re going to cover the three
tiers of certificates used in Linkerd: trust anchor, identity issuer, and workload certificates.</p>

<p class="author1">From Linkerd’s point of view,<a data-primary="trust anchor certificate" data-type="indexterm" id="id1104" class="calibre4"/><a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="trust anchor certificate" data-type="indexterm" id="id1105" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="trust anchor certificate" data-type="indexterm" id="id1106" class="calibre4"/> trust starts with its trust anchor
certificate, as shown in <a data-type="xref" href="#linkerd-trust-diagram-2" class="calibre4">Figure 7-5</a>. The trust anchor can, of
course, be signed by some other higher-level certificate—as far as Linkerd
is concerned, though, trust stops with the trust anchor.</p>

<figure class="calibre23"><div class="figure" id="linkerd-trust-diagram-2">
<img alt="luar 0705" src="assets/luar_0705.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-5. </span>The Linkerd trust hierarchy</h6>
</div></figure>

<p class="author1">Linkerd automatically handles the<a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="workload certificates" data-type="indexterm" id="id1107" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="workload certificates" data-type="indexterm" id="id1108" class="calibre4"/><a data-primary="workload certificates" data-type="indexterm" id="id1109" class="calibre4"/><a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="certificate management" data-type="indexterm" id="id1110" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="certificate management" data-type="indexterm" id="id1111" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="workload certificates" data-type="indexterm" id="id1112" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="workload certificates" data-type="indexterm" id="id1113" class="calibre4"/> generation, distribution, and rotation of
workload certificates, while relying on the user to manage the trust anchor
and the identity issuer. This is shown in <a data-type="xref" href="#linkerd-certificate-management" class="calibre4">Figure 7-6</a>.</p>

<figure class="calibre23"><div class="figure" id="linkerd-certificate-management">
<img alt="luar 0706" src="assets/luar_0706.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-6. </span>Linkerd certificate management</h6>
</div></figure>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Never Let Your Certificates Expire</h1>
<p class="author1">Because Linkerd requires<a data-primary="production" data-secondary="downtime from certificate expiration" data-type="indexterm" id="id1114" class="calibre4"/><a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="never let certificates expire" data-type="indexterm" id="id1115" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="never let certificates expire" data-type="indexterm" id="id1116" class="calibre4"/><a data-primary="expired certificates" data-type="indexterm" id="id1117" class="calibre4"/><a data-primary="mTLS (mutual TLS)" data-secondary="certificates should not expire" data-type="indexterm" id="id1118" class="calibre4"/> mTLS connections between Pods by default, the health
and security of the certificates it uses are absolutely critical to the
healthy operation of the mesh—and thus your platform. If certificates
expire, or can’t be generated for new Pods, <em class="hyperlink">you will incur downtime</em>.</p>

<p class="author1">This is the most common cause of downtime in production Linkerd clusters.
Understanding and monitoring your Linkerd certificates is vital.</p>
</div>








<section data-pdf-bookmark="The Linkerd Trust Anchor" data-type="sect2" class="preface"><div class="preface" id="id56">
<h2 class="calibre27">The Linkerd Trust Anchor</h2>

<p class="author1">The Linkerd <em class="hyperlink">trust anchor</em> is the <a data-primary="trust anchor certificate" data-type="indexterm" id="id1119" class="calibre4"/><a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="trust anchor certificate" data-type="indexterm" id="id1120" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="trust anchor certificate" data-type="indexterm" id="id1121" class="calibre4"/><a data-primary="keypairs of public and private keys" data-secondary="Linkerd trust anchor" data-type="indexterm" id="id1122" class="calibre4"/><a data-primary="private keys" data-secondary="Linkerd trust anchor" data-type="indexterm" id="id1123" class="calibre4"/><a data-primary="public keys" data-secondary="Linkerd trust anchor" data-type="indexterm" id="id1124" class="calibre4"/>certificate that provides the foundation
for all trust in your cluster. It is used for exactly two things:</p>

<ul class="printings">
<li class="calibre6">
<p class="author1">When installing Linkerd, you will use the trust anchor to issue the Linkerd
identity issuer certificate, which we’ll discuss in the next section.
This requires access to both the private and public keys of the trust
anchor and is something done outside of Linkerd, before installation.</p>
</li>
<li class="calibre6">
<p class="author1">Whenever a workload makes an mTLS connection to another workload, both
workloads use the identity issuer and the trust anchor to verify the
identity of the other workload. This requires access to only the public key
of the trust anchor and happens constantly while the mesh is operating.</p>
</li>
</ul>

<p class="author1">Since only the public key is needed for in-cluster operations (the second bullet in the preceding list), we
recommend that you never store your trust anchor’s private key in your
Kubernetes cluster. Instead, store the trust anchor in a secure system
outside of Kubernetes and only copy its public key into the cluster, as we’ll
cover in this chapter.</p>

<p class="author1">One very important thing to realize<a data-primary="trust anchor certificate" data-secondary="same trust anchor to multiple clusters" data-type="indexterm" id="id1125" class="calibre4"/><a data-primary="multicluster setups" data-secondary="same trust anchor to multiple clusters" data-type="indexterm" id="id1126" class="calibre4"/><a data-primary="trust hierarchy of certificates" data-secondary="multicluster setups" data-type="indexterm" id="id1127" class="calibre4"/> is that the trust anchor is not
intrinsically tied to a cluster: it is completely independent of network
topology or cluster boundaries. This means that if you give multiple clusters
the same trust anchor, they’ll be able to do secure mTLS between workloads in
different clusters, as shown in <a data-type="xref" href="#multicluster-trust-hierarchy-1" class="calibre4">Figure 7-7</a>. This is
extremely powerful, as it makes multicluster meshes very easy to set up.</p>

<figure class="calibre23"><div class="figure" id="multicluster-trust-hierarchy-1">
<img alt="luar 0707" src="assets/luar_0707.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-7. </span>Multicluster trust hierarchy</h6>
</div></figure>

<p class="author1">Correspondingly, two clusters that should <em class="hyperlink">not</em> be able to communicate with
each other should <em class="hyperlink">not</em> share a trust anchor! For most organizations, this
implies not sharing trust anchors across environment tiers—that is, test
clusters shouldn’t have the same trust anchor as development or production
clusters.</p>
</div></section>








<section data-pdf-bookmark="The Linkerd Identity Issuer" data-type="sect2" class="preface"><div class="preface" id="id57">
<h2 class="calibre27">The Linkerd Identity Issuer</h2>

<p class="author1">At the second level of the Linkerd<a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="identity issuer certificate" data-type="indexterm" id="id1128" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="identity issuer certificate" data-type="indexterm" id="id1129" class="calibre4"/><a data-primary="identity issuer certificate" data-type="indexterm" id="id1130" class="calibre4"/><a data-primary="control plane of Linkerd" data-secondary="Linkerd architecture" data-tertiary="identity controller" data-type="indexterm" id="id1131" class="calibre4"/><a data-primary="identity controller of control plane" data-secondary="identity issuer certificate" data-type="indexterm" id="id1132" class="calibre4"/> trust hierarchy is the identity issuer
certificate, as we also briefly touched on in <a data-type="xref" href="ch03.html#LUAR_deploying_linkerd" class="calibre4">Chapter 3</a>.
The identity issuer is used by the Linkerd control plane’s identity controller to
issue workload certificates, as shown in <a data-type="xref" href="#issuer-certificate-diagram" class="calibre4">Figure 7-8</a>.
Since the identity issuer<a data-primary="keypairs of public and private keys" data-secondary="identity issuer certificate" data-type="indexterm" id="id1133" class="calibre4"/><a data-primary="public keys" data-secondary="identity issuer certificate" data-type="indexterm" id="id1134" class="calibre4"/><a data-primary="private keys" data-secondary="identity issuer certificate" data-type="indexterm" id="id1135" class="calibre4"/><a data-primary="Secrets" data-secondary="identity issuer certificate storage" data-type="indexterm" id="id1136" class="calibre4"/><a data-primary="identity issuer certificate" data-secondary="Secret for storage in a cluster" data-type="indexterm" id="id1137" class="calibre4"/> is used to sign certificates, Linkerd must have
access to both the private and public keys of the identity issuer certificate,
which means that it must be stored in a Secret in the cluster.</p>

<figure class="calibre23"><div class="figure" id="issuer-certificate-diagram">
<img alt="luar 0708" src="assets/luar_0708.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-8. </span>The issuer certificate and the identity controller</h6>
</div></figure>

<p class="author1">The identity issuer must be signed by the trust anchor, and since it must be
stored in the cluster, each cluster must have its own identity issuer.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Linkerd Cannot Warn You If You Share Identity Issuer Certificates</h1>
<p class="author1">There isn’t any good way for<a data-primary="identity issuer certificate" data-secondary="same certificate in two clusters" data-type="indexterm" id="id1138" class="calibre4"/> Linkerd to warn you if you accidentally use the
same identity issuer certificate in two clusters, and in fact everything will
work. <em class="hyperlink">Don’t do this</em>, though. If you do, the two clusters will become
indistinguishable, and an evildoer will potentially be able to use one
cluster to create a workload certificate that can bypass authorization policy
in the other cluster.</p>

<p class="author1">Make sure that each cluster has a unique identity issuer.</p>
</div>
</div></section>








<section data-pdf-bookmark="Linkerd Workload Certificates" data-type="sect2" class="preface"><div class="preface" id="id58">
<h2 class="calibre27">Linkerd Workload Certificates</h2>

<p class="author1">Finally, we come to the certificates<a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="workload certificates" data-type="indexterm" id="id1139" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="workload certificates" data-type="indexterm" id="id1140" class="calibre4"/><a data-primary="workload certificates" data-type="indexterm" id="id1141" class="calibre4"/><a data-primary="workloads" data-secondary="adding to the mesh" data-tertiary="workload certificates" data-type="indexterm" id="id1142" class="calibre4"/><a data-primary="service meshes" data-secondary="adding workloads to" data-tertiary="workload certificates" data-type="indexterm" id="id1143" class="calibre4"/><a data-primary="Pods" data-secondary="workload certificates and mTLS" data-type="indexterm" id="id1144" class="calibre4"/> that actually do the work of providing
mTLS between our applications. When a workload is added to a Linkerd mesh, the
Linkerd proxy associated with each workload Pod automatically requests a
workload certificate from the Linkerd identity controller. This workload
certificate is the basis for the workload’s identity. It will be signed by the
identity issuer certificate, and since every other workload has access to the
public keys of the identity issuer and the trust anchor, the validity of the
workload certificate can be verified all the way back to the trust anchor.</p>

<p class="author1">The workload certificate for each<a data-primary="policy" data-secondary="workload certificates for Pod identity" data-type="indexterm" id="id1145" class="calibre4"/><a data-primary="Pods" data-secondary="policy" data-tertiary="workload identity, not IP address" data-type="indexterm" id="id1146" class="calibre4"/><a data-primary="Pods" data-secondary="IP addresses" data-tertiary="policy via workload identity" data-type="indexterm" id="id1147" class="calibre4"/> Pod is cryptographically linked to the
Kubernetes ServiceAccount assigned to the Pod, and its name includes the name
of the ServiceAccount and the namespace. This allows your Pods to be uniquely
identified when they communicate with each other. It also provides us with the
identity we will need later when we build policy. <a data-primary="workload certificates" data-secondary="Pod identity name format" data-type="indexterm" id="id1148" class="calibre4"/><a data-primary="Pods" data-secondary="identity name format" data-type="indexterm" id="id1149" class="calibre4"/><a data-primary="identity" data-secondary="Pod identity name format" data-type="indexterm" id="id1150" class="calibre4"/>The basic format for the
identity name is:</p>

<pre data-type="programlisting" class="calibre36">$serviceAccountName.$namespace.serviceaccount.identity.linkerd.$clusterDomain</pre>

<p class="author1">where <code class="calibre9">$clusterDomain</code> will be <code class="calibre9">cluster.local</code> if you haven’t overridden
it. (Most single-cluster Linkerd installations won’t need to override this.)</p>

<p class="author1">Linkerd handles workload certificates<a data-primary="workload certificates" data-secondary="Linkerd handling automatically" data-type="indexterm" id="id1151" class="calibre4"/> completely automatically; you should
never need to worry about managing them.</p>
</div></section>








<section data-pdf-bookmark="Certificate Lifetimes and Rotation" data-type="sect2" class="preface"><div class="preface" id="id59">
<h2 class="calibre27">Certificate Lifetimes and Rotation</h2>

<p class="author1">As we mentioned earlier,<a data-primary="keypairs of public and private keys" data-secondary="rotating the keys" data-tertiary="rotating the certificates" data-type="indexterm" id="id1152" class="calibre4"/><a data-primary="private keys" data-secondary="rotating the keys" data-tertiary="rotating the certificates" data-type="indexterm" id="id1153" class="calibre4"/><a data-primary="public keys" data-secondary="rotating the keys" data-tertiary="rotating the certificates" data-type="indexterm" id="id1154" class="calibre4"/><a data-primary="rotating the keys" data-secondary="rotating the certificates" data-type="indexterm" id="id1155" class="calibre4"/> the longer you use a given key, the more
valuable it tends to be to break that key. For this reason, certificates are
given fixed lifespans, and they must be replaced before they expire. Replacing
a certificate with a new one is called <em class="hyperlink">rotating</em> the certificate.</p>

<p class="author1">Choosing exactly how often to rotate certificates is a balancing act. Rotating
very frequently is most secure, but it can disrupt normal operations and
require an impractical amount of effort. Rotating very infrequently—or not
at all—is very simple, but also very insecure.</p>

<p class="author1">Linkerd handles rotating <a data-primary="workload certificates" data-secondary="Linkerd handling automatically" data-tertiary="rotating the certificates" data-type="indexterm" id="id1156" class="calibre4"/>workload certificates for you: by default, workload
certificates expire every 24 hours. <a data-primary="trust anchor certificate" data-secondary="rotating the certificates" data-type="indexterm" id="id1157" class="calibre4"/><a data-primary="identity issuer certificate" data-secondary="rotating the certificates" data-type="indexterm" id="id1158" class="calibre4"/>However, rotating the identity issuer and
trust anchor certificates is left up to you, since your organization’s policy will often
dictate how often you’ll be rotating. The critical things to consider are:</p>
<dl class="calibre10">
   <dt class="calibre11">Every time you rotate the trust anchor, you <em class="hyperlink">must</em> also rotate the identity issuer.</dt>

   <dd class="calibre12">
      <p class="calibre13">This is because the trust anchor must sign the identity issuer. If you’ve just generated a new trust anchor, there’s no way the old identity issuer can be signed by the new trust anchor, so you need a new identity issuer too.</p>
      <p class="calibre13">
         In turn, this means that you <em class="hyperlink">cannot</em> rotate the trust anchor more often
         than the identity issuer.
      </p>
   </dd>

   <dt class="calibre11">Every time you rotate the identity issuer, you <em class="hyperlink">may</em> also rotate the workload certificates.</dt>

   <dd class="calibre12"><p class="calibre13">Since workload certificates are automatically rotated by Linkerd, when you rotate the identity issuer you can opt to just wait for Linkerd to rotate the workload certificates. If you want to be sure they’re rotated immediately, just restart the workloads.</p></dd>
</dl>

<p class="author1">The way you rotate a certificate depends on which certificate it is:</p>
<dl class="calibre10">
<dt class="calibre11">Rotating the trust anchor</dt>
<dd class="calibre12">
<p class="calibre13">Rotating the trust anchor is actually out of scope for this book: in practice,
if you adhere to the principle that clusters themselves should be ephemeral,
it can be more practical to simply have the lifespan of the trust anchor
mirror that of the cluster. <a data-primary="trust anchor certificate" data-secondary="rotating the certificates" data-tertiary="documentation URL" data-type="indexterm" id="id1159" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="trust anchor certificate rotation" data-type="indexterm" id="id1160" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="trust anchor certificate rotation" data-type="indexterm" id="id1161" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="trust anchor certificate rotation" data-type="indexterm" id="id1162" class="calibre4"/>You can find more about rotating the trust anchor
in the <a href="https://oreil.ly/9fAPV" class="calibre4">official Linkerd docs</a>.</p>
</dd>
<dt class="calibre11">Rotating the identity issuer</dt>
<dd class="calibre12">
<p class="calibre13">Rotating the identity issuer is a basic operational task in Linkerd. Ideally,<a data-primary="Venafi cert-manager" data-type="indexterm" id="id1163" class="calibre4"/><a data-primary="cert-manager (Venafi)" data-type="indexterm" id="id1164" class="calibre4"/><a data-primary="identity issuer certificate" data-secondary="rotating the certificates" data-tertiary="Venafi cert-manager" data-type="indexterm" id="id1165" class="calibre4"/>
you’ll automate rotating the identity issuer with a tool like Venafi’s
<a href="https://cert-manager.io" class="calibre4">cert-manager</a>, and we show how to do this in this
chapter. <a data-primary="identity issuer certificate" data-secondary="rotating the certificates" data-tertiary="documentation URL" data-type="indexterm" id="id1166" class="calibre4"/><a data-primary="Linkerd" data-secondary="documentation URL" data-tertiary="identity issuer certificate rotation" data-type="indexterm" id="id1167" class="calibre4"/><a data-primary="documentation for Linkerd online" data-secondary="identity issuer certificate rotation" data-type="indexterm" id="id1168" class="calibre4"/><a data-primary="resources online" data-secondary="Linkerd documentation" data-tertiary="identity issuer certificate rotation" data-type="indexterm" id="id1169" class="calibre4"/>You can also manually rotate the trust anchor using the procedure
shown in the <a href="https://oreil.ly/CN9IB" class="calibre4">official Linkerd docs</a>.</p>

<p class="calibre13">Whether you automate identity issuer rotation or do it manually,<a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="never let certificates expire" data-type="indexterm" id="id1170" class="calibre4"/><a data-primary="expired certificates" data-type="indexterm" id="id1171" class="calibre4"/><a data-primary="mTLS (mutual TLS)" data-secondary="certificates should not expire" data-type="indexterm" id="id1172" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="never let certificates expire" data-type="indexterm" id="id1173" class="calibre4"/> it is
critical that you practice rotating the identity issuer <em class="hyperlink">before</em>
the identity issuer expires. Having a mechanism that you’ve never tested can
be worse than not having anything set up at all.</p>
</dd>
<dt class="calibre11">Rotating the workload certificates</dt>
<dd class="calibre12">
<p class="calibre13">Workload certificates are automatically<a data-primary="workload certificates" data-secondary="Linkerd handling automatically" data-tertiary="rotating the certificates" data-type="indexterm" id="id1174" class="calibre4"/><a data-primary="workload certificates" data-secondary="rotating a certificate manually" data-type="indexterm" id="id1175" class="calibre4"/> rotated by the Linkerd control plane,
so you should almost never need to deal with them. (As noted previously, if you
<em class="hyperlink">do</em> want to rotate a workload certificate, just restart the workload.)</p>

<p class="calibre13">By default, workload certificates are valid for 24 hours, and the control
plane will begin attempting to rotate a workload certificate once it’s hit 70%
of its effective lifetime.</p>
</dd>
</dl>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">Tuning Workload Certificates</h1>
<p class="author1">If needed, you can tune the lifespan<a data-primary="workload certificates" data-secondary="rotating a certificate manually" data-tertiary="tuning workload certificate lifespan" data-type="indexterm" id="id1176" class="calibre4"/> of workload certificates by setting the
<code class="calibre9">issuanceLifetime</code> value when installing Linkerd, but recognize that there are
two important operational concerns if you reduce this value.</p>

<p class="author1">First, you increase the frequency with which your Pods communicate with the identity controller, which increases the load on the identity controller.</p>

<p class="author1">Second, you reduce the amount of time you have to address problems with
renewals. The proxy will begin attempting to renew at 70% of the lifespan: for
a 24-hour lifespan, this means it will start trying with about 7 hours to
go before the certificate expires, giving you about 7 hours to solve any
problems that come up. If the whole lifespan is just 2 hours, you’ll only
have about half an hour to work with if anything goes wrong.</p>
</div>

<p class="author1">As you have likely surmised, we’ve only skimmed the surface of how certificates work in general, and in Linkerd in particular, but you should now have more than enough information to understand how certificates are used in Linkerd.</p>
</div></section>








<section data-pdf-bookmark="Certificate Management in Linkerd" data-type="sect2" class="preface"><div class="preface" id="id60">
<h2 class="calibre27">Certificate Management in Linkerd</h2>

<p class="author1">It should be clear at this point<a data-primary="certificates" data-secondary="Linkerd and" data-tertiary="certificate management" data-type="indexterm" id="id1177" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="Linkerd and" data-tertiary="certificate management" data-type="indexterm" id="id1178" class="calibre4"/><a data-primary="production" data-secondary="certificate management in Linkerd" data-type="indexterm" id="id1179" class="calibre4"/> that certificate management is a critical
part of securing a production Linkerd installation. Properly managing
certificates is an important way to reduce the likelihood of an incident. It can also help
minimize time to recovery and the overall impact if something does go wrong.</p>

<p class="author1">With that in mind, our recommendations for everyone using Linkerd for any kind
of production use are:<a data-primary="trust anchor certificate" data-secondary="rotating the certificates" data-tertiary="rotating whole cluster" data-type="indexterm" id="id1180" class="calibre4"/><a data-primary="rotating the keys" data-secondary="rotating the certificates" data-type="indexterm" id="id1181" class="calibre4"/><a data-primary="identity issuer certificate" data-secondary="rotating the certificates" data-tertiary="Venafi cert-manager" data-type="indexterm" id="id1182" class="calibre4"/><a data-primary="Venafi cert-manager" data-type="indexterm" id="id1183" class="calibre4"/><a data-primary="cert-manager (Venafi)" data-type="indexterm" id="id1184" class="calibre4"/></p>
<dl class="calibre10">
   <dt class="calibre11">Couple the life of the trust anchor to the life of the cluster.</dt>

   <dd class="calibre12">
      <p class="calibre13">It’s definitely possible to rotate the trust anchor, but treating the entire cluster as ephemeral and periodically rotating the whole cluster tends to make disaster recovery and provider migration ultimately simpler.</p>
   </dd>

   <dt class="calibre11">Automate rotating the identity issuer.</dt>

   <dd class="calibre12">
      <p class="calibre13">It’s definitely possible to manage the identity issuer by hand, but we <em class="hyperlink">strongly</em> recommend using a tool like cert-manager to regularly rotate the identity issuer certificate every few days instead. This shorter lifespan for the identity issuer can dramatically limit the scope of any incident, and using cert-manager makes it almost unnoticeable.</p>
   </dd>
</dl>
</div></section>








<section data-pdf-bookmark="Automatic Certificate Management with cert-manager" data-type="sect2" class="preface"><div class="preface" id="id150">
<h2 class="calibre27">Automatic Certificate Management with cert-manager</h2>

<p class="author1">Venafi’s cert-manager is a CNCF <a data-primary="certificates" data-secondary="automatic management via cert-manager" data-type="indexterm" id="id1185" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="automatic management via cert-manager" data-type="indexterm" id="id1186" class="calibre4"/><a data-primary="Venafi cert-manager" data-secondary="automatic certificate management via" data-type="indexterm" id="id1187" class="calibre4"/><a data-primary="cert-manager (Venafi)" data-secondary="automatic certificate management via" data-type="indexterm" id="id1188" class="calibre4"/><a data-primary="deploying Linkerd" data-secondary="cert-manager certificate management" data-type="indexterm" id="id1189" class="calibre4"/><a data-primary="Cloud Native Computing Foundation (CNCF)" data-secondary="Venafi cert-manager" data-type="indexterm" id="id1190" class="calibre4"/>project that manages automatic certificate
generation and rotation, as shown in <a data-type="xref" href="#rotation-with-cert-manager" class="calibre4">Figure 7-9</a>. We’re not
going to cover the detailed inner workings of cert-manager (that’s beyond the
scope of this book); instead, we’re going to focus on the concepts required to
understand how to use cert-manager with Linkerd.</p>

<figure class="calibre23"><div class="figure" id="rotation-with-cert-manager">
<img alt="luar 0709" src="assets/luar_0709.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 7-9. </span>Automatic issuer certificate rotation with cert-manager</h6>
</div></figure>










<section data-pdf-bookmark="Installing cert-manager" data-type="sect3" class="preface"><div class="preface" id="id151">
<h3 class="calibre33">Installing cert-manager</h3>

<p class="author1">We start by installing cert-manager <a data-primary="cert-manager (Venafi)" data-secondary="automatic certificate management via" data-tertiary="installing cert-manager" data-type="indexterm" id="id1191" class="calibre4"/><a data-primary="Venafi cert-manager" data-secondary="automatic certificate management via" data-tertiary="installing cert-manager" data-type="indexterm" id="id1192" class="calibre4"/><a data-primary="certificates" data-secondary="automatic management via cert-manager" data-tertiary="installing cert-manager" data-type="indexterm" id="id1193" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="automatic management via cert-manager" data-tertiary="installing cert-manager" data-type="indexterm" id="id1194" class="calibre4"/><a data-primary="Helm for Linkerd deployment" data-secondary="cert-manager installation" data-type="indexterm" id="id1195" class="calibre4"/><a data-primary="deploying Linkerd" data-secondary="cert-manager certificate management" data-tertiary="installing cert-manager" data-type="indexterm" id="id1196" class="calibre4"/>using Helm to manage our install, as shown
in <a data-type="xref" href="#EX9-1" class="calibre4">Example 7-1</a>. To follow along, you’ll need the following tools available
in your environment:</p>

<ul class="printings">
<li class="calibre6">
<p class="author1"><code class="calibre9">kubectl</code></p>
</li>
<li class="calibre6">
<p class="author1"><code class="calibre9">k3d</code> or another tool for getting a local Kubernetes cluster</p>
</li>
<li class="calibre6">
<p class="author1"><code class="calibre9">helm3</code></p>
</li>
</ul>
<div data-type="example" id="EX9-1" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 7-1. </span>Installing cert-manager</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Start by creating the cluster</code>
$<code class="w"> </code>k3d<code class="w"> </code>cluster<code class="w"> </code>create<code class="w"> </code>luar<code class="w"/>

<code class="c"># Add the jetstack Helm repo if you don't already have it</code>
$<code class="w"> </code>helm<code class="w"> </code>repo<code class="w"> </code>add<code class="w"> </code>jetstack<code class="w"> </code>https://charts.jetstack.io<code class="w"/>

<code class="c"># Make sure your Helm repositories are up-to-date</code>
$<code class="w"> </code>helm<code class="w"> </code>repo<code class="w"> </code>update<code class="w"/>

<code class="c"># Install cert-manager</code>
$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>cert-manager<code class="w"> </code>jetstack/cert-manager<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--namespace<code class="w"> </code>cert-manager<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--create-namespace<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--version<code class="w"> </code>v1.12.0<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--set<code class="w"> </code><code class="nv">installCRDs</code><code class="o">=</code><code class="nb">true</code><code class="w"/>

<code class="c"># Check out your cert-manager Pods</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>-n<code class="w"> </code>cert-manager<code class="w"/></pre></div>
<div class="calibre16" data-type="note" epub:type="note"><h1 class="calibre26">Software Versions</h1>
<p class="author1">Be aware that our examples are using specific versions to make sure that things work at the time of this writing. There may be more updated versions available by the time you read this, though; make sure you’re using appropriate versions.</p>
</div>
</div></section>










<section class="preface" data-pdf-bookmark="Configuring cert-manager for Linkerd" data-type="sect3"><div class="preface" id="id61">
<h3 class="calibre33">Configuring cert-manager for Linkerd</h3>

<p class="author1">While a deep dive into cert-manager <a data-primary="cert-manager (Venafi)" data-secondary="automatic certificate management via" data-tertiary="configuring for Linkerd" data-type="indexterm" id="ch07-conf" class="calibre4"/><a data-primary="Venafi cert-manager" data-secondary="automatic certificate management via" data-tertiary="configuring for Linkerd" data-type="indexterm" id="ch07-conf2" class="calibre4"/><a data-primary="certificates" data-secondary="automatic management via cert-manager" data-tertiary="configuring for Linkerd" data-type="indexterm" id="ch07-conf3" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="automatic management via cert-manager" data-tertiary="configuring for Linkerd" data-type="indexterm" id="ch07-conf4" class="calibre4"/><a data-primary="deploying Linkerd" data-secondary="cert-manager certificate management" data-tertiary="configuring for Linkerd" data-type="indexterm" id="ch07-conf5" class="calibre4"/>is out of scope for this book, it’s
definitely worth discussing its overall architecture for our use case.
cert-manager is configured with Issuer and Certificate resources: an Issuer
resource tells cert-manager where to find the keys it needs to issue a
certificate, and a Certificate resource tells cert-manager which Issuer to use
for a specific certificate.</p>

<p class="author1">In our case, as shown in <a data-type="xref" href="#rotation-with-cert-manager" class="calibre4">Figure 7-9</a>, we’ll create an Issuer
that holds the trust anchor keys and a Certificate that describes how to use
that Issuer to get a Linkerd issuer certificate.</p>

<p class="author1">We mentioned at the beginning of the chapter that you never want to add your
root CA’s private key to your Kubernetes cluster. Because standing up an
external key store is out of scope for this book, we’re going to break that
rule in <a data-type="xref" href="#EX9-2" class="calibre4">Example 7-2</a> and use cert-manager with the trust anchor stored in a
Kubernetes Secret. In any real production environment you would <em class="hyperlink">not</em> do
this, but the overall setup will stay the same, with one Issuer and one
Certificate: you’ll just change the Issuer definition to use your external agent
instead. <a data-primary="cert-manager (Venafi)" data-secondary="external agent documentation URL" data-type="indexterm" id="id1197" class="calibre4"/><a data-primary="Venafi cert-manager" data-secondary="external agent documentation URL" data-type="indexterm" id="id1198" class="calibre4"/><a data-primary="resources online" data-secondary="cert-manager external agent documentation" data-type="indexterm" id="id1199" class="calibre4"/>(cert-manager supports many different external agents; see
<a href="https://oreil.ly/f5354" class="calibre4">the documentation</a>.)</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Keep the Trust Anchor Key out of the Cluster!</h1>
<p class="author1">Again, <em class="hyperlink">do not</em> use this setup in production. It can be made safer, but having your trust anchor’s secret key in the cluster will never be as safe as having it exist only in an external store.</p>
</div>
<div class="calibre40" data-type="example" id="EX9-2">
<h5 class="calibre41"><span class="calibre">Example 7-2. </span>Generating certificates for Linkerd</h5>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Start by generating a trust anchor for the cluster.</code>
$ step<code class="w"> </code>certificate<code class="w"> </code>create<code class="w"> </code>root.linkerd.cluster.local<code class="w"> </code>ca.crt<code class="w"> </code>ca.key<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--profile<code class="w"> </code>root-ca<code class="w"> </code>--no-password<code class="w"> </code>--insecure<code class="w"> </code>--not-after<code class="o">=</code>87600h<code class="w"/>

<code class="c"># Create the linkerd namespace so that we have a place to install</code>
<code class="c"># the trust anchor Secret.</code>
$ kubectl<code class="w"> </code>create<code class="w"> </code>ns<code class="w"> </code>linkerd<code class="w"/>

<code class="c"># Save the trust anchor as a Secret in the linkerd namespace.</code>
<code class="c">#</code>
<code class="c"># During your real-world installs, you'd instead use an external</code>
<code class="c"># cert-manager-compatible Secret store (like Vault) to store the</code>
<code class="c"># trust anchor.</code>
$ kubectl<code class="w"> </code>create<code class="w"> </code>secret<code class="w"> </code>tls<code class="w"> </code>linkerd-trust-anchor<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--cert<code class="o">=</code>ca.crt<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--key<code class="o">=</code>ca.key<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--namespace<code class="o">=</code>linkerd<code class="w"/>

<code class="c"># Create a cert-manager Issuer that uses the trust anchor Secret</code>
<code class="c"># to issue certificates. This Issuer must be in the same namespace</code>
<code class="c"># as the trust anchor Secret.</code>
<code class="c">#</code>
<code class="c"># During your real-world installs, you'd instead change this</code>
<code class="c"># Issuer to connect to your external Secret store.</code>
$ kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: cert-manager.io/v1</code>
<code class="s">kind: Issuer</code>
<code class="s">metadata:</code>
<code class="s">  name: linkerd-trust-anchor</code>
<code class="s">  namespace: linkerd</code>
<code class="s">spec:</code>
<code class="s">  ca:</code>
<code class="s">    secretName: linkerd-trust-anchor</code>
<code class="s">EOF</code><code class="w"/>
<code class="w"> </code>
</pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># With the Issuer created, we will now use a Certificate to instruct</code>
<code class="c"># cert-manager to create our identity issuer certificate. We will</code>
<code class="c"># also instruct it to automatically rotate that certificate every 48</code>
<code class="c"># hours. This Certificate must be in the same namespace as the Secret</code>
<code class="c"># it is writing, which (again) is the linkerd namespace.</code>
$ kubectl<code class="w"> </code>apply<code class="w"> </code>-f<code class="w"> </code>-<code class="w"> </code><code class="s">&lt;&lt;EOF</code>
<code class="s">apiVersion: cert-manager.io/v1</code>
<code class="s">kind: Certificate</code>
<code class="s">metadata:</code>
<code class="s">  name: linkerd-identity-issuer</code>
<code class="s">  namespace: linkerd</code>
<code class="s">spec:</code>
<code class="s">  secretName: linkerd-identity-issuer</code>
<code class="s">  duration: 48h</code>
<code class="s">  issuerRef:</code>
<code class="s">    name: linkerd-trust-anchor</code>
<code class="s">    kind: Issuer</code>
<code class="s">  commonName: identity.linkerd.cluster.local</code>
<code class="s">  dnsNames:</code>
<code class="s">  - identity.linkerd.cluster.local</code>
<code class="s">  isCA: true</code>
<code class="s">  privateKey:</code>
<code class="s">    algorithm: ECDSA</code>
<code class="s">  usages:</code>
<code class="s">  - cert sign</code>
<code class="s">  - crl sign</code>
<code class="s">  - server auth</code>
<code class="s">  - client auth</code>
<code class="s">EOF</code><code class="w"/></pre></div>

<p class="author1">Let’s go back over what we just did. We started by installing cert-manager into our cluster, which will automate the process of issuing and rotating certificates. We then created a trust anchor and told cert-manager to use that certificate to automatically create and rotate Linkerd’s issuer certificate. The issuer certificate is an intermediary CA that Linkerd will use to create, distribute, and rotate the individual workload certificates. cert-manager will rotate the issuer certificate every 48 hours, as we defined in its Certificate object.</p>

<p class="author1">Let’s take a quick tour around our cluster, as shown in <a data-type="xref" href="#EX9-3" class="calibre4">Example 7-3</a>, to see what cert-manager will actually do with this setup.</p>
<div data-type="example" id="EX9-3" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 7-3. </span>Looking around</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># First, let's validate that the trust anchor Secret exists and</code>
<code class="c"># has some information in it.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>secret<code class="w"> </code>linkerd-trust-anchor<code class="w"> </code>-n<code class="w"> </code>linkerd<code class="w"/>

<code class="c"># Given that, we can use the step CLI to examine the public part</code>
<code class="c"># of the certificate itself. The way this works is that the public</code>
<code class="c"># part is stored, base-64 encoded, in the "tls.crt" key of the</code>
<code class="c"># Secret, so we extract that, decode it, and hand it to step.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>secret<code class="w"> </code>linkerd-trust-anchor<code class="w"> </code>-n<code class="w"> </code>linkerd<code class="w"> </code><code class="se">\</code>
<code class="w">    </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s">'{.data.tls\.crt}'</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code><code class="p">|</code><code class="w"> </code>base64<code class="w"> </code>-d<code class="w"> </code><code class="se">\</code>
<code class="w">    </code><code class="p">|</code><code class="w"> </code>step<code class="w"> </code>certificate<code class="w"> </code>inspect<code class="w"> </code>-<code class="w"/>

<code class="c"># Next, let's check to see if cert-manager was able to create</code>
<code class="c"># our issuer certificate. We should see a Certificate named</code>
<code class="c"># linkerd-identity-issuer with a "ready" status of True.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>certificate<code class="w"> </code>-n<code class="w"> </code>linkerd<code class="w"/>

<code class="c"># Following that, we'll check in on the identity issuer Secret.</code>
<code class="c"># This is just like what we did for the trust anchor, with a</code>
<code class="c"># different name for the Secret.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>secret<code class="w"> </code>linkerd-identity-issuer<code class="w"> </code>-n<code class="w"> </code>linkerd<code class="w"> </code><code class="se">\</code>
<code class="w">    </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s">'{.data.tls\.crt}'</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code><code class="p">|</code><code class="w"> </code>base64<code class="w"> </code>-d<code class="w"> </code><code class="se">\</code>
<code class="w">    </code><code class="p">|</code><code class="w"> </code>step<code class="w"> </code>certificate<code class="w"> </code>inspect<code class="w"> </code>-<code class="w"/></pre></div>

<p class="author1">With that out of the way, we can now install Linkerd.<a data-startref="ch07-conf" data-type="indexterm" id="id1200" class="calibre4"/><a data-startref="ch07-conf2" data-type="indexterm" id="id1201" class="calibre4"/><a data-startref="ch07-conf3" data-type="indexterm" id="id1202" class="calibre4"/><a data-startref="ch07-conf4" data-type="indexterm" id="id1203" class="calibre4"/><a data-startref="ch07-conf5" data-type="indexterm" id="id1204" class="calibre4"/></p>
</div></section>










<section data-pdf-bookmark="Installing Linkerd using cert-manager" data-type="sect3" class="preface"><div class="preface" id="id152">
<h3 class="calibre33">Installing Linkerd using cert-manager</h3>

<p class="author1">Once cert-manager is set up to<a data-primary="cert-manager (Venafi)" data-secondary="automatic certificate management via" data-tertiary="installing Linkerd using cert-manager" data-type="indexterm" id="id1205" class="calibre4"/><a data-primary="Venafi cert-manager" data-secondary="automatic certificate management via" data-tertiary="installing Linkerd using cert-manager" data-type="indexterm" id="id1206" class="calibre4"/><a data-primary="certificates" data-secondary="automatic management via cert-manager" data-tertiary="installing Linkerd using cert-manager" data-type="indexterm" id="id1207" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="automatic management via cert-manager" data-tertiary="installing Linkerd using cert-manager" data-type="indexterm" id="id1208" class="calibre4"/><a data-primary="deploying Linkerd" data-secondary="cert-manager certificate management" data-tertiary="installing Linkerd using cert-manager" data-type="indexterm" id="id1209" class="calibre4"/><a data-primary="Helm for Linkerd deployment" data-secondary="installing Linkerd via Helm" data-tertiary="cert-manager setup" data-type="indexterm" id="id1210" class="calibre4"/><a data-primary="deploying Linkerd" data-secondary="deploying on Kubernetes" data-tertiary="installing Linkerd via Helm" data-type="indexterm" id="id1211" class="calibre4"/> issue certs, we need to install Linkerd so that
it knows to use the certificates that cert-manager is managing, as shown in <a data-type="xref" href="#rotation-with-cert-manager" class="calibre4">Figure 7-9</a>.</p>

<p class="author1">You’ll remember that in <a data-type="xref" href="ch03.html#LUAR_deploying_linkerd" class="calibre4">Chapter 3</a> we went through the various
ways to install Linkerd. <a data-primary="Buoyant, Inc." data-secondary="Helm for Linkerd in production" data-type="indexterm" id="id1212" class="calibre4"/><a data-primary="Helm for Linkerd deployment" data-secondary="Helm for Linkerd in production" data-type="indexterm" id="id1213" class="calibre4"/>We’ll use Helm for our installation, as shown in
<a data-type="xref" href="#EX9-4" class="calibre4">Example 7-4</a>, since we recommend that folks hoping to run Linkerd in production
install Linkerd with Helm.<a data-primary="CRDs (custom resource definitions)" data-secondary="installing Linkerd CRDs" data-tertiary="Helm install of Linkerd" data-type="indexterm" id="id1214" class="calibre4"/></p>
<div class="calibre40" data-type="example" id="EX9-4">
<h5 class="calibre41"><span class="calibre">Example 7-4. </span>Installing Linkerd with cert-manager</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Configure our Linkerd Helm repo.</code>
$<code class="w"> </code>helm<code class="w"> </code>repo<code class="w"> </code>add<code class="w"> </code>linkerd<code class="w"> </code>https://helm.linkerd.io/stable<code class="w"/>

<code class="c"># Update our repos.</code>
$<code class="w"> </code>helm<code class="w"> </code>repo<code class="w"> </code>update<code class="w"/>

<code class="c"># Install the Linkerd CRDs.</code>
$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code>linkerd-crds<code class="w"> </code>-n<code class="w"> </code>linkerd<code class="w"> </code>--version<code class="w"> </code><code class="m">1</code>.6.1<code class="w"> </code>linkerd/linkerd-crds<code class="w"/>

<code class="c"># Install Linkerd's control plane.</code>
<code class="c">#</code>
<code class="c"># Unlike in earlier chapters, this install will not have us specifying</code>
<code class="c"># the issuer certificate. Instead, we instruct Linkerd to use the</code>
<code class="c"># existing certificate by setting the identity.issuer.scheme to</code>
<code class="c"># kubernetes.io/tls.</code>
$<code class="w"> </code>helm<code class="w"> </code>install<code class="w"> </code>linkerd-control-plane<code class="w"> </code>-n<code class="w"> </code>linkerd<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--set-file<code class="w"> </code><code class="nv">identityTrustAnchorsPEM</code><code class="o">=</code>ca.crt<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--set<code class="w"> </code>identity.issuer.scheme<code class="o">=</code>kubernetes.io/tls<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--version<code class="w"> </code><code class="m">1</code>.12.4<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>linkerd/linkerd-control-plane<code class="w"/>

<code class="c"># Validate the Linkerd install.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>check<code class="w"/>

<code class="c"># You'll see warnings letting you know your Linkerd issuer certificate isn't</code>
<code class="c"># valid for more than 60 days. That's to be expected, as you are now actively</code>
<code class="c"># rotating the issuer certificate with cert-manager.</code></pre></div>

<p class="author1">With that, you now have a fully functional Linkerd instance with an actively and automatically rotating issuer certificate. You’ve added a significant amount of security to your environment and ensured that your cluster will get new certificates on a regular basis. It’s important to actively monitor cert-manager and check that your certificates are being rotated regularly. An expired issuer certificate is one of the few ways Linkerd can actively take down your applications, and its health and safety is critical to your platform.</p>
</div></section>
</div></section>
</div></section>






<section class="preface" data-pdf-bookmark="Summary" data-type="sect1"><div class="preface" id="id319">
<h1 class="calibre8">Summary</h1>

<p class="author1">We’ve covered a lot of ground in this chapter. mTLS and certificate handling
are complex topics, even though they’ve been around for a long time. The
challenge is that to properly secure a cloud native application, right now you
need to know more about this stuff than you might like.</p>

<p class="author1">One of the ways that Linkerd simplifies the process of hardening your
environment is making mTLS effectively automatic, allowing any Linkerd user to
rely on mTLS’s well-trusted identity and encryption mechanisms for secure
communications. Another way is that Linkerd gives you control over critical
certificate management operations: Linkerd’s ability to issue certificates for
your application’s workloads, then rotate them frequently and automatically,
gives you some powerful tools you need to reduce the likelihood and impact of
any security incident.</p>
</div></section>
</div></section></body></html>