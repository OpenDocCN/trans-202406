<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. WebAssembly" class="calibre4"><div class="preface" id="ch_webassembly">
<h1 class="calibre12"><span class="keep-together">Chapter 7. </span>WebAssembly</h1>


<p class="author1">While the title of this book is <em class="calibre7">Multithreaded JavaScript</em>, modern JavaScript runtimes also support WebAssembly. For the unaware, WebAssembly (often abbreviated as WASM) is a binary-encoded <a data-type="indexterm" data-primary="WebAssembly" id="idm45995910927048" class="calibre6"/><a data-type="indexterm" data-primary="WASM" data-see="WebAssembly" id="idm45995910926376" class="calibre6"/>instruction format that runs on a stack-based virtual machine. It’s designed with security in mind and runs in a sandbox where the only things it has access to are memory and functions provided by the host environment. The main motivation behind having such a thing in browsers and other JavaScript runtimes is to run the parts of your program that are performance-sensitive in an environment where execution can happen much faster than JavaScript. Another goal is to provide a compile target for typically compiled languages like C, C++, and Rust. This opens the door for developers of those languages to develop for the web.</p>

<p class="author1">Generally, the memory used <a data-type="indexterm" data-primary="WebAssembly" data-secondary="memory" id="idm45995910924232" class="calibre6"/><a data-type="indexterm" data-primary="memory" data-secondary="WebAssembly" id="idm45995910922920" class="calibre6"/><a data-type="indexterm" data-primary="ArrayBuffer" data-secondary="WebAssembly" id="idm45995910921976" class="calibre6"/><a data-type="indexterm" data-primary="SharedArrayBuffer" data-secondary="WebAssembly" id="idm45995910921032" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="ArrayBuffer" id="idm45995910920088" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="SharedArrayBuffers" id="idm45995910919144" class="calibre6"/>by WebAssembly modules is represented by <code class="calibre18">ArrayBuffers</code>, but it can also be represented by <code class="calibre18">SharedArrayBuffers</code>. In addition, there are WebAssembly instructions <a data-type="indexterm" data-primary="atomicity" data-secondary="WebAssembly" id="idm45995910917224" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="atomic operations" id="idm45995910916248" class="calibre6"/>for atomic operations, similar to the <code class="calibre18">Atomics</code> object we have in JavaScript. With <code class="calibre18">SharedArrayBuffers</code>, atomic operations, and web workers (or <code class="calibre18">worker_threads</code> in Node.js), we have enough to do the full suite of multithreaded programming tasks using WebAssembly.</p>

<p class="author1">Before we jump into multithreaded WebAssembly, let’s build a “Hello, World!” example and execute it, to find the strengths and limitations of WebAssembly.</p>






<section data-type="sect1" data-pdf-bookmark="Your First WebAssembly" class="calibre4"><div class="preface" id="idm45995910913256">
<h1 class="calibre13">Your First WebAssembly</h1>

<p class="author1">While WebAssembly is a binary <a data-type="indexterm" data-primary="WebAssembly" data-secondary="Hello World" id="webassHello" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="text format" id="idm45995910910056" class="calibre6"/>format, a plain text format exists to represent it in human readable form. This is comparable to how machine code can by represented in a human-readable assembly language. The language for this WebAssembly text format is simply called WebAssembly text format, but the file <a data-type="indexterm" data-primary=".wat file extension" data-primary-sortas="wat file extension" id="idm45995910908696" class="calibre6"/>extension typically used is <em class="calibre7">.wat</em>, so it’s common enough to refer to this language as WAT. It uses <em class="calibre7">S-expressions</em> as its primary syntactic separator, which is <a data-type="indexterm" data-primary="WebAssembly" data-secondary="S-expressions" id="idm45995910906824" class="calibre6"/><a data-type="indexterm" data-primary="S-expressions, WebAssembly" id="idm45995910905848" class="calibre6"/>helpful for both parsing and readability. 
<span class="keep-together">S-expressions</span>, known primarily from <a data-type="indexterm" data-primary="Lisp, S-expressions" id="idm45995910904264" class="calibre6"/>the Lisp family of languages, are nested lists delimited by parentheses, with whitespace between each item in the list.</p>

<p class="author1">To get a feel for this format, let’s implement a simple addition function in WAT. Create a file called <em class="calibre7">ch7-wasm-add/add.wat</em> and add the contents of <a data-type="xref" href="#ex_ch7_add_wat" class="calibre6">Example 7-1</a>.</p>
<div id="ex_ch7_add_wat" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 7-1. </span><em class="calibre7">ch7-wasm-add/add.wat</em></h5>

<pre data-type="programlisting" data-code-language="lisp" class="calibre28"><code class="p">(</code><code class="nv">module</code><code class="calibre18"> </code><a class="calibre6" id="co_webassembly_CO1-1" href="#callout_webassembly_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
  </code><code class="p">(</code><code class="nv">func</code><code class="calibre18"> </code><code class="nv">$add</code><code class="calibre18"> </code><code class="p">(</code><code class="nv">param</code><code class="calibre18"> </code><code class="nv">$a</code><code class="calibre18"> </code><code class="nv">i32</code><code class="p">)</code><code class="calibre18"> </code><code class="p">(</code><code class="nv">param</code><code class="calibre18"> </code><code class="nv">$b</code><code class="calibre18"> </code><code class="nv">i32</code><code class="p">)</code><code class="calibre18"> </code><code class="p">(</code><code class="nv">result</code><code class="calibre18"> </code><code class="nv">i32</code><code class="p">)</code><code class="calibre18"> </code><a class="calibre6" id="co_webassembly_CO1-2" href="#callout_webassembly_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
    </code><code class="nv">local.get</code><code class="calibre18"> </code><code class="nv">$a</code><code class="calibre18"> </code><a class="calibre6" id="co_webassembly_CO1-3" href="#callout_webassembly_CO1-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">
    </code><code class="nv">local.get</code><code class="calibre18"> </code><code class="nv">$b</code><code class="calibre18">
    </code><code class="nv">i32.add</code><code class="p">)</code><code class="calibre18">
  </code><code class="p">(</code><code class="nb">export</code><code class="calibre18"> </code><code class="s">"add"</code><code class="calibre18"> </code><code class="p">(</code><code class="nv">func</code><code class="calibre18"> </code><code class="nv">$add</code><code class="p">)</code><code class="p">)</code><code class="calibre18"> </code><a class="calibre6" id="co_webassembly_CO1-4" href="#callout_webassembly_CO1-4"><img src="Images/4.png" alt="4" class="calibre32"/></a><code class="calibre18">
</code><code class="p">)</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_webassembly_CO1-1" href="#co_webassembly_CO1-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The first line declares <a data-type="indexterm" data-primary="WebAssembly" data-secondary="modules" data-tertiary="declaring" id="idm45995910783192" class="calibre6"/><a data-type="indexterm" data-primary="modules" data-secondary="WebAssembly, declaring" id="idm45995910781944" class="calibre6"/>a module. Every WAT file begins with this.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_webassembly_CO1-2" href="#co_webassembly_CO1-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">We declare a function called <code class="calibre18">$add</code>, taking in two 32-bit integers and returning another 32-bit integer.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_webassembly_CO1-3" href="#co_webassembly_CO1-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">This is the start of the function body, in which we have three statements. The first two grab the function parameters and put them on the stack one after another. Recall that WebAssembly is stack-based. That means many operations will 
<span class="keep-together">operate</span> on the first (if unary) or first two (if binary) items on the stack. The third statement is a binary “add” operation on i32 values, so it grabs the top two values from the stack and adds them together, putting the result at the top of the stack. The return value for a function is the value at the top of the stack once it 
<span class="keep-together">completes</span>.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_webassembly_CO1-4" href="#co_webassembly_CO1-4"><img src="Images/4.png" alt="4" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">In order to use a function outside the module in the host environment, it needs to be exported. Here we export the <code class="calibre18">$add</code> function, giving it the external name <code class="calibre18">add</code>.</p></dd>
</dl></div>

<p class="author1">We can convert this WAT file <a data-type="indexterm" data-primary="WAT files, WebAssembly binary" id="idm45995910744600" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="WAT files, converting to binary" id="idm45995910743992" class="calibre6"/><a data-type="indexterm" data-primary="WABT (WebAssembly Binary Toolkit)" id="idm45995910743144" class="calibre6"/>to WebAssembly binary by using the <code class="calibre18">wat2wasm</code> tool from the WebAssembly Binary Toolkit (WABT). This can be done with the following one-liner in the <em class="calibre7">ch7-wasm-add</em> directory.</p>

<pre data-type="programlisting" class="calibre38">$ npx -p wabt wat2wasm add.wat -o add.wasm</pre>

<p class="author1">Now we have our first WebAssembly file! These files aren’t useful outside a host environment, so let’s write a bit <a data-type="indexterm" data-primary="WebAssembly" data-secondary="file loading, JavaScript and" id="idm45995910740392" class="calibre6"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="WebAssembly files" id="idm45995910739544" class="calibre6"/>of JavaScript to load the WebAssembly and test the <code class="calibre18">add</code> function. Add the contents of <a data-type="xref" href="#ex_ch7_add_wat_js" class="calibre6">Example 7-2</a> to <em class="calibre7">ch7-wasm-add/add.js</em>.</p>
<div id="ex_ch7_add_wat_js" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 7-2. </span><em class="calibre7">ch7-wasm-add/add.js</em></h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'fs/promises'</code><code class="p">);</code> <code class="c">// Needs Node.js v14 or higher.</code>

<code class="p">(</code><code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">wasm</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s">'./add.wasm'</code><code class="p">);</code>
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">instance</code><code class="o">:</code> <code class="p">{</code> <code class="nx">exports</code><code class="o">:</code> <code class="p">{</code> <code class="nx">add</code> <code class="p">}</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">WebAssembly</code><code class="p">.</code><code class="nx">instantiate</code><code class="p">(</code><code class="nx">wasm</code><code class="p">);</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">add</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">));</code>
<code class="p">})();</code></pre></div>

<p class="author1">Provided you’ve created the <em class="calibre7">.wasm</em> file <a data-type="indexterm" data-primary=".wasm files" data-primary-sortas="wasm files" id="idm45995910733912" class="calibre6"/>using the <a data-type="indexterm" data-primary="WebAssembly" data-secondary="wat2wasm command" id="idm45995910681064" class="calibre6"/>preceding <code class="calibre18">wat2wasm</code> command, you should be able to run this in the <em class="calibre7">ch7-wasm-add</em> directory.</p>

<pre data-type="programlisting" class="calibre38">$ node add.js</pre>

<p class="author1">You can verify from the output that we are, in fact, adding via our WebAssembly module.</p>

<p class="author1">Simple mathematical operations on the stack don’t make any use of linear memory or of concepts that have no meaning in WebAssembly, such as strings. Consider strings in C. Effectively, they’re nothing more than a pointer to the start of an array of bytes, terminated by a null byte. We can’t pass whole arrays by value to WebAssembly functions or return them, but we can pass them by reference. This means that to pass a string as an argument, we need to first allocate the bytes in the linear memory and write to them, then pass the index of the first byte to the WebAssembly function. This can get more complex since we then need ways of managing the available space in <a data-type="indexterm" data-primary="memory" data-secondary="allocation" id="idm45995910676792" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="memory allocation" id="idm45995910675816" class="calibre6"/><a data-type="indexterm" data-primary="malloc() function" id="idm45995910674872" class="calibre6"/><a data-type="indexterm" data-primary="free() function" id="idm45995910674200" class="calibre6"/><a data-type="indexterm" data-primary="functions" data-secondary="free()" id="idm45995910673528" class="calibre6"/><a data-type="indexterm" data-primary="functions" data-secondary="malloc()" id="idm45995910672584" class="calibre6"/>the linear memory. We basically need <code class="calibre18">malloc()</code> and <code class="calibre18">free()</code> implementations operating on the linear memory.<sup class="calibre39"><a data-type="noteref" id="idm45995910670680-marker" href="ch07.xhtml#idm45995910670680" class="calibre40">1</a></sup></p>

<p class="author1">Hand-writing WebAssembly in WAT, while clearly possible, isn’t usually the easiest path to being productive and getting performance gains with it. It was designed to be a compile target for higher-level languages, and that’s where it really shines. <a data-type="xref" href="#ch_webassembly_sec_compile" class="calibre6">“Compiling C Programs to WebAssembly with Emscripten”</a> explores that in more detail.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Atomic Operations in WebAssembly" class="calibre4"><div class="preface" id="idm45995910912632">
<h1 class="calibre13">Atomic Operations in WebAssembly</h1>

<p class="author1">Although a full treatment of every <a href="https://oreil.ly/PfxJq" class="calibre6">WebAssembly instruction</a> would be out of <a data-type="indexterm" data-primary="atomicity" data-secondary="WebAssembly" id="atomass" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="atomic operations" id="webassatom" class="calibre6"/>place in this book, it’s worth pointing out the instructions specific to atomic operations on shared memory since they’re key to multithreaded WebAssembly code, whether compiled from another language or hand-written in WAT.</p>

<p class="author1">WebAssembly instructions often start with the type. In the case of atomic operations, the type <a data-type="indexterm" data-primary="WebAssembly" data-secondary="types" id="idm45995910661544" class="calibre6"/><a data-type="indexterm" data-primary="i32 type" id="idm45995910660568" class="calibre6"/><a data-type="indexterm" data-primary="i64 type" id="idm45995910659896" class="calibre6"/>is always <code class="calibre18">i32</code> or <code class="calibre18">i64</code>, corresponding to 32-bit and 64-bit integers, respectively. All atomic operations have <code class="calibre18">.atomic.</code> next in the instruction name. After that, you’ll find the specific instruction name.</p>

<p class="author1">Let’s go over some of the atomic operation instructions. We won’t go over exact syntax, but this should give you an idea of the kinds of operations available at the instruction level:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre18">[i32|i64].atomic.[load|load8_u|load16_u|load32_u]</code></dt>
<dd class="calibre16">
<p class="calibre17">The <code class="calibre18">load</code> family of instructions is equivalent to <code class="calibre18">Atomics.load()</code> in JavaScript. Using one of the suffixed instructions allows you to load smaller numbers of bits, extending the result with zeros.</p>
</dd>
<dt class="calibre15"><code class="calibre18">[i32|i64].atomic.[store|store8|store16|store32]</code></dt>
<dd class="calibre16">
<p class="calibre17">The <code class="calibre18">store</code> family of instructions is equivalent to <code class="calibre18">Atomics.store()</code> in JavaScript. Using one of the suffixed instructions wraps the input value to that number of bits and stores those at the index.</p>
</dd>
<dt class="calibre15"><code class="calibre18">[i32|i64].atomic.[rmw|rmw8|rmw16|rmw32].[add|sub|and|or|xor|xchg|cmpxchg][|_u]</code></dt>
<dd class="calibre16">
<p class="calibre17">The <code class="calibre18">rmw</code> family of instructions <a data-type="indexterm" data-primary="WebAssembly" data-secondary="rmw instructions" id="idm45995910649592" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="read-modify-write operations" id="idm45995910648616" class="calibre6"/>all perform read-modify-write operations, equivalent to <code class="calibre18">add()</code>, <code class="calibre18">sub()</code>, <code class="calibre18">and()</code>, <code class="calibre18">or()</code>, <code class="calibre18">xor()</code>, <code class="calibre18">exchange()</code>, and <code class="calibre18">compareExchange()</code> from the <code class="calibre18">Atomics</code> object in JavaScript, respectively. The operations are suffixed with a <code class="calibre18">_u</code> when they zero-extend, and <code class="calibre18">rmw</code> can have a suffix corresponding to the number of bits to be read.</p>
</dd>
</dl>

<p class="author1">The next two operations have a slightly different <a data-type="indexterm" data-primary="WebAssembly" data-secondary="naming conventions" id="idm45995910642824" class="calibre6"/>naming convention:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre18">memory.atomic.[wait32|wait64]</code></dt>
<dd class="calibre16">
<p class="calibre17">These are equivalent to <code class="calibre18">Atomics.wait()</code> in JavaScript, <a data-type="indexterm" data-primary="WebAssembly" data-secondary="memory.atomic" id="idm45995910639656" class="calibre6"/>suffixed according to the number of bits they operate on.</p>
</dd>
<dt class="calibre15"><code class="calibre18">memory.atomic.notify</code></dt>
<dd class="calibre16">
<p class="calibre17">This is equivalent <a data-type="indexterm" data-primary="WebAssembly" data-secondary="memory.atomic.notify" id="idm45995910637112" class="calibre6"/>to <code class="calibre18">Atomics.notify()</code> in JavaScript.</p>
</dd>
</dl>

<p class="author1">These instructions are enough to perform the same atomic operations in WebAssembly as we can in JavaScript, but there is an additional operation not available in 
<span class="keep-together">JavaScript</span>:</p>
<dl class="calibre14">
<dt class="calibre15"><code class="calibre18">atomic.fence</code></dt>
<dd class="calibre16">
<p class="calibre17">This instruction takes no <a data-type="indexterm" data-primary="WebAssembly" data-secondary="atomic.fence" id="idm45995910602792" class="calibre6"/>arguments and doesn’t return anything. It’s intended to be used by higher-level languages that have ways of guaranteeing ordering of nonatomic accesses to shared memory.</p>
</dd>
</dl>

<p class="author1">All of these operations are used <a data-type="indexterm" data-primary="WebAssembly" data-secondary="modules" data-tertiary="linear memory" id="idm45995910600984" class="calibre6"/>with the given WebAssembly module’s <em class="calibre7">linear memory</em>, which is the sandbox in which it gets to read and write values. When WebAssembly modules are initialized from JavaScript, <a data-type="indexterm" data-primary="WebAssembly" data-secondary="modules" data-tertiary="initializing" id="idm45995910599240" class="calibre6"/>they can be initialized with a linear memory provided as an option. This can be backed by a <code class="calibre18">SharedArrayBuffer</code> to enable usage across threads.</p>

<p class="author1">Although it’s certainly possible to use these instructions in WebAssembly, they suffer from the same drawback that the rest of WebAssembly does: it’s incredibly tedious and painstaking to <a data-type="indexterm" data-primary="WebAssembly" data-secondary="Hello World" data-startref="webassHello" id="idm45995910596936" class="calibre6"/><a data-type="indexterm" data-primary="atomicity" data-secondary="WebAssembly" data-startref="atomass" id="idm45995910595848" class="calibre6"/><a data-type="indexterm" data-primary="WebAssembly" data-secondary="atomic operations" data-startref="webassatom" id="idm45995910594760" class="calibre6"/>write. Luckily, we can compile higher-level languages down to WebAssembly.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Compiling C Programs to WebAssembly with Emscripten" class="calibre4"><div class="preface" id="ch_webassembly_sec_compile">
<h1 class="calibre13">Compiling C Programs to WebAssembly with Emscripten</h1>

<p class="author1">Since long before WebAssembly, <a href="https://emscripten.org" class="calibre6">Emscripten</a> has been the go-to way to <a data-type="indexterm" data-primary="WebAssembly" data-secondary="compilers" data-tertiary="Emscripten" id="webassemscrip" class="calibre6"/><a data-type="indexterm" data-primary="Emscripten" id="emscript" class="calibre6"/>compile C and C++ programs for use in JavaScript environments. Today, it supports multithreaded C and C++ code using web workers in browsers and <code class="calibre18">worker_threads</code> in Node.js.</p>

<p class="author1">In fact, a large corpus of existing multithreaded code in the wild can be compiled with Emscripten without issue. In both Node.js and browsers, Emscripten emulates <a data-type="indexterm" data-primary="Node.js" data-secondary="Emscripten" id="idm45995910587704" class="calibre6"/>the system calls used by native code compiled to WebAssembly so that programs written in compiled languages can run without many changes.</p>

<p class="author1">Indeed, the C code we wrote way back in <a data-type="xref" href="ch01.xhtml#ch_intro" class="calibre6">Chapter 1</a> can be compiled without any editing! Let’s give that a try now. We’ll use a Docker image to simplify using Emscripten. For other compiler toolchains, we’d want to make sure that the toolchain aligns with the system, but since WebAssembly and JavaScript are both platform-agnostic, we can just use the Docker image wherever Docker is supported.</p>

<p class="author1">First, make sure <a href="https://docker.com" class="calibre6">Docker is installed</a>. Then, in your <em class="calibre7">ch1-c-threads</em> directory, run the following command:</p>

<pre data-type="programlisting" class="calibre38">$ docker run --rm -v $(pwd):/src -u $(id -u):$(id -g) \
  emscripten/emsdk emcc happycoin-threads.c -pthread \
  -s PTHREAD_POOL_SIZE=4 -o happycoin-threads.js</pre>

<p class="author1">There are a few things to discuss with this command. We’re running the <code class="calibre18">emscripten/emsdk</code> image, with the current directory mounted, running as the current user. Everything after and including <code class="calibre18">emcc</code> is the command we’re running inside the container. For the most part, this looks a lot like what we’d do when using <code class="calibre18">cc</code> to compile a C program. The main difference is that the output file is a JavaScript file rather than an executable binary. Don’t worry! A <em class="calibre7">.wasm</em> file is also generated. The JS file is used as a bridge to any necessary system calls and to set up the threads because those can’t be instantiated in WebAssembly alone.</p>

<p class="author1">The other extra argument is <code class="calibre18">-s PTHREAD_POOL_SIZE=4</code>. Since <code class="calibre18">happycoin-threads.c</code> uses three threads, we allocate them ahead of time here. There are a few ways to 
<span class="keep-together">handle</span> thread creation in Emscripten, largely due to not blocking on main browser threads. It’s easiest to preallocate here since we know how many threads we’ll need.</p>

<p class="author1">Now we can run our WebAssembly version of multithreaded Happycoin. We’ll run the JavaScript file with Node.js. At time of writing, this requires Node.js v16 or higher, since that’s what the output of Emscripten supports.</p>

<pre data-type="programlisting" class="calibre38">$ node happycoin-threads.js</pre>

<p class="author1">The output should look a bit like the following:</p>

<pre data-type="programlisting" class="calibre38">120190845798210000 ... [ 106 more entries ] ... 14356375476580480000
count 108
Pthread 0x9017f8 exited.
Pthread 0x701500 exited.
Pthread 0xd01e08 exited.
Pthread 0xb01b10 exited.</pre>

<p class="author1">The output looks the same as our other Happycoin examples from previous chapters, but the wrapper provided by Emscripten also informs us when the threads have exited. You’ll also need to Ctrl+C to exit the program. For extra fun, see if you can figure out what needs changing in order to make the process exit when done, and avoid those <code class="calibre18">Pthread</code> messages.</p>

<p class="author1">One thing you may notice when comparing against the native or JavaScript versions of Happycoin is timing. It’s clearly faster than the multithreaded JavaScript version, but also a bit slower than the native multithreaded C version. As always, it’s important to take measurements of your application to ensure that you’re getting the right benefits with the right trade-offs.</p>

<p class="author1">While the Happycoin example doesn’t make use of any atomic operations, Emscripten supports the full suite of POSIX thread functionality and GNU Compiler Collection (GCC) built-in atomic operation functions. This means a great multitude of C and C++ programs can <a data-type="indexterm" data-primary="WebAssembly" data-secondary="compilers" data-tertiary="Emscripten" data-startref="webassemscrip" id="idm45995910572632" class="calibre6"/><a data-type="indexterm" data-primary="Emscripten" data-startref="emscript" id="idm45995910571112" class="calibre6"/>compile to WebAssembly using Emscripten.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Other WebAssembly Compilers" class="calibre4"><div class="preface" id="ch_webassembly_sec_other">
<h1 class="calibre13">Other WebAssembly Compilers</h1>

<p class="author1">Emscripten isn’t the only way to compile code to WebAssembly. Indeed, WebAssembly was designed primarily as a compile target, rather than as a general-purpose language in its own right. There are myriad tools for compiling well-known languages to WebAssembly, and there are even some languages built with WebAssembly as the main target in mind, rather than machine code. Some are listed here, but it’s by no means <a href="https://oreil.ly/wKfBe" class="calibre6">exhaustive</a>. You’ll notice a lot of “at time of writing” here, because this space is relatively new and the best ways of creating multithreaded WebAssembly code are still being developed! At least, at time of writing.</p>
<dl class="calibre14">
<dt class="calibre15">Clang/Clang++</dt>
<dd class="calibre16">
<p class="calibre17">The LLVM C-family compilers can <a data-type="indexterm" data-primary="WebAssembly" data-secondary="compilers" data-tertiary="Clang family" id="idm45995910564984" class="calibre6"/><a data-type="indexterm" data-primary="LLVM C-family compilers" id="idm45995910563736" class="calibre6"/><a data-type="indexterm" data-primary="Clang compiler" id="idm45995910563064" class="calibre6"/>target WebAssembly with the <code class="calibre18">-target wasm32-unknown-unknown</code> or <code class="calibre18">-target wasm64-unknown-unknown</code> options, respectively. This is actually what Emscripten is now based on, in which POSIX threads and atomic operations work as expected. At time of writing, this is some of the best support for multithreaded WebAssembly. While <code class="calibre18">clang</code> and <code class="calibre18">clang++</code> support WebAssembly output, the recommended approach is to use Emscripten, to get the full suite of platform support in browsers and Node.js.</p>
</dd>
<dt class="calibre15">Rust</dt>
<dd class="calibre16">
<p class="calibre17">The Rust programming <a data-type="indexterm" data-primary="WebAssembly" data-secondary="compilers" data-tertiary="Rust" id="idm45995910558728" class="calibre6"/><a data-type="indexterm" data-primary="Rust" id="idm45995910557480" class="calibre6"/>language compiler <code class="calibre18">rustc</code> supports WebAssembly output. The Rust website is a <a href="https://oreil.ly/ibOs3" class="calibre6">great starting point</a> on how to use <code class="calibre18">rustc</code> in this way. To make use of threads, you can use the <a href="https://oreil.ly/Pyuv4" class="calibre6"><code class="calibre18">wasm-bindgen-rayon</code> crate</a>, which provides a parallelism API implemented using web workers. At time of writing, Rust’s standard library thread support won’t work.</p>
</dd>
<dt class="calibre15">AssemblyScript</dt>
<dd class="calibre16">
<p class="calibre17">The AssemblyScript <a data-type="indexterm" data-primary="WebAssembly" data-secondary="compilers" data-tertiary="AssemblyScript" id="Webassass" class="calibre6"/><a data-type="indexterm" data-primary="AssemblyScript" id="idm45995910551000" class="calibre6"/>compiler takes a subset of TypeScript as input, then generates WebAssembly output. While it does not support spawning threads, it does support atomic operations and using <code class="calibre18">SharedArrayBuffers</code>, so as long as you handle the threads themselves on the JavaScript side via web workers or <code class="calibre18">worker_threads</code>, you can make full use of multithreaded programming in AssemblyScript. We’ll cover it in more depth in the next section.</p>
</dd>
</dl>

<p class="author1">There are, of course, many more options, with new ones arriving all the time. 
<span class="keep-together">It’s worth</span> having a look around the web to see if your compiled language of choice 
<span class="keep-together">can target</span> WebAssembly, and whether or not it supports atomic operations in 
<span class="keep-together">WebAssembly</span>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="AssemblyScript" class="calibre4"><div class="preface" id="ch_webassembly_sec_script">
<h1 class="calibre13">AssemblyScript</h1>

<p class="author1"><a href="https://assemblyscript.org" class="calibre6">AssemblyScript</a> is a subset of <a href="https://typescriptlang.org" class="calibre6">TypeScript</a> that compiles to WebAssembly. Rather than compiling an existing langauge and providing implementations of existing system APIs, AssemblyScript was designed as a way to produce WebAssembly code with a much more familiar syntax than WAT. A major selling point of AssemblyScript is that many projects use TypeScript already, so adding some AssemblyScript code to take advantage of WebAssembly doesn’t require as much of a context-switch or even learning an entirely different programming language.</p>

<p class="author1">An AssemblyScript module looks a lot <a data-type="indexterm" data-primary="AssemblyScript" data-secondary="module" id="idm45995910542072" class="calibre6"/>like a TypeScript module. If you’re unfamiliar with TypeScript, it can be thought of as ordinary JavaScript, but with some additional syntax to indicate type information. Here is a basic TypeScript <a data-type="indexterm" data-primary="TypeScript module" id="idm45995910540744" class="calibre6"/>module that performs addition:</p>

<pre data-type="programlisting" data-code-language="typescript" class="calibre38"><code class="kr">export</code> <code class="kr">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
  <code class="kr">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code>
<code class="p">}</code></pre>

<p class="author1">You’ll notice this looks almost <a data-type="indexterm" data-primary="ECMAScript module" id="idm45995910513384" class="calibre6"/>exactly the same as a plain ECMAScript module, with the exception of type information in the form of <code class="calibre18">: number</code> after each of the function arguments and identifying the return value’s type. The TypeScript compiler can use these types to check that any code calling this function is passing in the correct types and assuming the correct type on the return value.</p>

<p class="author1">AssemblyScript looks much the same, except instead of using JavaScript’s <code class="calibre18">number</code> type, there are built-in types for each of the WebAssembly types. If we wanted to write the same addition module in TypeScript, and assuming 32-bit integers everywhere for types, it would look something like <a data-type="xref" href="#ex_ch7_as_add" class="calibre6">Example 7-3</a>. Go ahead and add that to a file called <em class="calibre7">ch7-wasm-add/add.ts</em>.</p>
<div id="ex_ch7_as_add" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 7-3. </span><em class="calibre7">ch7-wasm-add/add.ts</em></h5>

<pre data-type="programlisting" data-code-language="typescript" class="calibre28"><code class="kr">export</code> <code class="kr">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">i32</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">i32</code><code class="p">)</code><code class="o">:</code> <code class="nx">i32</code> <code class="p">{</code>
  <code class="kr">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code>
<code class="p">}</code></pre></div>

<p class="author1">Since AssemblyScript files are just <a data-type="indexterm" data-primary="AssemblyScript" data-secondary=".ts file extension" data-secondary-sortas="ts file extension" id="idm45995910459144" class="calibre6"/><a data-type="indexterm" data-primary="ts file extension" data-primary-sortas="ts" id="idm45995910458056" class="calibre6"/>TypeScript, they use the <em class="calibre7">.ts</em> extension just the same. To compile a given AssemblyScript file to WebAssembly, we can use the <code class="calibre18">asc</code> command from the <code class="calibre18">assemblyscript</code> module. Try running the following command in the <em class="calibre7">ch7-wasm-add</em> directory:</p>

<pre data-type="programlisting" class="calibre38">$ npx -p assemblyscript asc add.ts --binaryFile add.wasm</pre>

<p class="author1">You can try running the WebAssembly code using the same <em class="calibre7">add.js</em> file from <a data-type="xref" href="#ex_ch7_add_wat_js" class="calibre6">Example 7-2</a>. The output should be the same since the code is the same.</p>

<p class="author1">If you omit the <code class="calibre18">--binaryFile add.wasm</code> you’ll get the module as translated into WAT, as shown in <a data-type="xref" href="#ex_ch7_as_add_wat" class="calibre6">Example 7-4</a>. You’ll see it’s roughly the same as <a data-type="xref" href="#ex_ch7_add_wat" class="calibre6">Example 7-1</a>.</p>
<div id="ex_ch7_as_add_wat" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 7-4. </span>The WAT rendition of the AssemblyScript <code class="calibre18">add</code> function</h5>

<pre data-type="programlisting" data-code-language="lisp" class="calibre28"><code class="p">(</code><code class="nv">module</code>
 <code class="p">(</code><code class="kr">type</code> <code class="nv">$i32_i32_=&gt;_i32</code> <code class="p">(</code><code class="nv">func</code> <code class="p">(</code><code class="nv">param</code> <code class="nv">i32</code> <code class="nv">i32</code><code class="p">)</code> <code class="p">(</code><code class="nv">result</code> <code class="nv">i32</code><code class="p">)))</code>
 <code class="p">(</code><code class="nv">memory</code> <code class="nv">$0</code> <code class="mi">0</code><code class="p">)</code>
 <code class="p">(</code><code class="nb">export</code> <code class="s">"add"</code> <code class="p">(</code><code class="nv">func</code> <code class="nv">$add/add</code><code class="p">))</code>
 <code class="p">(</code><code class="nb">export</code> <code class="s">"memory"</code> <code class="p">(</code><code class="nv">memory</code> <code class="nv">$0</code><code class="p">))</code>
 <code class="p">(</code><code class="nv">func</code> <code class="nv">$add/add</code> <code class="p">(</code><code class="nv">param</code> <code class="nv">$0</code> <code class="nv">i32</code><code class="p">)</code> <code class="p">(</code><code class="nv">param</code> <code class="nv">$1</code> <code class="nv">i32</code><code class="p">)</code> <code class="p">(</code><code class="nv">result</code> <code class="nv">i32</code><code class="p">)</code>
  <code class="nv">local.get</code> <code class="nv">$0</code>
  <code class="nv">local.get</code> <code class="nv">$1</code>
  <code class="nv">i32.add</code>
 <code class="p">)</code>
<code class="p">)</code></pre></div>

<p class="author1">AssemblyScript doesn’t provide the <a data-type="indexterm" data-primary="AssemblyScript" data-secondary="spawning threads" id="idm45995910446456" class="calibre6"/>ability to spawn threads, but threads can be spawned in the JavaScript environment, and <code class="calibre18">SharedArrayBuffers</code> can be used for the WebAssembly memory. Most importantly, it supports atomic operations via a global <code class="calibre18">atomics</code> object, not particularly different from regular JavaScript’s <code class="calibre18">Atomics</code>. The main difference is that rather than operating on a <code class="calibre18">TypedArray</code>, these functions operate on the linear memory of the WebAssembly module, with a pointer and an optional offset. See the <a href="https://oreil.ly/LhTkW" class="calibre6">AssemblyScript documentation</a> for details.</p>

<p class="author1">To see this in action, let’s create one more implementation of our Happycoin example that we’ve been iterating on since <a data-type="xref" href="ch01.xhtml#ch_intro" class="calibre6">Chapter 1</a>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Happycoin in AssemblyScript" class="calibre4"><div class="preface" id="idm45995910545496">
<h1 class="calibre13">Happycoin in AssemblyScript</h1>

<p class="author1">Much like previous versions of our <a data-type="indexterm" data-primary="AssemblyScript" data-secondary="Happycoin" id="asshappy" class="calibre6"/><a data-type="indexterm" data-primary="Happycoin" data-secondary="AssemblyScript" id="happyassscript" class="calibre6"/>Happycoin example, this approach multiplexes the crunching of numbers over several threads and sends the results back. It’s a glimpse of how multithreaded AssemblyScript can work. In a real-world application, you’d want to take advantage of shared memory and atomic operations, but to keep things simple, we’ll stick with just fanning the work out to the threads.</p>

<p class="author1">Let’s begin by creating a directory <a data-type="indexterm" data-primary="code samples" data-secondary="ch7-happycoin-as" id="idm45995910352984" class="calibre6"/>called <em class="calibre7">ch7-happycoin-as</em> and switch to that directory. We’ll initialize a new project and add some necessary dependencies as follows:</p>

<pre data-type="programlisting" class="calibre38">$ npm init -y
$ npm install assemblyscript
$ npm install @assemblyscript/loader</pre>

<p class="author1">The <code class="calibre18">assemblyscript</code> package includes <a data-type="indexterm" data-primary="AssemblyScript" data-secondary="assemblyscript package" id="idm45995910349784" class="calibre6"/>the AssemblyScript compiler, and the <code class="calibre18">assemblyscript/loader</code> package gives us handy tools for interacting with the built 
<span class="keep-together">module</span>.</p>

<p class="author1">In the <code class="calibre18">scripts</code> object in the newly created <em class="calibre7">package.json</em>, we’ll add <code class="calibre18">"build"</code> and <code class="calibre18">"start"</code> properties to simplify the compilation and running of the program:</p>

<pre data-type="programlisting" class="calibre38">"build": "asc happycoin.ts --binaryFile happycoin.wasm --exportRuntime",
"start": "node --no-warnings --experimental-wasi-unstable-preview1 happycoin.mjs"</pre>

<p class="author1">The additional <code class="calibre18">--exportRuntime</code> parameter gives us some high-level tools for interacting with values from AssemblyScript. We’ll get into that a bit later.</p>

<p class="author1">When invoking Node.js in the <code class="calibre18">"start"</code> script, <a data-type="indexterm" data-primary="Node.js" data-secondary="WASI flag" id="idm45995910342392" class="calibre6"/>we pass the experimental WASI flag. This enables the <a href="https://wasi.dev" class="calibre6">WebAssembly System Interface (WASI)</a> interface, giving WebAssembly access to system-level functionality that would otherwise be inaccessible. We’ll use this from AssemblyScript to generate random numbers. Because it’s experimental at time of writing, we’ll add the <code class="calibre18">--no-warnings</code> flag<sup class="calibre39"><a data-type="noteref" id="idm45995910339912-marker" href="ch07.xhtml#idm45995910339912" class="calibre40">2</a></sup> to suppress the warning we get for using WASI. The experimental status also means the flag may change in the future, so always be sure to consult the Node.js documentation for the version of Node.js you’re running.</p>

<p class="author1">Now, let’s write some AssemblyScript! <a data-type="xref" href="#ex_ch7_as_happycoin" class="calibre6">Example 7-5</a> contains an AssemblyScript version of the Happycoin algorithm. Go ahead and add it to a file called <em class="calibre7">happycoin.ts</em>.</p>
<div id="ex_ch7_as_happycoin" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 7-5. </span><em class="calibre7">ch7-happycoin-as/happycoin.ts</em></h5>

<pre data-type="programlisting" data-code-language="typescript" class="calibre28"><code class="kr">import</code><code class="calibre18"> </code><code class="s">'wasi'</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_webassembly_CO2-1" href="#callout_webassembly_CO2-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">

</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">randArr64</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Uint64Array</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">randArr8</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">Uint8Array</code><code class="p">.</code><code class="nx">wrap</code><code class="p">(</code><code class="nx">randArr64</code><code class="p">.</code><code class="nx">buffer</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">,</code><code class="calibre18"> </code><code class="mi">8</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_webassembly_CO2-2" href="#callout_webassembly_CO2-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
</code><code class="kr">function</code><code class="calibre18"> </code><code class="nx">random64</code><code class="p">(</code><code class="p">)</code><code class="o">:</code><code class="calibre18"> </code><code class="nx">u64</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="nx">crypto</code><code class="p">.</code><code class="nx">getRandomValues</code><code class="p">(</code><code class="nx">randArr8</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="co_webassembly_CO2-3" href="#callout_webassembly_CO2-3"><img src="Images/3.png" alt="3" class="calibre32"/></a><code class="calibre18">
  </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">randArr64</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18">

</code><code class="kr">function</code><code class="calibre18"> </code><code class="nx">sumDigitsSquared</code><code class="p">(</code><code class="nx">num</code><code class="calibre18">: </code><code class="nx">u64</code><code class="p">)</code><code class="o">:</code><code class="calibre18"> </code><code class="nx">u64</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">total</code><code class="calibre18">: </code><code class="nx">u64</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">while</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">num</code><code class="calibre18"> </code><code class="o">&gt;</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">numModBase</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">num</code><code class="calibre18"> </code><code class="o">%</code><code class="calibre18"> </code><code class="mi">10</code><code class="p">;</code><code class="calibre18">
    </code><code class="nx">total</code><code class="calibre18"> </code><code class="o">+=</code><code class="calibre18"> </code><code class="nx">numModBase</code><code class="calibre18"> </code><code class="o">*</code><code class="o">*</code><code class="calibre18"> </code><code class="mi">2</code><code class="p">;</code><code class="calibre18">
    </code><code class="nx">num</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">num</code><code class="calibre18"> </code><code class="o">/</code><code class="calibre18"> </code><code class="mi">10</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18">
  </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">total</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18">

</code><code class="kr">function</code><code class="calibre18"> </code><code class="nx">isHappy</code><code class="p">(</code><code class="nx">num</code><code class="calibre18">: </code><code class="nx">u64</code><code class="p">)</code><code class="o">:</code><code class="calibre18"> </code><code class="kr">boolean</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">while</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">num</code><code class="calibre18"> </code><code class="o">!=</code><code class="calibre18"> </code><code class="mi">1</code><code class="calibre18"> </code><code class="o">&amp;&amp;</code><code class="calibre18"> </code><code class="nx">num</code><code class="calibre18"> </code><code class="o">!=</code><code class="calibre18"> </code><code class="mi">4</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="nx">num</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">sumDigitsSquared</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18">
  </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">num</code><code class="calibre18"> </code><code class="o">===</code><code class="calibre18"> </code><code class="mi">1</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18">

</code><code class="kr">function</code><code class="calibre18"> </code><code class="nx">isHappycoin</code><code class="p">(</code><code class="nx">num</code><code class="calibre18">: </code><code class="nx">u64</code><code class="p">)</code><code class="o">:</code><code class="calibre18"> </code><code class="kr">boolean</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">isHappy</code><code class="p">(</code><code class="nx">num</code><code class="p">)</code><code class="calibre18"> </code><code class="o">&amp;&amp;</code><code class="calibre18"> </code><code class="nx">num</code><code class="calibre18"> </code><code class="o">%</code><code class="calibre18"> </code><code class="mi">10000</code><code class="calibre18"> </code><code class="o">===</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18">

</code><code class="kr">export</code><code class="calibre18"> </code><code class="kr">function</code><code class="calibre18"> </code><code class="nx">getHappycoins</code><code class="p">(</code><code class="nx">num</code><code class="calibre18">: </code><code class="nx">u32</code><code class="p">)</code><code class="o">:</code><code class="calibre18"> </code><code class="nb">Array</code><code class="o">&lt;</code><code class="nx">u64</code><code class="o">&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">result</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nb">Array</code><code class="o">&lt;</code><code class="nx">u64</code><code class="o">&gt;</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18">: </code><code class="nx">u32</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">1</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="nx">num</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="o">++</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">randomNum</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">random64</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">isHappycoin</code><code class="p">(</code><code class="nx">randomNum</code><code class="p">)</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="nx">result</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">randomNum</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
    </code><code class="p">}</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18">
  </code><code class="kr">return</code><code class="calibre18"> </code><code class="nx">result</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="callout_webassembly_CO2-1" href="#co_webassembly_CO2-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">The <code class="calibre18">wasi</code> module is imported here to <a data-type="indexterm" data-primary="AssemblyScript" data-secondary="wasi module" id="idm45995910170280" class="calibre6"/>ensure that the appropriate WASI-enabled globals are loaded.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_webassembly_CO2-2" href="#co_webassembly_CO2-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">We initialized a <code class="calibre18">Uint64Array</code> for our random numbers, but <code class="calibre18">crypto.getRandomValues()</code> only works with <code class="calibre18">Uint8Array</code>, so we’ll create one of those here as a view on the same buffer. Also, the <code class="calibre18">TypedArray</code> constructors <a data-type="indexterm" data-primary="constructors" data-secondary="TypedArray" id="idm45995910255032" class="calibre6"/>in AssemblyScript aren’t overloaded, so instead there’s a static <code class="calibre18">wrap()</code> method available to construct new <code class="calibre18">TypedArray</code> instances from <code class="calibre18">ArrayBuffer</code> instances.</p></dd>
<dt class="calibre15"><a class="calibre6" id="callout_webassembly_CO2-3" href="#co_webassembly_CO2-3"><img src="Images/3.png" alt="3" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">This method is the one we enabled WASI for.</p></dd>
</dl></div>

<p class="author1">If you’re familiar with TypeScript, you might be thinking this file looks very close to just being a TypeScript port of <a data-type="xref" href="ch03.xhtml#sec_happycoin_revisited" class="calibre6">“Happycoin: Revisited”</a>. You’d be correct! This is one of the major advantages of AssemblyScript. We’re not writing in a brand-new language, and yet we’re writing code that maps very closely to WebAssembly. Note that the return value of the exported function is of type <code class="calibre18">Array&lt;u64&gt;</code>. Exported functions in WebAssembly can’t return arrays of any kind, but they can return an index into the module’s memory (a pointer, really), which is exactly what’s happening here. We could deal with this manually, but as we’ll see, the AssemblyScript loader makes it much easier.</p>

<p class="author1">Of course, since AssemblyScript doesn’t provide a way of spawning threads on its own, we’ll need to do that from JavaScript. For this example, we’ll use ECMAScript modules to take advantage of top-level <code class="calibre18">await</code>, so go ahead and put the contents of <a data-type="xref" href="#ex_ch7_mjs_happycoin" class="calibre6">Example 7-6</a> into a file called <em class="calibre7">happycoin.mjs</em>.</p>
<div id="ex_ch7_mjs_happycoin" data-type="example" class="calibre26">
<h5 class="calibre27"><span class="keep-together">Example 7-6. </span><em class="calibre7">ch7-happycoin-as/happycoin.mjs</em></h5>
<pre data-type="programlisting" data-code-language="javascript" class="calibre28"><code class="kr">import</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">WASI</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="nx">from</code><code class="calibre18"> </code><code class="s">'wasi'</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="manual_co_webassembly_CO3-1" href="#manual_callout_webassembly_CO3-1"><img src="Images/1.png" alt="1" class="calibre32"/></a><code class="calibre18">
</code><code class="kr">import</code><code class="calibre18"> </code><code class="nx">fs</code><code class="calibre18"> </code><code class="nx">from</code><code class="calibre18"> </code><code class="s">'fs/promises'</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">import</code><code class="calibre18"> </code><code class="nx">loader</code><code class="calibre18"> </code><code class="nx">from</code><code class="calibre18"> </code><code class="s">'@assemblyscript/loader'</code><code class="p">;</code><code class="calibre18">
</code><code class="kr">import</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">isMainThread</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">parentPort</code><code class="calibre18"> </code><code class="p">}</code><code class="calibre18"> </code><code class="nx">from</code><code class="calibre18"> </code><code class="s">'worker_threads'</code><code class="p">;</code><code class="calibre18">

</code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">THREAD_COUNT</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">4</code><code class="p">;</code><code class="calibre18">

</code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="nx">isMainThread</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">inFlight</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">THREAD_COUNT</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">count</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">for</code><code class="calibre18"> </code><code class="p">(</code><code class="kr">let</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="calibre18"> </code><code class="o">&lt;</code><code class="calibre18"> </code><code class="nx">THREAD_COUNT</code><code class="p">;</code><code class="calibre18"> </code><code class="nx">i</code><code class="o">++</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
    </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">worker</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">Worker</code><code class="p">(</code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">URL</code><code class="p">(</code><code class="kr">import</code><code class="p">.</code><code class="nx">meta</code><code class="p">.</code><code class="nx">url</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code class="calibre18"> </code><a class="calibre6" id="manual_co_webassembly_CO3-2" href="#manual_callout_webassembly_CO3-2"><img src="Images/2.png" alt="2" class="calibre32"/></a><code class="calibre18">
    </code><code class="nx">worker</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'message'</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">msg</code><code class="calibre18"> </code><code class="o">=&gt;</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
      </code><code class="nx">count</code><code class="calibre18"> </code><code class="o">+=</code><code class="calibre18"> </code><code class="nx">msg</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code><code class="calibre18">
      </code><code class="nx">process</code><code class="p">.</code><code class="nx">stdout</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">msg</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s">' '</code><code class="p">)</code><code class="calibre18"> </code><code class="o">+</code><code class="calibre18"> </code><code class="s">' '</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="kr">if</code><code class="calibre18"> </code><code class="p">(</code><code class="o">--</code><code class="nx">inFlight</code><code class="calibre18"> </code><code class="o">===</code><code class="calibre18"> </code><code class="mi">0</code><code class="p">)</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
        </code><code class="nx">process</code><code class="p">.</code><code class="nx">stdout</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="s">'\ncount '</code><code class="calibre18"> </code><code class="o">+</code><code class="calibre18"> </code><code class="nx">count</code><code class="calibre18"> </code><code class="o">+</code><code class="calibre18"> </code><code class="s">'\n'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
      </code><code class="p">}</code><code class="calibre18">
    </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="p">}</code><code class="calibre18">
</code><code class="p">}</code><code class="calibre18"> </code><code class="kr">else</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">wasi</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="kr">new</code><code class="calibre18"> </code><code class="nx">WASI</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">importObject</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="p">{</code><code class="calibre18"> </code><code class="nx">wasi_snapshot_preview1</code><code class="o">:</code><code class="calibre18"> </code><code class="nx">wasi</code><code class="p">.</code><code class="nx">wasiImport</code><code class="calibre18"> </code><code class="p">}</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">wasmFile</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">await</code><code class="calibre18"> </code><code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s">'./happycoin.wasm'</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">happycoinModule</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">await</code><code class="calibre18"> </code><code class="nx">loader</code><code class="p">.</code><code class="nx">instantiate</code><code class="p">(</code><code class="nx">wasmFile</code><code class="p">,</code><code class="calibre18"> </code><code class="nx">importObject</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">wasi</code><code class="p">.</code><code class="nx">start</code><code class="p">(</code><code class="nx">happycoinModule</code><code class="p">)</code><code class="p">;</code><code class="calibre18">

  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">happycoinsWasmArray</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18">
    </code><code class="nx">happycoinModule</code><code class="p">.</code><code class="nx">exports</code><code class="p">.</code><code class="nx">getHappycoins</code><code class="p">(</code><code class="mi">10_000_000</code><code class="o">/</code><code class="nx">THREAD_COUNT</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="kr">const</code><code class="calibre18"> </code><code class="nx">happycoins</code><code class="calibre18"> </code><code class="o">=</code><code class="calibre18"> </code><code class="nx">happycoinModule</code><code class="p">.</code><code class="nx">exports</code><code class="p">.</code><code class="nx">__getArray</code><code class="p">(</code><code class="nx">happycoinsWasmArray</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
  </code><code class="nx">parentPort</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="nx">happycoins</code><code class="p">)</code><code class="p">;</code><code class="calibre18">
</code><code class="p">}</code></pre>
<dl class="calibre14">
<dt class="calibre15"><a class="calibre6" id="manual_callout_webassembly_CO3-1" href="#manual_co_webassembly_CO3-1"><img src="Images/1.png" alt="1" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">This can’t be done without the <code class="calibre18">--experimental-wasi-unstable-preview1</code> flag.</p></dd>
<dt class="calibre15"><a class="calibre6" id="manual_callout_webassembly_CO3-2" href="#manual_co_webassembly_CO3-2"><img src="Images/2.png" alt="2" class="calibre32"/></a></dt>
<dd class="calibre33"><p class="calibre34">If you’re new to ESM, this might look strange. We don’t get the <code class="calibre18">__filename</code> variable available to us like we do in CommonJS modules. Instead the <code class="calibre18">import.meta.url</code> property gives us the full path as a file URL string. We need to pass that to the <code class="calibre18">URL</code> constructor for it to be usable as an input to the <code class="calibre18">Worker</code> constructor.</p></dd>
</dl></div>

<p class="author1">Adapted from <a data-type="xref" href="ch03.xhtml#sec_happycoin_revisited" class="calibre6">“Happycoin: Revisited”</a>, we’re again checking whether we’re in the main thread or not, and spawning four worker threads from the main thread. In the main thread, we’re expecting only one message on the default <code class="calibre18">MessagePort</code>, containing an array of found Happycoins. We simply log those and a count of all of them once all the worker threads have sent the message.</p>

<p class="author1">On the <code class="calibre18">else</code> side, in the worker threads, we initialize a WASI instance to pass to the WebAssembly module, and then instantiate the module using <code class="calibre18">@assemblyscript/loader</code>, giving us what we need to handle the array return value we get from the <code class="calibre18">getHappycoins</code> function. We call the <code class="calibre18">getHappycoins()</code> method exported by the module, which gives us a pointer to an array in the WebAssembly linear memory. The <code class="calibre18">__getArray</code> function, provided by the loader, converts that pointer into a JavaScript array, which we can then use as normal. We pass that to the main thread for output.</p>

<p class="author1">To run this example, run the following two commands. The first will compile the AssemblyScript to WebAssembly, and the second will run it via the JavaScript we just put together:</p>

<pre data-type="programlisting" class="calibre38">$ npm run build
$ npm start</pre>

<p class="author1">The output will look roughly the same as with previous Happycoin examples. Here is the output from one local run:</p>

<pre data-type="programlisting" class="calibre38">7641056713284760000 ... [ 134 more entries ] ... 10495060512882410000
count 136</pre>

<p class="author1">As with all of these solutions, it’s important to evaluate the trade-offs made with proper benchmarks. As an exercise, try <a data-type="indexterm" data-primary="WebAssembly" data-secondary="compilers" data-tertiary="AssemblyScript" data-startref="Webassass" id="idm45995909975832" class="calibre6"/><a data-type="indexterm" data-primary="AssemblyScript" data-secondary="Happycoin" data-startref="asshappy" id="idm45995909974312" class="calibre6"/><a data-type="indexterm" data-primary="Happycoin" data-secondary="AssemblyScript" data-startref="happyassscript" id="idm45995909973096" class="calibre6"/>timing this example against the other Happycoin implementations in this book. Is it faster or slower? Can you figure out why? What improvements can be made?</p>
</div></section>







<div data-type="footnotes" class="calibre41"><p data-type="footnote" id="idm45995910670680" class="calibre42"><sup class="calibre43"><a href="ch07.xhtml#idm45995910670680-marker" class="calibre40">1</a></sup> In C and other languages without automatic memory management, memory must be allocated for use with allocation functions like <code class="calibre18">malloc()</code> and then freed for later allocation with functions like <code class="calibre18">free()</code>. Memory management techniques like garbage collection make it easier to write programs in higher-level languages like JavaScript, but they aren’t a built-in feature of WebAssembly.</p><p data-type="footnote" id="idm45995910339912" class="calibre42"><sup class="calibre43"><a href="ch07.xhtml#idm45995910339912-marker" class="calibre40">2</a></sup> In general, this isn’t a flag you want to have enabled for a production application. Hopefully by the time you read this, WASI support will no longer be experimental. If that’s the case, adjust these arguments accordingly.</p></div></div></section></div></body></html>