<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Introduction to Linux"><div class="chapter" id="intro-to-linux">
<h1><span class="label">Chapter 1. </span>Introduction to Linux</h1>


<p>Linux is the most widely used operating system, used in everything from mobile
devices to the cloud.</p>

<p>You might not be familiar with the concept of an operating system. Or you
might be using an operating system such as Microsoft Windows without giving
it too much thought. Or maybe you are new to Linux. To set the scene and
get you in the right mindset, we’ll take a bird’s-eye view of operating systems
and Linux in this chapter.</p>

<p>We’ll first discuss what <em>modern</em> means in the context
of the book. Then we’ll review a high-level Linux backstory, looking at important
events and phases over the past 30 years. Further, in this chapter you’ll learn what
the role of an operating system is in general and how Linux fills this role.
We also take a quick look at what Linux distributions are and what resource
visibility means.</p>

<p>If you’re new to operating systems and Linux, you’ll want to read the entire
chapter. If you’re already experienced with Linux, you might want to jump to
<a data-type="xref" href="#intro-10-view">“A Ten-Thousand-Foot View of Linux”</a>, which provides a visual overview as well as mapping to the book’s chapters.</p>

<p>But before we get into the technicalities, let’s first step back a bit and focus
on what we mean when we say “modern Linux.” This is, surprisingly, a nontrivial matter.</p>






<section data-type="sect1" data-pdf-bookmark="What Are Modern Environments?"><div class="sect1" id="intro-modern-envs">
<h1>What Are Modern Environments?</h1>

<p><a data-type="indexterm" data-primary="modern environments" id="ix_ch01-asciidoc0"/>The book title specifies <a data-type="indexterm" data-primary="modern, defined" id="idm45805455318832"/><em>modern</em>, but what does that really mean? Well, in the
context of this book, it can mean anything from cloud computing to a Raspberry Pi.
In addition, the recent rise of Docker and related innovations in infrastructure
has dramatically changed the landscape for developers and infrastructure
operators alike.</p>

<p>Let’s take a closer look at some of these modern environments
and the prominent role Linux plays in them:</p>
<dl>
<dt>Mobile devices</dt>
<dd>
<p><a data-type="indexterm" data-primary="mobile devices" id="idm45805451811008"/>When I say “mobile phone” to our kids, they say, “In contrast to what?”
In all fairness and seriousness, these days many phones—depending on who you ask, up to 80%
or more—as well as tablets run Android, which is a
<a href="https://oreil.ly/bQ6yJ">Linux variant</a>. These
environments have aggressive requirements around power consumption and
robustness, as we depend on them on a daily basis. If you’re interested in
developing Android apps, consider visiting the
<a href="https://oreil.ly/xf5kC">Android developer site</a> for more information.</p>
</dd>
<dt>Cloud computing</dt>
<dd>
<p><a data-type="indexterm" data-primary="cloud computing" id="idm45805451807616"/>With the cloud, we see at scale a similar pattern
as in the mobile and micro space. There are new, powerful, secure, and
energy-saving CPU architectures such as the successful ARM-based
<a href="https://oreil.ly/JzHzm">AWS Graviton</a> offerings, as well as
the established heavy-lifting outsourcing to cloud providers, especially in
the context of open source software.</p>
</dd>
<dt>Internet of (Smart) Things</dt>
<dd>
<p><a data-type="indexterm" data-primary="Internet of Things (IoT)" id="idm45805452151584"/>I’m sure you’ve seen a lot of Internet of Things (IoT)–related projects and products, from sensors
to drones. Many of us have already been exposed to smart appliances and smart cars.
These environments have even more challenging requirements around power consumption
than mobile devices. In addition, they might not even be
running all the time but, for example, only wake up once a day to transmit some data.
Another important aspect of these environments is
<a href="https://oreil.ly/zBsRy">real-time
capabilities</a>. If you’re interested in getting started with Linux in the IoT
context, consider the <a href="https://oreil.ly/3x0uf">AWS IoT EduKit</a>.</p>
</dd>
<dt>Diversity of processor architectures</dt>
<dd>
<p>For the past 30 years or so, Intel has been the leading CPU manufacturer, dominating
the microcomputer and personal computer space. Intel’s x86 architecture was
considered the gold standard. The open approach that IBM took (publishing the
specifications and enabling others to offer compatible devices) was promising,
resulting in x86 clones that also used Intel chips, at least initially.</p>

<p>While Intel is still widely used in desktop and laptop systems, with the
rise of mobile devices we’ve seen the increasing uptake of the
<a href="https://oreil.ly/sioDd">ARM
architecture</a> and recently <a href="https://oreil.ly/Tf0bb">RISC-V</a>.
At the same time, multi-arch programming languages and tooling, such as Go or
Rust, are becoming more and more widespread, creating a perfect storm.</p>
</dd>
</dl>

<p>All of these environments are examples of what I consider modern environments.
And most, if not all of them, run on or use Linux in one form or another.</p>

<p>Now that we know about the modern (hardware) systems, you might wonder how
we got here and how Linux came into being.<a data-type="indexterm" data-startref="ix_ch01-asciidoc0" id="idm45805452144848"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The Linux Story (So Far)"><div class="sect1" id="intro-backstory">
<h1>The Linux Story (So Far)</h1>

<p><a data-type="indexterm" data-primary="Linux (generally)" data-secondary="brief history of" id="idm45805454864096"/>Linux celebrated its <a href="https://oreil.ly/fkMyT">30th birthday</a>
in 2021. With billions of users and thousands of developers, the Linux project
is, without doubt, a worldwide (open source) success story. But how did it all
this start, and how did we get here?</p>
<dl>
<dt>1990s</dt>
<dd>
<p>We can consider Linus Torvalds’s email on August 25, 1991, to the
<code>comp.os.minix</code> newsgroup as the birth of the Linux project, at least in terms of the public record. This hobby project soon took off, both in terms of lines of code
(LOC) and in terms of adoption. For example, after less than three years, Linux 1.0.0
was released with over 176,000 LOCs. By that time, the original goal of being able
to run most Unix/GNU software was already well reached. Also, the first
commercial offering appeared in the 1990s: Red Hat Linux.</p>
</dd>
<dt>2000 to 2010</dt>
<dd>
<p>As a “teenager,” Linux was not only maturing in terms of features and supported
hardware but was also growing beyond what UNIX could do. In this time period, we also
witnessed a huge and ever-increasing buy-in of Linux by the big players, that
is, adoption by Google, Amazon, IBM, and so on. It was also the peak of the
<a href="https://oreil.ly/l6X4Q">distro wars</a>,
resulting in businesses changing their 
<span class="keep-together">directions.</span></p>
</dd>
<dt>2010s to now</dt>
<dd>
<p>Linux established itself as the workhorse in data centers and the cloud, as
well as for any types of IoT devices and phones. In a sense, one can consider
the distro wars as being over (nowadays, most commercial systems are either Red Hat
or Debian based), and in a sense, the rise of containers (from 2014/15 on)
is responsible for this development.</p>
</dd>
</dl>

<p>With this super-quick historic review, necessary to set the context and
understand the motivation for the scope of this book, we move on to a seemingly
innocent question: Why does anyone need Linux, or an operating system at all?</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Why an Operating System at All?"><div class="sect1" id="intro-os-overiew">
<h1>Why an Operating System at All?</h1>

<p><a data-type="indexterm" data-primary="operating system, reasons for having" id="idm45805455027552"/>Let’s say you do not have an operating system (OS) available or cannot use one
for whatever reason. You would then end up doing pretty much everything yourself:
memory management, interrupt handling, talking with I/O devices, managing files,
configuring and managing the network stack—the list goes on.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Technically speaking, an OS is not strictly needed. There are systems out
there that do not have an OS. These are usually embedded systems with a tiny
footprint: think of an IoT beacon. They simply do not have the resources available
to keep anything else around other than one application. For example, with Rust
you can use its Core and Standard Library to run any app on
<a href="https://oreil.ly/zW4j7">bare metal</a>.</p>
</div>

<p>An operating system takes on all this undifferentiated heavy lifting, abstracting
away the different hardware components and providing you with a (usually) clean
and nicely designed Application Programming Interface (API), such as is the case
with the Linux kernel that we will have a closer look at in <a data-type="xref" href="ch02.xhtml#kernel">Chapter 2</a>. <a data-type="indexterm" data-primary="system calls (syscalls)" id="idm45805455023584"/>We usually
call these APIs that an OS exposes <em>system calls</em>, or <em>syscalls</em> for short. Higher-level programming languages such as Go, Rust, Python, or Java build on top of
those syscalls, potentially wrapping them in libraries.</p>

<p>All of this allows you to focus on the business logic rather than having
to manage the resources yourself, and also takes care of the different hardware
you want to run your app on.</p>

<p>Let’s have a look at a concrete example of a syscall. Let’s say we want to
identify (and print) the ID of the current user.</p>

<p>First, we look at the Linux syscall
<a href="https://oreil.ly/md15Z"><code>getuid(2)</code></a>:</p>

<pre data-type="programlisting" data-code-language="shell">...
getuid<code class="o">()</code> returns the real user ID of the calling process.
...</pre>

<p>OK, so this <code>getuid</code> syscall is what we could use programmatically,
from a library. We will discuss Linux syscalls in greater detail in
<a data-type="xref" href="ch02.xhtml#kernel-syscalls">“syscalls”</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You might be wondering what the <code>(2)</code> means in <code>getuid(2)</code>. It’s a terminology
that the <code>man</code> utility (think built-in help pages) uses to indicate the section
of the command assigned in <code>man</code>, akin to a postal or country code. This is one
example where the Unix legacy is apparent; you can find its origin in the
<a href="https://oreil.ly/DgDrF"><em>Unix Programmer’s Manual</em>,
seventh edition, volume 1</a> from 1979.</p>
</div>

<p>On the command line (shell), we would be using the equivalent <code>id</code> command that
in turn uses the <code>getuid</code> syscall:</p>

<pre data-type="programlisting" data-code-language="shell">$ id --user
<code class="m">638114</code></pre>

<p>Now that you have a basic idea of why using an operating system, in most cases, makes
sense, let’s move on to the topic of Linux distributions.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Linux Distributions"><div class="sect1" id="idm45805453979040">
<h1>Linux Distributions</h1>

<p><a data-type="indexterm" data-primary="distros" data-secondary="basics" id="idm45805453334896"/><a data-type="indexterm" data-primary="Linux (generally)" data-secondary="distributions" id="idm45805451006304"/>When we say “Linux,” it might not be immediately clear what we mean. In this book,
we will say “Linux kernel,” or just “kernel,” when we mean the set of syscalls and
device drivers. Further, when we refer to
<a href="https://oreil.ly/U9luq">Linux distributions</a>
(or <em>distros</em>, for short), we mean a concrete bundling of kernel and related
components, including package management, file system layout, init system, and a shell, preselected for you.</p>

<p>Of course, you could do all of this yourself: you could download and compile the
kernel, choose a package manager, and so on, and create (or <em>roll</em>) your own distro.
And that’s what many folks did in the beginning. Over the years, people figured
out that it is a better use of their time to leave this packaging
(and also security patching) to experts, private or commercial, and simply
use the resulting Linux distro.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you are inclined to build your own distribution, maybe because you are a
tinkerer or because you have to due to certain business restrictions, I recommend
you take a closer look at <a href="https://oreil.ly/UBSHM">Arch Linux</a>, which puts you
in control and, with a little effort, allows you to create a very customized Linux
distro.</p>
</div>

<p>To get a feeling for the vastness of the distro space, including traditional distros
(Ubuntu, Red Hat Enterprise Linux [RHEL], CentOS, etc., as discussed in <a data-type="xref" href="ch06.xhtml#running-apps">Chapter 6</a>) and modern distros
(such as Bottlerocket and Flatcar; see <a data-type="xref" href="ch09.xhtml#advanced">Chapter 9</a>),
take a look at <a href="https://oreil.ly/DWmrr">DistroWatch</a>.</p>

<p>With the distro topic out of the way, let’s move on to a totally different
topic: resources and their visibility and isolation.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Resource Visibility"><div class="sect1" id="idm45805449948288">
<h1>Resource Visibility</h1>

<p><a data-type="indexterm" data-primary="Linux (generally)" data-secondary="resource visibility" id="ix_ch01-asciidoc1"/><a data-type="indexterm" data-primary="resource visibility" id="ix_ch01-asciidoc2"/>Linux has had, in good UNIX tradition, a by-default global view on resources.
This leads us to the question: what does <em>global view</em> mean (in contrast to what?),
and what are said resources?</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Why are we talking about resource visibility here in the first place? The main
reason is to raise awareness about this topic and to get you in
the right state of mind for one of the important themes in the context of
modern Linux: containers. Don’t worry if you don’t get all of the details now;
we will come back to this topic throughout the book and specifically in <a data-type="xref" href="ch06.xhtml#running-apps">Chapter 6</a>, in which we discuss containers and their building blocks in greater detail.</p>
</div>

<p>You might have heard the saying that in Unix, and by extension Linux,
everything is a file. In the context of this book, we consider resources to be
anything that can be used to aid the execution of software. This includes
hardware and its abstractions (such as CPU and RAM, files), filesystems, hard disk
drives, solid-state drives (SSDs), processes, networking-related stuff like devices or routing tables,
and credentials representing users.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Not all resources in Linux are
files or represented through a file interface. However, there are systems out
there, such as <a href="https://oreil.ly/5DkY8">Plan 9</a>, that take this much further.</p>
</div>

<p>Let’s have a look at a concrete example of some Linux resources. First, we want
to query a global property (the Linux version) and then specific hardware information
about the CPUs in use (output edited to fit space):</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>cat</code><code> </code><code>/proc/version</code><code> </code><a class="co" id="co_introduction_to_linux_CO1-1" href="#callout_introduction_to_linux_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>Linux</code><code> </code><code>version</code><code> </code><code class="m">5</code><code>.4.0-81-generic</code><code> </code><code class="o">(</code><code>buildd@lgw01-amd64-051</code><code class="o">)</code><code>
</code><code class="o">(</code><code>gcc</code><code> </code><code>version</code><code> </code><code class="m">7</code><code>.5.0</code><code> </code><code class="o">(</code><code>Ubuntu</code><code> </code><code class="m">7</code><code>.5.0-3ubuntu1~18.04</code><code class="o">)</code><code class="o">)</code><code>
</code><code class="c1">#91~18.04.1-Ubuntu SMP Fri Jul 23 13:36:29 UTC 2021
</code><code>
</code><code>$</code><code> </code><code>cat</code><code> </code><code>/proc/cpuinfo</code><code> </code><code class="p">|</code><code> </code><code>grep</code><code> </code><code class="s2">"model name"</code><code> </code><a class="co" id="co_introduction_to_linux_CO1-2" href="#callout_introduction_to_linux_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>model</code><code> </code><code>name</code><code>      </code><code>:</code><code> </code><code>Intel</code><code> </code><code>Core</code><code> </code><code>Processor</code><code> </code><code class="o">(</code><code>Haswell,</code><code> </code><code>no</code><code> </code><code>TSX,</code><code> </code><code>IBRS</code><code class="o">)</code><code>
</code><code>model</code><code> </code><code>name</code><code>      </code><code>:</code><code> </code><code>Intel</code><code> </code><code>Core</code><code> </code><code>Processor</code><code> </code><code class="o">(</code><code>Haswell,</code><code> </code><code>no</code><code> </code><code>TSX,</code><code> </code><code>IBRS</code><code class="o">)</code><code>
</code><code>model</code><code> </code><code>name</code><code>      </code><code>:</code><code> </code><code>Intel</code><code> </code><code>Core</code><code> </code><code>Processor</code><code> </code><code class="o">(</code><code>Haswell,</code><code> </code><code>no</code><code> </code><code>TSX,</code><code> </code><code>IBRS</code><code class="o">)</code><code>
</code><code>model</code><code> </code><code>name</code><code>      </code><code>:</code><code> </code><code>Intel</code><code> </code><code>Core</code><code> </code><code>Processor</code><code> </code><code class="o">(</code><code>Haswell,</code><code> </code><code>no</code><code> </code><code>TSX,</code><code> </code><code>IBRS</code><code class="o">)</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_introduction_to_linux_CO1-1" href="#co_introduction_to_linux_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Print the Linux version.</p></dd>
<dt><a class="co" id="callout_introduction_to_linux_CO1-2" href="#co_introduction_to_linux_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Print CPU-related information, filtering for model.</p></dd>
</dl>

<p>With the preceding commands, we learned that this system has four Intel i7 cores at its
disposal. When you log in with a different user, would you expect to see the
same number of CPUs?</p>

<p>Let’s consider a different type of resource: files. For example, if the user <code>troy</code>
creates a file under <code>/tmp/myfile</code> with permission to do so
(<a data-type="xref" href="ch04.xhtml#permissions">“Permissions”</a>), would another user, <code>worf</code>, see the file or
even be able to write to it?</p>

<p>Or, take the case of a process, that is, a program in memory that has all the
necessary resources available to run, such as CPU and memory.<a data-type="indexterm" data-primary="PID (process id)" id="idm45805441339440"/><a data-type="indexterm" data-primary="process id (PID)" id="idm45805441338736"/> Linux identifies
a process using its <em>process ID</em>, or <code>PID</code> for short (<a data-type="xref" href="ch02.xhtml#kernel-process-management">“Process Management”</a>):</p>

<pre data-type="programlisting" data-code-language="shell"><code>$</code><code> </code><code>cat</code><code> </code><code>/proc/</code><code class="nv">$$</code><code>/status</code><code> </code><code class="p">|</code><code> </code><code>head</code><code> </code><code>-n6</code><code> </code><a class="co" id="co_introduction_to_linux_CO2-1" href="#callout_introduction_to_linux_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>Name:</code><code>   </code><code>bash</code><code>
</code><code>Umask:</code><code>  </code><code class="m">0002</code><code>
</code><code>State:</code><code>  </code><code>S</code><code> </code><code class="o">(</code><code>sleeping</code><code class="o">)</code><code>
</code><code>Tgid:</code><code>   </code><code class="m">2056</code><code>
</code><code>Ngid:</code><code>   </code><code class="m">0</code><code>
</code><code>Pid:</code><code>    </code><code class="m">2056</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_introduction_to_linux_CO2-1" href="#co_introduction_to_linux_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Print process status—that is, details about the current process—and limit
output to show only the first six lines.</p></dd>
</dl>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45805441279600">
<h5>What Is $$?</h5>
<p>You might have noticed the <code>$$</code> and wondered what this means. This is a special
variable that is referring to the current process (see <a data-type="xref" href="ch03.xhtml#shell-variables">“Variables”</a> for
details). Note that in the context of a shell, <code>$$</code> is the process ID of
the shell (such as bash) in which you typed the command.</p>
</div></aside>

<p>Can there be multiple processes with the same <code>PID</code> in Linux? What may sound
like a silly or useless question turns out to be the basis for containers
(see <a data-type="xref" href="ch06.xhtml#containers">“Containers”</a>). The answer is yes, there can be multiple processes
with the same <code>PID</code>, in different contexts called <a data-type="indexterm" data-primary="namespaces" id="idm45805441247424"/><em>namespaces</em> (see <a data-type="xref" href="ch06.xhtml#namespaces">“Linux Namespaces”</a>).
This happens, for example, in a containerized setup, such as when you’re running
your app in Docker or Kubernetes.</p>

<p>Every single process might think that it is special, having <code>PID 1</code>, which
in a more traditional setup is reserved for the root of the user space process
tree (see <a data-type="xref" href="ch06.xhtml#linux-boot">“The Linux Startup Process”</a> for more details).</p>

<p>What we can learn from these observations is that there can be a global view
on a given resource (two users see a file at the exact same location) as well
as a local or virtualized view, such as the process example. This raises the
question: is everything in Linux by default global? Spoiler: it’s not. Let’s
have a closer look.</p>

<p>Part of the illusion of having multiple users or processes running in parallel
is the (restricted) visibility onto resources. The way to provide a local
view on (certain supported) resources in Linux is via namespaces (see <a data-type="xref" href="ch06.xhtml#namespaces">“Linux Namespaces”</a>).</p>

<p><a data-type="indexterm" data-primary="isolation" id="idm45805441242320"/>A second, independent dimension is that of isolation. When I use the term
<em>isolation</em> here, I don’t necessarily qualify it—that is, I make no assumptions
about how well things are isolated. For example, one way to think about process
isolation is to restrict the memory consumption so that one process cannot
starve other processes. For example, I give your app 1 GB of RAM to use. If
it uses more, it gets
<a href="https://oreil.ly/kvk1u">out-of-memory</a>
killed. This provides a certain level of protection. In Linux we use a kernel
feature called <code>cgroups</code> to provide this kind of isolation, and in
<a data-type="xref" href="ch06.xhtml#cgroups">“Linux cgroups”</a> you will learn more about it.</p>

<p>On the other hand, a fully isolated environment gives the appearance that the
app is entirely on its own. For example, a virtual machine (VM; see also
<a data-type="xref" href="ch09.xhtml#virtual-machines">“Virtual Machines”</a>) can be used to provide you with full isolation.<a data-type="indexterm" data-startref="ix_ch01-asciidoc2" id="idm45805441238064"/><a data-type="indexterm" data-startref="ix_ch01-asciidoc1" id="idm45805441237456"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="A Ten-Thousand-Foot View of Linux"><div class="sect1" id="intro-10-view">
<h1>A Ten-Thousand-Foot View of Linux</h1>

<p><a data-type="indexterm" data-primary="Linux (generally)" data-secondary="high-level overview" id="idm45805441235712"/>Whoa, we went quite deep into the weeds already. Time to take a deep breath and
re-focus. In <a data-type="xref" href="#fig-10k-view">Figure 1-1</a>, I’ve tried to provide you with a high-level
overview of the Linux operating system, mapping it to the book chapters.</p>

<figure><div id="fig-10k-view" class="figure">
<img src="Images/lmlx_0101.png" alt="lmlx 0101" width="600" height="396"/>
<h6><span class="label">Figure 1-1. </span>Mapping the Linux operating system to book chapters</h6>
</div></figure>

<p>At its core, any Linux distro has the kernel, providing the API that everything else
builds on. The three core topics of files, networking, and observability follow
you everywhere, and you can consider them the most basic building blocks above
the kernel. From a pure usage perspective, you will soon learn that you will most often be dealing with the shell
(Where is the output file for this app?) and things related to access control (Why
does this app crash? Ah, the directory is read-only, doh!).</p>

<p class="pagebreak-after">As an aside: I’ve collected some interesting topics, from virtual machines
to modern distros, in <a data-type="xref" href="ch09.xhtml#advanced">Chapter 9</a>. I call these topics “advanced” mainly because I consider
them optional. That is, you could get away
without learning them. But if you really, really, really want to benefit
from the full power that modern Linux can provide you, I strongly recommend
that you read <a data-type="xref" href="ch09.xhtml#advanced">Chapter 9</a>. I suppose it goes without saying that, by design,
the rest of the book—that is <a data-type="xref" href="ch02.xhtml#kernel">Chapter 2</a> to <a data-type="xref" href="ch08.xhtml#observability">Chapter 8</a>—are essential chapters
you should most definitely study and apply the content as you go.</p>
<aside data-type="sidebar" epub:type="sidebar" class="less_space"><div class="sidebar" id="def-posix">
<h5>Portable Operating System Interface</h5>
<p><a data-type="indexterm" data-primary="POSIX (Portable Operating System Interface)" id="idm45805441226176"/>We will come across the term <em>POSIX</em>, short for <em>Portable Operating System Interface</em>,
every now and then in this book. Formally, POSIX is an IEEE standard to
define service interfaces for UNIX operating systems. The motivation was to
provide portability between different implementations. So, if you read things
like “POSIX-compliant,” think of a set of formal specifications that are especially
relevant in official procurement context and less so in everyday usage.</p>

<p>Linux was built to be POSIX-compliant as well as to be compliant with
the UNIX System V Interface Definition (SVID), which gave it the flavor of
old-time AT&amp;T UNIX systems, as opposed to Berkeley Software Distribution
(BSD)-style systems.</p>

<p>If you want to learn more about POSIX, check out
<a href="https://oreil.ly/DO04h">“POSIX Abstractions
in Modern Operating Systems: The Old, the New, and the Missing”</a>, which provides
a great introduction and comments on uptake and challenges around this topic.</p>
</div></aside>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45805441223040">
<h1>Conclusion</h1>

<p>When we call something “modern” in the context of this book, we mean using
Linux in modern environments, including phones, data centers (of public cloud providers),
and embedded systems such as a Raspberry Pi.</p>

<p>In this chapter, I shared a high-level version of the Linux backstory. We
discussed the role of an operating  system in general—to abstract the underlying
hardware and provide a set of basic functions
such as process, memory, file, and network management to applications—and
how Linux goes about this task, specifically regarding visibility of resources.</p>

<p>The following resources will help you continue getting up to speed as well as dive deeper
into concepts discussed in this chapter<a data-type="indexterm" data-primary="applications" data-secondary="managing" data-see="package managers" id="idm45805441221024"/><a data-type="indexterm" data-primary="commands, modern" data-see="modern commands" id="idm45805441219936"/><a data-type="indexterm" data-primary="distros" data-secondary="modern" data-see="modern distros" id="idm45805441219088"/><a data-type="indexterm" data-primary="Linux (generally)" data-secondary="kernel" data-see="kernel" id="idm45805441218000"/><a data-type="indexterm" data-primary="Linux (generally)" data-secondary="startup process" data-see="boot process" id="idm45805441216912"/><a data-type="indexterm" data-primary="shell" data-secondary="scripting" data-see="scripting" id="idm45805441215824"/><a data-type="indexterm" data-primary="shell scripting" data-see="scripting" id="idm45805441214736"/>:</p>
<dl>
<dt>O’Reilly titles</dt>
<dd>

<ul>
<li>
<p><a class="orm:hideurl" href="https://oreil.ly/4Y90O"><em>Linux Cookbook</em></a> by Carla Schroder</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://oreil.ly/aJYyj"><em>Understanding the Linux Kernel</em></a> by Daniel P. Bovet and Marco Cesati</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://oreil.ly/nWCch"><em>Efficient Linux at the Command Line</em></a> by Daniel J. Barrett</p>
</li>
<li>
<p><a class="orm:hideurl" href="https://oreil.ly/fh85i"><em>Linux System Programming</em></a> by Robert Love</p>
</li>
</ul>
</dd>
</dl>
<dl class="pagebreak-before">
<dt class="less_space">Other resources</dt>
<dd>

<ul>
<li>
<p><a href="https://oreil.ly/hS0G0">Advanced Programming in the UNIX Environment</a>
is a complete course that offers introductory material and
hands-on exercises.</p>
</li>
<li>
<p><a href="https://oreil.ly/MlQ0J">“The Birth of UNIX”</a>
with Brian Kernighan is a great resource for learning about Linux’s legacy and provides
context for a lot of the original UNIX concepts.</p>
</li>
</ul>
</dd>
</dl>

<p>And now, without further ado: let’s start our journey into modern Linux with the
core, erm, kernel, of the matter!</p>
</div></section>







</div></section></div></body></html>