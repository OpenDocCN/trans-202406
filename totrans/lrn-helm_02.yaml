- en: Chapter 2\. Using Helm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 使用 Helm
- en: Helm provides a command-line tool, named `helm`, that makes available all the
    features necessary for working with Helm charts. In this chapter, we will discover
    the primary features of the `helm` client. Along the way, we’ll learn how Helm
    interacts with Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了一个命令行工具，名为 `helm`，可以使用所有与 Helm charts 相关的主要功能。在本章中，我们将探索 `helm` 客户端的主要功能。在此过程中，我们将了解
    Helm 如何与 Kubernetes 交互。
- en: We will start by looking at how to install and configure Helm, and work our
    way through the main command groups in Helm. Then we will cover finding and learning
    about packages, and how to install, upgrade, and delete them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看如何安装和配置 Helm，并逐步学习 Helm 的主要命令组。然后，我们将介绍如何查找和学习软件包，以及如何安装、升级和删除它们。
- en: Installing and Configuring the Helm Client
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和配置 Helm 客户端
- en: Helm provides a single command-line client that is capable of performing all
    of the main Helm tasks. This client is, appropriately enough, named `helm`. While
    there are many other tools that can work with Helm charts, this one is the official
    general-purpose tool maintained by the Helm core maintainers, and it is the subject
    of this chapter as well as the next.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了一个能够执行所有主要 Helm 任务的单一命令行客户端。这个客户端名为 `helm`。虽然有许多其他工具可以处理 Helm charts，但这是由
    Helm 核心维护者维护的官方通用工具，也是本章和下一章的主题。
- en: The `helm` client is written in a programming language called Go. Unlike Python,
    JavaScript, or Ruby, Go is a compiled language. Once a Go program is compiled,
    you do not need any of the Go tools to run or otherwise work with the binary.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm` 客户端是用一种名为 Go 的编程语言编写的。与 Python、JavaScript 或 Ruby 不同，Go 是一种编译语言。一旦 Go
    程序编译完成，您就不需要任何 Go 工具来运行或处理二进制文件。'
- en: So we will first cover downloading and installing the static binary, and then
    we will briefly introduce the process for fetching and compiling from the Go source
    code, should you so desire.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将首先介绍下载和安装静态二进制文件的过程，然后简要介绍如果您希望的话，可以获取并从 Go 源代码编译的过程。
- en: Installing a Prebuilt Binary
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装预编译二进制文件
- en: Each time the Helm maintainers issue a new release of `helm`, the project provides
    new signed binary builds of `helm` for a number of common operating systems and
    architectures. At the time of this writing, prebuilt versions of Helm are available
    for Linux, Windows, and macOS on architectures ranging from 64-bit Intel/AMD to
    ARM, to s390 and PPC. This means you can run Helm on anything from a Raspberry
    Pi to a supercomputer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每次 Helm 维护者发布新版本的 `helm` 时，项目都会提供针对多个常见操作系统和架构的新签名二进制版本的构建。截至撰写本文时，Helm 的预构建版本适用于从
    64 位 Intel/AMD 到 ARM、s390 和 PPC 的 Linux、Windows 和 macOS 等各种架构。这意味着您可以在从树莓派到超级计算机的任何设备上运行
    Helm。
- en: The definitive list of Helm releases is at [the Helm release page](https://oreil.ly/L_My5).
    The release page will show a chronological list of releases, with the latest release
    at the top.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 发行版的详尽列表位于[发布页面](https://oreil.ly/L_My5)。发布页面将显示按时间顺序排列的发行版列表，最新发行版位于顶部。
- en: A note on Helm version numbers
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Helm 版本号说明
- en: Until November 2020, two different major versions of Helm were actively maintained.
    The current stable major version of Helm is version 3\. When you visit the Helm
    download pages, you may see both versions available for download. Because the
    versions are chronologically listed, it is even possible that a Helm 2 release
    will be newer than the latest Helm 3 release. You should use Helm 3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 2020 年 11 月，仍在积极维护两个不同的 Helm 主要版本。当前稳定的 Helm 主要版本是版本 3。当您访问 Helm 下载页面时，您可能会看到可以下载的两个版本。由于版本按时间顺序列出，甚至可能会出现
    Helm 2 的版本比最新的 Helm 3 版本更新的情况。您应该使用 Helm 3。
- en: Helm follows a versioning convention known as [Semantic Versioning](https://semver.org)
    (SemVer). In Semantic Versioning, the version number conveys meaning about what
    you can expect in the release. Because Helm follows this specification, users
    can expect certain things out of releases simply by carefully reading the version
    number.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 遵循称为[语义化版本](https://semver.org)（SemVer）的版本控制约定。在语义化版本中，版本号传达了关于发布版中可期待内容的含义。由于
    Helm 遵循此规范，用户可以仅仔细阅读版本号即可对发行版期望有所了解。
- en: 'At its core, a semantic version has three numerical components and an optional
    *stability marker* (for alphas, betas, and release candidates). Here are some
    examples:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，语义版本具有三个数字组件和一个可选的*稳定性标记*（用于 alpha、beta 和候选发布版）。以下是一些示例：
- en: '`v1.0.0`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v1.0.0`'
- en: '`v3.3.2`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v3.3.2`'
- en: '`v2.4.22-alpha.2`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`v2.4.22-alpha.2`'
- en: Let’s talk about the numerical components first.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论数值组件。
- en: 'We often generalize this format to talk about `X.Y.Z`, where `X` is a *major
    version*, `Y` is a *minor version* and `Z` is a *patch release*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常将这种格式概括为 `X.Y.Z`，其中 `X` 是 *主版本*，`Y` 是 *次版本*，`Z` 是 *补丁发布*：
- en: The major release number tends to be incremented infrequently. It indicates
    that major changes have been made to Helm, and that some of those changes may
    break compatibility with previous versions. The difference between Helm 2 and
    Helm 3 is substantial, and there is work necessary to migrate between the versions.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要的版本号往往不经常增加。它表示 Helm 发生了重大变化，并且其中一些变化可能会破坏与旧版本的兼容性。Helm 2 和 Helm 3 之间的差别很大，需要进行版本迁移的工作。
- en: 'The minor release number indicates feature additions. The difference between
    3.2.0 and 3.3.0 might be that a few small new features were added. However, there
    are no *breaking changes* between versions. (With one caveat: a security fix might
    necessitate a breaking change, but we announce boldly when that is the case.)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次要版本号表示功能添加。例如 3.2.0 和 3.3.0 之间的区别可能是增加了一些小的新功能。但是，版本之间没有 *重大变更*。（有一个例外：安全修复可能需要进行重大变更，但我们会明确宣布这种情况。）
- en: The patch release number indicates that *only* backward compatible bug fixes
    have been made between this release and the last one. It is always recommended
    to stay at the latest patch release.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 补丁版本号表示在此版本与上一个版本之间仅进行了向后兼容的错误修复。建议始终保持在最新的补丁版本。
- en: When you see a release with a stability marker, like `alpha.1`, `beta.4`, or
    `rc.2`, appended to the release number, that means the release is considered to
    be a pre-release, and is not ready for mainstream production usage. In particular,
    Helm frequently issues *release candidates* before a major or minor update. These
    give the community a chance to give us some feedback on stability, compatibility,
    and new features before we issue a final release.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当您看到一个带有稳定性标记的发布版本，例如 `alpha.1`，`beta.4` 或 `rc.2`，附加到发布版本号时，这意味着该版本被视为预发布版本，尚未准备好用于主流生产环境。特别是在主要或次要更新之前，Helm
    经常发布 *候选版本*。这给社区一个机会，在正式发布之前就稳定性、兼容性和新功能提供反馈。
- en: With this in mind, we are ready to proceed with the actual installation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个理解，我们准备进行实际安装。
- en: Downloading the binary
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载二进制文件
- en: The easiest way to install Helm from the repository is to simply go to the [releases
    page](https://oreil.ly/L_My5) and download the latest Helm 3 version.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从仓库安装 Helm 的最简单方法是直接访问 [发布页面](https://oreil.ly/L_My5)，并下载最新的 Helm 3 版本。
- en: On Windows, the download file is a ZIP archive containing a *README.md* text
    file, a *LICENSE* text file, and *helm.exe*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，下载文件是一个 ZIP 存档，包含一个 *README.md* 文本文件，一个 *LICENSE* 文本文件和 *helm.exe*。
- en: On macOS and Linux, the download will be in a gzipped tar archive (`.tar.gz`)
    that can be extracted with the `tar -zxf` command. Like the Windows version, it
    will contain a *README.md* text file, a *LICENSE* text file, and the `helm` binary.
    If you are using Windows Subsystem for Linux (WSL), you should install the Linux
    AMD64 version into your WSL instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 Linux 上，下载将以一个可以用 `tar -zxf` 命令解压的 gzip 压缩的 tar 存档（`.tar.gz`）形式存在。与
    Windows 版本类似，它将包含一个 *README.md* 文本文件，一个 *LICENSE* 文本文件和 `helm` 二进制文件。如果您正在使用 Windows
    Subsystem for Linux（WSL），您应该将 Linux AMD64 版本安装到您的 WSL 实例中。
- en: Regardless of which operating system you use, the binary is the only file you
    need to run Helm, and you can put it wherever you prefer on your system. It should
    be pre-marked as an executable, but on rare occasions in UNIX-like environments,
    you may also need to run the command `chmod helm +x` to set Helm to be an executable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您使用哪个操作系统，二进制文件是运行 Helm 所需的唯一文件，您可以将其放在系统上任何您喜欢的位置。它应该被预先标记为可执行文件，但在类 UNIX
    环境中，您偶尔可能需要运行命令 `chmod helm +x` 来设置 Helm 为可执行文件。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When installing with package managers like Homebrew (macOS), Snap (Linux), or
    Chocolatey (Windows), `helm` will be installed in a standard location and be made
    immediately available to you via the command line.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用像 Homebrew（macOS）、Snap（Linux）或 Chocolatey（Windows）这样的软件包管理器安装时，`helm` 将安装在标准位置，并立即通过命令行对您可用。
- en: Once you have `helm` installed, you should be able to run the command `helm
    help` and see the Helm help text.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完毕 `helm` 后，您应该能够运行 `helm help` 命令并查看 Helm 帮助文本。
- en: Using the get script to install
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用获取脚本进行安装
- en: On macOS and Linux, you may prefer to run a shell script that will determine
    which version of Helm to install and do it automatically for you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 Linux 上，您可能更喜欢运行一个 shell 脚本，它会确定要安装的 Helm 版本，并自动完成安装。
- en: 'The usual sequence of commands for installing this way is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式安装的常规命令序列如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding commands fetch the latest version of the `get_helm.sh` script,
    and then use that to find and install the latest version of Helm 3.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会获取 `get_helm.sh` 脚本的最新版本，然后使用它来查找并安装 Helm 3 的最新版本。
- en: For systems that automatically install Helm, such as continuous integration
    (CI) systems, we recommend using this method if it is important to always have
    the latest Helm version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自动安装 Helm 的系统，例如持续集成（CI）系统，如果始终拥有最新的 Helm 版本很重要，我们建议使用这种方法。
- en: Guidance on Building from Source
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建源代码的指南
- en: Unless you are already familiar with Go development, building Helm from source
    can be a daunting task. You will need a version of the `make` command. Because
    `Makefile`-style build scripts do not follow a single standard, not all versions
    of `make` will work to build Helm. Gnu Make, the one most frequently used on Linux
    and Mac, is the one most Helm core developers use, so it is a safe bet. You will
    also need the `gcc` compiler and the entire Go toolchain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您已经熟悉 Go 开发，否则从源代码构建 Helm 可能会是一项艰巨的任务。您需要一个版本的 `make` 命令。因为 `Makefile` 风格的构建脚本没有遵循单一标准，不是所有版本的
    `make` 都能用于构建 Helm。GNU Make 是在 Linux 和 Mac 上最常用的，也是 Helm 核心开发人员最常用的，因此是一个安全的选择。您还需要
    `gcc` 编译器和完整的 Go 工具链。
- en: In addition to these, Helm needs several auxilliary tools. Fortunately, when
    you run `make` the first time, it will attempt to install any additional tools
    that are missing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Helm 还需要几个辅助工具。幸运的是，当您第一次运行 `make` 时，它将尝试安装任何缺失的附加工具。
- en: While they are not strictly necessary, you will probably also want the `git`
    tool and the `kubectl` command. The `git` tool will allow you to work directly
    with the Helm source code repository instead of downloading source code bundles.
    `kubectl`, of course, is for interacting with your Kubernetes cluster. While that’s
    not necessary for *building* Helm, it’s certainly necessary when checking to see
    whether Helm is doing what you want it to do.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们并非绝对必需，但您可能还需要 `git` 工具和 `kubectl` 命令。`git` 工具允许您直接使用 Helm 源代码仓库，而不是下载源代码包。当然，`kubectl`
    是用于与您的 Kubernetes 集群交互的。虽然这不是 *构建* Helm 所必需的，但在检查 Helm 是否按您希望的方式运行时，这无疑是必需的。
- en: Once you have the tools installed and configured, you can simply change directories
    in the folder that contains Helm’s source code (the directory with the *README.md*
    and Makefile files) and run `make build`. The first time you run this command,
    it will take at least several minutes. The build system must fetch lots of dependencies,
    including much of the Kubernetes source code, and compile it all.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装和配置好工具，您只需切换到包含 Helm 源代码的文件夹（即包含 *README.md* 和 Makefile 文件的目录），然后运行 `make
    build`。第一次运行此命令时，至少需要几分钟。构建系统必须获取大量依赖项，包括 Kubernetes 的大部分源代码，并对其进行编译。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Compiling Helm for the first time can be daunting, especially if you are new
    to the Go programming language. Kubernetes is a sophisticated platform, and thus
    the Helm source code is large and difficult to build. Plan on spending at least
    an hour or two to get a fresh environment prepared to install Helm.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 Helm 初次可能会令人望而却步，尤其是对于不熟悉 Go 编程语言的人来说。 Kubernetes 是一个复杂的平台，因此 Helm 的源代码庞大且难以构建。计划至少花上一两个小时准备一个新的环境来安装
    Helm。
- en: To verify that Helm is functioning correctly (especially if you have modified
    the source code), you can run `make test`. This will build the code, run a variety
    of checkers and linters, and then run the unit tests for Helm. If you plan on
    contributing any changes to Helm, this command *must* pass before Helm’s core
    maintainers will even look at your requested change.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 Helm 是否正常运行（特别是如果您修改了源代码），可以运行 `make test`。这将构建代码，运行各种检查器和 linter，并运行 Helm
    的单元测试。如果您计划向 Helm 的核心维护者提交任何更改请求，在查看您请求的更改之前，此命令 *必须* 通过。
- en: When Helm is compiled, it will be located alongside the source code in a subdirectory
    called *bin/*. It will not automatically be added to your executable path, so
    to execute the version you just built, you may need to specify the relative or
    exact path (e.g., *./bin/helm* or *$GOPATH/src/helm.sh/helm/bin/helm*).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Helm 编译完成时，它将位于源代码旁边的一个名为 *bin/* 的子目录中。它不会自动添加到可执行路径中，因此要执行您刚刚构建的版本，您可能需要指定相对或确切的路径（例如，*./bin/helm*
    或 *$GOPATH/src/helm.sh/helm/bin/helm*）。
- en: If the command `helm version` correctly executes, you can be assured that you
    correctly compiled Helm.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令 `helm version` 正确执行，您可以放心地确认您已正确编译 Helm。
- en: From here, you can follow the detailed [Developer Guide](https://oreil.ly/X9-Ii)
    to learn more. As always, if you run into problems, the `helm-users` channel on
    the Kubernetes Slack server is a great place to ask for help.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以按照详细的[开发人员指南](https://oreil.ly/X9-Ii)了解更多信息。和往常一样，如果遇到问题，可以在 Kubernetes
    Slack 服务器的 `helm-users` 频道中寻求帮助。
- en: Working with Kubernetes Clusters
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 集群
- en: Helm interacts directly with the Kubernetes API server. For that reason, Helm
    needs to be able to connect to a Kubernetes cluster. Helm attempts to do this
    automatically by reading the same configuration files used by `kubectl` (the main
    Kubernetes command-line client).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 与 Kubernetes API 服务器直接交互。因此，Helm 需要能够连接到 Kubernetes 集群。Helm 试图通过读取 `kubectl`（主要的
    Kubernetes 命令行客户端）使用的相同配置文件来自动执行此操作。
- en: Helm will try to find this information by reading the environment variable *$KUBECONFIG*.
    If that is not set, it will look in the same default locations that `kubectl`
    looks in (for example, *$HOME/.kube/config* on UNIX, Linux, and macOS).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 将尝试通过读取环境变量 *$KUBECONFIG* 来查找这些信息。如果未设置，它将在与 `kubectl` 相同的默认位置查找（例如，在 UNIX、Linux
    和 macOS 上为 *$HOME/.kube/config*）。
- en: You can also override these settings with environment variables (`HELM_KUBECONTEXT`)
    and command-line flags (`--kube-context`). You can see a list of environment variables
    and flags by running `helm help`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过环境变量（`HELM_KUBECONTEXT`）和命令行标志（`--kube-context`）覆盖这些设置。可以通过运行 `helm help`
    查看环境变量和标志的列表。
- en: The Helm maintainers recommend using `kubectl` to manage your Kubernetes credentials
    and letting Helm merely autodetect these settings. If you have not yet installed
    `kubectl`, the best place to start is with the [official Kubernetes installation
    documentation](https://oreil.ly/pHZIh).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 的维护者建议使用 `kubectl` 管理您的 Kubernetes 凭据，并让 Helm 仅仅自动检测这些设置。如果您尚未安装 `kubectl`，开始的最佳方法是参考[官方
    Kubernetes 安装文档](https://oreil.ly/pHZIh)。
- en: Getting Started with Helm
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 Helm
- en: Whether you built Helm from source or installed using one of the aforementioned
    methods, at this point you should have the `helm` command available on your system.
    From here on, we will assume that Helm can be executed with the command `helm`
    (as opposed to a full or relative path, as discussed in the previous section).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是从源代码构建 Helm 还是使用上述方法之一进行安装，在这一点上您应该在系统上拥有 `helm` 命令可用。从这里开始，我们将假设可以使用 `helm`
    命令执行 Helm（与之前部分讨论的完整或相对路径相反）。
- en: 'In what follows, we are going to take a look at the most common workflow for
    starting out with Helm:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看 Helm 最常见的启动工作流程：
- en: Add a chart repository.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个图表存储库。
- en: Find a chart to install.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找要安装的图表。
- en: Install a Helm chart.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Helm 图表。
- en: See the list of what is installed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看已安装的内容列表。
- en: Upgrade your installation.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 升级您的安装。
- en: Delete the installation.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除安装。
- en: Then, in the next chapter we will dive into some of the additional features
    of Helm and in so doing learn more about how Helm works.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在下一章中，我们将深入探讨 Helm 的一些附加功能，并通过这样做了解更多有关 Helm 如何工作的信息。
- en: Adding a Chart Repository
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加图表存储库。
- en: Chart repositories are a topic in their own right, and in [Chapter 7](ch07.xhtml#chart_repositories)
    we will examine them in detail. But anyone using Helm must know a few basics about
    chart repositories.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图表存储库是一个独立的主题，在第[7 章](ch07.xhtml#chart_repositories)中我们将详细讨论它们。但任何使用 Helm 的人都必须了解有关图表存储库的一些基础知识。
- en: A Helm chart is an *individual package* that can be installed into your Kubernetes
    cluster. During chart development, you will often just work with a chart that
    is stored on your local filesystem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表是可以安装到您的 Kubernetes 集群中的*独立包*。在图表开发过程中，您通常只需使用存储在本地文件系统上的一个图表来工作。
- en: But when it comes to sharing charts, Helm describes a standard format for indexing
    and sharing information about Helm charts. A Helm *chart repository* is simply
    a set of files, reachable over the network, that conforms to the Helm specification
    for indexing packages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当涉及到共享图表时，Helm 描述了一种标准格式，用于索引和共享有关 Helm 图表的信息。一个 Helm *图表仓库* 简单地是一组文件，通过网络可访问，符合
    Helm 规范以索引包。
- en: Note
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Helm 3 introduced an experimental feature for storing Helm charts in a different
    kind of repository: Open Container Initiative (OCI) registries (sometimes called
    Docker registries). In this backend, a Helm chart can be stored alongside Docker
    images. While this feature is not yet broadly supported, it may become the future
    of Helm package storage. This is discussed more in [Chapter 7](ch07.xhtml#chart_repositories).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 3 引入了一个实验性功能，用于将 Helm 图表存储在不同类型的仓库中：Open Container Initiative (OCI) 注册表（有时被称为
    Docker 注册表）。在这个后端，一个 Helm 图表可以与 Docker 镜像并存储。虽然这个功能目前支持不广泛，但它可能成为 Helm 包存储的未来。这在
    [第7章](ch07.xhtml#chart_repositories) 中更详细地讨论。
- en: There are many—perhaps thousands of—chart repositories on the internet. The
    easiest way to find the popular repositories is to use your web browser to navigate
    to [the Artifact Hub](https://artifacthub.io). There you will find thousands of
    Helm charts, each hosted on an appropriate repository.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多——也许成千上万——图表仓库。找到流行的仓库最简单的方法是使用你的网络浏览器导航到 [Artifact Hub](https://artifacthub.io)。在那里，你将找到成千上万的
    Helm 图表，每个都托管在适当的仓库上。
- en: To get started, we will install the popular [Drupal content management system](https://www.drupal.org).
    This makes a good example chart because it exercises many of Kubernetes’ types,
    including `Deployment`s, `Service`s, `Ingress`, and `ConfigMap`s.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们将安装流行的 [Drupal 内容管理系统](https://www.drupal.org)。这是一个很好的示例图表，因为它涵盖了许多 Kubernetes
    类型，包括 `Deployment`、`Service`、`Ingress` 和 `ConfigMap`。
- en: Helm 2 came with a Helm repository installed by default. The `stable` chart
    repository was at one time the official source of production-ready Helm charts.
    But we realized that centralizing the charts into one repository was overly taxing
    to a small group of maintainers and frustrating for chart contributors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 2 默认安装了一个 Helm 仓库。`stable` 图表仓库曾一度是生产准备好的 Helm 图表的官方来源。但我们意识到将图表集中到一个仓库对少数维护者来说过于繁重，并且对图表贡献者来说是令人沮丧的。
- en: In Helm 3, there is no default repository. Users are encouraged to use the Artifact
    Hub to find what they are looking for and then add their preferred repositories.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Helm 3 中，没有默认仓库。鼓励用户使用 Artifact Hub 找到他们需要的内容，然后添加他们偏好的仓库。
- en: 'Drupal’s Helm chart is located in one of the most well-curated chart repositories
    available: Bitnami’s official Helm charts. You can take a look at the Artifact
    Hub’s [entry for the Drupal chart](https://oreil.ly/baxxf) for more information.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 的 Helm 图表位于最完善的图表仓库之一：Bitnami 的官方 Helm 图表中。你可以查看 Artifact Hub 上的 [Drupal
    图表的条目](https://oreil.ly/baxxf) 以获取更多信息。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A handful of Bitnami developers were among the core contributors who designed
    the Helm repository system. They have contributed to the establishment of Helm’s
    best practices for chart development and have written many of the most widely
    used charts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 小部分 Bitnami 开发人员是设计 Helm 仓库系统核心贡献者之一。他们为图表开发建立了 Helm 的最佳实践，并编写了许多被广泛使用的图表。
- en: 'Adding a Helm chart is done with the `helm repo add` command. Several Helm
    repository commands are grouped under the `helm repo` command group:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 添加 Helm 图表可以使用 `helm repo add` 命令完成。几个 Helm 仓库命令被分组在 `helm repo` 命令组下：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `helm repo add` command will add a repository named `bitnami` that points
    to the URL *[*https://charts.bitnami.com/bitnami*](https://charts.bitnami.com/bitnami)*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm repo add` 命令将添加一个名为 `bitnami` 的仓库，指向网址 [*https://charts.bitnami.com/bitnami*](https://charts.bitnami.com/bitnami)。'
- en: 'Now we can verify that the Bitnami repository exists by running a second `repo`
    command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行第二个 `repo` 命令来验证 Bitnami 仓库是否存在。
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command shows us all of the repositories installed for Helm. Right now,
    we see only the Bitnami repository that we just added.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令显示了所有安装的 Helm 仓库。现在，我们只看到刚刚添加的 Bitnami 仓库。
- en: Once we have added a repository, its index will be locally cached until we next
    update it (see [Chapter 7](ch07.xhtml#chart_repositories)). And one important
    thing that we can now do is search the repository.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了一个仓库，其索引将被本地缓存，直到我们下次更新它（参见 [第7章](ch07.xhtml#chart_repositories)）。现在我们能做的一件重要的事情是搜索该仓库。
- en: Searching a Chart Repository
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索图表仓库
- en: Although we know, having looked at the Artifact Hub, that the Drupal chart exists
    in this repository, it is still useful to search for it from the command line.
    Oftentimes, searching is a useful way to find not only what charts can be installed,
    but what versions are available.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们知道，在 Artifact Hub 上查看过 Drupal 图表存在于此存储库中，但仍然有必要从命令行搜索它。通常情况下，搜索不仅是查找可以安装的图表的有用方式，还可以查找可用的版本。
- en: 'To begin, let’s search for the Drupal chart:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们搜索Drupal图表：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We did a simple search for the term *drupal*. Helm will search not just the
    package names, but also other fields like labels and descriptions. Thus, we could
    search for *content* and see Drupal listed there because it is a content management
    system:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单搜索了术语*drupal*。Helm 不仅会搜索包名称，还会搜索标签和描述等其他字段。因此，我们可以搜索*content*，看到Drupal因为它是内容管理系统而被列出：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While Drupal is the first result, note that there are a variety of other charts
    that contain the word *content* somewhere in the descriptive text.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Drupal 是第一个结果，但请注意还有许多其他图表在描述文本中包含*content*一词。
- en: 'By default, Helm tries to install the latest stable release of a chart, but
    you can override this behavior and install a specific verison of a chart. Thus
    it is often useful to see not just the summary info for a chart, but exactly which
    versions exist for a chart:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Helm 尝试安装图表的最新稳定版本，但您可以覆盖此行为并安装特定版本的图表。因此，查看图表的摘要信息以及确切的图表版本通常非常有用：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are several dozen versions of the Drupal chart. The preceding example
    has been truncated to just show the top few versions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Drupal 图表有几十个版本。前面的示例已经被截断，仅显示了前几个顶级版本。
- en: Chart and App Versions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表和应用版本
- en: A *chart version* is the version of the Helm chart. The *app version* is the
    version of the application packaged in the chart. Helm uses the chart version
    to make versioning decisions, such as which package is newest. As we can see in
    the preceding example, multiple chart versions may contain the same app version.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*图表版本*是Helm图表的版本。*应用程序版本*是打包在图表中的应用程序的版本。Helm 使用图表版本来做出版本决策，例如哪个包是最新的。正如我们在前面的示例中看到的，多个图表版本可能包含相同的应用程序版本。'
- en: Installing a Package
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装一个包
- en: In the next chapter, we will dive deeply into the details of how package installation
    works in Helm. In this section, though, we will look at the basic mechanics of
    installing a Helm chart.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨Helm中包安装的工作原理。不过，在本节中，我们将查看安装Helm图表的基本机制。
- en: 'At very minimum, installing a chart in Helm requires just two pieces of information:
    the name of the installation and the chart you want to install.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Helm中，至少需要两个信息来安装图表：安装名称和您想安装的图表。
- en: Recall that in the previous chapter we distinguished between an *installation*
    and a *chart*. This is an important distinction during installation and upgrading.
    In an operating system package manager, we may request that it install a piece
    of software. But it is extremely rare that we need to install the same exact package
    multiple times on an operating system. A Kubernetes cluster is different. It makes
    complete sense in Kubernetes to say “I want to install a MySQL database for Application
    A, and a second MySQL database for Application B.” Even if the two databases are
    exactly the same version and have the same configuration, in order to appropriately
    manage our applications, we may desire to have two instances running.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在上一章中，我们区分了*安装*和*图表*。这在安装和升级过程中是一个重要的区别。在操作系统包管理器中，我们可能请求安装某个软件包。但在操作系统上几乎不会需要多次安装完全相同的软件包。Kubernetes
    集群则不同。在 Kubernetes 中说“我想为应用程序 A 安装一个 MySQL 数据库，并为应用程序 B 安装第二个 MySQL 数据库”是完全有道理的。即使两个数据库是完全相同版本并且具有相同的配置，为了适当地管理我们的应用程序，我们可能希望运行两个实例。
- en: 'Therefore, Helm needs a way to distinguish between the different instances
    of the same chart. So an *installation* of a chart is a specific instance of the
    chart. One chart may have many installations. When we run the `helm install` command,
    we need to give it an installation name as well as the chart name. So the most
    basic installation command looks something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Helm 需要一种方法来区分同一个图表的不同实例。因此，一个图表的*安装*是该图表的特定实例。一个图表可能有多个安装。当我们运行`helm install`命令时，我们需要给出一个安装名称以及图表名称。因此，最基本的安装命令看起来像这样：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding will create an instance of the `bitnami/drupal` chart, and will
    name this instance `mysite`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前将创建一个`bitnami/drupal`图表的实例，并将此实例命名为`mysite`。
- en: As the install command runs, it will return a considerable amount of information,
    including user-facing instructions about getting started with Drupal.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装命令运行时，它将返回大量信息，包括有关如何开始使用 Drupal 的用户界面说明。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In future examples of `helm install`, we will omit the returned output for the
    sake of brevity. However, when using Helm, you will see that output for each installation.
    In the next chapter, we will also see how to view that output again with the `helm
    get` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后的`helm install`示例中，出于简洁起见，我们将省略返回的输出。但是，在使用 Helm 时，您将看到每个安装的输出。在下一章中，我们还将看到如何使用`helm
    get`命令再次查看该输出。
- en: 'At this point, there is now an instance named `mysite` in the cluster. If we
    tried to rerun the preceding command, we wouldn’t get a second instance. Instead,
    we would get an error because the name `mysite` has already been used:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，集群中现在有一个名为`mysite`的实例。如果我们尝试重新运行前面的命令，我们将不会得到第二个实例。相反，我们会因为名称`mysite`已被使用而收到错误消息：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One further clarification is in order. In Helm 2, instance names were cluster-wide.
    You could only have an instance named `mysite` once *per cluster*. In Helm 3,
    naming has been changed. Now instance names are scoped to Kubernetes namespaces.
    We could install two instances named `mysite` as long as they each lived in a
    different namespace.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要进一步澄清一点。在 Helm 2 中，实例名称是集群范围的。您只能在*每个集群*中有一个名为`mysite`的实例。在 Helm 3 中，命名已更改。现在实例名称限定在
    Kubernetes 命名空间内。只要它们分别位于不同的命名空间中，我们可以安装两个名为`mysite`的实例。
- en: 'For example, the following is perfectly legal in Helm 3, though it would have
    generated a fatal error in Helm 2:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Helm 3 中，以下操作是完全合法的，尽管在 Helm 2 中会生成致命错误：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will install one Drupal site named `mysite` in the `first` namespace, and
    an identically configured instance named `mysite` in the `second` namespace. This
    might seem confusing at first, but it becomes clearer when we think about a namespace
    as a *prefix on a name*. In that sense, we have a site named “first mysite” and
    another named “second mysite.”
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`first`命名空间中安装一个名为`mysite`的 Drupal 站点，并在`second`命名空间中安装一个配置相同的实例，也命名为`mysite`。起初可能会感到困惑，但当我们将命名空间视为名称的*前缀*时，情况就变得更清晰了。在这种情况下，我们有一个名为“first
    mysite”的站点和另一个名为“second mysite”的站点。
- en: Using Namespace Flags Throughout Helm
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Helm 中始终使用命名空间标志
- en: When working with namespaces and Helm, you can use the `--namespace` or `-n`
    flags to specify the namespace you desire.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理命名空间和 Helm 时，您可以使用`--namespace`或`-n`标志来指定所需的命名空间。
- en: Configuration at Installation Time
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装时的配置
- en: In the preceding examples, we installed the same chart a few different ways.
    In all cases, they are identically configured. While the default configuration
    is good sometimes, more often we want to pass our own configuration to the chart.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们以几种不同的方式安装了相同的图表。在所有情况下，它们的配置是相同的。虽然默认配置有时很好，但更常见的是我们想将自己的配置传递给图表。
- en: Many charts will allow you to provide configuration values. If we take a look
    at the [Artifact Hub page for Drupal](https://oreil.ly/baxxf), we would see a
    long list of configurable parameters. For example, we can configure the username
    of the Drupal admin account by setting the `drupalUsername` value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 许多图表将允许您提供配置值。如果我们查看[Drupal 的 Artifact Hub 页面](https://oreil.ly/baxxf)，我们将看到一长串可配置参数。例如，我们可以通过设置`drupalUsername`值来配置
    Drupal 管理员帐户的用户名。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter we will learn how to get this information using the `helm`
    command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用`helm`命令获取此信息。
- en: 'There are several ways of telling Helm which values you want to be configured.
    The best way is to create a YAML file with all of the configuration overrides.
    For example, we can create a file that sets values for `drupalUsername` and `drupalEmail`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以告诉 Helm 您想要配置哪些值。最好的方法是创建一个包含所有配置覆盖的 YAML 文件。例如，我们可以创建一个设置`drupalUsername`和`drupalEmail`值的文件：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we have a file (conventionally named *values.yaml*) that has all of our
    configuration. Since it is in a file, it is easy to reproduce the same installation.
    You can also check this file into a version control system to track changes to
    your values over time. The Helm core maintainers consider it a good practice to
    keep your configuration values in a YAML file. It is important to keep in mind,
    though, that if a configuration file has sensitive information (like a password
    or authentication token), you should take steps to ensure that this information
    is not leaked.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个文件（通常命名为*values.yaml*），其中包含所有配置信息。由于它在一个文件中，因此很容易复制相同的安装过程。您还可以将此文件检入到版本控制系统中，以跟踪值随时间的变化。Helm核心维护者认为将配置值存储在YAML文件中是一个良好的实践。但请记住，如果配置文件包含敏感信息（如密码或身份验证令牌），则应采取措施确保这些信息不会泄露。
- en: 'Both `helm install` and `helm upgrade` provide a `--values` flag that points
    to a YAML file with value overrides:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm install`和`helm upgrade`都提供了一个`--values`标志，该标志指向一个带有值覆盖的YAML文件：'
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that in the preceding output the `Username` is now `admin` instead of
    `user`. One nice feature of Helm is that even the help text can be updated using
    values you provide.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的输出中，`Username`现在是`admin`而不是`user`。Helm的一个很好的特性是，甚至可以使用您提供的值更新帮助文本。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can specify the `--values` flag multiple times. Some people use this feature
    to have “common” overrides in one file and specific overrides in another.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以多次指定`--values`标志。有些人使用此功能在一个文件中进行“常见”覆盖，而在另一个文件中进行特定的覆盖。
- en: 'There is a second flag that can be used to add individual parameters to an
    install or upgrade. The `--set` flag takes one or more values directly. They do
    not need to be stored in a YAML file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第二个标志可以用来向安装或升级添加单个参数。`--set`标志接受一个或多个直接值。它们不需要存储在YAML文件中：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This sets just one parameter, `drupalUsername`. This flag uses a simple `key=value`
    format.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这只设置了一个参数，`drupalUsername`。此标志使用简单的`key=value`格式。
- en: 'Configuration parameters can be structured. That is, a configuration file may
    have multiple sections. The Drupal chart, for example, has configuration specific
    to the MariaDB database. These parameters are all grouped into a `mariadb` section.
    Building on our previous example, we could override the MariaDB database name
    like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 配置参数可以是结构化的。也就是说，配置文件可以有多个部分。例如，Drupal图表具有特定于MariaDB数据库的配置。这些参数都被分组到`mariadb`部分中。在我们之前的示例基础上，我们可以像这样覆盖MariaDB数据库名称：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Subsections are a little more complicated when using the `--set` flag. You
    will need to use a dotted notation: `--set mariadb.db.name=my-database`. This
    can get verbose when setting multiple values.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`--set`标志时，子部分会更加复杂。您需要使用点分符号表示法：`--set mariadb.db.name=my-database`。当设置多个值时，这可能会变得冗长。
- en: In general, Helm core maintainers suggest storing configuration in *values.yaml*
    files (note that the filename does not need to be “values”), only using `--set`
    when absolutely necessary. This way, you have easy access to the values you used
    during an operation (and can track those over time), while also keeping your Helm
    commands short. Working with files also means you do not have to escape as many
    characters as you do when setting things on the command line.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Helm核心维护者建议将配置存储在*values.yaml*文件中（请注意，文件名不一定需要是“values”），只有在绝对必要时才使用`--set`。这样，您可以在操作期间轻松访问使用的值（并可以随时间跟踪这些值），同时保持Helm命令的简洁。使用文件还意味着您不必像在命令行设置时那样转义很多字符。
- en: Before moving on to upgrades, though, we will take a quick look at one of the
    most helpful Helm commands.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续升级之前，我们将快速查看Helm命令中最有帮助的一个功能。
- en: Listing Your Installations
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出您的安装
- en: As we have seen so far, Helm can install many things into the same cluster—even
    multiple instances of the same chart. And with multiple users on your cluster,
    different people may be installing things into the same namespace on a cluster.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Helm可以将许多内容安装到同一个集群中，甚至可以在同一个图表的多个实例之间进行安装。而且，在集群上有多个用户时，不同的人可能会将内容安装到同一个命名空间上。
- en: 'The `helm list` command is a simple tool to help you see installations and
    learn about those installations:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm list`命令是一个简单的工具，帮助您查看安装并了解这些安装情况：'
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command will provide you with lots of useful information, including the
    name and namespace of the release, the current revision number (discussed in [Chapter 1](ch01.xhtml#introducing_helm),
    and in more depth in the next section), the last time it was updated, the installation
    status, and the versions of the chart and app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为您提供大量有用的信息，包括发布的名称和命名空间，当前修订号（在[第1章](ch01.xhtml#introducing_helm)中讨论，并在下一节中深入讨论），上次更新时间，安装状态以及图表和应用程序的版本。
- en: Like other commands, `helm list` is namespace aware. By default, Helm uses the
    namespace your Kubernetes configuration file sets as the default. Usually this
    is the namespace named `default`. Earlier, we installed a Drupal instance into
    the namespace `first`. We can see that with `helm list --namespace first`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他命令一样，`helm list`会考虑命名空间。默认情况下，Helm使用Kubernetes配置文件设置的命名空间作为默认值。通常情况下，这个命名空间被命名为`default`。之前，我们将Drupal实例安装到`first`命名空间中。我们可以通过`helm
    list --namespace first`来查看。
- en: 'When listing all of your releases, one useful flag is the `--all-namespaces`
    flag, which will query all of the Kubernetes namespaces to which you have permission,
    and return all of the releases it finds:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当列出所有发布时，一个有用的标志是`--all-namespaces`标志，它将查询您具有权限的所有Kubernetes命名空间，并返回找到的所有发布：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Upgrading an Installation
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级安装
- en: When we talk about upgrading in Helm, we talk about upgrading an installation,
    not a chart. An *installation* is a particular instance of a chart in your cluster.
    When you run `helm install`, it creates the installation. To modify that installation,
    use `helm upgrade`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Helm中的升级时，我们指的是升级安装，而不是图表本身。*安装*是您集群中图表的特定实例。当您运行`helm install`时，它创建该安装。要修改该安装，请使用`helm
    upgrade`。
- en: 'This is an important distinction to make in the present context because upgrading
    an installation can consist of two different kinds of changes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前上下文中，这是一个重要的区分，因为在Helm中升级安装可以包含两种不同类型的更改：
- en: You can upgrade the *version of the chart*
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以升级图表的*版本*
- en: You can upgrade the *configuration* of the installation
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以升级*安装的配置*
- en: 'The two are not mutually exclusive; you can do both at the same time. But this
    does introduce one new term that Helm users refer to when talking about their
    systems: a *release* is a particular combination of configuration and chart version
    for an installation.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者并不是互斥的；您可以同时执行两者。但这确实引入了一个Helm用户在讨论其系统时引用的新术语：*发布*是安装的特定配置和图表版本的组合。
- en: 'When we first install a chart, we create the initial release of an installation.
    Let’s call this release 1\. When we perform an upgrade, we are creating a new
    *release* of the same *installation*: release 2\. When we upgrade again, we will
    create release 3\. (In the next chapter, we’ll see how rollbacks also create releases.)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次安装图表时，我们创建了安装的初始发布。让我们称其为发布1。当我们执行升级时，我们将创建相同安装的新发布：发布2。当我们再次升级时，我们将创建发布3。（在下一章中，我们将看到如何通过回滚也创建发布。）
- en: During an upgrade, then, we can create a release with new configuration, with
    a new chart version, or with both.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在升级过程中，我们可以使用新配置创建一个发布，使用新的图表版本，或者两者兼而有之。
- en: For example, say we install the Drupal chart with the `ingress` turned off.
    (This will effectively prevent traffic from being routed from outside the cluster
    into the Drupal instance.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们安装Drupal图表时，关闭了`ingress`。（这将有效阻止外部集群流量进入Drupal实例。）
- en: 'Note that we are using the `--set` flag to keep examples compact, but would
    recommend using a *values.yaml* file in regular scenarios:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在此处使用`--set`标志来保持示例的紧凑性，但在常规情况下建议使用*values.yaml*文件：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With `ingress` turned off, we can work on getting our site all set up to our
    liking. Then when we are ready, we can create a new release that enables the `ingress`
    feature:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭`ingress`功能后，我们可以开始设置我们喜欢的站点。然后，当我们准备好时，我们可以创建一个启用`ingress`功能的新发布：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we are running an `upgrade` that will only change the configuration.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在运行一个仅更改配置的`upgrade`。
- en: In the background, Helm will load the chart, generate all of the Kubernetes
    objects in that chart, and then see how those differ from the version of the chart
    that is already installed. It will only send Kubernetes the things that need to
    change. In other words, Helm will attempt to alter only the bare minimum.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，Helm将加载图表，生成该图表中的所有Kubernetes对象，然后查看这些对象与已安装图表版本的区别。它只会发送需要更改的Kubernetes对象。换句话说，Helm将尝试仅修改最小必要的内容。
- en: The preceding example will only change the `ingress` configuration. Nothing
    changes with the database, or even with the web server running Drupal. For that
    reason, nothing will be restarted or deleted and re-created. This can occasionally
    confuse new Helm users, but it is by design. The Kubernetes philosophy is to make
    changes in the most streamlined way possible, and Helm seeks to follow this philosophy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例只会更改 `ingress` 配置。数据库或者运行 Drupal 的 Web 服务器都不会发生任何变化。因此，不会重新启动或删除并重新创建任何内容。这有时会让新的
    Helm 用户感到困惑，但这是有意设计的。Kubernetes 的哲学是以最简洁的方式进行更改，Helm 也致力于遵循这一哲学。
- en: On occasion, you may want to force one of your services to restart. This is
    not something you need to use Helm for. You can simply use `kubectl` itself to
    restart things. With an operating system’s package manager, you do not use the
    package manager to restart a program. Likewise, you don’t need to use Helm to
    restart your web server or database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，您可能希望强制重启其中一个服务。这并不是您需要使用 Helm 的事情。您可以直接使用 `kubectl` 来重新启动。就像操作系统的软件包管理器不用于重新启动程序一样。同样，您不需要使用
    Helm 来重新启动 Web 服务器或数据库。
- en: 'When a new version of a chart comes out, you may want to upgrade your existing
    installation to use the new chart version. For the most part, Helm tries to make
    this easy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当图表的新版本发布时，您可能希望升级现有的安装以使用新的图表版本。大多数情况下，Helm 力求简化这个过程：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_using_helm_CO1-1)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_using_helm_CO1-1)'
- en: Fetch the latest packages from chart repositories.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从图表仓库获取最新的包。
- en: '[![2](Images/2.png)](#co_using_helm_CO1-2)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_using_helm_CO1-2)'
- en: Upgrade the `mysite` release to use the latest version of `bitnami/drupal`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `mysite` 发布升级到使用 `bitnami/drupal` 的最新版本。
- en: 'As you can see, the default policy of Helm is to attempt to use the latest
    version of a chart. If you would prefer to stay on a particular version of a chart,
    you can explicitly declare this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，Helm 的默认策略是尝试使用图表的最新版本。如果您希望保留特定版本的图表，可以显式声明：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, even if a newer version is released, only `bitnaim/drupal` version
    `6.2.22` will be installed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，即使发布了更新版本，也只会安装 `bitnami/drupal` 的 `6.2.22` 版本。
- en: Configuration Values and Upgrades
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置数值和升级
- en: 'One of the most important things to learn about Helm installs and upgrades
    is that configuration gets applied freshly on each release. Here’s a quick illustration:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 了解 Helm 的安装和升级最重要的一点是，每次发布都会全新应用配置数据。以下是一个快速说明：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](Images/1.png)](#co_using_helm_CO2-1)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_using_helm_CO2-1)'
- en: Install using a configuration file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件进行安装。
- en: '[![2](Images/2.png)](#co_using_helm_CO2-2)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_using_helm_CO2-2)'
- en: Upgrade without a configuration file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用配置文件进行升级。
- en: What is the result of this pair of operations? The installation will use all
    of the configuration data supplied in *values.yaml*, but the upgrade will not.
    As a result, some settings could be changed back to their defaults. This is usually
    not what you want.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这一对操作的结果是什么？安装将使用 *values.yaml* 中提供的所有配置数据，但升级则不会。因此，某些设置可能会被改回其默认值。这通常不是您想要的结果。
- en: Inspecting Values
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查数值
- en: In the next chapter we will look at the `helm get` command. You can use `helm
    get values mysite` to see what values were used on the last `helm install` or
    `helm upgrade` operation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 `helm get` 命令。您可以使用 `helm get values mysite` 查看上次 `helm install`
    或 `helm upgrade` 操作使用的值。
- en: 'Helm core maintainers suggest that you provide consistent configuration with
    each installation and upgrade. To apply the same configuration to both releases,
    supply the values on each operation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 核心维护者建议您在每次安装和升级时提供一致的配置。要将相同的配置应用于两个发布，需要在每个操作中提供这些值：
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_using_helm_CO3-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_using_helm_CO3-1)'
- en: Install using a configuration file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用配置文件进行安装。
- en: '[![2](Images/2.png)](#co_using_helm_CO3-2)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_using_helm_CO3-2)'
- en: Upgrade using the same configuration file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的配置文件进行升级。
- en: One of the reasons we suggest storing configuration in a *values.yaml* file
    is so that this pattern is easy to reproduce. Imagine how much more cumbersome
    these commands would be if you used `--set` to set three or four configuration
    parameters! For each release, you’d have to remember exactly which things to set.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议将配置存储在 *values.yaml* 文件中，这样可以轻松复制这种模式。想象一下，如果您使用 `--set` 设置三到四个配置参数，这些命令将会变得多么繁琐！对于每个发布，您都需要记住要设置哪些内容。
- en: 'While we strongly advise using the pattern discussed here, and specifying `--values`
    each time, there is an upgrade shortcut available that will just reuse the last
    set of values that you sent:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们强烈建议使用此处讨论的模式，并每次指定`--values`，但也有一个升级快捷方式可供使用，它将只重用您发送的上一组值：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `--reuse-values` flag will tell Helm to reload the server-side copy of the
    last set of values, and then use those to generate the upgrade. This method is
    okay if you are always *just* reusing the same values. However, the Helm maintainers
    strongly suggest not trying to mix `--reuse-values` with additional `--set` or
    `--values` options. Doing so can make troubleshooting complicated and can quickly
    lead to unmaintainable installations in which nobody is sure how certain configuration
    parameters were set. While Helm does retain some state information, it is not
    a configuration management tool. Users are advised to manage configuration using
    their own tools and explicitly pass that configuration to Helm in each invocation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`--reuse-values`标志将告诉Helm重新加载上次设置的服务器端副本的值，然后使用这些值生成升级。如果您总是*只*重用相同的值，这种方法是可以接受的。然而，Helm的维护者强烈建议不要尝试将`--reuse-values`与额外的`--set`或`--values`选项混合使用。这样做会使故障排除变得复杂，并且很快会导致不可维护的安装，其中没有人确切知道如何设置某些配置参数。虽然Helm保留了一些状态信息，但它不是配置管理工具。建议用户使用自己的工具管理配置，并在每次调用中显式传递该配置给Helm。'
- en: At this point, we’ve learned how to install, list, and upgrade installations.
    In the final section of this chapter, we will delete an installation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学会了如何安装、列出和升级安装。在本章的最后一节中，我们将删除一个安装。
- en: Uninstalling an Installation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卸载安装
- en: 'To remove a Helm installation, use the `helm uninstall` command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除Helm安装，请使用`helm uninstall`命令：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this command does not need a chart name (`bitnami/drupal`) or any
    configuration files. It simply needs the name of the installation. In this section,
    we will look at how deletion works and take a brief detour into a big change between
    Helm 2 and Helm 3.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此命令不需要图表名称（`bitnami/drupal`）或任何配置文件。它只需要安装名称。在本节中，我们将看看删除如何工作，并简要介绍Helm
    2和Helm 3之间的一个重大变化。
- en: 'Like `install`, `list`, and `upgrade`, you can supply a `--namespace` flag
    to specify that you want to delete an installation *from a specific namespace*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与`install`、`list`和`upgrade`一样，您可以提供`--namespace`标志来指定您希望从*特定命名空间*删除安装：
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding will delete the site we created in the `first` namespace earlier
    in this chapter. Note that there is no command to delete multiple applications.
    You must uninstall a *specific* installation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前述内容将删除我们在本章早期在`first`命名空间中创建的站点。请注意，没有删除多个应用程序的命令。您必须卸载*特定*的安装。
- en: Deletion can take time. Larger applications may take several minutes, or even
    longer, as Kubernetes cleans up all of the resources. During this time, you will
    not be able to reinstall using the same name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 删除可能需要一些时间。较大的应用程序可能需要几分钟，甚至更长时间，因为Kubernetes清理所有资源。在此期间，您将无法使用相同的名称重新安装。
- en: How Helm Stores Release Information
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm如何存储发布信息
- en: One of the big changes in Helm 3 is how it deletes Helm’s own data about an
    installation. This section briefly describes how installations are tracked and
    then concludes by explaining how and why Helm changed between version 2 and version
    3.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 3中的一个重大变化是如何删除有关安装的Helm自身数据。本节简要描述了安装是如何被跟踪的，然后总结了解释了为什么Helm在2和3版本之间发生了变化。
- en: When we first install a chart with Helm (such as with `helm install mysite bitnami/drupal`),
    we create the Drupal application instance, and we also create a special record
    that contains release information. By default, Helm stores these records as Kubernetes
    `Secret`s (though there are other supported storage backends).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次使用Helm安装图表（例如使用`helm install mysite bitnami/drupal`），我们创建了Drupal应用程序实例，并且还创建了一个包含发布信息的特殊记录。默认情况下，Helm将这些记录存储为Kubernetes
    `Secret`（尽管还支持其他存储后端）。
- en: 'We can see these records with `kubectl get secret`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`kubectl get secret`来查看这些记录：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see multiple release records at the bottom, one for each revision. As
    you can see, we have created four revisions of `mysite` by running `install` and
    `upgrade` operations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在底部看到多个发布记录，每个修订版本都有一个。正如您所看到的，我们通过运行`install`和`upgrade`操作创建了`mysite`的四个修订版本。
- en: In the next chapter, we will see how these extended records can be used to roll
    back to previous revisions of an installation. But we point this out now to illustrate
    something about how `helm uninstall` works.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何利用这些扩展记录来回滚到安装的先前版本。但我们现在指出这一点是为了说明`helm uninstall`的工作原理。
- en: 'When we run the command `helm uninstall mysite`, it will load the latest release
    record for the `mysite` installation. From that record, it will assemble a list
    of objects that it should remove from Kubernetes. Then Helm will delete all of
    those things before returning and deleting the four release records:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行命令`helm uninstall mysite`时，它将加载`mysite`安装的最新发布记录。从该记录中，它将组装一个应从 Kubernetes
    中删除的对象列表。然后 Helm 将在返回并删除这四个发布记录之前删除所有这些对象：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `helm list` command will no longer show `mysite`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm list`命令将不再显示`mysite`：'
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now have no installations. And if we rerun the `kubectl get secrets` command,
    we will also see all records of `mysite` have been purged:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们没有任何安装。如果我们重新运行`kubectl get secrets`命令，我们还将看到`mysite`的所有记录都已被清除：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see from this output, not only were the two `Secret`s created by the
    Drupal chart deleted, but the four release records were deleted as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从这个输出中看到的，Drupal图表创建的两个`Secret`不仅被删除了，还删除了四个发布记录。
- en: 'In the next chapter, we will see the `helm rollback` command. The preceding
    explanation should give you some hints as to why, by default, you cannot roll
    back an uninstall. It is possible, though, to delete the application, but keep
    the release records:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到`helm rollback`命令。前面的解释应该让你了解为什么默认情况下无法回滚卸载。不过，可以删除应用程序但保留发布记录：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In Helm 2, history was retained by default. In Helm 3, the default was changed
    to deleting history. Different organizations prefer different policies, but core
    maintainers found that when most people uninstalled, they expected all traces
    of the installation to be destroyed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Helm 2 中，默认情况下保留了历史记录。在 Helm 3 中，更改为默认删除历史记录。不同的组织偏好不同的策略，但核心维护者发现，当大多数人卸载时，他们希望销毁所有安装的痕迹。
- en: Conclusion
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we covered the basics of installing and then using Helm. After
    looking at popular methods of getting Helm installed and configured, we added
    a chart repository and learned how to search for charts. Then we installed, listed,
    upgraded, and finally uninstalled the `bitnami/drupal` chart.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了安装和使用 Helm 的基础知识。在探讨了流行的 Helm 安装和配置方法之后，我们添加了一个图表仓库，并学习了如何搜索图表。然后，我们安装了、列出了、升级了，并最终卸载了`bitnami/drupal`图表。
- en: Along the way, we picked up some important concepts. We learned about installations
    and releases. We took a first look at chart repositories, which will be covered
    at length in [Chapter 7](ch07.xhtml#chart_repositories). And at the end of the
    chapter we learned a little about how Helm stores information about our installations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们掌握了一些重要的概念。我们学习了安装和发布。我们初步了解了图表仓库，在[第7章](ch07.xhtml#chart_repositories)中将详细介绍。在本章的结尾，我们稍微了解了
    Helm 如何存储关于我们安装的信息。
- en: In the next chapter, we will return to the `helm` command, learning about other
    things that the Helm tool can do.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾`helm`命令，学习 Helm 工具的其他功能。
