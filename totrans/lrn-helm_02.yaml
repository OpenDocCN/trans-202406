- en: Chapter 2\. Using Helm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm provides a command-line tool, named `helm`, that makes available all the
    features necessary for working with Helm charts. In this chapter, we will discover
    the primary features of the `helm` client. Along the way, we’ll learn how Helm
    interacts with Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at how to install and configure Helm, and work our
    way through the main command groups in Helm. Then we will cover finding and learning
    about packages, and how to install, upgrade, and delete them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Configuring the Helm Client
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm provides a single command-line client that is capable of performing all
    of the main Helm tasks. This client is, appropriately enough, named `helm`. While
    there are many other tools that can work with Helm charts, this one is the official
    general-purpose tool maintained by the Helm core maintainers, and it is the subject
    of this chapter as well as the next.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: The `helm` client is written in a programming language called Go. Unlike Python,
    JavaScript, or Ruby, Go is a compiled language. Once a Go program is compiled,
    you do not need any of the Go tools to run or otherwise work with the binary.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: So we will first cover downloading and installing the static binary, and then
    we will briefly introduce the process for fetching and compiling from the Go source
    code, should you so desire.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Prebuilt Binary
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time the Helm maintainers issue a new release of `helm`, the project provides
    new signed binary builds of `helm` for a number of common operating systems and
    architectures. At the time of this writing, prebuilt versions of Helm are available
    for Linux, Windows, and macOS on architectures ranging from 64-bit Intel/AMD to
    ARM, to s390 and PPC. This means you can run Helm on anything from a Raspberry
    Pi to a supercomputer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The definitive list of Helm releases is at [the Helm release page](https://oreil.ly/L_My5).
    The release page will show a chronological list of releases, with the latest release
    at the top.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: A note on Helm version numbers
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until November 2020, two different major versions of Helm were actively maintained.
    The current stable major version of Helm is version 3\. When you visit the Helm
    download pages, you may see both versions available for download. Because the
    versions are chronologically listed, it is even possible that a Helm 2 release
    will be newer than the latest Helm 3 release. You should use Helm 3.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Helm follows a versioning convention known as [Semantic Versioning](https://semver.org)
    (SemVer). In Semantic Versioning, the version number conveys meaning about what
    you can expect in the release. Because Helm follows this specification, users
    can expect certain things out of releases simply by carefully reading the version
    number.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, a semantic version has three numerical components and an optional
    *stability marker* (for alphas, betas, and release candidates). Here are some
    examples:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '`v1.0.0`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v3.3.2`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2.4.22-alpha.2`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s talk about the numerical components first.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'We often generalize this format to talk about `X.Y.Z`, where `X` is a *major
    version*, `Y` is a *minor version* and `Z` is a *patch release*:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The major release number tends to be incremented infrequently. It indicates
    that major changes have been made to Helm, and that some of those changes may
    break compatibility with previous versions. The difference between Helm 2 and
    Helm 3 is substantial, and there is work necessary to migrate between the versions.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The minor release number indicates feature additions. The difference between
    3.2.0 and 3.3.0 might be that a few small new features were added. However, there
    are no *breaking changes* between versions. (With one caveat: a security fix might
    necessitate a breaking change, but we announce boldly when that is the case.)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The patch release number indicates that *only* backward compatible bug fixes
    have been made between this release and the last one. It is always recommended
    to stay at the latest patch release.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you see a release with a stability marker, like `alpha.1`, `beta.4`, or
    `rc.2`, appended to the release number, that means the release is considered to
    be a pre-release, and is not ready for mainstream production usage. In particular,
    Helm frequently issues *release candidates* before a major or minor update. These
    give the community a chance to give us some feedback on stability, compatibility,
    and new features before we issue a final release.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we are ready to proceed with the actual installation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the binary
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way to install Helm from the repository is to simply go to the [releases
    page](https://oreil.ly/L_My5) and download the latest Helm 3 version.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, the download file is a ZIP archive containing a *README.md* text
    file, a *LICENSE* text file, and *helm.exe*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: On macOS and Linux, the download will be in a gzipped tar archive (`.tar.gz`)
    that can be extracted with the `tar -zxf` command. Like the Windows version, it
    will contain a *README.md* text file, a *LICENSE* text file, and the `helm` binary.
    If you are using Windows Subsystem for Linux (WSL), you should install the Linux
    AMD64 version into your WSL instance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which operating system you use, the binary is the only file you
    need to run Helm, and you can put it wherever you prefer on your system. It should
    be pre-marked as an executable, but on rare occasions in UNIX-like environments,
    you may also need to run the command `chmod helm +x` to set Helm to be an executable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When installing with package managers like Homebrew (macOS), Snap (Linux), or
    Chocolatey (Windows), `helm` will be installed in a standard location and be made
    immediately available to you via the command line.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Once you have `helm` installed, you should be able to run the command `helm
    help` and see the Helm help text.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Using the get script to install
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On macOS and Linux, you may prefer to run a shell script that will determine
    which version of Helm to install and do it automatically for you.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 和 Linux 上，您可能更喜欢运行一个 shell 脚本，它会确定要安装的 Helm 版本，并自动完成安装。
- en: 'The usual sequence of commands for installing this way is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式安装的常规命令序列如下：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding commands fetch the latest version of the `get_helm.sh` script,
    and then use that to find and install the latest version of Helm 3.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令会获取 `get_helm.sh` 脚本的最新版本，然后使用它来查找并安装 Helm 3 的最新版本。
- en: For systems that automatically install Helm, such as continuous integration
    (CI) systems, we recommend using this method if it is important to always have
    the latest Helm version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自动安装 Helm 的系统，例如持续集成（CI）系统，如果始终拥有最新的 Helm 版本很重要，我们建议使用这种方法。
- en: Guidance on Building from Source
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建源代码的指南
- en: Unless you are already familiar with Go development, building Helm from source
    can be a daunting task. You will need a version of the `make` command. Because
    `Makefile`-style build scripts do not follow a single standard, not all versions
    of `make` will work to build Helm. Gnu Make, the one most frequently used on Linux
    and Mac, is the one most Helm core developers use, so it is a safe bet. You will
    also need the `gcc` compiler and the entire Go toolchain.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您已经熟悉 Go 开发，否则从源代码构建 Helm 可能会是一项艰巨的任务。您需要一个版本的 `make` 命令。因为 `Makefile` 风格的构建脚本没有遵循单一标准，不是所有版本的
    `make` 都能用于构建 Helm。GNU Make 是在 Linux 和 Mac 上最常用的，也是 Helm 核心开发人员最常用的，因此是一个安全的选择。您还需要
    `gcc` 编译器和完整的 Go 工具链。
- en: In addition to these, Helm needs several auxilliary tools. Fortunately, when
    you run `make` the first time, it will attempt to install any additional tools
    that are missing.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Helm 还需要几个辅助工具。幸运的是，当您第一次运行 `make` 时，它将尝试安装任何缺失的附加工具。
- en: While they are not strictly necessary, you will probably also want the `git`
    tool and the `kubectl` command. The `git` tool will allow you to work directly
    with the Helm source code repository instead of downloading source code bundles.
    `kubectl`, of course, is for interacting with your Kubernetes cluster. While that’s
    not necessary for *building* Helm, it’s certainly necessary when checking to see
    whether Helm is doing what you want it to do.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们并非绝对必需，但您可能还需要 `git` 工具和 `kubectl` 命令。`git` 工具允许您直接使用 Helm 源代码仓库，而不是下载源代码包。当然，`kubectl`
    是用于与您的 Kubernetes 集群交互的。虽然这不是 *构建* Helm 所必需的，但在检查 Helm 是否按您希望的方式运行时，这无疑是必需的。
- en: Once you have the tools installed and configured, you can simply change directories
    in the folder that contains Helm’s source code (the directory with the *README.md*
    and Makefile files) and run `make build`. The first time you run this command,
    it will take at least several minutes. The build system must fetch lots of dependencies,
    including much of the Kubernetes source code, and compile it all.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装和配置好工具，您只需切换到包含 Helm 源代码的文件夹（即包含 *README.md* 和 Makefile 文件的目录），然后运行 `make
    build`。第一次运行此命令时，至少需要几分钟。构建系统必须获取大量依赖项，包括 Kubernetes 的大部分源代码，并对其进行编译。
- en: Tip
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Compiling Helm for the first time can be daunting, especially if you are new
    to the Go programming language. Kubernetes is a sophisticated platform, and thus
    the Helm source code is large and difficult to build. Plan on spending at least
    an hour or two to get a fresh environment prepared to install Helm.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译 Helm 初次可能会令人望而却步，尤其是对于不熟悉 Go 编程语言的人来说。 Kubernetes 是一个复杂的平台，因此 Helm 的源代码庞大且难以构建。计划至少花上一两个小时准备一个新的环境来安装
    Helm。
- en: To verify that Helm is functioning correctly (especially if you have modified
    the source code), you can run `make test`. This will build the code, run a variety
    of checkers and linters, and then run the unit tests for Helm. If you plan on
    contributing any changes to Helm, this command *must* pass before Helm’s core
    maintainers will even look at your requested change.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证 Helm 是否正常运行（特别是如果您修改了源代码），可以运行 `make test`。这将构建代码，运行各种检查器和 linter，并运行 Helm
    的单元测试。如果您计划向 Helm 的核心维护者提交任何更改请求，在查看您请求的更改之前，此命令 *必须* 通过。
- en: When Helm is compiled, it will be located alongside the source code in a subdirectory
    called *bin/*. It will not automatically be added to your executable path, so
    to execute the version you just built, you may need to specify the relative or
    exact path (e.g., *./bin/helm* or *$GOPATH/src/helm.sh/helm/bin/helm*).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: If the command `helm version` correctly executes, you can be assured that you
    correctly compiled Helm.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can follow the detailed [Developer Guide](https://oreil.ly/X9-Ii)
    to learn more. As always, if you run into problems, the `helm-users` channel on
    the Kubernetes Slack server is a great place to ask for help.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Working with Kubernetes Clusters
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm interacts directly with the Kubernetes API server. For that reason, Helm
    needs to be able to connect to a Kubernetes cluster. Helm attempts to do this
    automatically by reading the same configuration files used by `kubectl` (the main
    Kubernetes command-line client).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Helm will try to find this information by reading the environment variable *$KUBECONFIG*.
    If that is not set, it will look in the same default locations that `kubectl`
    looks in (for example, *$HOME/.kube/config* on UNIX, Linux, and macOS).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: You can also override these settings with environment variables (`HELM_KUBECONTEXT`)
    and command-line flags (`--kube-context`). You can see a list of environment variables
    and flags by running `helm help`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: The Helm maintainers recommend using `kubectl` to manage your Kubernetes credentials
    and letting Helm merely autodetect these settings. If you have not yet installed
    `kubectl`, the best place to start is with the [official Kubernetes installation
    documentation](https://oreil.ly/pHZIh).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Helm
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you built Helm from source or installed using one of the aforementioned
    methods, at this point you should have the `helm` command available on your system.
    From here on, we will assume that Helm can be executed with the command `helm`
    (as opposed to a full or relative path, as discussed in the previous section).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'In what follows, we are going to take a look at the most common workflow for
    starting out with Helm:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Add a chart repository.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a chart to install.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install a Helm chart.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the list of what is installed.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade your installation.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the installation.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the next chapter we will dive into some of the additional features
    of Helm and in so doing learn more about how Helm works.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Chart Repository
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chart repositories are a topic in their own right, and in [Chapter 7](ch07.xhtml#chart_repositories)
    we will examine them in detail. But anyone using Helm must know a few basics about
    chart repositories.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: A Helm chart is an *individual package* that can be installed into your Kubernetes
    cluster. During chart development, you will often just work with a chart that
    is stored on your local filesystem.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: But when it comes to sharing charts, Helm describes a standard format for indexing
    and sharing information about Helm charts. A Helm *chart repository* is simply
    a set of files, reachable over the network, that conforms to the Helm specification
    for indexing packages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Helm 3 introduced an experimental feature for storing Helm charts in a different
    kind of repository: Open Container Initiative (OCI) registries (sometimes called
    Docker registries). In this backend, a Helm chart can be stored alongside Docker
    images. While this feature is not yet broadly supported, it may become the future
    of Helm package storage. This is discussed more in [Chapter 7](ch07.xhtml#chart_repositories).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: There are many—perhaps thousands of—chart repositories on the internet. The
    easiest way to find the popular repositories is to use your web browser to navigate
    to [the Artifact Hub](https://artifacthub.io). There you will find thousands of
    Helm charts, each hosted on an appropriate repository.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we will install the popular [Drupal content management system](https://www.drupal.org).
    This makes a good example chart because it exercises many of Kubernetes’ types,
    including `Deployment`s, `Service`s, `Ingress`, and `ConfigMap`s.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Helm 2 came with a Helm repository installed by default. The `stable` chart
    repository was at one time the official source of production-ready Helm charts.
    But we realized that centralizing the charts into one repository was overly taxing
    to a small group of maintainers and frustrating for chart contributors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: In Helm 3, there is no default repository. Users are encouraged to use the Artifact
    Hub to find what they are looking for and then add their preferred repositories.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Drupal’s Helm chart is located in one of the most well-curated chart repositories
    available: Bitnami’s official Helm charts. You can take a look at the Artifact
    Hub’s [entry for the Drupal chart](https://oreil.ly/baxxf) for more information.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A handful of Bitnami developers were among the core contributors who designed
    the Helm repository system. They have contributed to the establishment of Helm’s
    best practices for chart development and have written many of the most widely
    used charts.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a Helm chart is done with the `helm repo add` command. Several Helm
    repository commands are grouped under the `helm repo` command group:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `helm repo add` command will add a repository named `bitnami` that points
    to the URL *[*https://charts.bitnami.com/bitnami*](https://charts.bitnami.com/bitnami)*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can verify that the Bitnami repository exists by running a second `repo`
    command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command shows us all of the repositories installed for Helm. Right now,
    we see only the Bitnami repository that we just added.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Once we have added a repository, its index will be locally cached until we next
    update it (see [Chapter 7](ch07.xhtml#chart_repositories)). And one important
    thing that we can now do is search the repository.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Searching a Chart Repository
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we know, having looked at the Artifact Hub, that the Drupal chart exists
    in this repository, it is still useful to search for it from the command line.
    Oftentimes, searching is a useful way to find not only what charts can be installed,
    but what versions are available.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let’s search for the Drupal chart:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We did a simple search for the term *drupal*. Helm will search not just the
    package names, but also other fields like labels and descriptions. Thus, we could
    search for *content* and see Drupal listed there because it is a content management
    system:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: While Drupal is the first result, note that there are a variety of other charts
    that contain the word *content* somewhere in the descriptive text.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Helm tries to install the latest stable release of a chart, but
    you can override this behavior and install a specific verison of a chart. Thus
    it is often useful to see not just the summary info for a chart, but exactly which
    versions exist for a chart:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are several dozen versions of the Drupal chart. The preceding example
    has been truncated to just show the top few versions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Chart and App Versions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *chart version* is the version of the Helm chart. The *app version* is the
    version of the application packaged in the chart. Helm uses the chart version
    to make versioning decisions, such as which package is newest. As we can see in
    the preceding example, multiple chart versions may contain the same app version.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Package
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeply into the details of how package installation
    works in Helm. In this section, though, we will look at the basic mechanics of
    installing a Helm chart.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'At very minimum, installing a chart in Helm requires just two pieces of information:
    the name of the installation and the chart you want to install.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in the previous chapter we distinguished between an *installation*
    and a *chart*. This is an important distinction during installation and upgrading.
    In an operating system package manager, we may request that it install a piece
    of software. But it is extremely rare that we need to install the same exact package
    multiple times on an operating system. A Kubernetes cluster is different. It makes
    complete sense in Kubernetes to say “I want to install a MySQL database for Application
    A, and a second MySQL database for Application B.” Even if the two databases are
    exactly the same version and have the same configuration, in order to appropriately
    manage our applications, we may desire to have two instances running.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, Helm needs a way to distinguish between the different instances
    of the same chart. So an *installation* of a chart is a specific instance of the
    chart. One chart may have many installations. When we run the `helm install` command,
    we need to give it an installation name as well as the chart name. So the most
    basic installation command looks something like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding will create an instance of the `bitnami/drupal` chart, and will
    name this instance `mysite`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 之前将创建一个`bitnami/drupal`图表的实例，并将此实例命名为`mysite`。
- en: As the install command runs, it will return a considerable amount of information,
    including user-facing instructions about getting started with Drupal.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装命令运行时，它将返回大量信息，包括有关如何开始使用 Drupal 的用户界面说明。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In future examples of `helm install`, we will omit the returned output for the
    sake of brevity. However, when using Helm, you will see that output for each installation.
    In the next chapter, we will also see how to view that output again with the `helm
    get` command.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后的`helm install`示例中，出于简洁起见，我们将省略返回的输出。但是，在使用 Helm 时，您将看到每个安装的输出。在下一章中，我们还将看到如何使用`helm
    get`命令再次查看该输出。
- en: 'At this point, there is now an instance named `mysite` in the cluster. If we
    tried to rerun the preceding command, we wouldn’t get a second instance. Instead,
    we would get an error because the name `mysite` has already been used:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，集群中现在有一个名为`mysite`的实例。如果我们尝试重新运行前面的命令，我们将不会得到第二个实例。相反，我们会因为名称`mysite`已被使用而收到错误消息：
- en: '[PRE7]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One further clarification is in order. In Helm 2, instance names were cluster-wide.
    You could only have an instance named `mysite` once *per cluster*. In Helm 3,
    naming has been changed. Now instance names are scoped to Kubernetes namespaces.
    We could install two instances named `mysite` as long as they each lived in a
    different namespace.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要进一步澄清一点。在 Helm 2 中，实例名称是集群范围的。您只能在*每个集群*中有一个名为`mysite`的实例。在 Helm 3 中，命名已更改。现在实例名称限定在
    Kubernetes 命名空间内。只要它们分别位于不同的命名空间中，我们可以安装两个名为`mysite`的实例。
- en: 'For example, the following is perfectly legal in Helm 3, though it would have
    generated a fatal error in Helm 2:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Helm 3 中，以下操作是完全合法的，尽管在 Helm 2 中会生成致命错误：
- en: '[PRE8]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will install one Drupal site named `mysite` in the `first` namespace, and
    an identically configured instance named `mysite` in the `second` namespace. This
    might seem confusing at first, but it becomes clearer when we think about a namespace
    as a *prefix on a name*. In that sense, we have a site named “first mysite” and
    another named “second mysite.”
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`first`命名空间中安装一个名为`mysite`的 Drupal 站点，并在`second`命名空间中安装一个配置相同的实例，也命名为`mysite`。起初可能会感到困惑，但当我们将命名空间视为名称的*前缀*时，情况就变得更清晰了。在这种情况下，我们有一个名为“first
    mysite”的站点和另一个名为“second mysite”的站点。
- en: Using Namespace Flags Throughout Helm
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Helm 中始终使用命名空间标志
- en: When working with namespaces and Helm, you can use the `--namespace` or `-n`
    flags to specify the namespace you desire.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理命名空间和 Helm 时，您可以使用`--namespace`或`-n`标志来指定所需的命名空间。
- en: Configuration at Installation Time
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装时的配置
- en: In the preceding examples, we installed the same chart a few different ways.
    In all cases, they are identically configured. While the default configuration
    is good sometimes, more often we want to pass our own configuration to the chart.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们以几种不同的方式安装了相同的图表。在所有情况下，它们的配置是相同的。虽然默认配置有时很好，但更常见的是我们想将自己的配置传递给图表。
- en: Many charts will allow you to provide configuration values. If we take a look
    at the [Artifact Hub page for Drupal](https://oreil.ly/baxxf), we would see a
    long list of configurable parameters. For example, we can configure the username
    of the Drupal admin account by setting the `drupalUsername` value.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 许多图表将允许您提供配置值。如果我们查看[Drupal 的 Artifact Hub 页面](https://oreil.ly/baxxf)，我们将看到一长串可配置参数。例如，我们可以通过设置`drupalUsername`值来配置
    Drupal 管理员帐户的用户名。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the next chapter we will learn how to get this information using the `helm`
    command.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用`helm`命令获取此信息。
- en: 'There are several ways of telling Helm which values you want to be configured.
    The best way is to create a YAML file with all of the configuration overrides.
    For example, we can create a file that sets values for `drupalUsername` and `drupalEmail`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以告诉 Helm 您想要配置哪些值。最好的方法是创建一个包含所有配置覆盖的 YAML 文件。例如，我们可以创建一个设置`drupalUsername`和`drupalEmail`值的文件：
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now we have a file (conventionally named *values.yaml*) that has all of our
    configuration. Since it is in a file, it is easy to reproduce the same installation.
    You can also check this file into a version control system to track changes to
    your values over time. The Helm core maintainers consider it a good practice to
    keep your configuration values in a YAML file. It is important to keep in mind,
    though, that if a configuration file has sensitive information (like a password
    or authentication token), you should take steps to ensure that this information
    is not leaked.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `helm install` and `helm upgrade` provide a `--values` flag that points
    to a YAML file with value overrides:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that in the preceding output the `Username` is now `admin` instead of
    `user`. One nice feature of Helm is that even the help text can be updated using
    values you provide.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can specify the `--values` flag multiple times. Some people use this feature
    to have “common” overrides in one file and specific overrides in another.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a second flag that can be used to add individual parameters to an
    install or upgrade. The `--set` flag takes one or more values directly. They do
    not need to be stored in a YAML file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This sets just one parameter, `drupalUsername`. This flag uses a simple `key=value`
    format.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration parameters can be structured. That is, a configuration file may
    have multiple sections. The Drupal chart, for example, has configuration specific
    to the MariaDB database. These parameters are all grouped into a `mariadb` section.
    Building on our previous example, we could override the MariaDB database name
    like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Subsections are a little more complicated when using the `--set` flag. You
    will need to use a dotted notation: `--set mariadb.db.name=my-database`. This
    can get verbose when setting multiple values.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: In general, Helm core maintainers suggest storing configuration in *values.yaml*
    files (note that the filename does not need to be “values”), only using `--set`
    when absolutely necessary. This way, you have easy access to the values you used
    during an operation (and can track those over time), while also keeping your Helm
    commands short. Working with files also means you do not have to escape as many
    characters as you do when setting things on the command line.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to upgrades, though, we will take a quick look at one of the
    most helpful Helm commands.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Listing Your Installations
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, Helm can install many things into the same cluster—even
    multiple instances of the same chart. And with multiple users on your cluster,
    different people may be installing things into the same namespace on a cluster.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helm list` command is a simple tool to help you see installations and
    learn about those installations:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command will provide you with lots of useful information, including the
    name and namespace of the release, the current revision number (discussed in [Chapter 1](ch01.xhtml#introducing_helm),
    and in more depth in the next section), the last time it was updated, the installation
    status, and the versions of the chart and app.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将为您提供大量有用的信息，包括发布的名称和命名空间，当前修订号（在[第1章](ch01.xhtml#introducing_helm)中讨论，并在下一节中深入讨论），上次更新时间，安装状态以及图表和应用程序的版本。
- en: Like other commands, `helm list` is namespace aware. By default, Helm uses the
    namespace your Kubernetes configuration file sets as the default. Usually this
    is the namespace named `default`. Earlier, we installed a Drupal instance into
    the namespace `first`. We can see that with `helm list --namespace first`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他命令一样，`helm list`会考虑命名空间。默认情况下，Helm使用Kubernetes配置文件设置的命名空间作为默认值。通常情况下，这个命名空间被命名为`default`。之前，我们将Drupal实例安装到`first`命名空间中。我们可以通过`helm
    list --namespace first`来查看。
- en: 'When listing all of your releases, one useful flag is the `--all-namespaces`
    flag, which will query all of the Kubernetes namespaces to which you have permission,
    and return all of the releases it finds:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当列出所有发布时，一个有用的标志是`--all-namespaces`标志，它将查询您具有权限的所有Kubernetes命名空间，并返回找到的所有发布：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Upgrading an Installation
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级安装
- en: When we talk about upgrading in Helm, we talk about upgrading an installation,
    not a chart. An *installation* is a particular instance of a chart in your cluster.
    When you run `helm install`, it creates the installation. To modify that installation,
    use `helm upgrade`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论Helm中的升级时，我们指的是升级安装，而不是图表本身。*安装*是您集群中图表的特定实例。当您运行`helm install`时，它创建该安装。要修改该安装，请使用`helm
    upgrade`。
- en: 'This is an important distinction to make in the present context because upgrading
    an installation can consist of two different kinds of changes:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前上下文中，这是一个重要的区分，因为在Helm中升级安装可以包含两种不同类型的更改：
- en: You can upgrade the *version of the chart*
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以升级图表的*版本*
- en: You can upgrade the *configuration* of the installation
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以升级*安装的配置*
- en: 'The two are not mutually exclusive; you can do both at the same time. But this
    does introduce one new term that Helm users refer to when talking about their
    systems: a *release* is a particular combination of configuration and chart version
    for an installation.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者并不是互斥的；您可以同时执行两者。但这确实引入了一个Helm用户在讨论其系统时引用的新术语：*发布*是安装的特定配置和图表版本的组合。
- en: 'When we first install a chart, we create the initial release of an installation.
    Let’s call this release 1\. When we perform an upgrade, we are creating a new
    *release* of the same *installation*: release 2\. When we upgrade again, we will
    create release 3\. (In the next chapter, we’ll see how rollbacks also create releases.)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次安装图表时，我们创建了安装的初始发布。让我们称其为发布1。当我们执行升级时，我们将创建相同安装的新发布：发布2。当我们再次升级时，我们将创建发布3。（在下一章中，我们将看到如何通过回滚也创建发布。）
- en: During an upgrade, then, we can create a release with new configuration, with
    a new chart version, or with both.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在升级过程中，我们可以使用新配置创建一个发布，使用新的图表版本，或者两者兼而有之。
- en: For example, say we install the Drupal chart with the `ingress` turned off.
    (This will effectively prevent traffic from being routed from outside the cluster
    into the Drupal instance.)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们安装Drupal图表时，关闭了`ingress`。（这将有效阻止外部集群流量进入Drupal实例。）
- en: 'Note that we are using the `--set` flag to keep examples compact, but would
    recommend using a *values.yaml* file in regular scenarios:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在此处使用`--set`标志来保持示例的紧凑性，但在常规情况下建议使用*values.yaml*文件：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With `ingress` turned off, we can work on getting our site all set up to our
    liking. Then when we are ready, we can create a new release that enables the `ingress`
    feature:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭`ingress`功能后，我们可以开始设置我们喜欢的站点。然后，当我们准备好时，我们可以创建一个启用`ingress`功能的新发布：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this case, we are running an `upgrade` that will only change the configuration.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们正在运行一个仅更改配置的`upgrade`。
- en: In the background, Helm will load the chart, generate all of the Kubernetes
    objects in that chart, and then see how those differ from the version of the chart
    that is already installed. It will only send Kubernetes the things that need to
    change. In other words, Helm will attempt to alter only the bare minimum.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台，Helm将加载图表，生成该图表中的所有Kubernetes对象，然后查看这些对象与已安装图表版本的区别。它只会发送需要更改的Kubernetes对象。换句话说，Helm将尝试仅修改最小必要的内容。
- en: The preceding example will only change the `ingress` configuration. Nothing
    changes with the database, or even with the web server running Drupal. For that
    reason, nothing will be restarted or deleted and re-created. This can occasionally
    confuse new Helm users, but it is by design. The Kubernetes philosophy is to make
    changes in the most streamlined way possible, and Helm seeks to follow this philosophy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: On occasion, you may want to force one of your services to restart. This is
    not something you need to use Helm for. You can simply use `kubectl` itself to
    restart things. With an operating system’s package manager, you do not use the
    package manager to restart a program. Likewise, you don’t need to use Helm to
    restart your web server or database.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new version of a chart comes out, you may want to upgrade your existing
    installation to use the new chart version. For the most part, Helm tries to make
    this easy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_using_helm_CO1-1)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the latest packages from chart repositories.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_using_helm_CO1-2)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade the `mysite` release to use the latest version of `bitnami/drupal`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the default policy of Helm is to attempt to use the latest
    version of a chart. If you would prefer to stay on a particular version of a chart,
    you can explicitly declare this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this case, even if a newer version is released, only `bitnaim/drupal` version
    `6.2.22` will be installed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Values and Upgrades
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most important things to learn about Helm installs and upgrades
    is that configuration gets applied freshly on each release. Here’s a quick illustration:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](Images/1.png)](#co_using_helm_CO2-1)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Install using a configuration file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_using_helm_CO2-2)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade without a configuration file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: What is the result of this pair of operations? The installation will use all
    of the configuration data supplied in *values.yaml*, but the upgrade will not.
    As a result, some settings could be changed back to their defaults. This is usually
    not what you want.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Values
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter we will look at the `helm get` command. You can use `helm
    get values mysite` to see what values were used on the last `helm install` or
    `helm upgrade` operation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm core maintainers suggest that you provide consistent configuration with
    each installation and upgrade. To apply the same configuration to both releases,
    supply the values on each operation:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](Images/1.png)](#co_using_helm_CO3-1)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Install using a configuration file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_using_helm_CO3-2)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade using the same configuration file.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons we suggest storing configuration in a *values.yaml* file
    is so that this pattern is easy to reproduce. Imagine how much more cumbersome
    these commands would be if you used `--set` to set three or four configuration
    parameters! For each release, you’d have to remember exactly which things to set.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'While we strongly advise using the pattern discussed here, and specifying `--values`
    each time, there is an upgrade shortcut available that will just reuse the last
    set of values that you sent:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `--reuse-values` flag will tell Helm to reload the server-side copy of the
    last set of values, and then use those to generate the upgrade. This method is
    okay if you are always *just* reusing the same values. However, the Helm maintainers
    strongly suggest not trying to mix `--reuse-values` with additional `--set` or
    `--values` options. Doing so can make troubleshooting complicated and can quickly
    lead to unmaintainable installations in which nobody is sure how certain configuration
    parameters were set. While Helm does retain some state information, it is not
    a configuration management tool. Users are advised to manage configuration using
    their own tools and explicitly pass that configuration to Helm in each invocation.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve learned how to install, list, and upgrade installations.
    In the final section of this chapter, we will delete an installation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling an Installation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To remove a Helm installation, use the `helm uninstall` command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that this command does not need a chart name (`bitnami/drupal`) or any
    configuration files. It simply needs the name of the installation. In this section,
    we will look at how deletion works and take a brief detour into a big change between
    Helm 2 and Helm 3.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `install`, `list`, and `upgrade`, you can supply a `--namespace` flag
    to specify that you want to delete an installation *from a specific namespace*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding will delete the site we created in the `first` namespace earlier
    in this chapter. Note that there is no command to delete multiple applications.
    You must uninstall a *specific* installation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Deletion can take time. Larger applications may take several minutes, or even
    longer, as Kubernetes cleans up all of the resources. During this time, you will
    not be able to reinstall using the same name.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: How Helm Stores Release Information
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the big changes in Helm 3 is how it deletes Helm’s own data about an
    installation. This section briefly describes how installations are tracked and
    then concludes by explaining how and why Helm changed between version 2 and version
    3.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: When we first install a chart with Helm (such as with `helm install mysite bitnami/drupal`),
    we create the Drupal application instance, and we also create a special record
    that contains release information. By default, Helm stores these records as Kubernetes
    `Secret`s (though there are other supported storage backends).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see these records with `kubectl get secret`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can see multiple release records at the bottom, one for each revision. As
    you can see, we have created four revisions of `mysite` by running `install` and
    `upgrade` operations.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how these extended records can be used to roll
    back to previous revisions of an installation. But we point this out now to illustrate
    something about how `helm uninstall` works.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何利用这些扩展记录来回滚到安装的先前版本。但我们现在指出这一点是为了说明`helm uninstall`的工作原理。
- en: 'When we run the command `helm uninstall mysite`, it will load the latest release
    record for the `mysite` installation. From that record, it will assemble a list
    of objects that it should remove from Kubernetes. Then Helm will delete all of
    those things before returning and deleting the four release records:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行命令`helm uninstall mysite`时，它将加载`mysite`安装的最新发布记录。从该记录中，它将组装一个应从 Kubernetes
    中删除的对象列表。然后 Helm 将在返回并删除这四个发布记录之前删除所有这些对象：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `helm list` command will no longer show `mysite`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm list`命令将不再显示`mysite`：'
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We now have no installations. And if we rerun the `kubectl get secrets` command,
    we will also see all records of `mysite` have been purged:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们没有任何安装。如果我们重新运行`kubectl get secrets`命令，我们还将看到`mysite`的所有记录都已被清除：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see from this output, not only were the two `Secret`s created by the
    Drupal chart deleted, but the four release records were deleted as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从这个输出中看到的，Drupal图表创建的两个`Secret`不仅被删除了，还删除了四个发布记录。
- en: 'In the next chapter, we will see the `helm rollback` command. The preceding
    explanation should give you some hints as to why, by default, you cannot roll
    back an uninstall. It is possible, though, to delete the application, but keep
    the release records:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到`helm rollback`命令。前面的解释应该让你了解为什么默认情况下无法回滚卸载。不过，可以删除应用程序但保留发布记录：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In Helm 2, history was retained by default. In Helm 3, the default was changed
    to deleting history. Different organizations prefer different policies, but core
    maintainers found that when most people uninstalled, they expected all traces
    of the installation to be destroyed.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Helm 2 中，默认情况下保留了历史记录。在 Helm 3 中，更改为默认删除历史记录。不同的组织偏好不同的策略，但核心维护者发现，当大多数人卸载时，他们希望销毁所有安装的痕迹。
- en: Conclusion
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we covered the basics of installing and then using Helm. After
    looking at popular methods of getting Helm installed and configured, we added
    a chart repository and learned how to search for charts. Then we installed, listed,
    upgraded, and finally uninstalled the `bitnami/drupal` chart.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了安装和使用 Helm 的基础知识。在探讨了流行的 Helm 安装和配置方法之后，我们添加了一个图表仓库，并学习了如何搜索图表。然后，我们安装了、列出了、升级了，并最终卸载了`bitnami/drupal`图表。
- en: Along the way, we picked up some important concepts. We learned about installations
    and releases. We took a first look at chart repositories, which will be covered
    at length in [Chapter 7](ch07.xhtml#chart_repositories). And at the end of the
    chapter we learned a little about how Helm stores information about our installations.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们掌握了一些重要的概念。我们学习了安装和发布。我们初步了解了图表仓库，在[第7章](ch07.xhtml#chart_repositories)中将详细介绍。在本章的结尾，我们稍微了解了
    Helm 如何存储关于我们安装的信息。
- en: In the next chapter, we will return to the `helm` command, learning about other
    things that the Helm tool can do.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾`helm`命令，学习 Helm 工具的其他功能。
