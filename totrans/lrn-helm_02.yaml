- en: Chapter 2\. Using Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm provides a command-line tool, named `helm`, that makes available all the
    features necessary for working with Helm charts. In this chapter, we will discover
    the primary features of the `helm` client. Along the way, we’ll learn how Helm
    interacts with Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by looking at how to install and configure Helm, and work our
    way through the main command groups in Helm. Then we will cover finding and learning
    about packages, and how to install, upgrade, and delete them.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Configuring the Helm Client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm provides a single command-line client that is capable of performing all
    of the main Helm tasks. This client is, appropriately enough, named `helm`. While
    there are many other tools that can work with Helm charts, this one is the official
    general-purpose tool maintained by the Helm core maintainers, and it is the subject
    of this chapter as well as the next.
  prefs: []
  type: TYPE_NORMAL
- en: The `helm` client is written in a programming language called Go. Unlike Python,
    JavaScript, or Ruby, Go is a compiled language. Once a Go program is compiled,
    you do not need any of the Go tools to run or otherwise work with the binary.
  prefs: []
  type: TYPE_NORMAL
- en: So we will first cover downloading and installing the static binary, and then
    we will briefly introduce the process for fetching and compiling from the Go source
    code, should you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Prebuilt Binary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time the Helm maintainers issue a new release of `helm`, the project provides
    new signed binary builds of `helm` for a number of common operating systems and
    architectures. At the time of this writing, prebuilt versions of Helm are available
    for Linux, Windows, and macOS on architectures ranging from 64-bit Intel/AMD to
    ARM, to s390 and PPC. This means you can run Helm on anything from a Raspberry
    Pi to a supercomputer.
  prefs: []
  type: TYPE_NORMAL
- en: The definitive list of Helm releases is at [the Helm release page](https://oreil.ly/L_My5).
    The release page will show a chronological list of releases, with the latest release
    at the top.
  prefs: []
  type: TYPE_NORMAL
- en: A note on Helm version numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Until November 2020, two different major versions of Helm were actively maintained.
    The current stable major version of Helm is version 3\. When you visit the Helm
    download pages, you may see both versions available for download. Because the
    versions are chronologically listed, it is even possible that a Helm 2 release
    will be newer than the latest Helm 3 release. You should use Helm 3.
  prefs: []
  type: TYPE_NORMAL
- en: Helm follows a versioning convention known as [Semantic Versioning](https://semver.org)
    (SemVer). In Semantic Versioning, the version number conveys meaning about what
    you can expect in the release. Because Helm follows this specification, users
    can expect certain things out of releases simply by carefully reading the version
    number.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, a semantic version has three numerical components and an optional
    *stability marker* (for alphas, betas, and release candidates). Here are some
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`v1.0.0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v3.3.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`v2.4.22-alpha.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s talk about the numerical components first.
  prefs: []
  type: TYPE_NORMAL
- en: 'We often generalize this format to talk about `X.Y.Z`, where `X` is a *major
    version*, `Y` is a *minor version* and `Z` is a *patch release*:'
  prefs: []
  type: TYPE_NORMAL
- en: The major release number tends to be incremented infrequently. It indicates
    that major changes have been made to Helm, and that some of those changes may
    break compatibility with previous versions. The difference between Helm 2 and
    Helm 3 is substantial, and there is work necessary to migrate between the versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The minor release number indicates feature additions. The difference between
    3.2.0 and 3.3.0 might be that a few small new features were added. However, there
    are no *breaking changes* between versions. (With one caveat: a security fix might
    necessitate a breaking change, but we announce boldly when that is the case.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The patch release number indicates that *only* backward compatible bug fixes
    have been made between this release and the last one. It is always recommended
    to stay at the latest patch release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you see a release with a stability marker, like `alpha.1`, `beta.4`, or
    `rc.2`, appended to the release number, that means the release is considered to
    be a pre-release, and is not ready for mainstream production usage. In particular,
    Helm frequently issues *release candidates* before a major or minor update. These
    give the community a chance to give us some feedback on stability, compatibility,
    and new features before we issue a final release.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, we are ready to proceed with the actual installation.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the binary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way to install Helm from the repository is to simply go to the [releases
    page](https://oreil.ly/L_My5) and download the latest Helm 3 version.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, the download file is a ZIP archive containing a *README.md* text
    file, a *LICENSE* text file, and *helm.exe*.
  prefs: []
  type: TYPE_NORMAL
- en: On macOS and Linux, the download will be in a gzipped tar archive (`.tar.gz`)
    that can be extracted with the `tar -zxf` command. Like the Windows version, it
    will contain a *README.md* text file, a *LICENSE* text file, and the `helm` binary.
    If you are using Windows Subsystem for Linux (WSL), you should install the Linux
    AMD64 version into your WSL instance.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which operating system you use, the binary is the only file you
    need to run Helm, and you can put it wherever you prefer on your system. It should
    be pre-marked as an executable, but on rare occasions in UNIX-like environments,
    you may also need to run the command `chmod helm +x` to set Helm to be an executable.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When installing with package managers like Homebrew (macOS), Snap (Linux), or
    Chocolatey (Windows), `helm` will be installed in a standard location and be made
    immediately available to you via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have `helm` installed, you should be able to run the command `helm
    help` and see the Helm help text.
  prefs: []
  type: TYPE_NORMAL
- en: Using the get script to install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On macOS and Linux, you may prefer to run a shell script that will determine
    which version of Helm to install and do it automatically for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The usual sequence of commands for installing this way is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands fetch the latest version of the `get_helm.sh` script,
    and then use that to find and install the latest version of Helm 3.
  prefs: []
  type: TYPE_NORMAL
- en: For systems that automatically install Helm, such as continuous integration
    (CI) systems, we recommend using this method if it is important to always have
    the latest Helm version.
  prefs: []
  type: TYPE_NORMAL
- en: Guidance on Building from Source
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unless you are already familiar with Go development, building Helm from source
    can be a daunting task. You will need a version of the `make` command. Because
    `Makefile`-style build scripts do not follow a single standard, not all versions
    of `make` will work to build Helm. Gnu Make, the one most frequently used on Linux
    and Mac, is the one most Helm core developers use, so it is a safe bet. You will
    also need the `gcc` compiler and the entire Go toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these, Helm needs several auxilliary tools. Fortunately, when
    you run `make` the first time, it will attempt to install any additional tools
    that are missing.
  prefs: []
  type: TYPE_NORMAL
- en: While they are not strictly necessary, you will probably also want the `git`
    tool and the `kubectl` command. The `git` tool will allow you to work directly
    with the Helm source code repository instead of downloading source code bundles.
    `kubectl`, of course, is for interacting with your Kubernetes cluster. While that’s
    not necessary for *building* Helm, it’s certainly necessary when checking to see
    whether Helm is doing what you want it to do.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the tools installed and configured, you can simply change directories
    in the folder that contains Helm’s source code (the directory with the *README.md*
    and Makefile files) and run `make build`. The first time you run this command,
    it will take at least several minutes. The build system must fetch lots of dependencies,
    including much of the Kubernetes source code, and compile it all.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Compiling Helm for the first time can be daunting, especially if you are new
    to the Go programming language. Kubernetes is a sophisticated platform, and thus
    the Helm source code is large and difficult to build. Plan on spending at least
    an hour or two to get a fresh environment prepared to install Helm.
  prefs: []
  type: TYPE_NORMAL
- en: To verify that Helm is functioning correctly (especially if you have modified
    the source code), you can run `make test`. This will build the code, run a variety
    of checkers and linters, and then run the unit tests for Helm. If you plan on
    contributing any changes to Helm, this command *must* pass before Helm’s core
    maintainers will even look at your requested change.
  prefs: []
  type: TYPE_NORMAL
- en: When Helm is compiled, it will be located alongside the source code in a subdirectory
    called *bin/*. It will not automatically be added to your executable path, so
    to execute the version you just built, you may need to specify the relative or
    exact path (e.g., *./bin/helm* or *$GOPATH/src/helm.sh/helm/bin/helm*).
  prefs: []
  type: TYPE_NORMAL
- en: If the command `helm version` correctly executes, you can be assured that you
    correctly compiled Helm.
  prefs: []
  type: TYPE_NORMAL
- en: From here, you can follow the detailed [Developer Guide](https://oreil.ly/X9-Ii)
    to learn more. As always, if you run into problems, the `helm-users` channel on
    the Kubernetes Slack server is a great place to ask for help.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Kubernetes Clusters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm interacts directly with the Kubernetes API server. For that reason, Helm
    needs to be able to connect to a Kubernetes cluster. Helm attempts to do this
    automatically by reading the same configuration files used by `kubectl` (the main
    Kubernetes command-line client).
  prefs: []
  type: TYPE_NORMAL
- en: Helm will try to find this information by reading the environment variable *$KUBECONFIG*.
    If that is not set, it will look in the same default locations that `kubectl`
    looks in (for example, *$HOME/.kube/config* on UNIX, Linux, and macOS).
  prefs: []
  type: TYPE_NORMAL
- en: You can also override these settings with environment variables (`HELM_KUBECONTEXT`)
    and command-line flags (`--kube-context`). You can see a list of environment variables
    and flags by running `helm help`.
  prefs: []
  type: TYPE_NORMAL
- en: The Helm maintainers recommend using `kubectl` to manage your Kubernetes credentials
    and letting Helm merely autodetect these settings. If you have not yet installed
    `kubectl`, the best place to start is with the [official Kubernetes installation
    documentation](https://oreil.ly/pHZIh).
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started with Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whether you built Helm from source or installed using one of the aforementioned
    methods, at this point you should have the `helm` command available on your system.
    From here on, we will assume that Helm can be executed with the command `helm`
    (as opposed to a full or relative path, as discussed in the previous section).
  prefs: []
  type: TYPE_NORMAL
- en: 'In what follows, we are going to take a look at the most common workflow for
    starting out with Helm:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a chart repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a chart to install.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install a Helm chart.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the list of what is installed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upgrade your installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the installation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in the next chapter we will dive into some of the additional features
    of Helm and in so doing learn more about how Helm works.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Chart Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chart repositories are a topic in their own right, and in [Chapter 7](ch07.xhtml#chart_repositories)
    we will examine them in detail. But anyone using Helm must know a few basics about
    chart repositories.
  prefs: []
  type: TYPE_NORMAL
- en: A Helm chart is an *individual package* that can be installed into your Kubernetes
    cluster. During chart development, you will often just work with a chart that
    is stored on your local filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: But when it comes to sharing charts, Helm describes a standard format for indexing
    and sharing information about Helm charts. A Helm *chart repository* is simply
    a set of files, reachable over the network, that conforms to the Helm specification
    for indexing packages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Helm 3 introduced an experimental feature for storing Helm charts in a different
    kind of repository: Open Container Initiative (OCI) registries (sometimes called
    Docker registries). In this backend, a Helm chart can be stored alongside Docker
    images. While this feature is not yet broadly supported, it may become the future
    of Helm package storage. This is discussed more in [Chapter 7](ch07.xhtml#chart_repositories).'
  prefs: []
  type: TYPE_NORMAL
- en: There are many—perhaps thousands of—chart repositories on the internet. The
    easiest way to find the popular repositories is to use your web browser to navigate
    to [the Artifact Hub](https://artifacthub.io). There you will find thousands of
    Helm charts, each hosted on an appropriate repository.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we will install the popular [Drupal content management system](https://www.drupal.org).
    This makes a good example chart because it exercises many of Kubernetes’ types,
    including `Deployment`s, `Service`s, `Ingress`, and `ConfigMap`s.
  prefs: []
  type: TYPE_NORMAL
- en: Helm 2 came with a Helm repository installed by default. The `stable` chart
    repository was at one time the official source of production-ready Helm charts.
    But we realized that centralizing the charts into one repository was overly taxing
    to a small group of maintainers and frustrating for chart contributors.
  prefs: []
  type: TYPE_NORMAL
- en: In Helm 3, there is no default repository. Users are encouraged to use the Artifact
    Hub to find what they are looking for and then add their preferred repositories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Drupal’s Helm chart is located in one of the most well-curated chart repositories
    available: Bitnami’s official Helm charts. You can take a look at the Artifact
    Hub’s [entry for the Drupal chart](https://oreil.ly/baxxf) for more information.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A handful of Bitnami developers were among the core contributors who designed
    the Helm repository system. They have contributed to the establishment of Helm’s
    best practices for chart development and have written many of the most widely
    used charts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a Helm chart is done with the `helm repo add` command. Several Helm
    repository commands are grouped under the `helm repo` command group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `helm repo add` command will add a repository named `bitnami` that points
    to the URL *[*https://charts.bitnami.com/bitnami*](https://charts.bitnami.com/bitnami)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can verify that the Bitnami repository exists by running a second `repo`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This command shows us all of the repositories installed for Helm. Right now,
    we see only the Bitnami repository that we just added.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have added a repository, its index will be locally cached until we next
    update it (see [Chapter 7](ch07.xhtml#chart_repositories)). And one important
    thing that we can now do is search the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Searching a Chart Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we know, having looked at the Artifact Hub, that the Drupal chart exists
    in this repository, it is still useful to search for it from the command line.
    Oftentimes, searching is a useful way to find not only what charts can be installed,
    but what versions are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let’s search for the Drupal chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We did a simple search for the term *drupal*. Helm will search not just the
    package names, but also other fields like labels and descriptions. Thus, we could
    search for *content* and see Drupal listed there because it is a content management
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: While Drupal is the first result, note that there are a variety of other charts
    that contain the word *content* somewhere in the descriptive text.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Helm tries to install the latest stable release of a chart, but
    you can override this behavior and install a specific verison of a chart. Thus
    it is often useful to see not just the summary info for a chart, but exactly which
    versions exist for a chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are several dozen versions of the Drupal chart. The preceding example
    has been truncated to just show the top few versions.
  prefs: []
  type: TYPE_NORMAL
- en: Chart and App Versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *chart version* is the version of the Helm chart. The *app version* is the
    version of the application packaged in the chart. Helm uses the chart version
    to make versioning decisions, such as which package is newest. As we can see in
    the preceding example, multiple chart versions may contain the same app version.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we will dive deeply into the details of how package installation
    works in Helm. In this section, though, we will look at the basic mechanics of
    installing a Helm chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'At very minimum, installing a chart in Helm requires just two pieces of information:
    the name of the installation and the chart you want to install.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall that in the previous chapter we distinguished between an *installation*
    and a *chart*. This is an important distinction during installation and upgrading.
    In an operating system package manager, we may request that it install a piece
    of software. But it is extremely rare that we need to install the same exact package
    multiple times on an operating system. A Kubernetes cluster is different. It makes
    complete sense in Kubernetes to say “I want to install a MySQL database for Application
    A, and a second MySQL database for Application B.” Even if the two databases are
    exactly the same version and have the same configuration, in order to appropriately
    manage our applications, we may desire to have two instances running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, Helm needs a way to distinguish between the different instances
    of the same chart. So an *installation* of a chart is a specific instance of the
    chart. One chart may have many installations. When we run the `helm install` command,
    we need to give it an installation name as well as the chart name. So the most
    basic installation command looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding will create an instance of the `bitnami/drupal` chart, and will
    name this instance `mysite`.
  prefs: []
  type: TYPE_NORMAL
- en: As the install command runs, it will return a considerable amount of information,
    including user-facing instructions about getting started with Drupal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In future examples of `helm install`, we will omit the returned output for the
    sake of brevity. However, when using Helm, you will see that output for each installation.
    In the next chapter, we will also see how to view that output again with the `helm
    get` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, there is now an instance named `mysite` in the cluster. If we
    tried to rerun the preceding command, we wouldn’t get a second instance. Instead,
    we would get an error because the name `mysite` has already been used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One further clarification is in order. In Helm 2, instance names were cluster-wide.
    You could only have an instance named `mysite` once *per cluster*. In Helm 3,
    naming has been changed. Now instance names are scoped to Kubernetes namespaces.
    We could install two instances named `mysite` as long as they each lived in a
    different namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is perfectly legal in Helm 3, though it would have
    generated a fatal error in Helm 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will install one Drupal site named `mysite` in the `first` namespace, and
    an identically configured instance named `mysite` in the `second` namespace. This
    might seem confusing at first, but it becomes clearer when we think about a namespace
    as a *prefix on a name*. In that sense, we have a site named “first mysite” and
    another named “second mysite.”
  prefs: []
  type: TYPE_NORMAL
- en: Using Namespace Flags Throughout Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with namespaces and Helm, you can use the `--namespace` or `-n`
    flags to specify the namespace you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration at Installation Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding examples, we installed the same chart a few different ways.
    In all cases, they are identically configured. While the default configuration
    is good sometimes, more often we want to pass our own configuration to the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Many charts will allow you to provide configuration values. If we take a look
    at the [Artifact Hub page for Drupal](https://oreil.ly/baxxf), we would see a
    long list of configurable parameters. For example, we can configure the username
    of the Drupal admin account by setting the `drupalUsername` value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the next chapter we will learn how to get this information using the `helm`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways of telling Helm which values you want to be configured.
    The best way is to create a YAML file with all of the configuration overrides.
    For example, we can create a file that sets values for `drupalUsername` and `drupalEmail`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a file (conventionally named *values.yaml*) that has all of our
    configuration. Since it is in a file, it is easy to reproduce the same installation.
    You can also check this file into a version control system to track changes to
    your values over time. The Helm core maintainers consider it a good practice to
    keep your configuration values in a YAML file. It is important to keep in mind,
    though, that if a configuration file has sensitive information (like a password
    or authentication token), you should take steps to ensure that this information
    is not leaked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both `helm install` and `helm upgrade` provide a `--values` flag that points
    to a YAML file with value overrides:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the preceding output the `Username` is now `admin` instead of
    `user`. One nice feature of Helm is that even the help text can be updated using
    values you provide.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can specify the `--values` flag multiple times. Some people use this feature
    to have “common” overrides in one file and specific overrides in another.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a second flag that can be used to add individual parameters to an
    install or upgrade. The `--set` flag takes one or more values directly. They do
    not need to be stored in a YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This sets just one parameter, `drupalUsername`. This flag uses a simple `key=value`
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration parameters can be structured. That is, a configuration file may
    have multiple sections. The Drupal chart, for example, has configuration specific
    to the MariaDB database. These parameters are all grouped into a `mariadb` section.
    Building on our previous example, we could override the MariaDB database name
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsections are a little more complicated when using the `--set` flag. You
    will need to use a dotted notation: `--set mariadb.db.name=my-database`. This
    can get verbose when setting multiple values.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, Helm core maintainers suggest storing configuration in *values.yaml*
    files (note that the filename does not need to be “values”), only using `--set`
    when absolutely necessary. This way, you have easy access to the values you used
    during an operation (and can track those over time), while also keeping your Helm
    commands short. Working with files also means you do not have to escape as many
    characters as you do when setting things on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on to upgrades, though, we will take a quick look at one of the
    most helpful Helm commands.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Your Installations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, Helm can install many things into the same cluster—even
    multiple instances of the same chart. And with multiple users on your cluster,
    different people may be installing things into the same namespace on a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `helm list` command is a simple tool to help you see installations and
    learn about those installations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command will provide you with lots of useful information, including the
    name and namespace of the release, the current revision number (discussed in [Chapter 1](ch01.xhtml#introducing_helm),
    and in more depth in the next section), the last time it was updated, the installation
    status, and the versions of the chart and app.
  prefs: []
  type: TYPE_NORMAL
- en: Like other commands, `helm list` is namespace aware. By default, Helm uses the
    namespace your Kubernetes configuration file sets as the default. Usually this
    is the namespace named `default`. Earlier, we installed a Drupal instance into
    the namespace `first`. We can see that with `helm list --namespace first`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When listing all of your releases, one useful flag is the `--all-namespaces`
    flag, which will query all of the Kubernetes namespaces to which you have permission,
    and return all of the releases it finds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Upgrading an Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about upgrading in Helm, we talk about upgrading an installation,
    not a chart. An *installation* is a particular instance of a chart in your cluster.
    When you run `helm install`, it creates the installation. To modify that installation,
    use `helm upgrade`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an important distinction to make in the present context because upgrading
    an installation can consist of two different kinds of changes:'
  prefs: []
  type: TYPE_NORMAL
- en: You can upgrade the *version of the chart*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can upgrade the *configuration* of the installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two are not mutually exclusive; you can do both at the same time. But this
    does introduce one new term that Helm users refer to when talking about their
    systems: a *release* is a particular combination of configuration and chart version
    for an installation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first install a chart, we create the initial release of an installation.
    Let’s call this release 1\. When we perform an upgrade, we are creating a new
    *release* of the same *installation*: release 2\. When we upgrade again, we will
    create release 3\. (In the next chapter, we’ll see how rollbacks also create releases.)'
  prefs: []
  type: TYPE_NORMAL
- en: During an upgrade, then, we can create a release with new configuration, with
    a new chart version, or with both.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say we install the Drupal chart with the `ingress` turned off.
    (This will effectively prevent traffic from being routed from outside the cluster
    into the Drupal instance.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are using the `--set` flag to keep examples compact, but would
    recommend using a *values.yaml* file in regular scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With `ingress` turned off, we can work on getting our site all set up to our
    liking. Then when we are ready, we can create a new release that enables the `ingress`
    feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we are running an `upgrade` that will only change the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: In the background, Helm will load the chart, generate all of the Kubernetes
    objects in that chart, and then see how those differ from the version of the chart
    that is already installed. It will only send Kubernetes the things that need to
    change. In other words, Helm will attempt to alter only the bare minimum.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example will only change the `ingress` configuration. Nothing
    changes with the database, or even with the web server running Drupal. For that
    reason, nothing will be restarted or deleted and re-created. This can occasionally
    confuse new Helm users, but it is by design. The Kubernetes philosophy is to make
    changes in the most streamlined way possible, and Helm seeks to follow this philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: On occasion, you may want to force one of your services to restart. This is
    not something you need to use Helm for. You can simply use `kubectl` itself to
    restart things. With an operating system’s package manager, you do not use the
    package manager to restart a program. Likewise, you don’t need to use Helm to
    restart your web server or database.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new version of a chart comes out, you may want to upgrade your existing
    installation to use the new chart version. For the most part, Helm tries to make
    this easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_using_helm_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the latest packages from chart repositories.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_using_helm_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade the `mysite` release to use the latest version of `bitnami/drupal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the default policy of Helm is to attempt to use the latest
    version of a chart. If you would prefer to stay on a particular version of a chart,
    you can explicitly declare this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this case, even if a newer version is released, only `bitnaim/drupal` version
    `6.2.22` will be installed.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Values and Upgrades
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most important things to learn about Helm installs and upgrades
    is that configuration gets applied freshly on each release. Here’s a quick illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_using_helm_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Install using a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_using_helm_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade without a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: What is the result of this pair of operations? The installation will use all
    of the configuration data supplied in *values.yaml*, but the upgrade will not.
    As a result, some settings could be changed back to their defaults. This is usually
    not what you want.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter we will look at the `helm get` command. You can use `helm
    get values mysite` to see what values were used on the last `helm install` or
    `helm upgrade` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm core maintainers suggest that you provide consistent configuration with
    each installation and upgrade. To apply the same configuration to both releases,
    supply the values on each operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_using_helm_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Install using a configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_using_helm_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Upgrade using the same configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons we suggest storing configuration in a *values.yaml* file
    is so that this pattern is easy to reproduce. Imagine how much more cumbersome
    these commands would be if you used `--set` to set three or four configuration
    parameters! For each release, you’d have to remember exactly which things to set.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we strongly advise using the pattern discussed here, and specifying `--values`
    each time, there is an upgrade shortcut available that will just reuse the last
    set of values that you sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `--reuse-values` flag will tell Helm to reload the server-side copy of the
    last set of values, and then use those to generate the upgrade. This method is
    okay if you are always *just* reusing the same values. However, the Helm maintainers
    strongly suggest not trying to mix `--reuse-values` with additional `--set` or
    `--values` options. Doing so can make troubleshooting complicated and can quickly
    lead to unmaintainable installations in which nobody is sure how certain configuration
    parameters were set. While Helm does retain some state information, it is not
    a configuration management tool. Users are advised to manage configuration using
    their own tools and explicitly pass that configuration to Helm in each invocation.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we’ve learned how to install, list, and upgrade installations.
    In the final section of this chapter, we will delete an installation.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstalling an Installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To remove a Helm installation, use the `helm uninstall` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that this command does not need a chart name (`bitnami/drupal`) or any
    configuration files. It simply needs the name of the installation. In this section,
    we will look at how deletion works and take a brief detour into a big change between
    Helm 2 and Helm 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `install`, `list`, and `upgrade`, you can supply a `--namespace` flag
    to specify that you want to delete an installation *from a specific namespace*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding will delete the site we created in the `first` namespace earlier
    in this chapter. Note that there is no command to delete multiple applications.
    You must uninstall a *specific* installation.
  prefs: []
  type: TYPE_NORMAL
- en: Deletion can take time. Larger applications may take several minutes, or even
    longer, as Kubernetes cleans up all of the resources. During this time, you will
    not be able to reinstall using the same name.
  prefs: []
  type: TYPE_NORMAL
- en: How Helm Stores Release Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the big changes in Helm 3 is how it deletes Helm’s own data about an
    installation. This section briefly describes how installations are tracked and
    then concludes by explaining how and why Helm changed between version 2 and version
    3.
  prefs: []
  type: TYPE_NORMAL
- en: When we first install a chart with Helm (such as with `helm install mysite bitnami/drupal`),
    we create the Drupal application instance, and we also create a special record
    that contains release information. By default, Helm stores these records as Kubernetes
    `Secret`s (though there are other supported storage backends).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see these records with `kubectl get secret`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We can see multiple release records at the bottom, one for each revision. As
    you can see, we have created four revisions of `mysite` by running `install` and
    `upgrade` operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how these extended records can be used to roll
    back to previous revisions of an installation. But we point this out now to illustrate
    something about how `helm uninstall` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run the command `helm uninstall mysite`, it will load the latest release
    record for the `mysite` installation. From that record, it will assemble a list
    of objects that it should remove from Kubernetes. Then Helm will delete all of
    those things before returning and deleting the four release records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `helm list` command will no longer show `mysite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have no installations. And if we rerun the `kubectl get secrets` command,
    we will also see all records of `mysite` have been purged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from this output, not only were the two `Secret`s created by the
    Drupal chart deleted, but the four release records were deleted as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will see the `helm rollback` command. The preceding
    explanation should give you some hints as to why, by default, you cannot roll
    back an uninstall. It is possible, though, to delete the application, but keep
    the release records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In Helm 2, history was retained by default. In Helm 3, the default was changed
    to deleting history. Different organizations prefer different policies, but core
    maintainers found that when most people uninstalled, they expected all traces
    of the installation to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of installing and then using Helm. After
    looking at popular methods of getting Helm installed and configured, we added
    a chart repository and learned how to search for charts. Then we installed, listed,
    upgraded, and finally uninstalled the `bitnami/drupal` chart.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we picked up some important concepts. We learned about installations
    and releases. We took a first look at chart repositories, which will be covered
    at length in [Chapter 7](ch07.xhtml#chart_repositories). And at the end of the
    chapter we learned a little about how Helm stores information about our installations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will return to the `helm` command, learning about other
    things that the Helm tool can do.
  prefs: []
  type: TYPE_NORMAL
